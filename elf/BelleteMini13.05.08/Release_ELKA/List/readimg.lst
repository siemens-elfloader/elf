##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    06/Oct/2008  21:45:51 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\Pasha\elf\BelleteMini13.05.08\readimg.c           #
#    Command line    =  D:\Pasha\elf\BelleteMini13.05.08\readimg.c -D        #
#                       NEWSGOLD -D ELKA -lC D:\Pasha\elf\BelleteMini13.05.0 #
#                       8\Release_ELKA\List\ -o D:\Pasha\elf\BelleteMini13.0 #
#                       5.08\Release_ELKA\Obj\ -s9 --no_unroll --no_inline   #
#                       --cpu_mode arm --endian little --cpu ARM926EJ-S      #
#                       --stack_align 4 --interwork -e --fpu None            #
#                       --dlib_config "D:\Pasha\Embedded Workbench 4.0       #
#                       Evaluation2\ARM\LIB\dl5tpainl8n.h" -I                #
#                       "D:\Pasha\Embedded Workbench 4.0                     #
#                       Evaluation2\ARM\INC\"                                #
#    List file       =  D:\Pasha\elf\BelleteMini13.05.08\Release_ELKA\List\r #
#                       eadimg.lst                                           #
#    Object file     =  D:\Pasha\elf\BelleteMini13.05.08\Release_ELKA\Obj\re #
#                       adimg.r79                                            #
#                                                                            #
#                                                                            #
##############################################################################

D:\Pasha\elf\BelleteMini13.05.08\readimg.c
      1          
      2          #ifndef _SWILIB_H_
      3          #include "..\inc\swilib.h"
      4          #define _SWILIB_H_
      5          #endif
      6          
      7          #include "jpeglib/jpeglib.h"
      8          #include "jpeglib/jerror.h"
      9          #include "readimg.h"
     10          
     11          
     12          #define PNG_BYTES_TO_CHECK 8
     13          
     14          typedef struct {
     15            const char *p;
     16            char *row;
     17            char *img;
     18            IMGHDR * img_h;
     19          }PP;
     20          

   \                                 In segment CODE, align 4, keep-with-next
     21          void *xmalloc(int x,int n)
     22          {
   \                     xmalloc:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   0100A0E1           MOV      R0,R1
     23            return malloc(n);
   \   00000008   140000EF           SWI      +20
   \   0000000C   0080BDE8           POP      {PC}             ;; return
     24          }
     25          

   \                                 In segment CODE, align 4, keep-with-next
     26          void xmfree(int x,void* ptr)
     27          {
   \                     xmfree:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   0100A0E1           MOV      R0,R1
     28            mfree(ptr);
   \   00000008   150000EF           SWI      +21
     29          }
   \   0000000C   0080BDE8           POP      {PC}             ;; return
     30          

   \                                 In segment CODE, align 4, keep-with-next
     31          void read_data_fn(png_structp png_ptr, png_bytep data, png_size_t length)
     32          {
   \                     read_data_fn:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   \   00000008   0250A0E1           MOV      R5,R2
     33            PP *pp=png_get_io_ptr(png_ptr);
   \   0000000C   5E0100EF           SWI      +350
   \   00000010   0060A0E1           MOV      R6,R0
     34            memcpy(data,pp->p,length);
   \   00000014   001096E5           LDR      R1,[R6, #+0]
   \   00000018   0520A0E1           MOV      R2,R5
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   1E0100EF           SWI      +286
     35            pp->p+=length;
   \   00000024   000096E5           LDR      R0,[R6, #+0]
   \   00000028   000085E0           ADD      R0,R5,R0
   \   0000002C   000086E5           STR      R0,[R6, #+0]
     36          }
   \   00000030   7080BDE8           POP      {R4-R6,PC}       ;; return
     37          
     38          

   \                                 In segment CODE, align 4, keep-with-next
     39          IMGHDR *read_pngimg(const char *buf)
     40          {
   \                     read_pngimg:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   28D04DE2           SUB      SP,SP,#+40
     41            PP pp;
     42            IMGHDR * img_hc;
     43            png_structp png_ptr=NULL;
   \   00000008   0040A0E3           MOV      R4,#+0
   \   0000000C   00408DE5           STR      R4,[SP, #+0]
     44            png_infop info_ptr=NULL;
   \   00000010   04408DE5           STR      R4,[SP, #+4]
     45            png_uint_32 rowbytes;
     46            
     47            pp.p=buf;
   \   00000014   08008DE5           STR      R0,[SP, #+8]
     48            pp.row=NULL;
   \   00000018   0C408DE5           STR      R4,[SP, #+12]
     49            pp.img=NULL;
   \   0000001C   10408DE5           STR      R4,[SP, #+16]
     50            pp.img_h=NULL;  
   \   00000020   14408DE5           STR      R4,[SP, #+20]
     51            
     52            if  (!png_check_sig((png_bytep)pp.p,PNG_BYTES_TO_CHECK)) return 0; // не пнг
   \   00000024   0810A0E3           MOV      R1,#+8
   \   00000028   B20100EF           SWI      +434
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   BA00000A           BEQ      ??read_pngimg_0
     53            pp.p+=PNG_BYTES_TO_CHECK;
   \   00000034   08109DE5           LDR      R1,[SP, #+8]
     54            
     55            png_ptr = png_create_read_struct_2("1.2.5", (png_voidp)0, 0, 0, (png_voidp)0,(png_malloc_ptr)xmalloc,(png_free_ptr)xmfree);
   \   00000038   E8029FE5           LDR      R0,??read_pngimg_1  ;; xmfree
   \   0000003C   081081E2           ADD      R1,R1,#+8
   \   00000040   08108DE5           STR      R1,[SP, #+8]
   \   00000044   01002DE9           PUSH     {R0}
   \   00000048   DC029FE5           LDR      R0,??read_pngimg_1+0x4  ;; xmalloc
   \   0000004C   01002DE9           PUSH     {R0}
   \   00000050   0000A0E3           MOV      R0,#+0
   \   00000054   01002DE9           PUSH     {R0}
   \   00000058   0030A0E1           MOV      R3,R0
   \   0000005C   0020A0E1           MOV      R2,R0
   \   00000060   0010A0E1           MOV      R1,R0
   \   00000064   C4029FE5           LDR      R0,??read_pngimg_1+0x8  ;; `?<Constant "1.2.5">`
   \   00000068   A80100EF           SWI      +424
   \   0000006C   0C008DE5           STR      R0,[SP, #+12]
     56            if (!png_ptr) goto L_CLOSE_FILE;
   \   00000070   000050E3           CMP      R0,#+0
   \   00000074   0CD08DE2           ADD      SP,SP,#+12
   \   00000078   7900000A           BEQ      ??read_pngimg_2
     57            
     58            info_ptr = png_create_info_struct(png_ptr);
   \   0000007C   560100EF           SWI      +342
   \   00000080   04008DE5           STR      R0,[SP, #+4]
     59            if (!info_ptr)
   \   00000084   000050E3           CMP      R0,#+0
   \   00000088   0400001A           BNE      ??read_pngimg_3
     60            {
     61              png_destroy_read_struct(&png_ptr, (png_infopp)NULL, (png_infopp)NULL);
   \   0000008C   0020A0E3           MOV      R2,#+0
   \   00000090   0210A0E1           MOV      R1,R2
   \                     ??read_pngimg_4:
   \   00000094   0D00A0E1           MOV      R0,SP
   \   00000098   570100EF           SWI      +343
     62              goto L_CLOSE_FILE;
   \   0000009C   700000EA           B        ??read_pngimg_2
     63            }
     64            
     65            if (setjmp(png_jmpbuf(png_ptr)))
   \                     ??read_pngimg_3:
   \   000000A0   00009DE5           LDR      R0,[SP, #+0]
   \   000000A4   620100EF           SWI      +354
   \   000000A8   000050E3           CMP      R0,#+0
     66            {
     67              png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
   \   000000AC   0020A013           MOVNE    R2,#+0
   \   000000B0   04108D12           ADDNE    R1,SP,#+4
   \   000000B4   F6FFFF1A           BNE      ??read_pngimg_4
     68              goto L_CLOSE_FILE;
     69            }
     70            
     71            png_set_read_fn(png_ptr, &pp, read_data_fn);
   \   000000B8   74229FE5           LDR      R2,??read_pngimg_1+0xC  ;; read_data_fn
   \   000000BC   00009DE5           LDR      R0,[SP, #+0]
   \   000000C0   08108DE2           ADD      R1,SP,#+8
   \   000000C4   A90100EF           SWI      +425
     72            
     73            png_set_sig_bytes(png_ptr, PNG_BYTES_TO_CHECK);
   \   000000C8   00009DE5           LDR      R0,[SP, #+0]
   \   000000CC   0810A0E3           MOV      R1,#+8
   \   000000D0   580100EF           SWI      +344
     74            png_read_info(png_ptr, info_ptr);
   \   000000D4   04109DE5           LDR      R1,[SP, #+4]
   \   000000D8   00009DE5           LDR      R0,[SP, #+0]
   \   000000DC   590100EF           SWI      +345
     75            
     76            png_uint_32 width, height;
     77            int bit_depth, color_type;
     78            
     79            png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type, 0, 0, 0);
   \   000000E0   0000A0E3           MOV      R0,#+0
   \   000000E4   01002DE9           PUSH     {R0}
   \   000000E8   01002DE9           PUSH     {R0}
   \   000000EC   01002DE9           PUSH     {R0}
   \   000000F0   30008DE2           ADD      R0,SP,#+48
   \   000000F4   01002DE9           PUSH     {R0}
   \   000000F8   30008DE2           ADD      R0,SP,#+48
   \   000000FC   01002DE9           PUSH     {R0}
   \   00000100   18109DE5           LDR      R1,[SP, #+24]
   \   00000104   30308DE2           ADD      R3,SP,#+48
   \   00000108   14009DE5           LDR      R0,[SP, #+20]
   \   0000010C   2C208DE2           ADD      R2,SP,#+44
   \   00000110   5A0100EF           SWI      +346
     80            
     81            if (bit_depth < 8) png_set_gray_1_2_4_to_8(png_ptr);
   \   00000114   34009DE5           LDR      R0,[SP, #+52]
   \   00000118   14D08DE2           ADD      SP,SP,#+20
   \   0000011C   080050E3           CMP      R0,#+8
   \   00000120   010000AA           BGE      ??read_pngimg_5
   \   00000124   00009DE5           LDR      R0,[SP, #+0]
   \   00000128   D60100EF           SWI      +470
     82              
     83            if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))
   \                     ??read_pngimg_5:
   \   0000012C   00009DE5           LDR      R0,[SP, #+0]
   \   00000130   04109DE5           LDR      R1,[SP, #+4]
   \   00000134   1020A0E3           MOV      R2,#+16
   \   00000138   AC0100EF           SWI      +428
   \   0000013C   000050E3           CMP      R0,#+0
   \   00000140   0100000A           BEQ      ??read_pngimg_6
     84              png_set_tRNS_to_alpha(png_ptr); 
   \   00000144   00009DE5           LDR      R0,[SP, #+0]
   \   00000148   AD0100EF           SWI      +429
     85            
     86            if (bit_depth == 16) png_set_strip_16(png_ptr);
   \                     ??read_pngimg_6:
   \   0000014C   20009DE5           LDR      R0,[SP, #+32]
   \   00000150   100050E3           CMP      R0,#+16
   \   00000154   0100001A           BNE      ??read_pngimg_7
   \   00000158   00009DE5           LDR      R0,[SP, #+0]
   \   0000015C   AF0100EF           SWI      +431
     87            
     88            if (bit_depth < 8) png_set_packing(png_ptr);
   \                     ??read_pngimg_7:
   \   00000160   20009DE5           LDR      R0,[SP, #+32]
   \   00000164   080050E3           CMP      R0,#+8
   \   00000168   010000AA           BGE      ??read_pngimg_8
   \   0000016C   00009DE5           LDR      R0,[SP, #+0]
   \   00000170   B00100EF           SWI      +432
     89            
     90            if (color_type == PNG_COLOR_TYPE_PALETTE)
   \                     ??read_pngimg_8:
   \   00000174   24009DE5           LDR      R0,[SP, #+36]
   \   00000178   030050E3           CMP      R0,#+3
   \   0000017C   0100001A           BNE      ??read_pngimg_9
     91              png_set_palette_to_rgb(png_ptr);
   \   00000180   00009DE5           LDR      R0,[SP, #+0]
   \   00000184   AB0100EF           SWI      +427
     92            
     93            if (color_type == PNG_COLOR_TYPE_GRAY_ALPHA || color_type == PNG_COLOR_TYPE_GRAY)
   \                     ??read_pngimg_9:
   \   00000188   24009DE5           LDR      R0,[SP, #+36]
   \   0000018C   040050E3           CMP      R0,#+4
   \   00000190   00005013           CMPNE    R0,#+0
   \   00000194   0100001A           BNE      ??read_pngimg_10
     94              png_set_gray_to_rgb(png_ptr);
   \   00000198   00009DE5           LDR      R0,[SP, #+0]
   \   0000019C   B10100EF           SWI      +433
     95            
     96            png_set_filler(png_ptr,0xFF,PNG_FILLER_AFTER);
   \                     ??read_pngimg_10:
   \   000001A0   00009DE5           LDR      R0,[SP, #+0]
   \   000001A4   0120A0E3           MOV      R2,#+1
   \   000001A8   FF10A0E3           MOV      R1,#+255
   \   000001AC   AE0100EF           SWI      +430
     97            png_read_update_info(png_ptr, info_ptr);
   \   000001B0   04109DE5           LDR      R1,[SP, #+4]
   \   000001B4   00009DE5           LDR      R0,[SP, #+0]
     98            
     99            rowbytes = png_get_rowbytes(png_ptr, info_ptr);
    100            
    101            pp.row=malloc(rowbytes);
    102            pp.img_h=img_hc=malloc(sizeof(IMGHDR));
    103            
    104            {
    105              unsigned short *iimg=(unsigned short *)(pp.img=malloc(width*height*sizeof(unsigned short)));
    106              for (unsigned int y = 0; y<height; y++)
   \   000001B8   0070A0E3           MOV      R7,#+0
   \   000001BC   AA0100EF           SWI      +426
   \   000001C0   00009DE5           LDR      R0,[SP, #+0]
   \   000001C4   04109DE5           LDR      R1,[SP, #+4]
   \   000001C8   5F0100EF           SWI      +351
   \   000001CC   140000EF           SWI      +20
   \   000001D0   0C008DE5           STR      R0,[SP, #+12]
   \   000001D4   0C00A0E3           MOV      R0,#+12
   \   000001D8   140000EF           SWI      +20
   \   000001DC   0050A0E1           MOV      R5,R0
   \   000001E0   14508DE5           STR      R5,[SP, #+20]
   \   000001E4   18009DE5           LDR      R0,[SP, #+24]
   \   000001E8   1C109DE5           LDR      R1,[SP, #+28]
   \   000001EC   910000E0           MUL      R0,R1,R0
   \   000001F0   8000A0E1           LSL      R0,R0,#+1
   \   000001F4   140000EF           SWI      +20
   \   000001F8   10008DE5           STR      R0,[SP, #+16]
   \   000001FC   0060A0E1           MOV      R6,R0
   \   00000200   1C009DE5           LDR      R0,[SP, #+28]
   \   00000204   000050E3           CMP      R0,#+0
   \   00000208   1F00001A           BNE      ??read_pngimg_11
    107              {
    108                png_read_row(png_ptr, (png_bytep)pp.row, NULL);
    109                for (unsigned int x = 0; x<width; x++)
    110                {
    111                  if (pp.row[x*4+3]<128)
    112                    *iimg++=0xE000;
    113                  else
    114                  {
    115                    unsigned int c=((pp.row[x*4+0]<<8)&0xF800);
    116                    c|=((pp.row[x*4+1]<<3)&0x7E0);
    117                    c|=((pp.row[x*4+2]>>3)&0x1F);
    118                    *iimg++=c;
    119                  }
    120                }
    121              }
    122            }
    123            pp.img_h->bpnum=8;
   \                     ??read_pngimg_12:
   \   0000020C   14009DE5           LDR      R0,[SP, #+20]
   \   00000210   0810A0E3           MOV      R1,#+8
   \   00000214   041080E5           STR      R1,[R0, #+4]
    124            pp.img_h->w=width;
   \   00000218   14009DE5           LDR      R0,[SP, #+20]
   \   0000021C   18109DE5           LDR      R1,[SP, #+24]
   \   00000220   B010C0E1           STRH     R1,[R0, #+0]
    125            pp.img_h->h=height;
   \   00000224   14009DE5           LDR      R0,[SP, #+20]
   \   00000228   1C109DE5           LDR      R1,[SP, #+28]
   \   0000022C   B210C0E1           STRH     R1,[R0, #+2]
    126            pp.img_h->bitmap=pp.img;
   \   00000230   14009DE5           LDR      R0,[SP, #+20]
   \   00000234   10109DE5           LDR      R1,[SP, #+16]
   \   00000238   081080E5           STR      R1,[R0, #+8]
    127            
    128            png_read_end(png_ptr, info_ptr);
   \   0000023C   04109DE5           LDR      R1,[SP, #+4]
   \   00000240   00009DE5           LDR      R0,[SP, #+0]
   \   00000244   5D0100EF           SWI      +349
    129            png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
   \   00000248   0020A0E3           MOV      R2,#+0
   \   0000024C   04108DE2           ADD      R1,SP,#+4
   \   00000250   0D00A0E1           MOV      R0,SP
   \   00000254   570100EF           SWI      +343
    130            if (!pp.img)
   \   00000258   10009DE5           LDR      R0,[SP, #+16]
   \   0000025C   000050E3           CMP      R0,#+0
   \   00000260   2B00001A           BNE      ??read_pngimg_13
    131            {
    132            L_CLOSE_FILE:
    133              mfree(pp.row);
   \                     ??read_pngimg_2:
   \   00000264   0C009DE5           LDR      R0,[SP, #+12]
   \   00000268   150000EF           SWI      +21
    134              mfree(pp.img);
   \   0000026C   10009DE5           LDR      R0,[SP, #+16]
   \   00000270   150000EF           SWI      +21
    135              mfree(pp.img_h);
   \   00000274   14009DE5           LDR      R0,[SP, #+20]
   \   00000278   150000EF           SWI      +21
    136              return NULL;
   \   0000027C   0000A0E3           MOV      R0,#+0
   \   00000280   28D08DE2           ADD      SP,SP,#+40
   \   00000284   F080BDE8           POP      {R4-R7,PC}
    137            }
   \                     ??read_pngimg_14:
   \   00000288   017087E2           ADD      R7,R7,#+1
   \                     ??read_pngimg_11:
   \   0000028C   1C009DE5           LDR      R0,[SP, #+28]
   \   00000290   000057E1           CMP      R7,R0
   \   00000294   DCFFFF2A           BCS      ??read_pngimg_12
   \   00000298   0C109DE5           LDR      R1,[SP, #+12]
   \   0000029C   00009DE5           LDR      R0,[SP, #+0]
   \   000002A0   0020A0E3           MOV      R2,#+0
   \   000002A4   600100EF           SWI      +352
   \   000002A8   18109DE5           LDR      R1,[SP, #+24]
   \   000002AC   0400A0E1           MOV      R0,R4
   \   000002B0   000051E3           CMP      R1,#+0
   \   000002B4   7ECEA0E3           MOV      R12,#+2016
   \   000002B8   0B00001A           BNE      ??read_pngimg_15
   \   000002BC   F1FFFFEA           B        ??read_pngimg_14
   \                     ??read_pngimg_16:
   \   000002C0   0020D1E5           LDRB     R2,[R1, #+0]
   \   000002C4   F83CA0E3           MOV      R3,#+63488
   \   000002C8   022403E0           AND      R2,R3,R2, LSL #+8
   \   000002CC   0130D1E5           LDRB     R3,[R1, #+1]
   \   000002D0   0210D1E5           LDRB     R1,[R1, #+2]
   \   000002D4   83310CE0           AND      R3,R12,R3, LSL #+3
   \   000002D8   022083E1           ORR      R2,R3,R2
   \   000002DC   A111A0E1           LSR      R1,R1,#+3
   \   000002E0   021081E1           ORR      R1,R1,R2
   \                     ??read_pngimg_17:
   \   000002E4   ........           STRH     R1,[R6], #+2
   \   000002E8   010080E2           ADD      R0,R0,#+1
   \                     ??read_pngimg_15:
   \   000002EC   18109DE5           LDR      R1,[SP, #+24]
   \   000002F0   010050E1           CMP      R0,R1
   \   000002F4   E3FFFF2A           BCS      ??read_pngimg_14
   \   000002F8   0C109DE5           LDR      R1,[SP, #+12]
   \   000002FC   001181E0           ADD      R1,R1,R0, LSL #+2
   \   00000300   0320D1E5           LDRB     R2,[R1, #+3]
   \   00000304   800052E3           CMP      R2,#+128
   \   00000308   ECFFFF2A           BCS      ??read_pngimg_16
   \   0000030C   E01CA0E3           MOV      R1,#+57344
   \   00000310   F3FFFFEA           B        ??read_pngimg_17
    138            mfree(pp.row);
   \                     ??read_pngimg_13:
   \   00000314   0C009DE5           LDR      R0,[SP, #+12]
   \   00000318   150000EF           SWI      +21
    139            return (img_hc);
   \   0000031C   0500A0E1           MOV      R0,R5
   \                     ??read_pngimg_0:
   \   00000320   28D08DE2           ADD      SP,SP,#+40       ;; stack cleaning
   \   00000324   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??read_pngimg_1:
   \   00000328   ........           DC32     xmfree
   \   0000032C   ........           DC32     xmalloc
   \   00000330   ........           DC32     `?<Constant "1.2.5">`
   \   00000334   ........           DC32     read_data_fn
    140          }
    141          
    142          struct my_error_mgr {
    143            struct jpeg_error_mgr pub;	/* "public" fields */
    144          
    145            jmp_buf setjmp_buffer;	/* for return to caller */
    146          };
    147          
    148          typedef struct my_error_mgr * my_error_ptr;
    149          
    150          extern void longjmp(jmp_buf, int);

   \                                 In segment CODE, align 4, keep-with-next
    151          METHODDEF(void)
    152          my_error_exit (j_common_ptr cinfo)
    153          {
   \                     my_error_exit:
   \   00000000   10402DE9           PUSH     {R4,LR}
    154            my_error_ptr myerr = (my_error_ptr) cinfo->err;
   \   00000004   004090E5           LDR      R4,[R0, #+0]
    155            (*cinfo->err->output_message) (cinfo);
   \   00000008   081094E5           LDR      R1,[R4, #+8]
   \   0000000C   31FF2FE1           BLX      R1
    156            longjmp(myerr->setjmp_buffer, 1);
   \   00000010   0110A0E3           MOV      R1,#+1
   \   00000014   840084E2           ADD      R0,R4,#+132
   \   00000018   290200EF           SWI      +553
    157          }
   \   0000001C   1080BDE8           POP      {R4,PC}          ;; return
    158          

   \                                 In segment DATA_C, align 1, align-sorted
    159          const char jpg_hdr[]={0xFF, 0xD8};
   \                     jpg_hdr:
   \   00000000   FFD8               DC8 255, 216

   \                                 In segment CODE, align 4, keep-with-next
    160          IMGHDR *read_jpgimg(const char *buf)
    161          {
    162            int img_w, img_h;
    163            struct jpeg_decompress_struct cinfo;
    164            struct my_error_mgr jerr;
    165          
    166            IMGHDR * img_hc;
    167            unsigned short *img, *iimg;
    168            JSAMPARRAY buffer;
    169            char *row;
    170            
    171            if (memcmp((void *)buf,(void *)jpg_hdr,sizeof(jpg_hdr))) return NULL;
   \                     read_jpgimg:
   \   00000000   AC119FE5           LDR      R1,??read_jpgimg_0  ;; jpg_hdr
   \   00000004   E0472DE9           PUSH     {R5-R10,LR}
   \   00000008   9FDF4DE2           SUB      SP,SP,#+636
   \   0000000C   0050A0E1           MOV      R5,R0
   \   00000010   0220A0E3           MOV      R2,#+2
   \   00000014   1C0100EF           SWI      +284
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0000A013           MOVNE    R0,#+0
   \   00000020   5400001A           BNE      ??read_jpgimg_1
    172            
    173            img=0;
    174            img_hc=0;
    175            buffer=0;
    176            zeromem(&cinfo,sizeof(struct jpeg_decompress_struct));
   \   00000024   731FA0E3           MOV      R1,#+460
   \   00000028   0D00A0E1           MOV      R0,SP
   \   0000002C   1D0100EF           SWI      +285
    177            zeromem(&jerr,sizeof(struct my_error_mgr));
   \   00000030   B010A0E3           MOV      R1,#+176
   \   00000034   730F8DE2           ADD      R0,SP,#+460
   \   00000038   1D0100EF           SWI      +285
    178            
    179            cinfo.err=jpeg_std_error(&jerr.pub);
   \   0000003C   730F8DE2           ADD      R0,SP,#+460
   \   00000040   ........           _BLF     jpeg_std_error,??jpeg_std_error??rA
    180            jerr.pub.error_exit = my_error_exit;
   \   00000044   6C119FE5           LDR      R1,??read_jpgimg_0+0x4  ;; my_error_exit
   \   00000048   0080A0E3           MOV      R8,#+0
   \   0000004C   0070A0E3           MOV      R7,#+0
   \   00000050   00008DE5           STR      R0,[SP, #+0]
   \   00000054   CC118DE5           STR      R1,[SP, #+460]
    181            
    182            if (setjmp(jerr.setjmp_buffer))
   \   00000058   940F8DE2           ADD      R0,SP,#+592
   \   0000005C   620100EF           SWI      +354
   \   00000060   000050E3           CMP      R0,#+0
   \   00000064   0200000A           BEQ      ??read_jpgimg_2
    183            {
    184              jpeg_destroy_decompress(&cinfo);
   \   00000068   0D00A0E1           MOV      R0,SP
   \   0000006C   ........           _BLF     jpeg_destroy_decompress,??jpeg_destroy_decompress??rA
    185              goto L_ERROR;
   \   00000070   3A0000EA           B        ??read_jpgimg_3
    186            }
    187            jpeg_create_decompress(&cinfo);
   \                     ??read_jpgimg_2:
   \   00000074   732FA0E3           MOV      R2,#+460
   \   00000078   3E10A0E3           MOV      R1,#+62
   \   0000007C   0D00A0E1           MOV      R0,SP
   \   00000080   ........           _BLF     jpeg_CreateDecompress,??jpeg_CreateDecompress??rA
    188            
    189            jpeg_stdio_src(&cinfo, (void *)buf);
   \   00000084   0510A0E1           MOV      R1,R5
   \   00000088   0D00A0E1           MOV      R0,SP
   \   0000008C   ........           _BLF     jpeg_stdio_src,??jpeg_stdio_src??rA
    190            jpeg_read_header(&cinfo, TRUE);
   \   00000090   0110A0E3           MOV      R1,#+1
   \   00000094   0D00A0E1           MOV      R0,SP
   \   00000098   ........           _BLF     jpeg_read_header,??jpeg_read_header??rA
    191            jpeg_start_decompress(&cinfo);
   \   0000009C   0D00A0E1           MOV      R0,SP
   \   000000A0   ........           _BLF     jpeg_start_decompress,??jpeg_start_decompress??rA
    192            
    193            img_w=cinfo.output_width;
   \   000000A4   6C509DE5           LDR      R5,[SP, #+108]
    194            img_h=cinfo.output_height;
   \   000000A8   70609DE5           LDR      R6,[SP, #+112]
    195            
    196            img_hc=malloc(sizeof(IMGHDR));
   \   000000AC   0C00A0E3           MOV      R0,#+12
   \   000000B0   140000EF           SWI      +20
   \   000000B4   0070A0E1           MOV      R7,R0
    197            iimg=img=malloc(img_w*img_h*sizeof(unsigned short));
   \   000000B8   960500E0           MUL      R0,R6,R5
   \   000000BC   8000A0E1           LSL      R0,R0,#+1
   \   000000C0   140000EF           SWI      +20
    198            buffer = (*cinfo.mem->alloc_sarray)  
    199          		((j_common_ptr) &cinfo, JPOOL_IMAGE, img_w*cinfo.output_components, 1);
   \   000000C4   04A09DE5           LDR      R10,[SP, #+4]
   \   000000C8   0080A0E1           MOV      R8,R0
   \   000000CC   78009DE5           LDR      R0,[SP, #+120]
   \   000000D0   08A09AE5           LDR      R10,[R10, #+8]
   \   000000D4   0130A0E3           MOV      R3,#+1
   \   000000D8   900502E0           MUL      R2,R0,R5
   \   000000DC   0110A0E3           MOV      R1,#+1
   \   000000E0   0D00A0E1           MOV      R0,SP
   \   000000E4   3AFF2FE1           BLX      R10
   \   000000E8   00A0A0E1           MOV      R10,R0
   \   000000EC   88009DE5           LDR      R0,[SP, #+136]
   \   000000F0   0890A0E1           MOV      R9,R8
   \   000000F4   060050E1           CMP      R0,R6
   \   000000F8   0D00002A           BCS      ??read_jpgimg_4
    200            
    201            while (cinfo.output_scanline < img_h) 
    202            {
    203              jpeg_read_scanlines(&cinfo, buffer, 1);
   \                     ??read_jpgimg_5:
   \   000000FC   0120A0E3           MOV      R2,#+1
   \   00000100   0A10A0E1           MOV      R1,R10
   \   00000104   0D00A0E1           MOV      R0,SP
   \   00000108   ........           _BLF     jpeg_read_scanlines,??jpeg_read_scanlines??rA
    204              row=buffer[0];
   \   0000010C   00009AE5           LDR      R0,[R10, #+0]
    205              for (int x=0; x<img_w; x++)
   \   00000110   0010A0E3           MOV      R1,#+0
   \   00000114   010055E3           CMP      R5,#+1
   \   00000118   7ECEA0E3           MOV      R12,#+2016
   \   0000011C   010000BA           BLT      ??read_jpgimg_6
   \                     ??read_jpgimg_7:
   \   00000120   050051E1           CMP      R1,R5
   \   00000124   150000BA           BLT      ??read_jpgimg_8
   \                     ??read_jpgimg_6:
   \   00000128   88009DE5           LDR      R0,[SP, #+136]
   \   0000012C   060050E1           CMP      R0,R6
   \   00000130   F1FFFF3A           BCC      ??read_jpgimg_5
    206              {
    207                unsigned int c;
    208                c=((row[0]<<8)&0xF800);
    209                c|=((row[1]<<3)&0x7E0);
    210                c|=((row[2]>>3)&0x1F);
    211                row+=3;
    212                *iimg++=c;
    213              }
    214            }
    215            jpeg_finish_decompress(&cinfo);
   \                     ??read_jpgimg_4:
   \   00000134   0D00A0E1           MOV      R0,SP
   \   00000138   ........           _BLF     jpeg_finish_decompress,??jpeg_finish_decompress??rA
    216            jpeg_destroy_decompress(&cinfo);
   \   0000013C   0D00A0E1           MOV      R0,SP
   \   00000140   ........           _BLF     jpeg_destroy_decompress,??jpeg_destroy_decompress??rA
    217            img_hc->bitmap=(char *)img;
   \   00000144   088087E5           STR      R8,[R7, #+8]
    218            img_hc->bpnum=8;
   \   00000148   0800A0E3           MOV      R0,#+8
   \   0000014C   040087E5           STR      R0,[R7, #+4]
    219            img_hc->w=img_w;
   \   00000150   B050C7E1           STRH     R5,[R7, #+0]
    220            img_hc->h=img_h;
   \   00000154   B260C7E1           STRH     R6,[R7, #+2]
    221            if (!img)
   \   00000158   000058E3           CMP      R8,#+0
   \   0000015C   0400001A           BNE      ??read_jpgimg_9
    222            {
    223            L_ERROR:
    224              mfree(img_hc);
   \                     ??read_jpgimg_3:
   \   00000160   0700A0E1           MOV      R0,R7
   \   00000164   150000EF           SWI      +21
    225              img_hc=NULL;
    226              mfree(img);
   \   00000168   0800A0E1           MOV      R0,R8
   \   0000016C   150000EF           SWI      +21
   \   00000170   0070A0E3           MOV      R7,#+0
    227            } 
    228            return img_hc;
   \                     ??read_jpgimg_9:
   \   00000174   0700A0E1           MOV      R0,R7
   \                     ??read_jpgimg_1:
   \   00000178   9FDF8DE2           ADD      SP,SP,#+636      ;; stack cleaning
   \   0000017C   E087BDE8           POP      {R5-R10,PC}
   \                     ??read_jpgimg_8:
   \   00000180   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000184   F83CA0E3           MOV      R3,#+63488
   \   00000188   011081E2           ADD      R1,R1,#+1
   \   0000018C   022403E0           AND      R2,R3,R2, LSL #+8
   \   00000190   0130D0E5           LDRB     R3,[R0, #+1]
   \   00000194   83310CE0           AND      R3,R12,R3, LSL #+3
   \   00000198   022083E1           ORR      R2,R3,R2
   \   0000019C   0230D0E5           LDRB     R3,[R0, #+2]
   \   000001A0   030080E2           ADD      R0,R0,#+3
   \   000001A4   A331A0E1           LSR      R3,R3,#+3
   \   000001A8   022083E1           ORR      R2,R3,R2
   \   000001AC   ........           STRH     R2,[R9], #+2
   \   000001B0   DAFFFFEA           B        ??read_jpgimg_7
   \                     ??read_jpgimg_0:
   \   000001B4   ........           DC32     jpg_hdr
   \   000001B8   ........           DC32     my_error_exit
    229          }
    230          

   \                                 In segment CODE, align 4, keep-with-next
    231          IMGHDR *ConvertRGBAToRGB8(const char *buf, int width, int height)
    232          {
   \                     ConvertRGBAToRGB8:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0050A0E1           MOV      R5,R0
   \   00000008   0160A0E1           MOV      R6,R1
   \   0000000C   0240A0E1           MOV      R4,R2
    233            IMGHDR * img_hc=malloc(sizeof(IMGHDR));
   \   00000010   0C00A0E3           MOV      R0,#+12
   \   00000014   140000EF           SWI      +20
   \   00000018   0070A0E1           MOV      R7,R0
    234            unsigned short *iimg=malloc(width*height*sizeof(unsigned short));
   \   0000001C   940600E0           MUL      R0,R4,R6
   \   00000020   8000A0E1           LSL      R0,R0,#+1
   \   00000024   140000EF           SWI      +20
    235            img_hc->w=width;
   \   00000028   B060C7E1           STRH     R6,[R7, #+0]
    236            img_hc->h=height;
   \   0000002C   B240C7E1           STRH     R4,[R7, #+2]
    237            img_hc->bpnum=8;
   \   00000030   0810A0E3           MOV      R1,#+8
   \   00000034   041087E5           STR      R1,[R7, #+4]
    238            img_hc->bitmap=(char *)iimg;
   \   00000038   080087E5           STR      R0,[R7, #+8]
    239            
    240            for (unsigned int y = 0; y<height; y++)
   \   0000003C   0010A0E3           MOV      R1,#+0
   \   00000040   000054E3           CMP      R4,#+0
   \   00000044   0200001A           BNE      ??ConvertRGBAToRGB8_0
    241            {
    242              for (unsigned int x = 0; x<width; x++)
    243              {
    244                if (buf[y*width*4+x*4+0]<255)
    245                  *iimg++=0xE000;
    246                else
    247                {
    248                  unsigned int c=((buf[y*width*4+x*4+1]<<8)&0xF800);
    249                  c|=((buf[y*width*4+x*4+2]<<3)&0x7E0);
    250                  c|=((buf[y*width*4+x*4+3]>>3)&0x1F);
    251                  *iimg++=c;
    252                }
    253              }
    254            }
    255            return (img_hc);
   \                     ??ConvertRGBAToRGB8_1:
   \   00000048   0700A0E1           MOV      R0,R7
   \   0000004C   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??ConvertRGBAToRGB8_2:
   \   00000050   011081E2           ADD      R1,R1,#+1
   \                     ??ConvertRGBAToRGB8_0:
   \   00000054   040051E1           CMP      R1,R4
   \   00000058   FAFFFF2A           BCS      ??ConvertRGBAToRGB8_1
   \   0000005C   0020A0E3           MOV      R2,#+0
   \   00000060   000056E3           CMP      R6,#+0
   \   00000064   0C00001A           BNE      ??ConvertRGBAToRGB8_3
   \   00000068   F8FFFFEA           B        ??ConvertRGBAToRGB8_2
   \                     ??ConvertRGBAToRGB8_4:
   \   0000006C   01C0D3E5           LDRB     R12,[R3, #+1]
   \   00000070   F8ECA0E3           MOV      LR,#+63488
   \   00000074   7E8EA0E3           MOV      R8,#+2016
   \   00000078   0CC40EE0           AND      R12,LR,R12, LSL #+8
   \   0000007C   02E0D3E5           LDRB     LR,[R3, #+2]
   \   00000080   0330D3E5           LDRB     R3,[R3, #+3]
   \   00000084   8E8108E0           AND      R8,R8,LR, LSL #+3
   \   00000088   0C8088E1           ORR      R8,R8,R12
   \   0000008C   A331A0E1           LSR      R3,R3,#+3
   \   00000090   083083E1           ORR      R3,R3,R8
   \                     ??ConvertRGBAToRGB8_5:
   \   00000094   ........           STRH     R3,[R0], #+2
   \   00000098   012082E2           ADD      R2,R2,#+1
   \                     ??ConvertRGBAToRGB8_3:
   \   0000009C   060052E1           CMP      R2,R6
   \   000000A0   EAFFFF2A           BCS      ??ConvertRGBAToRGB8_2
   \   000000A4   962123E0           MLA      R3,R6,R1,R2
   \   000000A8   033185E0           ADD      R3,R5,R3, LSL #+2
   \   000000AC   0080D3E5           LDRB     R8,[R3, #+0]
   \   000000B0   FF0058E3           CMP      R8,#+255
   \   000000B4   ECFFFF0A           BEQ      ??ConvertRGBAToRGB8_4
   \   000000B8   E03CA0E3           MOV      R3,#+57344
   \   000000BC   F4FFFFEA           B        ??ConvertRGBAToRGB8_5
    256          }
    257          

   \                                 In segment CODE, align 4, keep-with-next
    258          IMGHDR *CreateFrame(int width, int height, const char *color)
    259          {
   \                     CreateFrame:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0270A0E1           MOV      R7,R2
    260            int color_c;
    261            IMGHDR * img_hc=malloc(sizeof(IMGHDR));
   \   00000010   0C00A0E3           MOV      R0,#+12
   \   00000014   140000EF           SWI      +20
   \   00000018   0060A0E1           MOV      R6,R0
    262            char *iimg=malloc(width*height);
   \   0000001C   950400E0           MUL      R0,R5,R4
   \   00000020   140000EF           SWI      +20
    263            img_hc->w=width;
   \   00000024   B040C6E1           STRH     R4,[R6, #+0]
    264            img_hc->h=height;
   \   00000028   B250C6E1           STRH     R5,[R6, #+2]
    265            img_hc->bpnum=5;
   \   0000002C   0510A0E3           MOV      R1,#+5
   \   00000030   041086E5           STR      R1,[R6, #+4]
    266            img_hc->bitmap=iimg;
   \   00000034   080086E5           STR      R0,[R6, #+8]
    267            
    268            if (color[3]<50) color_c=0xC0;
   \   00000038   0310D7E5           LDRB     R1,[R7, #+3]
   \   0000003C   320051E3           CMP      R1,#+50
   \   00000040   C010A033           MOVCC    R1,#+192
   \   00000044   0700003A           BCC      ??CreateFrame_0
    269            else
    270            {
    271              unsigned char c=color[0]&0xE0;
    272              c|=(color[1]>>3)&0x1C;
    273              c|=(color[2]>>6)&0x3;
    274              color_c=c;
   \   00000048   0010D7E5           LDRB     R1,[R7, #+0]
   \   0000004C   0120D7E5           LDRB     R2,[R7, #+1]
   \   00000050   1C30A0E3           MOV      R3,#+28
   \   00000054   E01001E2           AND      R1,R1,#0xE0
   \   00000058   A22103E0           AND      R2,R3,R2, LSR #+3
   \   0000005C   011082E1           ORR      R1,R2,R1
   \   00000060   0220D7E5           LDRB     R2,[R7, #+2]
   \   00000064   221381E1           ORR      R1,R1,R2, LSR #+6
    275            }
    276            for (unsigned int y = 0; y<height; y++)
   \                     ??CreateFrame_0:
   \   00000068   0020A0E3           MOV      R2,#+0
   \   0000006C   000055E3           CMP      R5,#+0
   \   00000070   0200001A           BNE      ??CreateFrame_1
    277            {
    278              for (unsigned int x = 0; x<width; x++)
    279              {
    280                if (x==0 || y==0 || x==width-1 || y==height-1)
    281                  *iimg++=color_c;
    282                else
    283                  *iimg++=0xC0;
    284              }
    285            }
    286            return (img_hc);  
   \                     ??CreateFrame_2:
   \   00000074   0600A0E1           MOV      R0,R6
   \   00000078   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??CreateFrame_3:
   \   0000007C   012082E2           ADD      R2,R2,#+1
   \                     ??CreateFrame_1:
   \   00000080   050052E1           CMP      R2,R5
   \   00000084   FAFFFF2A           BCS      ??CreateFrame_2
   \   00000088   0030A0E3           MOV      R3,#+0
   \   0000008C   000054E3           CMP      R4,#+0
   \   00000090   0100001A           BNE      ??CreateFrame_4
   \   00000094   F8FFFFEA           B        ??CreateFrame_3
   \                     ??CreateFrame_5:
   \   00000098   013083E2           ADD      R3,R3,#+1
   \                     ??CreateFrame_4:
   \   0000009C   040053E1           CMP      R3,R4
   \   000000A0   F5FFFF2A           BCS      ??CreateFrame_3
   \   000000A4   000053E3           CMP      R3,#+0
   \   000000A8   00005213           CMPNE    R2,#+0
   \   000000AC   01704412           SUBNE    R7,R4,#+1
   \   000000B0   07005311           CMPNE    R3,R7
   \   000000B4   01704512           SUBNE    R7,R5,#+1
   \   000000B8   07005211           CMPNE    R2,R7
   \   000000BC   C070A013           MOVNE    R7,#+192
   \   000000C0   ........           STRBNE   R7,[R0], #+1
   \   000000C4   ........           STRBEQ   R1,[R0], #+1
   \   000000C8   F2FFFFEA           B        ??CreateFrame_5
    287          }
    288          

   \                                 In segment CODE, align 4, keep-with-next
    289          IMGHDR *CreateDelimiter(int width, int height, const char *color)
    290          {
   \                     CreateDelimiter:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0270A0E1           MOV      R7,R2
    291            int color_c;
    292            IMGHDR * img_hc=malloc(sizeof(IMGHDR));
   \   00000010   0C00A0E3           MOV      R0,#+12
   \   00000014   140000EF           SWI      +20
   \   00000018   0060A0E1           MOV      R6,R0
    293            char *iimg=malloc(width*height);
   \   0000001C   950400E0           MUL      R0,R5,R4
   \   00000020   140000EF           SWI      +20
    294            img_hc->w=width;
   \   00000024   B040C6E1           STRH     R4,[R6, #+0]
    295            img_hc->h=height;
   \   00000028   B250C6E1           STRH     R5,[R6, #+2]
    296            img_hc->bpnum=5;
   \   0000002C   0510A0E3           MOV      R1,#+5
   \   00000030   041086E5           STR      R1,[R6, #+4]
    297            img_hc->bitmap=iimg;
   \   00000034   080086E5           STR      R0,[R6, #+8]
    298            
    299            if (color[3]<50) color_c=0xC0;
   \   00000038   0310D7E5           LDRB     R1,[R7, #+3]
   \   0000003C   320051E3           CMP      R1,#+50
   \   00000040   C010A033           MOVCC    R1,#+192
   \   00000044   0700003A           BCC      ??CreateDelimiter_0
    300            else
    301            {
    302              unsigned char c=color[0]&0xE0;
    303              c|=color[1]&0x1C;
    304              c|=color[2]&0x3;
    305              color_c=c;
   \   00000048   0010D7E5           LDRB     R1,[R7, #+0]
   \   0000004C   0120D7E5           LDRB     R2,[R7, #+1]
   \   00000050   E01001E2           AND      R1,R1,#0xE0
   \   00000054   1C2002E2           AND      R2,R2,#0x1C
   \   00000058   011082E1           ORR      R1,R2,R1
   \   0000005C   0220D7E5           LDRB     R2,[R7, #+2]
   \   00000060   032002E2           AND      R2,R2,#0x3
   \   00000064   011082E1           ORR      R1,R2,R1
    306            }
    307            for (unsigned int y = 0; y<height; y++)
   \                     ??CreateDelimiter_0:
   \   00000068   0020A0E3           MOV      R2,#+0
   \   0000006C   000055E3           CMP      R5,#+0
   \   00000070   0200001A           BNE      ??CreateDelimiter_1
    308            {
    309              for (unsigned int x = 0; x<width; x++)
    310              {
    311                if (y==height>>1 && x>3 && x<(width-3))
    312                  *iimg++=color_c;
    313                else
    314                  *iimg++=0xC0;
    315              }
    316            }
    317            return (img_hc);  
   \                     ??CreateDelimiter_2:
   \   00000074   0600A0E1           MOV      R0,R6
   \   00000078   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??CreateDelimiter_3:
   \   0000007C   012082E2           ADD      R2,R2,#+1
   \                     ??CreateDelimiter_1:
   \   00000080   050052E1           CMP      R2,R5
   \   00000084   FAFFFF2A           BCS      ??CreateDelimiter_2
   \   00000088   0030A0E3           MOV      R3,#+0
   \   0000008C   000054E3           CMP      R4,#+0
   \   00000090   0300001A           BNE      ??CreateDelimiter_4
   \   00000094   F8FFFFEA           B        ??CreateDelimiter_3
   \                     ??CreateDelimiter_5:
   \   00000098   C070A0E3           MOV      R7,#+192
   \   0000009C   ........           STRB     R7,[R0], #+1
   \                     ??CreateDelimiter_6:
   \   000000A0   013083E2           ADD      R3,R3,#+1
   \                     ??CreateDelimiter_4:
   \   000000A4   040053E1           CMP      R3,R4
   \   000000A8   F3FFFF2A           BCS      ??CreateDelimiter_3
   \   000000AC   C50052E1           CMP      R2,R5, ASR #+1
   \   000000B0   F8FFFF1A           BNE      ??CreateDelimiter_5
   \   000000B4   040053E3           CMP      R3,#+4
   \   000000B8   F6FFFF3A           BCC      ??CreateDelimiter_5
   \   000000BC   037044E2           SUB      R7,R4,#+3
   \   000000C0   070053E1           CMP      R3,R7
   \   000000C4   F3FFFF2A           BCS      ??CreateDelimiter_5
   \   000000C8   ........           STRB     R1,[R0], #+1
   \   000000CC   F3FFFFEA           B        ??CreateDelimiter_6
    318          }

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "1.2.5">`:
   \   00000000   312E322E3500       DC8 "1.2.5"
   \   00000006   0000               DC8 0, 0

   Maximum stack usage in bytes:

     Function          CSTACK
     --------          ------
     ConvertRGBAToRGB8    24
     CreateDelimiter      20
     CreateFrame          20
     my_error_exit         8
     read_data_fn         16
     read_jpgimg         668
     read_pngimg          80
     xmalloc               4
     xmfree                4


   Segment part sizes:

     Function/Label      Bytes
     --------------      -----
     xmalloc               16
     xmfree                16
     read_data_fn          52
     read_pngimg          824
     my_error_exit         32
     jpg_hdr                2
     read_jpgimg          444
     ConvertRGBAToRGB8    192
     CreateFrame          204
     CreateDelimiter      208
     ?<Constant "1.2.5">    8
      Others              132

 
 2 120 bytes in segment CODE
    10 bytes in segment DATA_C
 
 1 988 bytes of CODE  memory (+ 132 bytes shared)
    10 bytes of CONST memory

Errors: none
Warnings: none
