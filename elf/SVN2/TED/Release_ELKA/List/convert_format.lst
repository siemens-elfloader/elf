##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    02/Apr/2009  12:33:03 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\pasha\elf\SVN2\TED\convert_format.c               #
#    Command line    =  D:\pasha\elf\SVN2\TED\convert_format.c -D NEWSGOLD   #
#                       -D ELKA -lC D:\pasha\elf\SVN2\TED\Release_ELKA\List\ #
#                        -o D:\pasha\elf\SVN2\TED\Release_ELKA\Obj\ -s9      #
#                       --no_unroll --no_clustering --cpu_mode arm --endian  #
#                       little --cpu ARM926EJ-S --stack_align 4 --interwork  #
#                       -e --fpu None -I "D:\pasha\Embedded Workbench 4.0    #
#                       Evaluation2\ARM\INC\" --inline_threshold=9           #
#    List file       =  D:\pasha\elf\SVN2\TED\Release_ELKA\List\convert_form #
#                       at.lst                                               #
#    Object file     =  D:\pasha\elf\SVN2\TED\Release_ELKA\Obj\convert_forma #
#                       t.r79                                                #
#                                                                            #
#                                                                            #
##############################################################################

D:\pasha\elf\SVN2\TED\convert_format.c
      1          #include "..\inc\swilib.h"
      2          
      3          /*void my_memset(void *dst, int v, unsigned int len)
      4          {
      5            char *d=(char *)dst;
      6            if (len)
      7            {
      8              do
      9              {
     10                *d++=v;
     11              }
     12              while(--len);
     13            }
     14          }*/
     15          #define my_memset memset
     16          
     17          extern unsigned long curline; //Наружная переменная, счетчик строк
     18          extern unsigned int max_x; //Наружная переменная - макс. размер строки
     19          
     20          extern char *dstk;
     21          extern char *ustk;
     22          
     23          extern unsigned int FL_loader(int fin, unsigned int p);
     24          extern unsigned int FL_saver(int fs, unsigned int p);
     25          
     26          extern int win_dos_koi;
     27          extern const char wintranslation[];
     28          extern const char koi8translation[];
     29          
     30          extern void CharWidthForCodepage();
     31          
     32          extern char chars_width[];
     33          

   \                                 In segment DATA_C, align 4, align-sorted
     34          static const char ctype[128]=
   \                     ctype:
   \   00000000   020101010102       DC8 2, 1, 1, 1, 1, 2, 1, 1, 2, 3, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1
   \              010102030101
   \              010102010101
   \              0102010101  
   \   00000017   010101030203       DC8 1, 1, 1, 3, 2, 3, 2, 2, 2, 2, 1, 1, 1, 1, 2, 1, 1, 2, 3, 1, 1, 1, 1
   \              020202020101
   \              010102010102
   \              0301010101  
   \   0000002E   020100000000       DC8 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              0000000000  
   \   00000045   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              0000000000  
   \   0000005C   000000000101       DC8 0, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 3, 2, 3, 2, 2, 2, 2, 2, 2
   \              010201010101
   \              010103020302
   \              0202020202  
   \   00000073   020202020200       DC8 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00          
     35          {
     36            2,1,1,1,1,2,1,1, 2,3,1,1,1,1,2,1,
     37            1,1,1,2,1,1,1,1, 1,1,3,2,3,2,2,2,
     38            2,1,1,1,1,2,1,1, 2,3,1,1,1,1,2,1,
     39            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
     40            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
     41            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
     42            1,1,1,2,1,1,1,1, 1,1,3,2,3,2,2,2,
     43            2,2,2,2,2,2,2,2, 0,0,0,0,0,0,0,0,
     44          };
     45          

   \                                 In segment CODE, align 4, keep-with-next
     46          int GetCharType_x(int c)
     47          {
     48            if (c==' ') return(4); //Пробел
   \                     GetCharType_x:
   \   00000000   200050E3           CMP      R0,#+32
   \   00000004   0400A003           MOVEQ    R0,#+4
   \   00000008   1EFF2F01           BXEQ     LR
     49            if (c<32) return(5); //Конец строки
   \   0000000C   200050E3           CMP      R0,#+32
   \   00000010   0500A0B3           MOVLT    R0,#+5
   \   00000014   1EFF2FB1           BXLT     LR
     50            if ((c=='i')||(c=='I')) return 2; //Гласная для украинского ;)
   \   00000018   690050E3           CMP      R0,#+105
   \   0000001C   49005013           CMPNE    R0,#+73
   \   00000020   0200A003           MOVEQ    R0,#+2
   \   00000024   1EFF2F01           BXEQ     LR
     51            if (c<128) return(0); //Не русская буква
   \   00000028   800050E3           CMP      R0,#+128
   \   0000002C   0D0000BA           BLT      ??GetCharType_x_0
     52            switch(win_dos_koi)
   \   00000030   ........           LDR      R1,??DataTable1  ;; win_dos_koi
   \   00000034   001091E5           LDR      R1,[R1, #+0]
   \   00000038   011051E2           SUBS     R1,R1,#+1
   \   0000003C   0200000A           BEQ      ??GetCharType_x_1
   \   00000040   011051E2           SUBS     R1,R1,#+1
   \   00000044   0200000A           BEQ      ??GetCharType_x_2
   \   00000048   040000EA           B        ??GetCharType_x_3
     53            {
     54            case 1:
     55              //Win->Dos
     56              c=wintranslation[c-128];
   \                     ??GetCharType_x_1:
   \   0000004C   2C109FE5           LDR      R1,??GetCharType_x_4  ;; wintranslation
   \   00000050   000000EA           B        ??GetCharType_x_5
     57              break;
     58            case 2:
     59              //Koi8->Dos
     60              c=koi8translation[c-128];
   \                     ??GetCharType_x_2:
   \   00000054   28109FE5           LDR      R1,??GetCharType_x_4+0x4  ;; koi8translation
   \                     ??GetCharType_x_5:
   \   00000058   010080E0           ADD      R0,R0,R1
   \   0000005C   800050E5           LDRB     R0,[R0, #-128]
     61              break;
     62            }
     63            if (c<128) return(0); //Не русская буква
   \                     ??GetCharType_x_3:
   \   00000060   800050E3           CMP      R0,#+128
   \   00000064   010000AA           BGE      ??GetCharType_x_6
   \                     ??GetCharType_x_0:
   \   00000068   0000A0E3           MOV      R0,#+0
   \   0000006C   1EFF2FE1           BX       LR
     64            return(ctype[c-128]);
   \                     ??GetCharType_x_6:
   \   00000070   10109FE5           LDR      R1,??GetCharType_x_4+0x8  ;; ctype
   \   00000074   010080E0           ADD      R0,R0,R1
   \   00000078   800050E5           LDRB     R0,[R0, #-128]
   \   0000007C   1EFF2FE1           BX       LR               ;; return
   \                     ??GetCharType_x_4:
   \   00000080   ........           DC32     wintranslation
   \   00000084   ........           DC32     koi8translation
   \   00000088   ........           DC32     ctype
     65          }
     66          
     67          unsigned int def_code (void);
     68          
     69          //Процедура форматирования текста

   \                                 In segment CODE, align 4, keep-with-next
     70          unsigned int ConvertFormat(int fin,int fs,int fmt)
     71          {
   \                     ConvertFormat:
   \   00000000   F74F2DE9           PUSH     {R0-R2,R4-R11,LR}
   \   00000004   44DF4DE2           SUB      SP,SP,#+272
     72            unsigned int c0;
     73            unsigned int c1=1; //Начать с пропуска символов
     74            unsigned int c2=1;
     75            unsigned int c3=32; //Начать с абзаца, раз у нас форматирование ;)
     76          
     77            //unsigned int last_space;
     78          
     79            unsigned int sl;
     80          
     81            register unsigned int s;
     82            register unsigned int d;
     83            char ct[256]; //Массив для описания типа символов
     84          
     85            char *ds=dstk;
     86            register char *us=ustk;
   \   00000008   4C049FE5           LDR      R0,??ConvertFormat_0  ;; ustk
     87          
     88            extern unsigned int STKSZ50;
     89          
     90            int maxstk=STKSZ50;
     91            
     92            d=0;
     93            us[d]=0;
     94            sl=0;
     95            //last_space=0xFFFF;
     96            s=FL_loader(fin,0xFFFFFFFF);
     97          
     98            if (win_dos_koi==0xFF) win_dos_koi=def_code ();
   \   0000000C   ........           LDR      R8,??DataTable1  ;; win_dos_koi
   \   00000010   006090E5           LDR      R6,[R0, #+0]
   \   00000014   0110A0E3           MOV      R1,#+1
   \   00000018   00108DE5           STR      R1,[SP, #+0]
   \   0000001C   ........           LDR      R1,??DataTable5  ;; dstk
   \   00000020   0090A0E3           MOV      R9,#+0
   \   00000024   001091E5           LDR      R1,[R1, #+0]
   \   00000028   0900A0E1           MOV      R0,R9
   \   0000002C   04108DE5           STR      R1,[SP, #+4]
   \   00000030   28149FE5           LDR      R1,??ConvertFormat_0+0x4  ;; STKSZ50
   \   00000034   00A0A0E1           MOV      R10,R0
   \   00000038   001091E5           LDR      R1,[R1, #+0]
   \   0000003C   0140A0E3           MOV      R4,#+1
   \   00000040   0C108DE5           STR      R1,[SP, #+12]
   \   00000044   0000C6E5           STRB     R0,[R6, #+0]
   \   00000048   0010E0E1           MVN      R1,R0
   \   0000004C   10019DE5           LDR      R0,[SP, #+272]
   \   00000050   2050A0E3           MOV      R5,#+32
   \   00000054   ........           _BLF     FL_loader,??FL_loader??rA
   \   00000058   0070A0E1           MOV      R7,R0
   \   0000005C   000098E5           LDR      R0,[R8, #+0]
   \   00000060   FF0050E3           CMP      R0,#+255
   \   00000064   0100001A           BNE      ??ConvertFormat_1
   \   00000068   ........           BL       def_code
   \   0000006C   000088E5           STR      R0,[R8, #+0]
     99            CharWidthForCodepage();
   \                     ??ConvertFormat_1:
   \   00000070   ........           _BLF     CharWidthForCodepage,??CharWidthForCodepage??rA
    100          
    101            //Подготавливаем массив ct
    102            c0=0;
   \   00000074   0080A0E3           MOV      R8,#+0
    103            do
    104            {
    105              ct[c0]=GetCharType_x(c0);
   \                     ??ConvertFormat_2:
   \   00000078   0800A0E1           MOV      R0,R8
   \   0000007C   ........           BL       GetCharType_x
   \   00000080   10108DE2           ADD      R1,SP,#+16
   \   00000084   0100C8E7           STRB     R0,[R8, +R1]
    106            }
    107            while((++c0)!=sizeof(ct));
   \   00000088   018088E2           ADD      R8,R8,#+1
   \   0000008C   400F58E3           CMP      R8,#+256
   \   00000090   F8FFFF1A           BNE      ??ConvertFormat_2
    108          
    109          #define GetCharType(VAR) (ct[VAR])
    110          
    111            for(;;)
    112            {
    113              c0=c1;
   \                     ??ConvertFormat_3:
   \   00000094   0480A0E1           MOV      R8,R4
    114              c1=c2;
   \   00000098   00409DE5           LDR      R4,[SP, #+0]
    115              c2=c3;
   \   0000009C   00508DE5           STR      R5,[SP, #+0]
   \   000000A0   030000EA           B        ??ConvertFormat_4
    116            LSKIP1:
    117              c3=ds[s++];
    118              if (s>=maxstk) s=FL_loader(fin,s);
    119              if (c3==9) c3=' '; //Замена табуляции на пробел
   \                     ??ConvertFormat_5:
   \   000000A4   2050A0E3           MOV      R5,#+32
   \                     ??ConvertFormat_6:
   \   000000A8   00009DE5           LDR      R0,[SP, #+0]
   \   000000AC   200050E3           CMP      R0,#+32
   \   000000B0   1600001A           BNE      ??ConvertFormat_7
   \                     ??ConvertFormat_4:
   \   000000B4   04009DE5           LDR      R0,[SP, #+4]
   \   000000B8   0050D7E7           LDRB     R5,[R7, +R0]
   \   000000BC   0C009DE5           LDR      R0,[SP, #+12]
   \   000000C0   017087E2           ADD      R7,R7,#+1
   \   000000C4   000057E1           CMP      R7,R0
   \   000000C8   0300003A           BCC      ??ConvertFormat_8
   \   000000CC   10019DE5           LDR      R0,[SP, #+272]
   \   000000D0   0710A0E1           MOV      R1,R7
   \   000000D4   ........           _BLF     FL_loader,??FL_loader??rA
   \   000000D8   0070A0E1           MOV      R7,R0
   \                     ??ConvertFormat_8:
   \   000000DC   090055E3           CMP      R5,#+9
    120              if (c3==1) c3=' '; //Замена служ. символов
   \   000000E0   01005513           CMPNE    R5,#+1
   \   000000E4   EEFFFF0A           BEQ      ??ConvertFormat_5
    121              if ((c3==' ')&&(c2==' ')) goto LSKIP1; //Пропуск пробелов
   \   000000E8   200055E3           CMP      R5,#+32
   \   000000EC   EDFFFF0A           BEQ      ??ConvertFormat_6
    122              if ((c3==13)&&(ds[s]==10)) s++; //0D0A->0D
   \   000000F0   0D0055E3           CMP      R5,#+13
   \   000000F4   0500001A           BNE      ??ConvertFormat_7
   \   000000F8   04009DE5           LDR      R0,[SP, #+4]
   \   000000FC   0000D7E7           LDRB     R0,[R7, +R0]
   \   00000100   0A0050E3           CMP      R0,#+10
   \   00000104   0800001A           BNE      ??ConvertFormat_9
   \   00000108   017087E2           ADD      R7,R7,#+1
   \   0000010C   060000EA           B        ??ConvertFormat_9
    123              if ((c3==10)&&(ds[s]==13)) s++; //0A0D->0A
   \                     ??ConvertFormat_7:
   \   00000110   0A0055E3           CMP      R5,#+10
   \   00000114   0400001A           BNE      ??ConvertFormat_9
   \   00000118   04009DE5           LDR      R0,[SP, #+4]
    124              if (c3==10) c3=13; //0A->0D
   \   0000011C   0D50A0E3           MOV      R5,#+13
   \   00000120   0000D7E7           LDRB     R0,[R7, +R0]
   \   00000124   0D0050E3           CMP      R0,#+13
   \   00000128   01708702           ADDEQ    R7,R7,#+1
    125              if (c0==0) goto LEOF; //Конец текста
   \                     ??ConvertFormat_9:
   \   0000012C   060089E0           ADD      R0,R9,R6
   \   00000130   011089E2           ADD      R1,R9,#+1
   \   00000134   000058E3           CMP      R8,#+0
   \   00000138   0E00001A           BNE      ??ConvertFormat_10
    126              if (fmt==1)
    127              {
    128                if ((c0>' ')&&(c1=='-')&&(c2==13)&&(c3>' '))
    129                {
    130          	//Удаление переноса
    131          	c1=1;
    132          	c2=1;
    133          	goto LSYM;
    134                }
    135                if ((c0>' ')&&(c1==13)&&(c2>' '))
    136                {
    137          	//Замена перевода строки на пробел между словами
    138          	c1=' ';
    139          	goto LSYM;
    140                }
    141              }
    142              if (c0==13)
    143              {
    144                //Во всех других случаях перенос строки - это абзац
    145                //last_space=0xFFFF;
    146                sl=0;
    147                d=FL_saver(fs,d); //Сливаем не слитое
    148                us[d++]=0; //Конец строки
    149                curline++;
    150                if ((c1>' ')&&(fmt==2))
    151                {
    152          	us[d++]=' '; //Если сл. символ - буква, добавляем отступ
    153          	sl+=chars_width[' ']; //добавим ширину символа
    154                }
    155                continue;
    156              }
    157            LSYM:
    158              if (c0!=1)
    159              {
    160                us[d]=c0;
    161                //if ((c0==' ')&&sl) last_space=d; //Запоминаем последний пробел
    162                d++;
    163                sl+=chars_width[c0]; //добавим ширину символа
    164          //      sl++;
    165                if (sl>max_x)
    166                {
    167          	//Слишком длинная строка, ищем, куда вставить перенос
    168          	unsigned int pp=d+2; //Начинаем с конца c учетом доп. символов
    169          	unsigned int pg1=0xFFFFFFFF;
    170          	unsigned int pg2=0xFFFFFFFF;
    171          	int c;
    172          	us[d]=c1;
    173          	us[d+1]=c2;
    174          	us[d+2]=c3;
    175          	for(;;)
    176          	{
    177          	  c=GetCharType(us[pp]);
    178          	  if ((c==5)&&(pp<d))
    179          	  {
    180          	    //Нет подходящих пробелов, режем по живому ;)
    181          	  L_CUT:
    182          	    d--;
    183          	    d=FL_saver(fs,d);
    184          	    us[d++]=0;
    185          	    us[d++]=c0;
    186          	    sl=chars_width[c0]; //ширина символа в накопитель
    187          	    break;
    188          	  }
    189          	  if ((c==4)&&(pp<d))
    190          	  {
    191                      unsigned int wc;
    192          	    //Режем по пробелу
    193          	    if (us[pp-1]<2) goto L_CUT; //Первый пробел не обрезаем
    194          	    us[pp]=0; //Обрезаем по пробелу и признак форматирования
    195                      sl = 0;
    196                      for(wc = pp+1; wc < d; wc++)
    197                        sl+=chars_width[us[wc]];
    198                          
    199          	    //sl=(d-pp)-1;
    200          	    d=FL_saver(fs,d); //Сливаем не слитое
    201          	    //last_space=0xFFFF;
    202          	    break;
    203          	  }
    204          	  if ((c<1)||(c>3))
    205          	  {
    206          	    pg1=0xFFFFFFFF; //Новое слово
    207          	    pg2=0xFFFFFFFF;
    208          	  }
    209          	  if (c==2)
    210          	  {
    211          	    pg2=pg1;
    212          	    pg1=pp;
    213          	    if (pg2!=0xFFFFFFFF)
    214          	    {
    215          	      //Нашли 2 гласных
    216          	      unsigned int pm=(pg2+pg1+1)>>1;
    217          	      if (GetCharType(us[pm])==3) pm++; //Если нельзя отрывать букву
    218          	      c=GetCharType(us[pm-2]);
    219          	      if ((pm<(d-1))&&(c>0)&&(c<4))
    220          	      {
    221                          unsigned int wc;
    222          		if (pm==pg2)
    223          		{
    224          		  //Если гласная непостредственно справа, проверяем не одна ли она
    225          		  c=GetCharType(us[pg2+1]);
    226          		  if ((c<1)||(c>3)) goto L_NOPERE;
    227          		}
    228          		{
    229          		  //memmove(us+(pm+2),us+pm,d-pm);
    230          		  unsigned int len=d-pm;
    231          		  if (len)
    232          		  {
    233          		    char *d=us+(pm+2)+len-1;
    234          		    char *s=us+pm+len-1;
    235          		    do
    236          		    {
    237          		      *d=*s;
    238          		      d--;
    239          		      s--;
    240          		    }
    241          		    while(--len);
    242          		  }
    243          		}
    244          		us[pm++]='-';
    245          		us[pm++]=0;
    246          		d+=2; //Т.к. вставили 2 символа
    247          
    248                          sl = 0;
    249                          for(wc = pm; wc < d; wc++)
    250                            sl+=chars_width[us[wc]];
    251                      
    252            //              sl=(d-pm);
    253          		d=FL_saver(fs,d); //Сливаем не слитое
    254          		break;
    255          	      L_NOPERE:
    256          		;
    257          	      }
    258          	    }
    259          	  }
    260          	  pp--;
    261          	}
    262          	curline++;
    263                }
    264              }
    265            }
    266          LEOF:
    267            if (sl) //Не записана последняя строка
   \   0000013C   00005AE3           CMP      R10,#+0
   \   00000140   0700000A           BEQ      ??ConvertFormat_11
    268            {
    269              us[d++]=0;
   \   00000144   0190A0E1           MOV      R9,R1
    270              curline++;
   \   00000148   14139FE5           LDR      R1,??ConvertFormat_0+0x8  ;; curline
   \   0000014C   0020A0E3           MOV      R2,#+0
   \   00000150   0020C0E5           STRB     R2,[R0, #+0]
   \   00000154   08039FE5           LDR      R0,??ConvertFormat_0+0x8  ;; curline
   \   00000158   001091E5           LDR      R1,[R1, #+0]
   \   0000015C   011081E2           ADD      R1,R1,#+1
   \   00000160   001080E5           STR      R1,[R0, #+0]
    271            }
    272            d=FL_saver(fs,d); //Сливаем не слитое
    273            return(d);
   \                     ??ConvertFormat_11:
   \   00000164   14019DE5           LDR      R0,[SP, #+276]
   \   00000168   0910A0E1           MOV      R1,R9
   \   0000016C   ........           _BLF     FL_saver,??FL_saver??rA
   \   00000170   47DF8DE2           ADD      SP,SP,#+284
   \   00000174   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??ConvertFormat_10:
   \   00000178   18219DE5           LDR      R2,[SP, #+280]
   \   0000017C   010052E3           CMP      R2,#+1
   \   00000180   1300001A           BNE      ??ConvertFormat_12
   \   00000184   210058E3           CMP      R8,#+33
   \   00000188   1100003A           BCC      ??ConvertFormat_12
   \   0000018C   2D0054E3           CMP      R4,#+45
   \   00000190   0800001A           BNE      ??ConvertFormat_13
   \   00000194   00209DE5           LDR      R2,[SP, #+0]
   \   00000198   0D0052E3           CMP      R2,#+13
   \   0000019C   2700001A           BNE      ??ConvertFormat_14
   \   000001A0   210055E3           CMP      R5,#+33
   \   000001A4   2500003A           BCC      ??ConvertFormat_14
   \   000001A8   0140A0E3           MOV      R4,#+1
   \   000001AC   0130A0E3           MOV      R3,#+1
   \   000001B0   00308DE5           STR      R3,[SP, #+0]
   \   000001B4   210000EA           B        ??ConvertFormat_14
   \                     ??ConvertFormat_13:
   \   000001B8   0D0054E3           CMP      R4,#+13
   \   000001BC   1F00001A           BNE      ??ConvertFormat_14
   \   000001C0   00209DE5           LDR      R2,[SP, #+0]
   \   000001C4   210052E3           CMP      R2,#+33
   \   000001C8   1C00003A           BCC      ??ConvertFormat_14
   \   000001CC   2040A0E3           MOV      R4,#+32
   \   000001D0   1A0000EA           B        ??ConvertFormat_14
   \                     ??ConvertFormat_12:
   \   000001D4   0D0058E3           CMP      R8,#+13
   \   000001D8   1600001A           BNE      ??ConvertFormat_15
   \   000001DC   14019DE5           LDR      R0,[SP, #+276]
   \   000001E0   0910A0E1           MOV      R1,R9
   \   000001E4   ........           _BLF     FL_saver,??FL_saver??rA
   \   000001E8   0010A0E3           MOV      R1,#+0
   \   000001EC   0610C0E7           STRB     R1,[R0, +R6]
   \   000001F0   6C129FE5           LDR      R1,??ConvertFormat_0+0x8  ;; curline
   \   000001F4   019080E2           ADD      R9,R0,#+1
   \   000001F8   64029FE5           LDR      R0,??ConvertFormat_0+0x8  ;; curline
   \   000001FC   001091E5           LDR      R1,[R1, #+0]
   \   00000200   00A0A0E3           MOV      R10,#+0
   \   00000204   011081E2           ADD      R1,R1,#+1
   \   00000208   001080E5           STR      R1,[R0, #+0]
   \   0000020C   210054E3           CMP      R4,#+33
   \   00000210   9FFFFF3A           BCC      ??ConvertFormat_3
   \   00000214   18019DE5           LDR      R0,[SP, #+280]
   \   00000218   020050E3           CMP      R0,#+2
   \   0000021C   9CFFFF1A           BNE      ??ConvertFormat_3
   \   00000220   2000A0E3           MOV      R0,#+32
   \   00000224   0600C9E7           STRB     R0,[R9, +R6]
   \   00000228   38029FE5           LDR      R0,??ConvertFormat_0+0xC  ;; chars_width + 32
   \   0000022C   019089E2           ADD      R9,R9,#+1
   \   00000230   00A0D0E5           LDRB     R10,[R0, #+0]
   \   00000234   96FFFFEA           B        ??ConvertFormat_3
   \                     ??ConvertFormat_15:
   \   00000238   010058E3           CMP      R8,#+1
   \   0000023C   94FFFF0A           BEQ      ??ConvertFormat_3
   \                     ??ConvertFormat_14:
   \   00000240   0190A0E1           MOV      R9,R1
   \   00000244   20129FE5           LDR      R1,??ConvertFormat_0+0x10  ;; chars_width
   \   00000248   0080C0E5           STRB     R8,[R0, #+0]
   \   0000024C   011088E0           ADD      R1,R8,R1
   \   00000250   08108DE5           STR      R1,[SP, #+8]
   \   00000254   0000D1E5           LDRB     R0,[R1, #+0]
   \   00000258   0AA080E0           ADD      R10,R0,R10
   \   0000025C   0C029FE5           LDR      R0,??ConvertFormat_0+0x14  ;; max_x
   \   00000260   000090E5           LDR      R0,[R0, #+0]
   \   00000264   0A0050E1           CMP      R0,R10
   \   00000268   89FFFF2A           BCS      ??ConvertFormat_3
   \   0000026C   061089E0           ADD      R1,R9,R6
   \   00000270   0040C1E5           STRB     R4,[R1, #+0]
   \   00000274   00309DE5           LDR      R3,[SP, #+0]
   \   00000278   020089E2           ADD      R0,R9,#+2
   \   0000027C   0020E0E3           MVN      R2,#+0
   \   00000280   0130C1E5           STRB     R3,[R1, #+1]
   \   00000284   0250C1E5           STRB     R5,[R1, #+2]
   \   00000288   000000EA           B        ??ConvertFormat_16
   \                     ??ConvertFormat_17:
   \   0000028C   010040E2           SUB      R0,R0,#+1
   \                     ??ConvertFormat_16:
   \   00000290   063080E0           ADD      R3,R0,R6
   \   00000294   0010D3E5           LDRB     R1,[R3, #+0]
   \   00000298   10A08DE2           ADD      R10,SP,#+16
   \   0000029C   0AE0D1E7           LDRB     LR,[R1, +R10]
   \   000002A0   011049E2           SUB      R1,R9,#+1
   \   000002A4   05005EE3           CMP      LR,#+5
   \   000002A8   1000001A           BNE      ??ConvertFormat_18
   \   000002AC   090050E1           CMP      R0,R9
   \   000002B0   2B00002A           BCS      ??ConvertFormat_19
   \                     ??ConvertFormat_20:
   \   000002B4   14019DE5           LDR      R0,[SP, #+276]
   \   000002B8   ........           _BLF     FL_saver,??FL_saver??rA
   \   000002BC   0010A0E3           MOV      R1,#+0
   \   000002C0   0610C0E7           STRB     R1,[R0, +R6]
   \   000002C4   010080E2           ADD      R0,R0,#+1
   \   000002C8   0680C0E7           STRB     R8,[R0, +R6]
   \   000002CC   019080E2           ADD      R9,R0,#+1
   \   000002D0   08009DE5           LDR      R0,[SP, #+8]
   \   000002D4   00A0D0E5           LDRB     R10,[R0, #+0]
   \                     ??ConvertFormat_21:
   \   000002D8   84119FE5           LDR      R1,??ConvertFormat_0+0x8  ;; curline
   \   000002DC   80019FE5           LDR      R0,??ConvertFormat_0+0x8  ;; curline
   \   000002E0   001091E5           LDR      R1,[R1, #+0]
   \   000002E4   011081E2           ADD      R1,R1,#+1
   \   000002E8   001080E5           STR      R1,[R0, #+0]
   \   000002EC   68FFFFEA           B        ??ConvertFormat_3
   \                     ??ConvertFormat_18:
   \   000002F0   04005EE3           CMP      LR,#+4
   \   000002F4   1600001A           BNE      ??ConvertFormat_22
   \   000002F8   090050E1           CMP      R0,R9
   \   000002FC   1800002A           BCS      ??ConvertFormat_19
   \   00000300   012053E5           LDRB     R2,[R3, #-1]
   \   00000304   020052E3           CMP      R2,#+2
   \   00000308   E9FFFF3A           BCC      ??ConvertFormat_20
   \   0000030C   0010A0E3           MOV      R1,#+0
   \   00000310   0010C3E5           STRB     R1,[R3, #+0]
   \   00000314   00A0A0E3           MOV      R10,#+0
   \   00000318   010080E2           ADD      R0,R0,#+1
   \   0000031C   090050E1           CMP      R0,R9
   \   00000320   0600002A           BCS      ??ConvertFormat_23
   \                     ??ConvertFormat_24:
   \   00000324   0610D0E7           LDRB     R1,[R0, +R6]
   \   00000328   3C219FE5           LDR      R2,??ConvertFormat_0+0x10  ;; chars_width
   \   0000032C   010080E2           ADD      R0,R0,#+1
   \   00000330   0210D1E7           LDRB     R1,[R1, +R2]
   \   00000334   090050E1           CMP      R0,R9
   \   00000338   0AA081E0           ADD      R10,R1,R10
   \   0000033C   F8FFFF3A           BCC      ??ConvertFormat_24
   \                     ??ConvertFormat_23:
   \   00000340   14019DE5           LDR      R0,[SP, #+276]
   \   00000344   0910A0E1           MOV      R1,R9
   \   00000348   ........           _BLF     FL_saver,??FL_saver??rA
   \   0000034C   0090A0E1           MOV      R9,R0
   \   00000350   E0FFFFEA           B        ??ConvertFormat_21
   \                     ??ConvertFormat_22:
   \   00000354   01005EE3           CMP      LR,#+1
   \   00000358   010000BA           BLT      ??ConvertFormat_19
   \   0000035C   04005EE3           CMP      LR,#+4
   \   00000360   000000BA           BLT      ??ConvertFormat_25
   \                     ??ConvertFormat_19:
   \   00000364   0020E0E3           MVN      R2,#+0
   \                     ??ConvertFormat_25:
   \   00000368   02005EE3           CMP      LR,#+2
   \   0000036C   C6FFFF1A           BNE      ??ConvertFormat_17
   \   00000370   02C0A0E1           MOV      R12,R2
   \   00000374   0020A0E1           MOV      R2,R0
   \   00000378   01007CE3           CMN      R12,#+1
   \   0000037C   C2FFFF0A           BEQ      ??ConvertFormat_17
   \   00000380   02308CE0           ADD      R3,R12,R2
   \   00000384   013083E2           ADD      R3,R3,#+1
   \   00000388   A330A0E1           LSR      R3,R3,#+1
   \   0000038C   06A0D3E7           LDRB     R10,[R3, +R6]
   \   00000390   10E08DE2           ADD      LR,SP,#+16
   \   00000394   10B08DE2           ADD      R11,SP,#+16
   \   00000398   0EA0DAE7           LDRB     R10,[R10, +LR]
   \   0000039C   03005AE3           CMP      R10,#+3
   \   000003A0   01308302           ADDEQ    R3,R3,#+1
   \   000003A4   06A083E0           ADD      R10,R3,R6
   \   000003A8   02E05AE5           LDRB     LR,[R10, #-2]
   \   000003AC   010053E1           CMP      R3,R1
   \   000003B0   0BE0DEE7           LDRB     LR,[LR, +R11]
   \   000003B4   B4FFFF2A           BCS      ??ConvertFormat_17
   \   000003B8   01005EE3           CMP      LR,#+1
   \   000003BC   B2FFFFBA           BLT      ??ConvertFormat_17
   \   000003C0   04005EE3           CMP      LR,#+4
   \   000003C4   B0FFFFAA           BGE      ??ConvertFormat_17
   \   000003C8   0C0053E1           CMP      R3,R12
   \   000003CC   0600001A           BNE      ??ConvertFormat_26
   \   000003D0   06108CE0           ADD      R1,R12,R6
   \   000003D4   0110D1E5           LDRB     R1,[R1, #+1]
   \   000003D8   0BE0D1E7           LDRB     LR,[R1, +R11]
   \   000003DC   01005EE3           CMP      LR,#+1
   \   000003E0   A9FFFFBA           BLT      ??ConvertFormat_17
   \   000003E4   04005EE3           CMP      LR,#+4
   \   000003E8   A7FFFFAA           BGE      ??ConvertFormat_17
   \                     ??ConvertFormat_26:
   \   000003EC   030059E0           SUBS     R0,R9,R3
   \   000003F0   0700000A           BEQ      ??ConvertFormat_27
   \   000003F4   061080E0           ADD      R1,R0,R6
   \   000003F8   011083E0           ADD      R1,R3,R1
   \   000003FC   012081E2           ADD      R2,R1,#+1
   \   00000400   011041E2           SUB      R1,R1,#+1
   \                     ??ConvertFormat_28:
   \   00000404   ........           LDRB     R8,[R1], #-1
   \   00000408   010050E2           SUBS     R0,R0,#+1
   \   0000040C   ........           STRB     R8,[R2], #-1
   \   00000410   FBFFFF1A           BNE      ??ConvertFormat_28
   \                     ??ConvertFormat_27:
   \   00000414   2D00A0E3           MOV      R0,#+45
   \   00000418   0000CAE5           STRB     R0,[R10, #+0]
   \   0000041C   013083E2           ADD      R3,R3,#+1
   \   00000420   0000A0E3           MOV      R0,#+0
   \   00000424   0600C3E7           STRB     R0,[R3, +R6]
   \   00000428   029089E2           ADD      R9,R9,#+2
   \   0000042C   00A0A0E3           MOV      R10,#+0
   \   00000430   010083E2           ADD      R0,R3,#+1
   \   00000434   090050E1           CMP      R0,R9
   \   00000438   C0FFFF2A           BCS      ??ConvertFormat_23
   \                     ??ConvertFormat_29:
   \   0000043C   0610D0E7           LDRB     R1,[R0, +R6]
   \   00000440   24209FE5           LDR      R2,??ConvertFormat_0+0x10  ;; chars_width
   \   00000444   010080E2           ADD      R0,R0,#+1
   \   00000448   0210D1E7           LDRB     R1,[R1, +R2]
   \   0000044C   090050E1           CMP      R0,R9
   \   00000450   0AA081E0           ADD      R10,R1,R10
   \   00000454   B9FFFF2A           BCS      ??ConvertFormat_23
   \   00000458   F7FFFFEA           B        ??ConvertFormat_29
   \                     ??ConvertFormat_0:
   \   0000045C   ........           DC32     ustk
   \   00000460   ........           DC32     STKSZ50
   \   00000464   ........           DC32     curline
   \   00000468   ........           DC32     chars_width + 32
   \   0000046C   ........           DC32     chars_width
   \   00000470   ........           DC32     max_x
    274          }
    275          
    276          //-------------------------------------------------------------
    277          // Автоматическое определение кодировки (по первой загрузке)
    278          //-------------------------------------------------------------
    279          /* Таблица сочетаний */
    280          

   \                                 In segment DATA_C, align 4, align-sorted
    281          static const unsigned char table_2s[128]={0xFF,0xFF,0xFF,0xC7,0xFE,0xBE,0xF7,0xFB,
   \                     table_2s:
   \   00000000   FFFFFFC7FEBE       DC8 255, 255, 255, 199, 254, 190, 247, 251, 253, 191, 247, 249, 252
   \              F7FBFDBFF7F9
   \              FC          
   \   0000000D   BEF180FFFFF7       DC8 190, 241, 128, 255, 255, 247, 187, 255, 255, 255, 207, 222, 191
   \              BBFFFFFFCFDE
   \              BF          
   \   0000001A   D108FFBFF1BF       DC8 209, 8, 255, 191, 241, 191, 255, 255, 255, 199, 29, 63, 127, 129
   \              FFFFFFC71D3F
   \              7F81        
   \   00000028   A7B6F282FFFF       DC8 167, 182, 242, 130, 255, 255, 117, 219, 252, 191, 215, 157, 255
   \              75DBFCBFD79D
   \              FF          
   \   00000035   AEFBDFFFFFFF       DC8 174, 251, 223, 255, 255, 255, 199, 132, 183, 243, 159, 255, 255
   \              C784B7F39FFF
   \              FF          
   \   00000042   FFDBFFBFFFFF       DC8 255, 219, 255, 191, 255, 255, 253, 191, 255, 255, 255, 255, 231
   \              FDBFFFFFFFFF
   \              E7          
   \   0000004F   C7849EF012BC       DC8 199, 132, 158, 240, 18, 188, 191, 240, 132, 164, 186, 16, 16, 164
   \              BFF084A4BA10
   \              10A4        
   \   0000005D   BEB888ACBFF7       DC8 190, 184, 136, 172, 191, 247, 10, 132, 134, 144, 8, 4, 0, 0, 3, 127
   \              0A8486900804
   \              0000037F    
   \   0000006D   FDF7C17DAE6F       DC8 253, 247, 193, 125, 174, 111, 203, 21, 61, 252, 0, 127, 125, 231
   \              CB153DFC007F
   \              7DE7        
   \   0000007B   C27FFDF7C3         DC8 194, 127, 253, 247, 195
    282          0xFD,0xBF,0xF7,0xF9,0xFC,0xBE,0xF1,0x80,0xFF,0xFF,0xF7,0xBB,0xFF,0xFF,0xFF,
    283          0xCF,0xDE,0xBF,0xD1,0x08,0xFF,0xBF,0xF1,0xBF,0xFF,0xFF,0xFF,0xC7,0x1D,0x3F,
    284          0x7F,0x81,0xA7,0xB6,0xF2,0x82,0xFF,0xFF,0x75,0xDB,0xFC,0xBF,0xD7,0x9D,0xFF,
    285          0xAE,0xFB,0xDF,0xFF,0xFF,0xFF,0xC7,0x84,0xB7,0xF3,0x9F,0xFF,0xFF,0xFF,0xDB,
    286          0xFF,0xBF,0xFF,0xFF,0xFD,0xBF,0xFF,0xFF,0xFF,0xFF,0xE7,0xC7,0x84,0x9E,0xF0,
    287          0x12,0xBC,0xBF,0xF0,0x84,0xA4,0xBA,0x10,0x10,0xA4,0xBE,0xB8,0x88,0xAC,0xBF,
    288          0xF7,0x0A,0x84,0x86,0x90,0x08,0x04,0x00,0x00,0x03,0x7F,0xFD,0xF7,0xC1,0x7D,
    289          0xAE,0x6F,0xCB,0x15,0x3D,0xFC,0x00,0x7F,0x7D,0xE7,0xC2,0x7F,0xFD,0xF7,0xC3};
    290          
    291          /* =========================================================================
    292          Вспомогательная функция alt2num.
    293          Вход: a - код русской буквы в кодировке ALT.
    294          Выход: порядковый номер этой буквы (0-31).
    295          ========================================================================= */

   \                                 In segment CODE, align 4, keep-with-next
    296          unsigned int alt2num (int a)
    297          {
    298            if (a>=0xE0) a-=0x30;
   \                     alt2num:
   \   00000000   E00050E3           CMP      R0,#+224
   \   00000004   300040A2           SUBGE    R0,R0,#+48
    299            return (a&31);
   \   00000008   1F0000E2           AND      R0,R0,#0x1F
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    300          }
    301          /* =========================================================================
    302          Вспомогательная функция koi2num.
    303          Вход: a - код русской буквы в кодировке KOI.
    304          Выход: порядковый номер этой буквы (0-31).
    305          ========================================================================= */

   \                                 In segment CODE, align 4, keep-with-next
    306          unsigned int koi2num (int a)
    307          {
    308            static const unsigned char t[32]={30,0,1,22,4,5,20,3,21,8,9,10,11,12,13,14,15,31,
    309            16,17,18,19,6,2,28,27,7,24,29,25,23,26};
    310            return (t[a&31]);
   \                     koi2num:
   \   00000000   ........           LDR      R1,??DataTable7  ;; ??t
   \   00000004   1F0000E2           AND      R0,R0,#0x1F
   \   00000008   0100D0E7           LDRB     R0,[R0, +R1]
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    311          }

   \                                 In segment DATA_C, align 4, align-sorted
   \                     ??t:
   \   00000000   1E0001160405       DC8 30, 0, 1, 22, 4, 5, 20, 3, 21, 8, 9, 10, 11, 12, 13, 14, 15, 31, 16
   \              14031508090A
   \              0B0C0D0E0F1F
   \              10          
   \   00000013   11121306021C       DC8 17, 18, 19, 6, 2, 28, 27, 7, 24, 29, 25, 23, 26
   \              1B07181D1917
   \              1A          
    312          
    313          /* =========================================================================
    314          Вспомогательная функция work_2s - обработка двухбуквенного сочетания.
    315          Вход:  с1 - порядковый номер первой буквы (0-31),
    316          c2 - порядковый номер второй буквы (0-31),
    317          check - надо ли проверять, встречалось ли сочетание раньше
    318          (1 - да, 0 - нет),
    319          buf - адрес массива с информацией о встреченных сочетаниях.
    320          Выход: 0 - указанное сочетание уже встречалось раньше,
    321          1 - сочетание не встречалось раньше и является допустимым,
    322          2 - сочетание не встречалось раньше и является недопустимым.
    323          ========================================================================= */
    324          

   \                                 In segment CODE, align 4, keep-with-next
    325          unsigned int work_2s (unsigned int c1, unsigned int c2, unsigned int check, unsigned char buf[128])
    326          {
    327            unsigned int i=(c1<<2)+(c2>>3); /* Номер байта в массиве. */
   \                     work_2s:
   \   00000000   A1C1A0E1           LSR      R12,R1,#+3
   \   00000004   00018CE0           ADD      R0,R12,R0, LSL #+2
    328            unsigned int mask=0x80>>(c2&7); /* Маска, соответствующая номеру бита в байте. */
   \   00000008   80C0A0E3           MOV      R12,#+128
   \   0000000C   071001E2           AND      R1,R1,#0x7
   \   00000010   3C11A0E1           LSR      R1,R12,R1
    329          
    330            /* Если check=1, проверяем: если соответствующий бит массива buf равен 0,
    331            значит, указанное сочетание уже встречалось раньше. Тогда выходим из
    332            функции, возвращая 0. Если же сочетание не встречалось, то помечаем, что
    333            оно встретилось (обнуляем соответствующий бит массива buf). */
    334          
    335            if (check==1)
   \   00000014   010052E3           CMP      R2,#+1
   \   00000018   0600001A           BNE      ??work_2s_0
    336            {
    337              if ((buf[i]&mask)==0) return (0);
   \   0000001C   032080E0           ADD      R2,R0,R3
   \   00000020   0030D2E5           LDRB     R3,[R2, #+0]
   \   00000024   030011E1           TST      R1,R3
   \   00000028   0000A003           MOVEQ    R0,#+0
   \   0000002C   1EFF2F01           BXEQ     LR
    338              buf[i]&=~mask;
   \   00000030   0130C3E1           BIC      R3,R3,R1
   \   00000034   0030C2E5           STRB     R3,[R2, #+0]
    339            }
    340          
    341            /* Проверяем, допустимо сочетание или нет. */
    342          
    343            if ((table_2s[i]&mask)!=0) return (1); /* Допустимо. */
   \                     ??work_2s_0:
   \   00000038   ........           LDR      R2,??DataTable6  ;; table_2s
   \   0000003C   0200D0E7           LDRB     R0,[R0, +R2]
   \   00000040   000011E1           TST      R1,R0
   \   00000044   0100A013           MOVNE    R0,#+1
   \   00000048   1EFF2F11           BXNE     LR
    344            return (2);                            /* Недопустимо. */
   \   0000004C   0200A0E3           MOV      R0,#+2
   \   00000050   1EFF2FE1           BX       LR               ;; return
    345          }
    346          
    347          /* =========================================================================
    348          Вспомогательная функция def_code - определение кодировки текста. Функции
    349          m_def_code и f_def_code - лишь надстройки над этой функцией.
    350          Вход:  get_char - указатель на функцию, которую надо вызывать для получения
    351          очередного символа текста. Функция должна возвращать либо
    352          код символа, либо, при достижении конца текста, -1.
    353          n - количество различных сочетаний русских букв (1-255), которого
    354          достаточно для определения кодировки.
    355          Выход: 0 - текст в кодировке ALT, 1 - WIN, 2 - KOI.
    356          ========================================================================= */
    357          

   \                                 In segment CODE, align 4, keep-with-next
    358          unsigned int def_code (void)
    359          {
   \                     def_code:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   41DF4DE2           SUB      SP,SP,#+260
    360            /* В массиве buf_1 хранится информация о том, какие сочетания руских букв
    361            уже встречались в варианте ALT, а в массиве buf_2 - в варианте WIN. */
    362          
    363            unsigned char buf_1 [128];
    364            unsigned char buf_2 [128];
    365          
    366          
    367            unsigned int s=0;
   \   00000008   0010A0E3           MOV      R1,#+0
   \   0000000C   00108DE5           STR      R1,[SP, #+0]
    368          
    369            unsigned int bad_1=0;
    370            unsigned int bad_2=0;
   \   00000010   0150A0E1           MOV      R5,R1
    371            unsigned int bad_3=0;
   \   00000014   0160A0E1           MOV      R6,R1
    372            unsigned int all_1=0;
   \   00000018   0170A0E1           MOV      R7,R1
    373            unsigned int all_3=0;  /* all_2=all_3 */
   \   0000001C   0180A0E1           MOV      R8,R1
    374          
    375            unsigned int c1;
    376            unsigned int c2=0; /* Символы текущего обрабатываемого сочетания. */
   \   00000020   0190A0E1           MOV      R9,R1
    377          
    378            /* Инициализация buf_1 и buf_2. */
    379          
    380            my_memset(buf_1,0xFF,sizeof(buf_1));
   \   00000024   8020A0E3           MOV      R2,#+128
   \   00000028   FF10A0E3           MOV      R1,#+255
   \   0000002C   04008DE2           ADD      R0,SP,#+4
   \   00000030   BB0000EF           SWI      +187
    381            my_memset(buf_2,0xFF,sizeof(buf_2));
   \   00000034   8020A0E3           MOV      R2,#+128
   \   00000038   FF10A0E3           MOV      R1,#+255
   \   0000003C   84008DE2           ADD      R0,SP,#+132
   \   00000040   BB0000EF           SWI      +187
   \   00000044   0040A0E3           MOV      R4,#+0
   \   00000048   020000EA           B        ??def_code_0
    382          
    383            /* Главный цикл - обработка сочетаний для каждого из трёх вариантов. Цикл
    384            выполняется, пока не кончится текст или в каком-либо из вариантов не
    385            встретится n сочетаний. */
    386          
    387            while ((s<16384)&&(all_1<255)&&(all_3<255))
   \                     ??def_code_1:
   \   0000004C   FF0057E3           CMP      R7,#+255
   \   00000050   FF005833           CMPCC    R8,#+255
   \   00000054   5400002A           BCS      ??def_code_2
    388            {
    389              c1=c2;
    390              if ((c2=dstk[s])==0) break;
   \                     ??def_code_0:
   \   00000058   ........           LDR      R2,??DataTable5  ;; dstk
   \   0000005C   00109DE5           LDR      R1,[SP, #+0]
   \   00000060   002092E5           LDR      R2,[R2, #+0]
   \   00000064   0900A0E1           MOV      R0,R9
   \   00000068   0290D1E7           LDRB     R9,[R1, +R2]
   \   0000006C   000059E3           CMP      R9,#+0
   \   00000070   4D00000A           BEQ      ??def_code_2
    391              s++;
   \   00000074   012081E2           ADD      R2,R1,#+1
    392              /* Вариант ALT. Вначале проверяем, являются ли символы текущего сочетания
    393              кодами русских букв в кодировке ALT. */
    394          
    395              if ((((c1>=0x80)&&(c1<0xB0))||((c1>=0xE0)&&(c1<0xF0)))&&
    396          	(((c2>=0x80)&&(c2<0xB0))||((c2>=0xE0)&&(c2<0xF0))))
   \   00000078   ........           LDR      R1,??DataTable6  ;; table_2s
   \   0000007C   00208DE5           STR      R2,[SP, #+0]
   \   00000080   8020A0E3           MOV      R2,#+128
   \   00000084   800050E3           CMP      R0,#+128
   \   00000088   0100003A           BCC      ??def_code_3
   \   0000008C   B00050E3           CMP      R0,#+176
   \   00000090   0300003A           BCC      ??def_code_4
   \                     ??def_code_3:
   \   00000094   E00050E3           CMP      R0,#+224
   \   00000098   2000003A           BCC      ??def_code_5
   \   0000009C   F00050E3           CMP      R0,#+240
   \   000000A0   1E00002A           BCS      ??def_code_5
   \                     ??def_code_4:
   \   000000A4   800059E3           CMP      R9,#+128
   \   000000A8   0100003A           BCC      ??def_code_6
   \   000000AC   B00059E3           CMP      R9,#+176
   \   000000B0   0300003A           BCC      ??def_code_7
   \                     ??def_code_6:
   \   000000B4   E00059E3           CMP      R9,#+224
   \   000000B8   1800003A           BCC      ??def_code_5
   \   000000BC   F00059E3           CMP      R9,#+240
   \   000000C0   1600002A           BCS      ??def_code_5
    397              {
    398                switch (work_2s(alt2num(c1),alt2num(c2),1,buf_1)) /* Обработали. */
   \                     ??def_code_7:
   \   000000C4   0930A0E1           MOV      R3,R9
   \   000000C8   E00053E3           CMP      R3,#+224
   \   000000CC   303043A2           SUBGE    R3,R3,#+48
   \   000000D0   00A0A0E1           MOV      R10,R0
   \   000000D4   E0005AE3           CMP      R10,#+224
   \   000000D8   30A04AA2           SUBGE    R10,R10,#+48
   \   000000DC   1F3003E2           AND      R3,R3,#0x1F
   \   000000E0   1FA00AE2           AND      R10,R10,#0x1F
   \   000000E4   A3C1A0E1           LSR      R12,R3,#+3
   \   000000E8   0AC18CE0           ADD      R12,R12,R10, LSL #+2
   \   000000EC   04A08DE2           ADD      R10,SP,#+4
   \   000000F0   0AE08CE0           ADD      LR,R12,R10
   \   000000F4   00A0DEE5           LDRB     R10,[LR, #+0]
   \   000000F8   073003E2           AND      R3,R3,#0x7
   \   000000FC   3233A0E1           LSR      R3,R2,R3
   \   00000100   0A0013E1           TST      R3,R10
   \   00000104   0500000A           BEQ      ??def_code_5
   \   00000108   03A0CAE1           BIC      R10,R10,R3
   \   0000010C   00A0CEE5           STRB     R10,[LR, #+0]
   \   00000110   01A0DCE7           LDRB     R10,[R12, +R1]
    399                {
    400                case 2: bad_1++;
    401                case 1: all_1++;
   \   00000114   017087E2           ADD      R7,R7,#+1
   \   00000118   0A0013E1           TST      R3,R10
   \   0000011C   01408402           ADDEQ    R4,R4,#+1
    402                }
    403              }
    404              /* Варианты WIN и KOI. Вначале проверяем, являются ли символы текущего
    405              сочетания кодами русских букв в этих кодировках (в обеих кодировках
    406              диапазоны кодов русских букв совпадают). */
    407          
    408              if ((c1&c2)>=0xC0) /* Эквивалентно условию (c1>=0xC0)&&(c2>=0xC0). */
   \                     ??def_code_5:
   \   00000120   003009E0           AND      R3,R9,R0
   \   00000124   C00053E3           CMP      R3,#+192
   \   00000128   1C00003A           BCC      ??def_code_8
    409              {
    410                switch (work_2s(c1&31,c2&31,1,buf_2)) /* Обработали. */
   \   0000012C   1FA009E2           AND      R10,R9,#0x1F
   \   00000130   1F3000E2           AND      R3,R0,#0x1F
   \   00000134   AAB1A0E1           LSR      R11,R10,#+3
   \   00000138   03318BE0           ADD      R3,R11,R3, LSL #+2
   \   0000013C   84B08DE2           ADD      R11,SP,#+132
   \   00000140   0BC083E0           ADD      R12,R3,R11
   \   00000144   00E0DCE5           LDRB     LR,[R12, #+0]
   \   00000148   07A00AE2           AND      R10,R10,#0x7
   \   0000014C   32AAA0E1           LSR      R10,R2,R10
   \   00000150   0AB0A0E1           MOV      R11,R10
   \   00000154   0E001BE1           TST      R11,LR
   \   00000158   1000000A           BEQ      ??def_code_8
   \   0000015C   0BB0CEE1           BIC      R11,LR,R11
   \   00000160   00B0CCE5           STRB     R11,[R12, #+0]
   \   00000164   0130D3E7           LDRB     R3,[R3, +R1]
    411                {
    412                case 0: continue; /* Если сочетание букв уже встречалось в варианте WIN,
    413                то оно уже встречалось и в варианте KOI, так что
    414                пропускаем обработку варианта KOI и переходим
    415                к следующей итерации главного цикла. */
    416                case 2: bad_2++;
    417                }
    418          
    419                /* Если сочетание букв ещё не встречалось в варианте WIN, то оно заведомо
    420                не встречалось и в варианте KOI, поэтому специально проверять это не
    421                надо - значит, функцию work_2s вызываем с параметром check, равным 0. */
    422          
    423                switch (work_2s(koi2num(c1),koi2num(c2),0,NULL)) /* Обработали. */
   \   00000168   1F0000E2           AND      R0,R0,#0x1F
    424                {
    425                case 2: bad_3++;
    426                case 1: all_3++;
   \   0000016C   018088E2           ADD      R8,R8,#+1
   \   00000170   03001AE1           TST      R10,R3
   \   00000174   ........           LDR      R10,??DataTable7  ;; ??t
   \   00000178   1F3009E2           AND      R3,R9,#0x1F
   \   0000017C   0A30D3E7           LDRB     R3,[R3, +R10]
   \   00000180   0A00D0E7           LDRB     R0,[R0, +R10]
   \   00000184   01508502           ADDEQ    R5,R5,#+1
   \   00000188   A3A1A0E1           LSR      R10,R3,#+3
   \   0000018C   00018AE0           ADD      R0,R10,R0, LSL #+2
   \   00000190   0100D0E7           LDRB     R0,[R0, +R1]
   \   00000194   071003E2           AND      R1,R3,#0x7
   \   00000198   320110E1           TST      R0,R2, LSR R1
   \   0000019C   01608602           ADDEQ    R6,R6,#+1
    427                }
    428              }
    429            }
   \                     ??def_code_8:
   \   000001A0   00009DE5           LDR      R0,[SP, #+0]
   \   000001A4   400C50E3           CMP      R0,#+16384
   \   000001A8   A7FFFF3A           BCC      ??def_code_1
    430          
    431            /* Данные собраны. Теперь, если в каком-либо из вариантов недопустимых
    432            сочетаний не больше 1/32 от общего их числа, то считаем, что их и не
    433            было. */
    434          
    435            if (bad_1<=(all_1>>5)) bad_1=0;
   \                     ??def_code_2:
   \   000001AC   A70254E1           CMP      R4,R7, LSR #+5
   \   000001B0   0040A093           MOVLS    R4,#+0
    436            if (bad_2<=(all_3>>5)) bad_2=0;
   \   000001B4   A802A0E1           LSR      R0,R8,#+5
   \   000001B8   050050E1           CMP      R0,R5
   \   000001BC   0050A023           MOVCS    R5,#+0
    437            if (bad_3<=(all_3>>5)) bad_3=0;
   \   000001C0   060050E1           CMP      R0,R6
   \   000001C4   0060A023           MOVCS    R6,#+0
    438          
    439            /* Получаем результат. */
    440          
    441            {
    442              unsigned int a=((255-bad_1)<<8)+all_1;
   \   000001C8   FF0064E2           RSB      R0,R4,#+255
   \   000001CC   000487E0           ADD      R0,R7,R0, LSL #+8
    443              unsigned int b=((255-bad_2)<<8)+all_3;
   \   000001D0   FF1065E2           RSB      R1,R5,#+255
   \   000001D4   011488E0           ADD      R1,R8,R1, LSL #+8
    444              unsigned int c=((255-bad_3)<<8)+all_3;
   \   000001D8   FF2066E2           RSB      R2,R6,#+255
   \   000001DC   022488E0           ADD      R2,R8,R2, LSL #+8
    445          
    446              if ((a>=b)&&(a>=c)) return (0);
   \   000001E0   010050E1           CMP      R0,R1
   \   000001E4   02005021           CMPCS    R0,R2
   \   000001E8   0000A023           MOVCS    R0,#+0
   \   000001EC   0200002A           BCS      ??def_code_9
    447              if (b>=c) return (1); else return (2);
   \   000001F0   020051E1           CMP      R1,R2
   \   000001F4   0100A023           MOVCS    R0,#+1
   \   000001F8   0200A033           MOVCC    R0,#+2
   \                     ??def_code_9:
   \   000001FC   41DF8DE2           ADD      SP,SP,#+260      ;; stack cleaning
   \   00000200   F08FBDE8           POP      {R4-R11,PC}      ;; return
    448            }
    449          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   ........           DC32     win_dos_koi

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     dstk

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   ........           DC32     table_2s

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   ........           DC32     ??t

   Maximum stack usage in bytes:

     Function      CSTACK
     --------      ------
     ConvertFormat   320
     GetCharType_x     0
     alt2num           0
     def_code        296
     koi2num           0
     work_2s           0


   Segment part sizes:

     Function/Label Bytes
     -------------- -----
     ctype           128
     GetCharType_x   140
     ConvertFormat  1140
     table_2s        128
     alt2num          16
     koi2num          16
     t                32
     work_2s          84
     def_code        516
     ??DataTable1      4
     ??DataTable5      4
     ??DataTable6      4
     ??DataTable7      4
      Others          60

 
 1 988 bytes in segment CODE
   288 bytes in segment DATA_C
 
 1 928 bytes of CODE  memory (+ 60 bytes shared)
   288 bytes of CONST memory

Errors: none
Warnings: none
