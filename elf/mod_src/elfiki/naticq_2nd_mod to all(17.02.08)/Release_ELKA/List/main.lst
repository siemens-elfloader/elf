##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.41A/W32 EVALUATION    26/Feb/2008  13:47:25 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\Pasha\elf\mod_src\elfiki\naticq_2nd_mod to        #
#                       all(17.02.08)\main.c                                 #
#    Command line    =  "D:\Pasha\elf\mod_src\elfiki\naticq_2nd_mod to       #
#                       all(17.02.08)\main.c" -D NEWSGOLD -D ELKA            #
#                       --preprocess "D:\Pasha\elf\mod_src\elfiki\naticq_2nd #
#                       _mod to all(17.02.08)\Release_ELKA\List\" -lC        #
#                       "D:\Pasha\elf\mod_src\elfiki\naticq_2nd_mod to       #
#                       all(17.02.08)\Release_ELKA\List\" -o                 #
#                       "D:\Pasha\elf\mod_src\elfiki\naticq_2nd_mod to       #
#                       all(17.02.08)\Release_ELKA\Obj\" -s9 --no_unroll     #
#                       --cpu_mode arm --endian little --cpu ARM926EJ-S      #
#                       --stack_align 4 --interwork -e --fpu None            #
#                       --dlib_config "D:\Pasha\ARM_Embedded_Workbench\Embed #
#                       ded Workbench 4.0 Evaluation\ARM\LIB\dl5tpainl8n.h"  #
#                       -I "D:\Pasha\ARM_Embedded_Workbench\Embedded         #
#                       Workbench 4.0 Evaluation\ARM\INC\"                   #
#                       --inline_threshold=2                                 #
#    List file       =  D:\Pasha\elf\mod_src\elfiki\naticq_2nd_mod to        #
#                       all(17.02.08)\Release_ELKA\List\main.lst             #
#    Object file     =  D:\Pasha\elf\mod_src\elfiki\naticq_2nd_mod to        #
#                       all(17.02.08)\Release_ELKA\Obj\main.r79              #
#                                                                            #
#                                                                            #
##############################################################################

D:\Pasha\elf\mod_src\elfiki\naticq_2nd_mod to all(17.02.08)\main.c
      1          #include "../inc/swilib.h"
      2          #include "../inc/cfg_items.h"
      3          #include "../inc/pnglist.h"

  void SendAnswer(int dummy, TPKT *p);
                             ^
"D:\Pasha\elf\mod_src\elfiki\naticq_2nd_mod to all(17.02.08)\main.h",5  Error[Pe020]: 
          identifier "TPKT" is undefined

  void CreateEditChat(CLIST *t);
                      ^
"D:\Pasha\elf\mod_src\elfiki\naticq_2nd_mod to all(17.02.08)\main.h",6  Error[Pe020]: 
          identifier "CLIST" is undefined

  int GetIconIndex(CLIST *t);
                   ^
"D:\Pasha\elf\mod_src\elfiki\naticq_2nd_mod to all(17.02.08)\main.h",17  Error[Pe020]: 
          identifier "CLIST" is undefined

  void FreeLOGQ(LOGQ **pp);
                ^
"D:\Pasha\elf\mod_src\elfiki\naticq_2nd_mod to all(17.02.08)\main.h",20  Error[Pe020]: 
          identifier "LOGQ" is undefined

    CLIST *ed_contact;
    ^
"D:\Pasha\elf\mod_src\elfiki\naticq_2nd_mod to all(17.02.08)\main.h",25  Error[Pe020]: 
          identifier "CLIST" is undefined
      4          #include "NatICQ.h"
      5          #include "history.h"
      6          #include "conf_loader.h"
      7          #include "mainmenu.h"
      8          #include "main.h"
      9          #include "language.h"
     10          #include "../inc/xtask_ipc.h"
     11          #include "smiles.h"
     12          #include "naticq_ipc.h"
     13          #include "status_change.h"
     14          #include "strings.h"
     15          #include "manage_cl.h"
     16          #include "cl_work.h"
     17          #include "select_smile.h"
     18          #include "revision.h"
     19          #ifdef EVILFOX
     20          #include "print.h"
     21          #endif
     22          
     23          #ifndef NEWSGOLD
     24          #define SEND_TIMER
     25          #endif
     26          
     27          int total_unread;
     28          #define EOP -10
     29          int CurrentStatus;
     30          int CurrentXStatus;
     31          volatile CLIST *cltop;
     32          
     33          #ifdef EVILFOX
     34          //=========================mod definitions
     35          #ifdef ELKA
     36          #pragma swi_number=54
     37          __swi __arm void SLI_SetState(unsigned char state);  //for sli usage
     38          #endif
     39          #ifdef NEWSGOLD
     40          #pragma swi_number=0x0C5
     41          __swi __arm int IsIdleUiOnTop(); //for check if idlegui
     42          #endif
     43          char upcoming[64]; //for nick that comes online
     44          int total_unread2; //for total unread mesages
     45          int total_c_online; //for count of contacts who just came online
     46          #ifdef ELKA
     47          int Is_SLI_On; //for checking if is active sli
     48          GBSTMR mytmr; //timer for sli
     49          #endif
     50          //extern const int SLI_TYPE; //for check where to activate sli
     51          int Is_ILU_On; // for ilumination use
     52          int seconds; //sekundes
     53          int minutes; //minuutes
     54          int hours; //hours
     55          GBSTMR ctmr; //time counter
     56          char online_txt[18]; //online txt
     57          extern const unsigned int ONTIME_X; //cordinates for online time ms
     58          extern const unsigned int ONTIME_Y; //cordinates for online time ms
     59          extern const int Pause_Time; // for time refresher
     60          int align=0; //align for png font
     61          extern const unsigned int fonto; // font number
     62          extern const unsigned int spaco1; // space between letters in png font
     63          extern const unsigned int spaco2; // space between letters in png font
     64          extern const unsigned int system_color; //system font color
     65          int spaco1r; //display
     66          extern const char fontpath[64]; //font path for png
     67          int time_draw; //refresh for mainscreen
     68          void *canvasdata; //just canvasdata
     69          int show_ping; //for autoping not show
     70          int ping_sec; //for autoping engaging
     71          extern const int Show_Ping; //do ping if 1
     72          extern const unsigned int PING_X; //cordinates for ping ms
     73          extern const unsigned int PING_Y; //cordinates for ping ms
     74          char ping_txt[16]; // ping txt
     75          extern const unsigned int UNREAD_X; //cordinates for unread ms
     76          extern const unsigned int UNREAD_Y; //cordinates for unread ms
     77          char unread_txt[16]; //unread msg txt
     78          extern const int Is_Unread_On; //show/hide unread on ms
     79          extern const int Is_Online_On; //show/hide online time on ms
     80          int INC_show; //for popup sender counter
     81          char show_nick[64]; //nick save for popup sender
     82          int Is_INC_On; // show//hide popup sender
     83          GBSTMR incs; // popup sendet timer
     84          #ifdef ELKA
     85          int font=9; // font for popup sender
     86          #else
     87          #ifdef NEWSGOLD
     88          int font=11; // font for popup sender
     89          #else
     90          int font=7; // font for popup sender
     91          #endif
     92          #endif
     93          //const char color[4]={255,255,255,100}; //  color for popup sender
     94          int pp_color; //  color for popup sender
     95          extern const int Is_DRAWMAIN_On; //show/hide main msg
     96          int main_d; // refresher for main msg
     97          extern const unsigned int MSG_Y; // cordinates for main msg
     98          extern const unsigned int MSG_X; // cordinates for main msg
     99          int paused_height; // vertical height of font
    100          int in_count; // count incoming messages
    101          int out_count; // count outgoing messages
    102          #ifdef ELKA
    103          char last_msg_buffer[3072]; // last message buffer
    104          #endif
    105          int comanda; //for check comand to add it to log
    106          int msg_away_timer; // time for autostatus
    107          extern const unsigned int AUTO_ENGADE; //time to start autostatus
    108          int change_back_status; //to do changeback or not
    109          int status_rem; //remember your status before change
    110          char away_msg_time[64]; //away time char
    111          char away_msg[256]; // away txt
    112          int away_m; //use to check if auto time engaged
    113          extern const int Auto_Status; //use autostatus or not to use
    114          extern const char away_msg1[24]; //for hello msg in autostatus
    115          extern const char away_msg2[64]; //for automsg txt
    116          extern const int time_zone; //for time zone initialization
    117          char tim_zone[24]; //timezone txt
    118          int In_EXT_On; //to initialize extended sounds
    119          char ext_sound[128]; //path to play or init ext sound
    120          extern const char sndMsg2[64]; //path to extended sounds
    121          int total_count; //counter for extender sound info display
    122          int in_ext; //counter for extender sound info display
    123          char LG_MENU2[32]; //moved menu name here for my needs
    124          extern const unsigned int main_draw_l; // lenght of txt to draw on main
    125          extern const int TIME_OR_MSG; // for check what to draw with main header
    126          int icon_change; //for icon change on ms
    127          int icon_change2; //for icon change on ms
    128          extern int *XStatusesIconArray; // strange need but ok
    129          char mod_info[]="2nd generation mod based on revision 1848! mod date: 19.02.08 14:02!"; //just info for mod info
    130          //=========================end
    131          #endif
    132          
    133          #ifdef EVILFOX
    134          //=========================modification functions
    135          #ifdef ELKA
    136          void SLI_Off(void);
    137          void SLI_On()
    138          {
    139            if (total_unread)
    140            {
    141            SLI_SetState(1);   
    142            GBS_StartTimerProc(&mytmr, 21, SLI_Off);
    143            }
    144            else
    145              SLI_SetState(0);
    146          }
    147          
    148          void SLI_Off()
    149          {
    150            SLI_SetState(2);
    151            if (total_unread)
    152              GBS_StartTimerProc(&mytmr, 21, SLI_On); //26*SLI_time2
    153            else
    154              SLI_SetState(0);
    155          }
    156          
    157          void SLI_Timer()
    158          {
    159            if(Is_SLI_On)
    160            GBS_StartTimerProc(&mytmr, 262, SLI_On); //262*SLI_time
    161          }
    162          #endif
    163          //===============time count=========
    164          void time_count()
    165          {
    166            seconds++;
    167            if(seconds==60)
    168            {
    169              seconds=0;
    170              minutes++;
    171            }
    172            if(minutes==60)
    173            {
    174              minutes=0;
    175              hours++;
    176            }
    177          }
    178          
    179          void time_counter()
    180          {
    181            if(connect_state==3)
    182            {
    183            time_count();
    184            GBS_StartTimerProc(&ctmr, 216, time_counter);
    185            }
    186            else
    187            {
    188              if(!Pause_Time)
    189              {
    190              seconds=0;
    191              minutes=0;
    192              hours=0;
    193              }
    194              GBS_StartTimerProc(&ctmr, 216, time_counter);
    195            }
    196            time_draw=1;
    197          }
    198          //=========================time count=====
    199          //=========================mainscreen ping===============
    200          static void PingToServer2(void)
    201          {
    202            TPKT *p;
    203            p=malloc(sizeof(PKT)+sizeof(TTime));
    204            GetDateTime(NULL,(TTime *)p->data);
    205            p->pkt.uin=0;
    206            p->pkt.type=T_ECHO;
    207            p->pkt.data_len=sizeof(TTime);
    208            SUBPROC((void *)SendAnswer,0,p);
    209          }
    210          //=========================mainscreen ping==============
    211          
    212          //=========================popup sender=========================
    213          void show_pp_sender()
    214          {
    215            if(INC_show>0)
    216            {
    217              WSHDR *ws=AllocWS(64);
    218              ascii2ws(ws,show_nick);
    219              DrawRectangle(0,0,Get_WS_width(ws,font)+2,GetFontYSIZE(font)+2,0,GetPaletteAdrByColorIndex(1),GetPaletteAdrByColorIndex(1));
    220              DrawString(ws,1,1,1+Get_WS_width(ws,font)+2,1+GetFontYSIZE(font),font,0,GetPaletteAdrByColorIndex(pp_color),GetPaletteAdrByColorIndex(23));
    221              FreeWS(ws);
    222              INC_show--;
    223              GBS_StartTimerProc(&incs, 5, show_pp_sender);
    224            }
    225          }
    226          //==================================popup sender===============
    227          //===========================main msg add===================
    228          char a_txt[64];
    229          char s_txt[64];
    230          char d_txt[64];
    231          char f_txt[64];
    232          char g_txt[64];
    233                       
    234          static AddToMain(const char *nameu,const char *si)
    235          {
    236            char de[64];
    237            char du[64];
    238            int text_l=0;
    239            int iz=0;
    240            int name_l=0;
    241            name_l=strlen(nameu);
    242            text_l=main_draw_l-name_l;
    243            
    244            if(strlen(si)>text_l)
    245            {
    246              strncpy(du,si,text_l);
    247              du[text_l]='\0';
    248              sprintf(de,"%s%s",du,"...");
    249            }
    250            else
    251              strcpy(de, si);
    252            iz=0;
    253            while(strlen(de)!=iz)
    254            {
    255              if((de[iz]==0x0D)||(de[iz]==0x0A)) de[iz]=0x20;
    256              iz++;
    257            }
    258            de[iz]='\0';
    259            strcpy(a_txt, s_txt);
    260            strcpy(s_txt, d_txt);
    261            strcpy(d_txt, f_txt);
    262            strcpy(f_txt, g_txt);
    263            sprintf(g_txt, "%s: %s", nameu,de);
    264            main_d=1;
    265          }  
    266          //=================================main msg add============
    267          //==================================autostatus=============
    268          void away_engage()
    269          {
    270              TTime tt;
    271              GetDateTime(NULL,&tt);
    272              sprintf(away_msg_time, "(away since %02d : %02d ( %s ) )", tt.hour, tt.min, tim_zone);
    273              away_m=1;
    274              if(CurrentStatus!=2)
    275              {
    276                status_rem=CurrentStatus;
    277                CurrentStatus=2;
    278                set_my_status();
    279                change_back_status=1;
    280              }
    281          }
    282          
    283          int my_keyhook(int key, int m)
    284          {
    285            if (m==KEY_DOWN)
    286                 {
    287                   if(change_back_status==1)
    288                   {
    289                     CurrentStatus=status_rem;
    290                     set_my_status();
    291                     change_back_status=0;
    292                   }
    293          #ifdef ELKA
    294                   if ((key==VOL_DOWN_BUTTON)&&(IsIdleUiOnTop()))
    295                   {
    296                     msg_away_timer=AUTO_ENGADE;
    297                     away_engage();
    298                   }
    299                   else
    300          #endif
    301                     msg_away_timer=away_m=0;
    302                 }
    303            return 0;
    304          }
    305          
    306          void init_time_zone()
    307          {
    308            switch(time_zone)
    309            {
    310            case 0:
    311              sprintf(tim_zone, "GMT -12:00");
    312              break;
    313            case 1:
    314              sprintf(tim_zone, "GMT -11:00");
    315              break;
    316            case 2:
    317              sprintf(tim_zone, "GMT -10:00");
    318              break;
    319            case 3:
    320              sprintf(tim_zone, "GMT -09:00");
    321              break;
    322            case 4:
    323              sprintf(tim_zone, "GMT -08:00");
    324              break;
    325            case 5:
    326              sprintf(tim_zone, "GMT -07:00");
    327              break;
    328            case 6:
    329              sprintf(tim_zone, "GMT -06:00");
    330              break;
    331            case 7:
    332              sprintf(tim_zone, "GMT -05:00");
    333              break;
    334            case 8:
    335              sprintf(tim_zone, "GMT -04:00");
    336              break;
    337            case 9:
    338              sprintf(tim_zone, "GMT -03:30");
    339              break;
    340            case 10:
    341              sprintf(tim_zone, "GMT -03:00");
    342              break;
    343            case 11:
    344              sprintf(tim_zone, "GMT -02:00");
    345              break;
    346            case 12:
    347              sprintf(tim_zone, "GMT -01:00");
    348              break;
    349            case 13:
    350              sprintf(tim_zone, "GMT 00:00");
    351              break;
    352            case 14:
    353              sprintf(tim_zone, "GMT +01:00");
    354              break;
    355            case 15:
    356              sprintf(tim_zone, "GMT +02:00");
    357              break;
    358            case 16:
    359              sprintf(tim_zone, "GMT +03:00");
    360              break;
    361            case 17:
    362              sprintf(tim_zone, "GMT +03:30");
    363              break;
    364            case 18:
    365              sprintf(tim_zone, "GMT +04:00");
    366              break;
    367            case 19:
    368              sprintf(tim_zone, "GMT +04:30");
    369              break;
    370            case 20:
    371              sprintf(tim_zone, "GMT +05:00");
    372              break;
    373            case 21:
    374              sprintf(tim_zone, "GMT +05:30");
    375              break;
    376            case 22:
    377              sprintf(tim_zone, "GMT +05:45");
    378              break;
    379            case 23:
    380              sprintf(tim_zone, "GMT +06:00");
    381              break;
    382            case 24:
    383              sprintf(tim_zone, "GMT +06:30");
    384              break;
    385            case 25:
    386              sprintf(tim_zone, "GMT +07:00");
    387              break;
    388            case 26:
    389              sprintf(tim_zone, "GMT +08:00");
    390              break;
    391            case 27:
    392              sprintf(tim_zone, "GMT +09:00");
    393              break;
    394            case 28:
    395              sprintf(tim_zone, "GMT +09:30");
    396              break;
    397            case 29:
    398              sprintf(tim_zone, "GMT +10:00");
    399              break;
    400            case 30:
    401              sprintf(tim_zone, "GMT +11:00");
    402              break;
    403            case 31:
    404              sprintf(tim_zone, "GMT +12:00");
    405              break;
    406            case 32:
    407              sprintf(tim_zone, "GMT +13:00");
    408              break;
    409            }
    410          }
    411          //==================================autostatus=============
    412          //============================init extended sounds=============
    413          void Init_Ext_Sounds(void)
    414          {
    415            total_count=0;
    416            in_ext=0;
    417          //  unsigned int uli;
    418            char msgboxer[64];
    419            CLIST *t;
    420            t=(CLIST *)(&cltop);
    421            while(t=(CLIST *)(t->next))
    422            {
    423              if(!t->isgroup)
    424              {
    425                total_count++;
    426                volatile int hFile_ex;
    427                unsigned int io_error_ex = 0;
    428                sprintf(ext_sound, "%s%d.wav", sndMsg2, t->uin);
    429                hFile_ex = fopen(ext_sound,A_ReadOnly + A_BIN,P_READ, &io_error_ex);
    430                if(hFile_ex!=-1)
    431                {
    432                  in_ext++;
    433                  t->ext_snd=1;
    434                  fclose(hFile_ex, &io_error_ex);
    435                }
    436                else
    437                  t->ext_snd=0;
    438              }
    439            }
    440            sprintf(msgboxer, "Complete!\n"
    441                    "Enabled for:\n"
    442                      "%d / %d contacts",
    443                      in_ext, total_count);
    444            sprintf(LG_MENU2, "Меню <Ext:%d/%d>", in_ext, total_count);
    445            ShowMSG(1,(int)msgboxer);
    446          }
    447          //============================init extended sounds=============
    448          //=========================end of modification functions
    449          #endif
    450          
    451          char hostname[128];
    452          extern volatile int total_smiles;
    453          extern volatile int total_xstatuses;
    454          extern volatile int xstatuses_load;
    455          
    456          #define USE_MLMENU
    457          
    458          #define TMR_SECOND 216
    459          
    460          //IPC
    461          const char ipc_my_name[32]=IPC_NATICQ_NAME;
    462          const char ipc_xtask_name[]=IPC_XTASK_NAME;
    463          IPC_REQ gipc;
    464          
    465          
    466          char elf_path[256];
    467          int maincsm_id;
    468          int maingui_id;
    469          
    470          void SMART_REDRAW(void)
    471          {
    472            int f;
    473            LockSched();
    474            f=IsGuiOnTop(maingui_id);
    475            UnlockSched();
    476            if (f) REDRAW();
    477          }
    478          
    479          //По 10 секунд
    480          #ifdef EVILFOX
    481          #define ACTIVE_TIME 30
    482          #else
    483          #define ACTIVE_TIME 360
    484          #endif
    485          
    486          //Максимальное количество сообщений в логе
    487          #define MAXLOGMSG (20)
    488          
    489          // Строковые описания статусов
    490          
    491          const char S_OFFLINE[]="Offline";
    492          const char S_INVISIBLE[]="Invisible";
    493          const char S_AWAY[]="Away";
    494          const char S_NA[]="N/A";
    495          const char S_OCCUPIED[]="Occupied";
    496          const char S_DND[]="DND";
    497          const char S_ONLINE[]="Online";
    498          const char S_FFC[]="FFC";
    499          
    500          volatile int SENDMSGCOUNT;
    501          
    502          int IsActiveUp=0;
    503          
    504          int Is_Vibra_Enabled;
    505          unsigned int Is_Sounds_Enabled;
    506          int Is_Show_Offline;
    507          int Is_Show_Groups;
    508          
    509          int S_ICONS[TOTAL_ICONS+1];
    510          
    511          
    512          
    513          WSHDR *ews;
    514          
    515          extern const unsigned int UIN;
    516          extern const char PASS[];
    517          
    518          static const char * const icons_names[TOTAL_ICONS]=
    519          {
    520            "offline.png",
    521            "invisible.png",
    522            "away.png",
    523            "na.png",
    524            "occupied.png",
    525            "dnd.png",
    526            "depression.png",
    527            "evil.png",
    528            "home.png",
    529            "lunch.png",
    530            "work.png",
    531            "online.png",
    532            "ffc.png",
    533            "message.png",
    534            "unknown.png",
    535            "groupon.png",
    536            "groupoff.png",
    537            "null.png",
    538            "addcont.png",
    539            "head.png",
    540            "logo.png",
    541            "ping.png",
    542            "settings.png",
    543            "vis1.png",
    544            "vis2.png",
    545            "vis3.png",
    546            "vis4.png",
    547            "vis5.png"
    548          };
    549          
    550          extern const char ICON_PATH[];
    551          
    552          void setup_ICONS(void)
    553          {
    554            int i=0;
    555            do
    556            {
    557              if (!S_ICONS[i]) S_ICONS[i]=(int)MakeGlobalString(ICON_PATH,'\\',icons_names[i]);
    558              i++;
    559            }
    560            while(i<TOTAL_ICONS);
    561            return;
    562          }
    563          
    564          void free_ICONS(void)
    565          {
    566            int i=0;
    567            do
    568            {
    569              mfree((void*)S_ICONS[i]);
    570              S_ICONS[i]=0;
    571              i++;
    572            }
    573            while(i<TOTAL_ICONS);
    574            return;
    575          }
    576          
    577          extern const unsigned int IDLEICON_X;
    578          extern const unsigned int IDLEICON_Y;
    579          
    580          extern const unsigned int I_COLOR;
    581          extern const unsigned int TO_COLOR;
    582          extern const unsigned int X_COLOR;
    583          extern const unsigned int O_I_COLOR;
    584          extern const unsigned int O_TO_COLOR;
    585          extern const unsigned int O_X_COLOR;
    586          
    587          extern const unsigned int ED_FONT_SIZE;
    588          extern const unsigned int ED_H_FONT_SIZE;
    589          extern const unsigned int ED_X_FONT_SIZE;
    590          extern const unsigned int O_ED_FONT_SIZE;
    591          extern const unsigned int O_ED_H_FONT_SIZE;
    592          extern const unsigned int O_ED_X_FONT_SIZE;
    593          
    594          extern const unsigned int ACK_COLOR;
    595          extern const unsigned int UNACK_COLOR;
    596          
    597          extern const int ENA_AUTO_XTXT;
    598          extern const int NOT_LOG_SAME_XTXT;
    599          extern const int LOG_XTXT;
    600          
    601          extern const int HISTORY_BUFFER;
    602          
    603          const char percent_t[]="%t";
    604          const char percent_d[]="%d";
    605          const char empty_str[]="";
    606          const char I_str[]="I";
    607          const char x_status_change[]="X-Status change";
    608          
    609          char logmsg[256];
    610          
    611          //Illumination by BoBa 19.04.2007
    612          ///////////
    613          extern const unsigned int ILL_DISP_RECV;
    614          extern const unsigned int ILL_KEYS_RECV;
    615          extern const unsigned int ILL_DISP_SEND;
    616          extern const unsigned int ILL_KEYS_SEND;
    617          extern const unsigned int ILL_SEND_TMR;
    618          extern const unsigned int ILL_SEND_FADE;
    619          extern const unsigned int ILL_RECV_TMR;
    620          extern const unsigned int ILL_RECV_FADE;
    621          extern const unsigned int ILL_OFF_FADE;
    622          
    623          GBSTMR tmr_illumination;
    624          
    625          void IlluminationOff(){
    626            SetIllumination(0,1,0,ILL_OFF_FADE);
    627            SetIllumination(1,1,0,ILL_OFF_FADE);
    628          }
    629          
    630          void IlluminationOn(const int disp, const int key, const int tmr, const int fade){
    631            if(!tmr) return;
    632            GBS_DelTimer(&tmr_illumination);
    633            SetIllumination(0,1,disp,fade);
    634            SetIllumination(1,1,key,fade);
    635            GBS_StartTimerProc(&tmr_illumination,tmr*216,IlluminationOff);
    636          }
    637          
    638          volatile int silenthide;    //by BoBa 25.06.07
    639          volatile int disautorecconect;	//by BoBa 10.07
    640          ///////////
    641          int Is_Vibra_Enabled;
    642          unsigned int Is_Sounds_Enabled;
    643          int Is_Show_Offline;
    644          int Is_Show_Groups;
    645          int CurrentStatus;
    646          int CurrentXStatus;
    647          int CurrentPrivateStatus;
    648          
    649          //===================================================================
    650          const char def_setting[]="%sdef_settings_%d";
    651          
    652          void ReadDefSettings(void)
    653          {
    654            DEF_SETTINGS def_set;
    655            int f;
    656            unsigned int err;
    657            char str[128];
    658            snprintf(str,127,def_setting,elf_path,UIN);
    659            if ((f=fopen(str,A_ReadOnly+A_BIN,P_READ,&err))!=-1)
    660            {
    661              fread(f,&def_set,sizeof(DEF_SETTINGS),&err);
    662              fclose(f,&err);
    663              Is_Vibra_Enabled=def_set.vibra_status;
    664              Is_Sounds_Enabled=def_set.sound_status;
    665              Is_Show_Offline=def_set.off_contacts;
    666              Is_Show_Groups=def_set.show_groups;
    667              CurrentStatus=def_set.def_status+1;
    668              CurrentXStatus=def_set.def_xstatus;
    669          #ifdef EVILFOX
    670          #ifdef ELKA
    671              Is_SLI_On=def_set.sli_state;
    672          #endif
    673              Is_ILU_On=def_set.ilu_state;
    674              Is_INC_On=def_set.inc_state;
    675          #endif
    676            }
    677            else
    678            {
    679              Is_Vibra_Enabled=0;
    680              Is_Sounds_Enabled=0;
    681              Is_Show_Offline=0;
    682              Is_Show_Groups=1;
    683              CurrentStatus=IS_ONLINE;
    684              CurrentXStatus=0;
    685          #ifdef ELKA
    686              Is_SLI_On=1;
                     ^
Error[Pe020]: identifier "Is_SLI_On" is undefined
    687          #endif
    688              Is_ILU_On=0;
                     ^
Error[Pe020]: identifier "Is_ILU_On" is undefined
    689              Is_INC_On=1;
                     ^
Error[Pe020]: identifier "Is_INC_On" is undefined
    690            }
    691          }
    692          
    693          void WriteDefSettings(void)
    694          {
    695            DEF_SETTINGS def_set;
    696            int f;
    697            unsigned int err;
    698            char str[128];
    699            snprintf(str,127,def_setting,elf_path,UIN);
    700            if ((f=fopen(str,A_WriteOnly+A_BIN+A_Create+A_Truncate,P_WRITE,&err))!=-1)
    701            {
    702              def_set.vibra_status=Is_Vibra_Enabled;
    703              def_set.sound_status=Is_Sounds_Enabled;
    704              def_set.off_contacts=Is_Show_Offline;
    705              def_set.show_groups=Is_Show_Groups;
    706              def_set.def_status=CurrentStatus-1;
    707              def_set.def_xstatus=CurrentXStatus;
    708          #ifdef EVILFOX
    709          #ifdef ELKA
    710              def_set.sli_state=Is_SLI_On;
    711          #endif
    712              def_set.ilu_state=Is_ILU_On;
    713              def_set.inc_state=Is_INC_On;
    714          #endif
    715              fwrite(f,&def_set,sizeof(DEF_SETTINGS),&err);
    716              fclose(f,&err);
    717            }
    718          }
    719          //by KreN 27.09.2007
    720          //===================================================================
    721          extern S_SMILES *s_top;
    722          extern DYNPNGICONLIST *SmilesImgList;
    723          extern DYNPNGICONLIST *XStatusesImgList;
    724          
    725          //=============================Проигрывание звука=======================
    726          extern const char sndStartup[];
    727          extern const char sndSrvMsg[];
    728          extern const char sndGlobal[];
    729          extern const char sndMsg[];
    730          extern const char sndMsgSent[];
    731          extern const unsigned int sndVolume;
    732          
    733          
    734          void Play(const char *fname)
    735          {
    736            if ((!IsCalling())&&Is_Sounds_Enabled)
    737            {
    738              FSTATS fstats;
    739              unsigned int err;
    740              if (GetFileStats(fname,&fstats,&err)!=-1)
    741              {
    742                PLAYFILE_OPT _sfo1;
    743                WSHDR* sndPath=AllocWS(128);
    744                WSHDR* sndFName=AllocWS(128);
    745                char s[128];
    746                const char *p=strrchr(fname,'\\')+1;
    747                str_2ws(sndFName,p,128);
    748                strncpy(s,fname,p-fname);
    749                s[p-fname]='\0';
    750                str_2ws(sndPath,s,128);
    751          
    752                zeromem(&_sfo1,sizeof(PLAYFILE_OPT));
    753                _sfo1.repeat_num=1;
    754                _sfo1.time_between_play=0;
    755                _sfo1.play_first=0;
    756                _sfo1.volume=sndVolume;
    757          #ifdef NEWSGOLD
    758                _sfo1.unk6=1;
    759                _sfo1.unk7=1;
    760                _sfo1.unk9=2;
    761                PlayFile(0x10, sndPath, sndFName, GBS_GetCurCepid(), MSG_PLAYFILE_REPORT, &_sfo1);
    762          #else
    763          #ifdef X75
    764                _sfo1.unk4=0x80000000;
    765                _sfo1.unk5=1;
    766                PlayFile(0xC, sndPath, sndFName, 0,GBS_GetCurCepid(), MSG_PLAYFILE_REPORT, &_sfo1);
    767          #else
    768                _sfo1.unk5=1;
    769                PlayFile(0xC, sndPath, sndFName, GBS_GetCurCepid(), MSG_PLAYFILE_REPORT, &_sfo1);
    770          #endif
    771          #endif
    772                FreeWS(sndPath);
    773                FreeWS(sndFName);
    774              }
    775            }
    776          }
    777          
    778          GBSTMR tmr_vibra;
    779          volatile int vibra_count;
    780          
    781          void start_vibra(void)
    782          {
    783            extern const int VIBR_TYPE;
    784            void stop_vibra(void);
    785            if((Is_Vibra_Enabled)&&(!IsCalling()))
    786            {
    787              extern const unsigned int vibraPower;
    788              SetVibration(vibraPower);
    789              if(VIBR_TYPE)
    790                GBS_StartTimerProc(&tmr_vibra,TMR_SECOND>>2,stop_vibra);
    791              else
    792                GBS_StartTimerProc(&tmr_vibra,TMR_SECOND>>1,stop_vibra);
    793            }
    794          }
    795          
    796          void stop_vibra(void)
    797          {
    798            extern const int VIBR_TYPE;
    799            SetVibration(0);
    800            if (--vibra_count)
    801            {
    802              if(VIBR_TYPE)
    803                GBS_StartTimerProc(&tmr_vibra,TMR_SECOND>>5,start_vibra);
    804              else
    805                GBS_StartTimerProc(&tmr_vibra,TMR_SECOND>>1,start_vibra);
    806            }
    807          }
    808          
    809          void ChangeVibra(void)
    810          {
    811            if (!(Is_Vibra_Enabled=!(Is_Vibra_Enabled)))
    812              ShowMSG(1,(int)LG_MSGVIBRADIS);
    813            else
    814              ShowMSG(1,(int)LG_MSGVIBRAENA);
    815          }
    816          
    817          void ChangeSound(void)
    818          {
    819            if (!(Is_Sounds_Enabled=!(Is_Sounds_Enabled)))
    820              ShowMSG(1,(int)LG_MSGSNDDIS);
    821            else
    822              ShowMSG(1,(int)LG_MSGSNDENA);
    823          }
    824          
    825          //===================================================================
    826          //Templates
    827          char *templates_chars; //Собственно файл
    828          char **templates_lines; //Массив указателей на строки
    829          
    830          void FreeTemplates(void)
    831          {
    832            if (templates_lines) mfree(templates_lines);
    833            if (templates_chars) mfree(templates_chars);
    834            templates_lines=NULL;
    835            templates_chars=NULL;
    836          }
    837          
    838          extern const char TEMPLATES_PATH[];
    839          
    840          int LoadTemplates(unsigned int uin)
    841          {
    842            FSTATS stat;
    843            char fn[256];
    844            int f;
    845            unsigned int ul;
    846            int i;
    847            int fsize;
    848            char *p;
    849            char *pp;
    850            int c;
    851            FreeTemplates();
    852            strcpy(fn,TEMPLATES_PATH);
    853            i=strlen(fn);
    854            sprintf(fn+i,"\\%d.txt",uin);
    855            if (GetFileStats(fn,&stat,&ul)==-1) goto L1;
    856            if ((fsize=stat.size)<=0) goto L1;
    857            if ((f=fopen(fn,A_ReadOnly+A_BIN,P_READ,&ul))==-1)
    858            {
    859            L1:
    860              strcpy(fn+i,"\\0.txt");
    861              if (GetFileStats(fn,&stat,&ul)==-1) return 0;
    862              if ((fsize=stat.size)<=0) return 0;
    863              f=fopen(fn,A_ReadOnly+A_BIN,P_READ,&ul);
    864            }
    865            if (f==-1) return 0;
    866            p=templates_chars=malloc(fsize+1);
    867            p[fread(f,p,fsize,&ul)]=0;
    868            fclose(f,&ul);
    869            i=0;
    870            pp=p;
    871            for(;;)
    872            {
    873              c=*p;
    874              if (c<32)
    875              {
    876                if (pp&&(pp!=p))
    877                {
    878          	templates_lines=realloc(templates_lines,(i+1)*sizeof(char *));
    879          	templates_lines[i++]=pp;
    880                }
    881                pp=NULL;
    882                if (!c) break;
    883                *p=0;
    884              }
    885              else
    886              {
    887                if (pp==NULL) pp=p;
    888              }
    889              p++;
    890            }
    891            return i;
    892          }
    893          
    894          
    895          //===================================================================
    896          
    897          typedef struct
    898          {
    899            CSM_RAM csm;
    900            int gui_id;
    901          }MAIN_CSM;
    902          
    903          typedef struct
    904          {
    905            GUI gui;
    906            WSHDR *ws1;
    907            WSHDR *ws2;
    908            int i1;
    909          }MAIN_GUI;
    910          
    911          
    912          
    913          int RXstate=EOP; //-sizeof(RXpkt)..-1 - receive header, 0..RXpkt.data_len - receive data
    914          
    915          TPKT RXbuf;
    916          TPKT TXbuf;
    917          
    918          int connect_state=0;
    919          
    920          int sock=-1;
    921          
    922          volatile unsigned long TOTALRECEIVED;
    923          volatile unsigned long TOTALSENDED;
    924          volatile unsigned long ALLTOTALRECEIVED;	//by BoBa 10.07
    925          volatile unsigned long ALLTOTALSENDED;
    926          
    927          volatile int sendq_l=0; //Длинна очереди для send
    928          volatile void *sendq_p=NULL; //указатель очереди
    929          
    930          volatile int is_gprs_online=1;
    931          
    932          GBSTMR reconnect_tmr;
    933          
    934          extern void kill_data(void *p,void (*func_p)(void *));
    935          
    936          void ElfKiller(void)
    937          {
    938            extern void *ELF_BEGIN;
    939            kill_data(&ELF_BEGIN,(void (*)(void *))mfree_adr());
    940          }
    941          
    942          
    943          
    944          //===============================================================================================
    945          #pragma inline
    946          void patch_rect(RECT*rc,int x,int y, int x2, int y2)
    947          {
    948            rc->x=x;
    949            rc->y=y;
    950            rc->x2=x2;
    951            rc->y2=y2;
    952          }
    953          
    954          #pragma inline
    955          void patch_header(const HEADER_DESC* head)
    956          {
    957            ((HEADER_DESC*)head)->rc.x=0;
    958            ((HEADER_DESC*)head)->rc.y=YDISP;
    959            ((HEADER_DESC*)head)->rc.x2=ScreenW()-1;
    960            ((HEADER_DESC*)head)->rc.y2=HeaderH()+YDISP-1;
    961          }
    962          #pragma inline
    963          void patch_input(const INPUTDIA_DESC* inp)
    964          {
    965            ((INPUTDIA_DESC*)inp)->rc.x=0;
    966            ((INPUTDIA_DESC*)inp)->rc.y=HeaderH()+1+YDISP;
    967            ((INPUTDIA_DESC*)inp)->rc.x2=ScreenW()-1;
    968            ((INPUTDIA_DESC*)inp)->rc.y2=ScreenH()-SoftkeyH()-1;
    969          }
    970          //===============================================================================================
    971          
    972          
    973          volatile unsigned int GROUP_CACHE; //Текущая группа для добавления
    974          
    975          volatile int contactlist_menu_id;
    976          
    977          GBSTMR tmr_active;
    978          
    979          volatile int edchat_id;
    980          
    981          //Применяется для добавления сообщений
    982          //CLIST *edcontact;
    983          //void *edgui_data;
    984          
    985          static int prev_clmenu_itemcount;
    986          
    987          char clm_hdr_text[48];
    988          static const char def_clm_hdr_text[] = LG_CLTITLE;
    989          static const char key_clm_hdr_text[] = LG_CLT9INP;
    990          
    991          static const HEADER_DESC contactlist_menuhdr = {0, 0, 0, 0, S_ICONS+ICON_HEAD, (int)clm_hdr_text, LGP_NULL};
    992          static const int menusoftkeys[] = {0,1,2};
    993          static const SOFTKEY_DESC menu_sk[] =
    994          {
    995            {0x0018, 0x0000, (int)LG_SELECT},
    996            {0x0001, 0x0000, (int)LG_CLOSE},
    997            {0x003D, 0x0000, (int)LGP_DOIT_PIC}
    998          };
    999          
   1000          char clmenu_sk_r[16];
   1001          static const char def_clmenu_sk_r[] = LG_CLOSE;
   1002          static const char key_clmenu_sk_r[] = LG_CLEAR;
   1003          
   1004          static const SOFTKEY_DESC clmenu_sk[]=
   1005          {
   1006            {0x0018, 0x0000, (int)LG_OPTIONS},
   1007            {0x0001, 0x0000, (int)clmenu_sk_r},
   1008            {0x003D, 0x0000, (int)LGP_DOIT_PIC}
   1009          };
   1010          
   1011          const SOFTKEYSTAB menu_skt =
   1012          {
   1013            menu_sk, 0
   1014          };
   1015          
   1016          static const SOFTKEYSTAB clmenu_skt =
   1017          {
   1018            clmenu_sk, 0
   1019          };
   1020          
   1021          void contactlist_menu_ghook(void *data, int cmd);
   1022          int contactlist_menu_onkey(void *data, GUI_MSG *msg);
   1023          void contactlist_menu_iconhndl(void *data, int curitem, void *unk);
   1024          
   1025          #ifdef USE_MLMENU
   1026          static const ML_MENU_DESC contactlist_menu=
   1027          {
   1028            8,contactlist_menu_onkey,contactlist_menu_ghook,NULL,
   1029            menusoftkeys,
   1030            &clmenu_skt,
   1031            0x11, //+0x400
   1032            contactlist_menu_iconhndl,
   1033            NULL,   //Items
   1034            NULL,   //Procs
   1035            0,   //n
   1036            1 //Добавочных строк
   1037          };
   1038          #else
   1039          static const MENU_DESC contactlist_menu=
   1040          {
   1041            8,contactlist_menu_onkey,contactlist_menu_ghook,NULL,
   1042            menusoftkeys,
   1043            &clmenu_skt,
   1044            0x11, //+0x400
   1045            contactlist_menu_iconhndl,
   1046            NULL,   //Items
   1047            NULL,   //Procs
   1048            0   //n
   1049          };
   1050          #endif
   1051          
   1052          //GBSTMR tmr_ping;
   1053          int tenseconds_to_ping;
   1054          
   1055          LOGQ *NewLOGQ(const char *s)
   1056          {
   1057            LOGQ *p=malloc(sizeof(LOGQ)+1+strlen(s));
   1058            zeromem(p,sizeof(LOGQ));
   1059            strcpy(p->text,s);
   1060            return p;
   1061          }
   1062          
   1063          LOGQ *LastLOGQ(LOGQ **pp)
   1064          {
   1065            LOGQ *q=*pp;
   1066            if (q)
   1067            {
   1068              while(q->next) q=q->next;
   1069            }
   1070            return(q);
   1071          }
   1072          
   1073          //Уничтожить лог
   1074          void FreeLOGQ(LOGQ **pp)
   1075          {
   1076            LOGQ *p=*pp;
   1077            *pp=NULL; //Сразу обрежем
   1078            while(p)
   1079            {
   1080              LOGQ *np=p->next;
   1081              mfree(p);
   1082              p=np;
   1083            }
   1084          }
   1085          
   1086          //Удалить элемент из лога
   1087          void RemoveLOGQ(LOGQ **queue, LOGQ *p)
   1088          {
   1089            LOGQ *q=(LOGQ *)queue;
   1090            LOGQ *qp;
   1091            while(qp=q->next)
   1092            {
   1093              if (qp==p)
   1094              {
   1095                q->next=p->next;
   1096                break;
   1097              }
   1098              q=qp;
   1099            }
   1100            mfree(p); //Если элемент вообще не в логе
   1101          }
   1102          
   1103          //Добавить элемент в лог
   1104          int AddLOGQ(LOGQ **queue, LOGQ *p)
   1105          {
   1106            LOGQ *q=(LOGQ *)queue;
   1107            LOGQ *qp;
   1108            int i=0;
   1109            while(qp=q->next) {q=qp;i++;}
   1110            p->next=NULL;
   1111            q->next=p;
   1112            return(i+1); //Теперь всего в логе элементов
   1113          }
   1114          
   1115          //Получаем последний полученный X-статус
   1116          char *GetLastXTextLOGQ(CLIST *t)
   1117          {
   1118            LOGQ *p = t->log;
   1119            char *s = 0;
   1120            if(!p) return 0;
   1121            while(p->next)
   1122            {
   1123              if((p->type&0x0F)==3)
   1124                s = p->text;
   1125              p = p->next;
   1126            }
   1127            if((p->type&0x0F)==3)
   1128              s = p->text;
   1129            return s;
   1130          }
   1131          
   1132          int GetIconIndex(CLIST *t)
   1133          {
   1134            unsigned short s;
   1135            if (t)
   1136            {
   1137              s=t->state;
   1138              if (t->isgroup) return(IS_GROUP);
   1139              if (t->isunread)
   1140                return(IS_MSG);
   1141              else
   1142              {
   1143                if (s==0xFFFF) return(IS_OFFLINE);
   1144                if ((s&0xF000)==0x2000) return (IS_LUNCH);
   1145                if ((s&0xF000)==0x3000) return (IS_EVIL);
   1146                if ((s&0xF000)==0x4000) return (IS_DEPRESSION);
   1147                if ((s&0xF000)==0x5000) return (IS_HOME);
   1148                if ((s&0xF000)==0x6000) return (IS_WORK);
   1149                if (s & 0x0020) return(IS_FFC);
   1150                if (s & 0x0001) return(IS_AWAY);
   1151                if (s & 0x0005) return(IS_NA);
   1152                if (s & 0x0011) return(IS_OCCUPIED);
   1153                if (s & 0x0013) return(IS_DND);
   1154                if (s & 0x0002) return(IS_FFC);
   1155                if (s & 0x0100) return(IS_INVISIBLE);
   1156              }
   1157            }
   1158            else
   1159            {
   1160              return(IS_UNKNOWN);
   1161            }
   1162            return(IS_ONLINE);
   1163          }
   1164          
   1165          LOGQ *FindContactLOGQByAck(TPKT *p)
   1166          {
   1167            CLIST *t;
   1168            LockSched();
   1169            t=FindContactByUin(p->pkt.uin);
   1170            UnlockSched();
   1171            unsigned int id=*((unsigned short*)(p->data));
   1172            LOGQ *q;
   1173            if (!t) return NULL;
   1174            LockSched();
   1175            q=t->log;
   1176            while(q)
   1177            {
   1178              if (q->ID==id) break;
   1179              q=q->next;
   1180            }
   1181            UnlockSched();
   1182            return q;
   1183          }
   1184          
   1185          
   1186          char ContactT9Key[32];
   1187          
   1188          void UpdateCLheader(void)
   1189          {
   1190            if (strlen(ContactT9Key))
   1191            {
   1192              strcpy(clm_hdr_text,key_clm_hdr_text);
   1193              strcat(clm_hdr_text,ContactT9Key);
   1194              strcpy(clmenu_sk_r,key_clmenu_sk_r);
   1195            }
   1196            else
   1197            {
   1198          #ifdef EVILFOX
   1199              if(TIME_OR_MSG)
   1200              {
   1201              if(total_c_online>0)
   1202                sprintf(clm_hdr_text, "%s(%d/%d) On:%02d",def_clm_hdr_text,total_unread,total_unread2, total_c_online);
   1203              else
   1204              sprintf(clm_hdr_text, "%s(%d/%d)",def_clm_hdr_text,total_unread,total_unread2);
   1205              }
   1206              else
   1207                {
   1208                  TTime the;
   1209                  GetDateTime(NULL,&the);
   1210                  if(total_c_online>0)
   1211                    sprintf(clm_hdr_text, "%s(%02d:%02d) On:%02d",def_clm_hdr_text, the.hour, the.min, total_c_online);
   1212                  else
   1213                  sprintf(clm_hdr_text, "%s(%02d:%02d)",def_clm_hdr_text,the.hour,the.min);
   1214                }
   1215          #else
   1216              strcpy(clm_hdr_text,def_clm_hdr_text);
   1217          #endif
   1218              strcpy(clmenu_sk_r,def_clmenu_sk_r);
   1219            }
   1220          }
   1221          
   1222          void ClearContactT9Key(void)
   1223          {
   1224            zeromem(ContactT9Key,sizeof(ContactT9Key));
   1225          }
   1226          
   1227          void AddContactT9Key(int chr)
   1228          {
   1229            int l=strlen(ContactT9Key);
   1230            if (l<(sizeof(ContactT9Key)-1))
   1231            {
   1232              ContactT9Key[l]=chr;
   1233            }
   1234          }
   1235          
   1236          void BackSpaceContactT9(void)
   1237          {
   1238            int l=strlen(ContactT9Key);
   1239            if (l)
   1240            {
   1241              l--;
   1242              ContactT9Key[l]=0;
   1243            }
   1244          }
   1245          
   1246          void create_contactlist_menu(void)
   1247          {
   1248            int i;
   1249            i=CountContacts();
   1250            prev_clmenu_itemcount=i;
   1251            UpdateCLheader();
   1252            patch_header(&contactlist_menuhdr);
   1253          #ifdef USE_MLMENU
   1254            contactlist_menu_id=CreateMultiLinesMenu(0,0,&contactlist_menu,&contactlist_menuhdr,0,i);
   1255          #else
   1256            contactlist_menu_id=CreateMenu(0,0,&contactlist_menu,&contactlist_menuhdr,0,i,0,0);
   1257          #endif
   1258          }
   1259          
   1260          void contactlist_menu_ghook(void *data, int cmd)
   1261          {
   1262            PNGTOP_DESC *pltop=PNG_TOP();
   1263            if (cmd==9)
   1264            {
   1265              pltop->dyn_pltop=NULL;
   1266            }
   1267            if (cmd==0x0A)
   1268            {
   1269              silenthide=0;
   1270              pltop->dyn_pltop=XStatusesImgList;
   1271              DisableIDLETMR();
   1272            }
   1273          }
   1274          
   1275          void RecountMenu(CLIST *req, int needfocus)
   1276          {
   1277            int i;
   1278            int j;
   1279            void *data;
   1280            UpdateCLheader();
   1281            if (!contactlist_menu_id) return; //Нечего считать
   1282            data=FindGUIbyId(contactlist_menu_id,NULL);
   1283            if (req==NULL)
   1284            {
   1285              j=0;
   1286            }
   1287            else
   1288            {
   1289              j=FindContactByContact(req);
   1290            }
   1291            i=CountContacts();
   1292            if (j>=i) j=i-1;
   1293            if (j<0) j=0;
   1294            if (i!=prev_clmenu_itemcount)
   1295            {
   1296              prev_clmenu_itemcount=i;
   1297              Menu_SetItemCountDyn(data,i);
   1298            }
   1299            if(needfocus) SetCursorToMenuItem(data,j);
   1300            if (IsGuiOnTop(contactlist_menu_id)) RefreshGUI();
   1301          }
   1302          
   1303          int contactlist_menu_onkey(void *data, GUI_MSG *msg)
   1304          {
   1305            CLIST *t;
   1306            int i;
   1307            i=GetCurMenuItem(data);
   1308            t=FindContactByN(i);
   1309            if (msg->keys==0x18)
   1310            {
   1311              ShowMainMenu();
   1312              return(-1);
   1313            }
   1314            if (msg->keys==0x3D)
   1315            {
   1316              if (t)
   1317              {
   1318                if (t->isgroup)
   1319                {
   1320          	t->state^=0xFFFF;
   1321          	RecountMenu(t, 1);
   1322          	return(-1);
   1323                }
   1324                if (strlen(ContactT9Key))
   1325                {
   1326          	ClearContactT9Key();
   1327          	RecountMenu(NULL, 1);
   1328                }
   1329                if(!t->isactive && HISTORY_BUFFER) GetHistory(t, 64<<HISTORY_BUFFER);
   1330                CreateEditChat(t);
   1331              }
   1332              return(-1);
   1333            }
   1334            if (msg->keys==1)
   1335            {
   1336              if (strlen(ContactT9Key))
   1337              {
   1338                BackSpaceContactT9();
   1339                RecountMenu(NULL, 1);
   1340                return(-1);
   1341              }
   1342            }
   1343            if (msg->gbsmsg->msg==KEY_DOWN)
   1344            {
   1345              int key=msg->gbsmsg->submess;
   1346          #ifdef EVILFOX
   1347              if ((key>='0')&&(key<='9'))
   1348          #else
   1349              if (((key>='0')&&(key<='9'))||(key=='#')||(key=='*'))
   1350          #endif
   1351              {
   1352                AddContactT9Key(key);
   1353                RecountMenu(NULL, 1);
   1354                return(-1);
   1355              }
   1356              if (key==VOL_UP_BUTTON)
   1357              {
   1358                char *small_info=malloc(256);
   1359                sprintf(small_info, "Online time:\n"
   1360                        "%02d:%02d:%02d\n"
   1361                          "Server:\n"
   1362                            "%s"
   1363                          , hours, minutes, seconds, hostname);
                                   ^
Error[Pe020]: identifier "hours" is undefined

                  , hours, minutes, seconds, hostname);
                           ^
"D:\Pasha\elf\mod_src\elfiki\naticq_2nd_mod to all(17.02.08)\main.c",1363  Error[Pe020]: 
          identifier "minutes" is undefined

                  , hours, minutes, seconds, hostname);
                                    ^
"D:\Pasha\elf\mod_src\elfiki\naticq_2nd_mod to all(17.02.08)\main.c",1363  Error[Pe020]: 
          identifier "seconds" is undefined
   1364                ShowMSG(1,(int)small_info);
   1365                mfree(small_info);
   1366              }
   1367              if (key==LEFT_BUTTON)
   1368              {
   1369          #ifdef EVILFOX
   1370                while(t=(CLIST *)(t->next))
   1371                 {
   1372                   if (t->isunread) goto doit;
   1373                 }
   1374                t=(CLIST *)(&cltop);
   1375                while(t=(CLIST *)(t->next))
   1376                {
   1377                  if (t->isunread) goto doit;
   1378                }
   1379                t=(CLIST *)(&cltop);
   1380                if(Is_Show_Groups)
   1381                {
   1382                  while(t=(CLIST *)(t->next))
   1383                  {
   1384                    if (t->isgroup)
   1385                    {
   1386                      if(!t->state)
   1387          	    t->state^=0xFFFF;
   1388                    }
   1389                  }
   1390                }
   1391                goto doit2;
   1392              doit:
   1393                {
   1394                CLIST *g=FindGroupByID(t->group);
   1395                if (g)
   1396                {
   1397          	if (g->state)
   1398          	{
   1399          	  g->state=0;
   1400          	}
   1401                }
   1402                }
   1403              doit2:
   1404                RecountMenu(t, 1);
   1405          #else
   1406                IsActiveUp=!IsActiveUp;
   1407                RecountMenu(NULL, 1);
   1408          #endif
   1409                return(-1);
   1410              }
   1411          #ifdef EVILFOX
   1412              if (key=='*')
   1413              {
   1414                while(t=(CLIST *)(t->next))
   1415                 {
   1416                   if (t->just_now) goto doit3;
   1417                 }
   1418                t=(CLIST *)(&cltop);
   1419                while(t=(CLIST *)(t->next))
   1420                {
   1421                  if (t->just_now) goto doit3;
   1422                }
   1423                return(-1);
   1424              doit3:
   1425                {
   1426                CLIST *g=FindGroupByID(t->group);
   1427                if (g)
   1428                {
   1429          	if (g->state)
   1430          	{
   1431          	  g->state=0;
   1432          	}
   1433                }
   1434                }
   1435                RecountMenu(t, 1);
   1436                return(-1);
   1437              }
   1438              if (key=='#')
   1439              {
   1440                while(t=(CLIST *)(t->next))
   1441                 {
   1442                   if (t->isactive) goto doit4;
   1443                 }
   1444                t=(CLIST *)(&cltop);
   1445                while(t=(CLIST *)(t->next))
   1446                {
   1447                  if (t->isactive) goto doit4;
   1448                }
   1449                return(-1);
   1450              doit4:
   1451                {
   1452                CLIST *g=FindGroupByID(t->group);
   1453                if (g)
   1454                {
   1455          	if (g->state)
   1456          	{
   1457          	  g->state=0;
   1458          	}
   1459                }
   1460                }
   1461                RecountMenu(t, 1);
   1462                return(-1);
   1463              }
   1464          #endif
   1465              if (key==RIGHT_BUTTON)
   1466              {
   1467                //Послать запрос текста XStatus
   1468                if (t)
   1469                {
   1470          	if (!t->isgroup)
   1471          	{
   1472          	  FreeXText(t);
   1473                    t->req_xtext=0;
   1474                    RequestXText(t->uin);
   1475          	  RefreshGUI();
   1476          	  return(-1);
   1477          	}
   1478                }
   1479              }
   1480              if (key==GREEN_BUTTON)
   1481              {
   1482          #ifdef EVILFOX
   1483                IsActiveUp=!IsActiveUp;
   1484                RecountMenu(NULL, 1);
   1485          #else
   1486                if (t && Is_Show_Groups) {//есть контакт и показываем группы?
   1487                 if (!t->isgroup)
   1488                  t=FindGroupByID(t->group);
   1489                 if (t && !t->state) {//группа нашлась и она открыта?
   1490                  t->state^=0xFFFF;
   1491                  RecountMenu(t, 1);
   1492                 }
   1493                }
   1494          #endif
   1495                return(-1);
   1496              }
   1497            }
   1498            if (msg->gbsmsg->msg==LONG_PRESS)
   1499            {
   1500              if (msg->gbsmsg->submess=='#')
   1501              {
   1502                ClearContactT9Key();
   1503                RecountMenu(NULL, 1);
   1504                gipc.name_to=ipc_xtask_name;
   1505                gipc.name_from=ipc_my_name;
   1506                gipc.data=0;
   1507                GBS_SendMessage(MMI_CEPID,MSG_IPC,IPC_XTASK_IDLE,&gipc);
   1508                if (IsUnlocked())
   1509                {
   1510                  KbdLock();
   1511                }
   1512                return(-1);
   1513              }
   1514              if (msg->gbsmsg->submess=='*'){
   1515                ClearContactT9Key();
   1516                RecountMenu(NULL, 1);
   1517                silenthide=1;
   1518                gipc.name_to=ipc_xtask_name;
   1519                gipc.name_from=ipc_my_name;
   1520                gipc.data=0;
   1521                GBS_SendMessage(MMI_CEPID,MSG_IPC,IPC_XTASK_IDLE,&gipc);
   1522              }
   1523            }
   1524            return(0);
   1525          }
   1526          
   1527          void GetOnTotalContact(int group_id,int *_onlinetotal)
   1528          {
   1529            CLIST *t;
   1530            t=(CLIST *)&cltop;
   1531            int online=0,total=0;
   1532            while((t=t->next))
   1533            {
   1534              if(t->group==group_id && !t->isgroup)
   1535              {
   1536                total++;
   1537                if (t->state!=0xFFFF) online++;
   1538              }
   1539            }
   1540            _onlinetotal[0]=online;
   1541            _onlinetotal[1]=total;
   1542          }
   1543          
   1544          
   1545          void contactlist_menu_iconhndl(void *data, int curitem, void *unk)
   1546          {
   1547            CLIST *t;
   1548          #ifdef USE_MLMENU
   1549            void *item=AllocMLMenuItem(data);
   1550          #else
   1551            void *item=AllocMenuItem(data);
   1552          #endif
   1553            int icon;
   1554          
   1555            WSHDR *ws2;
   1556          #ifdef USE_MLMENU
   1557            WSHDR *ws4;
   1558          #endif
   1559            WSHDR ws1loc, *ws1;
   1560            unsigned short num[128];
   1561            ws1=CreateLocalWS(&ws1loc,num,128);
   1562          #ifdef USE_MLMENU
   1563            WSHDR ws3loc, *ws3;
   1564            unsigned short num3[128];
   1565            ws3=CreateLocalWS(&ws3loc,num3,128);
   1566            char s[64];
   1567          #endif
   1568            t=FindContactByN(curitem);
   1569            if (t)
   1570            {
   1571              icon=GetIconIndex(t);
   1572              if (icon!=IS_GROUP)
   1573              {
   1574          #ifdef EVILFOX
   1575                if(t->just_now)
   1576                {
   1577          //        char *test=malloc(64);
   1578                  sprintf(upcoming, ">> %s <<", t->name);
   1579                  wsprintf(ws1,percent_t,upcoming);
   1580          //        mfree(test);
   1581                }
   1582                else
   1583                wsprintf(ws1,percent_t,t->name);
   1584                if (t->just_now)
   1585                {
   1586                  wsInsertChar(ws1,0x0004,1);
   1587                  wsInsertChar(ws1,0xE008,1);
   1588                }
   1589                else
   1590          #else
   1591                wsprintf(ws1,percent_t,t->name);
   1592          #endif
   1593                if (t->isactive)
   1594                {
   1595                  wsInsertChar(ws1,0x0002,1);
   1596                  wsInsertChar(ws1,0xE008,1);
   1597                }
   1598          #ifdef USE_MLMENU
   1599                if (t->xtext && t->xtext[0]!=0)
   1600                {
   1601          	int i;
   1602          	zeromem(s,64);
   1603          	i=t->xtext[0];
   1604          	if (i>63) i=63;
   1605          	strncpy(s,t->xtext+1,i);
   1606          	wsprintf(ws3,"%c%t",0xE012,s);
   1607                }
   1608                else
   1609          	wsprintf(ws3,percent_d,t->uin);
   1610                if ((t->xstate<total_xstatuses)&&(t->xstate))
   1611                {
   1612          	wsInsertChar(ws3,FIRST_UCS2_BITMAP+t->xstate,1);
   1613                }
   1614          #endif
   1615              }
   1616              else
   1617              {
   1618                int onlinetotal[2];
   1619                GetOnTotalContact(t->group,onlinetotal);
   1620          #ifdef USE_MLMENU
   1621                wsprintf(ws1,percent_t,t->name);
   1622                wsprintf(ws3,"(%d/%d)",onlinetotal[0],onlinetotal[1]);
   1623          #else
   1624                wsprintf(ws1,"%t%c%c(%d/%d)",t->name,0xE01D,0xE012,onlinetotal[0],onlinetotal[1]);
   1625          #endif
   1626                if (t->state) icon++; //Модификация иконки группы
   1627              }
   1628            }
   1629            else
   1630            {
   1631              wsprintf(ws1, LG_CLERROR);
   1632            }
   1633            ws2=AllocMenuWS(data,ws1->wsbody[0]);
   1634            wstrcpy(ws2,ws1);
   1635          
   1636            SetMenuItemIconArray(data, item, S_ICONS+icon);
   1637          #ifdef USE_MLMENU
   1638            ws4=AllocMenuWS(data,ws3->wsbody[0]);
   1639            wstrcpy(ws4,ws3);
   1640            SetMLMenuItemText(data, item, ws2, ws4, curitem);
   1641          #else
   1642            SetMenuItemText(data, item, ws2, curitem);
   1643          #endif
   1644          }
   1645          
   1646          //===============================================================================================
   1647          int DNR_ID=0;
   1648          int DNR_TRIES=3;
   1649          
   1650          extern const char NATICQ_HOST[];
   1651          extern const unsigned int NATICQ_PORT;
   1652          
   1653          int host_counter = 0;
   1654          
   1655          //---------------------------------------------------------------------------
   1656          const char *GetHost(int cnt, const char *str, char *buf)
   1657          {
   1658            const char *tmp = str, *begin, *end;
   1659            if(cnt)
   1660            {
   1661              for(;cnt;cnt--)
   1662              {
   1663                for(;*str!=';' && *str!=' ' && *str!='\x0D' && *str!='\x0A' && *str; str++);
   1664                if(!*str) str = tmp;
   1665                for(;(*str==';' || *str==' ' || *str=='\x0D' || *str=='\x0A') && *str; str++);
   1666                if(!*str) str = tmp;
   1667              }
   1668            }
   1669            tmp = buf;
   1670            begin = str;
   1671            for(;*str!=';' && *str!=':' && *str!=' ' && *str!='\x0D' && *str!='\x0A' && *str; str++);
   1672            end = str;
   1673            for(;begin<end; *buf = *begin, begin++, buf++);
   1674            *buf = 0;
   1675            return tmp;
   1676          }
   1677          //---------------------------------------------------------------------------
   1678          int atoi(char *attr)
   1679          {
   1680            int ret=0;
   1681            int neg=1;
   1682            for (int k=0; ; k++)
   1683            {
   1684              if ( attr[k]>0x2F && attr[k]<0x3A) {ret=ret*10+attr[k]-0x30;} else { if ( attr[k]=='-') {neg=-1;} else {return(ret*neg);}}
   1685            }
   1686          }
   1687          //---------------------------------------------------------------------------
   1688          int GetPort(int cnt, const char *str)
   1689          {
   1690            const char *tmp = str;
   1691            char numbuf[6], numcnt = 0;
   1692            if(cnt)
   1693            {
   1694              for(;cnt;cnt--)
   1695              {
   1696                for(;*str!=';' && *str!=' ' && *str!='\x0D' && *str!='\x0A' && *str; str++);
   1697                if(!*str) str = tmp;
   1698                for(;(*str==';' || *str==' ' || *str=='\x0D' || *str=='\x0A') && *str; str++);
   1699                if(!*str) str = tmp;
   1700              }
   1701            }
   1702            for(;*str!=';' && *str!=':' && *str!=' ' && *str!='\x0D' && *str!='\x0A' && *str; str++);
   1703            if(*str!=':') return NATICQ_PORT;
   1704            str++;
   1705            numbuf[5] = 0;
   1706            for(;*str!=';' && *str!=' ' && *str!='\x0D' && *str!='\x0A' && *str && numcnt<5; numbuf[numcnt] = *str, str++, numcnt++);
   1707            numbuf[numcnt] = 0;
   1708            return atoi(numbuf);
   1709          
   1710          }
   1711          //---------------------------------------------------------------------------
   1712          int GetHostsCount(const char *str)
   1713          {
   1714            char cnt = 1;
   1715            for(;cnt;cnt++)
   1716            {
   1717              for(;*str!=';' && *str!=' ' && *str!='\x0D' && *str!='\x0A' && *str; str++);
   1718              if(!*str) return cnt;
   1719              for(;(*str==';' || *str==' ' || *str=='\x0D' || *str=='\x0A') && *str; str++);
   1720              if(!*str) return cnt;
   1721            }
   1722            return 0;
   1723          
   1724          }
   1725          //---------------------------------------------------------------------------
   1726          
   1727          void create_connect(void)
   1728          {
   1729            char hostbuf[128];
   1730            int hostport;
   1731            int ***p_res=NULL;
   1732            void do_reconnect(void);
   1733            SOCK_ADDR sa;
   1734            //Устанавливаем соединение
   1735            connect_state = 0;
   1736            int err;
   1737            unsigned int ip;
   1738            GBS_DelTimer(&reconnect_tmr);
   1739            if (!IsGPRSEnabled())
   1740            {
   1741              is_gprs_online=0;
   1742              strcpy(logmsg,LG_GRWAITFORGPRS);
   1743              SMART_REDRAW();
   1744              return;
   1745            }
   1746            DNR_ID=0;
   1747            *socklasterr()=0;
   1748          
   1749            if(host_counter > GetHostsCount(NATICQ_HOST)-1) host_counter = 0;
   1750            GetHost(host_counter, NATICQ_HOST, hostbuf);
   1751            hostport = GetPort(host_counter, NATICQ_HOST);
   1752            host_counter++;
   1753          
   1754          //  sprintf(hostname, "%s:%d", hostbuf, hostport);
   1755            strcpy(hostname, hostbuf);
   1756          
   1757            SMART_REDRAW();
   1758          
   1759            ip=str2ip(hostbuf);
   1760            if (ip!=0xFFFFFFFF)
   1761            {
   1762              sa.ip=ip;
   1763              strcpy(logmsg,"\nConnect by IP!");
   1764              SMART_REDRAW();
   1765              goto L_CONNECT;
   1766            }
   1767            strcpy(logmsg,LG_GRSENDDNR);
   1768            SMART_REDRAW();
   1769            err=async_gethostbyname(hostbuf,&p_res,&DNR_ID); //03461351 3<70<19<81
   1770            if (err)
   1771            {
   1772              if ((err==0xC9)||(err==0xD6))
   1773              {
   1774                if (DNR_ID)
   1775                {
   1776                  host_counter--;
   1777          	return; //Ждем готовности DNR
   1778                }
   1779              }
   1780              else
   1781              {
   1782                snprintf(logmsg,255,LG_GRDNRERROR,err);
   1783                SMART_REDRAW();
   1784                GBS_StartTimerProc(&reconnect_tmr,TMR_SECOND*10,do_reconnect);
   1785                return;
   1786              }
   1787            }
   1788            if (p_res)
   1789            {
   1790              if (p_res[3])
   1791              {
   1792                strcpy(logmsg,LG_GRDNROK);
   1793                SMART_REDRAW();
   1794                DNR_TRIES=0;
   1795                sa.ip=p_res[3][0][0];
   1796              L_CONNECT:
   1797                sock=socket(1,1,0);
   1798                if (sock!=-1)
   1799                {
   1800          	sa.family=1;
   1801          	sa.port=htons(hostport);
   1802          	//    sa.ip=htonl(IP_ADDR(82,207,89,182));
   1803          	if (connect(sock,&sa,sizeof(sa))!=-1)
   1804          	{
   1805          	  connect_state=1;
   1806          	  TOTALRECEIVED=0;
   1807          	  TOTALSENDED=0;
   1808          	  SMART_REDRAW();
   1809          	}
   1810          	else
   1811          	{
   1812          	  closesocket(sock);
   1813          	  sock=-1;
   1814          	  LockSched();
   1815          	  ShowMSG(1,(int)LG_MSGCANTCONN);
   1816          	  UnlockSched();
   1817          	  GBS_StartTimerProc(&reconnect_tmr,TMR_SECOND*10,do_reconnect);
   1818          	}
   1819                }
   1820                else
   1821                {
   1822          	LockSched();
   1823          	ShowMSG(1,(int)LG_MSGCANTCRSC);
   1824          	UnlockSched();
   1825          	//Не осилили создания сокета, закрываем GPRS-сессию
   1826          	GPRS_OnOff(0,1);
   1827                }
   1828              }
   1829            }
   1830            else
   1831            {
   1832              DNR_TRIES--;
   1833              LockSched();
   1834              ShowMSG(1,(int)LG_MSGHOSTNFND);
   1835              UnlockSched();
   1836            }
   1837          }
   1838          
   1839          #ifdef SEND_TIMER
   1840          GBSTMR send_tmr;
   1841          #endif
   1842          
   1843          void ClearSendQ(void)
   1844          {
   1845            mfree((void *)sendq_p);
   1846            sendq_p=NULL;
   1847            sendq_l=NULL;
   1848          #ifdef SEND_TIMER
   1849            GBS_DelTimer(&send_tmr);
   1850          #endif
   1851          }
   1852          
   1853          void end_socket(void)
   1854          {
   1855            if (sock>=0)
   1856            {
   1857              shutdown(sock,2);
   1858              closesocket(sock);
   1859            }
   1860          #ifdef SEND_TIMER
   1861            GBS_DelTimer(&send_tmr);
   1862          #endif
   1863          }
   1864          
   1865          #ifdef SEND_TIMER
   1866          static void resend(void)
   1867          {
   1868            void SendAnswer(int dummy, TPKT *p);
   1869            SUBPROC((void*)SendAnswer,0,0);
   1870          }
   1871          #endif
   1872          
   1873          void SendAnswer(int dummy, TPKT *p)
   1874          {
   1875            int i;
   1876            int j;
   1877            if (connect_state<2)
   1878            {
   1879              mfree(p);
   1880              return;
   1881            }
   1882            if (p)
   1883            {
   1884              j=sizeof(PKT)+p->pkt.data_len; //Размер пакета
   1885              TOTALSENDED+=j;
   1886              ALLTOTALSENDED+=j;			//by BoBa 10.07
   1887              //Проверяем, не надо ли добавить в очередь
   1888              if (sendq_p)
   1889              {
   1890                //Есть очередь, добавляем в нее
   1891                sendq_p=realloc((void *)sendq_p,sendq_l+j);
   1892                memcpy((char *)sendq_p+sendq_l,p,j);
   1893                mfree(p);
   1894                sendq_l+=j;
   1895                return;
   1896              }
   1897              sendq_p=p;
   1898              sendq_l=j;
   1899            }
   1900            //Отправляем уже существующее в очереди
   1901            while((i=sendq_l)!=0)
   1902            {
   1903              if (i>0x400) i=0x400;
   1904              j=send(sock,(void *)sendq_p,i,0);
   1905              snprintf(logmsg,255,"send res %d",j);
   1906              SMART_REDRAW();
   1907              if (j<0)
   1908              {
   1909                j=*socklasterr();
   1910                if ((j==0xC9)||(j==0xD6))
   1911                {
   1912          	//Передали что хотели
   1913          	strcpy(logmsg,"Send delayed...");
   1914          	return; //Видимо, надо ждать сообщения ENIP_BUFFER_FREE
   1915                }
   1916                else
   1917                {
   1918          	//Ошибка
   1919          	LockSched();
   1920          	ShowMSG(1,(int)"Send error!");
   1921          	UnlockSched();
   1922          	end_socket();
   1923          	return;
   1924                }
   1925              }
   1926              memcpy((void *)sendq_p,(char *)sendq_p+j,sendq_l-=j); //Удалили переданное
   1927              if (j<i)
   1928              {
   1929                //Передали меньше чем заказывали
   1930          #ifdef SEND_TIMER
   1931                GBS_StartTimerProc(&send_tmr,216*5,resend);
   1932          #endif
   1933                return; //Ждем сообщения ENIP_BUFFER_FREE1
   1934              }
   1935              tenseconds_to_ping=0; //Чего-то послали, можно начинать отсчет времени до пинга заново
   1936            }
   1937            mfree((void *)sendq_p);
   1938            sendq_p=NULL;
   1939          }
   1940          
   1941          void send_login(int dummy, TPKT *p)
   1942          {
   1943            connect_state=2;
   1944            char rev[16];
   1945            //Кто будет менять в этом месте идентификатор клиента, буду банить на уровне сервера!!!
   1946            //А Вова будет банить на форуме!
   1947            snprintf(rev,9,"Sie_%04d",__SVN_REVISION__);
   1948          
   1949            TPKT *p2=malloc(sizeof(PKT)+8);
   1950            p2->pkt.uin=UIN;
   1951            p2->pkt.type=T_SETCLIENT_ID;
   1952            p2->pkt.data_len=8;
   1953            memcpy(p2->data,rev,8);
   1954            SendAnswer(0,p2);
   1955            SendAnswer(dummy,p);
   1956            RXstate=-(int)sizeof(PKT);
   1957          }
   1958          
   1959          void do_ping(void)
   1960          {
   1961            TPKT *pingp=malloc(sizeof(PKT));
   1962            pingp->pkt.uin=UIN;
   1963            pingp->pkt.type=0;
   1964            pingp->pkt.data_len=0;
   1965            SendAnswer(0,pingp);
   1966          }
   1967          
   1968          void SendMSGACK(int i)
   1969          {
   1970            TPKT *ackp=malloc(sizeof(PKT));
   1971            ackp->pkt.uin=i;
   1972            ackp->pkt.type=T_MSGACK;
   1973            ackp->pkt.data_len=0;
   1974            SendAnswer(0,ackp);
   1975          }
   1976          
   1977          void RequestXText(unsigned int uin)
   1978          {
   1979            TPKT *p=malloc(sizeof(PKT));
   1980            p->pkt.uin=uin;
   1981            p->pkt.type=T_XTEXT_REQ;
   1982            p->pkt.data_len=0;
   1983            SUBPROC((void *)SendAnswer,0,p);
   1984          }
   1985          
   1986          void get_answer(void)
   1987          {
   1988            void *p;
   1989            int i=RXstate;
   1990            int j;
   1991            int n;
   1992            char rb[1024];
   1993            char *rp=rb;
   1994            if (connect_state<2) return;
   1995            if (i==EOP) return;
   1996            j=recv(sock,rb,sizeof(rb),0);
   1997            while(j>0)
   1998            {
   1999              if (i<0)
   2000              {
   2001                //Принимаем заголовок
   2002                n=-i; //Требуемое количество байт
   2003                if (j<n) n=j; //полученное<требуемое?
   2004                memcpy(RXbuf.data+i,rp,n); //Копируем
   2005                i+=n;
   2006                j-=n;
   2007                rp+=n;
   2008              }
   2009              if (i>=0)
   2010              {
   2011                //Принимаем тельце ;)
   2012                n=RXbuf.pkt.data_len; //Всего в тельце
   2013                if (n>16383)
   2014                {
   2015          	//Слишком много
   2016          	strcpy(logmsg,LG_GRBADPACKET);
   2017          	end_socket();
   2018          	RXstate=EOP;
   2019          	return;
   2020                }
   2021                n-=i; //Количество требуемых байт (общая длинна тельца-текущая позиция)
   2022                if (n>0)
   2023                {
   2024          	if (j<n) n=j; //полученное<требуемое?
   2025          	memcpy(RXbuf.data+i,rp,n);
   2026          	i+=n;
   2027          	j-=n;
   2028          	rp+=n;
   2029                }
   2030                if (RXbuf.pkt.data_len==i)
   2031                {
   2032          	//Пакет полностью получен
   2033          	TOTALRECEIVED+=(i+8);
   2034          	ALLTOTALRECEIVED+=(i+8);			//by BoBa 10.07
   2035          	//Пакет удачно принят, можно разбирать...
   2036          	RXbuf.data[i]=0; //Конец строки
   2037          	switch(RXbuf.pkt.type)
   2038          	{
   2039          	case T_LOGIN:
   2040          	  //Удачно залогинились
   2041          	  //Посылаем в MMI
   2042          	  n=i+sizeof(PKT)+1;
   2043          	  p=malloc(n);
   2044          	  memcpy(p,&RXbuf,n);
   2045          	  GBS_SendMessage(MMI_CEPID,MSG_HELPER_TRANSLATOR,0,p,sock);
   2046          	  Play(sndStartup);
   2047          	  //        GBS_StartTimerProc(&tmr_ping,120*TMR_SECOND,call_ping);
   2048          	  snprintf(logmsg,255,LG_GRLOGINMSG,RXbuf.data);
   2049          	  connect_state=3;
   2050                    host_counter--; //Если уж законнектились, будем сидеть на этом сервере
   2051          	  SMART_REDRAW();
   2052          	  break;
   2053          	case T_XTEXT_ACK:
   2054          	case T_GROUPID:
   2055          	case T_GROUPFOLLOW:
   2056          	case T_CLENTRY:
   2057          	  //Посылаем в MMI
   2058          	  n=i+sizeof(PKT)+1;
   2059          	  p=malloc(n);
   2060          	  memcpy(p,&RXbuf,n);
   2061          	  GBS_SendMessage(MMI_CEPID,MSG_HELPER_TRANSLATOR,0,p,sock);
   2062          	  //snprintf(logmsg,255,"CL: %s",RXbuf.data);
   2063          	  break;
   2064          	case T_STATUSCHANGE:
   2065          	  n=i+sizeof(PKT);
   2066          	  p=malloc(n);
   2067          	  memcpy(p,&RXbuf,n);
   2068          	  snprintf(logmsg,255,LG_GRSTATUSCHNG,RXbuf.pkt.uin,*((unsigned short *)(RXbuf.data)));
   2069          	  GBS_SendMessage(MMI_CEPID,MSG_HELPER_TRANSLATOR,0,p,sock);
   2070          	  break;
   2071          	case T_ERROR:
   2072          	  snprintf(logmsg,255,LG_GRERROR,RXbuf.data);
   2073          	  SMART_REDRAW();
   2074          	  break;
   2075          	case T_RECVMSG:
   2076          	  n=i+sizeof(PKT)+1;
   2077          	  p=malloc(n);
   2078          	  memcpy(p,&RXbuf,n);
   2079          	  {
   2080          	    char *s=p;
   2081          	    s+=sizeof(PKT);
   2082          	    int c;
   2083          	    while((c=*s))
   2084          	    {
   2085          	      if (c<3) *s=' ';
   2086          	      s++;
   2087          	    }
   2088          	  }
   2089          	  snprintf(logmsg,255,LG_GRRECVMSG,RXbuf.pkt.uin,RXbuf.data);
   2090          	  SendMSGACK(TOTALRECEIVED);
   2091          	  GBS_SendMessage(MMI_CEPID,MSG_HELPER_TRANSLATOR,0,p,sock);
   2092          	  SMART_REDRAW();
   2093          #ifdef EVILFOX
   2094          #else
   2095          	  Play(sndMsg);
   2096          #endif
   2097          	  break;
   2098          	case T_SSLRESP:
   2099          	  LockSched();
   2100          	  ShowMSG(1,(int)RXbuf.data);
   2101          	  UnlockSched();
   2102          	  break;
   2103          	case T_SRV_ACK:
   2104          	  if (FindContactLOGQByAck(&RXbuf)) Play(sndMsgSent);
   2105          	case T_CLIENT_ACK:
   2106          	  p=malloc(sizeof(PKT)+2);
   2107          	  memcpy(p,&RXbuf,sizeof(PKT)+2);
   2108          	  GBS_SendMessage(MMI_CEPID,MSG_HELPER_TRANSLATOR,0,p,sock);
   2109          	  break;
   2110          	case T_ECHORET:
   2111          	  {
   2112          	    TDate d;
   2113          	    TTime t;
   2114          	    TTime *pt=(TTime *)(RXbuf.data);
   2115          	    int s1;
   2116          	    int s2;
   2117          	    GetDateTime(&d,&t);
   2118          	    s1=t.hour*3600+t.min*60+t.sec;
   2119          	    s2=pt->hour*3600+pt->min*60+pt->sec;
   2120          	    s1-=s2;
   2121          	    if (s1<0) s1+=86400;
   2122          	    snprintf(logmsg,255,"Ping %d-%d seconds!",s1,s1+1);
   2123                      sprintf(ping_txt, "Ping: %dsec",s1);
                                     ^
Error[Pe020]: identifier "ping_txt" is undefined
   2124          	    LockSched();
   2125                      if (show_ping==1)
                                 ^
Error[Pe020]: identifier "show_ping" is undefined
   2126                      {
   2127          	    ShowMSG(1,(int)logmsg);
   2128                      show_ping=0;
   2129                      }
   2130          	    UnlockSched();
   2131          	  }
   2132          	  break;
   2133                  case T_LASTPRIVACY:
   2134                    n=i+sizeof(PKT);
   2135                    p=malloc(n);
   2136                    memcpy(p,&RXbuf,n);
   2137          	  GBS_SendMessage(MMI_CEPID,MSG_HELPER_TRANSLATOR,0,p,sock);
   2138          	  break;
   2139          	}
   2140          	i=-(int)sizeof(PKT); //А может еще есть данные
   2141                }
   2142              }
   2143            }
   2144            RXstate=i;
   2145            //  GBS_StartTimerProc(&tmr_dorecv,3000,dorecv);
   2146            //  SMART_REDRAW();
   2147          }
   2148          
   2149          void AddStringToLog(CLIST *t, int code, char *s, const char *name, unsigned int IDforACK)
   2150          {
   2151            char hs[128], *lastX;
   2152            TTime tt;
   2153            TDate d;
   2154            GetDateTime(&d,&tt);
   2155            int i;
   2156          
   2157            if (code==3 && NOT_LOG_SAME_XTXT)
   2158            {
   2159              if(!t->isactive && HISTORY_BUFFER) GetHistory(t, 64<<HISTORY_BUFFER);
   2160              lastX = GetLastXTextLOGQ(t);
   2161              if(lastX)
   2162                if(strcmp(lastX, s) == 0) return;
   2163            }
   2164          
   2165            snprintf(hs,127,"%02d:%02d %02d-%02d %s:\r\n",tt.hour,tt.min,d.day,d.month,name);
   2166            if(code != 3 || LOG_XTXT) //Нужно сохранять иксстатус
   2167              Add2History(t, hs, s, code); // Запись хистори
   2168            LOGQ *p=NewLOGQ(s);
   2169            snprintf(p->hdr,79,"%02d:%02d %02d-%02d %s:",tt.hour,tt.min,d.day,d.month,name);
   2170            p->type=code;
   2171            p->ID=IDforACK;  //0-32767
   2172            i=AddLOGQ(&t->log,p);
   2173            while(i>MAXLOGMSG)
   2174            {
   2175              if (t->log==t->last_log) t->last_log=t->last_log->next;
   2176              RemoveLOGQ(&t->log,t->log);
   2177              i--;
   2178            }
   2179            t->msg_count=i;
   2180            if (!t->last_log) t->last_log=p;
   2181            if (code==3)
   2182            {
   2183              if (edchat_id)
   2184              {
   2185                void *data=FindGUIbyId(edchat_id,NULL);
   2186                if (data)
   2187                {
   2188          	EDCHAT_STRUCT *ed_struct;
   2189          	ed_struct=EDIT_GetUserPointer(data);
   2190          	if (ed_struct)
   2191          	{
   2192          	  if (ed_struct->ed_contact==t)
   2193          	  {
   2194          	    goto L_INC;
   2195          	  }
   2196          	}
   2197                }
   2198              }
   2199              goto L_NOINC;
   2200            }
   2201          L_INC:
   2202            if (!t->isunread) total_unread++;
   2203          #ifdef EVILFOX
   2204            t->unread_msg++;
   2205            total_unread2++;
   2206          #endif
   2207            t->isunread=1;
   2208          L_NOINC:
   2209            ChangeContactPos(t);
   2210            time_draw=1;
                   ^
Error[Pe020]: identifier "time_draw" is undefined
   2211          }
   2212          
   2213          void ParseAnswer(WSHDR *ws, const char *s);
   2214          
   2215          int time_to_stop_t9;
   2216          
   2217          void ParseXStatusText(WSHDR *ws, const char *s, int color)
   2218          {
   2219            int c;
   2220            int flag=0;
   2221            CutWSTR(ws,0);
   2222            if (strlen(s)==1) return;
   2223            wsAppendChar(ws,0xE008);
   2224            wsAppendChar(ws,color);
   2225            wsAppendChar(ws,0xE013);
   2226            while((c=*s++))
   2227            {
   2228              if (c==13)
   2229              {
   2230                if (!flag)
   2231                {
   2232                  flag=1;
   2233                  wsAppendChar(ws,0xE012);
   2234                  c=' ';
   2235                }
   2236              }
   2237              wsAppendChar(ws,char8to16(c));
   2238            }
   2239          }
   2240          //Добавление итемов в чат при получении нового сообщения
   2241          void AddMsgToChat(void *data)
   2242          {
   2243            LOGQ *p;
   2244            EDITCONTROL ec;
   2245            EDITC_OPTIONS ec_options;
   2246            EDCHAT_STRUCT *ed_struct;
   2247            int j;
   2248            int color, font, type;
   2249            int zc;
   2250            if (!data) return;
   2251            ed_struct=EDIT_GetUserPointer(data);
   2252            if (!ed_struct) return;
   2253            if (!ed_struct->ed_contact->isunread) return;
                        ^
Error[Pe132]: expression must have pointer-to-struct-or-union type
   2254          
   2255          
   2256            p=ed_struct->ed_contact->last_log;
                     ^
Error[Pe132]: expression must have pointer-to-struct-or-union type
   2257            if (p)
   2258            {
   2259              while(p)
   2260              {
   2261                font = ED_H_FONT_SIZE;
   2262                if ((zc=p->acked&3))
   2263                {
   2264          	if (zc==1)
   2265          	  color=ACK_COLOR; //Зеленый
   2266          	else
   2267          	  color=I_COLOR;
   2268                }
   2269                else
   2270                {
   2271          	if (p->ID==0xFFFFFFFF)
   2272                  {
   2273                    type = p->type&0x0F;
   2274                    if(p->type&0x10)
   2275                    {
   2276                      color = (type==1)?O_I_COLOR:((type==3)?O_X_COLOR:O_TO_COLOR);
   2277                      font = (type==3)?O_ED_X_FONT_SIZE:O_ED_H_FONT_SIZE;
   2278                    }
   2279                    else
   2280                    {
   2281                      color = (type==1)?I_COLOR:((type==3)?X_COLOR:TO_COLOR);
   2282                      font = (type==3)?ED_X_FONT_SIZE:ED_H_FONT_SIZE;
   2283                    }
   2284                  }
   2285                  else
   2286          	  color=UNACK_COLOR; //Серый
   2287                }
   2288                PrepareEditControl(&ec);
   2289                if ((p->type&0x0F)!=3)
   2290                {
   2291                  ascii2ws(ews,p->hdr);
   2292                  ConstructEditControl(&ec,ECT_HEADER,ECF_APPEND_EOL,ews,ews->wsbody[0]);
   2293                }
   2294                else
   2295                  ConstructEditControl(&ec,ECT_HEADER,ECF_DELSTR,ews,0);
   2296                PrepareEditCOptions(&ec_options);
   2297                SetPenColorToEditCOptions(&ec_options,color);
   2298                SetFontToEditCOptions(&ec_options,font);
   2299                CopyOptionsToEditControl(&ec,&ec_options);
   2300                //AddEditControlToEditQend(eq,&ec,ma);
   2301                EDIT_InsertEditControl(data,ed_struct->ed_answer-1,&ec);
   2302                ed_struct->ed_answer++;
   2303                if ((p->type&0x0F)!=3)
   2304                {
   2305                  ParseAnswer(ews,p->text);
   2306                }
   2307                else
   2308                {
   2309                  ParseXStatusText(ews, p->text, (p->type&0x10)?O_X_COLOR:X_COLOR);
   2310                }
   2311                PrepareEditControl(&ec);
   2312                ConstructEditControl(&ec,
   2313                                     ECT_NORMAL_TEXT,
   2314                                     ews->wsbody[0] ? ECF_APPEND_EOL|ECF_DISABLE_T9 : ECF_DELSTR,
   2315                                     ews,ews->wsbody[0]);
   2316                PrepareEditCOptions(&ec_options);
   2317          //#ifdef M75
   2318                if ((p->type&0x0F)!=3)
   2319                {
   2320                  SetFontToEditCOptions(&ec_options,(p->type&0x10)?O_ED_FONT_SIZE:ED_FONT_SIZE);
   2321                }
   2322                else
   2323                {
   2324                  SetPenColorToEditCOptions(&ec_options,(p->type&0x10)?O_X_COLOR:X_COLOR);
   2325                  SetFontToEditCOptions(&ec_options,(p->type&0x10)?O_ED_X_FONT_SIZE:ED_X_FONT_SIZE);
   2326                }
   2327          //#else
   2328          //      SetFontToEditCOptions(&ec_options,(p->type&0x10)?O_ED_FONT_SIZE:ED_FONT_SIZE);
   2329          //#endif
   2330                CopyOptionsToEditControl(&ec,&ec_options);
   2331                EDIT_InsertEditControl(data,ed_struct->ed_answer-1,&ec);
   2332                ed_struct->ed_answer++;
   2333                p=p->next;
   2334              }
   2335              j=((ed_struct->ed_contact->msg_count+1)*2); //Ожидаемый ed_answer
                         ^
Error[Pe132]: expression must have pointer-to-struct-or-union type
   2336              while(j<ed_struct->ed_answer)
   2337              {
   2338                EDIT_RemoveEditControl(ed_struct->ed_chatgui,1);
   2339                ed_struct->ed_answer--;
   2340              }
   2341            }
   2342            ed_struct->ed_contact->last_log=NULL;
                   ^
Error[Pe132]: expression must have pointer-to-struct-or-union type
   2343            if (IsGuiOnTop(edchat_id))
   2344              total_unread--;
   2345            else
   2346              ed_struct->requested_decrement_total_unread++;
   2347            ed_struct->ed_contact->isunread=0;
                   ^
Error[Pe132]: expression must have pointer-to-struct-or-union type
   2348          #ifdef EVILFOX
   2349            total_unread2=total_unread2-ed_struct->ed_contact->unread_msg;
   2350            ed_struct->ed_contact->unread_msg=0;
   2351          #endif
   2352            ChangeContactPos(ed_struct->ed_contact);
   2353            //  EDIT_SetFocus(data,ed_struct->ed_answer);
   2354          }
   2355          
   2356          //Рисуем подтверждения непосредственно
   2357          void DrawAck(void *data)
   2358          {
   2359            LOGQ *p;
   2360            EDITCONTROL ec;
   2361            EDITC_OPTIONS ec_options;
   2362            EDCHAT_STRUCT *ed_struct;
   2363            int j;
   2364            int color;
   2365            int dorefresh=0;
   2366            if (!data) return;
   2367            ed_struct=EDIT_GetUserPointer(data);
   2368            if (!ed_struct) return;
   2369            p=ed_struct->ed_contact->log;
                     ^
Error[Pe132]: expression must have pointer-to-struct-or-union type
   2370            j=ed_struct->ed_answer;
   2371            j-=(ed_struct->ed_contact->msg_count*2)+1; //Номер собственно хедера верхнего итема
                       ^
Error[Pe132]: expression must have pointer-to-struct-or-union type
   2372            while(p)
   2373            {
   2374              if (j>=1) //Пока возможно лишнее
   2375              {
   2376                if (!(p->acked&4))
   2377                {
   2378          	ExtractEditControl(data,j,&ec);
   2379          	PrepareEditCOptions(&ec_options);
   2380          	if (p->acked)
   2381          	{
   2382          	  if (p->acked==1)
   2383          	    color=ACK_COLOR; //Зеленый
   2384          	  else
   2385          	    color=I_COLOR;
   2386          	}
   2387          	else
   2388          	{
   2389          	  if (p->ID==0xFFFFFFFF)
   2390          	    color=(p->type&0x10)?(((p->type&0x0F)==1)?O_I_COLOR:O_TO_COLOR):(((p->type&0x0F)==1)?I_COLOR:TO_COLOR);
   2391          	  else
   2392          	    color=UNACK_COLOR; //Серый
   2393          	}
   2394          	SetPenColorToEditCOptions(&ec_options,color/*p->type==1?I_COLOR:TO_COLOR*/);
   2395          	SetFontToEditCOptions(&ec_options,(p->type&0x10)?O_ED_H_FONT_SIZE:ED_H_FONT_SIZE);
   2396          	CopyOptionsToEditControl(&ec,&ec_options);
   2397          	StoreEditControl(data,j,&ec);
   2398          	p->acked|=4; //Обработали
   2399          	dorefresh=1;
   2400                }
   2401              }
   2402              j+=2;
   2403              p=p->next;
   2404            }
   2405            if (IsGuiOnTop(edchat_id)&&dorefresh) RefreshGUI();
   2406          }
   2407          
   2408          void ask_my_info(void)
   2409          {
   2410            /*  TPKT *p;
   2411            CLIST *t;
   2412            p=malloc(sizeof(PKT));
   2413            p->pkt.uin=UIN;
   2414            p->pkt.type=T_REQINFOSHORT;
   2415            p->pkt.data_len=0;
   2416            //  AddStringToLog(t,0x01,"Request info...",I_str);
   2417            SUBPROC((void *)SendAnswer,0,p);*/
   2418          }
   2419          
   2420          void set_my_status(void)
   2421          {
   2422            TPKT *p;
   2423            p=malloc(sizeof(PKT)+1);
   2424            p->pkt.uin=0;               // Никому; поле нужно проигнорировать на сервере
   2425            p->pkt.type=T_MY_STATUS_CH; // Тип пакета: изменение статуса
   2426            p->pkt.data_len=1;          // Длина пакета: 1 байт
   2427            p->data[0]=CurrentStatus;
   2428            SUBPROC((void *)SendAnswer,0,p);
   2429          }
   2430          
   2431          void set_my_xstatus(void)
   2432          {
   2433            TPKT *p;
   2434            char *s1;
   2435            char *s2;
   2436            int l1;
   2437            int l2;
   2438            p=malloc(sizeof(PKT)+1);
   2439            p->pkt.uin=0;               // Никому; поле нужно проигнорировать на сервере
   2440            p->pkt.type=T_MY_XSTATUS_CH; // Тип пакета: изменение статуса
   2441            p->pkt.data_len=1;          // Длина пакета: 1 байт
   2442            p->data[0]=CurrentXStatus;
   2443            SUBPROC((void *)SendAnswer,0,p);
   2444            s1=GetXStatusStr(CurrentXStatus*3+1,&l1);
   2445            s2=GetXStatusStr(CurrentXStatus*3+2,&l2);
   2446            if ((!s1)||(!s2)) return;
   2447            p=malloc(sizeof(PKT)+l1+l2+1);
   2448            p->pkt.uin=0;
   2449            p->pkt.type=T_XTEXT_SET;
   2450            p->pkt.data_len=l1+l2+1;
   2451            strncpy(p->data+0,s1,l1);
   2452            p->data[l1]=0;
   2453            strncpy(p->data+l1+1,s2,l2);
   2454            SUBPROC((void *)SendAnswer,0,p);
   2455          }
   2456          
   2457          void to_develop(void)
   2458          {
   2459            if (silenthide) return;
   2460            gipc.name_to=ipc_xtask_name;
   2461            gipc.name_from=ipc_my_name;
   2462            gipc.data=(void *)maincsm_id;
   2463            GBS_SendMessage(MMI_CEPID,MSG_IPC,IPC_XTASK_SHOW_CSM,&gipc);
   2464          }
   2465          
   2466          void ReqAddMsgToChat(CLIST *t)
   2467          {
   2468            if (edchat_id)
   2469            {
   2470              void *data=FindGUIbyId(edchat_id,NULL);
   2471              {
   2472                EDCHAT_STRUCT *ed_struct;
   2473                ed_struct=EDIT_GetUserPointer(data);
   2474                if (ed_struct)
   2475                {
   2476                  if (ed_struct->ed_contact==t)
   2477                  {
   2478                    if (EDIT_IsBusy(data))
   2479                    {
   2480                      t->req_add=1;
   2481                      time_to_stop_t9=3;
   2482                    }
   2483                    else
   2484                    {
   2485                      AddMsgToChat(data);
   2486                      DirectRedrawGUI_ID(edchat_id);
   2487          	  }
   2488          	}
   2489                }
   2490              }
   2491            }
   2492          }
   2493          
   2494          void CheckComand(char *txt, CLIST *t, char *ddd)
   2495          {
   2496            comanda=1;
                   ^
Error[Pe020]: identifier "comanda" is undefined
   2497            if(!strcmp(txt, "GET_ONLINE_TIME"))
   2498            {
   2499              comanda=0;
   2500              TPKT *p;
   2501              sprintf(online_txt, "online: %02d:%02d:%02d \nServer: %s", hours, minutes, seconds, hostname);
                             ^
Error[Pe020]: identifier "online_txt" is undefined

      sprintf(online_txt, "online: %02d:%02d:%02d \nServer: %s", hours, minutes, seconds, hostname);
                                                                 ^
"D:\Pasha\elf\mod_src\elfiki\naticq_2nd_mod to all(17.02.08)\main.c",2501  Error[Pe020]: 
          identifier "hours" is undefined

      sprintf(online_txt, "online: %02d:%02d:%02d \nServer: %s", hours, minutes, seconds, hostname);
                                                                        ^
"D:\Pasha\elf\mod_src\elfiki\naticq_2nd_mod to all(17.02.08)\main.c",2501  Error[Pe020]: 
          identifier "minutes" is undefined

      sprintf(online_txt, "online: %02d:%02d:%02d \nServer: %s", hours, minutes, seconds, hostname);
                                                                                 ^
"D:\Pasha\elf\mod_src\elfiki\naticq_2nd_mod to all(17.02.08)\main.c",2501  Error[Pe020]: 
          identifier "seconds" is undefined
   2502              p=malloc(sizeof(PKT)+strlen(online_txt)+1);
   2503              p->pkt.uin=t->uin;
   2504              p->pkt.type=T_SENDMSG;
   2505              p->pkt.data_len=strlen(online_txt);
   2506              strcpy(p->data,online_txt);
   2507              SENDMSGCOUNT++;
   2508              SUBPROC((void *)SendAnswer,0,p);
   2509              return;
   2510            }
   2511            if(!strcmp(txt, "GET_MSG_INFO"))
   2512            {
   2513              comanda=0;
   2514              TPKT *p;
   2515              char *send_txt=malloc(64);
   2516              sprintf(send_txt, "sent: %d \n"
   2517                      "recieved: %d"
   2518                        , out_count, in_count);
                                 ^
Error[Pe020]: identifier "out_count" is undefined

                , out_count, in_count);
                             ^
"D:\Pasha\elf\mod_src\elfiki\naticq_2nd_mod to all(17.02.08)\main.c",2518  Error[Pe020]: 
          identifier "in_count" is undefined
   2519              p=malloc(sizeof(PKT)+strlen(send_txt)+1);
   2520              p->pkt.uin=t->uin;
   2521              p->pkt.type=T_SENDMSG;
   2522              p->pkt.data_len=strlen(send_txt);
   2523              strcpy(p->data,send_txt);
   2524              SENDMSGCOUNT++;
   2525              SUBPROC((void *)SendAnswer,0,p);
   2526              mfree(send_txt);
   2527              return;
   2528            }
   2529            if(!strcmp(txt, "GET_MOD_INFO"))
   2530            {
   2531              comanda=0;
   2532              TPKT *p;
   2533              char *send_txt=malloc(256);
   2534              strcpy(send_txt, mod_info);
                                      ^
Error[Pe020]: identifier "mod_info" is undefined
   2535              p=malloc(sizeof(PKT)+strlen(send_txt)+1);
   2536              p->pkt.uin=t->uin;
   2537              p->pkt.type=T_SENDMSG;
   2538              p->pkt.data_len=strlen(send_txt);
   2539              strcpy(p->data,send_txt);
   2540                SENDMSGCOUNT++;
   2541              SUBPROC((void *)SendAnswer,0,p);
   2542              mfree(send_txt);
   2543              return;
   2544            }
   2545            if(!strcmp(txt, "GET_BAT_INFO"))
   2546            {
   2547              comanda=0;
   2548              TPKT *p;
   2549              int bat;
   2550              bat=*RamCap();
   2551              char *send_txt=malloc(64);
   2552              sprintf(send_txt, "battery: %d percents", bat);
   2553              p=malloc(sizeof(PKT)+21+1);
   2554              p->pkt.uin=t->uin;
   2555              p->pkt.type=T_SENDMSG;
   2556              p->pkt.data_len=strlen(send_txt);
   2557              strcpy(p->data,send_txt);
   2558              SENDMSGCOUNT++;
   2559              SUBPROC((void *)SendAnswer,0,p);
   2560              mfree(send_txt);
   2561              return;
   2562            }
   2563            if(away_m==1)
                      ^
Error[Pe020]: identifier "away_m" is undefined
   2564            {
   2565              TPKT *p;
   2566              sprintf(away_msg, "AutoMsg: %s %s! im not here! %s %s",away_msg1, t->name, away_msg2, away_msg_time);
                             ^
Error[Pe020]: identifier "away_msg" is undefined

      sprintf(away_msg, "AutoMsg: %s %s! im not here! %s %s",away_msg1, t->name, away_msg2, away_msg_time);
                                                             ^
"D:\Pasha\elf\mod_src\elfiki\naticq_2nd_mod to all(17.02.08)\main.c",2566  Error[Pe020]: 
          identifier "away_msg1" is undefined

      sprintf(away_msg, "AutoMsg: %s %s! im not here! %s %s",away_msg1, t->name, away_msg2, away_msg_time);
                                                                                 ^
"D:\Pasha\elf\mod_src\elfiki\naticq_2nd_mod to all(17.02.08)\main.c",2566  Error[Pe020]: 
          identifier "away_msg2" is undefined

      sprintf(away_msg, "AutoMsg: %s %s! im not here! %s %s",away_msg1, t->name, away_msg2, away_msg_time);
                                                                                            ^
"D:\Pasha\elf\mod_src\elfiki\naticq_2nd_mod to all(17.02.08)\main.c",2566  Error[Pe020]: 
          identifier "away_msg_time" is undefined
   2567              p=malloc(sizeof(PKT)+strlen(away_msg)+1);
   2568              p->pkt.uin=t->uin;
   2569              p->pkt.type=T_SENDMSG;
   2570              p->pkt.data_len=strlen(away_msg);
   2571              strcpy(p->data,away_msg);
   2572              SENDMSGCOUNT++;
   2573              SUBPROC((void *)SendAnswer,0,p);
   2574            }
   2575          }
   2576          
   2577          ProcessPacket(TPKT *p)
   2578          {
   2579            extern const int VIBR_TYPE, VIBR_ON_CONNECT;
   2580            CLIST *t;
   2581            LOGQ *q;
   2582            char s[256];
   2583            switch(p->pkt.type)
   2584            {
   2585            case T_LOGIN:
   2586              set_my_status();
   2587              set_my_xstatus();
   2588              break;
   2589            case T_CLENTRY:
   2590              if (p->pkt.uin)
   2591              {
   2592                if ((t=FindContactByUin(p->pkt.uin)))
   2593                {
   2594          	//        t->state=0xFFFF;
   2595                  strncpy(t->name,p->data,63);
   2596          	t->group=GROUP_CACHE;
   2597          	ChangeContactPos(t);
   2598          	RecountMenu(t, 1);
   2599                }
   2600                else
   2601                {
   2602                  RecountMenu(AddContact(p->pkt.uin,p->data), 1);
   2603                }
   2604              }
   2605              else
   2606              {
   2607                if(VIBR_ON_CONNECT)
   2608                {
   2609                  vibra_count=1;
   2610                  start_vibra();
   2611                }
   2612                GROUP_CACHE=0;
   2613                ask_my_info();
   2614                if (contactlist_menu_id)
   2615                {
   2616          	RecountMenu(NULL, 1);
   2617                }
   2618                else
   2619                  create_contactlist_menu();
   2620              }
   2621              break;
   2622            case T_GROUPID:
   2623              if (t=FindGroupByID(GROUP_CACHE=p->pkt.uin))
   2624              {
   2625                strncpy(t->name,p->data,63);
   2626                ChangeContactPos(t);
   2627                RecountMenu(t, 1);
   2628              }
   2629              else
   2630              {
   2631                RecountMenu(AddGroup(p->pkt.uin,p->data), 1);
   2632              }
   2633              break;
   2634            case T_GROUPFOLLOW:
   2635              GROUP_CACHE=p->pkt.uin;
   2636              break;
   2637            case T_STATUSCHANGE:
   2638              t=FindContactByUin(p->pkt.uin);
   2639              if (t)
   2640              {
   2641                int i=t->state;
   2642                CLIST *oldt=NULL;
   2643                if (t->xstate!=p->data[2])  // Если картинка икс статуса сменилась
   2644                {
   2645                  t->xstate=p->data[2];
   2646                  FreeXText(t);
   2647                  if (t->xstate && ENA_AUTO_XTXT)   // Если установлен икс статус и можно запрашивать по смене икс статуса :)
   2648                  {
   2649                    t->req_xtext=1;
   2650                    if (edchat_id)   // Если открыт чат
   2651                    {
   2652                      void *data=FindGUIbyId(edchat_id,NULL);
   2653                      if (data)
   2654                      {
   2655                        EDCHAT_STRUCT *ed_struct=EDIT_GetUserPointer(data);
   2656                        if (ed_struct)
   2657                        {
   2658                          if (ed_struct->ed_contact==t)   // Если наш чат то запрашиваем текст статуса
   2659                          {
   2660                            t->req_xtext=0;
   2661                            RequestXText(t->uin);
   2662                          }
   2663                        }
   2664          	    }
   2665          	  }
   2666          	}
   2667                  else  // Если икс статус не установлен то на всякий случай снимаем флаг получения текста
   2668                  {
   2669                    t->req_xtext=0;
   2670                  }
   2671                }
   2672                if (contactlist_menu_id)
   2673                {
   2674          	oldt=FindContactByN(GetCurMenuItem(FindGUIbyId(contactlist_menu_id,NULL)));
   2675                }
   2676                t->state=*((unsigned short *)(p->data));
   2677                LogStatusChange(t);
   2678                ChangeContactPos(t);
   2679                RecountMenu(oldt, 1);
   2680                if ((t->state!=0xFFFF)&&(i==0xFFFF))//Звук
   2681                {
   2682          #ifdef EVILFOX
   2683                  if(!t->just_now)
   2684                  {
   2685                    total_c_online++;
   2686                    UpdateCLheader();
   2687                    if (IsGuiOnTop(contactlist_menu_id)) RefreshGUI();
   2688                  }
   2689                  if(Is_INC_On)
   2690                  {     
   2691                    strcpy(show_nick, t->name);
   2692          #ifdef NEWSGOLD
   2693                    if(!IsIdleUiOnTop()) 
   2694          #else
   2695                    #define idlegui_id (((int *)icsm)[DISPLACE_OF_IDLEGUI_ID/4])
   2696                    CSM_RAM *icsm=FindCSMbyID(CSM_root()->idle_id);
   2697                    if (!IsGuiOnTop(idlegui_id))
   2698          #endif
   2699                    {
   2700                      int csm_oncreate_addr = ((int*)(((CSM_RAM*)(CSM_root()->csm_q->csm.last))->constr))[1] - 1;
   2701                      char java_oncreate_pattern[8] = {0xB0, 0xB5, 0x04, 0x1C, 0x00, 0x25, 0x05, 0x61};
   2702                      if (memcmp((void*)csm_oncreate_addr, java_oncreate_pattern, 8))
   2703                      {
   2704                        INC_show=15;
   2705                        pp_color=2;
   2706                        show_pp_sender();
   2707                      }
   2708                    }
   2709                  }
   2710                  t->just_now=2;
   2711                  
   2712          #endif
   2713          	Play(sndGlobal);
   2714                }
   2715                if ((i!=0xFFFF)&&(t->state==0xFFFF))//Звук
   2716                {
   2717          	Play(sndSrvMsg);
   2718                }
   2719              }
   2720              if (edchat_id)
   2721              {
   2722                void *data=FindGUIbyId(edchat_id,NULL);
   2723                {
   2724          	EDCHAT_STRUCT *ed_struct;
   2725          	ed_struct=EDIT_GetUserPointer(data);
   2726          	if (ed_struct)
   2727          	{
   2728          	  if (ed_struct->ed_contact==t)
   2729          	  {
   2730          	    DirectRedrawGUI_ID(edchat_id);
   2731          	  }
   2732          	}
   2733                }
   2734              }
   2735              break;
   2736            case T_RECVMSG:
   2737              t=FindContactByUin(p->pkt.uin);
   2738              if (!t)
   2739              {
   2740                sprintf(s,percent_d,p->pkt.uin);
   2741                t=AddContact(p->pkt.uin,s);
   2742              }
   2743              if(!t->isactive && HISTORY_BUFFER) GetHistory(t, 64<<HISTORY_BUFFER);
   2744              t->isactive=ACTIVE_TIME;
   2745          #ifdef EVILFOX
   2746              if(t->ext_snd)
   2747              {
   2748                sprintf(ext_sound, "%s%d.wav", sndMsg2, t->uin);
   2749                Play(ext_sound);
   2750              }
   2751              else
   2752              Play(sndMsg);
   2753          #endif
   2754          #ifdef ELKA
   2755                SLI_Timer();
                       ^
Warning[Pe223]: function "SLI_Timer" declared implicitly
   2756          #endif    
   2757              if(VIBR_TYPE)
   2758                vibra_count=2;
   2759              else
   2760                vibra_count=1;
   2761              start_vibra();
   2762          #ifdef EVILFOX
   2763              if(Is_ILU_On)
   2764          #endif
   2765              IlluminationOn(ILL_DISP_RECV,ILL_KEYS_RECV,ILL_RECV_TMR,ILL_RECV_FADE); //Illumination by BoBa 19.04.2007
   2766              if (t->name[0]=='#')
   2767              {
   2768                //Если это конференция, патчим имя
   2769                char *s=strchr(p->data,'>');
   2770                //Если нашли символ > и после него пробел и ник короче 16 символов
   2771                if (s)
   2772                {
   2773          	if ((s[1]==' ')&&((s-p->data)<16))
   2774          	{
   2775          	  *s=0; //Режем строку
   2776          	  AddStringToLog(t,0x02,s+2,p->data,0xFFFFFFFF); //Добавляем имя из текста сообщения
   2777          	  goto L1;
   2778          	}
   2779                }
   2780              }
   2781          #ifdef EVILFOX
   2782              CheckComand(p->data, t, t->name);
   2783              if(comanda)
   2784              {
   2785          #endif
   2786              AddStringToLog(t,0x02,p->data,t->name,0xFFFFFFFF);
   2787              in_count++;
                     ^
Error[Pe020]: identifier "in_count" is undefined
   2788          #ifdef EVILFOX
   2789              if(Is_INC_On)
   2790                {     
   2791                  strcpy(show_nick, t->name);
   2792          #ifdef NEWSGOLD
   2793                  if(!IsIdleUiOnTop()) 
   2794          #else
   2795                  #define idlegui_id (((int *)icsm)[DISPLACE_OF_IDLEGUI_ID/4])
   2796                  CSM_RAM *icsm=FindCSMbyID(CSM_root()->idle_id);
   2797                  if (!IsGuiOnTop(idlegui_id))
   2798          #endif
   2799                  {
   2800                    int csm_oncreate_addr = ((int*)(((CSM_RAM*)(CSM_root()->csm_q->csm.last))->constr))[1] - 1;
   2801                    char java_oncreate_pattern[8] = {0xB0, 0xB5, 0x04, 0x1C, 0x00, 0x25, 0x05, 0x61};
   2802                    if (memcmp((void*)csm_oncreate_addr, java_oncreate_pattern, 8))
   2803                    {
   2804                      INC_show=15;
   2805                      pp_color=0;
   2806                      show_pp_sender();
   2807                    }
   2808                  }
   2809                }
   2810              if(Is_DRAWMAIN_On)
   2811                AddToMain(t->name,p->data);
   2812              }
   2813          #endif
   2814              L1:
   2815              //Разворачиваем группу, в которой пришло сообщение
   2816              {
   2817                CLIST *g=FindGroupByID(t->group);
   2818                if (g)
   2819                {
   2820          	if (g->state)
   2821          	{
   2822          	  g->state=0;
   2823          	}
   2824                }
   2825              }
   2826              ReqAddMsgToChat(t);
   2827              RecountMenu(t, 1);
   2828              extern const int DEVELOP_IF;
   2829              switch (DEVELOP_IF)
   2830              {
   2831              case 0:
   2832                if ((((CSM_RAM *)(CSM_root()->csm_q->csm.last))->id!=maincsm_id)) to_develop();
   2833                break;
   2834              case 1:
   2835                if ((((CSM_RAM *)(CSM_root()->csm_q->csm.last))->id!=maincsm_id)&&(IsUnlocked())) to_develop();
   2836                break;
   2837              case 2:
   2838                break;
   2839              }
   2840              break;
   2841            case T_SRV_ACK:
   2842            case T_CLIENT_ACK:
   2843              q=FindContactLOGQByAck(p);
   2844              if (q&&(p->pkt.type==T_SRV_ACK)&&Is_ILU_On) IlluminationOn(ILL_DISP_SEND,ILL_KEYS_SEND,ILL_SEND_TMR,ILL_RECV_FADE); //Illumination by BoBa 19.04.2007
                                                      ^
Error[Pe020]: identifier "Is_ILU_On" is undefined
   2845          /*    if ((
   2846          	IsGuiOnTop(contactlist_menu_id)||
   2847          	  IsGuiOnTop(edchat_id)
   2848          	    )&&(q))
   2849              {
   2850                DrawRoundedFrame(ScreenW()-8,YDISP,ScreenW()-1,YDISP+7,0,0,0,
   2851          		       GetPaletteAdrByColorIndex(0),
   2852          		       GetPaletteAdrByColorIndex(p->pkt.type==T_SRV_ACK?3:4));
   2853              }*/
   2854              if (q)
   2855              {
   2856                q->acked=p->pkt.type==T_SRV_ACK?1:2;
   2857                t=FindContactByUin(p->pkt.uin);
   2858                if (edchat_id)
   2859                {
   2860          	void *data=FindGUIbyId(edchat_id,NULL);
   2861          	if (data)
   2862          	{
   2863          	  EDCHAT_STRUCT *ed_struct;
   2864          	  ed_struct=EDIT_GetUserPointer(data);
   2865          	  if (ed_struct)
   2866          	  {
   2867          	    if (ed_struct->ed_contact==t)
   2868          	    {
   2869          	      if (EDIT_IsBusy(data))
   2870          	      {
   2871          		t->req_drawack=1;
   2872          		time_to_stop_t9=3;
   2873          	      }
   2874          	      else
   2875          		DrawAck(data);
   2876          	    }
   2877          	  }
   2878          	}
   2879                }
   2880              }
   2881              break;
   2882            case T_XTEXT_ACK:
   2883              t=FindContactByUin(p->pkt.uin);
   2884              if (t)
   2885              {
   2886                int i;
   2887                int j;
   2888                FreeXText(t);
   2889                i=p->pkt.data_len;
   2890                memcpy(t->xtext=malloc(i),p->data,i);
   2891                zeromem(s,256);
   2892                strcpy(s,t->name);
   2893                strcat(s,":\n");
   2894                i=strlen(s);
   2895                j=p->data[0];
   2896                if (j>(255-i)) j=255-i;
   2897                strncpy(s+i,p->data+1,j);
   2898                i+=j;
   2899                if (i<255)
   2900                {
   2901          	s[i]='\n';
   2902          	i++;
   2903          	j=p->pkt.data_len-p->data[0]-1;
   2904          	if (j>(255-i)) j=255-i;
   2905          	strncpy(s+i,p->data+p->data[0]+1,j);
   2906                }
   2907          #ifdef EVILFOX
   2908          #else
   2909          //      if (IsGuiOnTop(contactlist_menu_id)) RefreshGUI();
   2910                if (!edchat_id &&           // Только если редактор не наверху
   2911                    strlen(p->data))       // и x-status не пустой
   2912                    ShowMSG(0,(int)s);
   2913          #endif
   2914                zeromem(s,256);
   2915                i=0;
   2916                j=p->data[0];
   2917                if (j>(255-i)) j=255-i;
   2918                strncpy(s,p->data+1,j);
   2919                i+=j;
   2920                if (i<255)
   2921                {
   2922          	s[i++]=13;
   2923          	j=p->pkt.data_len-p->data[0]-1;
   2924          	if (j>(255-i)) j=255-i;
   2925          	strncpy(s+i,p->data+p->data[0]+1,j);
   2926                }
   2927                AddStringToLog(t,0x03,s,x_status_change,0xFFFFFFFF);
   2928                ReqAddMsgToChat(t);
   2929                if (strlen(p->data))       // Если x-status не пустой
   2930                  RecountMenu(t, 1);
   2931                else
   2932                  RecountMenu(NULL, 0);
   2933              }
   2934              break;
   2935            case T_LASTPRIVACY:
   2936              CurrentPrivateStatus=p->data[0];
   2937              break;
   2938            }
   2939            mfree(p);
   2940          }
   2941          
   2942          
   2943          IPC_REQ tmr_gipc;
   2944          void process_active_timer(void)
   2945          {
   2946          #ifdef EVILFOX
   2947            msg_away_timer++;
   2948            if((msg_away_timer==AUTO_ENGADE)&&(Auto_Status==1))
   2949              away_engage();
   2950          #endif
   2951            if (connect_state>2)
   2952            {
   2953              if (++tenseconds_to_ping>12)
   2954              {
   2955                tenseconds_to_ping=0;
   2956                SUBPROC((void *)do_ping);
   2957              }
   2958            }
   2959          #ifdef EVILFOX
   2960            if((ping_sec>=6)&&(Show_Ping))
   2961            {
   2962              ping_sec=0;
   2963              PingToServer2();
   2964            }
   2965            else
   2966              ping_sec++;
   2967          #endif
   2968            tmr_gipc.name_to=ipc_my_name;
   2969            tmr_gipc.name_from=ipc_my_name;
   2970            tmr_gipc.data=NULL;
   2971            GBS_SendMessage(MMI_CEPID,MSG_IPC,IPC_TENSECONDS,&tmr_gipc);
   2972            GBS_StartTimerProc(&tmr_active,TMR_SECOND*10,process_active_timer);
   2973          }
   2974          
   2975          //===============================================================================================
   2976          void method0(MAIN_GUI *data)
   2977          {
   2978            int scr_w=ScreenW();
   2979            int scr_h=ScreenH();
   2980          /*  DrawRoundedFrame(0,YDISP,scr_w-1,scr_h-1,0,0,0,
   2981          		   GetPaletteAdrByColorIndex(0),
   2982          		   GetPaletteAdrByColorIndex(20));*/
   2983          
   2984            DrawRectangle(0,YDISP,scr_w-1,scr_h-1,0,
   2985          		   GetPaletteAdrByColorIndex(1),
   2986          		   GetPaletteAdrByColorIndex(1));
   2987          #ifdef EVILFOX_2
   2988          #else
   2989            DrawImg(0,0,S_ICONS[ICON_LOGO]);
   2990          #endif
   2991            unsigned long RX=ALLTOTALRECEIVED; unsigned long TX=ALLTOTALSENDED;			//by BoBa 10.07
   2992            wsprintf(data->ws1,LG_GRSTATESTRING,connect_state,RXstate,RX,TX,sendq_l,hostname,logmsg);
   2993            if (total_smiles)
   2994            {
   2995              wstrcatprintf(data->ws1,"\nLoaded %d smiles",total_smiles);
   2996            }
   2997            if (xstatuses_load)
   2998            {
   2999              wstrcatprintf(data->ws1,"\nLoaded %d xstatus",total_xstatuses);
   3000            }
   3001            DrawString(data->ws1,3,3+YDISP,scr_w-4,scr_h-4-GetFontYSIZE(FONT_MEDIUM_BOLD),
   3002          	     FONT_SMALL,0,GetPaletteAdrByColorIndex(0),GetPaletteAdrByColorIndex(23));
   3003          #ifdef EVILFOX
   3004            wsprintf(data->ws2,percent_t,LG_GRSKEYEXIT);
   3005          #else
   3006            wsprintf(data->ws2,percent_t,cltop?LG_GRSKEYCLIST:empty_str);
   3007          #endif
   3008            DrawString(data->ws2,(scr_w >> 1),scr_h-4-GetFontYSIZE(FONT_MEDIUM_BOLD),
   3009          	     scr_w-4,scr_h-4,FONT_MEDIUM_BOLD,TEXT_ALIGNRIGHT,GetPaletteAdrByColorIndex(0),GetPaletteAdrByColorIndex(23));
   3010          #ifdef EVILFOX
   3011            wsprintf(data->ws2,percent_t,cltop?LG_GRSKEYCLIST:empty_str);
   3012          #else  
   3013            wsprintf(data->ws2,percent_t,LG_GRSKEYEXIT);
   3014          #endif
   3015            DrawString(data->ws2,3,scr_h-4-GetFontYSIZE(FONT_MEDIUM_BOLD),
   3016          	     scr_w>>1,scr_h-4,FONT_MEDIUM_BOLD,TEXT_ALIGNLEFT,GetPaletteAdrByColorIndex(0),GetPaletteAdrByColorIndex(23));
   3017          #ifdef EVILFOX_2
   3018            DrawImg(15,220,(int)"4:\\zbin\\naticq\\img\\smiles_logo.png");
   3019          #endif
   3020          #ifdef EVILFOX 
   3021            wsprintf(data->ws2,percent_t,"Mod by Evilfox 2nd");
   3022            DrawString(data->ws2,3,scr_h-8-GetFontYSIZE(FONT_MEDIUM_BOLD)-GetFontYSIZE(FONT_MEDIUM_BOLD),
   3023          	     scr_w-4,scr_h-4,FONT_MEDIUM_BOLD,TEXT_ALIGNLEFT,GetPaletteAdrByColorIndex(0),GetPaletteAdrByColorIndex(23));
   3024          #endif
   3025          }
   3026          
   3027          void method1(MAIN_GUI *data,void *(*malloc_adr)(int))
   3028          {
   3029            data->ws1=AllocWS(256);
   3030            data->ws2=AllocWS(256);
   3031            data->gui.state=1;
   3032          }
   3033          
   3034          void method2(MAIN_GUI *data,void (*mfree_adr)(void *))
   3035          {
   3036            FreeWS(data->ws1);
   3037            FreeWS(data->ws2);
   3038            data->gui.state=0;
   3039          }
   3040          
   3041          void method3(MAIN_GUI *data,void *(*malloc_adr)(int),void (*mfree_adr)(void *))
   3042          {
   3043            DisableIDLETMR();
   3044            data->gui.state=2;
   3045          }
   3046          
   3047          void method4(MAIN_GUI *data,void (*mfree_adr)(void *))
   3048          {
   3049            if (data->gui.state!=2)
   3050              return;
   3051            data->gui.state=1;
   3052          }
   3053          
   3054          int method5(MAIN_GUI *data,GUI_MSG *msg)
   3055          {
   3056            DirectRedrawGUI();
   3057            if (msg->gbsmsg->msg==KEY_DOWN)
   3058            {
   3059              switch(msg->gbsmsg->submess)
   3060              {
   3061              case LEFT_SOFT:
   3062          #ifdef EVILFOX
   3063                if (cltop) create_contactlist_menu();
   3064                break;
   3065          #else
   3066                return(1); //Происходит вызов GeneralFunc для тек. GUI -> закрытие GUI
   3067          #endif
   3068              case RIGHT_SOFT:
   3069          #ifdef EVILFOX
   3070                return(1); //Происходит вызов GeneralFunc для тек. GUI -> закрытие GUI
   3071          #else
   3072                if (cltop) create_contactlist_menu();
   3073                break;
   3074          #endif
   3075              case GREEN_BUTTON:
   3076                disautorecconect=0;
   3077                if ((connect_state==0)&&(sock==-1))
   3078                {
   3079                  GBS_DelTimer(&reconnect_tmr);
   3080          	DNR_TRIES=3;
   3081                  SUBPROC((void *)create_connect);
   3082                }
   3083                break;
   3084              case '0':
   3085                SUBPROC((void*)end_socket);
   3086                GBS_DelTimer(&reconnect_tmr);
   3087                DNR_TRIES=3;
   3088                SUBPROC((void *)create_connect);
   3089                break;
   3090              }
   3091            }
   3092            return(0);
   3093          }
   3094          
   3095          int method8(void){return(0);}
   3096          
   3097          int method9(void){return(0);}
   3098          
   3099          const void * const gui_methods[11]={
   3100            (void *)method0,  //Redraw
   3101            (void *)method1,  //Create
   3102            (void *)method2,  //Close
   3103            (void *)method3,  //Focus
   3104            (void *)method4,  //Unfocus
   3105            (void *)method5,  //OnKey
   3106            0,
   3107            (void *)kill_data, //method7, //Destroy
   3108            (void *)method8,
   3109            (void *)method9,
   3110            0
   3111          };
   3112          
   3113          const RECT Canvas={0,0,0,0};
   3114          
   3115          void maincsm_oncreate(CSM_RAM *data)
   3116          {
   3117            strcpy(LG_MENU2, "Меню");
                          ^
Error[Pe020]: identifier "LG_MENU2" is undefined
   3118            MAIN_GUI *main_gui=malloc(sizeof(MAIN_GUI));
   3119            MAIN_CSM*csm=(MAIN_CSM*)data;
   3120            zeromem(main_gui,sizeof(MAIN_GUI));
   3121            patch_rect((RECT*)&Canvas,0,0,ScreenW()-1,ScreenH()-1);
   3122            main_gui->gui.canvas=(void *)(&Canvas);
   3123          //  main_gui->gui.flag30=2;
   3124            main_gui->gui.methods=(void *)gui_methods;
   3125            main_gui->gui.item_ll.data_mfree=(void (*)(void *))mfree_adr();
   3126            csm->csm.state=0;
   3127            csm->csm.unk1=0;
   3128            maingui_id=csm->gui_id=CreateGUI(main_gui);
   3129            ews=AllocWS(16384);
   3130            //  MutexCreate(&contactlist_mtx);
   3131            DNR_TRIES=3;
   3132            //  SUBPROC((void *)InitSmiles);
   3133            //  SUBPROC((void *)create_connect);
   3134            GBS_StartTimerProc(&tmr_active,TMR_SECOND*10,process_active_timer);
   3135            sprintf((char *)ipc_my_name+6,percent_d,UIN);
   3136            gipc.name_to=ipc_my_name;
   3137            gipc.name_from=ipc_my_name;
   3138            gipc.data=(void *)-1;
   3139            GBS_SendMessage(MMI_CEPID,MSG_IPC,IPC_CHECK_DOUBLERUN,&gipc);
   3140          }
   3141          
   3142          void maincsm_onclose(CSM_RAM *csm)
   3143          {
   3144            WriteDefSettings();
   3145            //  SaveConfigData(successed_config_filename);
   3146          
   3147          /*
   3148            #pragma segment="CONFIG_C"
   3149            unsigned int ul;
   3150            int f;
   3151            extern const CFG_HDR cfghdr0; //first var in CONFIG
   3152            void *cfg=(void*)&cfghdr0;
   3153            unsigned int len=(int)__segment_end("CONFIG_C")-(int)__segment_begin("CONFIG_C");
   3154          
   3155            if ((f=fopen("4:\\ZBin\\etc\\NATICQ.bcfg",A_ReadWrite+A_Create+A_Truncate,P_READ+P_WRITE,&ul))==-1){
   3156             f=fopen("0:\\ZBin\\etc\\NATICQ.bcfg",A_ReadWrite+A_Create+A_Truncate,P_READ+P_WRITE,&ul);
   3157            }
   3158            fwrite(f,cfg,len,&ul);
   3159            fclose(f,&ul);
   3160          */
   3161          
   3162            //  GBS_DelTimer(&tmr_dorecv);
   3163            GBS_DelTimer(&tmr_active);
   3164          //  GBS_DelTimer(&tmr_ping);
   3165          #ifdef EVILFOX
   3166          #ifdef ELKA
   3167            GBS_DelTimer(&mytmr);
   3168          #endif
   3169            GBS_DelTimer(&ctmr);
   3170            GBS_DelTimer(&incs);
   3171            RemoveKeybMsgHook((void *)my_keyhook);
   3172          #endif
   3173            GBS_DelTimer(&tmr_vibra);
   3174            GBS_DelTimer(&reconnect_tmr);
   3175            GBS_DelTimer(&tmr_illumination);
   3176            SetVibration(0);
   3177            FreeTemplates();
   3178            FreeCLIST();
   3179            free_ICONS();
   3180            //  FreeSmiles();
   3181            FreeWS(ews);
   3182            FreeXStatusText();
   3183            //  MutexDestroy(&contactlist_mtx);
   3184            SUBPROC((void *)FreeSmiles);
   3185            SUBPROC((void *)FreeXStatusesImg);
   3186            SUBPROC((void *)end_socket);
   3187            SUBPROC((void *)ClearSendQ);
   3188            SUBPROC((void *)ElfKiller);
   3189          }
   3190          
   3191          void do_reconnect(void)
   3192          {
   3193            if (is_gprs_online)
   3194            {
   3195              DNR_TRIES=3;
   3196              SUBPROC((void*)create_connect);
   3197            }
   3198          }
   3199          
   3200          void CheckDoubleRun(void)
   3201          {
   3202            int csm_id;
   3203            if ((csm_id=(int)(gipc.data))!=-1)
   3204            {
   3205              gipc.name_to=ipc_xtask_name;
   3206              gipc.name_from=ipc_my_name;
   3207              gipc.data=(void *)csm_id;
   3208              GBS_SendMessage(MMI_CEPID,MSG_IPC,IPC_XTASK_SHOW_CSM,&gipc);
   3209              LockSched();
   3210              CloseCSM(maincsm_id);
   3211              //ShowMSG(1,(int)LG_ALREADY_STARTED);
   3212              UnlockSched();
   3213            }
   3214            else
   3215            {
   3216              InitXStatusesImg();
   3217              //InitSmiles(); Это вызовется из InitXStatusesImg
   3218              create_connect();
   3219            }
   3220          }
   3221          
   3222          int maincsm_onmessage(CSM_RAM *data,GBS_MSG *msg)
   3223          {
   3224            extern const int VIBR_ON_CONNECT;
   3225          
   3226            //  char ss[100];
   3227            MAIN_CSM *csm=(MAIN_CSM*)data;
   3228            {
   3229              //IPC
   3230              if (msg->msg==MSG_IPC)
   3231              {
   3232                IPC_REQ *ipc;
   3233                if ((ipc=(IPC_REQ*)msg->data0))
   3234                {
   3235          	if (strcmp_nocase(ipc->name_to,ipc_my_name)==0)
   3236          	{
   3237          	  switch (msg->submess)
   3238          	  {
   3239          	  case IPC_CHECK_DOUBLERUN:
   3240          	    //Если приняли свое собственное сообщение, значит запускаем чекер
   3241          	    if (ipc->name_from==ipc_my_name) SUBPROC((void *)CheckDoubleRun);
   3242                      else ipc->data=(void *)maincsm_id;
   3243          	    break;
   3244          	  case IPC_SMILE_PROCESSED:
   3245          	    //Только собственные смайлы ;)
   3246          	    if (ipc->name_from==ipc_my_name) SUBPROC((void *)ProcessNextSmile);
   3247          	    SMART_REDRAW();
   3248          	    break;
   3249          	  case IPC_XSTATUSIMG_PROCESSED:
   3250          	    //Только собственные иксстатусы ;)
   3251          	    if (ipc->name_from==ipc_my_name) SUBPROC((void *)ProcessNextXStatImg);
   3252          	    SMART_REDRAW();
   3253          	    break;
   3254          	  case IPC_TENSECONDS:
   3255          	    //Только свое сообщение
   3256          	    if (ipc->name_from==ipc_my_name)
   3257          	    {
   3258          	      CLIST *t=(CLIST *)cltop;
   3259          	      int f=0;
   3260          	      while(t)
   3261          	      {
   3262                          if(t->just_now)
   3263                          {
   3264                            if (!(--(t->just_now))) {
   3265                              f=1;
   3266          #ifdef EVILFOX
   3267                              total_c_online--;
   3268          #endif
   3269                            }
   3270                          }
   3271          		if (t->isactive)
   3272          		{
   3273          		  if (!(--(t->isactive))) f=1; //Если дошли до 0 хотя бы один раз - надо перерисовать меню
   3274          		}
   3275          		t=(CLIST *)(t->next);
   3276          	      }
   3277          	      if (f)
   3278          	      {
   3279          		CLIST *oldt=NULL;
   3280          		if (contactlist_menu_id)
   3281          		{
   3282          		  oldt=FindContactByN(GetCurMenuItem(FindGUIbyId(contactlist_menu_id,NULL)));
   3283          		}
   3284          		RecountMenu(oldt, 1);
   3285          	      }
   3286          	      if (time_to_stop_t9)
   3287          	      {
   3288          		if (!(--time_to_stop_t9))
   3289          		{
   3290          		  if (IsGuiOnTop(edchat_id)) RefreshGUI();
   3291          		}
   3292          	      }
   3293          	    }
   3294          	    break;
   3295          #ifdef EVILFOX
   3296          #else
   3297               	  case IPC_SENDMSG: ;                                   //IPC_SENDMSG by BoBa 26.06.07
   3298                      int l=strlen(((IPCMsg *)(ipc->data))->msg);
   3299                      TPKT *msg=malloc(sizeof(PKT)+l);
   3300                      msg->pkt.uin=((IPCMsg *)(ipc->data))->uin;
   3301                      msg->pkt.type=T_SENDMSG;
   3302                      msg->pkt.data_len=l;
   3303                      memcpy(msg->data,((IPCMsg *)(ipc->data))->msg,l);
   3304                      //slientsend=1;
   3305          	    SENDMSGCOUNT++; //Номер сообщения
   3306                      SUBPROC((void *)SendAnswer,0,msg);
   3307                      break;
   3308          #endif
   3309          	  }
   3310          	}
   3311                }
   3312              }
   3313              //Нарисуем иконочку моего статуса
   3314          #define idlegui_id (((int *)icsm)[DISPLACE_OF_IDLEGUI_ID/4])
   3315              CSM_RAM *icsm=FindCSMbyID(CSM_root()->idle_id);
   3316              if (IsGuiOnTop(idlegui_id)/*&&IsUnlocked()*/) //Если IdleGui на самом верху
   3317              {
   3318                GUI *igui=GetTopGUI();
   3319                if (igui) //И он существует
   3320                {
   3321          ////	void *canvasdata=BuildCanvas();
   3322                  canvasdata=BuildCanvas();
                         ^
Error[Pe020]: identifier "canvasdata" is undefined
   3323          	int icn;
   3324          #ifdef EVILFOX
   3325                  if(time_draw)
   3326                  {
   3327          #endif
   3328          	if (total_unread)
   3329          	  icn=IS_MSG;
   3330          	else
   3331          	{
   3332          	  switch(connect_state)
   3333          	  {
   3334          	  case 0:
   3335          	    icn=IS_OFFLINE; break;
   3336          	  case 3:
   3337          	    icn=CurrentStatus; //IS_ONLINE;
   3338          	    break;
   3339          	  default:
   3340          	    icn=IS_UNKNOWN; break;
   3341          	  }
   3342          	}
   3343          
   3344          	//Тут трохи поменял
   3345          	// by Rainmaker: Рисуем канву только для иконки и выводим в своих координатах
   3346                  if((icon_change)||(total_unread)||(connect_state!=3))
                             ^
Error[Pe020]: identifier "icon_change" is undefined
   3347                  {
   3348          	DrawCanvas(canvasdata,IDLEICON_X,IDLEICON_Y,IDLEICON_X+GetImgWidth((int)S_ICONS[icn])-1,
   3349          		   IDLEICON_Y+GetImgHeight((int)S_ICONS[icn])-1,1);
   3350          	DrawImg(IDLEICON_X,IDLEICON_Y,S_ICONS[icn]);
   3351                  }
   3352                  else
   3353                  {
   3354                    PNGTOP_DESC *pltop=PNG_TOP();
   3355                    pltop->dyn_pltop=XStatusesImgList;
   3356                    DrawCanvas(canvasdata,IDLEICON_X,IDLEICON_Y,IDLEICON_X+GetImgWidth((int)XStatusesIconArray[CurrentXStatus])-1,
                                                                                                   ^
Error[Pe020]: identifier "XStatusesIconArray" is undefined
   3357          		   IDLEICON_Y+GetImgHeight((int)XStatusesIconArray[CurrentXStatus])-1,1);
   3358          	  DrawImg(IDLEICON_X,IDLEICON_Y,XStatusesIconArray[CurrentXStatus]);
   3359                  }
   3360          #ifdef EVILFOX_2
   3361                    DrawImg(IDLEICON_X-1,IDLEICON_Y-8,(int)"4:\\zbin\\naticq\\img\\naticq_ms.png");
   3362          #endif
   3363          #ifdef EVILFOX
   3364                    if(connect_state==3)
   3365                    sprintf(online_txt, "online: %02d:%02d:%02d", hours, minutes, seconds);
   3366                    else
   3367                      sprintf(online_txt ,"Offline");
   3368                    if(Is_Online_On)
   3369                    PrintField(ONTIME_X,ONTIME_Y, online_txt, align, fonto, spaco1r);
   3370                    if(Show_Ping)
   3371                      PrintField(PING_X,PING_Y, ping_txt, align, fonto, spaco1r);
   3372                    if(Is_Unread_On)
   3373                    {
   3374                      sprintf(unread_txt, "Unread: %d", total_unread2);
   3375                      PrintField(UNREAD_X,UNREAD_Y, unread_txt, align, fonto, spaco1r);
   3376                    }
   3377                    if(Is_DRAWMAIN_On&&main_d)
   3378                    {
   3379                      if(fonto==1)
   3380                      {
   3381                      PrintField(MSG_X,MSG_Y, a_txt, align, fonto, spaco2);
   3382                      PrintField(MSG_X,MSG_Y+paused_height+1, s_txt, align, fonto, spaco2);
   3383                      PrintField(MSG_X,MSG_Y+(2*paused_height)+2, d_txt, align, fonto, spaco2);
   3384                      PrintField(MSG_X,MSG_Y+(3*paused_height)+3, f_txt, align, fonto, spaco2);
   3385                      PrintField(MSG_X,MSG_Y+(4*paused_height)+4, g_txt, align, fonto, spaco2);
   3386                      }
   3387                      else
   3388                      {
   3389                        PrintField(MSG_X,MSG_Y, a_txt, align, fonto, spaco1r);
   3390                        PrintField(MSG_X,MSG_Y+GetFontYSIZE(paused_height)+1, s_txt, align, fonto, spaco1r);
   3391                        PrintField(MSG_X,MSG_Y+(2*GetFontYSIZE(paused_height))+2, d_txt, align, fonto, spaco1r);
   3392                        PrintField(MSG_X,MSG_Y+(3*GetFontYSIZE(paused_height))+3, f_txt, align, fonto, spaco1r);
   3393                        PrintField(MSG_X,MSG_Y+(4*GetFontYSIZE(paused_height))+4, g_txt, align, fonto, spaco1r);
   3394                      }
   3395                      main_d=0;
   3396                    }
   3397                    icon_change2=!(icon_change2);
   3398                    if(icon_change2)
   3399                    icon_change=!(icon_change);
   3400                    time_draw=0;
   3401                  }
   3402          #endif
   3403                }
   3404              }
   3405          #ifdef EVILFOX
   3406              else
   3407              {
   3408                time_draw=1;
   3409                main_d=1;
   3410              }
   3411          #endif
   3412            }
   3413            if (msg->msg==MSG_RECONFIGURE_REQ)
   3414            {
   3415              extern const char *successed_config_filename;
   3416              if (strcmp_nocase(successed_config_filename,(char *)msg->data0)==0)
   3417              {
   3418                ShowMSG(1,(int)"NatICQ config updated!");
   3419                InitConfig();
   3420          #ifdef EVILFOX
   3421                FontPathFree();
   3422                FontPathInit(fonto,(char *)fontpath, 0);
   3423                if(fonto==1)
   3424                {
   3425                  spaco1r=spaco1;
   3426                  char *heght=malloc(64);
   3427                  sprintf(heght, "%s2240.png", fontpath);
   3428                  paused_height=GetImgHeight((int)heght);
   3429                  mfree(heght);
   3430                }
   3431                else
   3432                {
   3433                  spaco1r=10001+(system_color*100);
   3434                  paused_height=fonto-100;
   3435                }
   3436                init_time_zone();
   3437          #endif
   3438                free_ICONS();
   3439                setup_ICONS();
   3440                ResortCL();
   3441                RecountMenu(NULL, 1);
   3442                //      InitSmiles();
   3443              }
   3444            }
   3445            if (msg->msg==MSG_GUI_DESTROYED)
   3446            {
   3447              if ((int)msg->data0==csm->gui_id)
   3448              {
   3449                csm->csm.state=-3;
   3450              }
   3451              if ((int)msg->data0==contactlist_menu_id)
   3452              {
   3453                contactlist_menu_id=0;
   3454                prev_clmenu_itemcount=0;
   3455              }
   3456              if ((int)msg->data0==edchat_id)
   3457              {
   3458                edchat_id=0;
   3459              }
   3460            }
   3461            if (msg->msg==MSG_HELPER_TRANSLATOR)
   3462            {
   3463              switch((int)msg->data0)
   3464              {
   3465              case LMAN_DISCONNECT_IND:
   3466                is_gprs_online=0;
   3467                return(1);
   3468              case LMAN_CONNECT_CNF:
   3469                vibra_count=1;
   3470                start_vibra();
   3471                is_gprs_online=1;
   3472                strcpy(logmsg,LG_GRGPRSUP);
   3473                GBS_StartTimerProc(&reconnect_tmr,TMR_SECOND*10,do_reconnect);
   3474                return(1);
   3475              case ENIP_DNR_HOST_BY_NAME:
   3476                if ((int)msg->data1==DNR_ID)
   3477                {
   3478          	if (DNR_TRIES) SUBPROC((void *)create_connect);
   3479                }
   3480                return(1);
   3481              }
   3482              if ((int)msg->data1==sock)
   3483              {
   3484                //Если наш сокет
   3485                if ((((unsigned int)msg->data0)>>28)==0xA)
   3486                {
   3487          	//Принят пакет
   3488          	ProcessPacket((TPKT *)msg->data0);
   3489          	return(0);
   3490                }
   3491                switch((int)msg->data0)
   3492                {
   3493                case ENIP_SOCK_CONNECTED:
   3494          	if (connect_state==1)
   3495          	{
   3496          	  if(VIBR_ON_CONNECT)
   3497                      vibra_count=2;
   3498                    else
   3499                      vibra_count=1;
   3500          	  start_vibra();
   3501          	  //Соединение установленно, посылаем пакет login
   3502          	  strcpy(logmsg, LG_GRTRYLOGIN);
   3503          	  {
   3504          	    int i=strlen(PASS);
   3505          	    TPKT *p=malloc(sizeof(PKT)+i);
   3506          	    p->pkt.uin=UIN;
   3507          	    p->pkt.type=T_REQLOGIN;
   3508          	    p->pkt.data_len=i;
   3509          	    memcpy(p->data,PASS,i);
   3510          	    SUBPROC((void *)send_login,0,p);
   3511          	  }
   3512          	  GROUP_CACHE=0;
   3513          	  SENDMSGCOUNT=0; //Начинаем отсчет
   3514          	  if (!FindGroupByID(0)) AddGroup(0,LG_GROUPNOTINLIST);
   3515          	  if (!FindContactByUin(UIN)) AddContact(UIN, LG_CLLOOPBACK);
   3516          	  SMART_REDRAW();
   3517          	}
   3518          	else
   3519          	{
   3520          	  ShowMSG(1,(int)LG_MSGILLEGMSGCON);
   3521          	}
   3522          	break;
   3523                case ENIP_SOCK_DATA_READ:
   3524          	if (connect_state>=2)
   3525          	{
   3526          	  //Если посылали send
   3527          	  SUBPROC((void *)get_answer);
   3528          	  //SMART_REDRAW();
   3529          	}
   3530          	else
   3531          	{
   3532          	  ShowMSG(1,(int)LG_MSGILLEGMSGREA);
   3533          	}
   3534          	break;
   3535                case ENIP_BUFFER_FREE:
   3536                case ENIP_BUFFER_FREE1:
   3537          	SUBPROC((void *)SendAnswer,0,0);
   3538          	break;
   3539                case ENIP_SOCK_REMOTE_CLOSED:
   3540          	//Закрыт со стороны сервера
   3541          	if (connect_state)
   3542          	  SUBPROC((void *)end_socket);
   3543          	break;
   3544                case ENIP_SOCK_CLOSED:
   3545          	//strcpy(logmsg, "No connection");
   3546          	//Dump not received
   3547          /*	if (RXstate>(-(int)sizeof(PKT)))
   3548          	{
   3549          	  unsigned int err;
   3550          	  int f=fopen("4:\\NATICQ.dump",A_ReadWrite+A_Create+A_Truncate+A_BIN,P_READ+P_WRITE,&err);
   3551          	  if (f!=-1)
   3552          	  {
   3553          	    fwrite(f,&RXbuf,RXstate+sizeof(PKT),&err);
   3554          	    fclose(f,&err);
   3555          	  }
   3556          	}*/
   3557          	FillAllOffline();
   3558          	RecountMenu(NULL, 1);
   3559          	connect_state=0;
   3560          	sock=-1;
   3561                  if(VIBR_ON_CONNECT)
   3562                    vibra_count=4;
   3563                  else
   3564                    vibra_count=1;
   3565          
   3566          	start_vibra();
   3567          	if (sendq_p)
   3568          	{
   3569          	  snprintf(logmsg,255,"Disconnected, %d bytes not sended!",sendq_l);
   3570          	}
   3571          	SMART_REDRAW();
   3572          	SUBPROC((void *)ClearSendQ);
   3573          	if (!disautorecconect)
   3574                  {
   3575                    GBS_StartTimerProc(&reconnect_tmr,TMR_SECOND*10,do_reconnect);
   3576                    snprintf(logmsg,255,"%s\nReconect after 10 second...",logmsg);
   3577                  }
   3578          	break;
   3579                }
   3580              }
   3581            }
   3582            return(1);
   3583          }
   3584          
   3585          
   3586          const int minus11=-11;
   3587          
   3588          unsigned short maincsm_name_body[140];
   3589          
   3590          const struct
   3591          {
   3592            CSM_DESC maincsm;
   3593            WSHDR maincsm_name;
   3594          }MAINCSM =
   3595          {
   3596            {
   3597              maincsm_onmessage,
   3598              maincsm_oncreate,
   3599          #ifdef NEWSGOLD
   3600          0,
   3601          0,
   3602          0,
   3603          0,
   3604          #endif
   3605          maincsm_onclose,
   3606          sizeof(MAIN_CSM),
   3607          1,
   3608          &minus11
   3609            },
   3610            {
   3611              maincsm_name_body,
   3612              NAMECSM_MAGIC1,
   3613              NAMECSM_MAGIC2,
   3614              0x0,
   3615              139
   3616            }
   3617          };
   3618          
   3619          void UpdateCSMname(void)
   3620          {
   3621            wsprintf((WSHDR *)(&MAINCSM.maincsm_name), "NATICQ: %d",UIN);
   3622          }
   3623          
   3624          
   3625          int main(char *filename)
   3626          {
   3627            MAIN_CSM main_csm;
   3628            char *s;
   3629            int len;
   3630            extern const char *successed_config_filename;
   3631            WSHDR *ws;
   3632          
   3633            InitConfig();
   3634            s=strrchr(filename,'\\');
   3635            len=(s-filename)+1;
   3636            strncpy(elf_path,filename,len);
   3637            elf_path[len]=0;
   3638            if (!UIN)
   3639            {
   3640              LockSched();
   3641              ShowMSG(1,(int)LG_MSGNOUINPASS);
   3642              ws=AllocWS(150);
   3643              str_2ws(ws,successed_config_filename,128);
   3644              ExecuteFile(ws,0,0);
   3645              UnlockSched();
   3646              SUBPROC((void *)ElfKiller);
   3647              return 0;
   3648            }
   3649            ReadDefSettings();
   3650            setup_ICONS();
   3651            LoadXStatusText();
   3652            UpdateCSMname();
   3653            LockSched();
   3654            maincsm_id=CreateCSM(&MAINCSM.maincsm,&main_csm,0);
   3655            UnlockSched();
   3656          #ifdef EVILFOX
   3657            time_counter();
   3658            FontPathInit(fonto,(char *)fontpath, 1);
   3659            if(fonto==1)
   3660              {
   3661                spaco1r=spaco1;
   3662                char *heght=malloc(64);
   3663                sprintf(heght, "%s2240.png", fontpath);
   3664                paused_height=GetImgHeight((int)heght);
   3665                mfree(heght);
   3666              }
   3667              else
   3668              {
   3669                spaco1r=10001+(system_color*100);
   3670                paused_height=fonto-100;
   3671              }
   3672            sprintf(ping_txt, "Ping: none");
   3673            init_time_zone();
   3674            AddKeybMsgHook((void *)my_keyhook); 
   3675          #endif
   3676            return 0;
   3677          }
   3678          
   3679          //===========================================================
   3680          // Edit chat
   3681          //===========================================================
   3682          void edchat_locret(void){}
   3683          
   3684          char *ExtractAnswer(WSHDR *ws)
   3685          {
   3686            S_SMILES *t;
   3687            int c;
   3688            int len=0;
   3689            int scur;
   3690            char *msg=NULL;
   3691            unsigned short *wsbody=ws->wsbody;
   3692            int wslen=wsbody[0];
   3693            if (wslen)
   3694            {
   3695              for (int i=0; i<wslen; i++) // Посчитаем общую длину будущей строки
   3696              {
   3697                c=wsbody[i+1];
   3698                if (c>=0xE100)
   3699                {
   3700                  t=FindSmileByUni(c);
   3701                  if (t)
   3702                  {
   3703                    if (t->lines)
   3704                    {
   3705                      len+=strlen(t->lines->text);
   3706                    }
   3707                  }
   3708                  else  len++;
   3709                }
   3710                else  len++;
   3711              }
   3712          
   3713              msg=malloc(len+1);
   3714              scur=0;
   3715              for (int wcur=0; wcur<wslen && scur<len; wcur++)
   3716              {
   3717                c=wsbody[wcur+1];
   3718                if (c==10) c=13;
   3719                if (c>=0xE100)
   3720                {
   3721                  t=FindSmileByUni(c);
   3722                  if (t)
   3723                  {
   3724                    int w;
   3725                    char *s;
   3726                    if (t->lines)
   3727                    {
   3728                      s=t->lines->text;
   3729                      while ((w=*s++) && scur<len)
   3730                      {
   3731                        msg[scur]=w;
   3732                        scur++;
   3733                      }
   3734                    }
   3735                  }
   3736                  else
   3737                  {
   3738                    msg[scur]=char16to8(c);
   3739                    scur++;
   3740                  }
   3741                }
   3742                else
   3743                {
   3744                  msg[scur]=char16to8(c);
   3745                  scur++;
   3746                }
   3747              }
   3748              msg[scur]=0;
   3749            }
   3750            return msg;
   3751          }
   3752          
   3753          CLIST *FindNextActiveContact(CLIST *t)
   3754          {
   3755            while(t=(CLIST *)(t->next))
   3756            {
   3757              if (t->isactive) return t;
   3758            }
   3759            t=(CLIST *)(&cltop);
   3760            while(t=(CLIST *)(t->next))
   3761            {
   3762              if (t->isactive) return t;
   3763            }
   3764            return NULL;
   3765          }
   3766          
   3767          CLIST *FindPrevActiveContact(CLIST *t)
   3768          {
   3769            CLIST *cl;
   3770            CLIST *cl_active=NULL;
   3771            cl=(CLIST *)(&cltop);
   3772          
   3773          
   3774            while(cl=cl->next)
   3775            {
   3776              if (cl==t)
   3777              {
   3778                if (cl_active==NULL) break;
   3779                else return (cl_active);
   3780              }
   3781              else
   3782              {
   3783                if (cl->isactive) cl_active=cl;
   3784              }
   3785            }
   3786            while(t)
   3787            {
   3788              if (t->isactive) cl_active=t;
   3789              t=t->next;
   3790            }
   3791            return cl_active;
   3792          }
   3793          
   3794          
   3795          void ed_options_handler(USR_MENU_ITEM *item)
   3796          {
   3797            EDCHAT_STRUCT *ed_struct=item->user_pointer;
   3798            CLIST *t;
   3799            int i=item->cur_item;
   3800            if (item->type==0)
   3801            {
   3802              switch(i)
   3803              {
   3804              case 0:
   3805                ascii2ws(item->ws,LG_MNUEDNEXTACT);
   3806                break;
   3807              case 1:
   3808                ascii2ws(item->ws,LG_MNUEDPREVACT);
   3809                break;
   3810              default:
   3811                i-=2;
   3812                if (i<ed_struct->loaded_templates) ascii2ws(item->ws,templates_lines[i]);
   3813                break;
   3814              }
   3815            }
   3816            if (item->type==1)
   3817            {
   3818              switch(i)
   3819              {
   3820              case 0:
   3821                t=FindNextActiveContact(ed_struct->ed_contact);
   3822                if (t && t!=ed_struct->ed_contact)
   3823                {
   3824                  GeneralFunc_flag1(edchat_id,1);
   3825                  CreateEditChat(t);
   3826                }
   3827                break;
   3828              case 1:
   3829                t=FindPrevActiveContact(ed_struct->ed_contact);
   3830                if (t && t!=ed_struct->ed_contact)
   3831                {
   3832                  GeneralFunc_flag1(edchat_id,1);
   3833                  CreateEditChat(t);
   3834                }
   3835                break;
   3836              default:
   3837                i-=2;
   3838                if (i<ed_struct->loaded_templates)
   3839                {
   3840          	EDITCONTROL ec;
   3841          	WSHDR *ed_ws;
   3842          	int c;
   3843          	char *p=templates_lines[i];
   3844          	ExtractEditControl(ed_struct->ed_chatgui,ed_struct->ed_answer,&ec);
   3845          	ed_ws=AllocWS(ec.pWS->wsbody[0]+strlen(p));
   3846          	wstrcpy(ed_ws,ec.pWS);
   3847                  if (EDIT_GetFocus(ed_struct->ed_chatgui)==ed_struct->ed_answer)
   3848                  {
   3849                    int pos=EDIT_GetCursorPos(ed_struct->ed_chatgui);
   3850                    while(c=*p++)
   3851                    {
   3852                      wsInsertChar(ed_ws,char8to16(c),pos++);
   3853                    }
   3854                    EDIT_SetTextToEditControl(ed_struct->ed_chatgui,ed_struct->ed_answer,ed_ws);
   3855                    EDIT_SetCursorPos(ed_struct->ed_chatgui,pos);
   3856                  }
   3857                  else
   3858                  {
   3859                    while(c=*p++)
   3860                    {
   3861                      wsAppendChar(ed_ws,char8to16(c));
   3862                    }
   3863                    EDIT_SetTextToEditControl(ed_struct->ed_chatgui,ed_struct->ed_answer,ed_ws);
   3864                  }
   3865          	FreeWS(ed_ws);
   3866                }
   3867                break;
   3868              }
   3869            }
   3870          }
   3871          
   3872          void ParseAnswer(WSHDR *ws, const char *s)
   3873          {
   3874            S_SMILES *t;
   3875            S_SMILES *t_root=(S_SMILES *)s_top;
   3876            STXT_SMILES *st;
   3877            unsigned int wchar;
   3878            unsigned int ulb=s[0]+(s[1]<<8)+(s[2]<<16)+(s[3]<<24);
   3879            CutWSTR(ws,0);
   3880            int i;
   3881            while(wchar=*s)
   3882            {
   3883              t=t_root;
   3884              while(t)
   3885              {
   3886                st=t->lines;
   3887                while(st)
   3888                {
   3889          	if ((ulb&st->mask)==st->key)
   3890          	{
   3891          	  if (!strncmp(s,st->text,strlen(st->text))) goto L1;
   3892          	}
   3893          	st=st->next;
   3894                }
   3895                t=t->next;
   3896              }
   3897            L1:
   3898              if (t)
   3899              {
   3900                wchar=t->uni_smile;
   3901                s+=strlen(st->text);
   3902                ulb=s[0]+(s[1]<<8)+(s[2]<<16)+(s[3]<<24);
   3903              }
   3904              else
   3905              {
   3906                wchar=char8to16(wchar);
   3907                s++;
   3908                ulb>>=8;
   3909                ulb+=s[3]<<24;
   3910              }
   3911              if (wchar!=10) wsAppendChar(ws,wchar);
   3912            }
   3913            i=ws->wsbody[0];
   3914            while(i>1)
   3915            {
   3916              if (ws->wsbody[i--]!=13) break;
   3917              ws->wsbody[0]=i;
   3918            }
   3919          }
   3920          
   3921          void SaveAnswer(CLIST *cl, WSHDR *ws)
   3922          {
   3923            char *p=ExtractAnswer(ws);
   3924            mfree(cl->answer);
   3925            cl->answer=p;
   3926          }
   3927          
   3928          int edchat_onkey(GUI *data, GUI_MSG *msg)
   3929          {
   3930            //-1 - do redraw
   3931            GBS_DelTimer(&tmr_illumination);
   3932            CLIST *t;
   3933            TPKT *p;
   3934            EDITCONTROL ec;
   3935            int len;
   3936            char *s;
   3937            int l=msg->gbsmsg->submess;
   3938            EDCHAT_STRUCT *ed_struct=EDIT_GetUserPointer(data);
   3939          
   3940            if (msg->keys==0xFFF)
   3941            {
   3942              void ec_menu(EDCHAT_STRUCT *);
   3943              ec_menu(ed_struct);
   3944              return(-1);
   3945            }
   3946            if (msg->keys==0xFF0)  return (1);
   3947            if (msg->gbsmsg->msg==LONG_PRESS)
   3948            {
   3949          #ifdef ELKA
   3950              if (l==VOL_DOWN_BUTTON)
   3951              {
   3952                WSHDR *ws;
   3953                ExtractEditControl(data,ed_struct->ed_answer,&ec);
   3954                if(wstrlen(ec.pWS)>0)
   3955                {
   3956                  ws=AllocWS(1);
   3957                  CutWSTR(ws,0);
   3958            
   3959                  EDIT_SetFocus(data,ed_struct->ed_answer);
   3960                  EDIT_SetTextToFocused(ed_struct->ed_chatgui,ws); 
   3961              
   3962                  FreeWS(ws);
   3963                  RefreshGUI();  
   3964                }
   3965              }
   3966              if (l==VOL_UP_BUTTON)
   3967              {
   3968          //      WSHDR *ws=AllocWS(strlen(ed_struct->ed_contact->last_msg_buffer)+1);
   3969          //      ascii2ws(ws,ed_struct->ed_contact->last_msg_buffer);
   3970                WSHDR *ws=AllocWS(strlen(last_msg_buffer)+1);
                                                ^
Error[Pe020]: identifier "last_msg_buffer" is undefined
   3971                ascii2ws(ws,last_msg_buffer);
   3972                EDIT_SetFocus(ed_struct->ed_chatgui,ed_struct->ed_answer);
   3973                EDIT_SetTextToFocused(ed_struct->ed_chatgui,ws);
   3974                FreeWS(ws);
   3975                RefreshGUI();
   3976              }
   3977          #else
   3978              if (l==RIGHT_BUTTON)
   3979              {
   3980                if (EDIT_GetFocus(data)==ed_struct->ed_answer)
   3981                {
   3982          	ExtractEditControl(data,ed_struct->ed_answer,&ec);
   3983          	if (ec.pWS->wsbody[0]==(EDIT_GetCursorPos(data)-1))
   3984          	{
   3985          	  t=FindNextActiveContact(ed_struct->ed_contact);
   3986          	  if (t && t!=ed_struct->ed_contact)
   3987          	  {
   3988          	    CreateEditChat(t);
   3989          	    return(1);
   3990          	  }
   3991          	}
   3992                }
   3993              }
   3994          #endif
   3995            }
   3996            if (msg->gbsmsg->msg==KEY_DOWN)
   3997            {
   3998              if ((l>='0')&&(l<='9'))
   3999              {
   4000                if (EDIT_GetFocus(data)!=ed_struct->ed_answer)
   4001          	EDIT_SetFocus(data,ed_struct->ed_answer);
   4002              }
   4003              if (l==GREEN_BUTTON)
   4004              {
   4005                if (connect_state==3)
   4006                {
   4007          	if ((t=ed_struct->ed_contact))
   4008          	{
   4009                    ExtractEditControl(data,ed_struct->ed_answer,&ec);
   4010                    SaveAnswer(t,ec.pWS);
   4011          	  if ((s=t->answer))
   4012          	  {
   4013          	    if ((len=strlen(s)))
   4014          	    {
   4015          	      t->isactive=ACTIVE_TIME;
   4016          	      p=malloc(sizeof(PKT)+len+1);
   4017          	      p->pkt.uin=t->uin;
   4018          	      p->pkt.type=T_SENDMSG;
   4019          	      p->pkt.data_len=len;
   4020          	      strcpy(p->data,s);
   4021          #ifdef ELKA
   4022                        strcpy(last_msg_buffer, s);
                                      ^
Error[Pe020]: identifier "last_msg_buffer" is undefined
   4023          #endif
   4024          	      AddStringToLog(t,0x01,p->data,I_str,(++SENDMSGCOUNT)&0x7FFF); //Номер сообщения
   4025                        out_count++;
                               ^
Error[Pe020]: identifier "out_count" is undefined
   4026          	      SUBPROC((void *)SendAnswer,0,p);
   4027          	      mfree(t->answer);
   4028          	      t->answer=NULL;
   4029          	      //        request_remake_edchat=1;
   4030          	      EDIT_SetFocus(data,ed_struct->ed_answer);
   4031          	      CutWSTR(ews,0);
   4032          	      EDIT_SetTextToFocused(data,ews);
   4033          	      AddMsgToChat(data);
   4034          	      RecountMenu(t, 1);
   4035          	      return(-1);
   4036          	    }
   4037          	  }
   4038          	}
   4039                }
   4040              }
   4041              if (l==ENTER_BUTTON)
   4042              {
   4043                //      t=FindNextActiveContact(ed_struct->ed_contact);
   4044                //      if ((t!=ed_struct->ed_contact) && t)
   4045                {
   4046          	int i=ed_struct->loaded_templates=LoadTemplates(ed_struct->ed_contact->uin);
                 	                                                ^
Error[Pe132]: expression must have pointer-to-struct-or-union type
   4047                  EDIT_OpenOptionMenuWithUserItems(data,ed_options_handler,ed_struct,i+2);
   4048                  return (-1);
   4049                }
   4050              }
   4051              if (l==VOL_UP_BUTTON)
   4052              {
   4053                int pos;
   4054          
   4055                if ((pos=EDIT_GetFocus(data)-2)>=2)
   4056                {
   4057                  EDIT_SetFocus(data, pos);
   4058                  EDIT_SetCursorPos(data, 1);
   4059                }
   4060                return (-1);
   4061              }
   4062              if (l==VOL_DOWN_BUTTON)
   4063              {
   4064                int pos;
   4065          
   4066                if ((pos=EDIT_GetFocus(data)+2)<=ed_struct->ed_answer)
   4067                {
   4068                  EDIT_SetFocus(data, pos);
   4069                  EDIT_SetCursorPos(data, 1);
   4070                }
   4071                return (-1);
   4072              }
   4073            }
   4074            return(0); //Do standart keys
   4075            //1: close
   4076          }
   4077          
   4078          static const HEADER_DESC edchat_hdr={0,0,NULL,NULL,NULL,0,LGP_NULL};
   4079          
   4080          void (*old_ed_redraw)(void *data);
   4081          void my_ed_redraw(void *data)
   4082          {
   4083            void *edchat_gui;
   4084            EDCHAT_STRUCT *ed_struct;
   4085            if (old_ed_redraw) old_ed_redraw(data);
   4086            edchat_gui=FindGUIbyId(edchat_id,NULL);
   4087            if (edchat_gui)
   4088            {
   4089              ed_struct=EDIT_GetUserPointer(edchat_gui);
   4090              if (ed_struct)
   4091              {
   4092                int icon, width;
   4093          #ifndef	NEWSGOLD
   4094                icon=*(S_ICONS+GetIconIndex(ed_struct->ed_contact));
   4095                ((HEADER_DESC *)&edchat_hdr)->rc.x2=ScreenW()-1-(width=GetImgWidth(icon));
   4096                DrawImg(ScreenW()-1-width,1,icon);
   4097          #else
   4098                icon=*(S_ICONS+GetIconIndex(ed_struct->ed_contact));
   4099                width=GetImgWidth(icon);
   4100                DrawImg(2,((HeaderH()-width)>>1)+YDISP,icon);
   4101          /*      DrawRoundedFrame(ScreenW()-8,YDISP,ScreenW()-1,YDISP+7,0,0,0,
   4102          		       GetPaletteAdrByColorIndex(0),
   4103          		       GetPaletteAdrByColorIndex(EDIT_IsBusy(edchat_gui)?3:4));*/
   4104          #endif
   4105              }
   4106            }
   4107          }
   4108          
   4109          void edchat_ghook(GUI *data, int cmd)
   4110          {
   4111            static const SOFTKEY_DESC sk={0x0FFF,0x0000,(int)LG_MENU};
   4112            static const SOFTKEY_DESC sk_cancel={0x0FF0,0x0000,(int)LG_CLOSE};
   4113            //  static SOFTKEY_DESC sk={0x0018,0x0000,(int)"Menu"};
   4114            int j;
   4115            EDITCONTROL ec;
   4116            EDCHAT_STRUCT *ed_struct=EDIT_GetUserPointer(data);
   4117            PNGTOP_DESC *pltop=PNG_TOP();
   4118            if (cmd==9)
   4119            {
   4120              GBS_DelTimer(&tmr_illumination);          //by BoBa 25.06.07
   4121              pltop->dyn_pltop=NULL;
   4122            }
   4123            if (cmd==2)
   4124            {
   4125              ed_struct->ed_chatgui=data;
   4126          //    edgui_data=data;
   4127              EDIT_SetFocus(data,ed_struct->ed_answer);
   4128          
   4129              static void *methods[16];
   4130              void **m=GetDataOfItemByID(data,2);
   4131              if (m)
   4132              {
   4133                if (m[1])
   4134                {
   4135                  memcpy(methods,m[1],sizeof(methods));
   4136                  old_ed_redraw=(void (*)(void *))(methods[0]);
   4137                  methods[0]=(void *)my_ed_redraw;
   4138                  m[1]=methods;
   4139                }
   4140              }
   4141            }
   4142            if (cmd==3)
   4143            {
   4144          //    if (edgui_data==data) edgui_data=NULL;
   4145              if (ed_struct->ed_contact)
   4146              {
   4147                ExtractEditControl(data,ed_struct->ed_answer,&ec);
   4148                SaveAnswer(ed_struct->ed_contact,ec.pWS);
   4149              }
   4150              RecountMenu(ed_struct->ed_contact, 1);
   4151              mfree(ed_struct);
   4152            }
   4153            if (cmd==0x0A)
   4154            {
   4155              pltop->dyn_pltop=SmilesImgList;
   4156              DisableIDLETMR();
   4157              total_unread-=ed_struct->requested_decrement_total_unread;
   4158              ed_struct->requested_decrement_total_unread=0;
   4159          /*    if (request_close_edchat)
   4160              {
   4161                request_close_edchat=0;
   4162                GeneralFunc_flag1(edchat_id,1);
   4163                return;
   4164              }*/
   4165            }
   4166            if (cmd==7)
   4167            {
   4168              SetSoftKey(data,&sk,SET_SOFT_KEY_N);
   4169              ExtractEditControl(data,ed_struct->ed_answer,&ec);
   4170              if (ec.pWS->wsbody[0]==0)
   4171                SetSoftKey(data,&sk_cancel,SET_SOFT_KEY_N==0?1:0);
   4172              if (!EDIT_IsBusy(data))
   4173              {
   4174                time_to_stop_t9=0;
   4175                if (ed_struct->ed_contact->req_add)
                           ^
Error[Pe132]: expression must have pointer-to-struct-or-union type
   4176                {
   4177          	ed_struct->ed_contact->req_add=0;
                 	^
Error[Pe132]: expression must have pointer-to-struct-or-union type
   4178          	AddMsgToChat(data);
   4179          	RecountMenu(ed_struct->ed_contact, 1);
   4180                }
   4181                if (ed_struct->ed_contact->req_drawack)
                           ^
Error[Pe132]: expression must have pointer-to-struct-or-union type
   4182                {
   4183          	ed_struct->ed_contact->req_drawack=0;
                 	^
Error[Pe132]: expression must have pointer-to-struct-or-union type
   4184          	DrawAck(data);
   4185                }
   4186              }
   4187            }
   4188            if (cmd==0x0C)
   4189            {
   4190              j=EDIT_GetFocus(data);
   4191              if ((EDIT_GetUnFocus(data)<j)&&(j!=ed_struct->ed_answer))
   4192                EDIT_SetCursorPos(data,1);
   4193            }
   4194          }
   4195          
   4196          
   4197          
   4198          static const INPUTDIA_DESC edchat_desc =
   4199          {
   4200            1,
   4201            edchat_onkey,
   4202            edchat_ghook,
   4203            (void *)edchat_locret,
   4204            0,
   4205            &menu_skt,
   4206            {0,NULL,NULL,NULL},
   4207            FONT_SMALL,
   4208            100,
   4209            101,
   4210            0,
   4211            //  0x00000001 - Выровнять по правому краю
   4212            //  0x00000002 - Выровнять по центру
   4213            //  0x00000004 - Инверсия знакомест
   4214            //  0x00000008 - UnderLine
   4215            //  0x00000020 - Не переносить слова
   4216            //  0x00000200 - bold
   4217            0,
   4218            //  0x00000002 - ReadOnly
   4219            //  0x00000004 - Не двигается курсор
   4220            //  0x40000000 - Поменять местами софт-кнопки
   4221            0x40000000
   4222          };
   4223          
   4224          void CreateEditChat(CLIST *t)
   4225          {
   4226            extern const int FIRST_LETTER;
   4227            void *ma=malloc_adr();
   4228            void *eq;
   4229            EDITCONTROL ec;
   4230            EDITC_OPTIONS ec_options;
   4231            int color, font, type;
   4232            int zc;
   4233          
   4234            LOGQ *lp;
   4235            int edchat_toitem;
   4236          //  edcontact=t;
   4237          
   4238            *((int *)(&edchat_hdr.lgp_id))=(int)t->name;
   4239          //  *((int **)(&edchat_hdr.icon))=(int *)S_ICONS+GetIconIndex(t);
   4240            *((int **)(&edchat_hdr.icon))=(int *)S_ICONS+IS_NULLICON;
   4241          
   4242            eq=AllocEQueue(ma,mfree_adr());
   4243          
   4244          
   4245            lp=t->log;
   4246          
   4247            while(lp)
   4248            {
   4249              font = ED_H_FONT_SIZE;
   4250              if ((zc=lp->acked&3))
   4251              {
   4252                if (zc==1)
   4253          	color=ACK_COLOR; //Зеленый
   4254                else
   4255          	color=I_COLOR;
   4256              }
   4257              else
   4258              {
   4259                if (lp->ID==0xFFFFFFFF)
   4260                {
   4261                  type = lp->type&0x0F;
   4262                  if(lp->type&0x10)
   4263                  {
   4264                    color = (type==1)?O_I_COLOR:((type==3)?O_X_COLOR:O_TO_COLOR);
   4265                    font = (type==3)?O_ED_X_FONT_SIZE:O_ED_H_FONT_SIZE;
   4266                  }
   4267                  else
   4268                  {
   4269                    color = (type==1)?I_COLOR:((type==3)?X_COLOR:TO_COLOR);
   4270                    font = (type==3)?ED_X_FONT_SIZE:ED_H_FONT_SIZE;
   4271                  }
   4272                }
   4273                else
   4274          	color=UNACK_COLOR; //Серый
   4275              }
   4276              PrepareEditControl(&ec);
   4277              if ((lp->type&0x0F)!=3)
   4278              {
   4279                ascii2ws(ews,lp->hdr);
   4280                ConstructEditControl(&ec,ECT_HEADER,ECF_APPEND_EOL,ews,ews->wsbody[0]);
   4281              }
   4282              else
   4283                ConstructEditControl(&ec,ECT_HEADER,ECF_DELSTR,ews,0);
   4284              PrepareEditCOptions(&ec_options);
   4285              SetPenColorToEditCOptions(&ec_options,color);
   4286              SetFontToEditCOptions(&ec_options,font);
   4287              CopyOptionsToEditControl(&ec,&ec_options);
   4288              AddEditControlToEditQend(eq,&ec,ma);
   4289              if ((lp->type&0x0F)!=3)
   4290              {
   4291                ParseAnswer(ews,lp->text);
   4292              }
   4293              else
   4294              {
   4295                ParseXStatusText(ews,lp->text,(lp->type&0x10)?O_X_COLOR:X_COLOR);
   4296              }
   4297              PrepareEditControl(&ec);
   4298              ConstructEditControl(&ec,
   4299                                   ECT_NORMAL_TEXT,
   4300                                   ews->wsbody[0] ? ECF_APPEND_EOL|ECF_DISABLE_T9 : ECF_DELSTR,
   4301                                   ews,ews->wsbody[0]);
   4302              PrepareEditCOptions(&ec_options);
   4303          //#ifdef M75
   4304              if ((lp->type&0x0F)!=3)
   4305              {
   4306                SetFontToEditCOptions(&ec_options,(lp->type&0x10)?O_ED_FONT_SIZE:ED_FONT_SIZE);
   4307              }
   4308              else
   4309              {
   4310                SetPenColorToEditCOptions(&ec_options,(lp->type&0x10)?O_X_COLOR:X_COLOR);
   4311                SetFontToEditCOptions(&ec_options,(lp->type&0x10)?O_ED_X_FONT_SIZE:ED_X_FONT_SIZE);
   4312              }
   4313          //#else
   4314          //    SetFontToEditCOptions(&ec_options,(lp->type&0x10)?O_ED_FONT_SIZE:ED_FONT_SIZE);
   4315          //#endif
   4316              CopyOptionsToEditControl(&ec,&ec_options);
   4317              AddEditControlToEditQend(eq,&ec,ma);
   4318              lp=lp->next;
   4319            }
   4320            if (t->isunread) total_unread--;
   4321            t->isunread=0;
   4322          #ifdef EVILFOX
   4323            total_unread2=total_unread2-t->unread_msg;
   4324            t->unread_msg=0;
   4325          #endif
   4326            ChangeContactPos(t);
   4327            wsprintf(ews, "-------");
   4328            PrepareEditControl(&ec);
   4329            ConstructEditControl(&ec,ECT_HEADER,ECF_APPEND_EOL,ews,ews->wsbody[0]);
   4330            PrepareEditCOptions(&ec_options);
   4331            SetFontToEditCOptions(&ec_options,ED_FONT_SIZE);
   4332            CopyOptionsToEditControl(&ec,&ec_options);
   4333            AddEditControlToEditQend(eq,&ec,ma);
   4334          
   4335            if (t->answer) ParseAnswer(ews,t->answer);
   4336            else  CutWSTR(ews,0);
   4337            PrepareEditControl(&ec);
   4338            ConstructEditControl(&ec,3,(FIRST_LETTER)?ECF_DEFAULT_BIG_LETTER:0,ews,1024);
   4339          
   4340            PrepareEditCOptions(&ec_options);
   4341            SetFontToEditCOptions(&ec_options,ED_FONT_SIZE);
   4342            CopyOptionsToEditControl(&ec,&ec_options);
   4343            edchat_toitem=AddEditControlToEditQend(eq,&ec,ma);
   4344          
   4345            if (t->req_xtext)
   4346            {
   4347              FreeXText(t);
   4348              t->req_xtext=0;
   4349              RequestXText(t->uin);
   4350            }
   4351          
   4352            EDCHAT_STRUCT *ed_struct=malloc(sizeof(EDCHAT_STRUCT));
   4353            ed_struct->ed_contact=t;
   4354            ed_struct->ed_answer=edchat_toitem;
   4355            ed_struct->requested_decrement_total_unread=0;
   4356            t->req_add=0;
   4357            t->last_log=NULL;
   4358          
   4359            //  int scr_w=ScreenW();
   4360            //  int scr_h=ScreenH();
   4361            //  int head_h=HeaderH();
   4362          
   4363            patch_header(&edchat_hdr);
   4364            patch_input(&edchat_desc);
   4365            //  edchat_desc.font=ED_FONT_SIZE;
   4366            edchat_id=CreateInputTextDialog(&edchat_desc,&edchat_hdr,eq,1,ed_struct);
   4367          }
   4368          
   4369          //-----------------------------------------------------------------------------
   4370          #define EC_MNU_MAX 8
   4371          
   4372          void Quote(GUI *data)
   4373          {
   4374            int q_n;
   4375            EDITCONTROL ec, ec_hdr;
   4376            EDITCONTROL ec_ed;
   4377            WSHDR *ed_ws;
   4378            WSHDR *ws;
   4379          
   4380            EDCHAT_STRUCT *ed_struct;
   4381            ed_struct=MenuGetUserPointer(data);
   4382          
   4383            q_n=EDIT_GetFocus(ed_struct->ed_chatgui);
   4384            ExtractEditControl(ed_struct->ed_chatgui,q_n,&ec);
   4385            ExtractEditControl(ed_struct->ed_chatgui,q_n-1,&ec_hdr);
   4386            ExtractEditControl(ed_struct->ed_chatgui,ed_struct->ed_answer,&ec_ed);
   4387          
   4388            ed_ws=AllocWS((ec_ed.maxlen<<1) + 1);
   4389            if(wstrlen(ec_hdr.pWS))
   4390            {
   4391              wstrcpy(ed_ws,ec_hdr.pWS);
   4392              wsAppendChar(ed_ws,'\r');
   4393            }
   4394            else
   4395              CutWSTR(ed_ws,0);
   4396            if (EDIT_IsMarkModeActive(ed_struct->ed_chatgui))
   4397            {
   4398              EDIT_GetMarkedText(ed_struct->ed_chatgui,ed_ws);
   4399            }
   4400            else
   4401            {
   4402              wstrcat(ed_ws,ec.pWS);
   4403            }
   4404            int ed_pos=0;
   4405            do
   4406            {
   4407              ed_pos++;
   4408              wsInsertChar(ed_ws,'>',ed_pos++);
   4409              wsInsertChar(ed_ws,' ',ed_pos);
   4410            }
   4411            while((ed_pos=wstrchr(ed_ws,ed_pos,'\r'))!=0xFFFF);
   4412            wsAppendChar(ed_ws,'\r');
   4413            wsAppendChar(ed_ws,'\r');
   4414            ws=AllocWS(ec_ed.pWS->wsbody[0]+ed_ws->wsbody[0]);
   4415            wstrcpy(ws,ec_ed.pWS);
   4416            wstrcat(ws,ed_ws);
   4417            FreeWS(ed_ws);
   4418            CutWSTR(ws,ec_ed.maxlen);
   4419            EDIT_SetFocus(ed_struct->ed_chatgui,ed_struct->ed_answer);
   4420            EDIT_SetTextToFocused(ed_struct->ed_chatgui,ws);
   4421            FreeWS(ws);
   4422            GeneralFuncF1(1);
   4423          }
   4424          
   4425          
   4426          void GetShortInfo(GUI *data)
   4427          {
   4428            EDCHAT_STRUCT *ed_struct;
   4429            ed_struct=MenuGetUserPointer(data);
   4430          
   4431            TPKT *p;
   4432            CLIST *t;
   4433            if ((t=ed_struct->ed_contact)&&(connect_state==3))
   4434            {
   4435              p=malloc(sizeof(PKT));
   4436              p->pkt.uin=t->uin;
   4437              p->pkt.type=T_REQINFOSHORT;
   4438              p->pkt.data_len=0;
   4439              AddStringToLog(t, 0x01, "Request info...", I_str,0xFFFFFFFF);
   4440              AddMsgToChat(ed_struct->ed_chatgui);
   4441              RecountMenu(t, 1);
   4442              SUBPROC((void *)SendAnswer,0,p);
   4443            }
   4444            GeneralFuncF1(1);
   4445          }
   4446          
   4447          void AskNickAndAddContact(EDCHAT_STRUCT *);
   4448          void AddCurContact(GUI *data)
   4449          {
   4450            EDCHAT_STRUCT *ed_struct;
   4451            ed_struct=MenuGetUserPointer(data);
   4452          
   4453            if ((ed_struct->ed_contact)&&(connect_state==3)) AskNickAndAddContact(ed_struct);
   4454            GeneralFuncF1(1);
   4455          }
   4456          
   4457          void SendAuthReq(GUI *data)
   4458          {
   4459            EDCHAT_STRUCT *ed_struct;
   4460            ed_struct=MenuGetUserPointer(data);
   4461          
   4462            TPKT *p;
   4463            CLIST *t;
   4464            int l;
   4465            const char s[]=LG_AUTHREQ;
   4466            if ((t=ed_struct->ed_contact)&&(connect_state==3))
   4467            {
   4468              p=malloc(sizeof(PKT)+(l=strlen(s))+1);
   4469              p->pkt.uin=t->uin;
   4470              p->pkt.type=T_AUTHREQ;
   4471              p->pkt.data_len=l;
   4472              strcpy(p->data,s);
   4473              AddStringToLog(t,0x01,p->data,I_str,0xFFFFFFFF);
   4474              AddMsgToChat(ed_struct->ed_chatgui);
   4475              RecountMenu(t, 1);
   4476              SUBPROC((void *)SendAnswer,0,p);
   4477            }
   4478            GeneralFuncF1(1);
   4479          }
   4480          
   4481          void SendAuthGrant(GUI *data)
   4482          {
   4483            EDCHAT_STRUCT *ed_struct;
   4484            ed_struct=MenuGetUserPointer(data);
   4485          
   4486            TPKT *p;
   4487            CLIST *t;
   4488            int l;
   4489            const char s[]=LG_AUTHGRANT;
   4490            if ((t=ed_struct->ed_contact)&&(connect_state==3))
   4491            {
   4492              p=malloc(sizeof(PKT)+(l=strlen(s))+1);
   4493              p->pkt.uin=t->uin;
   4494              p->pkt.type=T_AUTHGRANT;
   4495              p->pkt.data_len=l;
   4496              strcpy(p->data,s);
   4497              AddStringToLog(t,0x01,p->data,I_str,0xFFFFFFFF);
   4498              AddMsgToChat(ed_struct->ed_chatgui);
   4499              RecountMenu(t, 1);
   4500              SUBPROC((void *)SendAnswer,0,p);
   4501            }
   4502            GeneralFuncF1(1);
   4503          }
   4504          
   4505          void OpenLogfile(GUI *data)
   4506          {
   4507            EDCHAT_STRUCT *ed_struct;
   4508            ed_struct=MenuGetUserPointer(data);
   4509          
   4510            extern const char HIST_PATH[64];
   4511          #ifdef EVILFOX_2
   4512          #else
   4513            extern const int HISTORY_TYPE;
   4514          #endif
   4515            CLIST *t;
   4516            WSHDR *ws=AllocWS(256);
   4517            if ((t=ed_struct->ed_contact))
   4518            {
   4519          #ifdef EVILFOX_2
   4520              wsprintf(ws,"%s\\%u\\%s.txt",HIST_PATH,UIN,t->name);  
   4521          #else
   4522              if (HISTORY_TYPE)
   4523                wsprintf(ws,"%s\\%u\\%u.txt",HIST_PATH,UIN, t->uin);
   4524              else
   4525                wsprintf(ws,"%s\\%u.txt",HIST_PATH, t->uin);
   4526          #endif
   4527              ExecuteFile(ws,NULL,NULL);
   4528            }
   4529            FreeWS(ws);
   4530            GeneralFuncF1(1);
   4531          }
   4532          
   4533          void ClearLog(GUI *data/*,void *dummy*/)
   4534          {
   4535            EDITCONTROL ec;
   4536            EDCHAT_STRUCT *ed_struct;
   4537            WSHDR *ws;
   4538            CLIST *t;
   4539          
   4540            ed_struct=MenuGetUserPointer(data);
   4541          
   4542            ExtractEditControl(ed_struct->ed_chatgui,ed_struct->ed_answer,&ec);
   4543            if(wstrlen(ec.pWS)>0)
   4544            {
   4545              ws=AllocWS(1);
   4546              CutWSTR(ws,0);
   4547          
   4548              EDIT_SetFocus(ed_struct->ed_chatgui,ed_struct->ed_answer);
   4549              EDIT_SetTextToFocused(ed_struct->ed_chatgui,ws);
   4550          
   4551              FreeWS(ws);
   4552              GeneralFuncF1(1);
   4553            }
   4554            else
   4555            {
   4556          
   4557              if ((t=ed_struct->ed_contact))
   4558              {
   4559                if (t->log)
   4560                {
   4561                  FreeLOGQ(&t->log);
   4562                  t->msg_count=0;
   4563                  if (ed_struct->ed_answer>=2&&ed_struct->ed_chatgui)
   4564                  {
   4565                    while(ed_struct->ed_answer!=2)
   4566                    {
   4567                      EDIT_RemoveEditControl(ed_struct->ed_chatgui,1);
   4568                      ed_struct->ed_answer--;
   4569                    }
   4570                  }
   4571                }
   4572                t->isactive=0;		//by BoBa  18.06.07
   4573                RecountMenu(t, 1);
   4574                GeneralFuncF1(1);
   4575              }
   4576            }
   4577          }
   4578          
   4579          void ecmenu_ghook(void *data, int cmd)
   4580          {
   4581            if (cmd==0x0A)
   4582            {
   4583              DisableIDLETMR();
   4584            }
   4585          }
   4586          
   4587          static const MENUITEM_DESC ecmenu_ITEMS[EC_MNU_MAX]=
   4588          {
   4589            {NULL,(int)LG_MNUQUOTE,    LGP_NULL,0,NULL,MENU_FLAG3,MENU_FLAG2},
   4590            {NULL,(int)LG_MNUADDSML,   LGP_NULL,0,NULL,MENU_FLAG3,MENU_FLAG2},
   4591            {NULL,(int)LG_MNUSHINFO,   LGP_NULL,0,NULL,MENU_FLAG3,MENU_FLAG2},
   4592            {NULL,(int)LG_MNUADDREN,   LGP_NULL,0,NULL,MENU_FLAG3,MENU_FLAG2},
   4593            {NULL,(int)LG_MNUSAUTHREQ, LGP_NULL,0,NULL,MENU_FLAG3,MENU_FLAG2},
   4594            {NULL,(int)LG_MNUSAUTHGRT, LGP_NULL,0,NULL,MENU_FLAG3,MENU_FLAG2},
   4595            {NULL,(int)LG_MNUOPENLOG,  LGP_NULL,0,NULL,MENU_FLAG3,MENU_FLAG2},
   4596            {NULL,(int)LG_MNUCLEARCHT, LGP_NULL,0,NULL,MENU_FLAG3,MENU_FLAG2}
   4597          };
   4598          
   4599          extern void AddSmile(GUI *data);
   4600          static const MENUPROCS_DESC ecmenu_HNDLS[EC_MNU_MAX]=
   4601          {
   4602            Quote,
   4603            AddSmile,
   4604            GetShortInfo,
   4605            AddCurContact,
   4606            SendAuthReq,
   4607            SendAuthGrant,
   4608            OpenLogfile,
   4609            ClearLog,
   4610          };
   4611          
   4612          char ecm_contactname[64];
   4613          
   4614          static const HEADER_DESC ecmenu_HDR={0,0,NULL,NULL,NULL,(int)ecm_contactname,LGP_NULL};
   4615          
   4616          static const MENU_DESC ecmenu_STRUCT=
   4617          {
   4618            8,NULL,ecmenu_ghook,NULL,
   4619            menusoftkeys,
   4620            &menu_skt,
   4621            0,
   4622            NULL,
   4623            ecmenu_ITEMS,
   4624            ecmenu_HNDLS,
   4625            EC_MNU_MAX
   4626          };
   4627          
   4628          void ec_menu(EDCHAT_STRUCT *ed_struct)
   4629          {
   4630            CLIST *t;
   4631            int to_remove[EC_MNU_MAX+1];
   4632            int remove=0;
   4633            if ((t=ed_struct->ed_contact))
   4634            {
   4635              if (t->name)
   4636              {
   4637                strncpy(ecm_contactname,t->name,63);
   4638              }
   4639              else
   4640              {
   4641                sprintf(ecm_contactname,"%u",t->uin);
   4642              }
   4643              if (EDIT_GetFocus(ed_struct->ed_chatgui)==ed_struct->ed_answer)
   4644              {
   4645                to_remove[++remove]=0;
   4646              }
   4647              else
   4648              {
   4649                to_remove[++remove]=1;
   4650              }
   4651          
   4652              if (ed_struct->ed_answer<=2) to_remove[++remove]=7;
   4653              if (!ed_struct->ed_contact || connect_state!=3)
   4654              {
   4655                to_remove[++remove]=2;
   4656                to_remove[++remove]=3;
   4657                to_remove[++remove]=4;
   4658                to_remove[++remove]=5;
   4659              }
   4660          
   4661              patch_header(&ecmenu_HDR);
   4662              to_remove[0]=remove;
   4663              CreateMenu(0,0,&ecmenu_STRUCT,&ecmenu_HDR,0,EC_MNU_MAX,ed_struct,to_remove);
   4664            }
   4665          }
   4666          
   4667          
   4668          void AskNickAndAddContact(EDCHAT_STRUCT *ed_struct)
   4669          {
   4670            CreateAddContactGrpDialog(ed_struct->ed_contact);
   4671          }
   4672          
   4673          void AddSmile(GUI *data)
   4674          {
   4675            EDCHAT_STRUCT *ed_struct=MenuGetUserPointer(data);
   4676            CreateSmileSelectGUI(ed_struct);
   4677            GeneralFuncF1(1);
   4678          }

Errors: 48
Warnings: 1
