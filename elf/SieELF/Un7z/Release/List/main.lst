##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    14/Jan/2009  11:42:37 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  K:\Pasha\elf\SieELF\Un7z\main.c                      #
#    Command line    =  K:\Pasha\elf\SieELF\Un7z\main.c -lC                  #
#                       K:\Pasha\elf\SieELF\Un7z\Release\List\ -o            #
#                       K:\Pasha\elf\SieELF\Un7z\Release\Obj\ -s9            #
#                       --no_unroll --cpu_mode arm --endian little --cpu     #
#                       ARM926EJ-S --stack_align 4 --interwork -e --fpu      #
#                       None --dlib_config "K:\Pasha\Embedded Workbench 4.0  #
#                       Evaluation2\ARM\LIB\dl5tpainl8n.h" -I                #
#                       "K:\Pasha\Embedded Workbench 4.0                     #
#                       Evaluation2\ARM\INC\" --inline_threshold=2           #
#    List file       =  K:\Pasha\elf\SieELF\Un7z\Release\List\main.lst       #
#    Object file     =  K:\Pasha\elf\SieELF\Un7z\Release\Obj\main.r79        #
#                                                                            #
#                                                                            #
##############################################################################

K:\Pasha\elf\SieELF\Un7z\main.c
      1          
      2          #include "..\inc\swilib.h"
      3          //#include "zlib.h"
      4          
      5          // LZMA decoder
      6          
      7          // Не ме?ть!!!
      8          #undef _LZMA_IN_CB 
      9          #undef _LZMA_OUT_READ 
     10          
     11          #include "LzmaDecode.h"

  typedef unsigned char Byte;
                        ^
"K:\Pasha\elf\SieELF\Un7z\LzmaTypes.h",15  Warning[Pe301]: typedef name has
          already been declared (with same type)
     12          
     13          //#include <stdio.h>
     14          //#include <stdlib.h>
     15          //#include <string.h>
     16          
     17          #define byte unsigned char
     18          #define true 1
     19          #define false 0
     20          

   \                                 In segment DATA_C, align 4, align-sorted
     21          const int waitEOS = 1; 
   \                     waitEOS:
   \   00000000   01000000           DC32 1
     22          // waitEOS = 1, if there is no uncompressed size in headers, 
     23          // so decoder will wait EOS (End of Stream Marker) in compressed stream 

   \                                 In segment DATA_C, align 4, align-sorted
     24          const int maxdirsize=32768;
   \                     maxdirsize:
   \   00000000   00800000           DC32 32768

   \                                 In segment DATA_C, align 4, align-sorted
     25          const unsigned int hsize=0x20;//, bufSize=64*(1<<10);
   \                     hsize:
   \   00000000   20000000           DC32 32
     26          

   \                                 In segment DATA_I, align 4, align-sorted
     27          unsigned char properties[]={0x5d,0,0,0x80,0};
     28          CLzmaDecoderState state;  // it's about 24-80 bytes structure, if int is 32-bit 
   \                     state:
   \   00000000                      DS8 16
   \   00000010                      REQUIRE `?<Initializer for state>`
     29          unsigned int getpos=0;
   \                     getpos:
   \   00000010                      DS8 4
   \   00000014                      REQUIRE `?<Initializer for getpos>`
   \                     properties:
   \   00000014                      DS8 8
   \   0000001C                      REQUIRE `?<Initializer for properties>`
     30          SizeT outProcessed=0; //Скольк?распаковалос?//char newname[128];
   \                     outProcessed:
   \   0000001C                      DS8 4
   \   00000020                      REQUIRE `?<Initializer for outProcessed>`
     31          char filename[256];
   \                     filename:
   \   00000020                      DS8 256
   \   00000120                      REQUIRE `?<Initializer for filename>`
     32          unsigned int err;  
   \                     err:
   \   00000120                      DS8 4
   \   00000124                      REQUIRE `?<Initializer for err>`
     33          

   \                                 In segment CODE, align 4, keep-with-next
     34          int fread32(int fh, char *buf, int len, unsigned int *err)
     35          {
   \                     fread32:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   0370A0E1           MOV      R7,R3
     36          int clen;
     37          int rlen; 
     38          int total=0;
   \   00000014   0080A0E3           MOV      R8,#+0
   \   00000018   010000EA           B        ??fread32_0
     39          while(len)
     40          {
     41          if (len>16384) clen=16384; else clen=len;
     42          total+=(rlen=fread(fh, buf, clen, err));
     43          if (rlen!=clen) break;
     44          buf+=rlen;
   \                     ??fread32_1:
   \   0000001C   055080E0           ADD      R5,R0,R5
     45          len-=clen;
   \   00000020   096046E0           SUB      R6,R6,R9
   \                     ??fread32_0:
   \   00000024   000056E3           CMP      R6,#+0
   \   00000028   0C00000A           BEQ      ??fread32_2
   \   0000002C   0100A0E3           MOV      R0,#+1
   \   00000030   400C80E3           ORR      R0,R0,#0x4000
   \   00000034   000056E1           CMP      R6,R0
   \   00000038   409CA0A3           MOVGE    R9,#+16384
   \   0000003C   0690A0B1           MOVLT    R9,R6
   \   00000040   0730A0E1           MOV      R3,R7
   \   00000044   0920A0E1           MOV      R2,R9
   \   00000048   0510A0E1           MOV      R1,R5
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   0B0000EF           SWI      +11
   \   00000054   088080E0           ADD      R8,R0,R8
   \   00000058   090050E1           CMP      R0,R9
   \   0000005C   EEFFFF0A           BEQ      ??fread32_1
     46          }
     47          return(total);
   \                     ??fread32_2:
   \   00000060   0800A0E1           MOV      R0,R8
   \   00000064   F083BDE8           POP      {R4-R9,PC}       ;; return
     48          }
     49          

   \                                 In segment CODE, align 4, keep-with-next
     50          int fwrite32(int fh, char *buf, int len, unsigned int *err)
     51          {
   \                     fwrite32:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   0370A0E1           MOV      R7,R3
     52          int clen;
     53          int rlen; 
     54          int total=0;
   \   00000014   0080A0E3           MOV      R8,#+0
   \   00000018   010000EA           B        ??fwrite32_0
     55          while(len)
     56          {
     57          if (len>16384) clen=16384; else clen=len;
     58          total+=(rlen=fwrite(fh, buf, clen, err));
     59          if (rlen!=clen) break;
     60          buf+=rlen;
   \                     ??fwrite32_1:
   \   0000001C   055080E0           ADD      R5,R0,R5
     61          len-=clen;
   \   00000020   096046E0           SUB      R6,R6,R9
   \                     ??fwrite32_0:
   \   00000024   000056E3           CMP      R6,#+0
   \   00000028   0C00000A           BEQ      ??fwrite32_2
   \   0000002C   0100A0E3           MOV      R0,#+1
   \   00000030   400C80E3           ORR      R0,R0,#0x4000
   \   00000034   000056E1           CMP      R6,R0
   \   00000038   409CA0A3           MOVGE    R9,#+16384
   \   0000003C   0690A0B1           MOVLT    R9,R6
   \   00000040   0730A0E1           MOV      R3,R7
   \   00000044   0920A0E1           MOV      R2,R9
   \   00000048   0510A0E1           MOV      R1,R5
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   0C0000EF           SWI      +12
   \   00000054   088080E0           ADD      R8,R0,R8
   \   00000058   090050E1           CMP      R0,R9
   \   0000005C   EEFFFF0A           BEQ      ??fwrite32_1
     62          }
     63          return(total);
   \                     ??fwrite32_2:
   \   00000060   0800A0E1           MOV      R0,R8
   \   00000064   F083BDE8           POP      {R4-R9,PC}       ;; return
     64          }
     65          
     66          extern void kill_data(void *p, void (*func_p)(void *));
     67          

   \                                 In segment CODE, align 4, keep-with-next
     68          void ElfKiller(void)
     69          {
   \                     ElfKiller:
   \   00000000   00402DE9           PUSH     {LR}
     70            extern void *ELF_BEGIN;
     71            kill_data(&ELF_BEGIN,(void (*)(void *))mfree_adr());
   \   00000004   158000EF           SWI      +32789
   \   00000008   0010A0E1           MOV      R1,R0
   \   0000000C   04009FE5           LDR      R0,??ElfKiller_0  ;; ELF_BEGIN
   \   00000010   0040BDE8           POP      {LR}             ;; Pop
   \   00000014   ........           _BF      kill_data,??kill_data??rA  ;; tailcall
   \                     ??ElfKiller_0:
   \   00000018   ........           DC32     ELF_BEGIN
     72          }
     73          

   \                                 In segment CODE, align 4, keep-with-next
     74          int getint(unsigned char *ptr){
     75            return ptr[0]|(ptr[1]<<8)|((ptr[2])<<16)|((ptr[3])<<24);
   \                     getint:
   \   00000000   0010D0E5           LDRB     R1,[R0, #+0]
   \   00000004   0120D0E5           LDRB     R2,[R0, #+1]
   \   00000008   021481E1           ORR      R1,R1,R2, LSL #+8
   \   0000000C   0220D0E5           LDRB     R2,[R0, #+2]
   \   00000010   0300D0E5           LDRB     R0,[R0, #+3]
   \   00000014   021881E1           ORR      R1,R1,R2, LSL #+16
   \   00000018   000C81E1           ORR      R0,R1,R0, LSL #+24
   \   0000001C   1EFF2FE1           BX       LR               ;; return
     76          }
     77          

   \                                 In segment CODE, align 4, keep-with-next
     78          void prepname(char *file){
   \                     prepname:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   080000EA           B        ??prepname_0
     79            unsigned int err;
     80            do{
     81              while(*++file && *file!='/');
   \                     ??prepname_1:
   \   00000010   2F0050E3           CMP      R0,#+47
   \   00000014   0600001A           BNE      ??prepname_0
     82              if(!*file) break;
     83              *file=0;
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   0000C4E5           STRB     R0,[R4, #+0]
     84              mkdir(filename,&err);
   \   00000020   1C009FE5           LDR      R0,??prepname_2  ;; state + 32
   \   00000024   0D10A0E1           MOV      R1,SP
   \   00000028   100000EF           SWI      +16
     85              *file='\\';
   \   0000002C   5C00A0E3           MOV      R0,#+92
   \   00000030   0000C4E5           STRB     R0,[R4, #+0]
     86            }while(1);
   \                     ??prepname_0:
   \   00000034   0100F4E5           LDRB     R0,[R4, #+1]!
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   F3FFFF1A           BNE      ??prepname_1
     87          }
   \   00000040   1180BDE8           POP      {R0,R4,PC}       ;; return
   \                     ??prepname_2:
   \   00000044   ........           DC32     state + 32
     88          
     89          

   \                                 In segment CODE, align 4, keep-with-next
     90          int strcmp2(char *s, int p1, int p2, int size){
   \                     strcmp2:
   \   00000000   10002DE9           PUSH     {R4}
     91          	while(--size>=0)
   \                     ??strcmp2_0:
   \   00000004   013053E2           SUBS     R3,R3,#+1
   \   00000008   0A00004A           BMI      ??strcmp2_1
     92          	  if(s[p1++]!=s[p2++]) return false;
   \   0000000C   01C0A0E1           MOV      R12,R1
   \   00000010   01108CE2           ADD      R1,R12,#+1
   \   00000014   00C0DCE7           LDRB     R12,[R12, +R0]
   \   00000018   0240A0E1           MOV      R4,R2
   \   0000001C   012084E2           ADD      R2,R4,#+1
   \   00000020   0040D4E7           LDRB     R4,[R4, +R0]
   \   00000024   04005CE1           CMP      R12,R4
   \   00000028   F5FFFF0A           BEQ      ??strcmp2_0
   \   0000002C   1000BDE8           POP      {R4}
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   1EFF2FE1           BX       LR
     93          	return true;
   \                     ??strcmp2_1:
   \   00000038   1000BDE8           POP      {R4}
   \   0000003C   0100A0E3           MOV      R0,#+1
   \   00000040   1EFF2FE1           BX       LR               ;; return
     94          }
     95          

   \                                 In segment CODE, align 4, keep-with-next
     96          int getempty(byte *buf, int pos, int cnt){
     97          	int i,k,rez=0;
   \                     getempty:
   \   00000000   0020A0E3           MOV      R2,#+0
     98          	do{
     99          	  k=buf[pos++]&0xff;
   \                     ??getempty_0:
   \   00000004   0030D1E7           LDRB     R3,[R1, +R0]
   \   00000008   011081E2           ADD      R1,R1,#+1
    100          	  for(i=0;i<8;i++){
   \   0000000C   00C0A0E3           MOV      R12,#+0
   \   00000010   040000EA           B        ??getempty_1
    101          	    if((k&0x80)==0) return rez;
    102          	    k<<=1;
   \                     ??getempty_2:
   \   00000014   8330A0E1           LSL      R3,R3,#+1
    103          	    ++rez;
   \   00000018   012082E2           ADD      R2,R2,#+1
   \   0000001C   01C08CE2           ADD      R12,R12,#+1
   \   00000020   08005CE3           CMP      R12,#+8
   \   00000024   F6FFFFAA           BGE      ??getempty_0
   \                     ??getempty_1:
   \   00000028   800013E3           TST      R3,#0x80
   \   0000002C   F8FFFF1A           BNE      ??getempty_2
   \   00000030   0200A0E1           MOV      R0,R2
   \   00000034   1EFF2FE1           BX       LR               ;; return
    104          	  }
    105          	}while(true);
    106          }
    107          
    108          
    109          

   \                                 In segment CODE, align 4, keep-with-next
    110          unsigned char *un7z(int inFile, UInt32 compressedSize, UInt32 outSize){ //* на буфе??распак. данным?//  int res;                                            //outProcessed = скольк?распаковалос?  
   \                     un7z:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0090A0E1           MOV      R9,R0
   \   0000000C   0160A0E1           MOV      R6,R1
   \   00000010   0270A0E1           MOV      R7,R2
    111            SizeT inProcessed;
    112            unsigned char *inStream;
    113            unsigned char *outStream=0;
   \   00000014   0050A0E3           MOV      R5,#+0
    114          
    115            if(inFile!=-1 && compressedSize && outSize){
   \   00000018   010079E3           CMN      R9,#+1
   \   0000001C   00005613           CMPNE    R6,#+0
   \   00000020   00005713           CMPNE    R7,#+0
   \   00000024   3200000A           BEQ      ??un7z_0
    116              if(!(inStream = (unsigned char *)malloc(compressedSize))) return 0;
   \   00000028   0600A0E1           MOV      R0,R6
   \   0000002C   140000EF           SWI      +20
   \   00000030   0040B0E1           MOVS     R4,R0
   \   00000034   2E00000A           BEQ      ??un7z_0
    117             do{
    118              if(fread32(inFile,(char*)inStream,compressedSize,&err)!=compressedSize)  break;
   \   00000038   BC809FE5           LDR      R8,??un7z_1      ;; state
   \   0000003C   0620A0E1           MOV      R2,R6
   \   00000040   483F88E2           ADD      R3,R8,#+288
   \   00000044   0410A0E1           MOV      R1,R4
   \   00000048   0900A0E1           MOV      R0,R9
   \   0000004C   ........           BL       fread32
   \   00000050   060050E1           CMP      R0,R6
   \   00000054   2400001A           BNE      ??un7z_2
    119              if(!(outStream =(unsigned char *)malloc(outSize))) break;
   \   00000058   0700A0E1           MOV      R0,R7
   \   0000005C   140000EF           SWI      +20
   \   00000060   0050B0E1           MOVS     R5,R0
   \   00000064   2000000A           BEQ      ??un7z_2
    120          
    121              if (LzmaDecodeProperties(&state.Properties, properties, LZMA_PROPERTIES_SIZE) != LZMA_RESULT_OK){ mfree(outStream); outStream=0; break;}
   \   00000068   0520A0E3           MOV      R2,#+5
   \   0000006C   141088E2           ADD      R1,R8,#+20
   \   00000070   0800A0E1           MOV      R0,R8
   \   00000074   ........           _BLF     LzmaDecodeProperties,??LzmaDecodeProperties??rA
   \   00000078   000050E3           CMP      R0,#+0
   \   0000007C   0300000A           BEQ      ??un7z_3
   \   00000080   0500A0E1           MOV      R0,R5
   \   00000084   150000EF           SWI      +21
   \   00000088   0050A0E3           MOV      R5,#+0
   \   0000008C   160000EA           B        ??un7z_2
    122              state.Probs = (CProb *)malloc(LzmaGetNumProbs(&state.Properties) * sizeof(CProb));
   \                     ??un7z_3:
   \   00000090   001098E5           LDR      R1,[R8, #+0]
   \   00000094   042098E5           LDR      R2,[R8, #+4]
   \   00000098   C00FA0E3           MOV      R0,#+768
   \   0000009C   011082E0           ADD      R1,R2,R1
   \   000000A0   3620A0E3           MOV      R2,#+54
   \   000000A4   702E82E3           ORR      R2,R2,#0x700
   \   000000A8   100182E0           ADD      R0,R2,R0, LSL R1
   \   000000AC   8000A0E1           LSL      R0,R0,#+1
   \   000000B0   140000EF           SWI      +20
   \   000000B4   0C0088E5           STR      R0,[R8, #+12]
    123              LzmaDecode(&state, inStream, compressedSize, &inProcessed, outStream, outSize, &outProcessed);
   \   000000B8   1C0088E2           ADD      R0,R8,#+28
   \   000000BC   01002DE9           PUSH     {R0}
   \   000000C0   80002DE9           PUSH     {R7}
   \   000000C4   0620A0E1           MOV      R2,R6
   \   000000C8   0500A0E1           MOV      R0,R5
   \   000000CC   01002DE9           PUSH     {R0}
   \   000000D0   0C308DE2           ADD      R3,SP,#+12
   \   000000D4   0410A0E1           MOV      R1,R4
   \   000000D8   0800A0E1           MOV      R0,R8
   \   000000DC   ........           _BLF     LzmaDecode,??LzmaDecode??rA
    124              mfree(state.Probs);
   \   000000E0   0C0098E5           LDR      R0,[R8, #+12]
   \   000000E4   150000EF           SWI      +21
    125             }while(0); 
   \   000000E8   0CD08DE2           ADD      SP,SP,#+12
    126              mfree(inStream);
   \                     ??un7z_2:
   \   000000EC   0400A0E1           MOV      R0,R4
   \   000000F0   150000EF           SWI      +21
    127            }
    128            return outStream;
   \                     ??un7z_0:
   \   000000F4   0500A0E1           MOV      R0,R5
   \   000000F8   F283BDE8           POP      {R1,R4-R9,PC}
   \                     ??un7z_1:
   \   000000FC   ........           DC32     state
    129          }
    130          /* 
    131          int main(int argc, char **argv){
    132            UInt32 compressedSize=3815;
    133            UInt32 outSize=16359;
    134            FILE *inFile = 0;
    135            FILE *outFile = 0;
    136            char *outbuff;
    137          
    138            if (argc < 2 || argc > 3){
    139              printf("\nUsage:  lzmadec file.lzma [outFile]\n");
    140              return 1;
    141            }
    142          
    143            inFile = fopen(argv[1], "rb");
    144            if (inFile == 0) return 2;
    145            
    146            outbuff=un7z(inFile, compressedSize, outSize);
    147            if(outbuff){
    148              outFile = fopen(argv[2], "wb+");
    149              if (outFile == 0){ free(outbuff); return 3;}
    150              fwrite(outbuff, 1, outProcessed, outFile); 
    151              free(outbuff);
    152              fclose(outFile);
    153            }
    154            fclose(inFile);
    155            return 0;
    156          }
    157          */
    158          
    159          /////////////////////////////////////////////////////
    160          //SevenZip

   \                                 In segment CODE, align 4, keep-with-next
    161                int get8b(byte *b)
    162                {	//перекодировк?8байт
    163          		int i=0,v;
    164          		byte bb=b[getpos];
   \                     get8b:
   \   00000000   ........           LDR      R2,??DataTable1  ;; state
   \   00000004   10002DE9           PUSH     {R4}
   \   00000008   10C092E5           LDR      R12,[R2, #+16]
   \   0000000C   0030A0E3           MOV      R3,#+0
   \   00000010   0010DCE7           LDRB     R1,[R12, +R0]
   \   00000014   800011E3           TST      R1,#0x80
   \   00000018   0400000A           BEQ      ??get8b_0
    165          		while(bb&0x80){ bb<<=1; ++i;}
   \                     ??get8b_1:
   \   0000001C   811CA0E1           LSL      R1,R1,#+25
   \   00000020   211CA0E1           LSR      R1,R1,#+24
   \   00000024   013083E2           ADD      R3,R3,#+1
   \   00000028   800011E3           TST      R1,#0x80
   \   0000002C   FAFFFF1A           BNE      ??get8b_1
    166          		v=bb>>i;
   \                     ??get8b_0:
   \   00000030   5113A0E1           ASR      R1,R1,R3
    167          		switch(i)
   \   00000034   01C08CE2           ADD      R12,R12,#+1
   \   00000038   013053E2           SUBS     R3,R3,#+1
   \   0000003C   0400000A           BEQ      ??get8b_2
   \   00000040   013053E2           SUBS     R3,R3,#+1
   \   00000044   0600000A           BEQ      ??get8b_3
   \   00000048   013053E2           SUBS     R3,R3,#+1
   \   0000004C   0C00000A           BEQ      ??get8b_4
   \   00000050   160000EA           B        ??get8b_5
    168                          {
    169          		  case 1: v=(v<<8)|(b[++getpos]&0xff); break;
   \                     ??get8b_2:
   \   00000054   10C082E5           STR      R12,[R2, #+16]
   \   00000058   0000DCE7           LDRB     R0,[R12, +R0]
   \   0000005C   011480E1           ORR      R1,R0,R1, LSL #+8
   \   00000060   120000EA           B        ??get8b_5
    170          		  case 2: v=(v<<16)|(b[++getpos]&0xff)|((b[++getpos]&0xff)<<8); break;
                 		                                                              ^
Warning[Pa079]: undefined behavior: variable "getpos" (or a value reached by
          some form of indirection through it) is modified more than once
          without an intervening sequence point in this statement
   \                     ??get8b_3:
   \   00000064   10C082E5           STR      R12,[R2, #+16]
   \   00000068   01308CE2           ADD      R3,R12,#+1
   \   0000006C   103082E5           STR      R3,[R2, #+16]
   \   00000070   0040DCE7           LDRB     R4,[R12, +R0]
   \   00000074   0000D3E7           LDRB     R0,[R3, +R0]
   \   00000078   011884E1           ORR      R1,R4,R1, LSL #+16
   \   0000007C   001481E1           ORR      R1,R1,R0, LSL #+8
   \   00000080   0A0000EA           B        ??get8b_5
    171          		  case 3: v=(v<<24)|(b[++getpos]&0xff)|((b[++getpos]&0xff)<<8)|((b[++getpos]&0xff)<<16); break;
                 		                                                                                       ^
Warning[Pa079]: undefined behavior: variable "getpos" (or a value reached by
          some form of indirection through it) is modified more than once
          without an intervening sequence point in this statement
   \                     ??get8b_4:
   \   00000084   10C082E5           STR      R12,[R2, #+16]
   \   00000088   01308CE2           ADD      R3,R12,#+1
   \   0000008C   103082E5           STR      R3,[R2, #+16]
   \   00000090   014083E2           ADD      R4,R3,#+1
   \   00000094   104082E5           STR      R4,[R2, #+16]
   \   00000098   00C0DCE7           LDRB     R12,[R12, +R0]
   \   0000009C   0030D3E7           LDRB     R3,[R3, +R0]
   \   000000A0   0000D4E7           LDRB     R0,[R4, +R0]
   \   000000A4   011C8CE1           ORR      R1,R12,R1, LSL #+24
   \   000000A8   031481E1           ORR      R1,R1,R3, LSL #+8
   \   000000AC   001881E1           ORR      R1,R1,R0, LSL #+16
    172          		}
    173          		++getpos;
   \                     ??get8b_5:
   \   000000B0   100092E5           LDR      R0,[R2, #+16]
   \   000000B4   010080E2           ADD      R0,R0,#+1
   \   000000B8   100082E5           STR      R0,[R2, #+16]
    174          		return v;
   \   000000BC   1000BDE8           POP      {R4}
   \   000000C0   0100A0E1           MOV      R0,R1
   \   000000C4   1EFF2FE1           BX       LR               ;; return
    175          	}
    176          
    177          //char *tonewname(char *s, int size){
    178          //  memcpy(newname,s,size);
    179          //  newname[size]=0;
    180          //  return newname;
    181          //}
    182          
    183          

   \                                 In segment CODE, align 4, keep-with-next
    184          int main(char *exename, char *fname){
   \                     main:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   40D04DE2           SUB      SP,SP,#+64
   \   00000008   0140B0E1           MOVS     R4,R1
    185            byte bb[0x20], *b=bb;
    186            char *buffer=0;
    187            int inFile=-1, outFile=-1;
    188            int headoff,headsize,h2size,pos,cnt,maxcnt,p,pp,empty;
    189            int *filesize, *fileunsize;
    190            char *name, *file;
    191            int ii;
    192            //
    193          do{
    194            if(!fname || (inFile=fopen(fname,A_ReadOnly+A_BIN,P_READ,&err))==-1) break;
   \   0000000C   4D01000A           BEQ      ??main_0
   \   00000010   ........           LDR      R5,??DataTable1  ;; state
   \   00000014   8020A0E3           MOV      R2,#+128
   \   00000018   483F85E2           ADD      R3,R5,#+288
   \   0000001C   801CA0E3           MOV      R1,#+32768
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   0A0000EF           SWI      +10
   \   00000028   00008DE5           STR      R0,[SP, #+0]
   \   0000002C   010070E3           CMN      R0,#+1
   \   00000030   4401000A           BEQ      ??main_0
    195            strcpy(filename,fname);
   \   00000034   0410A0E1           MOV      R1,R4
   \   00000038   200085E2           ADD      R0,R5,#+32
   \   0000003C   1A0000EF           SWI      +26
    196            file=filename+strlen(filename);
   \   00000040   200085E2           ADD      R0,R5,#+32
   \   00000044   1B0000EF           SWI      +27
   \   00000048   050080E0           ADD      R0,R0,R5
   \   0000004C   206080E2           ADD      R6,R0,#+32
   \   00000050   200085E2           ADD      R0,R5,#+32
    197            while(--file>filename && *file!='.');
   \                     ??main_1:
   \   00000054   016046E2           SUB      R6,R6,#+1
   \   00000058   060050E1           CMP      R0,R6
   \   0000005C   0200002A           BCS      ??main_2
   \   00000060   0010D6E5           LDRB     R1,[R6, #+0]
   \   00000064   2E0051E3           CMP      R1,#+46
   \   00000068   F9FFFF1A           BNE      ??main_1
    198            *file=0;
   \                     ??main_2:
   \   0000006C   0000A0E3           MOV      R0,#+0
   \   00000070   0000C6E5           STRB     R0,[R6, #+0]
    199            mkdir(filename,&err);
   \   00000074   481F85E2           ADD      R1,R5,#+288
   \   00000078   200085E2           ADD      R0,R5,#+32
   \   0000007C   100000EF           SWI      +16
    200            *file++='\\';
   \   00000080   5C00A0E3           MOV      R0,#+92
   \   00000084   ........           STRB     R0,[R6], #+1
    201            //
    202            if(fread(inFile,b,hsize,&err)!=hsize)  break;
   \   00000088   00009DE5           LDR      R0,[SP, #+0]
   \   0000008C   483F85E2           ADD      R3,R5,#+288
   \   00000090   2020A0E3           MOV      R2,#+32
   \   00000094   1C108DE2           ADD      R1,SP,#+28
   \   00000098   0B0000EF           SWI      +11
   \   0000009C   200050E3           CMP      R0,#+32
    203            if(b[0]!=0x37 || b[1]!=0x7a) break;
   \   000000A0   1C00DD05           LDRBEQ   R0,[SP, #+28]
   \   000000A4   37005003           CMPEQ    R0,#+55
   \   000000A8   1D00DD05           LDRBEQ   R0,[SP, #+29]
   \   000000AC   7A005003           CMPEQ    R0,#+122
   \   000000B0   2101001A           BNE      ??main_3
    204          	headoff=(b[12]&0xff)|((b[13]&0xff)<<8)|
    205            	((b[14]&0xff)<<16)|((b[15]&0xff)<<24);
   \   000000B4   2800DDE5           LDRB     R0,[SP, #+40]
   \   000000B8   2910DDE5           LDRB     R1,[SP, #+41]
    206          	headsize=(b[20]&0xff)|((b[21]&0xff)<<8)|
    207            	((b[22]&0xff)<<16)|((b[23]&0xff)<<24);
   \   000000BC   3120DDE5           LDRB     R2,[SP, #+49]
    208          
    209            //inStream.skip(headoff+0x20);
    210            lseek(inFile,headoff+0x20,0,&err,&err);
   \   000000C0   483F85E2           ADD      R3,R5,#+288
   \   000000C4   010480E1           ORR      R0,R0,R1, LSL #+8
   \   000000C8   2A10DDE5           LDRB     R1,[SP, #+42]
   \   000000CC   010880E1           ORR      R0,R0,R1, LSL #+16
   \   000000D0   2B10DDE5           LDRB     R1,[SP, #+43]
   \   000000D4   010C80E1           ORR      R0,R0,R1, LSL #+24
   \   000000D8   3010DDE5           LDRB     R1,[SP, #+48]
   \   000000DC   208080E2           ADD      R8,R0,#+32
   \   000000E0   480F85E2           ADD      R0,R5,#+288
   \   000000E4   021481E1           ORR      R1,R1,R2, LSL #+8
   \   000000E8   3220DDE5           LDRB     R2,[SP, #+50]
   \   000000EC   021881E1           ORR      R1,R1,R2, LSL #+16
   \   000000F0   3320DDE5           LDRB     R2,[SP, #+51]
   \   000000F4   01002DE9           PUSH     {R0}
   \   000000F8   04009DE5           LDR      R0,[SP, #+4]
   \   000000FC   024C81E1           ORR      R4,R1,R2, LSL #+24
   \   00000100   0020A0E3           MOV      R2,#+0
   \   00000104   0810A0E1           MOV      R1,R8
   \   00000108   0F0000EF           SWI      +15
    211            if(fread(inFile,b,hsize,&err)!=hsize)  break;
   \   0000010C   04009DE5           LDR      R0,[SP, #+4]
   \   00000110   483F85E2           ADD      R3,R5,#+288
   \   00000114   2020A0E3           MOV      R2,#+32
   \   00000118   20108DE2           ADD      R1,SP,#+32
   \   0000011C   0B0000EF           SWI      +11
   \   00000120   200050E3           CMP      R0,#+32
   \   00000124   04D08DE2           ADD      SP,SP,#+4
   \   00000128   0301001A           BNE      ??main_3
    212            //if (LzmaDecodeProperties(&state.Properties, properties, LZMA_PROPERTIES_SIZE) != LZMA_RESULT_OK) return 3;
    213            //state.Probs = (CProb *)malloc(LzmaGetNumProbs(&state.Properties) * sizeof(CProb));
    214          
    215            if (b[0]==1 && b[1]==4 && b[2]==6){ //Распакованны?заголово?!
   \   0000012C   1C00DDE5           LDRB     R0,[SP, #+28]
   \   00000130   010050E3           CMP      R0,#+1
   \   00000134   1500001A           BNE      ??main_4
   \   00000138   1D00DDE5           LDRB     R0,[SP, #+29]
   \   0000013C   040050E3           CMP      R0,#+4
   \   00000140   1E00DD05           LDRBEQ   R0,[SP, #+30]
   \   00000144   06005003           CMPEQ    R0,#+6
   \   00000148   FB00001A           BNE      ??main_3
    216          		//System.arraycopy(b,0,decoder.m_OutWindow._buffer,0,hsize);
    217              buffer=malloc(headsize-hsize);
   \   0000014C   200044E2           SUB      R0,R4,#+32
   \   00000150   140000EF           SWI      +20
   \   00000154   0070A0E1           MOV      R7,R0
    218              lseek(inFile,headoff+0x20,0,&err,&err);
   \   00000158   480F85E2           ADD      R0,R5,#+288
   \   0000015C   01002DE9           PUSH     {R0}
   \   00000160   483F85E2           ADD      R3,R5,#+288
   \   00000164   0020A0E3           MOV      R2,#+0
   \   00000168   04009DE5           LDR      R0,[SP, #+4]
   \   0000016C   0810A0E1           MOV      R1,R8
   \   00000170   0F0000EF           SWI      +15
    219              fread32(inFile,buffer,headsize-hsize,&err);
   \   00000174   04009DE5           LDR      R0,[SP, #+4]
   \   00000178   483F85E2           ADD      R3,R5,#+288
   \   0000017C   202044E2           SUB      R2,R4,#+32
   \   00000180   0710A0E1           MOV      R1,R7
   \   00000184   ........           BL       fread32
    220          		//inStream.read(decoder.m_OutWindow._buffer,hsize,headsize-hsize);
    221              h2size=headsize;
   \   00000188   04D08DE2           ADD      SP,SP,#+4
   \   0000018C   2F0000EA           B        ??main_5
    222            }else{
    223             	if (b[0]!=0x17 || b[1]!=6) break;
   \                     ??main_4:
   \   00000190   170050E3           CMP      R0,#+23
   \   00000194   1D00DD05           LDRBEQ   R0,[SP, #+29]
   \   00000198   06005003           CMPEQ    R0,#+6
   \   0000019C   E600001A           BNE      ??main_3
    224          	  for(getpos=2;getpos<hsize-1;getpos++)
   \   000001A0   0240A0E3           MOV      R4,#+2
   \   000001A4   104085E5           STR      R4,[R5, #+16]
    225          	    if(b[getpos]==0 && b[getpos+1]==0xc) break;
   \                     ??main_6:
   \   000001A8   100095E5           LDR      R0,[R5, #+16]
   \   000001AC   1C108DE2           ADD      R1,SP,#+28
   \   000001B0   011080E0           ADD      R1,R0,R1
   \   000001B4   0020D1E5           LDRB     R2,[R1, #+0]
   \   000001B8   000052E3           CMP      R2,#+0
   \   000001BC   0110D105           LDRBEQ   R1,[R1, #+1]
   \   000001C0   0C005103           CMPEQ    R1,#+12
   \   000001C4   0300000A           BEQ      ??main_7
   \   000001C8   010080E2           ADD      R0,R0,#+1
   \   000001CC   100085E5           STR      R0,[R5, #+16]
   \   000001D0   1F0050E3           CMP      R0,#+31
   \   000001D4   F3FFFF3A           BCC      ??main_6
    226          	  if(b[++getpos]!=0xc) break;
   \                     ??main_7:
   \   000001D8   100095E5           LDR      R0,[R5, #+16]
   \   000001DC   1C108DE2           ADD      R1,SP,#+28
   \   000001E0   010080E2           ADD      R0,R0,#+1
   \   000001E4   100085E5           STR      R0,[R5, #+16]
   \   000001E8   0110D0E7           LDRB     R1,[R0, +R1]
   \   000001EC   0C0051E3           CMP      R1,#+12
   \   000001F0   D100001A           BNE      ??main_3
    227          	  ++getpos;
   \   000001F4   010080E2           ADD      R0,R0,#+1
   \   000001F8   100085E5           STR      R0,[R5, #+16]
    228          	  h2size=get8b(b);
   \   000001FC   1C008DE2           ADD      R0,SP,#+28
   \   00000200   ........           BL       get8b
    229            	getpos=2;
   \   00000204   104085E5           STR      R4,[R5, #+16]
    230              ii=0x20+get8b(b);
   \   00000208   1C008DE2           ADD      R0,SP,#+28
   \   0000020C   ........           BL       get8b
   \   00000210   204080E2           ADD      R4,R0,#+32
    231              lseek(inFile,ii,0,&err,&err);
   \   00000214   480F85E2           ADD      R0,R5,#+288
   \   00000218   01002DE9           PUSH     {R0}
   \   0000021C   483F85E2           ADD      R3,R5,#+288
   \   00000220   0020A0E3           MOV      R2,#+0
   \   00000224   04009DE5           LDR      R0,[SP, #+4]
   \   00000228   0410A0E1           MOV      R1,R4
   \   0000022C   0F0000EF           SWI      +15
    232              h2size=headoff+0x20-ii;
    233          	  //inStream.skip(0x20+get8b(b));
    234              if(!(buffer=(char*)un7z(inFile,h2size,maxdirsize))) break;
   \   00000230   04009DE5           LDR      R0,[SP, #+4]
   \   00000234   802CA0E3           MOV      R2,#+32768
   \   00000238   041048E0           SUB      R1,R8,R4
   \   0000023C   ........           BL       un7z
   \   00000240   0070B0E1           MOVS     R7,R0
   \   00000244   04D08DE2           ADD      SP,SP,#+4
   \   00000248   BB00000A           BEQ      ??main_3
    235            //if (!decoder.Code(main, main.zipbuf,inStream, main.os, h2size, handle, file))
    236              h2size=maxdirsize;
   \   0000024C   804CA0E3           MOV      R4,#+32768
    237            }
    238          
    239          	b=(byte*)buffer;
    240          	//////////// отладк?(табл.симв.)
    241          //  outFile = fopen("tab", "wb+"); 
    242          //  fwrite(buffer, 1, 20000, outFile); 
    243          //  fclose(outFile);
    244          	///////////
    245          	if (b[0]!=1 || b[1]!=4 || b[2]!=6 || b[3]!=0) //Распакованны?заголово?!
   \                     ??main_5:
   \   00000250   0000D7E5           LDRB     R0,[R7, #+0]
   \   00000254   010050E3           CMP      R0,#+1
   \   00000258   0100D705           LDRBEQ   R0,[R7, #+1]
   \   0000025C   04005003           CMPEQ    R0,#+4
   \   00000260   0200D705           LDRBEQ   R0,[R7, #+2]
   \   00000264   06005003           CMPEQ    R0,#+6
   \   00000268   0300D705           LDRBEQ   R0,[R7, #+3]
   \   0000026C   00005003           CMPEQ    R0,#+0
   \   00000270   B100001A           BNE      ??main_3
    246          		break;
    247          	getpos=4;
   \   00000274   0400A0E3           MOV      R0,#+4
   \   00000278   100085E5           STR      R0,[R5, #+16]
    248          	maxcnt=get8b(b);
   \   0000027C   0700A0E1           MOV      R0,R7
   \   00000280   ........           BL       get8b
   \   00000284   04008DE5           STR      R0,[SP, #+4]
    249          	if(b[getpos++]!=9) break;
   \   00000288   100095E5           LDR      R0,[R5, #+16]
   \   0000028C   011080E2           ADD      R1,R0,#+1
   \   00000290   101085E5           STR      R1,[R5, #+16]
   \   00000294   0700D0E7           LDRB     R0,[R0, +R7]
   \   00000298   090050E3           CMP      R0,#+9
   \   0000029C   A600001A           BNE      ??main_3
    250          	
    251                  filesize=(int *)malloc(maxcnt*2*sizeof(int));
   \   000002A0   04009DE5           LDR      R0,[SP, #+4]
    252                  fileunsize=filesize+maxcnt;
    253          	for(cnt=0;cnt<maxcnt;cnt++){
   \   000002A4   0080A0E3           MOV      R8,#+0
   \   000002A8   8001A0E1           LSL      R0,R0,#+3
   \   000002AC   140000EF           SWI      +20
   \   000002B0   08008DE5           STR      R0,[SP, #+8]
   \   000002B4   04109DE5           LDR      R1,[SP, #+4]
   \   000002B8   011180E0           ADD      R1,R0,R1, LSL #+2
   \   000002BC   14108DE5           STR      R1,[SP, #+20]
   \   000002C0   04009DE5           LDR      R0,[SP, #+4]
   \   000002C4   010050E3           CMP      R0,#+1
   \   000002C8   050000AA           BGE      ??main_8
   \   000002CC   070000EA           B        ??main_9
    254          	   filesize[cnt]=get8b(b);
   \                     ??main_10:
   \   000002D0   0700A0E1           MOV      R0,R7
   \   000002D4   ........           BL       get8b
   \   000002D8   08109DE5           LDR      R1,[SP, #+8]
   \   000002DC   080181E7           STR      R0,[R1, +R8, LSL #+2]
    255                  }
   \   000002E0   018088E2           ADD      R8,R8,#+1
   \                     ??main_8:
   \   000002E4   04009DE5           LDR      R0,[SP, #+4]
   \   000002E8   000058E1           CMP      R8,R0
   \   000002EC   F7FFFFBA           BLT      ??main_10
    256          	for(;getpos<h2size-1;getpos++)
   \                     ??main_9:
   \   000002F0   100095E5           LDR      R0,[R5, #+16]
   \   000002F4   019044E2           SUB      R9,R4,#+1
   \   000002F8   011080E2           ADD      R1,R0,#+1
   \   000002FC   090050E1           CMP      R0,R9
   \   00000300   0600002A           BCS      ??main_11
    257          	  if(b[getpos]==0 && b[getpos+1]==0xc) break;
   \   00000304   070080E0           ADD      R0,R0,R7
   \   00000308   0020D0E5           LDRB     R2,[R0, #+0]
   \   0000030C   000052E3           CMP      R2,#+0
   \   00000310   0100D005           LDRBEQ   R0,[R0, #+1]
   \   00000314   0C005003           CMPEQ    R0,#+12
   \   00000318   10108515           STRNE    R1,[R5, #+16]
   \   0000031C   F3FFFF1A           BNE      ??main_9
    258                  if(b[++getpos]!=0xc) break;
   \                     ??main_11:
   \   00000320   101085E5           STR      R1,[R5, #+16]
   \   00000324   0700D1E7           LDRB     R0,[R1, +R7]
   \   00000328   0C0050E3           CMP      R0,#+12
   \   0000032C   8200001A           BNE      ??main_3
    259          	++getpos;
   \   00000330   010081E2           ADD      R0,R1,#+1
   \   00000334   100085E5           STR      R0,[R5, #+16]
    260                  for(cnt=0;cnt<maxcnt;cnt++){
   \   00000338   04009DE5           LDR      R0,[SP, #+4]
   \   0000033C   0080A0E3           MOV      R8,#+0
   \   00000340   010050E3           CMP      R0,#+1
   \   00000344   050000AA           BGE      ??main_12
   \   00000348   070000EA           B        ??main_13
    261          	   fileunsize[cnt]=get8b(b);
   \                     ??main_14:
   \   0000034C   0700A0E1           MOV      R0,R7
   \   00000350   ........           BL       get8b
   \   00000354   14109DE5           LDR      R1,[SP, #+20]
   \   00000358   080181E7           STR      R0,[R1, +R8, LSL #+2]
    262                  }
   \   0000035C   018088E2           ADD      R8,R8,#+1
   \                     ??main_12:
   \   00000360   04009DE5           LDR      R0,[SP, #+4]
   \   00000364   000058E1           CMP      R8,R0
   \   00000368   F7FFFFBA           BLT      ??main_14
    263                  for(;getpos<h2size-1;getpos++)
   \                     ??main_13:
   \   0000036C   100095E5           LDR      R0,[R5, #+16]
   \   00000370   011080E2           ADD      R1,R0,#+1
   \   00000374   090050E1           CMP      R0,R9
   \   00000378   0600002A           BCS      ??main_15
    264          	  if(b[getpos]==0 && b[getpos+1]==5) break;
   \   0000037C   070080E0           ADD      R0,R0,R7
   \   00000380   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000384   000052E3           CMP      R2,#+0
   \   00000388   0100D005           LDRBEQ   R0,[R0, #+1]
   \   0000038C   05005003           CMPEQ    R0,#+5
   \   00000390   10108515           STRNE    R1,[R5, #+16]
   \   00000394   F4FFFF1A           BNE      ??main_13
    265          	if(b[++getpos]!=5) break;
   \                     ??main_15:
   \   00000398   101085E5           STR      R1,[R5, #+16]
   \   0000039C   0700D1E7           LDRB     R0,[R1, +R7]
   \   000003A0   050050E3           CMP      R0,#+5
   \   000003A4   6400001A           BNE      ??main_3
    266                  ++getpos;
   \   000003A8   010081E2           ADD      R0,R1,#+1
   \   000003AC   100085E5           STR      R0,[R5, #+16]
    267          	get8b(b);
   \   000003B0   0700A0E1           MOV      R0,R7
   \   000003B4   ........           BL       get8b
    268          	empty=0;
    269          	if(b[getpos]==0xe){	//Пустые заголовк?	    ++getpos;
   \   000003B8   100095E5           LDR      R0,[R5, #+16]
   \   000003BC   0090A0E3           MOV      R9,#+0
   \   000003C0   0710D0E7           LDRB     R1,[R0, +R7]
   \   000003C4   0E0051E3           CMP      R1,#+14
   \   000003C8   0F00001A           BNE      ??main_16
    270          	    empty=getempty(b,++getpos,cnt>>3);
   \   000003CC   01A080E2           ADD      R10,R0,#+1
   \   000003D0   10A085E5           STR      R10,[R5, #+16]
   \   000003D4   C8B1A0E1           ASR      R11,R8,#+3
   \   000003D8   0B20A0E1           MOV      R2,R11
   \   000003DC   0A10A0E1           MOV      R1,R10
   \   000003E0   0700A0E1           MOV      R0,R7
   \   000003E4   ........           BL       getempty
   \   000003E8   0090A0E1           MOV      R9,R0
    271          	    getpos+=(cnt>>3);//?
   \   000003EC   0A008BE0           ADD      R0,R11,R10
   \   000003F0   100085E5           STR      R0,[R5, #+16]
    272          	    while(b[++getpos]==0);// ++getpos;
   \                     ??main_17:
   \   000003F4   100095E5           LDR      R0,[R5, #+16]
   \   000003F8   010080E2           ADD      R0,R0,#+1
   \   000003FC   100085E5           STR      R0,[R5, #+16]
   \   00000400   0700D0E7           LDRB     R0,[R0, +R7]
   \   00000404   000050E3           CMP      R0,#+0
   \   00000408   F9FFFF0A           BEQ      ??main_17
    273          	 }
    274          	 if(b[getpos]==0x11){
   \                     ??main_16:
   \   0000040C   100095E5           LDR      R0,[R5, #+16]
   \   00000410   0710D0E7           LDRB     R1,[R0, +R7]
   \   00000414   110051E3           CMP      R1,#+17
   \   00000418   0300001A           BNE      ??main_18
    275          	    ++getpos;
   \   0000041C   010080E2           ADD      R0,R0,#+1
   \   00000420   100085E5           STR      R0,[R5, #+16]
    276          	    get8b(b);
   \   00000424   0700A0E1           MOV      R0,R7
   \   00000428   ........           BL       get8b
    277                   }
    278                --getpos;
   \                     ??main_18:
   \   0000042C   100095E5           LDR      R0,[R5, #+16]
   \   00000430   010040E2           SUB      R0,R0,#+1
   \   00000434   100085E5           STR      R0,[R5, #+16]
    279                while(b[++getpos]==0);
   \                     ??main_19:
   \   00000438   100095E5           LDR      R0,[R5, #+16]
   \   0000043C   010080E2           ADD      R0,R0,#+1
   \   00000440   100085E5           STR      R0,[R5, #+16]
   \   00000444   0700D0E7           LDRB     R0,[R0, +R7]
   \   00000448   000050E3           CMP      R0,#+0
   \   0000044C   F9FFFF0A           BEQ      ??main_19
    280                name = malloc(h2size>>1);
   \   00000450   C4A0A0E1           ASR      R10,R4,#+1
   \   00000454   0A00A0E1           MOV      R0,R10
   \   00000458   140000EF           SWI      +20
   \   0000045C   0040A0E1           MOV      R4,R0
    281                for(p=pp=0;p<(h2size>>1) && pp<cnt;p++)
   \   00000460   0000A0E3           MOV      R0,#+0
   \   00000464   0010A0E3           MOV      R1,#+0
   \   00000468   010000EA           B        ??main_20
    282                {
    283                  name[p]=(char)((b[getpos++]&0xff)+((b[getpos++]&0xff)<<8));
                                                                                   ^
Warning[Pa079]: undefined behavior: variable "getpos" (or a value reached by
          some form of indirection through it) is modified more than once
          without an intervening sequence point in this statement
    284                  if(name[p]==0)
    285                  if(empty>0)
    286                  {
    287                    p=pp=0; --p; --empty;
    288                  }
    289                  else ++pp;
   \                     ??main_21:
   \   0000046C   010080E2           ADD      R0,R0,#+1
   \                     ??main_22:
   \   00000470   011081E2           ADD      R1,R1,#+1
   \                     ??main_20:
   \   00000474   0A0051E1           CMP      R1,R10
   \   00000478   080050B1           CMPLT    R0,R8
   \   0000047C   0E0000AA           BGE      ??main_23
   \   00000480   102095E5           LDR      R2,[R5, #+16]
   \   00000484   0720D2E7           LDRB     R2,[R2, +R7]
   \   00000488   0420C1E7           STRB     R2,[R1, +R4]
   \   0000048C   102095E5           LDR      R2,[R5, #+16]
   \   00000490   022082E2           ADD      R2,R2,#+2
   \   00000494   102085E5           STR      R2,[R5, #+16]
   \   00000498   0420D1E7           LDRB     R2,[R1, +R4]
   \   0000049C   000052E3           CMP      R2,#+0
   \   000004A0   F2FFFF1A           BNE      ??main_22
   \   000004A4   010059E3           CMP      R9,#+1
   \   000004A8   EFFFFFBA           BLT      ??main_21
   \   000004AC   0000A0E3           MOV      R0,#+0
   \   000004B0   0010E0E1           MVN      R1,R0
   \   000004B4   019049E2           SUB      R9,R9,#+1
   \   000004B8   ECFFFFEA           B        ??main_22
    290                }
    291                p=pp=0;
   \                     ??main_23:
   \   000004BC   0090A0E3           MOV      R9,#+0
   \   000004C0   0010A0E3           MOV      R1,#+0
   \   000004C4   0C108DE5           STR      R1,[SP, #+12]
    292                pos=0x20;
   \   000004C8   2010A0E3           MOV      R1,#+32
   \   000004CC   10108DE5           STR      R1,[SP, #+16]
    293              for(cnt=0;cnt<maxcnt; cnt++){ // && !main.stop
   \   000004D0   0980A0E1           MOV      R8,R9
   \   000004D4   0F0000EA           B        ??main_24
    294          	while(name[pp]!=0) ++pp;
    295                  ///////
    296                  memcpy(file,name+p,pp-p+1);
    297                  prepname(file);
    298                  outFile=fopen(filename,A_ReadWrite+A_BIN+A_Create,P_READ+P_WRITE,&err);//tonewname(name+p,pp-p)
    299          	p=++pp;
    300                  lseek(inFile,pos,0,&err,&err);
    301                  mfree(buffer);/////
    302                  if(!(buffer=(char*)un7z(inFile,filesize[cnt],fileunsize[cnt]))){
    303            	   //free(filesize); fclose(inFile); 
    304                     if(outFile!=-1) fclose(outFile,&err);
    305                     goto lexit;
    306                     //return 11;
    307                  }
    308          	pos+=filesize[cnt];
   \                     ??main_25:
   \   000004D8   18209DE5           LDR      R2,[SP, #+24]
   \   000004DC   10109DE5           LDR      R1,[SP, #+16]
   \   000004E0   002092E5           LDR      R2,[R2, #+0]
    309                  if(outFile!=-1){
   \   000004E4   01007AE3           CMN      R10,#+1
   \   000004E8   011082E0           ADD      R1,R2,R1
   \   000004EC   10108DE5           STR      R1,[SP, #+16]
   \   000004F0   0700000A           BEQ      ??main_26
    310                    fwrite32(outFile,buffer,fileunsize[cnt],&err);
   \   000004F4   00209BE5           LDR      R2,[R11, #+0]
   \   000004F8   483F85E2           ADD      R3,R5,#+288
   \   000004FC   0710A0E1           MOV      R1,R7
   \   00000500   0A00A0E1           MOV      R0,R10
   \   00000504   ........           BL       fwrite32
    311                    fclose(outFile,&err);
   \   00000508   481F85E2           ADD      R1,R5,#+288
   \   0000050C   0A00A0E1           MOV      R0,R10
   \   00000510   0D0000EF           SWI      +13
    312                  }
   \                     ??main_26:
   \   00000514   018088E2           ADD      R8,R8,#+1
   \                     ??main_24:
   \   00000518   04009DE5           LDR      R0,[SP, #+4]
   \   0000051C   000058E1           CMP      R8,R0
   \   00000520   0E0000BA           BLT      ??main_27
    313              }
    314              mfree(buffer);
   \   00000524   0700A0E1           MOV      R0,R7
   \   00000528   150000EF           SWI      +21
    315          lexit:
    316              mfree(name);
   \                     ??main_28:
   \   0000052C   0400A0E1           MOV      R0,R4
   \   00000530   150000EF           SWI      +21
    317              mfree(filesize);
   \   00000534   08009DE5           LDR      R0,[SP, #+8]
   \   00000538   150000EF           SWI      +21
    318           }while(0);
    319           if(inFile!=-1) fclose(inFile,&err);
   \                     ??main_3:
   \   0000053C   00009DE5           LDR      R0,[SP, #+0]
   \   00000540   481F85E2           ADD      R1,R5,#+288
   \   00000544   0D0000EF           SWI      +13
    320           SUBPROC((void *)ElfKiller);
   \                     ??main_0:
   \   00000548   D4009FE5           LDR      R0,??main_29     ;; ElfKiller
   \   0000054C   710100EF           SWI      +369
    321           return (0);
   \   00000550   0000A0E3           MOV      R0,#+0
   \   00000554   40D08DE2           ADD      SP,SP,#+64
   \   00000558   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??main_30:
   \   0000055C   0B90A0E1           MOV      R9,R11
   \                     ??main_27:
   \   00000560   0400D9E7           LDRB     R0,[R9, +R4]
   \   00000564   01B089E2           ADD      R11,R9,#+1
   \   00000568   000050E3           CMP      R0,#+0
   \   0000056C   FAFFFF1A           BNE      ??main_30
   \   00000570   0C009DE5           LDR      R0,[SP, #+12]
   \   00000574   000049E0           SUB      R0,R9,R0
   \   00000578   012080E2           ADD      R2,R0,#+1
   \   0000057C   0C009DE5           LDR      R0,[SP, #+12]
   \   00000580   0B90A0E1           MOV      R9,R11
   \   00000584   041080E0           ADD      R1,R0,R4
   \   00000588   0600A0E1           MOV      R0,R6
   \   0000058C   1E0100EF           SWI      +286
   \   00000590   0600A0E1           MOV      R0,R6
   \   00000594   ........           BL       prepname
   \   00000598   483F85E2           ADD      R3,R5,#+288
   \   0000059C   602FA0E3           MOV      R2,#+384
   \   000005A0   0210A0E3           MOV      R1,#+2
   \   000005A4   811C81E3           ORR      R1,R1,#0x8100
   \   000005A8   200085E2           ADD      R0,R5,#+32
   \   000005AC   0A0000EF           SWI      +10
   \   000005B0   00A0A0E1           MOV      R10,R0
   \   000005B4   0C908DE5           STR      R9,[SP, #+12]
   \   000005B8   480F85E2           ADD      R0,R5,#+288
   \   000005BC   01002DE9           PUSH     {R0}
   \   000005C0   14109DE5           LDR      R1,[SP, #+20]
   \   000005C4   483F85E2           ADD      R3,R5,#+288
   \   000005C8   04009DE5           LDR      R0,[SP, #+4]
   \   000005CC   0020A0E3           MOV      R2,#+0
   \   000005D0   0F0000EF           SWI      +15
   \   000005D4   0700A0E1           MOV      R0,R7
   \   000005D8   150000EF           SWI      +21
   \   000005DC   0C109DE5           LDR      R1,[SP, #+12]
   \   000005E0   081181E0           ADD      R1,R1,R8, LSL #+2
   \   000005E4   1C108DE5           STR      R1,[SP, #+28]
   \   000005E8   18009DE5           LDR      R0,[SP, #+24]
   \   000005EC   001091E5           LDR      R1,[R1, #+0]
   \   000005F0   08B180E0           ADD      R11,R0,R8, LSL #+2
   \   000005F4   04009DE5           LDR      R0,[SP, #+4]
   \   000005F8   00209BE5           LDR      R2,[R11, #+0]
   \   000005FC   ........           BL       un7z
   \   00000600   0070B0E1           MOVS     R7,R0
   \   00000604   04D08DE2           ADD      SP,SP,#+4
   \   00000608   B2FFFF1A           BNE      ??main_25
   \   0000060C   01007AE3           CMN      R10,#+1
   \   00000610   C5FFFF0A           BEQ      ??main_28
   \   00000614   481F85E2           ADD      R1,R5,#+288
   \   00000618   0A00A0E1           MOV      R0,R10
   \   0000061C   0D0000EF           SWI      +13
   \   00000620   C1FFFFEA           B        ??main_28
   \                     ??main_29:
   \   00000624   ........           DC32     ElfKiller
    322          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   ........           DC32     state

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for state>`:
   \   00000000   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \                     `?<Initializer for getpos>`:
   \   00000010   00000000           DC32 0
   \                     `?<Initializer for properties>`:
   \   00000014   5D0000800000       DC8 93, 0, 0, 128, 0, 0, 0, 0
   \              0000        
   \                     `?<Initializer for outProcessed>`:
   \   0000001C   00000000           DC32 0
   \                     `?<Initializer for filename>`:
   \   00000020   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000030   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000040   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000050   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000060   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000070   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000080   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000090   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000A0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000B0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000C0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000D0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000E0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000F0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000100   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000110   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \                     `?<Initializer for err>`:
   \   00000120   00000000           DC8 0, 0, 0, 0
    323          
    324          /*
    325          int main(char *exename, char *fname)
    326          {
    327            int in,out;
    328            int packsize=1, unpacksize=2, filenamesize=3;
    329            unsigned int err;
    330            char *buf, *file=filename;
    331          ////// // char dummy[sizeof(MAIN_CSM)];
    332            if(fname && (in=fopen(fname,A_ReadOnly+A_BIN,0,&err))!=-1){
    333              strcpy(filename,fname);
    334              file=filename+strlen(filename);
    335              while(file>filename && *file!='\\') --file;
    336              ++file;
    337              while(1){
    338                if(fread(in,file,30,&err)!=30) break;
    339                if(getint(file)!=0x4034b50) break;
    340                packsize=getint(file+18);
    341                unpacksize=getint(file+22);
    342                filenamesize=getint(file+26);
    343                fread(in,file,filenamesize,&err);
    344                file[filenamesize]=0;
    345                if(file[filenamesize-1]!='/'){
    346                  if((buf=(char*)malloc((packsize==unpacksize)?packsize:(packsize+unpacksize)))!=NULL){
    347                    fread32(in,buf,packsize,&err);
    348                    prepname(file);
    349                    if ((out=fopen(filename,A_ReadWrite+A_BIN+A_Create,P_READ+P_WRITE,&err))!=-1){
    350                      if(packsize==unpacksize){
    351                        fwrite32(out,buf,packsize,&err);
    352                      }else{
    353                        unzip((Byte*)buf,packsize,(Byte*)(buf+packsize),unpacksize);
    354                        fwrite32(out,buf+packsize,unpacksize,&err);
    355                      }
    356                      fclose(out,&err);
    357                    }
    358                    mfree(buf);
    359                  }
    360                }
    361              }
    362          ////////  CreateCSM(&maincsm,dummy,0);  
    363            fclose(in,&err);
    364           }
    365          /////// // FreeWS(ws_filelist);
    366          /////// // ws_filelist=NULL;
    367           SUBPROC((void *)ElfKiller);
    368           return (0);
    369          }
    370          */
    371          
    372          //int main(int argc, char **argv){
    373          //  unpack(*++argv);
    374          //  return 0;
    375          //}

   Maximum stack usage in bytes:

     Function  CSTACK
     --------  ------
     ElfKiller     4
     fread32      28
     fwrite32     28
     get8b         4
     getempty      0
     getint        0
     main        104
     prepname     12
     strcmp2       4
     un7z         48


   Segment part sizes:

     Function/Label           Bytes
     --------------           -----
     waitEOS                     4
     maxdirsize                  4
     hsize                       4
     state                     292
     fread32                   104
     fwrite32                  104
     ElfKiller                  28
     getint                     32
     prepname                   72
     strcmp2                    68
     getempty                   56
     un7z                      256
     get8b                     200
     main                     1576
     ??DataTable1                4
     ?<Initializer for state>  292
      Others                    88

 
 2 576 bytes in segment CODE
    12 bytes in segment DATA_C
   292 bytes in segment DATA_I
   292 bytes in segment DATA_ID
    12 bytes in segment INITTAB
 
 2 500 bytes of CODE  memory (+ 88 bytes shared)
   304 bytes of CONST memory
   292 bytes of DATA  memory

Errors: none
Warnings: 4
