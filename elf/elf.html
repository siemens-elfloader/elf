<HTML><HEAD><meta http-equiv='Content-Type' content='text/html; charset=windows-1251'><TITLE>Создание ELF-приложений</TITLE><link rel='STYLESHEET' type='text/css' href='st.css'><link rel='STYLESHEET' type='text/css' href='scin/pages.css'><link rel='STYLESHEET' type='text/css' href='scin/teg.css'><link rel='STYLESHEET' type='text/css' href='scin/left-menu.css'><script language='JavaScript' src='menus.js'></script>
<style type='text/css'></style></HEAD>
<body  onload='parseStylesheets();'><CENTER>
<TABLE class=main id=main style="HEIGHT: 100%" cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=head colSpan=2>
<TABLE cellSpacing=0 cellPadding=0 width="100%">
<TBODY>
<TR>
<TD id=menu_top></TD></TR>
<TR>
<TD id=zagol>
<TABLE class=zagol cellSpacing=0 cellPadding=0>
<TBODY>
<TR>
<TD id=SiteName>
<DIV id=name_div>
<P align=right>Эльфы для Siemens</P></DIV></TD></TR></TBODY></TABLE>
<DIV></DIV></TD></TR></TBODY></TABLE></TD></TR>
<TR>
<TD vAlign=top>
<TABLE height="100%" cellSpacing=0 cellPadding=0>
<TBODY>
<TR>
<TD id=menu_left>
<DIV id=divMenuBarLeft>
<DIV id=left-menu>
<TABLE width="100%">
<TBODY>
<TR>
<FORM name=frm_s onsubmit="search_text();return false;">
<TD id=l_search></TD></FORM></TR>
<TR>
<TD class=betv_menuleft></TD></TR></TBODY></TABLE>
<UL class=men_l id=nav>
<LI class=m_l><A lang=a1 href="main.html" page="1">Новости</A></LI>
<LI class=m_l><A lang=a1 href="elf_download.html" page="2">ELF - контент</A></LI>
<LI class=m_l><A lang=a1 href="java_download.html" page="4">JAVA - контент</A></LI>
<LI class=m_l><A lang=a1 href="readplay.html" page="3">ReadPlayZX</A></LI>
<LI class=m_l><A lang=a1 href="mobilerar.html" page="5">MobileRAR</A></LI>
<LI class=m_l><A lang=a1 href="mobilerar_faq.html" page="6">MobileRAR - FAQ</A></LI>
<LI class=m_l><A lang=a1 id=left-current href="elf.html" page="7">Справочник по ELF</A></LI>
<LI class=m_l><A lang=a1 href="arm.html" page="8">Siemens ARM</A></LI>
<LI class=m_l><A lang=a1 href="misc.html" page="9">MISC</A></LI>
<LI class=m_l><A lang=a1 href="forum.html" page="10">ФОРУМ</A></LI>
<LI class=m_l><A lang=a1 href="authors.html" page="11">Авторы</A></LI>
<LI class=m_l><A lang=a1 href="http://www.google.com/translate?u=http%3A%2F%2Fcbn.narod.ru%2Fmain.html&langpair=ru%7Cen&hl=en&ie=UTF8">English</A></LI>
</UL></DIV></DIV></TD></TR>
<TR>
<TD id=anons_1></TD></TR></TBODY></TABLE></TD>
<TD vAlign=top width="100%">
<TABLE height="100%" cellSpacing=0 cellPadding=0 width="100%">
<TBODY>
<TR>
<TD id=menu_middle></TD></TR>
<TR>
<TD id=link vAlign=top><A name=top></A>
<TABLE cellSpacing=0 cellPadding=4>
<TBODY>
<TR>
<TD id=link_back></TD>
<TD id=link_next></TD>
<TD id=print1></TD></TR></TBODY></TABLE></TD></TR>
<TR>
<TD id=text style="HEIGHT: 100%">
<H1 class=pagename_div>Создание ELF-приложений</H1>
<DIV id=text_div>Эльфы написаны на языке Си и обеспечивают максимальное быстродействие. <BR>Для их запуска у Вас должны быть установлены 3 ПАТЧА: библиотека функций, elfloader и swi-hook конкретно для ВАШЕЙ МОДЕЛИ прошивки и мобилы (номер прошивки смотрим по *#06# -&gt; Другие функции, строку SW-Version). Ссылки на патчи смотрим ниже. <BR>В настоящий момент загрузчик эльфов написан для всех моделей x65 (некоторые нужно перешить в др. модель, что обозначается -&gt;): CX65-&gt;CX70, M65(-&gt;CX70), C65-&gt;SL65, S65 <BR>и для x75 моделей: S75, CX75 и др. 
<H3>Инструкция по созданию эльфов от cbn 0.4:</H3>Все примеры (с) Rst7. <BR>Что такое эльфы см. <A href="http://www.siemens-club.org/faq/index.php?Action=showarticle&amp;faqID=231">здесь.</A> <BR>Готовые эльфы и патчи ищем на <A href="http://patches.kibab.com/">kibab</A> <BR><BR>Содержание: <BR><br><a href="#page1">1. Установка Си компилятора IAR</a>
<br><a href="#page2">2. Установка загрузчика эльфов на мобилу</a>
<br><a href="#page3">3. Запуск примеров в IAR</a>
<br><a href="#page4">4. Создаем свой эльф</a>
<br><a href="#page5">5. Пример 1. Работа с памятью и файлами</a>
<br><a href="#page6">6. Пример 2. Вывод на экран и обработка клавиш</a>
<br><a href="#page7">7. Пример попроще. Запускаем фоновый процесс, рисуем по таймеру </a>
<br><a href="#page8">8. Пример 4. Резидентная программа</a>
<br><a href="#page9">9. FAQ</a> <BR><BR><A name=page1><B>1. Установка Си компилятора IAR</B></A> <BR>- С сайта <A href="http://www.iar.com/">www.iar.com</A> скачиваем evaluation версию ARM IAR компилятора (&gt;100 Мб), <BR>при регистрации указывая реальный e-mail - на него пришлют ключ. <BR>- Запускаем крек <A href="http://cbn.narod.ru/Iarunicrk.rar">iarunicrk</A> чтобы обойти 30-дневное ограничение (прочитать инструкцию). <BR>Или (кому лень качать 100 Мб :) берем урезанную рабочую версию Iar (11 Мб, без англ.help и т.п.) <BR>отсюда: &nbsp; <A href="http://cbn.narod.ru/Iar1.7z">1</A> &nbsp; <A href="http://cbn.narod.ru/Iar2.7z">2</A> &nbsp; <A href="http://cbn.narod.ru/Iar3.7z">3</A> &nbsp; <A href="http://cbn.narod.ru/Iar4.7z">4</A> &nbsp; <A href="http://cbn.narod.ru/Iar5.7z">5</A> &nbsp; <A href="http://cbn.narod.ru/Iar6.7z">6</A> &nbsp; <A href="http://cbn.narod.ru/Iar7.7z">7</A> <BR><BR><A name=page2><B>2. Установка загрузчика эльфов на мобилу</B> ( понадобится шнур - без него никак ):</A> <BR>- Идем на сименс-клуб, читаем все про эльфы в <A href="http://www.siemens-club.org/faq/index.php?Action=showarticle&amp;faqID=231">FAQ</A> и на форумах там же. <BR>- Делаем как там написано...:) <BR><BR><A name=page3><B>3. Запуск примеров в IAR</B></A> <BR>- Распаковываем примеры от <A href="http://cbn.narod.ru/Rst7.rar">Rst7</A> (и <A href="http://cbn.narod.ru/Unzipsrc.zip">Unzip</A>, <A href="http://cbn.narod.ru/Tetrisrc.zip">Tetris</A>, <A href="http://cbn.narod.ru/Balloonsrc.zip">Ballooons</A>(cbn), <A href="http://cbn.narod.ru/Dictzip.rar">Diction</A>(alex_itd), <A href="http://cbn.narod.ru/Calcsrc.rar">Calc</A>, библ. <A href="http://cbn.narod.ru/Swilib.zip">Swilib</A>) <BR>в папку E:\ARM\ <BR>- Запускаем IAR, открываем Open existing Workspace один из примеров <BR>- Щелкаем в левом окне вверху на название проекта и выбираем меню Project-&gt;Options-&gt;Arm <BR>- Компилируем Project -&gt; Rebuild All <BR>Если получили ошибку "_thumb...in range 0-0xFF", то не сделали предыдущий пункт! <BR>В настройках должно стоять Release (Project-&gt;Edit Configurations-&gt;Release), т.к. скомпилированные с Debug эльфы не загрузятся! <BR>- Полученный эльф лежит в папке E:\ARM\Имя проекта\Release\Exe\ <BR>PS. Если нужен эльф для x65, то перед компиляцией комментируем // в файле E:\ARM\swilib.h строку <BR>#define NEWSGOLD, если для s75, то убираем комментарий. <BR>Комментируем все ненужные #include png,sys,&lt;&gt;... кроме swilib.h <BR>Если выскакивает ошибка obexcopy... не пугаться - все ок. <BR>Как видим все очень просто :) <BR><BR><A name=page4><B>4. Создаем свой эльф</B></A> <BR>Теперь создание эльфов стало совсем простым делом :) <BR>Проще всего подправить готовый пример: см. предыдущий раздел. <BR>Добавляем к проекту "Project-&gt;Add Files" файлы <A href="http://cbn.narod.ru/Siemens.c">Siemens.c</A> и <A href="http://cbn.narod.ru/main.c">main.c</A>
<br>(А вот последняя версия мультиплатформенного
<a href="http://cbn.narod.ru/Siemens.cpp">Siemens.cpp</a> с автоопределением типа мобилы).

 <BR>К проекту должны быть подключены файлы Func.asm (точка старта) и div.r79 (деление, см.Swilib выше) <BR>Корректируем в main.c функции: <BR>onkey - обработка клавиш (return 1 для выхода из эльфа) <BR>onredraw - перерисовка экрана (массива screen[132*176]) <BR>onstart, oncreate - функции вызываются при старте <BR>onclose, onexit - функции вызываются при выходе <BR>REDRAW() вызываем для перерисовки экрана (запуска onredraw) <BR>И ВСЕ! У Вас готовое приложение. Специфику Сименса знать не нужно вообще! <BR>Также см. примеры ниже. <BR><BR><A name=page5><B>5. Пример 1. Работа с памятью и файлами</B></A> <BR>меняем в любом примере main.c на: <BR>#include "E:\ARM\swilib.h" <BR><BR>void ElfKiller(void){ // Используется для выхода из эльфа <BR>extern void *ELF_BEGIN; <BR>// здесь обычно еще освобождают память по mfree(), freeWS() <BR>((void (*)(void *))(mfree_adr()))(&amp;ELF_BEGIN); // Ничего не понятно :( <BR>} <BR><BR>int main(char *exename, char *fname){ // Основная функция <BR>// в exename передается путь запущенного эльфа вида 4:\Zbin\xyz.elf <BR>// в fname передается имя файла, который выбран в CardExplorere, вида 0:\Misc\data.txt <BR>// или 0, если elf запущен сам <BR>char *mem; <BR>int i, err; <BR>int handle; <BR>if(fname){ <BR>// Работа с файлами стандартна: <BR>handle=fopen(fname,A_ReadWrite+A_BIN+A_Append+A_Create,P_READ+P_WRITE,&amp;err); <BR>// Открыть для чтения и записи в двоичн. режиме с дозаписью (append), создать если нет <BR>// или handle=fopen(fname,A_ReadOnly+A_BIN,P_READ,&amp;err); // только для чтения - константы см. swilib.h <BR>if(handle!=-1){ //-1 = error <BR>mem=malloc(10000); // Выделить память: AllocWS() для строк (по 2б) <BR>if(mem!=0){ //0 = error <BR>i=fread(handle,mem,10000,&amp;err); // Возвращает число прочитанных байт и ошибку в err <BR>// Делаем что-либо makesomebody(mem,i); <BR>fwrite(handle,mem,i,&amp;err); <BR>mfree(mem); // Освободить память: FreeWS() для строк <BR>} <BR>fclose(handle); // Закрыть файл <BR>} <BR>} <BR>SUBPROC((void *)ElfKiller); // се загадка великая есть :) Но без нее низя! <BR>return(0); <BR>} <BR>// PS. Т.к. в x65 файловые чтение и запись проводятся блоками до 32767 байт, <BR>// вместо fread() и fwrite() используем их аналоги fread32() и fwrite32( аналогично) <BR><BR>int fread32(int fh, char *buf, int len, unsigned int *err) // (с) Rst7 <BR>{ <BR>int clen; <BR>int rlen; <BR>int total=0; <BR>while(len) <BR>{ <BR>if (len&gt;16384) clen=16384; else clen=len; <BR>total+=(rlen=fread(fh, buf, clen, err)); <BR>if (rlen!=clen) break; <BR>buf+=rlen; <BR>len-=clen; <BR>} <BR>return(total); <BR>} <BR><BR>Не забываем включить в каждый проект файл &nbsp;<B>Func.asm</B>: <BR>PUBLIC ELF_BEGIN <BR>RSEG ELFBEGIN:DATA <BR>ELF_BEGIN <BR>defadr MACRO a,b <BR>PUBLIC a <BR>a EQU b <BR>ENDM <BR>END <BR><BR><A name=page6><B>6. Пример 2. Вывод на экран и обработка клавиш</B></A> <BR>Выводит маленький рисунок на экран, перемещаемый с помощью джойстика, <BR>и выходит по долгому нажатию красной кнопки. Сделан на примере TED-а (c) Rst7 <BR>Смотреть снизу-вверх :) <BR>меняем в примере main.c на: <BR>#include "E:\ARM\swilib.h" <BR><BR>typedef struct <BR>{ <BR>GUI gui; <BR>// WSHDR *ws1; <BR>// WSHDR *ws2; <BR>// int i1; <BR>}MAIN_GUI; <BR><BR>typedef struct <BR>{ <BR>CSM_RAM csm; <BR>int gui_id; <BR>}MAIN_CSM; <BR><BR>const int minus11=-11; <BR>const unsigned int INK=0; <BR>const unsigned int PAPER=1; <BR>volatile int xx=0, yy=0; // Координаты отображения рисунка <BR><BR>const char bmp[12]={0xFC,0x86,0xB3,0xA9,0xB1,0xA9,0x81,0xFF,0,0,0,0}; <BR>const IMGHDR img = {8,12,0x1,0,(char *)bmp}; <BR><BR>//================================ <BR>//Вывод на экран <BR>//================================ <BR><BR>void DrwImg(IMGHDR *img, int x, int y, int *pen, int *brush) <BR>{ <BR>RECT rc; <BR>DRWOBJ drwobj; <BR>StoreXYWHtoRECT(&amp;rc,x,y,img-&gt;w,img-&gt;h); <BR>SetPropTo_Obj5(&amp;drwobj,&amp;rc,0,img); <BR>SetColor(&amp;drwobj,pen,brush); <BR>DrawObject(&amp;drwobj); <BR>} <BR><BR>void DrawScreen(void) <BR>{ <BR>int *ink=GetPaletteAdrByColorIndex(INK); <BR>int *paper=GetPaletteAdrByColorIndex(PAPER); <BR>int x=xx; <BR>DrwImg((IMGHDR *)&amp;img,x,yy,ink,paper); <BR>} <BR><BR>//Перерисовка основного диалога <BR>void method0(MAIN_GUI *data){ <BR>DrawScreen(); <BR>} <BR><BR>void method1(MAIN_GUI *data, void *(*malloc_adr)(int)){} <BR>void method2(MAIN_GUI *data, void (*mfree_adr)(void *)){} <BR>void method3(MAIN_GUI *data, void *(*malloc_adr)(int), void (*mfree_adr)(void *)){} <BR>void method4(MAIN_GUI *data, void (*mfree_adr)(void *)){} <BR>void method7(MAIN_GUI *data, void (*mfree_adr)(void *)){} <BR>int method8(void){return(0);} // Пустая ф-я <BR>int method9(void){return(0);} // Пустая ф-я <BR><BR>//------------------------------------------------------------------------------ <BR>// Осн. диалог - обработка кнопок <BR>//------------------------------------------------------------------------------ <BR>int method5(MAIN_GUI *data, GUI_MSG *msg) <BR>{ <BR>// if (msg-&gt;gbsmsg-&gt;msg==KEY_UP) // Клавиша отпущена <BR>if ((msg-&gt;gbsmsg-&gt;msg==KEY_DOWN)||(msg-&gt;gbsmsg-&gt;msg==LONG_PRESS)) // Кл. нажата или удерживается <BR>switch(msg-&gt;gbsmsg-&gt;submess) <BR>{ <BR>case RED_BUTTON: <BR>return(1); //Происходит вызов GeneralFunc для тек. GUI -&gt; закрытие GUI <BR>case UP_BUTTON: <BR>if(yy&gt;0) --yy; break; <BR>case LEFT_BUTTON: <BR>if(xx&gt;0) --xx; break; <BR>case DOWN_BUTTON: <BR>if(yy&lt;130) ++yy; break; <BR>case RIGHT_BUTTON: <BR>if(xx&lt;120) ++xx; break; <BR><BR>// case GREEN_BUTTON: <BR>// case RIGHT_SOFT: <BR>// case ENTER_BUTTON: <BR>// case LEFT_SOFT: <BR>// case VOL_UP_BUTTON: <BR>// case VOL_DOWN_BUTTON: <BR>// case '0': <BR>// case '9': <BR>// case '#': <BR>// SUBPROC((void *)DoDiskAccess,1); <BR>// Др. процесс с низким приоритетом чтобы не тормозить перерисовку окна <BR>} <BR>DrawScreen(); <BR>return(0); <BR>} <BR><BR>const void * const gui_methods[11]={ <BR>(void *)method0, //Redraw <BR>(void *)method1, //Create <BR>(void *)method2, //Close <BR>(void *)method3, //Focus <BR>(void *)method4, //Unfocus <BR>(void *)method5, //OnKey <BR>0, <BR>(void *)method7, //Destroy <BR>(void *)method8, <BR>(void *)method9, <BR>0 <BR>}; <BR><BR>const RECT Canvas={0,0,131,175}; <BR><BR>void maincsm_oncreate(CSM_RAM *data) <BR>{ <BR>MAIN_GUI *main_gui=malloc(sizeof(MAIN_GUI)); <BR>MAIN_CSM*csm=(MAIN_CSM*)data; <BR>zeromem(main_gui,sizeof(MAIN_GUI)); <BR><BR>// ustk=malloc(STKSZ); // Выделяем память под что нам надо <BR>// info_ws=AllocWS(512); <BR><BR>main_gui-&gt;gui.canvas=(void *)(&amp;Canvas); <BR>main_gui-&gt;gui.flag30=2; <BR>main_gui-&gt;gui.methods=(void *)gui_methods; // Основные методы (см. выше) <BR>main_gui-&gt;gui.item_ll.data_mfree=(void (*)(void *))mfree_adr(); // Ниже ниче не знаю :( <BR>csm-&gt;csm.state=0; <BR>csm-&gt;csm.unk1=0; <BR>csm-&gt;gui_id=CreateGUI(main_gui); // Собственно создание GUI <BR>} <BR><BR>void Killer(void) // Выход <BR>{ <BR>extern void *ELF_BEGIN; <BR>// mfree(ustk); // Освобождаем память <BR>// FreeWS(info_ws); <BR>((void (*)(void *))(mfree_adr()))(&amp;ELF_BEGIN); <BR>} <BR><BR>void maincsm_onclose(CSM_RAM *csm) <BR>{ <BR>// GBS_StopTimer(&amp;light_tmr); <BR>SUBPROC((void *)Killer); <BR>} <BR><BR>int maincsm_onmessage(CSM_RAM *data, GBS_MSG *msg){ <BR>return(1); <BR>} <BR><BR>unsigned short maincsm_name_body[140]; <BR><BR>const struct <BR>{ <BR>CSM_DESC maincsm; <BR>WSHDR maincsm_name; <BR>}MAINCSM = <BR>{ <BR>{ <BR>maincsm_onmessage, // Обработчик сообщений <BR>maincsm_oncreate, // Вызывается при создании <BR>// 0, // Для S75 убрать комментарии в 4х строчках <BR>// 0, // и раскомментировать в swilib.h строку #define NEWSGOLD <BR>// 0, <BR>// 0, <BR>maincsm_onclose, // Вызывается при закрытии <BR>sizeof(MAIN_CSM), <BR>1, <BR>&amp;minus11 <BR>}, <BR>{ <BR>maincsm_name_body, <BR>NAMECSM_MAGIC1, <BR>NAMECSM_MAGIC2, <BR>0x0, <BR>139 <BR>} <BR>}; <BR><BR>int main(char *exename, char *fname) <BR>{ <BR>char dummy[sizeof(MAIN_CSM)]; <BR>// strcpy(filename,fname); // Сохраняем где-либо fname <BR>CreateCSM(&amp;MAINCSM.maincsm,dummy,0); <BR>return 0; <BR>} <BR><BR><A name=page7><B>7. Пример попроще. Запускаем фоновый процесс, рисуем по таймеру</B></A> <BR>Добавляем к проекту "Project-&gt;Add Files" файл Siemens.c: <BR>// Siemens.c 0.1 <BR>// Интерфейс мобилы для IAR <BR>// Здесь ничего не трогаем! (если не уверены) <BR>// Внешние функции вызываются при: <BR>extern int onstart(char *exename, char *fname); // Старте приложения. Возвращает 0 или 1 для выхода. <BR>extern void oncreate(); // Создании окна <BR>extern void onclose(); // Закрытии окна <BR>extern void onexit(); // Выходе <BR>extern void onredraw(void); // Перерисовке экрана <BR>extern int onkey(unsigned char keycode, int pressed); // Нажатии клавиши. Возвращает 0 или 1 для выхода. <BR><BR>// В swilib.h комментируем // строку #define NEWSGOLD если не S75 <BR>#include "E:\ARM\swilib.h" <BR>// Следующая строка задает 16 битный режим (RGB 565 по 2 байта на точку экрана screen) <BR>// закомментировав получим 8 битный режим (RGB 232 по 1 байту на точку) <BR>#define HIGHCOLOR <BR>#ifdef HIGHCOLOR <BR>short screen[132*176]; <BR>const int screensize=132*176*sizeof(short); <BR>const IMGHDR img = {(unsigned)132,(unsigned)176,8,0,(char*)screen}; <BR>#else <BR>char screen[132*176]; <BR>const int screensize=132*176*sizeof(char); <BR>const IMGHDR img = {(unsigned)132,(unsigned)176,5,0,(char*)screen}; <BR>#endif <BR><BR>// Ниже читать уже не надо! :) <BR>typedef struct <BR>{ <BR>GUI gui; <BR>WSHDR *ws1; <BR>WSHDR *ws2; <BR>int i1; <BR>}MAIN_GUI; <BR><BR>typedef struct <BR>{ <BR>CSM_RAM csm; <BR>int gui_id; <BR>}MAIN_CSM; <BR><BR>void DrawScreen(){ <BR>RECT rc; DRWOBJ drwobj; <BR>StoreXYWHtoRECT(&amp;rc,0,0,img.w,img.h); <BR>SetPropTo_Obj5(&amp;drwobj,&amp;rc,0,(IMGHDR*)&amp;img); <BR>SetColor(&amp;drwobj,GetPaletteAdrByColorIndex(0),GetPaletteAdrByColorIndex(1)); <BR>DrawObject(&amp;drwobj); <BR>} <BR>void method0(MAIN_GUI *data){ onredraw(); DrawScreen();} <BR>void method1(MAIN_GUI *data, void *(*malloc_adr)(int)){ oncreate(); data-&gt;gui.state=1;} <BR>void method2(MAIN_GUI *data, void (*mfree_adr)(void *)){ data-&gt;gui.state=0;} <BR>void method3(MAIN_GUI *data, void *(*malloc_adr)(int), void (*mfree_adr)(void *)){ data-&gt;gui.state=2;} <BR>void method4(MAIN_GUI *data, void (*mfree_adr)(void *)){ if (data-&gt;gui.state!=2) return; data-&gt;gui.state=1;} <BR>int method5(MAIN_GUI *data, GUI_MSG *msg){ <BR>return onkey(msg-&gt;gbsmsg-&gt;submess, msg-&gt;gbsmsg-&gt;msg);} <BR>void method7(MAIN_GUI *data, void (*mfree_adr)(void *)){}// mfree_adr(data); <BR>int method8(void){return(0);} // Пустая ф-я <BR>int method9(void){return(0);} // Пустая ф-я <BR><BR>const void * const gui_methods[11]={ <BR>(void *)method0, //Redraw <BR>(void *)method1, //Create <BR>(void *)method2, //Close <BR>(void *)method3, //Focus <BR>(void *)method4, //Unfocus <BR>(void *)method5, //OnKey <BR>0, <BR>(void *)method7, //Destroy <BR>(void *)method8, <BR>(void *)method9, <BR>0 <BR>}; <BR><BR>const RECT Canvas={0,0,131,175}; <BR><BR>void maincsm_oncreate(CSM_RAM *data) <BR>{ <BR>MAIN_GUI *main_gui=malloc(sizeof(MAIN_GUI)); <BR>MAIN_CSM*csm=(MAIN_CSM*)data; <BR>zeromem(main_gui,sizeof(MAIN_GUI)); <BR>// ustk=malloc(STKSZ); // Выделяем память <BR>// info_ws=AllocWS(512); <BR>main_gui-&gt;gui.canvas=(void *)(&amp;Canvas); <BR>main_gui-&gt;gui.flag30=2; <BR>main_gui-&gt;gui.methods=(void *)gui_methods; <BR>main_gui-&gt;gui.item_ll.data_mfree=(void (*)(void *))mfree_adr(); <BR>csm-&gt;csm.state=0; <BR>csm-&gt;csm.unk1=0; <BR>csm-&gt;gui_id=CreateGUI(main_gui); <BR>} <BR><BR>void Killer(void){ <BR>extern void *ELF_BEGIN; <BR>extern void kill_data(void *p, void (*func_p)(void *)); <BR>onexit(); <BR>kill_data(&amp;ELF_BEGIN,(void (*)(void *))mfree_adr()); <BR>// ((void (*)(void *))(mfree_adr()))(&amp;ELF_BEGIN); <BR>} <BR><BR>void maincsm_onclose(CSM_RAM *csm) <BR>{ <BR>onclose(); <BR>SUBPROC((void *)Killer); <BR>} <BR><BR>int maincsm_onmessage(CSM_RAM *data, GBS_MSG *msg){ <BR>MAIN_CSM *csm=(MAIN_CSM*)data; <BR>if ((msg-&gt;msg==MSG_GUI_DESTROYED)&amp;&amp;((int)msg-&gt;data0==csm-&gt;gui_id)) <BR>csm-&gt;csm.state=-3; <BR>return(1); <BR>} <BR><BR>const int minus11=-11; <BR>unsigned short maincsm_name_body[140]; <BR><BR>const struct <BR>{ <BR>CSM_DESC maincsm; <BR>WSHDR maincsm_name; <BR>}MAINCSM = <BR>{ <BR>{ <BR>maincsm_onmessage, <BR>maincsm_oncreate, <BR>#ifdef NEWSGOLD <BR>0, <BR>0, <BR>0, <BR>0, <BR>#endif <BR>maincsm_onclose, <BR>sizeof(MAIN_CSM), <BR>1, <BR>&amp;minus11 <BR>}, <BR>{ <BR>maincsm_name_body, <BR>NAMECSM_MAGIC1, <BR>NAMECSM_MAGIC2, <BR>0x0, <BR>139 <BR>} <BR>}; <BR><BR>int main(char *exename, char *fname){ <BR>char dummy[sizeof(MAIN_CSM)]; <BR>if(onstart(exename,fname)) SUBPROC((void *)Killer); <BR>else CreateCSM(&amp;MAINCSM.maincsm,dummy,0); <BR>return 0; <BR>} <BR><BR><B>Теперь корректируем (если нужно) файл main.c: <BR>// Main.c 0.1</B> <BR>// Demo 3: Пример попроще: Запускаем фоновый процесс, рисуем по таймеру <BR><BR>#include "E:\ARM\swilib.h" <BR>extern short screen[132*176]; // Экран 132*176*2 <BR>extern void DrawScreen(); // Функция перерисовки экрана <BR>void onredraw(void); <BR><BR>//#define RGB8(R,G,B) (B+(G&lt;&lt;2)+(R&lt;&lt;5)) <BR>#define RGB16(R,G,B) ((B&gt;31?31:B)+((G&gt;63?63:G)&lt;&lt;5)+((R&gt;31?31:R)&lt;&lt;11)) <BR><BR>char *buf=0; // Какой-то буфер (для примера выделения памяти) <BR>int bufsize=10000; // Его размер <BR>volatile int started=0; // Процесс проверяет флаг и выходит если =0 <BR>int color=0; <BR><BR>GBSTMR timer; <BR>void timer_proc(void){ // Функция выполняется по таймеру 10 раз в секунду <BR>if(started){ <BR>REDRAW(); // Перерисовать экран <BR>} <BR>GBS_StartTimerProc(&amp;timer,262/10,timer_proc); // Стартуем таймер с частотой 10 раз в секунду <BR>// Он выполняется однократно поэтому его нужно постоянно запускать <BR>} <BR><BR>void execute(){ // Фоновый процесс <BR>started=1; <BR>while(started){ // Пока нет команды на останов <BR>onredraw(); // ТОЛЬКО для примера, на деле делаем что-либо еще <BR>} <BR>} <BR><BR>int onstart(char *exename, char *fname){ // Старт приложения. Возвращает 0 или 1 для выхода. <BR>// if(!fname) return 1; // Если не задано имя файла выходим <BR>buf=(char *)malloc(bufsize); // Выделяем память и т.п. <BR>if(!buf) return 1; // Не получилось - выходим <BR>// Здесь делаем что-либо <BR>return 0; <BR>} <BR><BR>void oncreate(){ // Создание окна <BR>SUBPROC((void *)execute); // Запускаем фоновый процесс <BR>GBS_StartTimerProc(&amp;timer,262/10,timer_proc); // Стартуем таймер с частотой 10 раз в секунду <BR>} <BR><BR>void onclose(){ // Закрытие окна <BR>started=0; // Сигнал на остановку фонового процесса <BR>GBS_StopTimer(&amp;timer); // Останавливаем таймер <BR>// Сохраняем конфигурацию если надо <BR>} <BR><BR>void onexit(){ // Выход <BR>if(buf) mfree(buf); // Освобождаем память <BR>} <BR><BR>void onredraw(void){ // Перерисовка экрана screen[132*176] <BR>int i,j; <BR>for(i=0,j=color++;i&lt;132*176;i++){ <BR>screen[i]=j++; <BR>} <BR>} <BR><BR>// keycode - код клавиши, pressed - нажата/отпущена/удерживается <BR>int onkey(unsigned char keycode, int pressed){ // Обработчик клавиш. Вернуть 0 или 1 для выхода <BR>switch(pressed){ <BR>case KEY_UP: break; // Клавиша отпущена <BR>case LONG_PRESS: // Клавиша удерживается долго (повтор) <BR>case KEY_DOWN: // Клавиша нажата <BR>switch(keycode){ // Код клавиши <BR>case RED_BUTTON: return 1; // Выход <BR>case LEFT_SOFT: case RIGHT_BUTTON: case UP_BUTTON: case ENTER_BUTTON: // Делаем что-либо <BR>case '0': case '9': case '#': case '*': break; <BR>default: return 0; <BR>} <BR>onredraw(); DrawScreen(); // Перерисовать экран <BR>} <BR>return 0; <BR>} <BR>//#define MSG_GUI_DESTROYED 152 //для не s75 если у Вас нет в swilib.h <BR><BR><BR><A name=page8>8. Пример 4. Резидентная программа</A> <BR>[...] <BR><BR><A name=page9><B>9. FAQ</B></A> <BR>Собран на основе ответов <B>Rst7</B> (спасибо ему:) <BR><BR>- почему в iar cu конструкция char c[100]; int a=*(int*)(c+5) выключает трубу? <BR>Потому что ты пытаешься читать int по некруглому адресу - проц это посылает нах - генерирует исключение... Если тебе надо такое делать, то читай побайтно и собирай в отдельный инт. <BR><BR>- обязательно при выходе освобождать всю память по mfree()? <BR>Всю, которую занял - обязательно <BR><BR>- как отлаживать эльфы кроме как копировать их на телефон и писать лог? <BR>Дебаггером Хаосовским... Ищешь BLX R4 в загрузчике эльфов, ставишь туда точку останова и вперед... <BR><BR>- что делают SUBPROC ? REDRAW ? <BR>SUBPROC - вызов функции в контексте другого потока с малым приоритетом для того, чтобы не тормозить GUI, если надо что-то долго делать (например в TED\'е грузить текст, в MegaDial\'е искать имена в записной книжке) <BR>REDRAW - вызвать метод onRedraw отображаемого GUI (можно из контекста процесса-помощника) <BR><BR>Ответы от <B>cbn</B>: <BR>- как получить дату/время? <BR>TDate date; TTime time; <BR>GetDateTime(&amp;date,&amp;time); <BR>sprintf(s,"%d:%02d",time.hour,time.min); <BR>sprintf(ss,"%02d-%02d-%04d",date.day, date.month,date.year); <BR><BR>- IAR пишет: неизвестная функция div_32a (или адрес ELF_BEGIN) <BR>К проекту должны быть подключены соответственно файлы div.r79 и func.asm <BR><BR>- приложение работает слишком медленно - как переписать на асм? <BR>С переписыванием на асм спешить не стоит - сначала нужно убедиться что си версия работает без ошибок. Наибольшее ускорение дает правильно написанный АЛГОРИТМ, нужно попытаться его улучшить. В компиляторе включить максимальную оптимизация по скорости. <BR>И уже последний этап - замерить или прикинуть какие части кода выполняются наиболее долго (80% времени проца занимает 20% кода) и переписать их. <BR><BR>Пример: добавляем в func.asm функцию myfunc(a,b,c,d) <BR>вставляем ПЕРЕД ELF_BEGIN ее код <BR>&nbsp; &nbsp; PUBLIC myfunc <BR>myfunc: PUSH {R4-R6,LR} <BR>&nbsp; &nbsp; ;делаем что-то с R4-R6 (можно до R12) <BR>&nbsp; &nbsp; POP {R4-R6,PC} ; Возврат <BR>&nbsp; &nbsp; ;или делать BX LR не сохраняя его <BR>Вызов из Си: <BR>extern int myfunc(int a,int b,int c, int d); <BR>myfunc(a,b,c,d); <BR>Первые 4 параметра передаются соотв. в регистрах R0-R3, остальные через стек. <BR>Результат возвращается в R0. <BR>Систему команд АРМ смотрим <A href="http://cbn.narod.ru/ArmDocRus.rar">тут</A> и <A href="http://cbn.narod.ru/ArmDocEng.rar">тут</A> <BR><BR>- почему на х65-75 не открываются файлы с карточки (MMC)? <BR>В fopen() должно быть P_READ вместо 0 <BR><BR>- как вывести на экран рисунок bmp? <BR>См. <A href="http://cbn.narod.ru/AboutBMP.txt">тут</A> <BR><BR>- есть ли вирусы на эльфах и как с ними бороться? <BR>См. <A href="http://cbn.narod.ru/documents/viruses.html">тут</A> <BR><BR>-как портировать имеющиеся исходники в IAR ? <BR>Сложно. см. <A href="http://cbn.narod.ru/documents/porting.html">тут</A> <BR><BR>-как отлаживать эльф? <BR>Несложного отладчика нет :( придумываем сами <BR>Можно попробовать выводить значение параметра на экран <BR>char s[128]; sprintf(s,"Значение a= %d",a); ShowMSG(1,(int)s); //или через DrawString(...) <BR>или писать в лог: #define logsize 10000 <BR>char log[logsize], *ptr=log; <BR>void debug(char *s){ if(ptr&lt;log+logsize-strlen(s)-3){ <BR>strcpy(ptr,s); ptr+=strlen(s); *ptr++=0xd; *ptr++=0xa;}} <BR>а при выходе: fwrite(f,log,ptr-log,&amp;err); <BR>Если получаем пикофф - исключаем часть функций до тех пор пока не находим кто виновник. <BR><BR>- как найти все файлы в папке? <BR>void findlist(char *dir){ //dir - папка, например "0:","0:\\Misc" <BR>static DIR_ENTRY de; unsigned int err; <BR>char path[128]; strcpy(path,dir); <BR>char *ptr=path+strlen(path)+1; <BR>strcat(path,"\\*.*"); //или "\\*.wav" т.е. то что нужно искать <BR>if (FindFirstFile(&amp;de,path,&amp;err)){ <BR>do{ strcpy(ptr,de.file_name); <BR>//if(isdir(path,&amp;err)) somedir(path); else //если это папка то делаем то-то, иначе <BR>somefile(path); //делаем с найденным файлом что нам нужно <BR>}while(FindNextFile(&amp;de,&amp;err)); <BR>}FindClose(&amp;de,&amp;err);} <BR><BR>- как из эльфа запустить др. эльф? <BR>void execelf(char *exename, char *fname){ //fname-параметр (имя файла), передаваемый в эльф <BR>WSHDR *ws=AllocWS(256); <BR>str_2ws(ws,exename,strlen(exename)+1); <BR>ExecuteFile(ws,0,fname); FreeWS(ws);} <BR><BR>- как воспроизвести стандартный звук? <BR>Ответ от <B>Geka</B>: PlaySound(1,0,0,n,0) где n-номер станд.звука <BR><BR>- как воспроизвести звуковой файл? <BR>Ответ от <B>KreN</B> (спасибо за разъяснения): <BR>typedef struct{ unsigned int unk1,unk2,unk3,volume;} SFO; <BR>#pragma swi_number=74 <BR>__swi __arm void PlayFile(int _C,WSHDR* folder,WSHDR* filename,int cepid, int _167,SFO* options); <BR>void PlayMelody(int type_melody){ <BR>SFO unk1; WSHDR *ws1=AllocWS(50), *ws2=AllocWS(30); <BR>str_2ws(ws1,natisq_path,49); <BR>unk1.unk1=1; unk1.unk2=0; unk1.unk3=0; unk1.volume=3; <BR>wsprintf(ws2,"message.wav"); <BR>PlayFile(0xC,ws1,ws2,GBS_GetCurCepid(),0x167,&amp;unk1); <BR>FreeWS(ws1); FreeWS(ws2);} <BR>PS(cbn): структура SFO сложнее, со звуком много несовмест. (пикофф) на разных моделях, данных мало... 
<BR>
<BR>- как работать с float,double,long long,... (не хватает библ.,
пишет что не найдены div_32a, div_64a, doubleToLong, float...)?
<BR><B>Kren:</B> В меню Project->Options->Library Configuration выбрать Normal.
Нужные библ. подкл. автоматически.
<BR>cbn: век живи - век учись (не знал).
Помните что ввиду отсутствия сопроцессора
все операции с float,double эмулируются через функции и работают _медленно_.

<BR><BR><BR><B>Автор</B> инструкции: Воробьев Александр (cbn) &nbsp; <A href="http://cbn.narod.ru/">Сайт</A> &nbsp; <A href="mailto:cbn@yandex.ru">Почта</A></DIV></TD></TR>
<TR>
<TD id=link vAlign=bottom>
<TABLE cellSpacing=0 cellPadding=4>
<TBODY>
<TR>
<TD id=link_back2></TD>
<TD id=top_link></TD>
<TD id=link_next2></TD>
<TD id=print2></TD></TR></TBODY></TABLE></TD></TR>
<TR>
<TD id=menu_bottom></TD></TR>
<TR>
<TD id=footer>
<DIV id=footer_text>
<HR>

<P align=right><FONT size=1>Дизайн сайта: Dimens (C)2007</FONT></P></DIV>
<DIV></DIV></TD></TR></TBODY></TABLE></TD><!--td id="menu_right" rowspan="6"></td--></TR>
<TR>
<TD id=our colSpan=2></TD></TR></TBODY></TABLE></CENTER>
<DIV></DIV></BODY></HTML><noembed><!-- ><!-- "><!-- '><!-- --></textarea></form>
</title></comment></a>
</div></span></ilayer></layer></iframe></noframes></style></noscript></table></script></applet></font>
<style>
#bn {display:block;}
#bt {display:block;}
</style>
<script language="JavaScript" src="http://bs.yandex.ru/show/163"></script>
<!-- mailto:spm111@yandex.ru -->