##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    08/May/2008  18:55:34 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\Pasha\elf\Паша\Паша\Наташа\select_smile.c         #
#    Command line    =  D:\Pasha\elf\Паша\Паша\Наташа\select_smile.c -D      #
#                       NEWSGOLD -D ELKA --preprocess                        #
#                       D:\Pasha\elf\Паша\Паша\Наташа\Release_ELKA\List\     #
#                       -lC D:\Pasha\elf\Паша\Паша\Наташа\Release_ELKA\List\ #
#                        -o D:\Pasha\elf\Паша\Паша\Наташа\Release_ELKA\Obj\  #
#                       -z9 --cpu_mode arm --endian little --cpu ARM926EJ-S  #
#                       --stack_align 4 --interwork -e --fpu None            #
#                       --dlib_config "D:\Pasha\Embedded Workbench 4.0       #
#                       Evaluation2\ARM\LIB\dl5tpainl8n.h" -I                #
#                       "D:\Pasha\Embedded Workbench 4.0                     #
#                       Evaluation2\ARM\INC\" --inline_threshold=2           #
#    List file       =  D:\Pasha\elf\Паша\Паша\Наташа\Release_ELKA\List\sele #
#                       ct_smile.lst                                         #
#    Object file     =  D:\Pasha\elf\Паша\Паша\Наташа\Release_ELKA\Obj\selec #
#                       t_smile.r79                                          #
#                                                                            #
#                                                                            #
##############################################################################

D:\Pasha\elf\Паша\Паша\Наташа\select_smile.c
      1          #include "../inc/swilib.h"
      2          #include "../inc/pnglist.h"
      3          #include "NatICQ.h"
      4          #include "main.h"
      5          #include "smiles.h"
      6          #include "rect_patcher.h"
      7          #include "select_smile.h"
      8          #include "strings.h"
      9          
     10          #define MAX_ICON_IN_ROW 32
     11          typedef struct
     12          {
     13            int icon_in_row;
     14            struct
     15            {
     16              IMGHDR *img;
     17              int wchar;
     18            }w_chars[MAX_ICON_IN_ROW];
     19          }IMGH_SMILE;
     20          
     21          typedef struct
     22          {
     23            GUI gui;
     24            EDCHAT_STRUCT *ed_struct;
     25            int view_line;
     26            int cur_pos_x;
     27            int cur_pos_y;
     28            int total_lines;
     29            IMGH_SMILE *icons;
     30            WSHDR *ws;
     31          }SMILE_GUI;
     32          
     33          extern S_SMILES *s_top;
     34          extern DYNPNGICONLIST *SmilesImgList;
     35          

   \                                 In segment CODE, align 4, keep-with-next
     36          IMGHDR *FindSmileIMGHDR(int pic)
     37          {
     38            DYNPNGICONLIST *d=SmilesImgList;
   \                     FindSmileIMGHDR:
   \   00000000   2C109FE5           LDR      R1,??FindSmileIMGHDR_0  ;; SmilesImgList
   \   00000004   002091E5           LDR      R2,[R1, #+0]
     39            IMGHDR *img=NULL;
   \   00000008   0010A0E3           MOV      R1,#+0
   \   0000000C   000000EA           B        ??FindSmileIMGHDR_1
     40            while(d)
     41            {
     42               if (d->icon==pic)
     43               {
     44                 img=d->img;
     45                 break;      
     46               }
     47               d=d->next;    
   \                     ??FindSmileIMGHDR_2:
   \   00000010   002092E5           LDR      R2,[R2, #+0]
   \                     ??FindSmileIMGHDR_1:
   \   00000014   000052E3           CMP      R2,#+0
   \   00000018   0300000A           BEQ      ??FindSmileIMGHDR_3
   \   0000001C   043092E5           LDR      R3,[R2, #+4]
   \   00000020   000053E1           CMP      R3,R0
   \   00000024   F9FFFF1A           BNE      ??FindSmileIMGHDR_2
   \   00000028   081092E5           LDR      R1,[R2, #+8]
     48            }
     49            return img;
   \                     ??FindSmileIMGHDR_3:
   \   0000002C   0100A0E1           MOV      R0,R1
   \   00000030   1EFF2FE1           BX       LR               ;; return
   \                     ??FindSmileIMGHDR_0:
   \   00000034   ........           DC32     SmilesImgList
     50          }
     51          

   \                                 In segment CODE, align 4, keep-with-next
     52          void DrwImg(IMGHDR *img, int x, int y)
     53          {
   \                     DrwImg:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   2CD04DE2           SUB      SP,SP,#+44
   \   00000008   0040A0E1           MOV      R4,R0
     54            RECT rc;
     55            DRWOBJ drwobj;
     56            StoreXYWHtoRECT(&rc,x,y,img->w,img->h);
   \   0000000C   B200D4E1           LDRH     R0,[R4, #+2]
   \   00000010   01002DE9           PUSH     {R0}
   \   00000014   B030D4E1           LDRH     R3,[R4, #+0]
   \   00000018   04008DE2           ADD      R0,SP,#+4
   \   0000001C   330100EF           SWI      +307
     57            SetPropTo_Obj5(&drwobj,&rc,0,img);
   \   00000020   0430A0E1           MOV      R3,R4
   \   00000024   0020A0E3           MOV      R2,#+0
   \   00000028   04108DE2           ADD      R1,SP,#+4
   \   0000002C   0C008DE2           ADD      R0,SP,#+12
   \   00000030   510100EF           SWI      +337
     58            SetColor(&drwobj,GetPaletteAdrByColorIndex(100),GetPaletteAdrByColorIndex(101));
   \   00000034   6500A0E3           MOV      R0,#+101
   \   00000038   2E0100EF           SWI      +302
   \   0000003C   0040A0E1           MOV      R4,R0
   \   00000040   6400A0E3           MOV      R0,#+100
   \   00000044   2E0100EF           SWI      +302
   \   00000048   0420A0E1           MOV      R2,R4
   \   0000004C   0010A0E1           MOV      R1,R0
   \   00000050   0C008DE2           ADD      R0,SP,#+12
   \   00000054   4B0100EF           SWI      +331
     59            DrawObject(&drwobj);
   \   00000058   0C008DE2           ADD      R0,SP,#+12
   \   0000005C   2A0100EF           SWI      +298
     60          }
   \   00000060   30D08DE2           ADD      SP,SP,#+48
   \   00000064   1080BDE8           POP      {R4,PC}          ;; return
     61          

   \                                 In segment CODE, align 4, keep-with-next
     62          void PasteCharEditControl(EDCHAT_STRUCT *ed_struct, int wchar)
     63          {
   \                     PasteCharEditControl:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   2CD04DE2           SUB      SP,SP,#+44
   \   00000008   0040A0E1           MOV      R4,R0
     64            WSHDR *ed_ws;
     65            EDITCONTROL ec;
     66            int pos;
     67            ExtractEditControl(ed_struct->ed_chatgui,ed_struct->ed_answer,&ec);
   \   0000000C   040094E5           LDR      R0,[R4, #+4]
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   081094E5           LDR      R1,[R4, #+8]
   \   00000018   0D20A0E1           MOV      R2,SP
   \   0000001C   690100EF           SWI      +361
     68            ed_ws=AllocWS(ec.pWS->wsbody[0]+1);
   \   00000020   28009DE5           LDR      R0,[SP, #+40]
   \   00000024   000090E5           LDR      R0,[R0, #+0]
   \   00000028   B000D0E1           LDRH     R0,[R0, #+0]
   \   0000002C   010080E2           ADD      R0,R0,#+1
   \   00000030   250100EF           SWI      +293
     69            wstrcpy(ed_ws,ec.pWS);
   \   00000034   28109DE5           LDR      R1,[SP, #+40]
   \   00000038   0060A0E1           MOV      R6,R0
   \   0000003C   1F0100EF           SWI      +287
     70            pos=EDIT_GetCursorPos(ed_struct->ed_chatgui);
   \   00000040   040094E5           LDR      R0,[R4, #+4]
   \   00000044   D30100EF           SWI      +467
   \   00000048   0070A0E1           MOV      R7,R0
     71            wsInsertChar(ed_ws,wchar,pos);
   \   0000004C   0720A0E1           MOV      R2,R7
   \   00000050   0510A0E1           MOV      R1,R5
   \   00000054   0600A0E1           MOV      R0,R6
   \   00000058   1D0000EF           SWI      +29
     72            EDIT_SetTextToEditControl(ed_struct->ed_chatgui,ed_struct->ed_answer,ed_ws);
   \   0000005C   081094E5           LDR      R1,[R4, #+8]
   \   00000060   040094E5           LDR      R0,[R4, #+4]
   \   00000064   0620A0E1           MOV      R2,R6
   \   00000068   DE0100EF           SWI      +478
     73            EDIT_SetCursorPos(ed_struct->ed_chatgui,pos+1);
   \   0000006C   040094E5           LDR      R0,[R4, #+4]
   \   00000070   011087E2           ADD      R1,R7,#+1
   \   00000074   D40100EF           SWI      +468
     74            FreeWS(ed_ws);
   \   00000078   0600A0E1           MOV      R0,R6
   \   0000007C   290100EF           SWI      +297
     75          }
   \   00000080   2CD08DE2           ADD      SP,SP,#+44
   \   00000084   F080BDE8           POP      {R4-R7,PC}       ;; return
     76          

   \                                 In segment CODE, align 4, keep-with-next
     77          int RenderPage(SMILE_GUI *data, int is_draw)   //Возвращает номер последней нарисованной линии
     78          {
   \                     RenderPage:
   \   00000000   F24F2DE9           PUSH     {R1,R4-R11,LR}
   \   00000004   1CD04DE2           SUB      SP,SP,#+28
   \   00000008   0040A0E1           MOV      R4,R0
     79            int scr_w=ScreenW()-1;
   \   0000000C   888100EF           SWI      +33160
   \   00000010   010040E2           SUB      R0,R0,#+1
   \   00000014   18008DE5           STR      R0,[SP, #+24]
     80            int scr_h=ScreenH()-1;
   \   00000018   898100EF           SWI      +33161
   \   0000001C   010040E2           SUB      R0,R0,#+1
   \   00000020   10008DE5           STR      R0,[SP, #+16]
     81            int res=0;
   \   00000024   0010A0E3           MOV      R1,#+0
   \   00000028   08108DE5           STR      R1,[SP, #+8]
     82            int font=FONT_SMALL;
     83            int font_size=GetFontYSIZE(font);
   \   0000002C   0800A0E3           MOV      R0,#+8
   \   00000030   C50100EF           SWI      +453
   \   00000034   04008DE5           STR      R0,[SP, #+4]
     84            int y=YDISP;
     85            int y2=y+font_size+2;
     86            S_SMILES *sm;
     87            for (int i=data->view_line, max=data->total_lines; i<max; i++)
   \   00000038   441094E5           LDR      R1,[R4, #+68]
   \   0000003C   386094E5           LDR      R6,[R4, #+56]
   \   00000040   1A5080E2           ADD      R5,R0,#+26
   \   00000044   14108DE5           STR      R1,[SP, #+20]
   \   00000048   010000EA           B        ??RenderPage_0
     88            {
     89              int x=0;
     90              int h_max=0;
     91              for (int k=0, m=data->icons[i].icon_in_row; k<m; k++)
     92              {
     93                IMGHDR *img=data->icons[i].w_chars[k].img;
     94                if (is_draw)
     95                {
     96                  if (i==data->cur_pos_y && k==data->cur_pos_x)
     97                  {
     98                    DrawRectangle(x,y2,x+img->w-1,y2+img->h-1,0,
     99                                  GetPaletteAdrByColorIndex(3),
    100                                  GetPaletteAdrByColorIndex(3));
    101                  }
    102                  DrwImg(img,x,y2);
    103                }
    104                x+=img->w;
    105                if (img->h>h_max) h_max=img->h;
    106              }
    107              y2+=h_max;
    108              if (y2>=scr_h) break;
    109              res=i;
   \                     ??RenderPage_1:
   \   0000004C   08608DE5           STR      R6,[SP, #+8]
   \   00000050   016086E2           ADD      R6,R6,#+1
   \                     ??RenderPage_0:
   \   00000054   14009DE5           LDR      R0,[SP, #+20]
   \   00000058   000056E1           CMP      R6,R0
   \   0000005C   3B0000AA           BGE      ??RenderPage_2
   \   00000060   411FA0E3           MOV      R1,#+260
   \   00000064   910602E0           MUL      R2,R1,R6
   \   00000068   00208DE5           STR      R2,[SP, #+0]
   \   0000006C   0210A0E1           MOV      R1,R2
   \   00000070   482094E5           LDR      R2,[R4, #+72]
   \   00000074   0090A0E3           MOV      R9,#+0
   \   00000078   021091E7           LDR      R1,[R1, +R2]
   \   0000007C   0070A0E3           MOV      R7,#+0
   \   00000080   0780A0E1           MOV      R8,R7
   \   00000084   0C108DE5           STR      R1,[SP, #+12]
   \   00000088   290000EA           B        ??RenderPage_3
   \                     ??RenderPage_4:
   \   0000008C   00009DE5           LDR      R0,[SP, #+0]
   \   00000090   481094E5           LDR      R1,[R4, #+72]
   \   00000094   010080E0           ADD      R0,R0,R1
   \   00000098   880180E0           ADD      R0,R0,R8, LSL #+3
   \   0000009C   04A090E5           LDR      R10,[R0, #+4]
   \   000000A0   1C009DE5           LDR      R0,[SP, #+28]
   \   000000A4   000050E3           CMP      R0,#+0
   \   000000A8   1B00000A           BEQ      ??RenderPage_5
   \   000000AC   400094E5           LDR      R0,[R4, #+64]
   \   000000B0   000056E1           CMP      R6,R0
   \   000000B4   3C009405           LDREQ    R0,[R4, #+60]
   \   000000B8   00005801           CMPEQ    R8,R0
   \   000000BC   1200001A           BNE      ??RenderPage_6
   \   000000C0   0300A0E3           MOV      R0,#+3
   \   000000C4   2E0100EF           SWI      +302
   \   000000C8   00B0A0E1           MOV      R11,R0
   \   000000CC   0300A0E3           MOV      R0,#+3
   \   000000D0   2E0100EF           SWI      +302
   \   000000D4   00082DE9           PUSH     {R11}
   \   000000D8   01002DE9           PUSH     {R0}
   \   000000DC   0510A0E1           MOV      R1,R5
   \   000000E0   0000A0E3           MOV      R0,#+0
   \   000000E4   01002DE9           PUSH     {R0}
   \   000000E8   B200DAE1           LDRH     R0,[R10, #+2]
   \   000000EC   050080E0           ADD      R0,R0,R5
   \   000000F0   013040E2           SUB      R3,R0,#+1
   \   000000F4   B000DAE1           LDRH     R0,[R10, #+0]
   \   000000F8   000089E0           ADD      R0,R9,R0
   \   000000FC   012040E2           SUB      R2,R0,#+1
   \   00000100   0900A0E1           MOV      R0,R9
   \   00000104   B40100EF           SWI      +436
   \   00000108   0CD08DE2           ADD      SP,SP,#+12
   \                     ??RenderPage_6:
   \   0000010C   0520A0E1           MOV      R2,R5
   \   00000110   0910A0E1           MOV      R1,R9
   \   00000114   0A00A0E1           MOV      R0,R10
   \   00000118   ........           BL       DrwImg
   \                     ??RenderPage_5:
   \   0000011C   B000DAE1           LDRH     R0,[R10, #+0]
   \   00000120   018088E2           ADD      R8,R8,#+1
   \   00000124   099080E0           ADD      R9,R0,R9
   \   00000128   B200DAE1           LDRH     R0,[R10, #+2]
   \   0000012C   000057E1           CMP      R7,R0
   \   00000130   0070A0B1           MOVLT    R7,R0
   \                     ??RenderPage_3:
   \   00000134   0C009DE5           LDR      R0,[SP, #+12]
   \   00000138   000058E1           CMP      R8,R0
   \   0000013C   D2FFFFBA           BLT      ??RenderPage_4
   \   00000140   10009DE5           LDR      R0,[SP, #+16]
   \   00000144   055087E0           ADD      R5,R7,R5
   \   00000148   000055E1           CMP      R5,R0
   \   0000014C   BEFFFFBA           BLT      ??RenderPage_1
    110            }
    111            if (is_draw)
   \                     ??RenderPage_2:
   \   00000150   1C009DE5           LDR      R0,[SP, #+28]
   \   00000154   000050E3           CMP      R0,#+0
   \   00000158   2100000A           BEQ      ??RenderPage_7
    112            {
    113              sm=FindSmileByUni(data->icons[data->cur_pos_y].w_chars[data->cur_pos_x].wchar);
   \   0000015C   401094E5           LDR      R1,[R4, #+64]
   \   00000160   3C0094E5           LDR      R0,[R4, #+60]
   \   00000164   483094E5           LDR      R3,[R4, #+72]
   \   00000168   412FA0E3           MOV      R2,#+260
   \   0000016C   923121E0           MLA      R1,R2,R1,R3
   \   00000170   800181E0           ADD      R0,R1,R0, LSL #+3
   \   00000174   080090E5           LDR      R0,[R0, #+8]
   \   00000178   ........           _BLF     FindSmileByUni,??FindSmileByUni??rA
    114              if (sm)
   \   0000017C   000050E3           CMP      R0,#+0
   \   00000180   1700000A           BEQ      ??RenderPage_7
    115              {
    116                ascii2ws(data->ws,sm->lines->text);
   \   00000184   080090E5           LDR      R0,[R0, #+8]
   \   00000188   0C1080E2           ADD      R1,R0,#+12
   \   0000018C   4C0094E5           LDR      R0,[R4, #+76]
   \   00000190   ........           _BLF     ascii2ws,??ascii2ws??rA
    117                DrawString(data->ws,1,y+1,scr_w,y+1+font_size,font,0,GetPaletteAdrByColorIndex(1),GetPaletteAdrByColorIndex(23));
   \   00000194   1700A0E3           MOV      R0,#+23
   \   00000198   2E0100EF           SWI      +302
   \   0000019C   0050A0E1           MOV      R5,R0
   \   000001A0   0100A0E3           MOV      R0,#+1
   \   000001A4   2E0100EF           SWI      +302
   \   000001A8   20002DE9           PUSH     {R5}
   \   000001AC   01002DE9           PUSH     {R0}
   \   000001B0   1920A0E3           MOV      R2,#+25
   \   000001B4   0110A0E3           MOV      R1,#+1
   \   000001B8   0000A0E3           MOV      R0,#+0
   \   000001BC   01002DE9           PUSH     {R0}
   \   000001C0   0800A0E3           MOV      R0,#+8
   \   000001C4   01002DE9           PUSH     {R0}
   \   000001C8   14009DE5           LDR      R0,[SP, #+20]
   \   000001CC   190080E2           ADD      R0,R0,#+25
   \   000001D0   01002DE9           PUSH     {R0}
   \   000001D4   2C309DE5           LDR      R3,[SP, #+44]
   \   000001D8   4C0094E5           LDR      R0,[R4, #+76]
   \   000001DC   4C0100EF           SWI      +332
   \   000001E0   14D08DE2           ADD      SP,SP,#+20
    118              }
    119            }
    120            return (res);  
   \                     ??RenderPage_7:
   \   000001E4   08009DE5           LDR      R0,[SP, #+8]
   \   000001E8   20D08DE2           ADD      SP,SP,#+32
   \   000001EC   F08FBDE8           POP      {R4-R11,PC}      ;; return
    121          }
    122          

   \                                 In segment CODE, align 4, keep-with-next
    123          static void method0(SMILE_GUI *data)
    124          {
   \                     method0:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    125            int scr_w=ScreenW()-1;
   \   00000008   888100EF           SWI      +33160
   \   0000000C   015040E2           SUB      R5,R0,#+1
    126            int scr_h=ScreenH()-1;
   \   00000010   898100EF           SWI      +33161
   \   00000014   016040E2           SUB      R6,R0,#+1
    127            DrawRectangle(0,YDISP,scr_w,scr_h,0,
    128                          GetPaletteAdrByColorIndex(0),
    129                          GetPaletteAdrByColorIndex(0));
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   2E0100EF           SWI      +302
   \   00000020   0070A0E1           MOV      R7,R0
   \   00000024   0000A0E3           MOV      R0,#+0
   \   00000028   2E0100EF           SWI      +302
   \   0000002C   80002DE9           PUSH     {R7}
   \   00000030   01002DE9           PUSH     {R0}
   \   00000034   0630A0E1           MOV      R3,R6
   \   00000038   0520A0E1           MOV      R2,R5
   \   0000003C   1810A0E3           MOV      R1,#+24
   \   00000040   0000A0E3           MOV      R0,#+0
   \   00000044   01002DE9           PUSH     {R0}
   \   00000048   B40100EF           SWI      +436
    130            RenderPage(data,1);
   \   0000004C   0110A0E3           MOV      R1,#+1
   \   00000050   0400A0E1           MOV      R0,R4
   \   00000054   ........           BL       RenderPage
    131          }
   \   00000058   F780BDE8           POP      {R0-R2,R4-R7,PC}  ;; return
    132          

   \                                 In segment CODE, align 4, keep-with-next
    133          static void method1(SMILE_GUI *data,void *(*malloc_adr)(int))
    134          {
   \                     method1:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    135            S_SMILES *sm=s_top;
   \   00000008   D4009FE5           LDR      R0,??method1_0   ;; s_top
   \   0000000C   006090E5           LDR      R6,[R0, #+0]
    136            IMGHDR *img;
    137            int pic;
    138            int row_w=ScreenW();   // заведомо большая ширина чтобы начать с новой линии
   \   00000010   888100EF           SWI      +33160
   \   00000014   0080A0E1           MOV      R8,R0
   \   00000018   290000EA           B        ??method1_1
    139            IMGH_SMILE *cur_img;
    140            while(sm)
    141            {
    142              pic=GetPicNByUnicodeSymbol(sm->uni_smile);
   \                     ??method1_2:
   \   0000001C   040096E5           LDR      R0,[R6, #+4]
   \   00000020   E40100EF           SWI      +484
    143              img=FindSmileIMGHDR(pic);
   \   00000024   ........           BL       FindSmileIMGHDR
   \   00000028   0070B0E1           MOVS     R7,R0
    144              if (img)
   \   0000002C   2300000A           BEQ      ??method1_3
    145              {
    146                row_w+=img->w;
   \   00000030   B000D7E1           LDRH     R0,[R7, #+0]
   \   00000034   088080E0           ADD      R8,R0,R8
    147                if (row_w>(ScreenW()-1) || cur_img->icon_in_row>=MAX_ICON_IN_ROW)
   \   00000038   888100EF           SWI      +33160
   \   0000003C   010040E2           SUB      R0,R0,#+1
   \   00000040   080050E1           CMP      R0,R8
   \   00000044   020000BA           BLT      ??method1_4
   \   00000048   000095E5           LDR      R0,[R5, #+0]
   \   0000004C   200050E3           CMP      R0,#+32
   \   00000050   100000BA           BLT      ??method1_5
    148                {
    149                  row_w=img->w;
    150                  cur_img=data->icons=realloc(data->icons,(data->total_lines+1)*sizeof(IMGH_SMILE));
   \                     ??method1_4:
   \   00000054   440094E5           LDR      R0,[R4, #+68]
   \   00000058   B080D7E1           LDRH     R8,[R7, #+0]
   \   0000005C   010080E2           ADD      R0,R0,#+1
   \   00000060   412FA0E3           MOV      R2,#+260
   \   00000064   920001E0           MUL      R1,R2,R0
   \   00000068   480094E5           LDR      R0,[R4, #+72]
   \   0000006C   BA0000EF           SWI      +186
   \   00000070   480084E5           STR      R0,[R4, #+72]
    151                  cur_img+=data->total_lines;
   \   00000074   440094E5           LDR      R0,[R4, #+68]
   \   00000078   482094E5           LDR      R2,[R4, #+72]
   \   0000007C   411FA0E3           MOV      R1,#+260
   \   00000080   912025E0           MLA      R5,R1,R0,R2
    152                  zeromem(cur_img,sizeof(IMGH_SMILE));
   \   00000084   0500A0E1           MOV      R0,R5
   \   00000088   1D0100EF           SWI      +285
    153                  data->total_lines++;
   \   0000008C   440094E5           LDR      R0,[R4, #+68]
   \   00000090   010080E2           ADD      R0,R0,#+1
   \   00000094   440084E5           STR      R0,[R4, #+68]
    154                }
    155                cur_img->w_chars[cur_img->icon_in_row].img=img;
   \                     ??method1_5:
   \   00000098   000095E5           LDR      R0,[R5, #+0]
   \   0000009C   800185E0           ADD      R0,R5,R0, LSL #+3
   \   000000A0   047080E5           STR      R7,[R0, #+4]
    156                cur_img->w_chars[cur_img->icon_in_row].wchar=sm->uni_smile;
   \   000000A4   000095E5           LDR      R0,[R5, #+0]
   \   000000A8   041096E5           LDR      R1,[R6, #+4]
   \   000000AC   800185E0           ADD      R0,R5,R0, LSL #+3
   \   000000B0   081080E5           STR      R1,[R0, #+8]
    157                cur_img->icon_in_row++;
   \   000000B4   000095E5           LDR      R0,[R5, #+0]
   \   000000B8   010080E2           ADD      R0,R0,#+1
   \   000000BC   000085E5           STR      R0,[R5, #+0]
    158              }
    159              sm=sm->next;
   \                     ??method1_3:
   \   000000C0   006096E5           LDR      R6,[R6, #+0]
    160            }
   \                     ??method1_1:
   \   000000C4   000056E3           CMP      R6,#+0
   \   000000C8   D3FFFF1A           BNE      ??method1_2
    161            data->ws=AllocWS(50);
   \   000000CC   3200A0E3           MOV      R0,#+50
   \   000000D0   250100EF           SWI      +293
   \   000000D4   4C0084E5           STR      R0,[R4, #+76]
    162            data->gui.state=1;
   \   000000D8   0100A0E3           MOV      R0,#+1
   \   000000DC   0C00C4E5           STRB     R0,[R4, #+12]
    163          }
   \   000000E0   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??method1_0:
   \   000000E4   ........           DC32     s_top
    164          

   \                                 In segment CODE, align 4, keep-with-next
    165          static void method2(SMILE_GUI *data,void (*mfree_adr)(void *))
    166          {
   \                     method2:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    167            data->gui.state=0;
   \   00000008   0000A0E3           MOV      R0,#+0
   \   0000000C   0C00C4E5           STRB     R0,[R4, #+12]
    168            mfree(data->icons);
   \   00000010   480094E5           LDR      R0,[R4, #+72]
   \   00000014   150000EF           SWI      +21
    169            FreeWS(data->ws);
   \   00000018   4C0094E5           LDR      R0,[R4, #+76]
   \   0000001C   290100EF           SWI      +297
    170          }
   \   00000020   1080BDE8           POP      {R4,PC}          ;; return
    171          

   \                                 In segment CODE, align 4, keep-with-next
    172          static void method3(SMILE_GUI *data,void *(*malloc_adr)(int),void (*mfree_adr)(void *))
    173          {
   \                     method3:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    174            DisableIDLETMR();
   \   00000008   7F0100EF           SWI      +383
    175            data->gui.state=2;
   \   0000000C   0200A0E3           MOV      R0,#+2
   \   00000010   0C00C4E5           STRB     R0,[R4, #+12]
    176          }
   \   00000014   1080BDE8           POP      {R4,PC}          ;; return
    177          

   \                                 In segment CODE, align 4, keep-with-next
    178          static void method4(SMILE_GUI *data,void (*mfree_adr)(void *))
    179          {
    180            if (data->gui.state!=2)
   \                     method4:
   \   00000000   0C10D0E5           LDRB     R1,[R0, #+12]
   \   00000004   020051E3           CMP      R1,#+2
    181              return;
    182            data->gui.state=1;
   \   00000008   0110A003           MOVEQ    R1,#+1
   \   0000000C   0C10C005           STRBEQ   R1,[R0, #+12]
    183          }
   \   00000010   1EFF2FE1           BX       LR               ;; return
    184          

   \                                 In segment CODE, align 4, keep-with-next
    185          static int method5(SMILE_GUI *data,GUI_MSG *msg)
    186          {
   \                     method5:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    187            int i;
    188            int m=msg->gbsmsg->msg;
   \   00000008   040091E5           LDR      R0,[R1, #+4]
   \   0000000C   042090E5           LDR      R2,[R0, #+4]
    189            int key=msg->gbsmsg->submess;
   \   00000010   081090E5           LDR      R1,[R0, #+8]
    190            if ((m==KEY_DOWN)||(m==LONG_PRESS))
   \   00000014   9300A0E3           MOV      R0,#+147
   \   00000018   400F80E3           ORR      R0,R0,#0x100
   \   0000001C   000052E1           CMP      R2,R0
   \   00000020   02008012           ADDNE    R0,R0,#+2
   \   00000024   00005211           CMPNE    R2,R0
   \   00000028   5700001A           BNE      ??method5_0
    191            {
    192              if (key==GREEN_BUTTON || (key>='0' && key<='9'))
   \   0000002C   442094E5           LDR      R2,[R4, #+68]
   \   00000030   340094E5           LDR      R0,[R4, #+52]
   \   00000034   483094E5           LDR      R3,[R4, #+72]
   \   00000038   0B0051E3           CMP      R1,#+11
   \   0000003C   0300000A           BEQ      ??method5_1
   \   00000040   300051E3           CMP      R1,#+48
   \   00000044   180000BA           BLT      ??method5_2
   \   00000048   3A0051E3           CMP      R1,#+58
   \   0000004C   160000AA           BGE      ??method5_2
    193              {
    194                int c;
    195                int n=0;
   \                     ??method5_1:
   \   00000050   0040A0E3           MOV      R4,#+0
    196                int d;
    197                if (key==GREEN_BUTTON) c=0;
   \   00000054   0B0051E3           CMP      R1,#+11
   \   00000058   0010A003           MOVEQ    R1,#+0
   \   0000005C   0500000A           BEQ      ??method5_3
    198                else if (key=='0') c=10;
   \   00000060   300051E3           CMP      R1,#+48
   \   00000064   30104112           SUBNE    R1,R1,#+48
   \   00000068   0A10A003           MOVEQ    R1,#+10
   \   0000006C   010000EA           B        ??method5_3
    199                else c=key-'0';
    200                while(c>=(d=data->icons[n].icon_in_row) && n<data->total_lines)
    201                {
    202                  c-=d;
   \                     ??method5_4:
   \   00000070   0C1041E0           SUB      R1,R1,R12
    203                  n++;
   \   00000074   014084E2           ADD      R4,R4,#+1
    204                }
   \                     ??method5_3:
   \   00000078   415FA0E3           MOV      R5,#+260
   \   0000007C   95342EE0           MLA      LR,R5,R4,R3
   \   00000080   00C09EE5           LDR      R12,[LR, #+0]
   \   00000084   0C0051E1           CMP      R1,R12
   \   00000088   010000BA           BLT      ??method5_5
   \   0000008C   020054E1           CMP      R4,R2
   \   00000090   F6FFFFBA           BLT      ??method5_4
    205                if (c>=0 && n<data->total_lines)
   \                     ??method5_5:
   \   00000094   000051E3           CMP      R1,#+0
   \   00000098   3B00004A           BMI      ??method5_0
   \   0000009C   020054E1           CMP      R4,R2
   \   000000A0   390000AA           BGE      ??method5_0
    206                {
    207                  PasteCharEditControl(data->ed_struct,data->icons[n].w_chars[c].wchar);
   \   000000A4   81118EE0           ADD      R1,LR,R1, LSL #+3
   \   000000A8   580000EA           B        ??method5_6
    208                  return (1);
    209                }
    210              }
    211              else
    212              {
    213                switch(key)
   \                     ??method5_2:
   \   000000AC   40C094E5           LDR      R12,[R4, #+64]
   \   000000B0   3CE094E5           LDR      LR,[R4, #+60]
   \   000000B4   415FA0E3           MOV      R5,#+260
   \   000000B8   953C23E0           MLA      R3,R5,R12,R3
   \   000000BC   012042E2           SUB      R2,R2,#+1
   \   000000C0   0050A0E3           MOV      R5,#+0
   \   000000C4   011051E2           SUBS     R1,R1,#+1
   \   000000C8   4F00000A           BEQ      ??method5_7
   \   000000CC   031051E2           SUBS     R1,R1,#+3
   \   000000D0   5000000A           BEQ      ??method5_8
   \   000000D4   161051E2           SUBS     R1,R1,#+22
   \   000000D8   4B00000A           BEQ      ??method5_7
   \   000000DC   211051E2           SUBS     R1,R1,#+33
   \   000000E0   0600000A           BEQ      ??method5_9
   \   000000E4   011051E2           SUBS     R1,R1,#+1
   \   000000E8   2A00000A           BEQ      ??method5_10
   \   000000EC   011051E2           SUBS     R1,R1,#+1
   \   000000F0   3800000A           BEQ      ??method5_11
   \   000000F4   011051E2           SUBS     R1,R1,#+1
   \   000000F8   3C00000A           BEQ      ??method5_12
   \   000000FC   220000EA           B        ??method5_0
    214                {
    215                case UP_BUTTON:
    216                  if (data->cur_pos_y>0)
   \                     ??method5_9:
   \   00000100   01005CE3           CMP      R12,#+1
   \   00000104   060000BA           BLT      ??method5_13
    217                  {
    218                    data->cur_pos_y--;
   \   00000108   01004CE2           SUB      R0,R12,#+1
   \   0000010C   400084E5           STR      R0,[R4, #+64]
    219                    if (data->cur_pos_y<=data->view_line) data->view_line=data->cur_pos_y;
   \   00000110   381094E5           LDR      R1,[R4, #+56]
   \   00000114   000051E1           CMP      R1,R0
   \   00000118   110000BA           BLT      ??method5_14
   \                     ??method5_15:
   \   0000011C   380084E5           STR      R0,[R4, #+56]
   \   00000120   0F0000EA           B        ??method5_14
    220                  }
    221                  else
    222                  {
    223                    data->cur_pos_y=data->total_lines-1;
   \                     ??method5_13:
   \   00000124   402084E5           STR      R2,[R4, #+64]
    224                    data->view_line=0;
   \   00000128   385084E5           STR      R5,[R4, #+56]
   \   0000012C   020000EA           B        ??method5_16
    225                    while(data->view_line<data->total_lines)
    226                    {
    227                      if (data->cur_pos_y==RenderPage(data,0)) break;
    228                      data->view_line++;
   \                     ??method5_17:
   \   00000130   380094E5           LDR      R0,[R4, #+56]
   \   00000134   010080E2           ADD      R0,R0,#+1
   \   00000138   380084E5           STR      R0,[R4, #+56]
   \                     ??method5_16:
   \   0000013C   380094E5           LDR      R0,[R4, #+56]
   \   00000140   441094E5           LDR      R1,[R4, #+68]
   \   00000144   010050E1           CMP      R0,R1
   \   00000148   050000AA           BGE      ??method5_14
   \   0000014C   0010A0E3           MOV      R1,#+0
   \   00000150   0400A0E1           MOV      R0,R4
   \   00000154   ........           BL       RenderPage
   \   00000158   401094E5           LDR      R1,[R4, #+64]
   \   0000015C   000051E1           CMP      R1,R0
   \   00000160   F2FFFF1A           BNE      ??method5_17
    229                    }
    230                  }
    231                  if (data->cur_pos_x>=(i=data->icons[data->cur_pos_y].icon_in_row)) data->cur_pos_x=i-1;  // Проверяем на выход за пределы
   \                     ??method5_14:
   \   00000164   400094E5           LDR      R0,[R4, #+64]
   \   00000168   482094E5           LDR      R2,[R4, #+72]
   \   0000016C   411FA0E3           MOV      R1,#+260
   \   00000170   912020E0           MLA      R0,R1,R0,R2
   \   00000174   3C1094E5           LDR      R1,[R4, #+60]
   \   00000178   000090E5           LDR      R0,[R0, #+0]
   \   0000017C   000051E1           CMP      R1,R0
   \   00000180   010000BA           BLT      ??method5_0
   \                     ??method5_18:
   \   00000184   010040E2           SUB      R0,R0,#+1
   \   00000188   3C0084E5           STR      R0,[R4, #+60]
    232                  break;
    233                  
    234                case DOWN_BUTTON:
    235                  if (data->cur_pos_y<data->total_lines-1)
    236                  {
    237                    data->cur_pos_y++;
    238                    if (data->cur_pos_y>RenderPage(data,0)) data->view_line++;
    239                  }
    240                  else
    241                  {
    242                    data->cur_pos_y=data->view_line=0;
    243                  }
    244                  if (data->cur_pos_x>=(i=data->icons[data->cur_pos_y].icon_in_row)) data->cur_pos_x=i-1;  // Проверяем на выход за пределы
    245                  break;
    246                  
    247                case LEFT_BUTTON:
    248                  if (data->cur_pos_x>0) data->cur_pos_x--;
    249                  else data->cur_pos_x=data->icons[data->cur_pos_y].icon_in_row-1;
    250                  break;
    251                  
    252                case RIGHT_BUTTON:
    253                  data->cur_pos_x++;
    254                  if (data->cur_pos_x>=(i=data->icons[data->cur_pos_y].icon_in_row)) data->cur_pos_x=0;  // Переходим на первый в ряду
    255                  break;
    256                  
    257                case LEFT_SOFT:
    258                case ENTER_BUTTON:
    259                  PasteCharEditControl(data->ed_struct,data->icons[data->cur_pos_y].w_chars[data->cur_pos_x].wchar);
    260                  return (1);
    261                
    262                case RIGHT_SOFT:
    263                  return (1);
    264                }
    265              }
    266            }
    267            DirectRedrawGUI();
   \                     ??method5_0:
   \   0000018C   3F0100EF           SWI      +319
    268            return(0);
   \   00000190   0000A0E3           MOV      R0,#+0
   \   00000194   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??method5_10:
   \   00000198   02005CE1           CMP      R12,R2
   \   0000019C   0A0000AA           BGE      ??method5_19
   \   000001A0   01008CE2           ADD      R0,R12,#+1
   \   000001A4   400084E5           STR      R0,[R4, #+64]
   \   000001A8   0010A0E3           MOV      R1,#+0
   \   000001AC   0400A0E1           MOV      R0,R4
   \   000001B0   ........           BL       RenderPage
   \   000001B4   401094E5           LDR      R1,[R4, #+64]
   \   000001B8   010050E1           CMP      R0,R1
   \   000001BC   E8FFFFAA           BGE      ??method5_14
   \   000001C0   380094E5           LDR      R0,[R4, #+56]
   \   000001C4   010080E2           ADD      R0,R0,#+1
   \   000001C8   D3FFFFEA           B        ??method5_15
   \                     ??method5_19:
   \   000001CC   385084E5           STR      R5,[R4, #+56]
   \   000001D0   405084E5           STR      R5,[R4, #+64]
   \   000001D4   E2FFFFEA           B        ??method5_14
   \                     ??method5_11:
   \   000001D8   01005EE3           CMP      LR,#+1
   \   000001DC   01004EA2           SUBGE    R0,LR,#+1
   \   000001E0   3C0084A5           STRGE    R0,[R4, #+60]
   \   000001E4   E8FFFFAA           BGE      ??method5_0
   \   000001E8   000093E5           LDR      R0,[R3, #+0]
   \   000001EC   E4FFFFEA           B        ??method5_18
   \                     ??method5_12:
   \   000001F0   01008EE2           ADD      R0,LR,#+1
   \   000001F4   3C0084E5           STR      R0,[R4, #+60]
   \   000001F8   001093E5           LDR      R1,[R3, #+0]
   \   000001FC   010050E1           CMP      R0,R1
   \   00000200   E1FFFFBA           BLT      ??method5_0
   \   00000204   3C5084E5           STR      R5,[R4, #+60]
   \   00000208   DFFFFFEA           B        ??method5_0
   \                     ??method5_7:
   \   0000020C   8E1183E0           ADD      R1,R3,LR, LSL #+3
   \                     ??method5_6:
   \   00000210   081091E5           LDR      R1,[R1, #+8]
   \   00000214   ........           BL       PasteCharEditControl
   \                     ??method5_8:
   \   00000218   0100A0E3           MOV      R0,#+1
   \   0000021C   3080BDE8           POP      {R4,R5,PC}
    269          }
    270          

   \                                 In segment CODE, align 4, keep-with-next
    271          static int method8(void){return(0);}
   \                     method8:
   \   00000000   ........           B        ?Subroutine13

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine13:
   \   00000000   0000A0E3           MOV      R0,#+0
   \   00000004   1EFF2FE1           BX       LR               ;; return
    272          

   \                                 In segment CODE, align 4, keep-with-next
    273          static int method9(void){return(0);}
   \                     method9:
   \   00000000                      REQUIRE ?Subroutine13
   \   00000000                      ;; // Fall through to label ?Subroutine13
    274          
    275          extern void kill_data(void *p, void (*func_p)(void *));
    276          static const void * const gui_methods[11]={
    277            (void *)method0,  //Redraw
    278            (void *)method1,  //Create
    279            (void *)method2,  //Close
    280            (void *)method3,  //Focus
    281            (void *)method4,  //Unfocus
    282            (void *)method5,  //OnKey
    283            0,
    284            (void *)kill_data, //method7, //Destroy
    285            (void *)method8,
    286            (void *)method9,
    287            0
    288          };
    289          

   \                                 In segment CODE, align 4, keep-with-next
    290          int CreateSmileSelectGUI(EDCHAT_STRUCT *ed_struct)
    291          {
   \                     CreateSmileSelectGUI:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    292            static const RECT Canvas={0,0,0,0};
    293            SMILE_GUI *smile_gui=malloc(sizeof(SMILE_GUI));
   \   00000008   5000A0E3           MOV      R0,#+80
   \   0000000C   140000EF           SWI      +20
   \   00000010   0050A0E1           MOV      R5,R0
    294            zeromem(smile_gui,sizeof(SMILE_GUI));
   \   00000014   5010A0E3           MOV      R1,#+80
   \   00000018   1D0100EF           SWI      +285
    295            patch_rect((RECT*)&Canvas,0,0,ScreenW()-1,ScreenH()-1);
   \   0000001C   898100EF           SWI      +33161
   \   00000020   0060A0E1           MOV      R6,R0
   \   00000024   888100EF           SWI      +33160
   \   00000028   38209FE5           LDR      R2,??CreateSmileSelectGUI_0  ;; ??Canvas
   \   0000002C   011046E2           SUB      R1,R6,#+1
   \   00000030   010040E2           SUB      R0,R0,#+1
   \   00000034   0030A0E3           MOV      R3,#+0
   \   00000038   003082E5           STR      R3,[R2, #+0]
   \   0000003C   B400C2E1           STRH     R0,[R2, #+4]
   \   00000040   B610C2E1           STRH     R1,[R2, #+6]
    296            smile_gui->gui.canvas=(void *)(&Canvas);
   \   00000044   002085E5           STR      R2,[R5, #+0]
    297            smile_gui->gui.methods=(void *)gui_methods;
   \   00000048   080082E2           ADD      R0,R2,#+8
   \   0000004C   040085E5           STR      R0,[R5, #+4]
    298            smile_gui->gui.item_ll.data_mfree=(void (*)(void *))mfree_adr();
   \   00000050   158000EF           SWI      +32789
   \   00000054   200085E5           STR      R0,[R5, #+32]
    299            smile_gui->ed_struct=ed_struct;
   \   00000058   344085E5           STR      R4,[R5, #+52]
    300            return CreateGUI(smile_gui);
   \   0000005C   0500A0E1           MOV      R0,R5
   \   00000060   370100EF           SWI      +311
   \   00000064   7080BDE8           POP      {R4-R6,PC}       ;; return
   \                     ??CreateSmileSelectGUI_0:
   \   00000068   ........           DC32     ??Canvas
    301          }

   \                                 In segment DATA_C, align 4, align-sorted
   \                     ??Canvas:
   \   00000000   000000000000       DC16 0, 0, 0, 0
   \              0000        
   \   00000008   ............       DC32 method0, method1, method2, method3, method4, method5, 0H
   \              ............
   \              ............
   \              ............
   \              00000000    
   \   00000024   ............       DC32 kill_data, method8, method9, 0H
   \              ............
   \              00000000    

   Maximum stack usage in bytes:

     Function             CSTACK
     --------             ------
     CreateSmileSelectGUI    16
     DrwImg                  56
     FindSmileIMGHDR          0
     PasteCharEditControl    64
     RenderPage              88
     method0                 32
     method1                 24
     method2                  8
     method3                  8
     method4                  0
     method5                 12
     method8                  0
     method9                  0


   Segment part sizes:

     Function/Label       Bytes
     --------------       -----
     FindSmileIMGHDR        56
     DrwImg                104
     PasteCharEditControl  136
     RenderPage            496
     method0                92
     method1               232
     method2                36
     method3                24
     method4                20
     method5               544
     method8                 4
     ?Subroutine13           8
     method9                 0
     CreateSmileSelectGUI  108
     Canvas                 52
      Others                76

 
 1 936 bytes in segment CODE
    52 bytes in segment DATA_C
 
 1 860 bytes of CODE  memory (+ 76 bytes shared)
    52 bytes of CONST memory

Errors: none
Warnings: none
