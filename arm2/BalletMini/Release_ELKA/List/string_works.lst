##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    27/Dec/2010  18:20:07 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\BalletMini\string_works.c                     #
#    Command line    =  C:\arm\BalletMini\string_works.c -D NEWSGOLD -D      #
#                       ELKA -lC C:\arm\BalletMini\Release_ELKA\List\ -o     #
#                       C:\arm\BalletMini\Release_ELKA\Obj\ -s9 --no_unroll  #
#                       --no_inline --cpu_mode arm --endian little --cpu     #
#                       ARM926EJ-S --stack_align 4 --interwork -e --fpu      #
#                       None --dlib_config "C:\arm2\Embedded Workbench 4.0   #
#                       Evaluation\ARM\LIB\dl5tpainl8n.h" -I                 #
#                       "C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\" #
#    List file       =  C:\arm\BalletMini\Release_ELKA\List\string_works.lst #
#    Object file     =  C:\arm\BalletMini\Release_ELKA\Obj\string_works.r79  #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\BalletMini\string_works.c
      1          #include "../inc/swilib.h"
      2          #include "string_works.h"
      3          

   \                                 In segment DATA_I, align 4, align-sorted
      4          int debugA=A_Truncate;
   \                     debugA:
   \   00000000                      DS8 4
   \   00000004                      REQUIRE `?<Initializer for debugA>`
      5          unsigned int debug_ul;
      6          int debug_file;
   \                     debug_file:
   \   00000004                      DS8 4
   \   00000008                      REQUIRE `?<Initializer for debug_file>`
   \                     debug_ul:
   \   00000008                      DS8 4
   \   0000000C                      REQUIRE `?<Initializer for debug_ul>`
      7          

   \                                 In segment CODE, align 4, keep-with-next
      8          void debugv(char *file,int line,void *p, int sz)
      9          {
   \                     debugv:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
     10            if ((debug_file=fopen("4:\\zbin\\balletmini\\debug.txt",A_ReadWrite+A_Create+debugA,P_READ+P_WRITE,&debug_ul))!=-1)
   \   00000004   ........           LDR      R6,??DataTable1  ;; debugA
   \   00000008   0240A0E1           MOV      R4,R2
   \   0000000C   000096E5           LDR      R0,[R6, #+0]
   \   00000010   602FA0E3           MOV      R2,#+384
   \   00000014   7E1042E2           SUB      R1,R2,#+126
   \   00000018   001081E0           ADD      R1,R1,R0
   \   0000001C   3C009FE5           LDR      R0,??debugv_0    ;; `?<Constant "4:\\\\zbin\\\\balletmini\\\\de...">`
   \   00000020   0350A0E1           MOV      R5,R3
   \   00000024   083086E2           ADD      R3,R6,#+8
   \   00000028   0A0000EF           SWI      +10
   \   0000002C   040086E5           STR      R0,[R6, #+4]
   \   00000030   010070E3           CMN      R0,#+1
   \   00000034   7080BD08           POPEQ    {R4-R6,PC}
     11            {
     12              fwrite(debug_file,p,sz,&debug_ul);
   \   00000038   083086E2           ADD      R3,R6,#+8
   \   0000003C   0520A0E1           MOV      R2,R5
   \   00000040   0410A0E1           MOV      R1,R4
   \   00000044   0C0000EF           SWI      +12
     13              fclose(debug_file,&debug_ul);
   \   00000048   040096E5           LDR      R0,[R6, #+4]
   \   0000004C   081086E2           ADD      R1,R6,#+8
   \   00000050   0D0000EF           SWI      +13
     14              debugA=A_Append;
   \   00000054   0800A0E3           MOV      R0,#+8
   \   00000058   000086E5           STR      R0,[R6, #+0]
     15            }
     16          }
   \   0000005C   7080BDE8           POP      {R4-R6,PC}       ;; return
   \                     ??debugv_0:
   \   00000060   ........           DC32     `?<Constant "4:\\\\zbin\\\\balletmini\\\\de...">`
     17          

   \                                 In segment CODE, align 4, keep-with-next
     18          void debugf(char *file,int line)
     19          {
   \                     debugf:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
     20            if ((debug_file=fopen("0:\\zbin\\balletmini\\debug.txt",A_ReadWrite+A_Create+debugA,P_READ+P_WRITE,&debug_ul))!=-1)
   \   00000004   80609FE5           LDR      R6,??debugf_0    ;; `?<Constant "%s : %i\\n">`
   \   00000008   ........           LDR      R7,??DataTable1  ;; debugA
   \   0000000C   40DF4DE2           SUB      SP,SP,#+256
   \   00000010   0040A0E1           MOV      R4,R0
   \   00000014   000097E5           LDR      R0,[R7, #+0]
   \   00000018   0150A0E1           MOV      R5,R1
   \   0000001C   083087E2           ADD      R3,R7,#+8
   \   00000020   602FA0E3           MOV      R2,#+384
   \   00000024   7E1042E2           SUB      R1,R2,#+126
   \   00000028   001081E0           ADD      R1,R1,R0
   \   0000002C   0C0086E2           ADD      R0,R6,#+12
   \   00000030   0A0000EF           SWI      +10
   \   00000034   040087E5           STR      R0,[R7, #+4]
   \   00000038   010070E3           CMN      R0,#+1
   \   0000003C   1000000A           BEQ      ??debugf_1
     21            {
     22              char c[256];
     23              sprintf(c,"%s : %i\n",file,line);
   \   00000040   0530A0E1           MOV      R3,R5
   \   00000044   0420A0E1           MOV      R2,R4
   \   00000048   0610A0E1           MOV      R1,R6
   \   0000004C   0D00A0E1           MOV      R0,SP
   \   00000050   160000EF           SWI      +22
     24              fwrite(debug_file,c,strlen(c),&debug_ul);
   \   00000054   0D00A0E1           MOV      R0,SP
   \   00000058   1B0000EF           SWI      +27
   \   0000005C   0020A0E1           MOV      R2,R0
   \   00000060   040097E5           LDR      R0,[R7, #+4]
   \   00000064   083087E2           ADD      R3,R7,#+8
   \   00000068   0D10A0E1           MOV      R1,SP
   \   0000006C   0C0000EF           SWI      +12
     25              fclose(debug_file,&debug_ul);
   \   00000070   040097E5           LDR      R0,[R7, #+4]
   \   00000074   081087E2           ADD      R1,R7,#+8
   \   00000078   0D0000EF           SWI      +13
     26              debugA=A_Append;
   \   0000007C   0800A0E3           MOV      R0,#+8
   \   00000080   000087E5           STR      R0,[R7, #+0]
     27            }
     28          }
   \                     ??debugf_1:
   \   00000084   40DF8DE2           ADD      SP,SP,#+256      ;; stack cleaning
   \   00000088   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??debugf_0:
   \   0000008C   ........           DC32     `?<Constant "%s : %i\\n">`
     29          

   \                                 In segment CODE, align 4, keep-with-next
     30          void debuf(void *p, int sz)
     31          {
     32          //  static char buf[1024];
     33          //  static int buf_sz=0;
     34          //  
     35          //  if (buf_sz+sz<1024)
     36          //  {
     37          //    memcpy(&buf[buf_sz],p,sz);
     38          //    buf_sz+=sz;
     39          //    return;
     40          //  }
     41          //  if ((debug_file=fopen("0:\\zbin\\balletmini\\debug.txt",A_ReadWrite+A_Create+debugA,P_READ+P_WRITE,&debug_ul))!=-1)
     42          //  {
     43          //    fwrite(debug_file,p,sz,&debug_ul);
     44          //    fclose(debug_file,&debug_ul);
     45          //    buf_sz=0;
     46          //    debugA=A_Append;
     47          //    memcpy(&buf[buf_sz],p,sz);
     48          //    buf_sz+=sz;
     49          //  }
     50          }
   \                     debuf:
   \   00000000   1EFF2FE1           BX       LR               ;; return
     51          

   \                                 In segment CODE, align 4, keep-with-next
     52          static unsigned int _rshort(char *p)
     53          {
     54            unsigned int r=*p++;
   \                     _rshort:
   \   00000000   ........           LDRB     R1,[R0], #+1
     55            r<<=8;
     56            r|=*p;
     57            return r;
   \   00000004   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000008   010480E1           ORR      R0,R0,R1, LSL #+8
   \   0000000C   1EFF2FE1           BX       LR               ;; return
     58          }
     59          

   \                                 In segment CODE, align 4, keep-with-next
     60          unsigned int _rshort2(char *p)
     61          {
     62            unsigned int r=*p++;
   \                     _rshort2:
   \   00000000   ........           LDRB     R1,[R0], #+1
     63            r<<=8;
     64            r|=*p;
     65            return r;
   \   00000004   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000008   010480E1           ORR      R0,R0,R1, LSL #+8
   \   0000000C   1EFF2FE1           BX       LR               ;; return
     66          }
     67          

   \                                 In segment CODE, align 4, keep-with-next
     68          int strcmp_nocase(const char *s, const char *d)
     69          {
     70            int cs;
     71            int ds;
     72            do
     73            {
     74              cs=*s++;
   \                     strcmp_nocase:
   \                     ??strcmp_nocase_0:
   \   00000000   ........           LDRB     R2,[R0], #+1
     75              if (cs&0x40) cs&=0xDF;
     76              ds=*d++;
   \   00000004   ........           LDRB     R3,[R1], #+1
   \   00000008   400012E3           TST      R2,#0x40
   \   0000000C   DF200212           ANDNE    R2,R2,#0xDF
     77              if (ds&0x40) ds&=0xDF;
   \   00000010   400013E3           TST      R3,#0x40
   \   00000014   DF300312           ANDNE    R3,R3,#0xDF
     78              cs-=ds;
   \   00000018   032052E0           SUBS     R2,R2,R3
     79              if (cs) break;
   \   0000001C   0100001A           BNE      ??strcmp_nocase_1
     80            }
     81            while(ds);
   \   00000020   000053E3           CMP      R3,#+0
   \   00000024   F5FFFF1A           BNE      ??strcmp_nocase_0
     82            return(cs);
   \                     ??strcmp_nocase_1:
   \   00000028   0200A0E1           MOV      R0,R2
   \   0000002C   1EFF2FE1           BX       LR               ;; return
     83          }
     84          

   \                                 In segment CODE, align 4, keep-with-next
     85          int omstrcmp(VIEWDATA *vd, unsigned int ps, unsigned int pd)
     86          {
   \                     omstrcmp:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0240A0E1           MOV      R4,R2
     87            int ls;
     88            char *s;
     89            int ld;
     90            char *d;
     91            if (ps>=vd->oms_size) return 1;
   \   00000008   402090E5           LDR      R2,[R0, #+64]
   \   0000000C   020051E1           CMP      R1,R2
     92            if (pd>=vd->oms_size) return 1;
   \   00000010   02005431           CMPCC    R4,R2
   \   00000014   0100003A           BCC      ??omstrcmp_0
   \                     ??omstrcmp_1:
   \   00000018   0100A0E3           MOV      R0,#+1
   \   0000001C   F080BDE8           POP      {R4-R7,PC}
     93            ls=_rshort(s=vd->oms+ps);
   \                     ??omstrcmp_0:
   \   00000020   3C5090E5           LDR      R5,[R0, #+60]
   \   00000024   056081E0           ADD      R6,R1,R5
   \   00000028   0600A0E1           MOV      R0,R6
   \   0000002C   ........           BL       _rshort
   \   00000030   0070A0E1           MOV      R7,R0
     94            ld=_rshort(d=vd->oms+pd);
   \   00000034   054084E0           ADD      R4,R4,R5
   \   00000038   0400A0E1           MOV      R0,R4
   \   0000003C   ........           BL       _rshort
     95            if (ls!=ld) return 1;
   \   00000040   000057E1           CMP      R7,R0
   \   00000044   F3FFFF1A           BNE      ??omstrcmp_1
     96            return memcmp(s+2,d+2,ls);
   \   00000048   0720A0E1           MOV      R2,R7
   \   0000004C   021084E2           ADD      R1,R4,#+2
   \   00000050   020086E2           ADD      R0,R6,#+2
   \   00000054   1C0100EF           SWI      +284
   \   00000058   F080BDE8           POP      {R4-R7,PC}       ;; return
     97          }
     98          

   \                                 In segment CODE, align 4, keep-with-next
     99          char *globalstr(const char *s)
    100          {
   \                     globalstr:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    101            int l=strlen(s)+1;
   \   00000008   1B0000EF           SWI      +27
   \   0000000C   015080E2           ADD      R5,R0,#+1
    102            char *d=malloc(l);
   \   00000010   0500A0E1           MOV      R0,R5
   \   00000014   140000EF           SWI      +20
   \   00000018   0060A0E1           MOV      R6,R0
    103            memcpy(d,s,l);
   \   0000001C   0520A0E1           MOV      R2,R5
   \   00000020   0410A0E1           MOV      R1,R4
   \   00000024   1E0100EF           SWI      +286
    104            return d;
   \   00000028   0600A0E1           MOV      R0,R6
   \   0000002C   7080BDE8           POP      {R4-R6,PC}       ;; return
    105          }
    106          

   \                                 In segment CODE, align 4, keep-with-next
    107          void freegstr(char **ps)
    108          {
   \                     freegstr:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    109            mfree(*ps);
   \   00000008   000094E5           LDR      R0,[R4, #+0]
   \   0000000C   150000EF           SWI      +21
    110            *ps=NULL;
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   000084E5           STR      R0,[R4, #+0]
    111          }
   \   00000018   1080BDE8           POP      {R4,PC}          ;; return
    112          

   \                                 In segment CODE, align 4, keep-with-next
    113          char *replacegstr(char **ps, const char *s, int len)
    114          {
   \                     replacegstr:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
    115            freegstr(ps);
   \   00000010   ........           BL       freegstr
    116            char *d=malloc(len+1);
   \   00000014   010086E2           ADD      R0,R6,#+1
   \   00000018   140000EF           SWI      +20
   \   0000001C   0070A0E1           MOV      R7,R0
    117            memcpy(d,s,len);
   \   00000020   0620A0E1           MOV      R2,R6
   \   00000024   0510A0E1           MOV      R1,R5
   \   00000028   1E0100EF           SWI      +286
    118            d[len]=0;
   \   0000002C   0000A0E3           MOV      R0,#+0
   \   00000030   0700C6E7           STRB     R0,[R6, +R7]
    119            return *ps=d;
   \   00000034   007084E5           STR      R7,[R4, #+0]
   \   00000038   0700A0E1           MOV      R0,R7
   \   0000003C   F080BDE8           POP      {R4-R7,PC}       ;; return
    120          }
    121          

   \                                 In segment CODE, align 4, keep-with-next
    122          int char16to8(int c)
    123          {
    124            if (c<0x400) return (c);
   \                     char16to8:
   \   00000000   400E50E3           CMP      R0,#+1024
   \   00000004   1EFF2FB1           BXLT     LR
    125            c-=0x400;
   \   00000008   FF10E0E3           MVN      R1,#+255
   \   0000000C   C01FC1E3           BIC      R1,R1,#0x300
   \   00000010   000081E0           ADD      R0,R1,R0
    126            if (c<16)
   \   00000014   100050E3           CMP      R0,#+16
   \   00000018   090000AA           BGE      ??char16to8_0
    127            {
    128              if (c==1) c=0;
   \   0000001C   010050E3           CMP      R0,#+1
   \   00000020   0000A003           MOVEQ    R0,#+0
   \   00000024   1400000A           BEQ      ??char16to8_1
    129              else if (c==4) c=2;
   \   00000028   040050E3           CMP      R0,#+4
   \   0000002C   0200A003           MOVEQ    R0,#+2
   \   00000030   1100000A           BEQ      ??char16to8_1
    130              else if (c==6) c=10;
   \   00000034   060050E3           CMP      R0,#+6
   \   00000038   1EFF2F11           BXNE     LR
   \   0000003C   0A00A0E3           MOV      R0,#+10
   \   00000040   0D0000EA           B        ??char16to8_1
    131              else return (c);
    132            }
    133            else if (c>79)
   \                     ??char16to8_0:
   \   00000044   500050E3           CMP      R0,#+80
   \   00000048   0D0000BA           BLT      ??char16to8_2
    134            {
    135              if (c==0x51) c=16;
   \   0000004C   510050E3           CMP      R0,#+81
   \   00000050   1000A003           MOVEQ    R0,#+16
   \   00000054   0800000A           BEQ      ??char16to8_1
    136              else if (c==0x54) c=18;
   \   00000058   540050E3           CMP      R0,#+84
   \   0000005C   1200A003           MOVEQ    R0,#+18
   \   00000060   0500000A           BEQ      ??char16to8_1
    137              else if (c==0x56) c=11;
   \   00000064   560050E3           CMP      R0,#+86
   \   00000068   0B00A003           MOVEQ    R0,#+11
   \   0000006C   0200000A           BEQ      ??char16to8_1
    138              else if (c==0x57) c=23;
   \   00000070   570050E3           CMP      R0,#+87
   \   00000074   1EFF2F11           BXNE     LR
   \   00000078   1700A0E3           MOV      R0,#+23
   \                     ??char16to8_1:
   \   0000007C   A80080E2           ADD      R0,R0,#+168
   \   00000080   1EFF2FE1           BX       LR
    139              else return (c);
    140            }
    141            else c+=8;
   \                     ??char16to8_2:
   \   00000084   080080E2           ADD      R0,R0,#+8
    142            c+=168;
    143            return (c);
   \                     ??char16to8_3:
   \   00000088   FBFFFFEA           B        ??char16to8_1
    144          }
    145          

   \                                 In segment CODE, align 4, keep-with-next
    146          int char8to16(int c)
    147          {
    148            if (c<168) return (c);
   \                     char8to16:
   \   00000000   A80050E3           CMP      R0,#+168
   \   00000004   1EFF2FB1           BXLT     LR
    149            c-=168;
   \   00000008   A710E0E3           MVN      R1,#+167
   \   0000000C   000091E0           ADDS     R0,R1,R0
    150            if (!c)  c=1;
   \   00000010   0100A003           MOVEQ    R0,#+1
   \   00000014   1700000A           BEQ      ??char8to16_0
    151            else if (c<24) 
   \   00000018   180050E3           CMP      R0,#+24
   \   0000001C   120000AA           BGE      ??char8to16_1
    152            {
    153              if (c==2) c=4;
   \   00000020   020050E3           CMP      R0,#+2
   \   00000024   0400A003           MOVEQ    R0,#+4
   \   00000028   1200000A           BEQ      ??char8to16_0
    154              else if (c==10) c=6;
   \   0000002C   0A0050E3           CMP      R0,#+10
   \   00000030   0600A003           MOVEQ    R0,#+6
   \   00000034   0F00000A           BEQ      ??char8to16_0
    155              else if (c==11) c=0x56;
   \   00000038   0B0050E3           CMP      R0,#+11
   \   0000003C   5600A003           MOVEQ    R0,#+86
   \   00000040   0C00000A           BEQ      ??char8to16_0
    156              else if (c==16) c=0x51;
   \   00000044   100050E3           CMP      R0,#+16
   \   00000048   5100A003           MOVEQ    R0,#+81
   \   0000004C   0900000A           BEQ      ??char8to16_0
    157              else if (c==18) c=0x54;
   \   00000050   120050E3           CMP      R0,#+18
   \   00000054   5400A003           MOVEQ    R0,#+84
   \   00000058   0600000A           BEQ      ??char8to16_0
    158              else if (c==23) c=0x57;
   \   0000005C   170050E3           CMP      R0,#+23
   \   00000060   1EFF2F11           BXNE     LR
   \   00000064   5700A0E3           MOV      R0,#+87
   \   00000068   020000EA           B        ??char8to16_0
    159              else return (c);
    160            }
    161            else if (c>87) return (c);
   \                     ??char8to16_1:
   \   0000006C   580050E3           CMP      R0,#+88
   \   00000070   1EFF2FA1           BXGE     LR
    162              else c-=8;
   \   00000074   080040E2           SUB      R0,R0,#+8
    163            c+=0x400;
    164            return (c); 
   \                     ??char8to16_0:
   \   00000078   400E80E2           ADD      R0,R0,#+1024
   \   0000007C   1EFF2FE1           BX       LR               ;; return
    165          }
    166          

   \                                 In segment CODE, align 4, keep-with-next
    167          int ws2ascii(char *buf, WSHDR *ws)
    168          {
   \                     ws2ascii:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    169            unsigned int sWs=ws->wsbody[0];
   \   0000000C   000095E5           LDR      R0,[R5, #+0]
    170            int p=0;
   \   00000010   0070A0E3           MOV      R7,#+0
   \   00000014   B060D0E1           LDRH     R6,[R0, #+0]
   \   00000018   000056E3           CMP      R6,#+0
   \   0000001C   0600001A           BNE      ??ws2ascii_0
   \   00000020   070000EA           B        ??ws2ascii_1
    171            unsigned int cWs;
    172            while(p<sWs)
    173            {
    174              cWs=ws->wsbody[p+1];
    175              buf[p]=char16to8(cWs);
   \                     ??ws2ascii_2:
   \   00000024   000095E5           LDR      R0,[R5, #+0]
   \   00000028   870080E0           ADD      R0,R0,R7, LSL #+1
   \   0000002C   B200D0E1           LDRH     R0,[R0, #+2]
   \   00000030   ........           BL       char16to8
   \   00000034   0400C7E7           STRB     R0,[R7, +R4]
    176              p++;
   \   00000038   017087E2           ADD      R7,R7,#+1
    177            }
   \                     ??ws2ascii_0:
   \   0000003C   060057E1           CMP      R7,R6
   \   00000040   F7FFFF3A           BCC      ??ws2ascii_2
    178            buf[p] = 0;
   \                     ??ws2ascii_1:
   \   00000044   0000A0E3           MOV      R0,#+0
   \   00000048   0400C7E7           STRB     R0,[R7, +R4]
    179            return p;
   \   0000004C   0700A0E1           MOV      R0,R7
   \   00000050   F080BDE8           POP      {R4-R7,PC}       ;; return
    180          }
    181          

   \                                 In segment CODE, align 4, keep-with-next
    182          void ascii2ws(WSHDR *ws, const char *s)
    183          {
   \                     ascii2ws:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    184            char c;
    185            CutWSTR(ws,0);
   \   0000000C   0010A0E3           MOV      R1,#+0
   \   00000010   260100EF           SWI      +294
   \   00000014   030000EA           B        ??ascii2ws_0
    186            while((c=*s++))
    187            {
    188              wsAppendChar(ws,char8to16(c));
   \                     ??ascii2ws_1:
   \   00000018   ........           BL       char8to16
   \   0000001C   0010A0E1           MOV      R1,R0
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   1C0000EF           SWI      +28
    189            }
   \                     ??ascii2ws_0:
   \   00000028   ........           LDRB     R1,[R5], #+1
   \   0000002C   0100B0E1           MOVS     R0,R1
   \   00000030   F8FFFF1A           BNE      ??ascii2ws_1
    190          }
   \   00000034   3080BDE8           POP      {R4,R5,PC}       ;; return
    191          

   \                                 In segment CODE, align 4, keep-with-next
    192          char *extract_omstr(VIEWDATA *vd, unsigned int pos)
    193          {
   \                     extract_omstr:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
    194            int n;
    195            char *s;
    196            char *d;
    197            if (pos>=vd->oms_size||pos==_NOREF) return NULL;
   \   00000004   402090E5           LDR      R2,[R0, #+64]
   \   00000008   020051E1           CMP      R1,R2
   \   0000000C   0100002A           BCS      ??extract_omstr_0
   \   00000010   010071E3           CMN      R1,#+1
   \   00000014   0100001A           BNE      ??extract_omstr_1
   \                     ??extract_omstr_0:
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   7080BDE8           POP      {R4-R6,PC}
    198            n=_rshort(s=vd->oms+pos);
   \                     ??extract_omstr_1:
   \   00000020   3C0090E5           LDR      R0,[R0, #+60]
   \   00000024   004081E0           ADD      R4,R1,R0
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           BL       _rshort
   \   00000030   0050A0E1           MOV      R5,R0
    199            d=malloc(n+1);
   \   00000034   010085E2           ADD      R0,R5,#+1
   \   00000038   140000EF           SWI      +20
   \   0000003C   0060A0E1           MOV      R6,R0
    200            memcpy(d,s+2,n);
   \   00000040   0520A0E1           MOV      R2,R5
   \   00000044   021084E2           ADD      R1,R4,#+2
   \   00000048   1E0100EF           SWI      +286
    201            d[n]=0;
   \   0000004C   0000A0E3           MOV      R0,#+0
   \   00000050   0600C5E7           STRB     R0,[R5, +R6]
    202            return d;
   \   00000054   0600A0E1           MOV      R0,R6
   \   00000058   7080BDE8           POP      {R4-R6,PC}       ;; return
    203          }
    204          

   \                                 In segment CODE, align 4, keep-with-next
    205          void utf82win(char*d,const char *s)
    206          {
   \                     utf82win:
   \   00000000   10002DE9           PUSH     {R4}
    207            int ds = 2;
   \   00000004   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000008   000052E3           CMP      R2,#+0
   \   0000000C   2500000A           BEQ      ??utf82win_0
    208            for (; *s; s+=ds)
    209            {
    210              unsigned char ub = *s, lb = *(s+1);
   \                     ??utf82win_1:
   \   00000010   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000014   01C0D1E5           LDRB     R12,[R1, #+1]
    211              ds = 1;
   \   00000018   0130A0E3           MOV      R3,#+1
    212              if (ub == 0xD0)
   \   0000001C   D00052E3           CMP      R2,#+208
   \   00000020   0400001A           BNE      ??utf82win_2
    213                if (lb != 0x81)
   \   00000024   81005CE3           CMP      R12,#+129
   \   00000028   A840A003           MOVEQ    R4,#+168
    214                  {*d = lb + 48; d++;}
   \   0000002C   30408C12           ADDNE    R4,R12,#+48
   \                     ??utf82win_3:
   \   00000030   ........           STRB     R4,[R0], #+1
   \   00000034   0E0000EA           B        ??utf82win_4
    215                else
    216                  {*d = 'Ё'; d++;}
    217          
    218              if (ub == 0xD1)
   \                     ??utf82win_2:
   \   00000038   D10052E3           CMP      R2,#+209
   \   0000003C   0500001A           BNE      ??utf82win_5
    219                if (lb != 0x91)
   \   00000040   91005CE3           CMP      R12,#+145
    220                  {*d = lb + 112; d++;}
   \   00000044   70408C12           ADDNE    R4,R12,#+112
   \   00000048   ........           STRBNE   R4,[R0], #+1
   \   0000004C   0800001A           BNE      ??utf82win_4
    221                else
    222                  {*d = 'ё'; d++;}
   \   00000050   B840A0E3           MOV      R4,#+184
   \   00000054   F5FFFFEA           B        ??utf82win_3
    223          
    224              if (ub == 0xE2)
   \                     ??utf82win_5:
   \   00000058   E20052E3           CMP      R2,#+226
    225                if (lb == 0x80)
   \   0000005C   80005C03           CMPEQ    R12,#+128
    226                  if ((unsigned char)*(s+2) == 0x94)
   \   00000060   0240D105           LDRBEQ   R4,[R1, #+2]
   \   00000064   94005403           CMPEQ    R4,#+148
    227                    {*d = '-'; d++; ds = 3;}
   \   00000068   2D30A003           MOVEQ    R3,#+45
   \   0000006C   ........           STRBEQ   R3,[R0], #+1
   \   00000070   0330A003           MOVEQ    R3,#+3
    228          
    229              if(!(ub & 0x80))
   \                     ??utf82win_4:
   \   00000074   800012E3           TST      R2,#0x80
    230              {
    231                *d = ub;
   \   00000078   ........           STRBEQ   R2,[R0], #+1
    232                d++;
   \   0000007C   0500000A           BEQ      ??utf82win_6
    233              }
    234              else
    235                for(ds = 0; ub&0x80; ub <<= 1, ds++);
   \   00000080   0030A0E3           MOV      R3,#+0
   \                     ??utf82win_7:
   \   00000084   822CA0E1           LSL      R2,R2,#+25
   \   00000088   222CA0E1           LSR      R2,R2,#+24
   \   0000008C   013083E2           ADD      R3,R3,#+1
   \   00000090   800012E3           TST      R2,#0x80
   \   00000094   FAFFFF1A           BNE      ??utf82win_7
    236            }
   \                     ??utf82win_6:
   \   00000098   011083E0           ADD      R1,R3,R1
   \   0000009C   0020D1E5           LDRB     R2,[R1, #+0]
   \   000000A0   000052E3           CMP      R2,#+0
   \   000000A4   D9FFFF1A           BNE      ??utf82win_1
    237            *d = 0;
   \                     ??utf82win_0:
   \   000000A8   0010A0E3           MOV      R1,#+0
   \   000000AC   0010C0E5           STRB     R1,[R0, #+0]
    238          }
   \   000000B0   1000BDE8           POP      {R4}
   \   000000B4   1EFF2FE1           BX       LR               ;; return
    239          

   \                                 In segment DATA_I, align 4, align-sorted
    240          char symbols[]={0x0A,0x20,0x23,0x24,0x25,0x26,0x2B,0x2C,0x2F,0x3A,0x3B,0x3D,0x3F,0x40,0x7E,0x00};
    241          
    242          char percent_symb[]={0x25, 0x00};
   \                     percent_symb:
   \   00000000                      DS8 2
   \   00000002                      REQUIRE `?<Initializer for percent_symb>`
   \   00000002                      DS8 2
   \                     symbols:
   \   00000004                      DS8 16
   \   00000014                      REQUIRE `?<Initializer for symbols>`
    243          

   \                                 In segment CODE, align 4, keep-with-next
    244          int sfind8(char s,char *v)
    245          {
   \                     sfind8:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    246            for (int i=0;i<strlen(v);i++)
   \   0000000C   0060A0E3           MOV      R6,#+0
   \   00000010   000000EA           B        ??sfind8_0
   \                     ??sfind8_1:
   \   00000014   016086E2           ADD      R6,R6,#+1
   \                     ??sfind8_0:
   \   00000018   0500A0E1           MOV      R0,R5
   \   0000001C   1B0000EF           SWI      +27
   \   00000020   000056E1           CMP      R6,R0
   \   00000024   0400002A           BCS      ??sfind8_2
    247              if (s==v[i])
   \   00000028   0500D6E7           LDRB     R0,[R6, +R5]
   \   0000002C   000054E1           CMP      R4,R0
   \   00000030   F7FFFF1A           BNE      ??sfind8_1
    248                return i;
   \   00000034   0600A0E1           MOV      R0,R6
   \   00000038   7080BDE8           POP      {R4-R6,PC}
    249            return -1;
   \                     ??sfind8_2:
   \   0000003C   0000E0E3           MVN      R0,#+0
   \   00000040   7080BDE8           POP      {R4-R6,PC}       ;; return
    250          }
    251          

   \                                 In segment CODE, align 4, keep-with-next
    252          int char_win2utf8(char*d,const char *s, char* symbols_array) // функция возвращает количество 
    253          {                                       // добавленных символов в d
   \                     char_win2utf8:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
    254            char hex[] = "0123456789abcdef";
   \   00000004   1C519FE5           LDR      R5,??char_win2utf8_0  ;; `?<Constant "0123456789abcdef">`
   \   00000008   14D04DE2           SUB      SP,SP,#+20
   \   0000000C   C05195E8           LDM      R5,{R6-R8,R12,LR}
   \   00000010   0040A0E1           MOV      R4,R0
   \   00000014   0D00A0E1           MOV      R0,SP
   \   00000018   C05180E8           STM      R0,{R6-R8,R12,LR}
    255            char *d0 = "%d0%";
    256            char *d1 = "%d1%";
    257            unsigned char b = *s, lb, ub;
   \   0000001C   0070D1E5           LDRB     R7,[R1, #+0]
    258            int r = 0, ab;
   \   00000020   0080A0E3           MOV      R8,#+0
    259            if (sfind8(b,symbols_array)>=0)
   \   00000024   2560A0E3           MOV      R6,#+37
   \   00000028   0210A0E1           MOV      R1,R2
   \   0000002C   0700A0E1           MOV      R0,R7
   \   00000030   ........           BL       sfind8
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   0800004A           BMI      ??char_win2utf8_1
    260            {
    261              *d = '%'; d++;
   \   0000003C   ........           STRB     R6,[R4], #+1
    262              *d = hex[(b>>4)&0xF]; d++;
   \   00000040   0700A0E1           MOV      R0,R7
   \   00000044   0D10A0E1           MOV      R1,SP
   \   00000048   4002D1E7           LDRB     R0,[R1, +R0, ASR #+4]
    263              *d = hex[b     &0xF]; d++;
    264              r = 3;
   \   0000004C   0380A0E3           MOV      R8,#+3
   \   00000050   ........           STRB     R0,[R4], #+1
   \   00000054   0F0007E2           AND      R0,R7,#0xF
   \   00000058   0100D0E7           LDRB     R0,[R0, +R1]
   \   0000005C   ........           STRB     R0,[R4], #+1
    265            }
    266            if(b >= 0xC0 && b <= 0xFF)           //если это русская буква в коде win1251
   \                     ??char_win2utf8_1:
   \   00000060   C00057E3           CMP      R7,#+192
   \   00000064   1700003A           BCC      ??char_win2utf8_2
    267            {
    268              ab = 0x350;                        //считаем её unicode-номер
    269              ab += b;
   \   00000068   D40F87E2           ADD      R0,R7,#+848
    270              ub = 0xC0 | ((ab>>6) & 0x1F);      //вычисляем бытовые компоненты для utf8
   \   0000006C   4013A0E1           ASR      R1,R0,#+6
   \   00000070   1F1001E2           AND      R1,R1,#0x1F
   \   00000074   C01081E3           ORR      R1,R1,#0xC0
    271              lb = 0x80 | (ab & 0x3F);
    272              *d = '%'; d++;
   \   00000078   ........           STRB     R6,[R4], #+1
    273              *d = hex[(ub>>4)&0xF]; d++;        //и кладём в буфер результата
   \   0000007C   0120A0E1           MOV      R2,R1
   \   00000080   0D30A0E1           MOV      R3,SP
   \   00000084   4222D3E7           LDRB     R2,[R3, +R2, ASR #+4]
    274              *d = hex[ub     &0xF]; d++;
   \   00000088   0F1001E2           AND      R1,R1,#0xF
   \   0000008C   3F0000E2           AND      R0,R0,#0x3F
   \   00000090   ........           STRB     R2,[R4], #+1
   \   00000094   0D20A0E1           MOV      R2,SP
   \   00000098   0210D1E7           LDRB     R1,[R1, +R2]
   \   0000009C   800080E3           ORR      R0,R0,#0x80
   \   000000A0   ........           STRB     R1,[R4], #+1
    275              *d = '%'; d++;
   \   000000A4   ........           STRB     R6,[R4], #+1
    276              *d = hex[(lb>>4)&0xF]; d++;
   \   000000A8   0010A0E1           MOV      R1,R0
   \   000000AC   4112D2E7           LDRB     R1,[R2, +R1, ASR #+4]
    277              *d = hex[lb     &0xF]; d++;
   \   000000B0   0F0000E2           AND      R0,R0,#0xF
   \   000000B4   ........           STRB     R1,[R4], #+1
   \   000000B8   0D10A0E1           MOV      R1,SP
   \   000000BC   0100D0E7           LDRB     R0,[R0, +R1]
   \   000000C0   0000C4E5           STRB     R0,[R4, #+0]
    278              r = 6;
   \   000000C4   130000EA           B        ??char_win2utf8_3
    279            }
    280            else
    281                if(b == 0xA8)
   \                     ??char_win2utf8_2:
   \   000000C8   3160A0E3           MOV      R6,#+49
   \   000000CC   A80057E3           CMP      R7,#+168
   \   000000D0   0600001A           BNE      ??char_win2utf8_4
    282                {
    283                  memcpy(d, d0, 4);              //пара особых случаев для буквы "ё"
   \   000000D4   0420A0E3           MOV      R2,#+4
   \   000000D8   141085E2           ADD      R1,R5,#+20
   \   000000DC   0400A0E1           MOV      R0,R4
   \   000000E0   1E0100EF           SWI      +286
    284                  d+=4;
   \   000000E4   044084E2           ADD      R4,R4,#+4
    285                  *d = '8'; d++;
   \   000000E8   3800A0E3           MOV      R0,#+56
   \   000000EC   070000EA           B        ??char_win2utf8_5
    286                  *d = '1'; d++;
    287                  r = 6;
    288                }
    289                else
    290                  if(b == 0xB8)
   \                     ??char_win2utf8_4:
   \   000000F0   B80057E3           CMP      R7,#+184
   \   000000F4   0800001A           BNE      ??char_win2utf8_6
    291                  {
    292                  memcpy(d, d1, 4);
   \   000000F8   0420A0E3           MOV      R2,#+4
   \   000000FC   1C1085E2           ADD      R1,R5,#+28
   \   00000100   0400A0E1           MOV      R0,R4
   \   00000104   1E0100EF           SWI      +286
    293                  d+=4;
   \   00000108   044084E2           ADD      R4,R4,#+4
    294                  *d = '9'; d++;
   \   0000010C   3900A0E3           MOV      R0,#+57
   \                     ??char_win2utf8_5:
   \   00000110   ........           STRB     R0,[R4], #+1
    295                  *d = '1'; d++;
   \   00000114   0060C4E5           STRB     R6,[R4, #+0]
    296                  r = 6;
   \                     ??char_win2utf8_3:
   \   00000118   0680A0E3           MOV      R8,#+6
    297                  }
    298            return r;
   \                     ??char_win2utf8_6:
   \   0000011C   0800A0E1           MOV      R0,R8
   \   00000120   14D08DE2           ADD      SP,SP,#+20
   \   00000124   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??char_win2utf8_0:
   \   00000128   ........           DC32     `?<Constant "0123456789abcdef">`
    299          }
    300          

   \                                 In segment CODE, align 4, keep-with-next
    301          char * ToWeb(char *src, int special, int conv_percent)                   //конвертируем ссылку в utf8
    302          {
   \                     ToWeb:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
    303            int cnt = 0, i, j;
    304            char* symbols_array;
    305            if (conv_percent)
   \   00000004   F0609FE5           LDR      R6,??ToWeb_0     ;; percent_symb
   \   00000008   0040A0E1           MOV      R4,R0
    306              symbols_array = percent_symb;
    307            else
    308              symbols_array = symbols;
    309            char *ret;
    310            for(i = 0; src[i]; i++)                 //считаем русские символы
   \   0000000C   0000D4E5           LDRB     R0,[R4, #+0]
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   0070A0E3           MOV      R7,#+0
   \   00000018   000052E3           CMP      R2,#+0
   \   0000001C   04608602           ADDEQ    R6,R6,#+4
   \   00000020   0080A0E3           MOV      R8,#+0
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   1700001A           BNE      ??ToWeb_1
    311            {
    312              unsigned char c=src[i];
    313              if(c>=0x80) cnt+=2;
    314              else
    315                if(special&&(sfind8(c,symbols_array)>=0)) cnt++;
    316            }
    317            ret = malloc(strlen(src) + cnt*3 + 1);  //выделяем память под utf8-строку
   \                     ??ToWeb_2:
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   1B0000EF           SWI      +27
   \   00000034   871087E0           ADD      R1,R7,R7, LSL #+1
   \   00000038   000081E0           ADD      R0,R1,R0
   \   0000003C   010080E2           ADD      R0,R0,#+1
   \   00000040   140000EF           SWI      +20
   \   00000044   0070A0E1           MOV      R7,R0
    318            for(i = 0, j = 0; src[i]; i++)
   \   00000048   0000D4E5           LDRB     R0,[R4, #+0]
   \   0000004C   0090A0E3           MOV      R9,#+0
   \   00000050   0080A0E3           MOV      R8,#+0
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   1600001A           BNE      ??ToWeb_3
   \                     ??ToWeb_4:
   \   0000005C   0700C8E7           STRB     R0,[R8, +R7]
    319            {
    320              unsigned char c=src[i];
    321              if(c>=0x80||(special&&(sfind8(c,symbols_array)>=0)))
    322                j += char_win2utf8(ret+j, src+i, symbols_array);   //получаем вместо русского символа utf8-замену
    323              else
    324                ret[j++] = src[i];
    325            }
    326            ret[j] = 0;
    327            mfree(src);                             //освобождаем память от исходной строки
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   150000EF           SWI      +21
    328            return ret;
   \   00000068   0700A0E1           MOV      R0,R7
   \   0000006C   F083BDE8           POP      {R4-R9,PC}       ;; return
   \                     ??ToWeb_5:
   \   00000070   000055E3           CMP      R5,#+0
   \   00000074   0300000A           BEQ      ??ToWeb_6
   \   00000078   0610A0E1           MOV      R1,R6
   \   0000007C   ........           BL       sfind8
   \   00000080   000050E3           CMP      R0,#+0
   \   00000084   01708752           ADDPL    R7,R7,#+1
   \                     ??ToWeb_6:
   \   00000088   018088E2           ADD      R8,R8,#+1
   \                     ??ToWeb_1:
   \   0000008C   0400D8E7           LDRB     R0,[R8, +R4]
   \   00000090   000050E3           CMP      R0,#+0
   \   00000094   E4FFFF0A           BEQ      ??ToWeb_2
   \   00000098   800050E3           CMP      R0,#+128
   \   0000009C   F3FFFF3A           BCC      ??ToWeb_5
   \   000000A0   027087E2           ADD      R7,R7,#+2
   \   000000A4   F7FFFFEA           B        ??ToWeb_6
   \                     ??ToWeb_7:
   \   000000A8   0400D9E7           LDRB     R0,[R9, +R4]
   \   000000AC   0700C8E7           STRB     R0,[R8, +R7]
   \   000000B0   018088E2           ADD      R8,R8,#+1
   \                     ??ToWeb_8:
   \   000000B4   019089E2           ADD      R9,R9,#+1
   \                     ??ToWeb_3:
   \   000000B8   0400D9E7           LDRB     R0,[R9, +R4]
   \   000000BC   000050E3           CMP      R0,#+0
   \   000000C0   E5FFFF0A           BEQ      ??ToWeb_4
   \   000000C4   800050E3           CMP      R0,#+128
   \   000000C8   0500002A           BCS      ??ToWeb_9
   \   000000CC   000055E3           CMP      R5,#+0
   \   000000D0   F4FFFF0A           BEQ      ??ToWeb_7
   \   000000D4   0610A0E1           MOV      R1,R6
   \   000000D8   ........           BL       sfind8
   \   000000DC   000050E3           CMP      R0,#+0
   \   000000E0   F0FFFF4A           BMI      ??ToWeb_7
   \                     ??ToWeb_9:
   \   000000E4   0620A0E1           MOV      R2,R6
   \   000000E8   041089E0           ADD      R1,R9,R4
   \   000000EC   070088E0           ADD      R0,R8,R7
   \   000000F0   ........           BL       char_win2utf8
   \   000000F4   088080E0           ADD      R8,R0,R8
   \   000000F8   EDFFFFEA           B        ??ToWeb_8
   \                     ??ToWeb_0:
   \   000000FC   ........           DC32     percent_symb
    329          }
    330          

   \                                 In segment CODE, align 4, keep-with-next
    331          void oms2ws(WSHDR *ws, const char *text, int len)
    332          {
    333            ws->wsbody[0]=0;
   \                     oms2ws:
   \   00000000   000090E5           LDR      R0,[R0, #+0]
   \   00000004   0030A0E3           MOV      R3,#+0
   \   00000008   B030C0E1           STRH     R3,[R0, #+0]
   \   0000000C   130000EA           B        ??oms2ws_0
    334            int c;
    335            while((len--)>0)
    336            {
    337              c=*text++;
    338              if ((c&0xE0)==0xC0)
    339              {
    340                if (len>0)
    341                {
    342                  c&=0x1F;
    343                  c<<=6;
    344                  c|=(*text++)&0x3F;
    345                  len-=1;
    346                }
    347              }
    348              else
    349                if ((c&0xF0)==0xE0)
   \                     ??oms2ws_1:
   \   00000010   F0C003E2           AND      R12,R3,#0xF0
   \   00000014   E0005CE3           CMP      R12,#+224
   \   00000018   0A00001A           BNE      ??oms2ws_2
    350                {
    351                  if (len>1)
   \   0000001C   020052E3           CMP      R2,#+2
   \   00000020   080000BA           BLT      ??oms2ws_2
    352                  {
    353                    c&=0x0F;
    354                    c<<=12;
    355                    c|=((*text++)&0x3F)<<6;
   \   00000024   ........           LDRB     R12,[R1], #+1
   \   00000028   0F3003E2           AND      R3,R3,#0xF
    356                    c|=((*text++)&0x3F)<<0;
    357                    len-=2;
   \   0000002C   022042E2           SUB      R2,R2,#+2
   \   00000030   3FC00CE2           AND      R12,R12,#0x3F
   \   00000034   0CC3A0E1           LSL      R12,R12,#+6
   \   00000038   03368CE1           ORR      R3,R12,R3, LSL #+12
   \   0000003C   ........           LDRB     R12,[R1], #+1
   \   00000040   3FC00CE2           AND      R12,R12,#0x3F
   \   00000044   03308CE1           ORR      R3,R12,R3
    358                  }
    359                }
    360              ws->wsbody[++(ws->wsbody[0])]=c;
   \                     ??oms2ws_2:
   \   00000048   B0C0D0E1           LDRH     R12,[R0, #+0]
   \   0000004C   01C08CE2           ADD      R12,R12,#+1
   \   00000050   B0C0C0E1           STRH     R12,[R0, #+0]
   \   00000054   B0C0D0E1           LDRH     R12,[R0, #+0]
   \   00000058   8CC080E0           ADD      R12,R0,R12, LSL #+1
   \   0000005C   B030CCE1           STRH     R3,[R12, #+0]
   \                     ??oms2ws_0:
   \   00000060   0230A0E1           MOV      R3,R2
   \   00000064   012043E2           SUB      R2,R3,#+1
   \   00000068   010053E3           CMP      R3,#+1
   \   0000006C   1EFF2FB1           BXLT     LR
   \   00000070   ........           LDRB     R3,[R1], #+1
   \   00000074   E0C003E2           AND      R12,R3,#0xE0
   \   00000078   C0005CE3           CMP      R12,#+192
   \   0000007C   E3FFFF1A           BNE      ??oms2ws_1
   \   00000080   010052E3           CMP      R2,#+1
   \   00000084   EFFFFFBA           BLT      ??oms2ws_2
   \   00000088   ........           LDRB     R12,[R1], #+1
   \   0000008C   1F3003E2           AND      R3,R3,#0x1F
   \   00000090   012042E2           SUB      R2,R2,#+1
   \   00000094   3FC00CE2           AND      R12,R12,#0x3F
   \   00000098   03338CE1           ORR      R3,R12,R3, LSL #+6
   \   0000009C   E9FFFFEA           B        ??oms2ws_2
    361            }
    362          }
    363          

   \                                 In segment CODE, align 4, keep-with-next
    364          int CompareWchar(short wchar1, short wchar2, int isCaseSensitive)
    365          {
    366            if (isCaseSensitive)
   \                     CompareWchar:
   \   00000000   000052E3           CMP      R2,#+0
   \   00000004   0300000A           BEQ      ??CompareWchar_0
    367              return (wchar1 == wchar2);
   \   00000008   010050E1           CMP      R0,R1
   \   0000000C   2500001A           BNE      ??CompareWchar_1
   \   00000010   0100A0E3           MOV      R0,#+1
   \   00000014   1EFF2FE1           BX       LR
    368            else
    369            {
    370              if ((wchar1 < 0x100)&&(wchar1&0x40)) wchar1&=0xDF;
   \                     ??CompareWchar_0:
   \   00000018   400F50E3           CMP      R0,#+256
   \   0000001C   010000AA           BGE      ??CompareWchar_2
   \   00000020   400010E3           TST      R0,#0x40
   \   00000024   DF000012           ANDNE    R0,R0,#0xDF
    371              if ((wchar2 < 0x100)&&(wchar2&0x40)) wchar2&=0xDF;
   \                     ??CompareWchar_2:
   \   00000028   400F51E3           CMP      R1,#+256
   \   0000002C   010000AA           BGE      ??CompareWchar_3
   \   00000030   400011E3           TST      R1,#0x40
   \   00000034   DF100112           ANDNE    R1,R1,#0xDF
    372              if ((wchar1 >= 0x430)&&(wchar1 < 0x450)) wchar1-=0x20;
   \                     ??CompareWchar_3:
   \   00000038   430E50E3           CMP      R0,#+1072
   \   0000003C   010000BA           BLT      ??CompareWchar_4
   \   00000040   450E50E3           CMP      R0,#+1104
   \   00000044   200040B2           SUBLT    R0,R0,#+32
    373              if ((wchar2 >= 0x430)&&(wchar2 < 0x450)) wchar2-=0x20;
   \                     ??CompareWchar_4:
   \   00000048   430E51E3           CMP      R1,#+1072
   \   0000004C   010000BA           BLT      ??CompareWchar_5
   \   00000050   450E51E3           CMP      R1,#+1104
   \   00000054   201041B2           SUBLT    R1,R1,#+32
    374              if ((wchar1 > 0x450)&&(wchar1 <= 0x45F)) wchar1-=0x50;
   \                     ??CompareWchar_5:
   \   00000058   5120A0E3           MOV      R2,#+81
   \   0000005C   402E82E3           ORR      R2,R2,#0x400
   \   00000060   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000064   4008A0E1           MOV      R0,R0, ASR #+16
   \   00000068   020050E1           CMP      R0,R2
   \   0000006C   010000BA           BLT      ??CompareWchar_6
   \   00000070   460E50E3           CMP      R0,#+1120
   \   00000074   500040B2           SUBLT    R0,R0,#+80
    375              if ((wchar2 > 0x450)&&(wchar2 <= 0x45F)) wchar2-=0x50;
   \                     ??CompareWchar_6:
   \   00000078   0118A0E1           MOV      R1,R1, LSL #+16
   \   0000007C   4118A0E1           MOV      R1,R1, ASR #+16
   \   00000080   020051E1           CMP      R1,R2
   \   00000084   010000BA           BLT      ??CompareWchar_7
   \   00000088   460E51E3           CMP      R1,#+1120
   \   0000008C   501041B2           SUBLT    R1,R1,#+80
    376              return (wchar1 == wchar2);
   \                     ??CompareWchar_7:
   \   00000090   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000094   4008A0E1           MOV      R0,R0, ASR #+16
   \   00000098   0118A0E1           MOV      R1,R1, LSL #+16
   \   0000009C   410850E1           CMP      R0,R1, ASR #+16
   \   000000A0   0100A003           MOVEQ    R0,#+1
   \   000000A4   1EFF2F01           BXEQ     LR
   \                     ??CompareWchar_1:
   \   000000A8   0000A0E3           MOV      R0,#+0
   \   000000AC   1EFF2FE1           BX       LR               ;; return
    377            }
    378          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   ........           DC32     debugA

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for debugA>`:
   \   00000000   00020000           DC32 512
   \                     `?<Initializer for debug_file>`:
   \   00000004   00000000           DC8 0, 0, 0, 0
   \                     `?<Initializer for debug_ul>`:
   \   00000008   00000000           DC8 0, 0, 0, 0

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for percent_symb>`:
   \   00000000   2500               DC8 37, 0
   \   00000002   0000               DC8 0, 0
   \                     `?<Initializer for symbols>`:
   \   00000004   0A2023242526       DC8 10, 32, 35, 36, 37, 38, 43, 44, 47, 58, 59, 61, 63, 64, 126, 0
   \              2B2C2F3A3B3D
   \              3F407E00    

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "4:\\\\zbin\\\\balletmini\\\\de...">`:
   \   00000000   343A5C7A6269       DC8 "4:\\zbin\\balletmini\\debug.txt"
   \              6E5C62616C6C
   \              65746D696E69
   \              5C6465627567
   \              2E74787400  
   \   0000001D   000000             DC8 0, 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "%s : %i\\n">`:
   \   00000000   2573203A2025       DC8 "%s : %i\012"
   \              690A00      
   \   00000009   000000             DC8 0, 0, 0
   \   0000000C   303A5C7A6269       DC8 "0:\\zbin\\balletmini\\debug.txt"
   \              6E5C62616C6C
   \              65746D696E69
   \              5C6465627567
   \              2E74787400  
   \   00000029   000000             DC8 0, 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "0123456789abcdef">`:
   \   00000000   303132333435       DC8 "0123456789abcdef"
   \              363738396162
   \              6364656600  
   \   00000011   000000             DC8 0, 0, 0
   \   00000014   2564302500         DC8 "%d0%"
   \   00000019   000000             DC8 0, 0, 0
   \   0000001C   2564312500         DC8 "%d1%"
   \   00000021   000000             DC8 0, 0, 0

   Maximum stack usage in bytes:

     Function      CSTACK
     --------      ------
     CompareWchar      0
     ToWeb            28
     _rshort           0
     _rshort2          0
     ascii2ws         12
     char16to8         0
     char8to16         0
     char_win2utf8    44
     debuf             0
     debugf          276
     debugv           16
     extract_omstr    16
     freegstr          8
     globalstr        16
     oms2ws            0
     omstrcmp         20
     replacegstr      20
     sfind8           16
     strcmp_nocase     0
     utf82win          4
     ws2ascii         20


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     debugA                           12
     debugv                          100
     debugf                          144
     debuf                             4
     _rshort                          16
     _rshort2                         16
     ??strcmp_nocase_0                48
     omstrcmp                         92
     globalstr                        48
     freegstr                         28
     replacegstr                      64
     char16to8                       140
     char8to16                       128
     ws2ascii                         84
     ascii2ws                         56
     extract_omstr                    92
     utf82win                        184
     percent_symb                     20
     sfind8                           68
     char_win2utf8                   300
     ToWeb                           256
     oms2ws                          160
     CompareWchar                    176
     ??DataTable1                      4
     ?<Initializer for debugA>        12
     ?<Initializer for percent_symb>
                                      20
     ?<Constant "4:\\zbin\\balletmini\\de...">
                                      32
     ?<Constant "%s : %i\n">          44
     ?<Constant "0123456789abcdef">   36
      Others                          96

 
 2 292 bytes in segment CODE
   112 bytes in segment DATA_C
    32 bytes in segment DATA_I
    32 bytes in segment DATA_ID
    12 bytes in segment INITTAB
 
 2 208 bytes of CODE  memory (+ 96 bytes shared)
   144 bytes of CONST memory
    32 bytes of DATA  memory

Errors: none
Warnings: none
