##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    27/Dec/2010  18:19:49 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\BalletMini\readimg.c                          #
#    Command line    =  C:\arm\BalletMini\readimg.c -D NEWSGOLD -D ELKA -lC  #
#                       C:\arm\BalletMini\Release_ELKA\List\ -o              #
#                       C:\arm\BalletMini\Release_ELKA\Obj\ -s9 --no_unroll  #
#                       --no_inline --cpu_mode arm --endian little --cpu     #
#                       ARM926EJ-S --stack_align 4 --interwork -e --fpu      #
#                       None --dlib_config "C:\arm2\Embedded Workbench 4.0   #
#                       Evaluation\ARM\LIB\dl5tpainl8n.h" -I                 #
#                       "C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\" #
#    List file       =  C:\arm\BalletMini\Release_ELKA\List\readimg.lst      #
#    Object file     =  C:\arm\BalletMini\Release_ELKA\Obj\readimg.r79       #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\BalletMini\readimg.c
      1          #include "..\inc\swilib.h"
      2          #include "jpeglib/jpeglib.h"
      3          #include "jpeglib/jerror.h"
      4          #include "readimg.h"
      5          
      6          #define PNG_BYTES_TO_CHECK 8
      7          
      8          typedef struct {
      9            const char *p;
     10            char *row;
     11            char *img;
     12            IMGHDR * img_h;
     13          }PP;
     14          

   \                                 In segment CODE, align 4, keep-with-next
     15          void *xmalloc(int x,int n)
     16          {
   \                     xmalloc:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   0100A0E1           MOV      R0,R1
     17            return malloc(n);
   \   00000008   140000EF           SWI      +20
   \   0000000C   0080BDE8           POP      {PC}             ;; return
     18          }
     19          

   \                                 In segment CODE, align 4, keep-with-next
     20          void xmfree(int x,void* ptr)
     21          {
   \                     xmfree:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   0100A0E1           MOV      R0,R1
     22            mfree(ptr);
   \   00000008   150000EF           SWI      +21
     23          }
   \   0000000C   0080BDE8           POP      {PC}             ;; return
     24          

   \                                 In segment CODE, align 4, keep-with-next
     25          void read_data_fn(png_structp png_ptr, png_bytep data, png_size_t length)
     26          {
   \                     read_data_fn:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   \   00000008   0250A0E1           MOV      R5,R2
     27            PP *pp=png_get_io_ptr(png_ptr);
   \   0000000C   5E0100EF           SWI      +350
   \   00000010   0060A0E1           MOV      R6,R0
     28            memcpy(data,pp->p,length);
   \   00000014   001096E5           LDR      R1,[R6, #+0]
   \   00000018   0520A0E1           MOV      R2,R5
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   1E0100EF           SWI      +286
     29            pp->p+=length;
   \   00000024   000096E5           LDR      R0,[R6, #+0]
   \   00000028   000085E0           ADD      R0,R5,R0
   \   0000002C   000086E5           STR      R0,[R6, #+0]
     30          }
   \   00000030   7080BDE8           POP      {R4-R6,PC}       ;; return
     31          
     32          

   \                                 In segment CODE, align 4, keep-with-next
     33          IMGHDR *read_pngimg(const char *buf)
     34          {
   \                     read_pngimg:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   28D04DE2           SUB      SP,SP,#+40
     35            PP pp;
     36            IMGHDR * img_hc;
     37            png_structp png_ptr=NULL;
   \   00000008   0040A0E3           MOV      R4,#+0
   \   0000000C   00408DE5           STR      R4,[SP, #+0]
     38            png_infop info_ptr=NULL;
   \   00000010   04408DE5           STR      R4,[SP, #+4]
     39            png_uint_32 rowbytes;
     40            
     41            pp.p=buf;
   \   00000014   08008DE5           STR      R0,[SP, #+8]
     42            pp.row=NULL;
   \   00000018   0C408DE5           STR      R4,[SP, #+12]
     43            pp.img=NULL;
   \   0000001C   10408DE5           STR      R4,[SP, #+16]
     44            pp.img_h=NULL;  
   \   00000020   14408DE5           STR      R4,[SP, #+20]
     45            
     46            if  (!png_check_sig((png_bytep)pp.p,PNG_BYTES_TO_CHECK)) return 0; // не пнг
   \   00000024   0810A0E3           MOV      R1,#+8
   \   00000028   B20100EF           SWI      +434
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   BA00000A           BEQ      ??read_pngimg_0
     47            pp.p+=PNG_BYTES_TO_CHECK;
   \   00000034   08109DE5           LDR      R1,[SP, #+8]
     48            
     49            png_ptr = png_create_read_struct_2("1.2.5", (png_voidp)0, 0, 0, (png_voidp)0,(png_malloc_ptr)xmalloc,(png_free_ptr)xmfree);
   \   00000038   E8029FE5           LDR      R0,??read_pngimg_1  ;; xmfree
   \   0000003C   081081E2           ADD      R1,R1,#+8
   \   00000040   08108DE5           STR      R1,[SP, #+8]
   \   00000044   01002DE9           PUSH     {R0}
   \   00000048   DC029FE5           LDR      R0,??read_pngimg_1+0x4  ;; xmalloc
   \   0000004C   01002DE9           PUSH     {R0}
   \   00000050   0000A0E3           MOV      R0,#+0
   \   00000054   01002DE9           PUSH     {R0}
   \   00000058   0030A0E1           MOV      R3,R0
   \   0000005C   0020A0E1           MOV      R2,R0
   \   00000060   0010A0E1           MOV      R1,R0
   \   00000064   C4029FE5           LDR      R0,??read_pngimg_1+0x8  ;; `?<Constant "1.2.5">`
   \   00000068   A80100EF           SWI      +424
   \   0000006C   0C008DE5           STR      R0,[SP, #+12]
     50            if (!png_ptr) goto L_CLOSE_FILE;
   \   00000070   000050E3           CMP      R0,#+0
   \   00000074   0CD08DE2           ADD      SP,SP,#+12
   \   00000078   7900000A           BEQ      ??read_pngimg_2
     51            
     52            info_ptr = png_create_info_struct(png_ptr);
   \   0000007C   560100EF           SWI      +342
   \   00000080   04008DE5           STR      R0,[SP, #+4]
     53            if (!info_ptr)
   \   00000084   000050E3           CMP      R0,#+0
   \   00000088   0400001A           BNE      ??read_pngimg_3
     54            {
     55              png_destroy_read_struct(&png_ptr, (png_infopp)NULL, (png_infopp)NULL);
   \   0000008C   0020A0E3           MOV      R2,#+0
   \   00000090   0210A0E1           MOV      R1,R2
   \                     ??read_pngimg_4:
   \   00000094   0D00A0E1           MOV      R0,SP
   \   00000098   570100EF           SWI      +343
     56              goto L_CLOSE_FILE;
   \   0000009C   700000EA           B        ??read_pngimg_2
     57            }
     58            
     59            if (setjmp(png_jmpbuf(png_ptr)))
   \                     ??read_pngimg_3:
   \   000000A0   00009DE5           LDR      R0,[SP, #+0]
   \   000000A4   620100EF           SWI      +354
   \   000000A8   000050E3           CMP      R0,#+0
     60            {
     61              png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
   \   000000AC   0020A013           MOVNE    R2,#+0
   \   000000B0   04108D12           ADDNE    R1,SP,#+4
   \   000000B4   F6FFFF1A           BNE      ??read_pngimg_4
     62              goto L_CLOSE_FILE;
     63            }
     64            
     65            png_set_read_fn(png_ptr, &pp, read_data_fn);
   \   000000B8   74229FE5           LDR      R2,??read_pngimg_1+0xC  ;; read_data_fn
   \   000000BC   00009DE5           LDR      R0,[SP, #+0]
   \   000000C0   08108DE2           ADD      R1,SP,#+8
   \   000000C4   A90100EF           SWI      +425
     66            
     67            png_set_sig_bytes(png_ptr, PNG_BYTES_TO_CHECK);
   \   000000C8   00009DE5           LDR      R0,[SP, #+0]
   \   000000CC   0810A0E3           MOV      R1,#+8
   \   000000D0   580100EF           SWI      +344
     68            png_read_info(png_ptr, info_ptr);
   \   000000D4   04109DE5           LDR      R1,[SP, #+4]
   \   000000D8   00009DE5           LDR      R0,[SP, #+0]
   \   000000DC   590100EF           SWI      +345
     69            
     70            png_uint_32 width, height;
     71            int bit_depth, color_type;
     72            
     73            png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type, 0, 0, 0);
   \   000000E0   0000A0E3           MOV      R0,#+0
   \   000000E4   01002DE9           PUSH     {R0}
   \   000000E8   01002DE9           PUSH     {R0}
   \   000000EC   01002DE9           PUSH     {R0}
   \   000000F0   30008DE2           ADD      R0,SP,#+48
   \   000000F4   01002DE9           PUSH     {R0}
   \   000000F8   30008DE2           ADD      R0,SP,#+48
   \   000000FC   01002DE9           PUSH     {R0}
   \   00000100   18109DE5           LDR      R1,[SP, #+24]
   \   00000104   30308DE2           ADD      R3,SP,#+48
   \   00000108   14009DE5           LDR      R0,[SP, #+20]
   \   0000010C   2C208DE2           ADD      R2,SP,#+44
   \   00000110   5A0100EF           SWI      +346
     74            
     75            if (bit_depth < 8) png_set_gray_1_2_4_to_8(png_ptr);
   \   00000114   34009DE5           LDR      R0,[SP, #+52]
   \   00000118   14D08DE2           ADD      SP,SP,#+20
   \   0000011C   080050E3           CMP      R0,#+8
   \   00000120   010000AA           BGE      ??read_pngimg_5
   \   00000124   00009DE5           LDR      R0,[SP, #+0]
   \   00000128   D60100EF           SWI      +470
     76              
     77            if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))
   \                     ??read_pngimg_5:
   \   0000012C   00009DE5           LDR      R0,[SP, #+0]
   \   00000130   04109DE5           LDR      R1,[SP, #+4]
   \   00000134   1020A0E3           MOV      R2,#+16
   \   00000138   AC0100EF           SWI      +428
   \   0000013C   000050E3           CMP      R0,#+0
   \   00000140   0100000A           BEQ      ??read_pngimg_6
     78              png_set_tRNS_to_alpha(png_ptr); 
   \   00000144   00009DE5           LDR      R0,[SP, #+0]
   \   00000148   AD0100EF           SWI      +429
     79            
     80            if (bit_depth == 16) png_set_strip_16(png_ptr);
   \                     ??read_pngimg_6:
   \   0000014C   20009DE5           LDR      R0,[SP, #+32]
   \   00000150   100050E3           CMP      R0,#+16
   \   00000154   0100001A           BNE      ??read_pngimg_7
   \   00000158   00009DE5           LDR      R0,[SP, #+0]
   \   0000015C   AF0100EF           SWI      +431
     81            
     82            if (bit_depth < 8) png_set_packing(png_ptr);
   \                     ??read_pngimg_7:
   \   00000160   20009DE5           LDR      R0,[SP, #+32]
   \   00000164   080050E3           CMP      R0,#+8
   \   00000168   010000AA           BGE      ??read_pngimg_8
   \   0000016C   00009DE5           LDR      R0,[SP, #+0]
   \   00000170   B00100EF           SWI      +432
     83            
     84            if (color_type == PNG_COLOR_TYPE_PALETTE)
   \                     ??read_pngimg_8:
   \   00000174   24009DE5           LDR      R0,[SP, #+36]
   \   00000178   030050E3           CMP      R0,#+3
   \   0000017C   0100001A           BNE      ??read_pngimg_9
     85              png_set_palette_to_rgb(png_ptr);
   \   00000180   00009DE5           LDR      R0,[SP, #+0]
   \   00000184   AB0100EF           SWI      +427
     86            
     87            if (color_type == PNG_COLOR_TYPE_GRAY_ALPHA || color_type == PNG_COLOR_TYPE_GRAY)
   \                     ??read_pngimg_9:
   \   00000188   24009DE5           LDR      R0,[SP, #+36]
   \   0000018C   040050E3           CMP      R0,#+4
   \   00000190   00005013           CMPNE    R0,#+0
   \   00000194   0100001A           BNE      ??read_pngimg_10
     88              png_set_gray_to_rgb(png_ptr);
   \   00000198   00009DE5           LDR      R0,[SP, #+0]
   \   0000019C   B10100EF           SWI      +433
     89            
     90            png_set_filler(png_ptr,0xFF,PNG_FILLER_AFTER);
   \                     ??read_pngimg_10:
   \   000001A0   00009DE5           LDR      R0,[SP, #+0]
   \   000001A4   0120A0E3           MOV      R2,#+1
   \   000001A8   FF10A0E3           MOV      R1,#+255
   \   000001AC   AE0100EF           SWI      +430
     91            png_read_update_info(png_ptr, info_ptr);
   \   000001B0   04109DE5           LDR      R1,[SP, #+4]
   \   000001B4   00009DE5           LDR      R0,[SP, #+0]
     92            
     93            rowbytes = png_get_rowbytes(png_ptr, info_ptr);
     94            
     95            pp.row=malloc(rowbytes);
     96            pp.img_h=img_hc=malloc(sizeof(IMGHDR));
     97            
     98            {
     99              unsigned short *iimg=(unsigned short *)(pp.img=malloc(width*height*sizeof(unsigned short)));
    100              for (unsigned int y = 0; y<height; y++)
   \   000001B8   0070A0E3           MOV      R7,#+0
   \   000001BC   AA0100EF           SWI      +426
   \   000001C0   00009DE5           LDR      R0,[SP, #+0]
   \   000001C4   04109DE5           LDR      R1,[SP, #+4]
   \   000001C8   5F0100EF           SWI      +351
   \   000001CC   140000EF           SWI      +20
   \   000001D0   0C008DE5           STR      R0,[SP, #+12]
   \   000001D4   0C00A0E3           MOV      R0,#+12
   \   000001D8   140000EF           SWI      +20
   \   000001DC   0050A0E1           MOV      R5,R0
   \   000001E0   14508DE5           STR      R5,[SP, #+20]
   \   000001E4   18009DE5           LDR      R0,[SP, #+24]
   \   000001E8   1C109DE5           LDR      R1,[SP, #+28]
   \   000001EC   910000E0           MUL      R0,R1,R0
   \   000001F0   8000A0E1           LSL      R0,R0,#+1
   \   000001F4   140000EF           SWI      +20
   \   000001F8   10008DE5           STR      R0,[SP, #+16]
   \   000001FC   0060A0E1           MOV      R6,R0
   \   00000200   1C009DE5           LDR      R0,[SP, #+28]
   \   00000204   000050E3           CMP      R0,#+0
   \   00000208   1F00001A           BNE      ??read_pngimg_11
    101              {
    102                png_read_row(png_ptr, (png_bytep)pp.row, NULL);
    103                for (unsigned int x = 0; x<width; x++)
    104                {
    105                  if (pp.row[x*4+3]<128)
    106                    *iimg++=0xE000;
    107                  else
    108                  {
    109                    unsigned int c=((pp.row[x*4+0]<<8)&0xF800);
    110                    c|=((pp.row[x*4+1]<<3)&0x7E0);
    111                    c|=((pp.row[x*4+2]>>3)&0x1F);
    112                    *iimg++=c;
    113                  }
    114                }
    115              }
    116            }
    117            pp.img_h->bpnum=8;
   \                     ??read_pngimg_12:
   \   0000020C   14009DE5           LDR      R0,[SP, #+20]
   \   00000210   0810A0E3           MOV      R1,#+8
   \   00000214   041080E5           STR      R1,[R0, #+4]
    118            pp.img_h->w=width;
   \   00000218   14009DE5           LDR      R0,[SP, #+20]
   \   0000021C   18109DE5           LDR      R1,[SP, #+24]
   \   00000220   B010C0E1           STRH     R1,[R0, #+0]
    119            pp.img_h->h=height;
   \   00000224   14009DE5           LDR      R0,[SP, #+20]
   \   00000228   1C109DE5           LDR      R1,[SP, #+28]
   \   0000022C   B210C0E1           STRH     R1,[R0, #+2]
    120            pp.img_h->bitmap=pp.img;
   \   00000230   14009DE5           LDR      R0,[SP, #+20]
   \   00000234   10109DE5           LDR      R1,[SP, #+16]
   \   00000238   081080E5           STR      R1,[R0, #+8]
    121            
    122            png_read_end(png_ptr, info_ptr);
   \   0000023C   04109DE5           LDR      R1,[SP, #+4]
   \   00000240   00009DE5           LDR      R0,[SP, #+0]
   \   00000244   5D0100EF           SWI      +349
    123            png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
   \   00000248   0020A0E3           MOV      R2,#+0
   \   0000024C   04108DE2           ADD      R1,SP,#+4
   \   00000250   0D00A0E1           MOV      R0,SP
   \   00000254   570100EF           SWI      +343
    124            if (!pp.img)
   \   00000258   10009DE5           LDR      R0,[SP, #+16]
   \   0000025C   000050E3           CMP      R0,#+0
   \   00000260   2B00001A           BNE      ??read_pngimg_13
    125            {
    126            L_CLOSE_FILE:
    127              mfree(pp.row);
   \                     ??read_pngimg_2:
   \   00000264   0C009DE5           LDR      R0,[SP, #+12]
   \   00000268   150000EF           SWI      +21
    128              mfree(pp.img);
   \   0000026C   10009DE5           LDR      R0,[SP, #+16]
   \   00000270   150000EF           SWI      +21
    129              mfree(pp.img_h);
   \   00000274   14009DE5           LDR      R0,[SP, #+20]
   \   00000278   150000EF           SWI      +21
    130              return NULL;
   \   0000027C   0000A0E3           MOV      R0,#+0
   \   00000280   28D08DE2           ADD      SP,SP,#+40
   \   00000284   F080BDE8           POP      {R4-R7,PC}
    131            }
   \                     ??read_pngimg_14:
   \   00000288   017087E2           ADD      R7,R7,#+1
   \                     ??read_pngimg_11:
   \   0000028C   1C009DE5           LDR      R0,[SP, #+28]
   \   00000290   000057E1           CMP      R7,R0
   \   00000294   DCFFFF2A           BCS      ??read_pngimg_12
   \   00000298   0C109DE5           LDR      R1,[SP, #+12]
   \   0000029C   00009DE5           LDR      R0,[SP, #+0]
   \   000002A0   0020A0E3           MOV      R2,#+0
   \   000002A4   600100EF           SWI      +352
   \   000002A8   18109DE5           LDR      R1,[SP, #+24]
   \   000002AC   0400A0E1           MOV      R0,R4
   \   000002B0   000051E3           CMP      R1,#+0
   \   000002B4   7ECEA0E3           MOV      R12,#+2016
   \   000002B8   0B00001A           BNE      ??read_pngimg_15
   \   000002BC   F1FFFFEA           B        ??read_pngimg_14
   \                     ??read_pngimg_16:
   \   000002C0   0020D1E5           LDRB     R2,[R1, #+0]
   \   000002C4   F83CA0E3           MOV      R3,#+63488
   \   000002C8   022403E0           AND      R2,R3,R2, LSL #+8
   \   000002CC   0130D1E5           LDRB     R3,[R1, #+1]
   \   000002D0   0210D1E5           LDRB     R1,[R1, #+2]
   \   000002D4   83310CE0           AND      R3,R12,R3, LSL #+3
   \   000002D8   022083E1           ORR      R2,R3,R2
   \   000002DC   A111A0E1           LSR      R1,R1,#+3
   \   000002E0   021081E1           ORR      R1,R1,R2
   \                     ??read_pngimg_17:
   \   000002E4   ........           STRH     R1,[R6], #+2
   \   000002E8   010080E2           ADD      R0,R0,#+1
   \                     ??read_pngimg_15:
   \   000002EC   18109DE5           LDR      R1,[SP, #+24]
   \   000002F0   010050E1           CMP      R0,R1
   \   000002F4   E3FFFF2A           BCS      ??read_pngimg_14
   \   000002F8   0C109DE5           LDR      R1,[SP, #+12]
   \   000002FC   001181E0           ADD      R1,R1,R0, LSL #+2
   \   00000300   0320D1E5           LDRB     R2,[R1, #+3]
   \   00000304   800052E3           CMP      R2,#+128
   \   00000308   ECFFFF2A           BCS      ??read_pngimg_16
   \   0000030C   E01CA0E3           MOV      R1,#+57344
   \   00000310   F3FFFFEA           B        ??read_pngimg_17
    132            mfree(pp.row);
   \                     ??read_pngimg_13:
   \   00000314   0C009DE5           LDR      R0,[SP, #+12]
   \   00000318   150000EF           SWI      +21
    133            return (img_hc);
   \   0000031C   0500A0E1           MOV      R0,R5
   \                     ??read_pngimg_0:
   \   00000320   28D08DE2           ADD      SP,SP,#+40       ;; stack cleaning
   \   00000324   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??read_pngimg_1:
   \   00000328   ........           DC32     xmfree
   \   0000032C   ........           DC32     xmalloc
   \   00000330   ........           DC32     `?<Constant "1.2.5">`
   \   00000334   ........           DC32     read_data_fn
    134          }
    135          
    136          struct my_error_mgr {
    137            struct jpeg_error_mgr pub;	/* "public" fields */
    138          
    139            jmp_buf setjmp_buffer;	/* for return to caller */
    140          };
    141          
    142          typedef struct my_error_mgr * my_error_ptr;
    143          
    144          extern void longjmp(jmp_buf, int);

   \                                 In segment CODE, align 4, keep-with-next
    145          METHODDEF(void)
    146          my_error_exit (j_common_ptr cinfo)
    147          {
   \                     my_error_exit:
   \   00000000   10402DE9           PUSH     {R4,LR}
    148            my_error_ptr myerr = (my_error_ptr) cinfo->err;
   \   00000004   004090E5           LDR      R4,[R0, #+0]
    149            (*cinfo->err->output_message) (cinfo);
   \   00000008   081094E5           LDR      R1,[R4, #+8]
   \   0000000C   31FF2FE1           BLX      R1
    150            longjmp(myerr->setjmp_buffer, 1);
   \   00000010   0110A0E3           MOV      R1,#+1
   \   00000014   840084E2           ADD      R0,R4,#+132
   \   00000018   290200EF           SWI      +553
    151          }
   \   0000001C   1080BDE8           POP      {R4,PC}          ;; return
    152          

   \                                 In segment DATA_C, align 1, align-sorted
    153          const char jpg_hdr[]={0xFF, 0xD8};
   \                     jpg_hdr:
   \   00000000   FFD8               DC8 255, 216

   \                                 In segment CODE, align 4, keep-with-next
    154          IMGHDR *read_jpgimg(const char *buf)
    155          {
    156            int img_w, img_h;
    157            struct jpeg_decompress_struct cinfo;
    158            struct my_error_mgr jerr;
    159          
    160            IMGHDR * img_hc;
    161            unsigned short *img, *iimg;
    162            JSAMPARRAY buffer;
    163            char *row;
    164            
    165            if (memcmp((void *)buf,(void *)jpg_hdr,sizeof(jpg_hdr))) return NULL;
   \                     read_jpgimg:
   \   00000000   AC119FE5           LDR      R1,??read_jpgimg_0  ;; jpg_hdr
   \   00000004   E0472DE9           PUSH     {R5-R10,LR}
   \   00000008   9FDF4DE2           SUB      SP,SP,#+636
   \   0000000C   0050A0E1           MOV      R5,R0
   \   00000010   0220A0E3           MOV      R2,#+2
   \   00000014   1C0100EF           SWI      +284
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0000A013           MOVNE    R0,#+0
   \   00000020   5400001A           BNE      ??read_jpgimg_1
    166            
    167            img=0;
    168            img_hc=0;
    169            buffer=0;
    170            zeromem(&cinfo,sizeof(struct jpeg_decompress_struct));
   \   00000024   731FA0E3           MOV      R1,#+460
   \   00000028   0D00A0E1           MOV      R0,SP
   \   0000002C   1D0100EF           SWI      +285
    171            zeromem(&jerr,sizeof(struct my_error_mgr));
   \   00000030   B010A0E3           MOV      R1,#+176
   \   00000034   730F8DE2           ADD      R0,SP,#+460
   \   00000038   1D0100EF           SWI      +285
    172            
    173            cinfo.err=jpeg_std_error(&jerr.pub);
   \   0000003C   730F8DE2           ADD      R0,SP,#+460
   \   00000040   ........           _BLF     jpeg_std_error,??jpeg_std_error??rA
    174            jerr.pub.error_exit = my_error_exit;
   \   00000044   6C119FE5           LDR      R1,??read_jpgimg_0+0x4  ;; my_error_exit
   \   00000048   0080A0E3           MOV      R8,#+0
   \   0000004C   0070A0E3           MOV      R7,#+0
   \   00000050   00008DE5           STR      R0,[SP, #+0]
   \   00000054   CC118DE5           STR      R1,[SP, #+460]
    175            
    176            if (setjmp(jerr.setjmp_buffer))
   \   00000058   940F8DE2           ADD      R0,SP,#+592
   \   0000005C   620100EF           SWI      +354
   \   00000060   000050E3           CMP      R0,#+0
   \   00000064   0200000A           BEQ      ??read_jpgimg_2
    177            {
    178              jpeg_destroy_decompress(&cinfo);
   \   00000068   0D00A0E1           MOV      R0,SP
   \   0000006C   ........           _BLF     jpeg_destroy_decompress,??jpeg_destroy_decompress??rA
    179              goto L_ERROR;
   \   00000070   3A0000EA           B        ??read_jpgimg_3
    180            }
    181            jpeg_create_decompress(&cinfo);
   \                     ??read_jpgimg_2:
   \   00000074   732FA0E3           MOV      R2,#+460
   \   00000078   3E10A0E3           MOV      R1,#+62
   \   0000007C   0D00A0E1           MOV      R0,SP
   \   00000080   ........           _BLF     jpeg_CreateDecompress,??jpeg_CreateDecompress??rA
    182            
    183            jpeg_stdio_src(&cinfo, (void *)buf);
   \   00000084   0510A0E1           MOV      R1,R5
   \   00000088   0D00A0E1           MOV      R0,SP
   \   0000008C   ........           _BLF     jpeg_stdio_src,??jpeg_stdio_src??rA
    184            jpeg_read_header(&cinfo, TRUE);
   \   00000090   0110A0E3           MOV      R1,#+1
   \   00000094   0D00A0E1           MOV      R0,SP
   \   00000098   ........           _BLF     jpeg_read_header,??jpeg_read_header??rA
    185            jpeg_start_decompress(&cinfo);
   \   0000009C   0D00A0E1           MOV      R0,SP
   \   000000A0   ........           _BLF     jpeg_start_decompress,??jpeg_start_decompress??rA
    186            
    187            img_w=cinfo.output_width;
   \   000000A4   6C509DE5           LDR      R5,[SP, #+108]
    188            img_h=cinfo.output_height;
   \   000000A8   70609DE5           LDR      R6,[SP, #+112]
    189            
    190            img_hc=malloc(sizeof(IMGHDR));
   \   000000AC   0C00A0E3           MOV      R0,#+12
   \   000000B0   140000EF           SWI      +20
   \   000000B4   0070A0E1           MOV      R7,R0
    191            iimg=img=malloc(img_w*img_h*sizeof(unsigned short));
   \   000000B8   960500E0           MUL      R0,R6,R5
   \   000000BC   8000A0E1           LSL      R0,R0,#+1
   \   000000C0   140000EF           SWI      +20
    192            buffer = (*cinfo.mem->alloc_sarray)  
    193          		((j_common_ptr) &cinfo, JPOOL_IMAGE, img_w*cinfo.output_components, 1);
   \   000000C4   04A09DE5           LDR      R10,[SP, #+4]
   \   000000C8   0080A0E1           MOV      R8,R0
   \   000000CC   78009DE5           LDR      R0,[SP, #+120]
   \   000000D0   08A09AE5           LDR      R10,[R10, #+8]
   \   000000D4   0130A0E3           MOV      R3,#+1
   \   000000D8   900502E0           MUL      R2,R0,R5
   \   000000DC   0110A0E3           MOV      R1,#+1
   \   000000E0   0D00A0E1           MOV      R0,SP
   \   000000E4   3AFF2FE1           BLX      R10
   \   000000E8   00A0A0E1           MOV      R10,R0
   \   000000EC   88009DE5           LDR      R0,[SP, #+136]
   \   000000F0   0890A0E1           MOV      R9,R8
   \   000000F4   060050E1           CMP      R0,R6
   \   000000F8   0D00002A           BCS      ??read_jpgimg_4
    194            
    195            while (cinfo.output_scanline < img_h) 
    196            {
    197              jpeg_read_scanlines(&cinfo, buffer, 1);
   \                     ??read_jpgimg_5:
   \   000000FC   0120A0E3           MOV      R2,#+1
   \   00000100   0A10A0E1           MOV      R1,R10
   \   00000104   0D00A0E1           MOV      R0,SP
   \   00000108   ........           _BLF     jpeg_read_scanlines,??jpeg_read_scanlines??rA
    198              row=buffer[0];
   \   0000010C   00009AE5           LDR      R0,[R10, #+0]
    199              for (int x=0; x<img_w; x++)
   \   00000110   0010A0E3           MOV      R1,#+0
   \   00000114   010055E3           CMP      R5,#+1
   \   00000118   7ECEA0E3           MOV      R12,#+2016
   \   0000011C   010000BA           BLT      ??read_jpgimg_6
   \                     ??read_jpgimg_7:
   \   00000120   050051E1           CMP      R1,R5
   \   00000124   150000BA           BLT      ??read_jpgimg_8
   \                     ??read_jpgimg_6:
   \   00000128   88009DE5           LDR      R0,[SP, #+136]
   \   0000012C   060050E1           CMP      R0,R6
   \   00000130   F1FFFF3A           BCC      ??read_jpgimg_5
    200              {
    201                unsigned int c;
    202                c=((row[0]<<8)&0xF800);
    203                c|=((row[1]<<3)&0x7E0);
    204                c|=((row[2]>>3)&0x1F);
    205                row+=3;
    206                *iimg++=c;
    207              }
    208            }
    209            jpeg_finish_decompress(&cinfo);
   \                     ??read_jpgimg_4:
   \   00000134   0D00A0E1           MOV      R0,SP
   \   00000138   ........           _BLF     jpeg_finish_decompress,??jpeg_finish_decompress??rA
    210            jpeg_destroy_decompress(&cinfo);
   \   0000013C   0D00A0E1           MOV      R0,SP
   \   00000140   ........           _BLF     jpeg_destroy_decompress,??jpeg_destroy_decompress??rA
    211            img_hc->bitmap=(char *)img;
   \   00000144   088087E5           STR      R8,[R7, #+8]
    212            img_hc->bpnum=8;
   \   00000148   0800A0E3           MOV      R0,#+8
   \   0000014C   040087E5           STR      R0,[R7, #+4]
    213            img_hc->w=img_w;
   \   00000150   B050C7E1           STRH     R5,[R7, #+0]
    214            img_hc->h=img_h;
   \   00000154   B260C7E1           STRH     R6,[R7, #+2]
    215            if (!img)
   \   00000158   000058E3           CMP      R8,#+0
   \   0000015C   0400001A           BNE      ??read_jpgimg_9
    216            {
    217            L_ERROR:
    218              mfree(img_hc);
   \                     ??read_jpgimg_3:
   \   00000160   0700A0E1           MOV      R0,R7
   \   00000164   150000EF           SWI      +21
    219              img_hc=NULL;
    220              mfree(img);
   \   00000168   0800A0E1           MOV      R0,R8
   \   0000016C   150000EF           SWI      +21
   \   00000170   0070A0E3           MOV      R7,#+0
    221            } 
    222            return img_hc;
   \                     ??read_jpgimg_9:
   \   00000174   0700A0E1           MOV      R0,R7
   \                     ??read_jpgimg_1:
   \   00000178   9FDF8DE2           ADD      SP,SP,#+636      ;; stack cleaning
   \   0000017C   E087BDE8           POP      {R5-R10,PC}
   \                     ??read_jpgimg_8:
   \   00000180   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000184   F83CA0E3           MOV      R3,#+63488
   \   00000188   011081E2           ADD      R1,R1,#+1
   \   0000018C   022403E0           AND      R2,R3,R2, LSL #+8
   \   00000190   0130D0E5           LDRB     R3,[R0, #+1]
   \   00000194   83310CE0           AND      R3,R12,R3, LSL #+3
   \   00000198   022083E1           ORR      R2,R3,R2
   \   0000019C   0230D0E5           LDRB     R3,[R0, #+2]
   \   000001A0   030080E2           ADD      R0,R0,#+3
   \   000001A4   A331A0E1           LSR      R3,R3,#+3
   \   000001A8   022083E1           ORR      R2,R3,R2
   \   000001AC   ........           STRH     R2,[R9], #+2
   \   000001B0   DAFFFFEA           B        ??read_jpgimg_7
   \                     ??read_jpgimg_0:
   \   000001B4   ........           DC32     jpg_hdr
   \   000001B8   ........           DC32     my_error_exit
    223          }
    224          

   \                                 In segment CODE, align 4, keep-with-next
    225          IMGHDR *ConvertRGBAToRGB8(const char *buf, int width, int height)
    226          {
   \                     ConvertRGBAToRGB8:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0050A0E1           MOV      R5,R0
   \   00000008   0160A0E1           MOV      R6,R1
   \   0000000C   0240A0E1           MOV      R4,R2
    227            IMGHDR * img_hc=malloc(sizeof(IMGHDR));
   \   00000010   0C00A0E3           MOV      R0,#+12
   \   00000014   140000EF           SWI      +20
   \   00000018   0070A0E1           MOV      R7,R0
    228            unsigned short *iimg=malloc(width*height*sizeof(unsigned short));
   \   0000001C   940600E0           MUL      R0,R4,R6
   \   00000020   8000A0E1           LSL      R0,R0,#+1
   \   00000024   140000EF           SWI      +20
    229            img_hc->w=width;
   \   00000028   B060C7E1           STRH     R6,[R7, #+0]
    230            img_hc->h=height;
   \   0000002C   B240C7E1           STRH     R4,[R7, #+2]
    231            img_hc->bpnum=8;
   \   00000030   0810A0E3           MOV      R1,#+8
   \   00000034   041087E5           STR      R1,[R7, #+4]
    232            img_hc->bitmap=(char *)iimg;
   \   00000038   080087E5           STR      R0,[R7, #+8]
    233            
    234            for (unsigned int y = 0; y<height; y++)
   \   0000003C   0010A0E3           MOV      R1,#+0
   \   00000040   000054E3           CMP      R4,#+0
   \   00000044   0200001A           BNE      ??ConvertRGBAToRGB8_0
    235            {
    236              for (unsigned int x = 0; x<width; x++)
    237              {
    238                if (buf[y*width*4+x*4+0]<255)
    239                  *iimg++=0xE000;
    240                else
    241                {
    242                  unsigned int c=((buf[y*width*4+x*4+1]<<8)&0xF800);
    243                  c|=((buf[y*width*4+x*4+2]<<3)&0x7E0);
    244                  c|=((buf[y*width*4+x*4+3]>>3)&0x1F);
    245                  *iimg++=c;
    246                }
    247              }
    248            }
    249            return (img_hc);
   \                     ??ConvertRGBAToRGB8_1:
   \   00000048   0700A0E1           MOV      R0,R7
   \   0000004C   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??ConvertRGBAToRGB8_2:
   \   00000050   011081E2           ADD      R1,R1,#+1
   \                     ??ConvertRGBAToRGB8_0:
   \   00000054   040051E1           CMP      R1,R4
   \   00000058   FAFFFF2A           BCS      ??ConvertRGBAToRGB8_1
   \   0000005C   0020A0E3           MOV      R2,#+0
   \   00000060   000056E3           CMP      R6,#+0
   \   00000064   0C00001A           BNE      ??ConvertRGBAToRGB8_3
   \   00000068   F8FFFFEA           B        ??ConvertRGBAToRGB8_2
   \                     ??ConvertRGBAToRGB8_4:
   \   0000006C   01C0D3E5           LDRB     R12,[R3, #+1]
   \   00000070   F8ECA0E3           MOV      LR,#+63488
   \   00000074   7E8EA0E3           MOV      R8,#+2016
   \   00000078   0CC40EE0           AND      R12,LR,R12, LSL #+8
   \   0000007C   02E0D3E5           LDRB     LR,[R3, #+2]
   \   00000080   0330D3E5           LDRB     R3,[R3, #+3]
   \   00000084   8E8108E0           AND      R8,R8,LR, LSL #+3
   \   00000088   0C8088E1           ORR      R8,R8,R12
   \   0000008C   A331A0E1           LSR      R3,R3,#+3
   \   00000090   083083E1           ORR      R3,R3,R8
   \                     ??ConvertRGBAToRGB8_5:
   \   00000094   ........           STRH     R3,[R0], #+2
   \   00000098   012082E2           ADD      R2,R2,#+1
   \                     ??ConvertRGBAToRGB8_3:
   \   0000009C   060052E1           CMP      R2,R6
   \   000000A0   EAFFFF2A           BCS      ??ConvertRGBAToRGB8_2
   \   000000A4   962123E0           MLA      R3,R6,R1,R2
   \   000000A8   033185E0           ADD      R3,R5,R3, LSL #+2
   \   000000AC   0080D3E5           LDRB     R8,[R3, #+0]
   \   000000B0   FF0058E3           CMP      R8,#+255
   \   000000B4   ECFFFF0A           BEQ      ??ConvertRGBAToRGB8_4
   \   000000B8   E03CA0E3           MOV      R3,#+57344
   \   000000BC   F4FFFFEA           B        ??ConvertRGBAToRGB8_5
    250          }
    251          

   \                                 In segment CODE, align 4, keep-with-next
    252          IMGHDR *CreateFrame(int width, int height, const char *color)
    253          {
   \                     CreateFrame:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0270A0E1           MOV      R7,R2
    254            int color_c;
    255            IMGHDR * img_hc=malloc(sizeof(IMGHDR));
   \   00000010   0C00A0E3           MOV      R0,#+12
   \   00000014   140000EF           SWI      +20
   \   00000018   0060A0E1           MOV      R6,R0
    256            char *iimg=malloc(width*height);
   \   0000001C   950400E0           MUL      R0,R5,R4
   \   00000020   140000EF           SWI      +20
    257            img_hc->w=width;
   \   00000024   B040C6E1           STRH     R4,[R6, #+0]
    258            img_hc->h=height;
   \   00000028   B250C6E1           STRH     R5,[R6, #+2]
    259            img_hc->bpnum=5;
   \   0000002C   0510A0E3           MOV      R1,#+5
   \   00000030   041086E5           STR      R1,[R6, #+4]
    260            img_hc->bitmap=iimg;
   \   00000034   080086E5           STR      R0,[R6, #+8]
    261            
    262            if (color[3]<50) color_c=0xC0;
   \   00000038   0310D7E5           LDRB     R1,[R7, #+3]
   \   0000003C   320051E3           CMP      R1,#+50
   \   00000040   C010A033           MOVCC    R1,#+192
   \   00000044   0700003A           BCC      ??CreateFrame_0
    263            else
    264            {
    265              unsigned char c=color[0]&0xE0;
    266              c|=(color[1]>>3)&0x1C;
    267              c|=(color[2]>>6)&0x3;
    268              color_c=c;
   \   00000048   0010D7E5           LDRB     R1,[R7, #+0]
   \   0000004C   0120D7E5           LDRB     R2,[R7, #+1]
   \   00000050   1C30A0E3           MOV      R3,#+28
   \   00000054   E01001E2           AND      R1,R1,#0xE0
   \   00000058   A22103E0           AND      R2,R3,R2, LSR #+3
   \   0000005C   011082E1           ORR      R1,R2,R1
   \   00000060   0220D7E5           LDRB     R2,[R7, #+2]
   \   00000064   221381E1           ORR      R1,R1,R2, LSR #+6
    269            }
    270            for (unsigned int y = 0; y<height; y++)
   \                     ??CreateFrame_0:
   \   00000068   0020A0E3           MOV      R2,#+0
   \   0000006C   000055E3           CMP      R5,#+0
   \   00000070   0200001A           BNE      ??CreateFrame_1
    271            {
    272              for (unsigned int x = 0; x<width; x++)
    273              {
    274                if (x==0 || y==0 || x==width-1 || y==height-1)
    275                  *iimg++=color_c;
    276                else
    277                  *iimg++=0xC0;
    278              }
    279            }
    280            return (img_hc);  
   \                     ??CreateFrame_2:
   \   00000074   0600A0E1           MOV      R0,R6
   \   00000078   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??CreateFrame_3:
   \   0000007C   012082E2           ADD      R2,R2,#+1
   \                     ??CreateFrame_1:
   \   00000080   050052E1           CMP      R2,R5
   \   00000084   FAFFFF2A           BCS      ??CreateFrame_2
   \   00000088   0030A0E3           MOV      R3,#+0
   \   0000008C   000054E3           CMP      R4,#+0
   \   00000090   0100001A           BNE      ??CreateFrame_4
   \   00000094   F8FFFFEA           B        ??CreateFrame_3
   \                     ??CreateFrame_5:
   \   00000098   013083E2           ADD      R3,R3,#+1
   \                     ??CreateFrame_4:
   \   0000009C   040053E1           CMP      R3,R4
   \   000000A0   F5FFFF2A           BCS      ??CreateFrame_3
   \   000000A4   000053E3           CMP      R3,#+0
   \   000000A8   00005213           CMPNE    R2,#+0
   \   000000AC   01704412           SUBNE    R7,R4,#+1
   \   000000B0   07005311           CMPNE    R3,R7
   \   000000B4   01704512           SUBNE    R7,R5,#+1
   \   000000B8   07005211           CMPNE    R2,R7
   \   000000BC   C070A013           MOVNE    R7,#+192
   \   000000C0   ........           STRBNE   R7,[R0], #+1
   \   000000C4   ........           STRBEQ   R1,[R0], #+1
   \   000000C8   F2FFFFEA           B        ??CreateFrame_5
    281          }
    282          

   \                                 In segment CODE, align 4, keep-with-next
    283          IMGHDR *CreateDelimiter(int width, int height, const char *color)
    284          {
   \                     CreateDelimiter:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0270A0E1           MOV      R7,R2
    285            int color_c;
    286            IMGHDR * img_hc=malloc(sizeof(IMGHDR));
   \   00000010   0C00A0E3           MOV      R0,#+12
   \   00000014   140000EF           SWI      +20
   \   00000018   0060A0E1           MOV      R6,R0
    287            char *iimg=malloc(width*height);
   \   0000001C   950400E0           MUL      R0,R5,R4
   \   00000020   140000EF           SWI      +20
    288            img_hc->w=width;
   \   00000024   B040C6E1           STRH     R4,[R6, #+0]
    289            img_hc->h=height;
   \   00000028   B250C6E1           STRH     R5,[R6, #+2]
    290            img_hc->bpnum=5;
   \   0000002C   0510A0E3           MOV      R1,#+5
   \   00000030   041086E5           STR      R1,[R6, #+4]
    291            img_hc->bitmap=iimg;
   \   00000034   080086E5           STR      R0,[R6, #+8]
    292            
    293            if (color[3]<50) color_c=0xC0;
   \   00000038   0310D7E5           LDRB     R1,[R7, #+3]
   \   0000003C   320051E3           CMP      R1,#+50
   \   00000040   C010A033           MOVCC    R1,#+192
   \   00000044   0700003A           BCC      ??CreateDelimiter_0
    294            else
    295            {
    296              unsigned char c=color[0]&0xE0;
    297              c|=color[1]&0x1C;
    298              c|=color[2]&0x3;
    299              color_c=c;
   \   00000048   0010D7E5           LDRB     R1,[R7, #+0]
   \   0000004C   0120D7E5           LDRB     R2,[R7, #+1]
   \   00000050   E01001E2           AND      R1,R1,#0xE0
   \   00000054   1C2002E2           AND      R2,R2,#0x1C
   \   00000058   011082E1           ORR      R1,R2,R1
   \   0000005C   0220D7E5           LDRB     R2,[R7, #+2]
   \   00000060   032002E2           AND      R2,R2,#0x3
   \   00000064   011082E1           ORR      R1,R2,R1
    300            }
    301            for (unsigned int y = 0; y<height; y++)
   \                     ??CreateDelimiter_0:
   \   00000068   0020A0E3           MOV      R2,#+0
   \   0000006C   000055E3           CMP      R5,#+0
   \   00000070   0200001A           BNE      ??CreateDelimiter_1
    302            {
    303              for (unsigned int x = 0; x<width; x++)
    304              {
    305                if (y==height>>1 && x>3 && x<(width-3))
    306                  *iimg++=color_c;
    307                else
    308                  *iimg++=0xC0;
    309              }
    310            }
    311            return (img_hc);  
   \                     ??CreateDelimiter_2:
   \   00000074   0600A0E1           MOV      R0,R6
   \   00000078   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??CreateDelimiter_3:
   \   0000007C   012082E2           ADD      R2,R2,#+1
   \                     ??CreateDelimiter_1:
   \   00000080   050052E1           CMP      R2,R5
   \   00000084   FAFFFF2A           BCS      ??CreateDelimiter_2
   \   00000088   0030A0E3           MOV      R3,#+0
   \   0000008C   000054E3           CMP      R4,#+0
   \   00000090   0300001A           BNE      ??CreateDelimiter_4
   \   00000094   F8FFFFEA           B        ??CreateDelimiter_3
   \                     ??CreateDelimiter_5:
   \   00000098   C070A0E3           MOV      R7,#+192
   \   0000009C   ........           STRB     R7,[R0], #+1
   \                     ??CreateDelimiter_6:
   \   000000A0   013083E2           ADD      R3,R3,#+1
   \                     ??CreateDelimiter_4:
   \   000000A4   040053E1           CMP      R3,R4
   \   000000A8   F3FFFF2A           BCS      ??CreateDelimiter_3
   \   000000AC   C50052E1           CMP      R2,R5, ASR #+1
   \   000000B0   F8FFFF1A           BNE      ??CreateDelimiter_5
   \   000000B4   040053E3           CMP      R3,#+4
   \   000000B8   F6FFFF3A           BCC      ??CreateDelimiter_5
   \   000000BC   037044E2           SUB      R7,R4,#+3
   \   000000C0   070053E1           CMP      R3,R7
   \   000000C4   F3FFFF2A           BCS      ??CreateDelimiter_5
   \   000000C8   ........           STRB     R1,[R0], #+1
   \   000000CC   F3FFFFEA           B        ??CreateDelimiter_6
    312          }
    313          

   \                                 In segment CODE, align 4, keep-with-next
    314          IMGHDR *CreateButton(int width, int height)
    315          {
   \                     CreateButton:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    316          #define RGB16(R, G, B) (((B>>3)&0x1F) | ((G<<3)&0x7E0) | ((R<<8)&0xF800))
    317            IMGHDR * img_hc=malloc(sizeof(IMGHDR));
   \   0000000C   0C00A0E3           MOV      R0,#+12
   \   00000010   140000EF           SWI      +20
   \   00000014   0060A0E1           MOV      R6,R0
    318            short *iimg=malloc(width*height*2);
   \   00000018   950400E0           MUL      R0,R5,R4
   \   0000001C   8000A0E1           LSL      R0,R0,#+1
   \   00000020   140000EF           SWI      +20
    319            img_hc->w=width;
   \   00000024   B040C6E1           STRH     R4,[R6, #+0]
    320            img_hc->h=height;
   \   00000028   B250C6E1           STRH     R5,[R6, #+2]
    321            img_hc->bpnum=8;
   \   0000002C   0810A0E3           MOV      R1,#+8
   \   00000030   041086E5           STR      R1,[R6, #+4]
    322            img_hc->bitmap=(char*)iimg;
   \   00000034   080086E5           STR      R0,[R6, #+8]
    323            
    324            for (unsigned int y = 0; y<height; y++)
   \   00000038   0010A0E3           MOV      R1,#+0
   \   0000003C   000055E3           CMP      R5,#+0
   \   00000040   0200001A           BNE      ??CreateButton_0
    325            {
    326              for (unsigned int x = 0; x<width; x++)
    327              {
    328               
    329                if ((y == 0)|| (y == (height-1))||(x==0)||(x==width-1))
    330                {
    331                  *iimg++ = 0xE000; //transparent
    332                  continue;
    333                }
    334                if ((y == 1)|| (y == (height-2))||(x==1)||(x==width-2))
    335                {
    336                  *iimg++ = RGB16(88,92,88);
    337                  continue;
    338                }
    339                if ((y==2)||(x==2))
    340                {
    341                  *iimg++ = RGB16(248,252,248);
    342                  continue;
    343                }
    344                if ((y == (height-3))||(x==width-3))
    345                {
    346                  *iimg++ = RGB16(200,204,200);
    347                  continue;
    348                }
    349                *iimg++ = RGB16(224,228,224);
    350              }
    351            }
    352            return (img_hc);  
   \                     ??CreateButton_1:
   \   00000044   0600A0E1           MOV      R0,R6
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
   \                     ??CreateButton_2:
   \   0000004C   011081E2           ADD      R1,R1,#+1
   \                     ??CreateButton_0:
   \   00000050   050051E1           CMP      R1,R5
   \   00000054   FAFFFF2A           BCS      ??CreateButton_1
   \   00000058   0020A0E3           MOV      R2,#+0
   \   0000005C   000054E3           CMP      R4,#+0
   \   00000060   0200001A           BNE      ??CreateButton_3
   \   00000064   F8FFFFEA           B        ??CreateButton_2
   \                     ??CreateButton_4:
   \   00000068   ........           STRH     R3,[R0], #+2
   \   0000006C   012082E2           ADD      R2,R2,#+1
   \                     ??CreateButton_3:
   \   00000070   040052E1           CMP      R2,R4
   \   00000074   F4FFFF2A           BCS      ??CreateButton_2
   \   00000078   000051E3           CMP      R1,#+0
   \   0000007C   01304512           SUBNE    R3,R5,#+1
   \   00000080   03005111           CMPNE    R1,R3
   \   00000084   00005213           CMPNE    R2,#+0
   \   00000088   01304412           SUBNE    R3,R4,#+1
   \   0000008C   03005211           CMPNE    R2,R3
   \   00000090   FF30E003           MVNEQ    R3,#+255
   \   00000094   7C3DC303           BICEQ    R3,R3,#0x1F00
   \   00000098   F2FFFF0A           BEQ      ??CreateButton_4
   \   0000009C   010051E3           CMP      R1,#+1
   \   000000A0   02304512           SUBNE    R3,R5,#+2
   \   000000A4   03005111           CMPNE    R1,R3
   \   000000A8   01005213           CMPNE    R2,#+1
   \   000000AC   02304412           SUBNE    R3,R4,#+2
   \   000000B0   03005211           CMPNE    R2,R3
   \   000000B4   EB30A003           MOVEQ    R3,#+235
   \   000000B8   5A3C8303           ORREQ    R3,R3,#0x5A00
   \   000000BC   E9FFFF0A           BEQ      ??CreateButton_4
   \   000000C0   020051E3           CMP      R1,#+2
   \   000000C4   02005213           CMPNE    R2,#+2
   \   000000C8   0030E003           MVNEQ    R3,#+0
   \   000000CC   E5FFFF0A           BEQ      ??CreateButton_4
   \   000000D0   033045E2           SUB      R3,R5,#+3
   \   000000D4   030051E1           CMP      R1,R3
   \   000000D8   03304412           SUBNE    R3,R4,#+3
   \   000000DC   03005211           CMPNE    R2,R3
   \   000000E0   C330E013           MVNNE    R3,#+195
   \   000000E4   603DC313           BICNE    R3,R3,#0x1800
   \   000000E8   8630E003           MVNEQ    R3,#+134
   \   000000EC   C43DC303           BICEQ    R3,R3,#0x3100
   \   000000F0   DCFFFFEA           B        ??CreateButton_4
    353          }

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "1.2.5">`:
   \   00000000   312E322E3500       DC8 "1.2.5"
   \   00000006   0000               DC8 0, 0

   Maximum stack usage in bytes:

     Function          CSTACK
     --------          ------
     ConvertRGBAToRGB8    24
     CreateButton         16
     CreateDelimiter      20
     CreateFrame          20
     my_error_exit         8
     read_data_fn         16
     read_jpgimg         668
     read_pngimg          80
     xmalloc               4
     xmfree                4


   Segment part sizes:

     Function/Label      Bytes
     --------------      -----
     xmalloc               16
     xmfree                16
     read_data_fn          52
     read_pngimg          824
     my_error_exit         32
     jpg_hdr                2
     read_jpgimg          444
     ConvertRGBAToRGB8    192
     CreateFrame          204
     CreateDelimiter      208
     CreateButton         244
     ?<Constant "1.2.5">    8
      Others              136

 
 2 368 bytes in segment CODE
    10 bytes in segment DATA_C
 
 2 232 bytes of CODE  memory (+ 136 bytes shared)
    10 bytes of CONST memory

Errors: none
Warnings: none
