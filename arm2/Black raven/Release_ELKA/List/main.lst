##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    11/Aug/2009  13:41:03 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\Ballet Mini test\main.c                       #
#    Command line    =  "C:\arm\Ballet Mini test\main.c" -D NEWSGOLD -D      #
#                       ELKA -lC "C:\arm\Ballet Mini                         #
#                       test\Release_ELKA\List\" -o "C:\arm\Ballet Mini      #
#                       test\Release_ELKA\Obj\" -s9 --no_unroll --no_inline  #
#                       --cpu_mode arm --endian little --cpu ARM926EJ-S      #
#                       --stack_align 4 --interwork -e --char_is_signed      #
#                       --fpu None -I "C:\arm2\Embedded Workbench 4.0        #
#                       Evaluation\ARM\INC\"                                 #
#    List file       =  C:\arm\Ballet Mini test\Release_ELKA\List\main.lst   #
#    Object file     =  C:\arm\Ballet Mini test\Release_ELKA\Obj\main.r79    #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\Ballet Mini test\main.c
      1          #include "..\inc\swilib.h"
      2          #include "rect_patcher.h"
      3          #include "../inc/cfg_items.h"
      4          #include "conf_loader.h"
      5          #include "dialogs.c"

  void patch_rect(RECT*rc,int x,int y, int x2, int y2)
       ^
"C:\arm\Ballet Mini test\rect_patcher.h",2  Error[Pe247]: function "patch_rect"
          has already been defined

  void patch_header(const HEADER_DESC* head)
       ^
"C:\arm\Ballet Mini test\rect_patcher.h",11  Error[Pe247]: function
          "patch_header" has already been defined

  void patch_input(const INPUTDIA_DESC* inp)
       ^
"C:\arm\Ballet Mini test\rect_patcher.h",20  Error[Pe247]: function
          "patch_input" has already been defined

  int toupper(int c)
      ^
"C:\arm\Ballet Mini test\rect_patcher.h",29  Error[Pe247]: function "toupper"
          has already been defined

  int strcmp_nocase(const char *s1,const char *s2)
      ^
"C:\arm\Ballet Mini test\rect_patcher.h",36  Error[Pe247]: function
          "strcmp_nocase" has already been defined

  char *strtolower(char *src, char *dst, int sz)
        ^
"C:\arm\Ballet Mini test\rect_patcher.h",45  Error[Pe247]: function
          "strtolower" has already been defined
      6          #include "constants.c"

  const char WHITE[]={255,255,255,100};
                      ^
"C:\arm\Ballet Mini test\constants.c",6  Warning[Pe068]: integer conversion
          resulted in a change of sign

  const char WHITE[]={255,255,255,100};
                          ^
"C:\arm\Ballet Mini test\constants.c",6  Warning[Pe068]: integer conversion
          resulted in a change of sign

  const char WHITE[]={255,255,255,100};
                              ^
"C:\arm\Ballet Mini test\constants.c",6  Warning[Pe068]: integer conversion
          resulted in a change of sign

  const char GRAY[]={128,128,128,100};
                     ^
"C:\arm\Ballet Mini test\constants.c",8  Warning[Pe068]: integer conversion
          resulted in a change of sign

  const char GRAY[]={128,128,128,100};
                         ^
"C:\arm\Ballet Mini test\constants.c",8  Warning[Pe068]: integer conversion
          resulted in a change of sign

  const char GRAY[]={128,128,128,100};
                             ^
"C:\arm\Ballet Mini test\constants.c",8  Warning[Pe068]: integer conversion
          resulted in a change of sign

  const char RED[]={255,0,0,100};
                    ^
"C:\arm\Ballet Mini test\constants.c",10  Warning[Pe068]: integer conversion
          resulted in a change of sign

  const char GREEN[]={0,255,0,100};
                        ^
"C:\arm\Ballet Mini test\constants.c",11  Warning[Pe068]: integer conversion
          resulted in a change of sign

  const char BLUE[]={0,0,255,100};
                         ^
"C:\arm\Ballet Mini test\constants.c",12  Warning[Pe068]: integer conversion
          resulted in a change of sign

  const char YELLOW[]={255,255,0,100};
                       ^
"C:\arm\Ballet Mini test\constants.c",14  Warning[Pe068]: integer conversion
          resulted in a change of sign

  const char YELLOW[]={255,255,0,100};
                           ^
"C:\arm\Ballet Mini test\constants.c",14  Warning[Pe068]: integer conversion
          resulted in a change of sign

  const char CYAN[]={0,255,255,100};
                       ^
"C:\arm\Ballet Mini test\constants.c",15  Warning[Pe068]: integer conversion
          resulted in a change of sign

  const char CYAN[]={0,255,255,100};
                           ^
"C:\arm\Ballet Mini test\constants.c",15  Warning[Pe068]: integer conversion
          resulted in a change of sign

  const char PURPLE[]={255,0,255,100};
                       ^
"C:\arm\Ballet Mini test\constants.c",16  Warning[Pe068]: integer conversion
          resulted in a change of sign

  const char PURPLE[]={255,0,255,100};
                             ^
"C:\arm\Ballet Mini test\constants.c",16  Warning[Pe068]: integer conversion
          resulted in a change of sign

  const char ORANGE[]={255,165,0,100};
                       ^
"C:\arm\Ballet Mini test\constants.c",18  Warning[Pe068]: integer conversion
          resulted in a change of sign

  const char ORANGE[]={255,165,0,100};
                           ^
"C:\arm\Ballet Mini test\constants.c",18  Warning[Pe068]: integer conversion
          resulted in a change of sign

  const char GOLD[]={255,215,0,100};
                     ^
"C:\arm\Ballet Mini test\constants.c",19  Warning[Pe068]: integer conversion
          resulted in a change of sign

  const char GOLD[]={255,215,0,100};
                         ^
"C:\arm\Ballet Mini test\constants.c",19  Warning[Pe068]: integer conversion
          resulted in a change of sign

  const char DARKGOLD[]={218,165,32,100};
                         ^
"C:\arm\Ballet Mini test\constants.c",20  Warning[Pe068]: integer conversion
          resulted in a change of sign

  const char DARKGOLD[]={218,165,32,100};
                             ^
"C:\arm\Ballet Mini test\constants.c",20  Warning[Pe068]: integer conversion
          resulted in a change of sign

  const char BROWN[]={160,40,20,100};
                      ^
"C:\arm\Ballet Mini test\constants.c",21  Warning[Pe068]: integer conversion
          resulted in a change of sign

  const char ORED[]={255,0,0,20};
                     ^
"C:\arm\Ballet Mini test\constants.c",27  Warning[Pe068]: integer conversion
          resulted in a change of sign

  const char OGREEN[]={0,255,0,20};
                         ^
"C:\arm\Ballet Mini test\constants.c",28  Warning[Pe068]: integer conversion
          resulted in a change of sign

  const char OBLUE[]={0,0,255,20};
                          ^
"C:\arm\Ballet Mini test\constants.c",29  Warning[Pe068]: integer conversion
          resulted in a change of sign

  const char OBROWN[]={160,40,20,20};
                       ^
"C:\arm\Ballet Mini test\constants.c",30  Warning[Pe068]: integer conversion
          resulted in a change of sign
      7          #include "fnt.c"

  int isCharValid(char c) {  if((c>31 && c<127)||(c>191 && c<256)) {return 1;} else{return 0;}}
                                                   ^
"C:\arm\Ballet Mini test\fnt.c",230  Warning[Pa084]: pointless integer
          comparison with an out of range value
      8          //#include "debug.c"
      9          
     10          //typedef char const* color;
     11          
     12          #define TMR_SECOND 261
     13          #define kadrCLK 6 // период анимации кадров в секунду
     14          
     15          #ifdef NEWSGOLD
     16          #define DEFAULT_DISK "4"
     17          #else
     18          #define DEFAULT_DISK "0"
     19          #endif
     20          
     21          //-----------------------------------------------------//
     22          //Ёт стремные переменные,но они нужны в любом проекте :)
     23          const int minus11=-11;
     24          unsigned short maincsm_name_body[140];
     25          unsigned int MAINCSM_ID = 0;
     26          unsigned int MAINGUI_ID = 0;
     27          typedef struct
     28          {
     29            CSM_RAM csm;
     30            int gui_id;
     31          }MAIN_CSM;
     32          
     33          typedef struct
     34          {
     35            GUI gui;
     36            WSHDR *ws1;
     37            WSHDR *ws2;
     38            int i1;
     39          }MAIN_GUI;
     40          
     41          //ќбъ€вл€ем переменные из конфига
     42          extern const int font;
     43          //----------------------------------//
     44          int kadrnum=1 ;   // текущий кадр анимации ландшафта
     45          int mapx = 0, mapy = 0; // –азмеры карты по x и y
     46          int sm=0; // смещение в байтах от начала дл€ обхода даных карты до начала номера первой картинки
     47          int sizeSP=16; //размер €чейки
     48          int sizeX=8;  // сколько €чеек выводить на экран по ’
     49          int sizeY=9;  // сколько €чеек выводить на экран по Y
     50          int scrX=0; //координаты экрана относительно начала карты
     51          int scrY=0;
     52          int cursorX=0; //координаты курсора в карте
     53          int cursorY=0;
     54          int Xscr=2;  // текущие координаты в экране 
     55                        // точнее координаты с которых выводитс€ карта 
     56          GBSTMR timerredraw;
     57          
     58          int countM2=3; // текущий пункт меню
     59          const int counCOLM=8; // максимум пунктов меню
     60          int sizeF=15;  // размер точнее высота шрифта
     61          int gold=15000;  //золото
     62          int wood=15000;  //дерево
     63          int Yscr=2;
     64          int i;
     65          int y;
     66          int x;
     67          int p;
     68          int DelayVAR;
     69          int tpic=1;  // текуща€ картинка
     70          int maxpic=105;// максимальный номер картинки дл€ фона
     71          int minpic=1;
     72          int scrCURx;
     73          int typeGUI;
     74          int scrCURy;
     75          int typeGUI=0;// номер текущего экрана:0-карта 1-меню 2-выбор картинки
     76          int scr_w, scr_h;//Ўирина и высота экрана
     77          
     78          #define earth 0x01;
     79          
     80          static const char* const tagids[] = {
     81            "MSX", //–азмер по X
     82            "MSY", //–азмер по Y
     83            "GLD", //«олото
     84            "WOD", //Ћес
     85            "MDT", //ћассив графики
     86            "BLD",}; //ћассив зданий
     87          
     88          const char NULLS[4]=
     89          {
     90            0x00,0x00,0x00,0x00,
     91          };
     92          
     93          #include "textfield.c"
     94          #include "cb.c"
     95          
     96          void printmap(); // функци€ рисует карту
     97          void printminimap(); // функци€ рисует миникарту
     98          void printGW(); // выводит золото/дерево
     99          int npic (int x,int y); // функци€ возвращает номер картинки
    100          void printpic (int x,int y,int numer); // рисует картинку
    101          void printCUR (); // рисует курсор
    102          void vverh ();
    103          void vniz ();
    104          void vpravo ();
    105          void vlevo ();
    106          void vibor ();
    107          void printM1 ();
    108          void drawSBy ();
    109          void drawSBx ();
    110          int REDRAW2 ();
    111          void sss();
    112          
    113          char *map;
    114          char *builds;
    115          
    116          int FindTag(int tagid, char *dat, int maxlen, int tseek)
    117          {
    118            int post;
    119            for(post = tseek; post < (maxlen-3); post++)
    120            {
    121              if ((dat[post]==tagids[tagid][0])&&(dat[post+1]==tagids[tagid][1])&&(dat[post+2]==tagids[tagid][2]))
    122              {
    123                return (post+3); //≈сли нашли значит текуща€ позици€ = результат
    124              }
    125            }
    126            return -1;
    127          }
    128          
    129          int getInt32(char* dat, int ps)
    130          {
    131            int nm = 0;
    132            nm = dat[ps + 0] * 0x200000 + dat[ps + 1] * 0x4000 + dat[ps + 2] * 0x80 + dat[ps + 3];
    133            return nm;
    134          }
    135          
    136          void toInt32(int in, char *cint32)
    137          {
    138            if (in <= 255) 
    139              {
    140                cint32[0] = 0x00;
    141                cint32[1] = 0x00;
    142                cint32[2] = 0x00;
    143                cint32[3] = in;
    144              }
    145              else if(in <= 32767)
    146              {
    147                cint32[0] = 0x00;
    148                cint32[1] = 0x00;
    149                cint32[2] = in / 128;
    150                cint32[3] = in % 128;
    151              }
    152              else
    153              {
    154                int tm = 0;
    155                cint32[0] = 0x00;
    156                tm = in - (in % 16384);
    157                cint32[1] = tm / 16384;
    158                tm = in % 16384;
    159                cint32[2] = tm / 128;
    160                cint32[3] = tm % 128;
    161              }
    162          }
    163          
    164          void InitMap(char *fname) //√рузит карту
    165          {
    166            scr_w=ScreenW();//ѕрисваиваем переменным высоту и ширину экрана
    167            scr_h=ScreenH();
    168            int f;
    169            int FSize;
    170            unsigned int err;
    171            char *tmap;
    172            if (strrchr(fname,'brm')) // ≈сли эльф запущен с параметром, то грузим эту карту
    173            {
    174              f=fopen(fname, A_ReadOnly+A_BIN, P_READ, &err);
    175              FSize=lseek(f,0,S_END,&err,&err);
    176              tmap = malloc(FSize);
    177              lseek(f,0,0,&err,&err);
    178              fread( f,tmap, FSize, & err );
    179              fclose(f,&err);
    180            }
    181            else // »наче грузим дефолтную
    182            {
    183              f=fopen(DEFAULT_DISK ":\\zbin\\Black Raven\\maps\\default.brm", A_ReadOnly+A_BIN, P_READ, &err);   
    184              //if(f==-1) {ConfirmBox("default.brm not loaded!!", "Ok", 0); return;}    
    185              FSize=lseek(f,0,S_END,&err,&err);
    186              tmap = malloc(FSize);
    187              lseek(f,0,0,&err,&err);
    188              fread( f,tmap, FSize, & err );
    189              fclose(f,&err); 
    190            }
    191            
    192            // »щем "тег" размера карты по горизонтали
    193            int pos = 0;
    194            pos = FindTag(0, tmap, FSize, 0);
    195            mapx = tmap[pos];
    196            // »щем "тег" размера карты по вертикали
    197            pos = FindTag(1, tmap, FSize, pos);
    198            mapy = tmap[pos];
    199            // »щем "тег" золота
    200            pos = FindTag(2, tmap, FSize, pos);
    201            gold = getInt32(tmap, pos);
    202            // »щем "тег" леса
    203            pos = FindTag(3, tmap, FSize, pos);
    204            wood = getInt32(tmap, pos);
    205            // »щем "тег" самой карты
    206            pos = FindTag(4, tmap, FSize, pos);
    207            memcpy(map,&tmap[pos],(mapx * mapy));
    208            pos = FindTag(5, tmap, FSize, pos);
    209            int bldlen = 0;
    210            bldlen = getInt32(tmap, pos);
    211            if (bldlen)
    212            {
    213              builds = malloc(bldlen);
    214              memcpy(builds,&tmap[pos],bldlen);
    215            }
    216            if (tmap) mfree(tmap);
    217          }
    218          
    219          //void canvasdata(void);
    220          
    221          void *canvasdata;
    222          int delay (int t);
    223          void printPCUR ();
    224          int npic2save ();
    225          void printwin (int x,int y,int l,int h);
    226          
    227          void writemap(char* fname)
    228          {
    229            unsigned int err;
    230            char *filename_full = malloc(64);
    231            sprintf(filename_full, DEFAULT_DISK ":\\zbin\\Black Raven\\maps\\%s.brm", fname);
    232            int ff;
    233            if(fopen(filename_full, A_ReadOnly, 0, &err) != -1) unlink(filename_full, &err);
    234            ff = fopen(filename_full,A_ReadWrite+A_BIN+A_Create+A_Truncate,P_READ+P_WRITE,&err);
    235            fwrite(ff, "MSX", 3, &err);
    236            fwrite(ff, &mapx, 1, &err);
    237            fwrite(ff, "MSY", 3, &err);
    238            fwrite(ff, &mapy, 1, &err);
    239            fwrite(ff, "GLD", 3, &err);
    240            char *cint32 = malloc(4);
    241            toInt32(gold, cint32);
    242            fwrite(ff, cint32, 4, &err);
    243            zeromem(cint32, 4);
    244            fwrite(ff, "WOD", 3, &err);
    245            toInt32(wood, cint32);
    246            fwrite(ff, cint32, 4, &err);
    247            zeromem(cint32, 4);
    248            fwrite(ff, "MDT", 3, &err);
    249            fwrite(ff, map, mapx * mapy, &err);
    250            fwrite(ff, "BLD", 3, &err);
    251            if(builds)
    252            {
    253              int blen = strlen(builds);
    254              toInt32(blen, cint32);
    255              fwrite(ff, cint32, 4, &err);
    256              zeromem(cint32, 4);
    257              fwrite(ff, builds, blen, &err);
    258            }
    259            else
    260            {
    261              fwrite(ff, NULLS, 4, &err);
    262            }
    263            fclose(ff, &err);
    264            if(cint32) mfree(cint32);
    265            if(filename_full) mfree(filename_full);
    266          }
    267          
    268          void writeinit(int digit, int init)
    269          {
    270            if(digit > 100000) digit = 100000;
    271            if (init == 1) gold = digit;
    272            else wood = digit;
    273          }
    274          
    275          
    276          void changeSize(int xx, int yy)
    277          {   
    278            if(mapx != xx || mapy != yy)
    279            {
    280               char *tmpmap = malloc(mapx * mapy);
    281               memcpy(tmpmap,map,(mapx * mapy));
    282                if (map) mfree(map);
    283                map=malloc(xx*yy);
    284                memset(map,1,xx*yy);
    285              
    286                for(int ii = 0; ii < mapy; ii++)
    287                {
    288                  memcpy(map + ii*xx, tmpmap + (mapx * ii), (xx<mapx)?xx:mapx);
    289                }
    290                
    291              mapx = xx;
    292              mapy = yy;
    293            }
    294          }
    295          
    296          static void OnRedraw(MAIN_GUI *data)//эта функци€ нужна дл€ перерисовки экрана,тут рисуем все что нам нужно
    297          {
    298            if(typeGUI == 0 || typeGUI == 2 || typeGUI == 3)
    299            {
    300             printmap ();  // рисуем карту
    301             printCUR ();  // рисуем курсор
    302             drawSBy ();   //рисуем скролбар
    303             drawSBx ();
    304             printGW();    //пишем золото/дерево
    305            }
    306            if (typeGUI==2)
    307            {
    308            printPCUR ();
    309            }
    310            if (typeGUI==3)
    311            {
    312            printminimap();
    313            }
    314            if (typeGUI==1)
    315             {
    316             printwin (4,10,120,150);
    317             printM1 ();
    318             }
    319          }
    320          // тут наши фунуции процедуры и т д///////////////////////////////////////////////////////////////////
    321          void sss()
    322          {
    323            kadrnum = (kadrnum%4)+1;
    324              //if  (kadrnum==4)  kadrnum=1;
    325              //else kadrnum += 1;
    326            REDRAW();
    327            GBS_StartTimerProc(&timerredraw,TMR_SECOND/kadrCLK,sss);
    328          }
    329          void printM1 ()// рисует меню
    330          {
    331            WSHDR *wstr = AllocWS(64);
    332            int countM=0;
    333            int xm1=11;
    334            int ym1=10;
    335            int xm1m=xm1;
    336            int ym1m=ym1;
    337            countM++;
    338            DrawRectangle(xm1m-1,ym1m+countM2*sizeF-3,120,ym1m+countM2*sizeF+sizeF-4,0,GetPaletteAdrByColorIndex(2),GetPaletteAdrByColorIndex(15));
    339            wsprintf (wstr, percent_t,"ќ“ –џ“№"); //1
    340            DrawString(wstr, xm1m, ym1m+countM*sizeF, 132-10, ym1m+countM*sizeF+GetFontYSIZE(FONT_SMALL), FONT_SMALL, 1, 
    341                       GetPaletteAdrByColorIndex( 0 ), GetPaletteAdrByColorIndex( 23 ) );
    342            countM++;
    343            wsprintf (wstr, percent_t,"—ќ’–јЌ»“№"); //2
    344            DrawString(wstr, xm1m, ym1m+countM*sizeF, 132-10, ym1m+countM*sizeF+GetFontYSIZE(FONT_SMALL), FONT_SMALL, 1, 
    345                       GetPaletteAdrByColorIndex( 0 ), GetPaletteAdrByColorIndex( 23 ) );
    346            countM++;
    347            wsprintf (wstr, percent_t,"÷ель миссии"); //3
    348            DrawString(wstr, xm1m, ym1m+countM*sizeF, 132-10, ym1m+countM*sizeF+GetFontYSIZE(FONT_SMALL), FONT_SMALL, 1, 
    349                       GetPaletteAdrByColorIndex( 0 ), GetPaletteAdrByColorIndex( 23 ) );
    350            countM++;
    351            wsprintf (wstr, percent_t,"¬озможности уровн€"); //4
    352            DrawString(wstr, xm1m, ym1m+countM*sizeF, 132-10, ym1m+countM*sizeF+GetFontYSIZE(FONT_SMALL), FONT_SMALL, 1, 
    353                       GetPaletteAdrByColorIndex( 0 ), GetPaletteAdrByColorIndex( 23 ) );
    354            countM++;
    355            wsprintf (wstr, percent_t,"«олото"); //5
    356            DrawString(wstr, xm1m, ym1m+countM*sizeF, 132-10, ym1m+countM*sizeF+GetFontYSIZE(FONT_SMALL), FONT_SMALL, 1, 
    357                       GetPaletteAdrByColorIndex( 0 ), GetPaletteAdrByColorIndex( 23 ) );
    358            countM++;
    359            wsprintf (wstr, percent_t,"Ћес"); //6
    360            DrawString(wstr, xm1m, ym1m+countM*sizeF, 132-10, ym1m+countM*sizeF+GetFontYSIZE(FONT_SMALL), FONT_SMALL, 1, 
    361                       GetPaletteAdrByColorIndex( 0 ), GetPaletteAdrByColorIndex( 23 ) );
    362            countM++;
    363            wsprintf (wstr, percent_t,"–азмер карты"); //7
    364            DrawString(wstr, xm1m, ym1m+countM*sizeF, 132-10, ym1m+countM*sizeF+GetFontYSIZE(FONT_SMALL), FONT_SMALL, 1, 
    365                       GetPaletteAdrByColorIndex( 0 ), GetPaletteAdrByColorIndex( 23 ) );
    366              countM++;
    367            wsprintf (wstr, percent_t,"¬ыход"); //8
    368            DrawString(wstr, xm1m, ym1m+countM*sizeF, 132-10, ym1m+countM*sizeF+GetFontYSIZE(FONT_SMALL), FONT_SMALL, 1, 
    369                       GetPaletteAdrByColorIndex( 0 ), GetPaletteAdrByColorIndex( 23 ) );
    370            FreeWS(wstr);
    371            countM=1;
    372          }
    373          
    374          inline void MenuEnter()
    375          {
    376            switch(countM2)
    377                     {
    378                       // ќткрыть
    379                       case 1: {//CreateBookmarksMenu();break;}// —охранить
    380                       case 2: {DoEditcontrol(1, "map0", NULL);break;}  // ÷ель миссии
    381                       case 3: break;  // ¬озможности уровн€
    382                       case 4: //TextBox(" ровава€ бан€","¬ы должны отсто€ть ”рюпинск","убить не менее трех бобруйских медведов\n построить шайтан-арбу\n спасти  енни"); break;// «олото
    383                       case 5:
    384                       {
    385                         char *mt = malloc(10);
    386                         sprintf(mt, percent_d, gold);
    387                         DoEditcontrol(2, mt, NULL);
    388                         if(mt) mfree(mt);
    389                         break;
    390                       }
    391                       // Ћес
    392                       case 6: 
    393                       {
    394                         char *mt = malloc(10);
    395                         sprintf(mt, percent_d, wood);
    396                         DoEditcontrol(3, mt, NULL);
    397                         if(mt) mfree(mt);
    398                         break;
    399                       }
    400                       // –азмер карты
    401                       case 7: 
    402                       {
    403                         char *mx = malloc(10);
    404                         char *my = malloc(10);
    405                         sprintf(mx, percent_d, mapx);
    406                         sprintf(my, percent_d, mapy);
    407                         DoEditcontrol(4, mx, my);
    408                         if(mx) mfree(mx);
    409                         if(my) mfree(my);
    410                         break;
    411                       }
    412                       // ¬ыход
    413                       case 8: break;
    414                     }
    415          }
    416          }
    417          
    418          
    419          int npic (int x,int y) // функци€ возвращает номер картинки на входе х и у кординаты
    420          {
    421            i=1;
    422            p=1;
    423            i=sm+x+y*mapx;
    424            int p=map[i];
    425            return p;
    426          }
    427          
    428          int npic2save () // функци€ возвращает смещение от начала карты дл€ текущей картинки
    429          {
    430            i=1;
    431            y=cursorY;
    432            x=cursorX;
    433            i=sm+x+y*mapx;
    434            return i;
    435          }
    436          
    437          
    438          void printpic (int x,int y,int numer) //рисует картинку на входе координаты на экране и номер
    439          {
    440            char *path=malloc(128);
    441            
    442            if (numer>=100)
    443            {
    444               sprintf(path, DEFAULT_DISK ":\\zbin\\Black Raven\\img\\map\\%d_%d.png", numer, kadrnum);
    445            
    446            }
    447            else 
    448            {
    449              sprintf(path, DEFAULT_DISK ":\\zbin\\Black Raven\\img\\map\\%d.png", numer);
    450            
    451            }
    452            DrawImg(x,y,(int)path);
    453            if(path) mfree(path);
    454          }
    455          
    456          void printCUR () // рисует курсор
    457          {
    458            int scrCURx;
    459            int scrCURy;
    460            scrCURx=Xscr+(cursorX-scrX)*sizeSP;
    461            scrCURy=Yscr+(cursorY-scrY)*sizeSP;
    462            DrawImg(scrCURx,scrCURy,(int)DEFAULT_DISK ":\\zbin\\Black Raven\\img\\map\\0.png");
    463          }
    464          
    465          void printPCUR ()//  рисует картинку текущую по месту курсора
    466          {
    467            scrCURx=Xscr+(cursorX-scrX)*sizeSP;
    468            scrCURy=Yscr+(cursorY-scrY)*sizeSP;
    469            int numer2=tpic;
    470            char *path=malloc(128);
    471            sprintf(path, DEFAULT_DISK ":\\zbin\\Black Raven\\img\\map\\%d.png", numer2);
    472            DrawImg(scrCURx,scrCURy,(int)path);
    473            if(path) mfree(path);
    474          }
    475          
    476          void drawSBy () // скролбар ’
    477          { 
    478            int ySB; int lenSB;
    479            lenSB=159*((sizeSP*100)/(sizeSP*mapy))/100;
    480            ySB=(lenSB)*cursorY;
    481            DrawLine(130,1,130,147,1,GetPaletteAdrByColorIndex(6));
    482            DrawRectangle(129,ySB-3,131,ySB+lenSB-3,0,RED,RED);
    483          }
    484          
    485          void  drawSBx () // скролбар ”
    486          {
    487            DrawLine(1,147,130,147,1,GetPaletteAdrByColorIndex(6));
    488            int xSB; int lenSB;
    489            lenSB=146*((sizeSP*100)/(sizeSP*mapx))/100;
    490            xSB=lenSB*cursorX;
    491            DrawRectangle(xSB-3,146,xSB+lenSB-3,148,0,RED,RED);
    492          }
    493          
    494          void printwin (int x,int y,int l,int h)  // рисует окно
    495          {
    496            DrawRoundedFrame(x,y,x+l,y+h,5,5,0,GetPaletteAdrByColorIndex(2),GetPaletteAdrByColorIndex(1));
    497          //);
    498          }
    499          
    500          int zoom=3; 
    501          
    502          void printminimap()
    503          { 
    504            int mmx= (ScreenW()-mapx*zoom)/2;
    505           
    506            DrawRectangle(-1,-1,ScreenW(),ScreenH(),0,SBLACK,SBLACK);
    507            
    508            
    509            DrawRectangle(mmx-3,mmx-3,mmx+zoom*sizeX+2,mmx+zoom*sizeY+2,0,GOLD,DARKBROWN);
    510            
    511            
    512            DrawRectangle(mmx-3,mmx-3,mmx-1,mmx-1,0,GOLD,DARKBROWN);
    513            DrawRectangle(mmx-3,mmx+zoom*sizeY+2,mmx-1,mmx+zoom*sizeY,0,GOLD,DARKBROWN);
    514            DrawRectangle(mmx+zoom*sizeX+2,mmx-3,mmx+zoom*sizeX,mmx-1,0,GOLD,DARKBROWN);
    515            DrawRectangle(mmx+zoom*sizeX+2,mmx+zoom*sizeY+2,mmx+zoom*sizeX,mmx+zoom*sizeY,0,GOLD,DARKBROWN);
    516            
    517            
    518            int n; 
    519            for (int o=0;o<sizeY;o++)
    520            {
    521              for (int i=0;i<sizeX;i++)
    522               {
    523                 n=npic(scrX+i,scrY+o);
    524                 DrawRectangle (mmx+zoom*i,mmx+zoom*o,zoom+mmx+zoom*i-1,zoom+mmx+zoom*o-1,0,GetPaletteAdrByColorIndex(n),GetPaletteAdrByColorIndex(n));
    525               }
    526            }
    527          }
    528          
    529          void printmap ()// рисует карту
    530          {
    531            DrawRectangle(0,0,ScreenW()-1,ScreenH()-1,0,GetPaletteAdrByColorIndex(1),GetPaletteAdrByColorIndex(1));//–исуем фон
    532            DrawRectangle(0,0,122,152,0,GetPaletteAdrByColorIndex(1),GetPaletteAdrByColorIndex(1));//–исуем рамку
    533            x=Xscr;   //координаты начала вывода карты в экране
    534            y=Yscr;
    535            int i;
    536            int n;
    537            int o; 
    538            for (o=0;o<sizeY;o++)
    539            {
    540              for (i=0;i<sizeX;i++)
    541               {
    542                 n=npic(scrX+i,scrY+o);
    543                 printpic (x+i*sizeSP,y+sizeSP*o,n);
    544               }
    545            }
    546          }
    547          
    548          void printGW()
    549          {
    550            int ygw=3+Yscr+sizeY*sizeSP;
    551            DrawRectangle(0,ygw,ScreenW()-1,ScreenH()-1,0,GOLD,DARKBROWN);
    552           
    553            //DrawRoundedFrame(0,ygw,ScreenW(),ScreenH(),0,0,0,DARKGOLD,NULL);
    554            
    555            DrawRectangle(0           ,ygw         ,2          ,ygw+2,0,GOLD,DARKBROWN);
    556            DrawRectangle(ScreenW()-3 ,ygw         ,ScreenW()-1,ygw+2,0,GOLD,DARKBROWN);
    557            DrawRectangle(0           ,ScreenH()-3 ,2          ,ScreenH()-1,0,GOLD,DARKBROWN);
    558            DrawRectangle(ScreenW()-3 ,ScreenH()-3 ,ScreenW()-1,ScreenH()-1,0,GOLD,DARKBROWN);
    559            
    560             /*
    561            color blink[5]={NULL,RED,ORANGE,RED,YELLOW};
    562           
    563            DrawRoundedFrame(0           ,ygw         ,3          ,ygw+3,2,2,0,GOLD,(char*)&(blink[kadrnum]));
    564            DrawRoundedFrame(ScreenW()-4 ,ygw         ,ScreenW()-1,ygw+3,2,2,0,GOLD,(char*)&(blink[kadrnum]));
    565            DrawRoundedFrame(0           ,ScreenH()-4 ,3          ,ScreenH()-1,2,2,0,GOLD,(char*)&(blink[kadrnum]));
    566            DrawRoundedFrame(ScreenW()-4 ,ScreenH()-4 ,ScreenW()-1,ScreenH()-1,2,2,0,GOLD,(char*)&(blink[kadrnum]));
    567            //когда ж мен€ отпустит-то... (с)*/
    568            
    569            //попытки налепить красивостей(( пока закомментировал
    570            
    571            char string[20];
    572            sprintf (string, "%s%d", "«олото: ", gold);
    573            DrawStrShadowed(string,5,ygw+3,WHITE,BLACK);
    574            
    575            sprintf (string, "%s%d", "Ћес: ", wood);
    576            DrawStrShadowed(string,5,ygw+10,WHITE,BLACK);
    577            
    578            if (typeGUI==2){sprintf (string, "%s[%d]",GetTerrainNames[tpic],tpic); }  
    579            if (typeGUI==0){sprintf (string, "%s[%d]",GetTerrainNames[npic (cursorX,cursorY)],npic (cursorX,cursorY)); }
    580            DrawStrShadowed(string,5,ygw+17,WHITE,BLACK);
    581            
    582            sprintf (string, "%i %i",cursorX,cursorY);
    583            DrawStrShadowed(string,115,ygw+3,WHITE,BLACK);
    584            
    585            /*
    586            WSHDR *wstrr = AllocWS(32);
    587            wsprintf (wstrr, percent_td, "«олото: ", gold); //1
    588            DrawString(wstrr, 5, (scr_h-2-(GetFontYSIZE(FONT_SMALL)*2)), scr_w-2, scr_h-2-GetFontYSIZE(FONT_SMALL), FONT_SMALL, 0, 
    589                       GetPaletteAdrByColorIndex( 0 ), GetPaletteAdrByColorIndex( 23 ) );
    590            wsprintf (wstrr, percent_td, "Ћес: ", wood); //2
    591            DrawString(wstrr, 5, scr_h-1-GetFontYSIZE(FONT_SMALL), scr_w-2, scr_h-1, FONT_SMALL, 0, 
    592                       GetPaletteAdrByColorIndex( 0 ), GetPaletteAdrByColorIndex( 23 ) );
    593            
    594            
    595            wsprintf (wstrr, "%i %i",cursorX,cursorY); 
    596            DrawString(wstrr, 15, ygw+2, ScreenW()-5, 999, FONT_NUMERIC_XSMALL, 4, WHITE, NULL );
    597            
    598            
    599            if (typeGUI==2){wsprintf (wstrr, "%t[%d]",GetTerrainNames[tpic],tpic); }  
    600            if (typeGUI==0){wsprintf (wstrr, "%t[%d]",GetTerrainNames[npic (cursorX,cursorY)],npic (cursorX,cursorY)); }
    601            
    602            DrawString(wstrr, 15, scr_h-1-GetFontYSIZE(FONT_SMALL), ScreenW()-5, 999, FONT_SMALL, 4, WHITE, NULL );
    603            FreeWS(wstrr);
    604            */
    605          }
    606          
    607          //-----------------------------------------------------------------------------------------------------
    608          
    609          static void onCreate(MAIN_GUI *data, void *(*malloc_adr)(int)) //“ут делаем что либо при создании гуи
    610          {
    611          #ifdef ELKA//≈сли елка,то отключаем иконбар
    612            DisableIconBar(1);
    613          #endif
    614            data->ws1=AllocWS(256); //¬ыдел€ем пам€ть под строку
    615            data->gui.state=1;
    616            
    617          }
    618          
    619          void ElfKiller(void)//освобождаем все зан€тое место эльфом в оперативе
    620          {
    621            if(map) mfree(map);
    622            extern void *ELF_BEGIN;
    623            kill_data(&ELF_BEGIN,(void (*)(void *))mfree_adr());
    624          }
    625          
    626          static void onClose(MAIN_GUI *data, void (*mfree_adr)(void *)) //—десь делаем что нить при закрытии гуи:)
    627          {
    628            data->gui.state=0;
    629            FreeWS(data->ws1);//например, освобождаем пам€ть
    630          }
    631          
    632          static void onFocus(MAIN_GUI *data, void *(*malloc_adr)(int), void (*mfree_adr)(void *))//≈сли гуи на верху то оп€ть же делаем что нужно
    633          {
    634            data->gui.state=2;
    635            DisableIDLETMR();//отключаем таймер,иначе через 2 минуты эльф закроетс€
    636            sss();
    637          }
    638          
    639          static void onUnfocus(MAIN_GUI *data, void (*mfree_adr)(void *))//а если гуи не вверху,то можно закрыть эльф например:)
    640          {
    641            if (data->gui.state!=2) return;
    642            data->gui.state=1;
    643            GBS_DelTimer(&timerredraw);
    644          }
    645          
    646          //////////////////////////////////////////////////////////////////////////
    647          
    648          static int OnKey(MAIN_GUI *data, GUI_MSG *msg)//Ќу это кей хук
    649          {
    650            //char box[128];
    651            if (msg->gbsmsg->msg==KEY_DOWN)//≈сли клавиша нажата
    652            {
    653               if (typeGUI==0)  // карта
    654               {
    655                 switch(msg->gbsmsg->submess)
    656                 { 
    657                   case UP_BUTTON: case '2': //  лавиша вверх
    658                   {
    659                     if(cursorY-scrY==0 && scrY>0) scrY--;
    660                     if(cursorY!=0) cursorY--;
    661                     return 0;
    662                   }
    663                   case DOWN_BUTTON: case '8': //  лавиша вниз
    664                   {
    665                     if(cursorY-scrY==sizeY-1 && scrY<mapy-sizeY) scrY++;
    666                     if(cursorY<mapy-1) cursorY++;
    667                     return 0;
    668                   }
    669                   case RIGHT_BUTTON: case '6': //  лавиша вправо
    670                   {
    671                     if(cursorX-scrX==sizeX-1 && scrX<mapx-sizeX) scrX++;
    672                     if(cursorX<mapx-1) cursorX++;
    673                     return 0;
    674                   }
    675                   case LEFT_BUTTON: case '4': //  лавиша влево
    676                   {
    677                     if(cursorX-scrX==0 && scrX>0) scrX--;
    678                     if(cursorX!=0) cursorX--;
    679                     return 0;
    680                   }           
    681                   case '0':
    682                   {
    683                     typeGUI=3;
    684                     return 0;
    685                   }     
    686                   case ENTER_BUTTON: //  лавиша выбор
    687                   {
    688                     typeGUI=2;
    689                     return 0;
    690                   }
    691                   case LEFT_SOFT: // Ћевый софт(меню)
    692                   {
    693                     typeGUI=1;
    694                     return 0;
    695                   }
    696                   case RIGHT_SOFT:case RED_BUTTON: return (1); //¬ыход
    697                 }
    698               }
    699               if (typeGUI==1)  //  меню
    700               {
    701                 switch(msg->gbsmsg->submess)
    702                 {
    703                   case UP_BUTTON: case '2': // ¬верх
    704                   {
    705                     countM2 = (countM2 == 1 ? counCOLM : countM2-1);
    706                     return 0;
    707                   }
    708                   case DOWN_BUTTON: case '8': // ¬низ
    709                   {
    710                     countM2 = (countM2 == counCOLM ? 1 : countM2+1);
    711                     return 0;
    712                   }
    713                   case LEFT_SOFT: // Ћевый софт(меню)
    714                   {
    715                     typeGUI=0;
    716                     return 0;
    717                   }
    718                   case ENTER_BUTTON:
    719                   {
    720                     MenuEnter();
    721                     if(countM2==8) return 1;
    722                     typeGUI = 0;
    723                     return 0;
    724                    }
    725                    case RIGHT_SOFT: typeGUI=2; REDRAW (); return 0; // ѕравый софт
    726                    case RED_BUTTON: return (1); // ¬ыход
    727                  }
    728                }
    729               if (typeGUI==2)  // замена текущей картинки в карте
    730               {
    731                 switch(msg->gbsmsg->submess)
    732                 {
    733                   case RIGHT_BUTTON: case '6': // ¬право
    734                   { 
    735                     if (tpic<maxpic) tpic++;
    736                     printPCUR ();
    737                     return 0;
    738                   }
    739                   case LEFT_BUTTON: case '4': // ¬лево
    740                   {
    741                     if (tpic > minpic) tpic--;
    742                     printPCUR ();
    743                     return 0;
    744                   }
    745                   
    746                   case '#':
    747                   { 
    748                     tpic = (tpic+10)%maxpic;
    749                     printPCUR ();
    750                     return 0;
    751                   }
    752                   case '*':
    753                   {
    754                     tpic = (tpic+maxpic-10)%maxpic;
    755                     printPCUR ();
    756                     return 0;
    757                   }
    758                   
    759                   case ENTER_BUTTON: // ¬ыбор
    760                   { 
    761                     int i;
    762                     i=npic2save ();
    763                     map[i]=tpic;
    764                     REDRAW();
    765                     typeGUI=0;
    766                     return 0;
    767                   }
    768                   
    769                   case '1': // ¬ыбор
    770                   { 
    771                     int i;
    772                     i=npic2save ();
    773                     map[i]=1;
    774                     REDRAW();
    775                     return 0;
    776                   }
    777                   case LEFT_SOFT: typeGUI=1; return 0;
    778                   case RIGHT_SOFT: case RED_BUTTON: return (1);
    779                 }
    780               }
    781               
    782               if (typeGUI==3)  //миникарта
    783               {
    784                 switch(msg->gbsmsg->submess)
    785                 {
    786                   case DOWN_BUTTON: case '8':
    787                   { 
    788                     zoom--;
    789                     REDRAW();
    790                     return 0;
    791                   }
    792                   case UP_BUTTON: case '2':
    793                   {
    794                     zoom++;
    795                     REDRAW();
    796                     return 0;
    797                   }
    798                   
    799                 default: typeGUI=0; REDRAW(); return 0;        
    800                 }
    801               }
    802               
    803            }
    804            
    805            
    806            
    807            if (msg->gbsmsg->msg==LONG_PRESS)//или удержана
    808            {
    809               if (typeGUI==0)
    810               {
    811                  switch(msg->gbsmsg->submess)
    812                  {
    813                   case UP_BUTTON: case '2': //  лавиша вверх
    814                   {
    815                     if(cursorY-scrY==0 && scrY>0) scrY--;
    816                     if(cursorY!=0) cursorY--;
    817                     break;
    818                   }
    819                   case DOWN_BUTTON: case '8': //  лавиша вниз
    820                   {
    821                     if(cursorY-scrY==sizeY-1 && scrY<mapy-sizeY) scrY++;
    822                     if(cursorY<mapy-1) cursorY++;
    823                     break;
    824                   }
    825                   case RIGHT_BUTTON: case '6': //  лавиша вправо
    826                   {
    827                     if(cursorX-scrX==sizeX-1 && scrX<mapx-sizeX) scrX++;
    828                     if(cursorX<mapx-1) cursorX++;
    829                     break;
    830                   }
    831                   case LEFT_BUTTON: case '4': //  лавиша влево
    832                   {
    833                     if(cursorX-scrX==0 && scrX>0) scrX--;
    834                     if(cursorX!=0) cursorX--;
    835                     break;
    836                   }
    837                  case RIGHT_SOFT:case RED_BUTTON: return (1); //¬ыход
    838                  }  
    839               }
    840            }
    841            return(0);
    842          }
    843          
    844          /////////////////////////////////////////////////////////////////////////
    845          extern void kill_data(void *p, void (*func_p)(void *));//Ёта функци€ убивает эльф и освобождает пам€ть
    846          
    847          int method8(void){return(0);}
    848          int method9(void){return(0);}
    849          
    850          const void * const gui_methods[11]={
    851            (void *)OnRedraw,
    852            (void *)onCreate,
    853            (void *)onClose,
    854            (void *)onFocus,
    855            (void *)onUnfocus,
    856            (void *)OnKey,
    857            0,
    858            (void *)kill_data,
    859            (void *)method8,
    860            (void *)method9,
    861            0
    862          };
    863          
    864          static void maincsm_oncreate(CSM_RAM *data)//¬ызываетс€ при открытии эльфа,делаем что нужно
    865          {
    866            //тут хитрые махинации дл€ получени€ ид гу€ чтобы мона было с ним манипулировать
    867            static const RECT Canvas={0,0,0,0};
    868            MAIN_GUI *main_gui=malloc(sizeof(MAIN_GUI));
    869            MAIN_CSM*csm=(MAIN_CSM*)data;
    870            zeromem(main_gui,sizeof(MAIN_GUI));
    871            patch_rect((RECT*)&Canvas,0,YDISP,ScreenW()-1,ScreenH()-1);
    872            main_gui->gui.canvas=(void *)(&Canvas);
    873            main_gui->gui.flag30=2;
    874            main_gui->gui.methods=(void *)gui_methods;
    875            main_gui->gui.item_ll.data_mfree=(void (*)(void *))mfree_adr();
    876            csm->csm.state=0;
    877            csm->csm.unk1=0;
    878            csm->gui_id=CreateGUI(main_gui);
    879          }
    880          
    881          static void maincsm_onclose(CSM_RAM *csm)//функци€ закрыти€ эльфа,тут освобождаем памчть если нужно и т.п.
    882          {
    883            SUBPROC((void *)ElfKiller);
    884          }
    885          
    886          
    887          #pragma inline=forced
    888          int toupper(int c)
                     ^
Error[Pe247]: function "toupper" has already been defined
    889          {
    890            if ((c>='a')&&(c<='z')) c+='A'-'a';
    891            return(c);
    892          }
    893          #pragma inline
    894          int strcmp_nocase(const char *s1,const char *s2)
                     ^
Error[Pe247]: function "strcmp_nocase" has already been defined
    895          {
    896            int i;
    897            int c;
    898            while(!(i=(c=toupper(*s1++))-toupper(*s2++))) if (!c) break;
    899            return(i);
    900          }
    901          
    902          static int maincsm_onmessage(CSM_RAM *data, GBS_MSG *msg)//тут вообщем протекают все сообщени€ поступаемые из эльфа так сказать:)
    903          {
    904            //сообщение о реконфигурации например,ипц и т.д. и т.п.
    905            MAIN_CSM *csm=(MAIN_CSM*)data;
    906            if ((msg->msg==MSG_GUI_DESTROYED)&&((int)msg->data0==csm->gui_id))
    907            {
    908              csm->csm.state=-3;
    909            }
    910            if (msg->msg==MSG_RECONFIGURE_REQ)//≈лси была реконфигураци€,то обновл€ем настройки эльфа
    911            {
    912              extern const char *successed_config_filename;
    913              if (strcmp_nocase(successed_config_filename,(char *)msg->data0)==0)
    914              {
    915                ShowMSG(1,(int)"BR_MapEditor config updated!");
    916                InitConfig();
    917              }
    918            }
    919          
    920            return(1);
    921          }
    922          
    923          
    924          static const struct//это структура цсм,разбиратьс€ не надо:)
    925          {
    926            CSM_DESC maincsm;
    927            WSHDR maincsm_name;
    928          }MAINCSM =
    929          {
    930            {
    931            maincsm_onmessage,
    932            maincsm_oncreate,
    933          #ifdef NEWSGOLD
    934            0,
    935            0,
    936            0,
    937            0,
    938          #endif
    939            maincsm_onclose,
    940            sizeof(MAIN_CSM),
    941            1,
    942            &minus11
    943            },
    944            {
    945              maincsm_name_body,
    946              NAMECSM_MAGIC1,
    947              NAMECSM_MAGIC2,
    948              0x0,
    949              139
    950            }
    951          };
    952          
    953          void UpdateCSMname(void)//ну собственно им€ эльфа передаваемое хтаску
    954          {
    955            wsprintf((WSHDR *)(&MAINCSM.maincsm_name),"BRgame");
    956          }
    957          
    958          
    959          int main(char *exename, char *fname)//exename-путь запускаемого эльфа, fname параметр передаваемый эльфу
    960          {
    961            MAIN_CSM main_csm;
    962            InitConfig();//инициируем конфиг,тобишь читаем настройки из него
    963            LockSched();
    964            UpdateCSMname();//обновл€ем им€ дл€ хтаска
    965            map = malloc(16384);
    966            InitMap(fname);
    967            CreateCSM(&MAINCSM.maincsm,&main_csm,0);//создаем цсм
    968            UnlockSched();
    969            return 0;
    970          }

Errors: 8
Warnings: 27
