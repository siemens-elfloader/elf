//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION   29/Mar/2011  10:39:20 /
// Copyright 1999-2005 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Cpu mode        =  interwork                                           /
//    Endian          =  little                                              /
//    Stack alignment =  4                                                   /
//    Source file     =  C:\arm\vkcom\sp_dec.c                               /
//    Command line    =  C:\arm\vkcom\sp_dec.c -D NEWSGOLD -D ELKA -lA       /
//                       C:\arm\vkcom\Release_ELKA\List\ -o                  /
//                       C:\arm\vkcom\Release_ELKA\Obj\ -s9 --cpu_mode arm   /
//                       --endian little --cpu ARM926EJ-S --stack_align 4    /
//                       --interwork -e --fpu None --dlib_config             /
//                       "C:\arm2\Embedded Workbench 4.0                     /
//                       Evaluation\ARM\LIB\dl5tpainl8n.h" -I                /
//                       "C:\arm2\Embedded Workbench 4.0                     /
//                       Evaluation\ARM\INC\" --inline_threshold=2           /
//    List file       =  C:\arm\vkcom\Release_ELKA\List\sp_dec.s79           /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME sp_dec

        RTMODEL "StackAlign4", "USED"
        RTMODEL "__cpu_mode", "__pcs__interwork"
        RTMODEL "__data_model", "absolute"
        RTMODEL "__endian", "little"
        RTMODEL "__rt_version", "6"

        RSEG CSTACK:DATA:NOROOT(2)

        EXTERN ??div32_a
        EXTERN ??divu32_a

        MULTWEAK ??Speech_Decode_Frame??rT
        MULTWEAK ??Speech_Decode_Frame_exit??rT
        MULTWEAK ??Speech_Decode_Frame_init??rT
        MULTWEAK ??Speech_Decode_Frame_reset??rT
        MULTWEAK ??rA??div32_a
        MULTWEAK ??rA??divu32_a
        FUNCTION A_Refl,0203H
        LOCFRAME CSTACK, 96, STACK
        FUNCTION Bgn_scd,0203H
        LOCFRAME CSTACK, 32, STACK
        FUNCTION Build_CN_param,0203H
        LOCFRAME CSTACK, 12, STACK
        FUNCTION Cb_gain_average,0203H
        LOCFRAME CSTACK, 92, STACK
        FUNCTION D_plsf_3,0203H
        LOCFRAME CSTACK, 100, STACK
        FUNCTION D_plsf_5,0203H
        LOCFRAME CSTACK, 188, STACK
        FUNCTION Dec_gain,0203H
        LOCFRAME CSTACK, 52, STACK
        FUNCTION Dec_lag3,0203H
        LOCFRAME CSTACK, 20, STACK
        FUNCTION Decoder_amr,0203H
        LOCFRAME CSTACK, 840, STACK
        FUNCTION Decoder_amr_init,0203H
        LOCFRAME CSTACK, 16, STACK
        FUNCTION Decoder_amr_reset,0203H
        LOCFRAME CSTACK, 36, STACK
        FUNCTION Ex_ctrl,0203H
        LOCFRAME CSTACK, 28, STACK
        FUNCTION Get_lsp_pol,0203H
        LOCFRAME CSTACK, 24, STACK
        FUNCTION Int_lpc_1to3,0203H
        LOCFRAME CSTACK, 56, STACK
        FUNCTION Int_lsf,0203H
        LOCFRAME CSTACK, 8, STACK
        FUNCTION Log2,0203H
        LOCFRAME CSTACK, 12, STACK
        FUNCTION Lsf_lsp,0203H
        LOCFRAME CSTACK, 4, STACK
        FUNCTION Lsp_Az,0203H
        LOCFRAME CSTACK, 60, STACK
        FUNCTION Post_Filter,0203H
        LOCFRAME CSTACK, 232, STACK
        FUNCTION Post_Process,0203H
        LOCFRAME CSTACK, 20, STACK
        FUNCTION Pow2,0203H
        LOCFRAME CSTACK, 4, STACK
        FUNCTION Pred_lt_3or6_40,0203H
        LOCFRAME CSTACK, 20, STACK
        FUNCTION Reorder_lsf,0203H
        FUNCTION Residu40,0203H
        LOCFRAME CSTACK, 16, STACK
        PUBLIC Speech_Decode_Frame
        FUNCTION Speech_Decode_Frame,0203H
        LOCFRAME CSTACK, 840, STACK
        PUBLIC Speech_Decode_Frame_exit
        FUNCTION Speech_Decode_Frame_exit,0203H
        LOCFRAME CSTACK, 16, STACK
        PUBLIC Speech_Decode_Frame_init
        FUNCTION Speech_Decode_Frame_init,0201H
        LOCFRAME CSTACK, 20, STACK
        PUBLIC Speech_Decode_Frame_reset
        FUNCTION Speech_Decode_Frame_reset,0203H
        LOCFRAME CSTACK, 16, STACK
        FUNCTION Syn_filt,0203H
        LOCFRAME CSTACK, 236, STACK
        FUNCTION Syn_filt_overflow,0203H
        LOCFRAME CSTACK, 232, STACK
        FUNCTION agc,0203H
        LOCFRAME CSTACK, 32, STACK
        FUNCTION agc2,0203H
        LOCFRAME CSTACK, 20, STACK
        FUNCTION d_gain_code,0203H
        LOCFRAME CSTACK, 56, STACK
        FUNCTION decode_3i40_14bits,0203H
        LOCFRAME CSTACK, 24, STACK
        FUNCTION decode_4i40_17bits,0203H
        LOCFRAME CSTACK, 28, STACK
        FUNCTION decompress_codewords,0203H
        LOCFRAME CSTACK, 12, STACK
        FUNCTION dtx_dec,0203H
        LOCFRAME CSTACK, 548, STACK
        FUNCTION dtx_dec_activity_update,0203H
        LOCFRAME CSTACK, 28, STACK
        FUNCTION ec_gain_code,0203H
        LOCFRAME CSTACK, 20, STACK
        FUNCTION ec_gain_code_update,0203H
        FUNCTION ec_gain_pitch_update,0203H
        FUNCTION energy_new,0203H
        LOCFRAME CSTACK, 16, STACK
        FUNCTION energy_old,0203H
        FUNCTION gc_pred,0203H
        LOCFRAME CSTACK, 44, STACK
        FUNCTION gmed_n,0203H
        LOCFRAME CSTACK, 80, STACK
        FUNCTION ph_disp,0203H
        LOCFRAME CSTACK, 356, STACK
        FUNCTION pseudonoise,0203H
        LOCFRAME CSTACK, 8, STACK
        FUNCTION rx_dtx_handler,0203H
        LOCFRAME CSTACK, 16, STACK
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 HUGEDATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, CPSR:32, R13:32
        CFI Resource R14:32, SPSR:32
        CFI VirtualResource ?RET:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon0
        
        
        CFI Common cfiCommon1 Using cfiNames0
        CFI CodeAlign 4
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon1
        
Speech_Decode_Frame SYMBOL "Speech_Decode_Frame"
??Speech_Decode_Frame??rT SYMBOL "??rT", Speech_Decode_Frame
Speech_Decode_Frame_exit SYMBOL "Speech_Decode_Frame_exit"
??Speech_Decode_Frame_exit??rT SYMBOL "??rT", Speech_Decode_Frame_exit
Speech_Decode_Frame_init SYMBOL "Speech_Decode_Frame_init"
??Speech_Decode_Frame_init??rT SYMBOL "??rT", Speech_Decode_Frame_init
Speech_Decode_Frame_reset SYMBOL "Speech_Decode_Frame_reset"
??Speech_Decode_Frame_reset??rT SYMBOL "??rT", Speech_Decode_Frame_reset

// C:\arm\vkcom\sp_dec.c
//    1 /*
//    2  * ===================================================================
//    3  *  TS 26.104
//    4  *  R99   V3.4.0 2002-02
//    5  *  REL-4 V4.3.0 2002-02
//    6  *  3GPP AMR Floating-point Speech Codec
//    7  * ===================================================================
//    8  *
//    9  */
//   10 
//   11 /*
//   12  * sp_dec.c
//   13  *
//   14  *
//   15  * Project:
//   16  *    AMR Floating-Point Codec
//   17  *
//   18  * Contains:
//   19  *    This module contains all the functions needed decoding AMR
//   20  *    encoder parameters to 16-bit speech samples
//   21  *
//   22  */
//   23 /*
//   24  * include files
//   25  */
//   26 #include "..\inc\swilib.h"
//   27 #include <math.h>
//   28 #include "sp_dec.h"
//   29 #include "rom_dec.h"

        RSEG DATA_C:CONST:SORT:NOROOT(2)
// static short const __data bitno_MR475[17]
bitno_MR475:
        DATA
        DC16 8, 8, 7, 8, 7, 2, 8, 4, 7, 2, 4, 7, 2, 8, 4, 7, 2
        DC8 0, 0
        DC16 8, 8, 7, 8, 7, 2, 6, 4, 7, 2, 6, 4, 7, 2, 6, 4, 7, 2, 6
        DC8 0, 0
        DC16 8, 9, 9, 8, 9, 2, 6, 4, 9, 2, 6, 8, 9, 2, 6, 4, 9, 2, 6
        DC8 0, 0
        DC16 8, 9, 9, 8, 11, 3, 7, 4, 11, 3, 7, 8, 11, 3, 7, 4, 11, 3, 7
        DC8 0, 0
        DC16 8, 9, 9, 8, 13, 4, 7, 5, 13, 4, 7, 8, 13, 4, 7, 5, 13, 4, 7
        DC8 0, 0
        DC16 9, 9, 9, 8, 13, 4, 4, 5, 6, 13, 4, 4, 5, 8, 13, 4, 4, 5, 6, 13, 4
        DC16 4, 5
        DC8 0, 0
        DC32 2621, 2623, 2629, 2638, 2651, 2668, 2689, 2713, 2741, 2772, 2808
        DC32 2847, 2890, 2936, 2986, 3040, 3097, 3158, 3223, 3291, 3363, 3438
        DC32 3517, 3599, 3685, 3774, 3867, 3963, 4063, 4166, 4272, 4382, 4495
        DC32 4611, 4731, 4853, 4979, 5108, 5240, 5376, 5514, 5655, 5800, 5947
        DC32 6097, 6250, 6406, 6565, 6726, 6890, 7057, 7227, 7399, 7573, 7750
        DC32 7930, 8112, 8296, 8483, 8672, 8863, 9057, 9252, 9450, 9650, 9852
        DC32 10055, 10261, 10468, 10677, 10888, 11101, 11315, 11531, 11748
        DC32 11967, 12187, 12409, 12632, 12856, 13082, 13308, 13536, 13764
        DC32 13994, 14225, 14456, 14688, 14921, 15155, 15389, 15624, 15859
        DC32 16095, 16331, 16568, 16805, 17042, 17279, 17516, 17754, 17991
        DC32 18228, 18465, 18702, 18939, 19175, 19411, 19647, 19882, 20117
        DC32 20350, 20584, 20816, 21048, 21279, 21509, 21738, 21967, 22194
        DC32 22420, 22644, 22868, 23090, 23311, 23531, 23749, 23965, 24181
        DC32 24394, 24606, 24816, 25024, 25231, 25435, 25638, 25839, 26037
        DC32 26234, 26428, 26621, 26811, 26999, 27184, 27368, 27548, 27727
        DC32 27903, 28076, 28247, 28415, 28581, 28743, 28903, 29061, 29215
        DC32 29367, 29515, 29661, 29804, 29944, 30081, 30214, 30345, 30472
        DC32 30597, 30718, 30836, 30950, 31062, 31170, 31274, 31376, 31474
        DC32 31568, 31659, 31747, 31831, 31911, 31988, 32062, 32132, 32198
        DC32 32261, 32320, 32376, 32428, 32476, 32521, 32561, 32599, 32632
        DC32 32662, 32688, 32711, 32729, 32744, 32755, 32763, 32767, 32767
        DC32 32741, 32665, 32537, 32359, 32129, 31850, 31521, 31143, 30716
        DC32 30242, 29720, 29151, 28538, 27879, 27177, 26433, 25647, 24821
        DC32 23957, 23055, 22117, 21145, 20139, 19102, 18036, 16941, 15820
        DC32 14674, 13505, 12315, 11106, 9879, 8637, 7381, 6114, 4838, 3554
        DC32 2264, 971

        RSEG DATA_C:CONST:SORT:NOROOT(2)
// static short const __data bitno_MR102[39]
bitno_MR102:
        DATA
        DC16 8, 9, 9, 8, 1, 1, 1, 1, 10, 10, 7, 7, 5, 1, 1, 1, 1, 10, 10, 7, 7
        DC16 8, 1, 1, 1, 1, 10, 10, 7, 7, 5, 1, 1, 1, 1, 10, 10, 7, 7
        DC8 0, 0
        DC16 7, 8, 9, 8, 6, 9, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 5, 6, 4, 4, 4
        DC16 4, 4, 4, 3, 3, 3, 3, 3, 5, 9, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 5
        DC16 6, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 5
        DC8 0, 0

        RSEG DATA_C:CONST:SORT:NOROOT(2)
// static short const __data dtx_log_en_adjust[9]
dtx_log_en_adjust:
        DATA
        DC16 -1023, -878, -732, -586, -440, -294, -148, 0, 0
        DC8 0, 0
        DC16 20000, 20000, 20000, 20000, 20000, 18000, 16384, 8192, 0, 0
        DC32 32767, 32729, 32610, 32413, 32138, 31786, 31357, 30853, 30274
        DC32 29622, 28899, 28106, 27246, 26320, 25330, 24279, 23170, 22006
        DC32 20788, 19520, 18205, 16846, 15447, 14010, 12540, 11039, 9512, 7962
        DC32 6393, 4808, 3212, 1608, 0, -1608, -3212, -4808, -6393, -7962
        DC32 -9512, -11039, -12540, -14010, -15447, -16846, -18205, -19520
        DC32 -20788, -22006, -23170, -24279, -25330, -26320, -27246, -28106
        DC32 -28899, -29622, -30274, -30853, -31357, -31786, -32138, -32413
        DC32 -32610, -32729, -32768
        DC32 -26887, -8812, -5323, -3813, -2979, -2444, -2081, -1811, -1608
        DC32 -1450, -1322, -1219, -1132, -1059, -998, -946, -901, -861, -827
        DC32 -797, -772, -750, -730, -713, -699, -687, -677, -668, -662, -657
        DC32 -654, -652, -652, -654, -657, -662, -668, -677, -687, -699, -713
        DC32 -730, -750, -772, -797, -827, -861, -901, -946, -998, -1059, -1132
        DC32 -1219, -1322, -1450, -1608, -1811, -2081, -2444, -2979, -3813
        DC32 -5323, -8812, -26887
        DC32 -258, -318, -439, -634, -656, -773, -711, -502, -268, -193, -2
        DC32 125, 122, -39, -9, 105, 129, 283, 372, 575, -277, -324, -197, -487
        DC32 -445, -362, -292, -27, 177, 543, 342, 517, 516, 130, 27, -104
        DC32 -120, -140, -74, -56, -564, -943, -1520, -965, -814, -526, -322
        DC32 -2, 159, 657, -312, -284, -386, -597, -493, -526, -418, -229, 105
        DC32 449, -557, -870, -1075, -919, -950, -752, -709, -316, 62, 486
        DC32 -314, -191, -203, -330, -160, -103, -51, 131, 338, 515

        RSEG DATA_C:CONST:SORT:NOROOT(2)
// static long const __data cdown[7]
cdown:
        DATA
        DC32 32767, 32112, 32112, 32112, 32112, 32112, 22937

        RSEG DATA_C:CONST:SORT:NOROOT(2)
// static long const __data sqrt_table[49]
sqrt_table:
        DATA
        DC32 16384, 16888, 17378, 17854, 18318, 18770, 19212, 19644, 20066
        DC32 20480, 20886, 21283, 21674, 22058, 22435, 22806, 23170, 23530
        DC32 23884, 24232, 24576, 24915, 25249, 25580, 25905, 26227, 26545
        DC32 26859, 27170, 27477, 27780, 28081, 28378, 28672, 28963, 29251
        DC32 29537, 29819, 30099, 30377, 30652, 30924, 31194, 31462, 31727
        DC32 31991, 32252, 32511, 32767
        DC32 32767, 32112, 32112, 26214, 9830, 6553, 6553
        DC32 0, 3277, 6556, 8192, 9830, 11469, 12288, 13107, 13926, 14746
        DC32 15565, 16384, 17203, 18022, 18842, 19661
        DC32 0, 1, 3, 2, 5, 6, 4, 7
        DC8 0, 2, 0, 3, 0, 2, 0, 3, 1, 3, 2, 4, 1, 4, 1, 4
        DC8 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0

        RSEG DATA_C:CONST:SORT:NOROOT(2)
// static long const __data log2_table[33]
log2_table:
        DATA
        DC32 0, 1455, 2866, 4236, 5568, 6863, 8124, 9352, 10549, 11716, 12855
        DC32 13967, 15054, 16117, 17156, 18172, 19167, 20142, 21097, 22033
        DC32 22951, 23852, 24735, 25603, 26455, 27291, 28113, 28922, 29716
        DC32 30497, 31266, 32023, 32767
        DC32 5571, 4751, 2785, 1556
        DC32 44, 37, 22, 12

        RSEG DATA_C:CONST:SORT:NOROOT(2)
// static long const __data gamma4_gamma3_MR122[10]
gamma4_gamma3_MR122:
        DATA
        DC32 22938, 16057, 11240, 7868, 5508, 3856, 2699, 1889, 1322, 925
        DC32 18022, 9912, 5451, 2998, 1649, 907, 499, 274, 151, 83
        DC32 24576, 18432, 13824, 10368, 7776, 5832, 4374, 3281, 2461, 1846

        RSEG DATA_C:CONST:SORT:NOROOT(2)
// static long const __data qua_gain_code[96]
qua_gain_code:
        DATA
        DC32 159, -3776, -22731, 206, -3394, -20428, 268, -3005, -18088, 349
        DC32 -2615, -15739, 419, -2345, -14113, 482, -2138, -12867, 554, -1932
        DC32 -11629, 637, -1726, -10387, 733, -1518, -9139, 842, -1314, -7906
        DC32 969, -1106, -6656, 1114, -900, -5416, 1281, -694, -4173, 1473
        DC32 -487, -2931, 1694, -281, -1688, 1948, -75, -445, 2241, 133, 801
        DC32 2577, 339, 2044, 2963, 545, 3285, 3408, 752, 4530, 3919, 958, 5772
        DC32 4507, 1165, 7016, 5183, 1371, 8259, 5960, 1577, 9501, 6855, 1784
        DC32 10745, 7883, 1991, 11988, 9065, 2197, 13231, 10425, 2404, 14474
        DC32 12510, 2673, 16096, 16263, 3060, 18429, 21142, 3448, 20763, 27485
        DC32 3836, 23097

        RSEG DATA_C:CONST:SORT:NOROOT(2)
// static long const __data inv_sqrt_table[49]
inv_sqrt_table:
        DATA
        DC32 32767, 31790, 30894, 30070, 29309, 28602, 27945, 27330, 26755
        DC32 26214, 25705, 25225, 24770, 24339, 23930, 23541, 23170, 22817
        DC32 22479, 22155, 21845, 21548, 21263, 20988, 20724, 20470, 20225
        DC32 19988, 19760, 19539, 19326, 19119, 18919, 18725, 18536, 18354
        DC32 18176, 18004, 17837, 17674, 17515, 17361, 17211, 17064, 16921
        DC32 16782, 16646, 16514, 16384

        RSEG DATA_C:CONST:SORT:NOROOT(2)
// static long const __data pow2_table[33]
pow2_table:
        DATA
        DC32 16384, 16743, 17109, 17484, 17867, 18258, 18658, 19066, 19484
        DC32 19911, 20347, 20792, 21247, 21713, 22188, 22674, 23170, 23678
        DC32 24196, 24726, 25268, 25821, 26386, 26964, 27554, 28158, 28774
        DC32 29405, 30048, 30706, 31379, 32066, 32767

        RSEG DATA_C:CONST:SORT:NOROOT(2)
// static long const __data ph_imp_low_MR795[40]
ph_imp_low_MR795:
        DATA
        DC32 26777, 801, 2505, -683, -1382, 582, 604, -1274, 3511, -5894, 4534
        DC32 -499, -1940, 3011, -5058, 5614, -1990, -1061, -1459, 4442, -700
        DC32 -5335, 4609, 452, -589, -3352, 2953, 1267, -1212, -2590, 1731
        DC32 3670, -4475, -975, 4391, -2537, 949, -1363, -979, 5734
        DC32 30274, 3831, -4036, 2972, -1048, -1002, 2477, -3043, 2815, -2231
        DC32 1753, -1611, 1714, -1775, 1543, -1008, 429, -169, 472, -1264, 2176
        DC32 -2706, 2523, -1621, 344, 826, -1529, 1724, -1657, 1701, -2063
        DC32 2644, -3060, 2897, -1978, 557, 780, -1369, 842, 655
        DC32 14690, 11518, 1268, -2761, -5671, 7514, -35, -2807, -3040, 4823
        DC32 2952, -8424, 3785, 1455, 2179, -8637, 8051, -2103, -1454, 777
        DC32 1108, -2385, 2254, -363, -674, -2103, 6046, -5681, 1072, 3123
        DC32 -5058, 5312, -2329, -3728, 6924, -3889, 675, -1775, 29, 10145
        DC32 30274, 3831, -4036, 2972, -1048, -1002, 2477, -3043, 2815, -2231
        DC32 1753, -1611, 1714, -1775, 1543, -1008, 429, -169, 472, -1264, 2176
        DC32 -2706, 2523, -1621, 344, 826, -1529, 1724, -1657, 1701, -2063
        DC32 2644, -3060, 2897, -1978, 557, 780, -1369, 842, 655

        RSEG DATA_C:CONST:SORT:NOROOT(2)
// static long const __data mean_lsf_3[10]
mean_lsf_3:
        DATA
        DC32 1546, 2272, 3778, 5488, 6972, 8382, 10047, 11229, 12766, 13714
        DC32 9556, 10769, 12571, 13292, 14381, 11651, 10588, 9767, 8593, 6484
        DC32 6, 82, -131, 154, -56, -735, 183, -65, -265, 9, -210, -361, 113
        DC32 718, 1817, 1010, 1214, 1573, 857, 1333, 2276, 827, 1568, 1933, 717
        DC32 1989, 2206, 838, 1172, 1823, 721, 1000, 2154, 286, 476, 1509, -247
        DC32 -531, 230, 147, -82, 569, 26, -177, -944, -27, -273, 692, -164
        DC32 -264, -183, 224, 790, 1039, 899, 946, 601, 485, 771, 1150, 524
        DC32 677, 903, -140, 375, 778, 410, 676, 429, 301, 530, 1009, 719, 646
        DC32 38, 226, 367, 40, 145, -45, -505, 290, 121, -121, 302, 127, 166
        DC32 -124, -383, -956, -358, -455, -977, 715, 878, 894, 978, 923, 211
        DC32 477, 272, 64, 188, -78, 17, -143, -65, 38, 643, 586, 621, -134
        DC32 -426, -651, 347, 545, 2820, 1188, 2726, 2442, 142, -80, 1735, 283
        DC32 130, 461, -262, -399, -1145, -411, 155, 430, 329, 375, 779, 53
        DC32 -226, -139, -129, -236, 1682, 285, 744, 1327, 738, 697, 1664, 312
        DC32 409, 266, 325, 720, 135, 1, 221, 453, 8, 203, 145, 299, 640, 760
        DC32 29, 468, 638, 103, 429, 379, 420, 954, 932, 1326, 1210, 1258, 704
        DC32 1012, 1152, -166, -444, -266, -316, -130, -376, 191, 1151, 1904
        DC32 -240, -543, -1260, -112, 268, 1207, 70, 1062, 1583, 278, 1360
        DC32 1574, -258, -272, -768, 19, 563, 2240, -3, -265, 135, -295, -591
        DC32 -388, 140, 354, -206, -260, -504, -795, -433, -718, -1319, 109
        DC32 331, 962, -429, -87, 652, -296, 426, 1019, -239, 775, 851, 489
        DC32 1334, 1073, -334, -332, 25, 543, 1206, 1807, 326, 61, 727, 578
        DC32 849, 1405, -208, -277, 329, -152, 64, 669, -434, -678, -727, -454
        DC32 -71, 251, 605, 480, 254, -482, 11, 996, -289, 395, 486, 722, 1049
        DC32 1440, -30, -316, -786, -106, -115, -619, 861, 1474, 1412, 1055
        DC32 1366, 1184, 812, 1237, 925, 42, -251, -576, 342, 141, -454, -168
        DC32 -80, 1359, -342, -656, -1763, 100, 821, 725, 990, 747, 800, 332
        DC32 440, 568, 663, 379, 852, 112, 165, -369, 597, 910, 282, -8, 834
        DC32 1281, -352, 572, 695, 462, 2246, 1806, 345, 190, 1374, 416, 915
        DC32 2166, 168, -82, 280, -516, -446, 840, 47, 533, 44, -362, -711
        DC32 -1143, 22, 193, 1472, -85, 233, 1813, -62, 579, 1504, 550, 944
        DC32 1749, 723, 650, 1148, 972, 884, 1395, -425, 643, 0, 1000, 952
        DC32 1098, 249, 1446, 672, -334, -87, 2172, -554, 1882, 2672, 140, 1826
        DC32 1853, 920, 1749, 2590, 1076, 1933, 2038, -137, -443, -1555, 1269
        DC32 1174, 468, -493, -122, 1521, -451, 1033, 1214, 482, 1695, 1118
        DC32 815, 649, 384, -446, -692, 107, -319, -605, -118, -207, -505, 525
        DC32 -468, -12, 2736, 75, 1934, 1305, 880, 2358, 2267, 1285, 1575, 2004
        DC32 -48, -304, -1186, -435, -461, -251, -366, -404, -547, -289, -605
        DC32 -597, -538, -810, -165, -120, 3, 356, 639, 1241, 1502, 96, 177
        DC32 750, -435, -585, -1174, -356, 109, -79, -485, 288, 2005, 9, 1116
        DC32 731, 880, 2134, 946, -265, 1585, 1065, 1157, 1210, 843, -498, -668
        DC32 431, 374, 321, -229, 1440, 2101, 1381, 449, 461, 1155, -105, 39
        DC32 -384, -263, 367, 182, -371, -660, 773, -188, 1151, 971, 1333, 1632
        DC32 1435, 774, 1267, 1221, -482, -832, -1489, -237, -210, 860, 890
        DC32 1615, 1064, 472, 1062, 1192, 185, 1077, 989, -568, -992, -1704
        DC32 -449, -902, -2043, -142, -377, -458, -210, -554, -1029, -11, 1133
        DC32 2265, -329, -675, -893, -250, 657, 1187, 519, 1510, 1779, 520, 539
        DC32 1403, 527, 1421, 1302, -563, -871, -1248, -147, -463, 879, -76
        DC32 2334, 2840, 563, 2573, 2385, 632, 1926, 2920, 719, 2023, 1840
        DC32 -545, -723, 1108, 129, -125, 884, 1417, 1632, 925, -94, 1566, 1751
        DC32 -341, 1533, 1551, 591, 395, -274, -76, 981, 2831, 153, 2985, 1844
        DC32 1032, 2565, 2749, 1508, 2832, 1879, 791, 1199, 538, -190, -453
        DC32 1489, -278, -548, 1158, -245, 1941, 2044, 1024, 1560, 1650, 512
        DC32 253, 466, -62, -323, 1151, -473, -376, 507, -433, 1380, 2162, 899
        DC32 1943, 1445, 134, 704, 440, 460, 525, -28, -450, 279, 1338, 0, 971
        DC32 252, -445, -627, -991, -348, -602, -1424, 398, 712, 1656, -107
        DC32 314, -178, 93, 2226, 2238, 518, 849, 656, -462, -711, -447, 174
        DC32 -34, 1191, -119, 42, 1005, -372, 274, 758, 1036, 2352, 1838, 675
        DC32 1724, 1498, 430, 1286, 2133, -129, -439, 0, -373, 800, 2144, 6
        DC32 1587, 2478, 478, 596, 2128, -428, -736, 1505, 385, 178, 980, 139
        DC32 449, 1225, -526, -842, -982, 145, 1554, 1242, 623, 1448, 656, 349
        DC32 1016, 1482, 31, -280, 415, -316, 724, 1641, 360, 1058, 556, -436
        DC32 -358, 1201, -355, 1123, 1939, 401, 1584, 2248, -527, -1012, 355
        DC32 233, 238, 2233, -550, -897, -639, -365, -501, 1957, 389, 1860
        DC32 1621, 162, 1132, 1264, -237, 1174, 1390, -640, -411, 116, -228
        DC32 1694, 2298, 1639, 2186, 2267, 562, 1273, 2658, 323, 338, 1774, 578
        DC32 1107, 852, 22, 594, 934, -143, 718, 446
        DC32 50, 71, -9, -338, -698, -1407, 102, -138, -820, -310, -469, -1147
        DC32 414, 67, -267, 1060, 814, 1441, 1548, 1360, 1272, 1754, 1895, 1661
        DC32 2019, 2133, 1820, 1808, 2318, 1845, 644, -93, 454, 858, 329, -136
        DC32 489, -258, -128, -198, -745, -41, -52, -265, -985, 346, 137, 479
        DC32 -1741, -748, -684, -1163, -1725, -367, -895, -1145, -784, -488
        DC32 -946, -968, -85, -390, -725, 215, -340, -171, 1020, 916, 1969, 564
        DC32 179, 746, 662, 977, 1734, 887, 622, 914, 939, 856, 1165, 309, 688
        DC32 803, 917, 161, 570, 118, -20, -283, -816, -42, 204, -1228, -325
        DC32 -462, -963, -202, -143, -988, -484, -361, -702, -978, -477, -302
        DC32 -790, -1188, -100, -786, -1088, -1054, -947, -1684, -202, -843
        DC32 -782, -1039, -1378, -901, -624, -110, -85, 356, 213, -10, -493
        DC32 364, 774, 425, 822, 479, -83, 557, 520, -992, -1560, -572, -603
        DC32 -741, -26, -502, -638, -903, 209, 306, 147, -316, -593, -596, -85
        DC32 -211, -225, -918, -529, 117, 233, -439, -738, 1101, 751, 633, 1457
        DC32 1716, 1511, 1765, 1457, 910, 1122, 1156, 849, 1354, 868, 470, -871
        DC32 -1150, -1796, -871, -861, -992, -118, 155, 212, -1051, -849, -606
        DC32 -1117, -1849, -2750, -1019, -1427, -1869, 370, -184, -414, 959
        DC32 493, 104, 958, 1039, 543, 154, 653, 201, 1249, 507, 150, 663, 503
        DC32 230, 623, 777, 675, 659, 88, -110, 843, 244, 224, 382, 541, 302
        DC32 724, 433, 666, 1166, 734, 341, -138, 20, -397, -1183, -424, -46
        DC32 -321, -352, -124, 1333, 1021, 1080, 262, 366, 723, 922, 283, -551
        DC32 31, -636, -611, -689, -697, -415, -952, -779, -201, -1329, -598
        DC32 -359, -953, -1285, 166, 493, 305, 221, 846, 703, 610, 840, 936
        DC32 774, -723, -1324, -1261, -357, -1025, -1388, -1096, -1376, -365
        DC32 -1416, -1881, -608, -1798, -1727, -674, -545, -1173, -703, 678
        DC32 786, 148, -123, 696, 1288, 644, 350, -10, 414, 614, 15, 137, 344
        DC32 -211, -814, -1512, -819, -391, -930, -588, 47, -591, -898, -909
        DC32 -1097, -163, -1272, -1167, -157, -1464, -1525, -389, -1274, -1188
        DC32 -624, 671, 213, 454, 124, -274, -525, -729, -496, -152, -1344, 122
        DC32 135, -2905, -589, -394, -1728, 441, -50, 1476, 904, 787, 316, 236
        DC32 -440, -347, 217, 413, -911, -917, 121, -455, -932, 202, -92, -465
        DC32 -375, 488, 390, 474, 876, 729, 316, -1815, -1312, -669, 87, 962
        DC32 432, 563, -249, -1058, 250, 285, 1105, 1141, 427, 696, -1038
        DC32 -1664, -1582, -948, 346, 160, -309, -272, -858, 670, 624, 1250
        DC32 -944, -408, -666, -606, -320, -384, -492, 230, 65, 334, -50, -16
        DC32 -16, -690, -1397, 1791, 1716, 1399, 2478, 2063, 1404, 1245, 1471
        DC32 1426, -382, -1037, -2, 173, -398, 1145, 1491, 2024, 1801, 772
        DC32 1274, 1506, 1429, 1735, 2001, 1079, 1218, 1273, -1154, -1851
        DC32 -1329, -808, -1133, -1096, -451, -1033, -1722, 65, 578, -84, -1476
        DC32 -2434, -1778, -765, -1366, -494, -218, -594, -931, 337, -236, 562
        DC32 2357, 2662, 1938, 1489, 1276, 874, 189, 358, 374, -1519, -2281
        DC32 -2346, -967, -1271, -2095, -628, -1188, -1542, 1661, 1043, 546
        DC32 565, 1061, 732, -64, -836, -434, -436, -96, 203, 1078, 1216, 1636
        DC32 907, 1534, 986, 326, 965, 845, 142, -84, 197, 470, 2379, 1570
        DC32 1133, 470, 1214, 395, 1376, 1200, 1125, 1042, 348, -543, -1234
        DC32 -376, -215, -181, 481, -1947, -1621, -210, -750, -1185, 390, 29
        DC32 -399, 27, 820, 1236, 755, 695, 979, 409, -174, 1197, 1035, 912
        DC32 1356, 1846, -992, -1437, 484, -1485, -1700, 208, -412, 1204, 1432
        DC32 -271, 896, 1144, -416, 1777, 1434, -1696, -2644, -204, -1789
        DC32 -1551, 1033, -1656, -1559, 1303, -1253, -1589, 1081, -669, -1095
        DC32 -66, -682, 320, -345, 659, 305, 1069, -1292, -804, -19, -1635
        DC32 -1291, 29, -1683, -497, 71, -287, -7, -100, -494, -962, -237, 852
        DC32 1881, 1740, -1217, -1387, 227, -660, 302, 373, 96, 1087, 1257
        DC32 -1074, -1669, 160, 485, 2076, 1798, -934, -220, 552, -596, -612
        DC32 237, 336, 1720, 879, 643, 629, 434, 1267, 522, 1633, 15, 244, -441
        DC32 1475, 717, 184, 1819, 1590, 1709, 988, 261, 937, 2093, 2345, 1520
        DC32 2139, 1858, 1606, -577, -579, -1203, -956, 135, -488, -464, 51
        DC32 -338, -629, -348, -723, 1146, 2073, 1442, 2192, 1466, 911, -1444
        DC32 -1572, -2278, 1400, 710, 1297, 1335, 633, 928, 1434, 2194, 2594
        DC32 2422, 2204, 1881, 982, 2242, 1854, 380, 792, 1145, -63, -539, 414
        DC32 -252, -964, -314, -1261, -683, -780, -831, -526, -1005, -1666
        DC32 -1135, -424, -1611, -452, -299, 1268, 1048, 642, 1147, 853, 856
        DC32 -675, -336, 139, 2268, 1343, 1418, 29, 768, 797, -1224, 423, 564
        DC32 -1318, -1082, 245, -1302, -812, 573, -1298, -1617, 646, -968, 834
        DC32 723, 993, 1652, 2027, -191, -817, 432, 662, 60, 198, 626, 997
        DC32 1330, 1648, 1963, 1289, -1597, -93, -45, -1088, 37, -84, 1653
        DC32 2607, 2337, 1065, 2040, 2377, 1139, 2326, 2118, 859, 357, 1510
        DC32 664, 1227, 1099, 479, 1360, 912, 1897, 1754, 2019, 1168, 1909
        DC32 1784, 399, 34, 256, -593, -304, -1053, 547, 1694, 1407, 647, -99
        DC32 -341, 1492, 1647, 1190, 38, -644, -212, 395, 846, 222, -704, -765
        DC32 -716, -724, -1964, -2804, -150, 291, -82, 1233, 1459, 1007, -140
        DC32 -155, 153, 439, 297, 1568, -1529, -410, -636, 1536, 455, -237
        DC32 -1328, -139, -260, 531, 554, 868, 269, 1264, 606, -233, 883, 463
        DC32 742, 600, -120, -73, 421, 212, -439, -58, 804, -1286, -1241, 728
        DC32 294, -490, 50, -591, -905, -1254, 42, -687, 147, -25, 273, 596
        DC32 -311, 1213, 601, -754, 849, 584, 429, 607, 587, -602, -166, 461
        DC32 -796, -823, 777, 1380, 910, 1755, 119, 1417, 972, -219, -880
        DC32 -1596, -1049, -1010, 438, -713, -1379, 78, 0, -447, -1179, -1136
        DC32 -1319, -1573, 2248, 1767, 1309, 946, 1583, 1432, 1150, 482, 436
        DC32 -469, -1108, 618, -447, -966, 1088, -1252, -1515, -114, -1104
        DC32 -2008, -579, 210, 613, 497, -1975, -1437, 642, -1269, -856, 1011
        DC32 -1646, -1185, 1063, -1555, -672, 1204, -1692, -1114, 623, -979
        DC32 -1326, -1277, 539, -147, 894, -1354, -897, -434, 888, 475, 428
        DC32 153, -384, 338, -1492, -511, 359, -974, -1115, -470, 105, -550
        DC32 677, -937, -1145, 877, 380, -260, 210, 1685, 924, 1256, 1775, 1190
        DC32 1095, 1419, 631, 533, 627, 299, -347, -411, -534, 647, -650, 29
        DC32 -595, -378, -1367, 1563, 1402, 1121, 1465, 1089, 1410, 648, -2096
        DC32 -1090, -6, 311, -194, -869, -639, -831, 416, -1162, -1224, 1349
        DC32 -1247, -941, 1813, -2193, -1987, 453, -619, -1367, -956, -1606
        DC32 -1972, -1507, -1175, -1057, -1104, -377, 601, 201, 1876, 825, 374
        DC32 -430, -1323, 29, -1397, -1249, -1331, -1007, -1504, 960, -1401
        DC32 -2009, 197, -1379, -1949, -236, -1077, 123, 422, 615, 1269, 546
        DC32 -306, 1526, 904, 1194, 1788, 1177, -626, -884, -1526, 199, 766
        DC32 1504, -1065, 862, 197, -1034, -1773, -887, -800, 145, 599, -1134
        DC32 -519, 626, -1205, -1926, 500, -910, -1041, -1395, -1476, -1567
        DC32 -969, -523, 842, 34, 1794, 646, 862, -1207, -1888, -1002, -78, -9
        DC32 -672, 1044, 759, 80, -600, 1139, 1019, 57, 2000, 1422, -833, 1414
        DC32 1121, -1202, 1630, 1260, -461, 1420, 1244, 1537, 975, 253, -283
        DC32 324, -359, 599, -195, 106, 588, 62, -587, -757, 645, 205, 51, 1201
        DC32 758, -1209, 673, -390, -624, 1581, 941, -151, 1023, 735, 2820
        DC32 1301, 690, -302, 524, -99, -900, -1588, -1189, 1084, 251, 238
        DC32 2014, 1792, 1010, 1245, 1633, 1741, -1227, -1540, -1208, -621, 456
        DC32 -109, 40, -65, 788, -805, -699, -1350, -583, 904, 832, -801, 532
        DC32 594, 1972, 1408, 1351, -1177, -1880, -2114, -773, 568, 948, -1015
        DC32 1079, 1260, -1111, 482, -130, 1778, 1044, 780, -1491, 245, 912
        DC32 -316, -1141, -917, -536, -1442, -2346, -785, -1546, -1988, -2003
        DC32 257, 909, -1849, -633, -1209, -1538, -1918, -1054, 1606, 2239
        DC32 1576, -567, -1500, -1544, -1279, 195, 1369, -817, 293, 1219, -525
        DC32 630, 1197, -1698, -2425, -1840, -303, 731, 747, -1169, -251, 269
        DC32 -950, -75, 1684, -1182, -453, 1005, -1599, 585, 378, -2075, -571
        DC32 -427, -529, -1159, -1171, -283, -205, -564, -796, 1246, 717, 2277
        DC32 927, 539, -454, 559, 440, -717, 1460, 1615, -1030, 1052, 1610
        DC32 -1169, -138, 847, 226, 39, -612, -1251, -106, -729, -651, 968
        DC32 1302, -714, -636, 1727, 353, 1069, 410, -798, -156, 1099, -574
        DC32 918, 446, -1310, 1012, 466, 1408, 1591, 765, 1429, 1380, 1757
        DC32 1949, 1956, 2378, 1578, 2047, 2148, 916, 98, -7, 1893, 1418, 2141
        DC32 348, 1405, 1579, 152, 1134, 1801, -267, 154, 1395, -1166, 469
        DC32 1054, -1142, -405, -1073, -1341, -2264, -1581, -364, 869, 1706
        DC32 -1162, 549, 1550, -1225, -1932, -1666, -1485, -1977, -2055, -1727
        DC32 -906, -98, -1897, 233, 1492, 892, 108, -331, -1728, -1170, -1700
        DC32 -1060, 1980, 1790, -1070, -1741, -1909, -11, 1539, 1317, -1600, 94
        DC32 497, 421, 443, -197, -1578, -349, -994, -599, -539, 1140, -965
        DC32 -1419, -129, -1341, 175, -447, -375, 1311, 2055, -371, -650, -307
        DC32 -1073, 605, 365, -2057, -113, 430, 652, 914, 967, -1012, -1586
        DC32 -2323, 1505, 1248, 559, 262, -486, -401, -1727, 1342, 1546, 50, 56
        DC32 432, -330, 119, -604, -1517, -1080, -810, 946, 1127, 1055, -1400
        DC32 -1703, -1712, -1270, -704, -1317, 807, 1821, 1143, 2760, 1606
        DC32 2171, 1120, 409, -150, -147, 404, 959, 2439, 1911, 2189, -906
        DC32 -141, -866, -904, -142, -458, -557, -708, -1679, -830, -1431
        DC32 -1583, -1842, -1346, -1086, -1604, -272, 915, -1196, 772, 1056
        DC32 -638, -1234, -1897, -500, -81, -822, -1289, -1613, -735, -117, 785
        DC32 168, -1090, 1133, 922, -1096, -746, 1384, 287, -547, -1063, -1376
        DC32 -2201, -1204, -2176, -1570, -1757, -1511, -2241, -771, -1737, 1099
        DC32 830, -1588, 724, 1243, -1542, 693, 805, -1690, -240, 1665, -1700
        DC32 -4, -668, 2149, 816, 1042, -818, -1841, 22, -764, -507, 449, -1151
        DC32 -617, 289, -843, -1596, -240, 498, -234, -657, -752, 480, 1678
        DC32 -319, -481, 193, -811, 171, -119, -2128, -202, -848, 1717, 1140
        DC32 1700
        DC32 67, -17, 66, -12, -1690, -581, -104, -272, -1076, -1186, -1845
        DC32 -376, -1140, -926, -420, -58, -259, -656, -1134, -553, 1788, 1227
        DC32 455, 129, 462, 441, -240, -528, 840, 514, 130, -75, 1114, 623, 153
        DC32 216, 1068, 564, -6, -276, 1119, 727, 190, -68, 704, 306, 119, -264
        DC32 329, 61, -100, 156, 364, 123, 183, -208, -171, -123, 220, -65
        DC32 -306, -62, 402, 17, -660, -938, -266, 0, 385, 235, 276, 285, 320
        DC32 268, -336, -200, -724, 17, -84, 381, -544, 429, 494, 519, -117
        DC32 288, 304, 329, 643, 157, 701, 508, 1200, 625, 796, 608, 998, 421
        DC32 492, 632, 1204, 780, 446, 132, 1257, 844, 547, 449, 829, 658, 541
        DC32 470, 1132, 1258, 918, 639, 547, 51, 423, 279, 9, 392, 83, 94, 542
        DC32 543, 229, -147, -198, 129, 194, -185, -863, -1321, -302, 30, -597
        DC32 -629, -19, 114, -900, -1081, 466, 353, -1483, -1573, 15, -143
        DC32 -1708, -2059, -751, 196, -1876, -2067, -642, -258, -2335, -1470
        DC32 -450, -564, -584, -186, -872, -414, -1805, -988, -1125, -1310
        DC32 -726, -1129, 28, 169, -1039, -864, -718, -246, 484, 36, -233, -49
        DC32 265, 67, 289, 467, 178, 543, 810, 540, 84, 282, 672, 703, -975
        DC32 -777, 129, 287, -938, -227, 955, 595, -1617, -289, 836, 649, -1847
        DC32 -215, 1106, 718, -2034, -1085, 650, 440, -2101, -529, 907, 575
        DC32 -2011, -336, 670, 204, -2389, -692, 360, 137, -2156, -2204, -9
        DC32 280, -266, 119, 39, 193, 78, -59, -120, 226, -975, -858, -781
        DC32 -1095, -619, -413, -451, -842, -1216, -1321, -813, -883, -1376
        DC32 -1615, -394, -428, -737, -1113, -549, -790, -880, -975, -967, -642
        DC32 -985, -886, -1273, -1361, -473, -804, -1401, -1407, 160, -265
        DC32 -919, -275, -248, -250, -718, -380, 97, -103, -375, -229, -415
        DC32 -193, -135, -555, 628, 361, 119, 216, 579, 364, 391, 209, 634, 522
        DC32 -154, -148, 526, 389, 170, 33, 105, 267, 64, 380, -1503, -1000
        DC32 -30, -369, -1070, 58, 647, 223, -1520, -291, 621, 307, -1531, 156
        DC32 762, 404, -2029, 141, 734, 499, -1849, -650, 306, 512, -187, -104
        DC32 -59, 438, 134, -230, 156, -186, -61, -260, -16, 10, -569, -3, -421
        DC32 -297, -1725, -521, -346, 178, -1362, -59, -44, 157, -2146, -461
        DC32 -470, -349, -2170, -1, -369, -121, -1579, -373, -900, -1015, -1117
        DC32 -591, -613, -784, -561, 122, -75, -449, -4, -171, -123, -372, 192
        DC32 168, -76, -132, 252, -107, 340, 210, 392, 509, 272, 181, -109, 145
        DC32 218, 119, -416, -263, 485, 265, -181, -8, -286, 226, -244, -218
        DC32 69, -290, -158, 191, -1, -64, -592, -90, 213, -96, 255, 435, 178
        DC32 -80, -369, -18, -33, -80, -42, 415, 140, -222, 1143, 651, 649, 329
        DC32 767, 556, 249, 235, 948, 413, 442, 279, 141, 339, 356, 557, -470
        DC32 -170, 99, 237, -569, -800, 352, 565, 282, 473, 470, 332, -199
        DC32 -690, -1284, -917, -193, -426, -800, -1122, -26, -371, -490, -193
        DC32 637, 595, 519, 330, 408, -115, 79, 12, 477, 87, -103, -376, -666
        DC32 -347, -277, -291, -510, -481, 169, 297, -829, -738, -205, -171
        DC32 -320, -540, 328, 283, -859, -958, 442, -2, 556, 686, 130, 56, 1383
        DC32 1012, 755, 427, 612, 741, 628, 553, -339, -796, 134, 277, -633
        DC32 -1085, -2, -246, -880, -1035, -1607, -1064, -994, -474, -1138
        DC32 -488, -414, -795, 73, -206, -8, -139, 439, 204, -176, -578, 23
        DC32 131, -269, -757, -191, 245, -109, -338, 112, 316, 120, -406, -118
        DC32 611, -180, -186, -645, 115, -173, 34, -518, -489, -151, 61, -583
        DC32 -844, 220, -138, -681, -1020, 391, -17, -598, -321, 157, -295, 129
        DC32 155, -926, -875, -987, 285, 241, -83, -125, -125, 620, 597, 432
        DC32 92, 393, 78, 409, 61, -393, -739, -413, -748, 83, 54, 361, 27
        DC32 -1084, 130, -337, -694, -1565, 297, 318, -19, -1873, 36, 51, -317
        DC32 -2323, -246, 231, -84, -2306, -783, 40, -179, -2233, -930, -474
        DC32 -462, -754, -86, -288, -626, -2411, -455, -63, 171, -1099, -1094
        DC32 -26, -143, -1193, -455, -406, -381, -605, -210, -96, -51, -580
        DC32 -476, -276, -15, -1195, -634, -1203, -881, -378, -221, -669, -952
        DC32 594, 178, -403, -676, 763, 327, 601, 290, 172, 300, 203, 157, -56
        DC32 -336, 356, 24, -228, -296, -259, -29, -186, 263, 416, 14, -353
        DC32 373, -12, -216, 257, 96, 174, 57, -1526, -616, -954, -499, -497
        DC32 -152, -333, 125, 105, 200, 179, -97, -331, -224, 765, 697, 760
        DC32 256, 301, 59, 455, -85, 204, 288, -514, 240, 251, -109, 256, 417
        DC32 -34, -413, 101, 430, 384, 156, -31, -10, 206, 426, 589, 145, 143
        DC32 71, 808, 906, 333, 349, 986, 938, 589, 331, 1300, 824, 187, 509
        DC32 1062, 653, 379, 466, 1462, 937, 401, 274, 787, 861, 265, 2, 609
        DC32 553, 28, 305, 926, 340, 106, 386, 241, -267, -147, 225, -178, -534
        DC32 347, 502, -643, -381, 397, 30, -651, -733, -435, 398, -407, -726
        DC32 -484, -248, -789, -914, -438, -476, -498, -390, 75, -295, -964
        DC32 -590, -606, 150, -121, -49, -155, -78, 935, 550, 389, 38, -321
        DC32 127, 424, 315, -285, -113, 283, 259, 658, 203, 322, 486, 903, 505
        DC32 748, 417, 611, 423, 555, 512, 239, -83, -578, -19, -339, -731, 349
        DC32 13, -934, -1399, -114, -360, 107, 692, 182, 90, -1243, -1538
        DC32 -1551, -725, -568, -903, -1363, -525, -517, -853, -861, -1004
        DC32 -168, -690, -835, 63, -137, -556, -547, 144, -286, -817, 485, 319
        DC32 -147, -408, 526, 246, -347, -434, 297, -28, -290, -471, -1110
        DC32 -1285, -460, -359, -988, -794, 1347, 1299, 690, 523, 1216, 1068
        DC32 1094, 757, 825, 1140, 752, 494, 1252, 1365, 1195, 898, 521, 1053
        DC32 532, 432, -334, -216, -313, -263, -160, 52, -472, -155, 127, 136
        DC32 -380, 44, 851, 410, -162, -489, 123, -255, -796, -667, 1090, 917
        DC32 789, 493, 1397, 1197, 558, 202, -51, -118, -342, -701, 83, 108
        DC32 -42, -441, 61, 95, 287, 256, -27, 89, 524, 531, 351, 227, 592, 545
        DC32 697, 155, -164, 307, 638, 274, -489, -50, 754, 240, -166, -124
        DC32 -116, -579, -1212, -63, 190, -295, -1040, -1296, 147, -376, -177
        DC32 -113, 841, 1241, 1051, 668, 2, 293, 551, 304, -1096, -953, -248
        DC32 376, -750, -965, 87, 516, -275, -516, 689, 391, -379, -643, 876
        DC32 594, -390, -1013, -645, 573, -107, -568, -689, -826, -1025, -27
        DC32 -328, -203, 861, 749, 548, 233, -1660, -1043, 451, 108, -660, -620
        DC32 430, 236, 21, -396, -1158, -631, 1372, 1298, 967, 577, 1125, 1125
        DC32 589, 454, -323, -865, -467, 153, -468, -699, -804, -509, -392
        DC32 -718, -204, -35, -603, -1093, -567, -162, -505, -1004, -102, 350
        DC32 219, 224, 423, 252, 395, 591, 608, 363, -746, -96, 373, 172, 171
        DC32 295, 714, 339, 233, 77, 107, 277, 157, 153, -499, -356, 1547, 1073
        DC32 576, 494, -292, -339, -504, -592, -903, -72, -619, -481, -1594
        DC32 -1117, -567, -254, -793, -507, -564, -291, -492, -532, 502, 560
        DC32 -382, 427, 600, 230, -227, 477, 251, 75, 285, 842, 813, 476, -1310
        DC32 -1333, 186, 377, -587, -917, 643, 381, -1186, -553, 411, 82, -1127
        DC32 -820, -174, -540, -604, 119, 543, 205, -380, 657, 909, 567, 112
        DC32 -298, -374, 114, -857, -251, 56, 159, 401, 345, -34, -140, -111
        DC32 -607, 41, 614, 355, -114, -77, 474, 578, 56, 1450, 924, 1098, 1420
        DC32 741, 400, 246, 22, 588, 313, -121, 327, 831, 472, -1138, -608, 856
        DC32 552, -1241, -1072, 638, 600, -358, 254, -333, -303, -646, 739, 358
        DC32 74, 1226, 1671, 1221, 849, 2241, 1624, 983, 636, 1841, 1477, 749
        DC32 384, 350, 263, 87, 128, -1902, -941, -144, -64, -1734, -255, 288
        DC32 -31, -2644, -1238, 366, 235, -1643, -1092, -1344, -304, -541
        DC32 -1075, -1116, 123, -1178, -252, -816, -180, -1016, 533, 565, 233
        DC32 -487, -430, -188, 334, 867, 1236, 534, 171, -1590, -1607, 635, 630
        DC32 -2196, 310, 924, 412, -2358, -328, 956, 529, -2639, -377, 630, 278
        DC32 -2602, 317, 799, 299, -2406, 133, 340, 31, -2156, -1468, 131, 125
        DC32 -1184, -490, -139, 46, -744, 447, 891, 564, 67, -451, 646, 604
        DC32 -553, -429, -876, 396, 162, -66, 1305, 915, 479, 579, 1088, 794
        DC32 450, 278, 566, 324, -1057, -154, 148, -177, -2545, 168, 1070, 592
        DC32 -2351, -42, 819, 345, -2344, -707, 721, 250, -2175, -1497, -309
        DC32 122, -78, -73, 120, 173, -4, 262, -263, -261, -431, -64, -405
        DC32 -732, -2609, 116, -83, -193, -1525, -944, -477, -725, -508, 307
        DC32 170, 172, 832, 417, 832, 686, -225, 177, 894, 818, -482, -389
        DC32 1279, 1039, -383, 201, -350, 40, 730, 635, 226, 526, 503, 462, 338
        DC32 398, 535, 714, 40, -282, 1482, 1471, 1085, 731, 1561, 1072, 909
        DC32 693, 1419, 1282, 889, 879, 1153, 728, 1186, 840, -226, 1130, 949
        DC32 689, -494, -986, -1556, -128, -568, -721, -713, -26, 317, 524, 70
        DC32 135, -405, -865, -1766, -652, -174, -801, 885, 773, -153, -91
        DC32 1099, 751, -506, -1149, 853, 646, 241, 782, 519, 539, 1853, 1700
        DC32 1101, 684, -1249, -1486, -464, 188, -893, -1409, -1312, -341, -135
        DC32 438, -175, 18, 1111, 976, 319, 208, -1430, -1768, 83, 458, -530
        DC32 -1000, 307, 129, -840, -15, -29, -356, -911, -924, -1147, -242
        DC32 -119, -528, 127, -133, -761, -765, 190, -83, -315, 895, 522, 231
        DC32 -222, 102, -63, -428, 316, 699, 379, 70, 25, 716, 314, -108, 507
        DC32 874, 566, 238, 108, 941, 519, 195, 425, -60, -427, 257, 139, -103
        DC32 -630, 446, 334, 370, 412, 48, -172, -690, -283, 557, 187, -286
        DC32 158, 483, 140, 270, -344, -631, 924, 579, -116, 132, 142, 466, -68
        DC32 -64, 230, -145, -302, -542, -803, -912, 1018, 737, -773, 1015, 630
        DC32 297, -2596, 95, 445, 336, -2122, 491, 510, 191, -1253, 161, -2
        DC32 -324, -1450, -633, -712, -105, -842, -254, -411, 100, -640, -290
        DC32 1010, 763, -650, 313, 1169, 730, 140, 505, 1030, 766, 772, 287
        DC32 1067, 823, 495, 749, 305, 323, -164, 462, 78, 399, -342, -874, 69
        DC32 597, -16, 620, 621, 337, -138, -444, -265, 218, 84, -450, 953, 666
        DC32 -222, -803, 541, 604, -921, -1376, 244, 116, -841, -723, 630, 588
        DC32 140, 663, 294, 368, 935, 1046, 881, 759, 1746, 1464, 916, 628, 436
        DC32 963, 281, 1, -119, 74, 542, 213, 1, -567, 301, 241, 260, 435, 222
        DC32 396, 936, 957, 1108, 703, 510, 506, 808, 478, 601, 694, 960, 620
        DC32 972, 741, 980, 600, 834, 717, 767, 684, 643, 972, 935, 638, 501
        DC32 661, 720, 851, -105, -632, -303, -117, -429, 130, 789, 442, -522
        DC32 -188, 704, 373, -759, 42, 814, 523, -531, -1137, 373, 578, -682
        DC32 -1203, -455, 285, -1163, -1577, -1098, 44, 81, -82, 712, 363, 477
        DC32 246, 954, 622, 1604, 1622, 1277, 891, 1409, 859, 924, 892, 774
        DC32 1041, 947, 1142, 40, -546, -75, 288, -616, -106, -697, -26, -169
        DC32 -160, -891, -739, -279, -384, -1029, -350, 1781, 1308, 1046, 816
        DC32 1580, 1533, 1472, 1178, 1505, 1076, 1216, 899, 890, 904, 564, 654
        DC32 920, 692, 1021, 856, -493, 132, 177, 505, 71, 195, -28, 97, 456
        DC32 351, -164, 88, 439, 278, -40, 350, 1395, 949, 234, -95, -805, -472
        DC32 38, -163, 367, -98, 489, 523, 1025, 1178, 1212, 906, 319, 1314
        DC32 814, 461, -123, -543, -804, 447, -748, -324, -897, -1127, -737
        DC32 -501, -789, -713, 715, 777, 1239, 922, 1949, 1939, 1368, 865, 730
        DC32 880, 758, 388, -871, 454, 17, -251, -381, -810, -1583, 239, -521
        DC32 -966, -792, 259, -890, -1358, -770, -73, 166, 349, -212, 323, -840
        DC32 -301, 473, 435, -679, -464, 728, 351, -156, -199, 667, 432, 29
        DC32 -252, 415, 480, -731, -379, 145, 559, -528, -631, -1158, -159, 445
        DC32 273, 123, 639, 373, -126, 800, 568, 84, -162, 720, 712, -830, -536
        DC32 -185, 222, 408, 452, 501, 771, -897, -1355, -67, 442, -792, -1406
        DC32 566, 602, 167, -326, 509, 330, -95, -626, -730, -344, 1668, 1217
        DC32 779, 455, 1316, 828, 584, 719, 404, -31, 1013, 789, 89, 107, 891
        DC32 549, 871, 1581, 917, 671, 866, 1479, 1289, 854, 391, 1068, 1122
        DC32 812, 78, -562, 345, 563, 429, -103, 417, 787, -122, -437, 411, 788
        DC32 -913, -417, 602, 754, -226, -16, 151, 760, -700, 118, -104, -14
        DC32 -1128, 48, 284, 393, -390, -419, -639, -116, -910, 306, 316, -13
        DC32 1207, 984, 821, 669, -1195, -693, 140, -213, -884, -416, -199
        DC32 -558, -616, 245, -404, -664, 262, 56, -617, -724, -85, -491, -320
        DC32 -656, -570, -831, -129, -528, -1506, -63, -367, -385, -358, -321
        DC32 4, 51, -366, -214, 319, 511, 146, 671, -17, -291, -110, 464, -139
        DC32 -496, -202, 220, -312, -631, -660, -73, -655, -820, -662, -653
        DC32 -1288, -857, -430, -953, -959, -264, -49, -468, -72, -381, -350
        DC32 -563, -193, -407, 55, -408, -803, 11, -309, 649, 188, -198, -512
        DC32 461, -79, -458, -1318, -263, -134, -523, -1657, -435, -495, -765
        DC32 57, -347, -414, 434, -1141, -242, -664, -857, 34, -68, -707, -338
        DC32 419, 163, -30, -262, -455, -789, -1430, -721, 1006, 664, 269, 25
        DC32 619, 260, 183, 96, -968, -1358, -388, 135, -693, 835, 456, 154
        DC32 1105, 703, 569, 363, 1625, 1326, 985, 748, -220, 219, 76, -208
        DC32 -1455, -1662, 49, 149, -964, -172, -752, -336, 625, 209, -250, -66
        DC32 -1017, -838, -2, 317, -2168, -1485, -138, 123, -1876, -2099, -521
        DC32 85, -967, -366, -695, -881, -921, -1011, -763, -949, -124, -256
        DC32 -352, -660, 178, 463, 354, 304, -1744, -591, -282, 79, -2249, 175
        DC32 867, 499, -138, -180, -181, -21, -2291, -1241, -460, -520, -771
        DC32 451, -10, -308, 271, -65, 4, 214, -279, -435, -43, -348, -670, 35
        DC32 -65, -211, 806, 535, 85, 297, 57, 239, 722, 493, 225, 661, 840
        DC32 547, -540, -376, 14, 349, 469, 721, 331, 162, -544, -752, -62, -10
        DC32 398, -88, 724, 701, -19, -533, -94, 601, 136, -71, -681, -747
        DC32 -166, -344, 261, -50, 161, -52, 485, 337, -1675, 50, 190, -93
        DC32 -2282, -231, -194, -82, -95, -595, -154, 128, 894, 501, 588, 457
        DC32 -345, 206, 122, 110, -631, -227, -569, 3, 408, 239, 397, 226, -197
        DC32 -2, 128, 491, 1281, 904, 292, 215, 538, 306, 259, 509, -677, -1047
        DC32 13, 321, -679, -588, -358, -212, -558, 243, 646, 479, 486, 342
        DC32 634, 532, 107, 802, 331, 136, -112, -398, -1031, -286, -326, -705
        DC32 288, 272, 1299, 1144, 1178, 860, -423, 121, -385, -148, -295, -302
        DC32 -834, -819, 16, -24, -201, -476, 555, 91, -245, 294, -38, -379
        DC32 -962, -1221, -1191, -1518, -273, -395, -390, -1013, -645, 573
        DC32 -1843, -1030, 505, 468, 744, 947, 609, 493, -689, -1172, -628
        DC32 -135, -1026, 195, 411, 196, 1582, 1147, 575, 337, -1239, -777
        DC32 -648, -142, 595, 825, 967, 735, -1206, -970, -81, -342, -745, 13
        DC32 -72, 375, 454, 19, 1407, 921, -1647, -172, 861, 562, 928, 1537
        DC32 1063, 740, -2472, -952, 264, 82, -502, -965, -1334, 123, 867, 1236
        DC32 534, 171, -2320, -460, 780, 363, -1190, -617, 252, -61, -174, 34
        DC32 1011, 788, -2333, 247, 423, 153, -16, -355, 262, 449, -1576, -1073
        DC32 -544, -371, -615, -305, 1051, 805, 687, 528, 6, -182, 935, 875
        DC32 1002, 809, 199, 257, 126, 76, -584, -1138, 599, 556, -1105, -1391
        DC32 -1591, -519, -977, -1325, 108, 347, -722, -975, 365, 101, -145
        DC32 681, 249, -153, 0, -334, -570, 159, 412, 285, -336, -617, -953
        DC32 -966, 887, 689, -1251, 84, -185, -398, -592, 433, 1044, 653, 85
        DC32 329, -40, 361, -433, -705, 466, 574, -154, 654, 592, 290, -167, 72
        DC32 349, 175, 674, 297, 977, 720, 1235, 1204, 757, 488, -400, -269
        DC32 538, 372, -1350, -1387, -1194, -91, 1262, 876, 775, 700, -599, -38
        DC32 -430, -722, 1976, 1630, 991, 608, 111, 276, -226, -96, -947, -388
        DC32 -11, -7, -303, -531, -839, 338, 1734, 1710, 1405, 1013, -516, -855
        DC32 -645, 210, -688, -416, 513, 230, -822, -637, -1146, -320, -952
        DC32 -658, -694, 183, -114, -623, 818, 674, -191, -204, 731, 635, 51
        DC32 1221, 883, 576, -954, -431, 826, 598, -342, -755, -900, -407
        DC32 -1126, -354, -206, -512, -547, -810, -357, -620, 66, 515, -73
        DC32 -410, -872, -945, -1444, -1227, 191, -17, -544, -231, -1540, -544
        DC32 -901, -886
        DC32 -890, -1550, -2541, -819, -970, 175, -826, -1234, -762, -599, -22
        DC32 634, -811, -987, -902, -323, 203, 26, -383, -235, -781, -399, 1262
        DC32 906, -932, -1399, -1380, -624, 93, 87, -414, -539, -691, 37, 633
        DC32 510, -387, -476, -1330, 399, 66, 263, -407, -49, -335, -417, 1041
        DC32 1865, -779, -1089, -1440, -746, -858, 832, -581, -759, -371, -673
        DC32 -506, 2088, -560, -634, -1179, 271, 241, 14, -438, -244, -397, 463
        DC32 1202, 1047, -606, -797, -1438, -51, -323, 481, -224, -584, -527
        DC32 494, 881, 682, -433, -306, -1002, 554, 659, 222, 171, -160, -353
        DC32 681, 1798, 1565, -852, -1181, -1695, -336, -666, 114, -581, -756
        DC32 -744, -195, 375, 497, -465, -804, -1098, 154, 282, -131, -50, -191
        DC32 -719, 323, 732, 1542, -722, -819, -1404, 105, -250, 185, -178
        DC32 -502, -742, 321, 510, 1111, -323, -567, -966, 127, 484, 338, -160
        DC32 52, -338, 732, 1367, 1554, -626, -802, -1696, -286, -586, 676
        DC32 -695, -343, -370, -490, 295, 1893, -630, -574, -1014, -80, 645
        DC32 -69, -6, -318, -364, 782, 1450, 1038, -313, -733, -1395, 120, 60
        DC32 477, -264, -585, -123, 711, 1245, 633, -91, -355, -1016, 771, 758
        DC32 261, 253, 81, -474, 930, 2215, 1720, -808, -1099, -1925, -560
        DC32 -782, 169, -804, -1074, -188, -626, -55, 1405, -694, -716, -1194
        DC32 -660, 354, 329, -514, -55, -543, 366, 1033, 1182, -658, -959
        DC32 -1357, -55, -184, 93, -605, -286, -662, 404, 449, 827, -286, -350
        DC32 -1263, 628, 306, 227, -16, 147, -623, 186, 923, 2146, -674, -890
        DC32 -1606, -443, -228, 339, -369, -790, -409, 231, 86, 1469, -448
        DC32 -581, -1061, 594, 450, -177, -124, -170, -447, 671, 1159, 1404
        DC32 -476, -667, -1511, -77, -138, 716, -177, -372, -381, 451, 934, 915
        DC32 -250, -432, -822, 272, 828, 446, 26, 19, -31, 698, 1692, 2168
        DC32 -646, -977, -1924, -179, -473, 268, -379, -745, -691, 11, 127
        DC32 1033, -488, -917, -825, 61, 323, 135, 147, -145, -686, 685, 786
        DC32 1682, -506, -848, -1297, 35, 90, 222, -23, -346, -670, 455, 591
        DC32 1287, -203, -593, -1086, 652, 352, 437, 39, 63, -457, 841, 1265
        DC32 2105, -520, -882, -1584, -328, -711, 1421, -596, -342, -70, 209
        DC32 173, 1928, -423, -598, -921, 421, 605, -38, -2, -245, -127, 896
        DC32 1969, 1135, -379, -518, -1579, 173, 118, 753, -55, -381, -52, 985
        DC32 1021, 753, -2, -291, -891, 753, 992, 423, 264, 131, -196, 895
        DC32 2274, 2543, -635, -1088, -2499, -529, -982, 526, -764, -830, -548
        DC32 -436, 316, 599, -675, -940, -746, -57, 236, -11, -201, -81, -798
        DC32 16, 845, 1558, -737, -985, -1212, -468, 17, 290, -279, -584, -700
        DC32 183, 822, 705, -265, -492, -1187, 421, 152, 468, -390, 166, -268
        DC32 39, 1550, 1868, -635, -966, -1571, -453, -492, 910, -284, -1027
        DC32 -75, -181, -133, 1852, -445, -624, -1174, 420, 367, -49, -389
        DC32 -212, -169, 707, 1073, 1208, -539, -710, -1449, 83, -163, 484
        DC32 -236, -543, -355, 338, 1175, 814, -246, -309, -958, 606, 760, 60
        DC32 166, -8, -163, -306, 1849, 2563, -747, -1025, -1783, -419, -446
        DC32 209, -718, -566, -534, -506, 693, 857, -463, -697, -1082, 325, 431
        DC32 -206, -15, -8, -763, 545, 919, 1518, -611, -783, -1313, 256, -55
        DC32 208, -165, -348, -662, 321, 680, 930, -326, -429, -951, 484, 446
        DC32 570, -197, 72, -73, 909, 1455, 1741, -563, -737, -1974, -124, -416
        DC32 718, -478, -404, -314, -16, 446, 1636, -551, -537, -750, -58, 638
        DC32 214, 55, -185, -271, 1148, 1301, 1212, -483, -671, -1264, 117, 285
        DC32 543, -204, -391, -111, 513, 1538, 854, -114, -190, -978, 877, 595
        DC32 464, 260, 260, -311, 748, 2283, 2216, -517, -945, -2171, -326
        DC32 -708, 378, -812, -691, -232, -560, 687, 1409, -732, -690, -836
        DC32 -359, 645, 386, -265, 62, -678, 145, 1644, 1208, -555, -988, -1233
        DC32 -78, 14, 114, -327, -358, -489, 392, 677, 697, -201, -236, -1140
        DC32 693, 449, 178, -243, 256, -433, 611, 1385, 2456, -612, -901, -1464
        DC32 -307, -17, 499, -315, -667, -254, 256, 428, 1463, -486, -422
        DC32 -1056, 655, 370, 18, -102, -185, -276, 755, 1578, 1335, -488, -603
        DC32 -1418, 182, -93, 870, -73, -458, -348, 835, 862, 957, -282, -333
        DC32 -746, 547, 839, 428, 273, -89, 13, 940, 1708, 2576, -418, -1084
        DC32 -1758, -44, -358, 259, -497, -643, -560, 99, 557, 961, -421, -766
        DC32 -917, 295, 326, 184, 175, 15, -626, 532, 878, 1981, -443, -768
        DC32 -1275, 221, 156, 268, 39, -363, -505, 695, 772, 1140, -162, -459
        DC32 -912, 709, 444, 658, 25, 303, -312, 1268, 1410, 1715, -297, -766
        DC32 -1836, -263, -108, 1070, -406, -13, -129, 57, 438, 2734, -374
        DC32 -487, -835, 304, 696, 164, 104, -235, 5, 1611, 1900, 1399, -229
        DC32 -582, -1325, 405, 192, 817, -87, -438, 111, 1028, 1199, 993, 68
        DC32 -175, -934, 1033, 1117, 451, 478, 200, -248, 2127, 2696, 2042
        DC32 -835, -1323, -2131, -799, -692, 466, -812, -1032, -469, -622, 288
        DC32 920, -701, -841, -1070, -411, 512, 8, -390, -91, -744, -30, 1043
        DC32 1161, -822, -1148, -1156, -294, -46, 110, -411, -374, -678, 214
        DC32 531, 668, -406, -420, -1194, 487, 232, 303, -318, 91, -472, 123
        DC32 1232, 2445, -722, -952, -1495, -738, -675, 1332, -543, -606, -211
        DC32 -95, -98, 1508, -549, -514, -1193, 473, 211, 73, -288, -112, -389
        DC32 537, 1332, 1258, -567, -755, -1545, 71, -283, 632, -170, -481
        DC32 -493, 681, 1002, 817, -356, -331, -877, 419, 706, 346, 241, -34
        DC32 -326, 377, 1950, 1883, -727, -1075, -1625, -233, -543, 116, -524
        DC32 -806, -585, -73, 478, 729, -288, -925, -1143, 173, 447, -52, 68
        DC32 -229, -606, 449, 529, 1797, -591, -875, -1363, 183, -144, 324
        DC32 -103, -452, -666, 623, 488, 1176, -238, -511, -1004, 326, 552, 458
        DC32 136, 108, -319, 626, 1343, 1883, -490, -646, -1730, -186, -449
        DC32 984, -738, -76, -170, -550, 755, 2560, -496, -510, -947, 210, 694
        DC32 -52, 84, -322, -199, 1090, 1625, 1224, -376, -603, -1396, 343, 74
        DC32 632, -175, -502, -32, 972, 1332, 734, 52, -295, -1113, 1065, 918
        DC32 160, 393, 107, -397, 1214, 2649, 1741, -632, -1201, -1891, -719
        DC32 -277, 353, -651, -880, -122, -211, 209, 1338, -562, -714, -1059
        DC32 -208, 388, 159, -320, -61, -551, 293, 1092, 1443, -648, -865
        DC32 -1253, -49, -143, 305, -401, -227, -585, 561, 532, 927, -117, -443
        DC32 -1188, 507, 436, 292, -79, 233, -458, 671, 1025, 2396, -633, -842
        DC32 -1525, -308, -286, 640, -373, -621, -407, 418, 253, 1305, -315
        DC32 -581, -1137, 572, 685, -281, 61, -68, -371, 991, 1101, 1498, -493
        DC32 -683, -1362, -47, 164, 704, -256, -314, -268, 631, 949, 1052, -118
        DC32 -348, -833, 68, 1180, 568, 152, 117, 34, 1113, 1902, 2239, -601
        DC32 -959, -1706, -143, -489, 480, -332, -655, -574, 54, 353, 1192
        DC32 -462, -652, -796, 150, 549, 112, 195, -111, -515, 679, 1108, 1647
        DC32 -558, -749, -1217, -9, 272, 341, -53, -265, -535, 489, 843, 1298
        DC32 -120, -482, -1032, 632, 543, 408, 179, 306, -526, 1124, 1464, 2244
        DC32 -417, -786, -1562, -224, -384, 1364, -377, -459, -25, 385, 489
        DC32 2174, -332, -651, -829, 544, 553, 61, 22, -113, -89, 1128, 1725
        DC32 1524, -216, -373, -1653, 161, 316, 908, -165, -222, -67, 1362
        DC32 1175, 789, 73, -252, -767, 738, 932, 616, 362, 246, -126, 787
        DC32 2654, 3027, -691, -1106, -2190, -565, -588, 524, -590, -979, -490
        DC32 -263, 397, 982, -577, -837, -945, -22, 435, -49, -190, -118, -629
        DC32 -88, 1240, 1513, -636, -1051, -1019, -291, 189, 259, -257, -470
        DC32 -629, 145, 945, 894, -326, -364, -1094, 543, 260, 630, -202, 189
        DC32 -209, 357, 1379, 2091, -569, -1075, -1449, -714, -239, 919, -420
        DC32 -705, -84, -109, -114, 2407, -413, -529, -1177, 482, 368, 131
        DC32 -186, -72, -131, 861, 1255, 1220, -611, -658, -1341, 227, -121
        DC32 631, -176, -489, -218, 745, 1175, 957, -321, -148, -936, 671, 966
        DC32 216, 340, -3, -143, 469, 1848, 2437, -729, -961, -1683, -213, -254
        DC32 321, -511, -438, -521, -126, 725, 903, -340, -685, -1032, 316, 480
        DC32 20, 23, -89, -551, 353, 1051, 1789, -544, -757, -1364, 298, -25
        DC32 436, -100, -392, -519, 467, 754, 1078, -210, -398, -1078, 620, 658
        DC32 630, 33, 147, -178, 921, 1687, 1921, -325, -528, -1978, 2, -285
        DC32 910, -371, -490, -230, 0, 597, 2010, -496, -395, -834, 37, 945
        DC32 245, 181, -160, -144, 1481, 1373, 1357, -355, -601, -1270, 298
        DC32 322, 672, -193, -336, 77, 1089, 1533, 922, 177, -39, -1125, 996
        DC32 781, 536, 456, 366, -432, 1415, 2440, 2279, -466, -758, -2325
        DC32 -303, -509, 387, -727, -557, 66, -145, 643, 1248, -544, -676, -916
        DC32 -225, 862, 588, -152, 40, -533, 423, 1423, 1558, -572, -843, -1145
        DC32 -128, 85, 461, -238, -257, -584, 605, 748, 861, 24, -202, -1409
        DC32 797, 487, 303, -181, 364, -182, 616, 1378, 2942, -494, -852, -1441
        DC32 -292, 61, 812, -84, -723, -182, 555, 532, 1506, -365, -493, -1057
        DC32 822, 588, 11, -14, -18, -230, 1001, 1401, 1451, -474, -569, -1292
        DC32 302, 62, 1062, -70, -376, -222, 982, 974, 1149, -196, -234, -795
        DC32 479, 1098, 499, 362, 58, 70, 1147, 2069, 2857, -487, -878, -1824
        DC32 73, -288, 348, -358, -500, -508, 199, 721, 1242, -78, -697, -795
        DC32 361, 536, 196, 374, 110, -735, 847, 1051, 1896, -366, -713, -1182
        DC32 315, 320, 429, 72, -215, -450, 759, 886, 1363, -30, -428, -834
        DC32 861, 627, 796, 118, 468, -279, 1355, 1883, 1893, -188, -642, -1612
        DC32 63, -175, 1198, -418, -211, 51, 414, 587, 2601, -234, -557, -858
        DC32 424, 889, 222, 136, -101, 83, 1413, 2278, 1383, -84, -445, -1389
        DC32 414, 313, 1045, 29, -343, 65, 1552, 1647, 980, 183, -91, -829
        DC32 1273, 1413, 360, 553, 272, -107, 1587, 3149, 2603

        RSEG DATA_C:CONST:SORT:NOROOT(2)
// static long const __data mean_lsf_5[10]
mean_lsf_5:
        DATA
        DC32 1384, 2077, 3420, 5108, 6742, 8122, 9863, 11092, 12714, 13701
        DC32 -451, -1065, -529, -1305, -450, -756, -497, -863, -384, -619, -413
        DC32 -669, -317, -538, -331, -556, -414, -508, -424, -378, -274, -324
        DC32 -434, -614, -226, -500, -232, -514, -263, -377, -298, -410, -151
        DC32 -710, -174, -818, -149, -412, -156, -429, -288, -462, -186, -203
        DC32 -170, -302, -191, -321, -131, -147, -297, -395, -228, -214, -245
        DC32 -192, -67, -316, -71, -327, -104, -205, -94, -183, -143, -38, -193
        DC32 -95, 16, -76, -124, -248, 23, -237, 24, -244, 18, -136, 44, -111
        DC32 -33, -24, -25, 0, 149, 19, 23, -143, 158, -169, 174, -181, 133
        DC32 -55, 165, -26, 111, 84, 98, 75, 87, 183, -115, -11, -8, 130, 11
        DC32 170, 254, 77, 205, 17, 183, 112, 262, 194, 202, 287, 95, 189, -42
        DC32 -105, 234, 179, 39, 186, 163, 345, 332, 199, 299, 161, -54, 285
        DC32 -78, 281, -133, 141, -182, 111, 249, 341, 271, 364, 93, 403, 75
        DC32 391, 92, 510, -138, 220, -185, -29, -34, 361, -115, 320, 3, 554
        DC32 99, 286, 218, 591, -245, 406, -268, 453, 0, 580, 25, 606, 275, 532
        DC32 148, 450, -73, 739, -285, 518, -288, 94, -203, 674, -140, -74, 205
        DC32 714, -114, 299, 176, 923, 182, 557, 240, 705, -16, 513, 485, 593
        DC32 293, 384, 451, 617, -38, 50, 563, 529, 303, 209, 459, 363, 433
        DC32 452, 450, 454, 367, 606, 477, 741, 432, 353, 368, 267, 361, 716
        DC32 273, 583, 453, 166, 510, 172, 201, 629, 274, 191, 568, 639, 302
        DC32 298, 634, 387, 643, 350, 587, 560, 612, 565, 600, 788, 487, 672
        DC32 512, 1015, 321, 333, 357, 854, -125, 413, 474, 712, 17, -151, 564
        DC32 285, 270, -241, 971, 889, 489, 220, 510, 896, 549, 924, 327, 825
        DC32 290, 911, 540, 1108, 158, 805, 199, 957, 511, 730, 100, 874, 13
        DC32 791, 435, 632, 676, 972, 249, 900, 467, 1218, 781, 1074, 585, 785
        DC32 -23, 669, 267, 1043, 619, 1084, 615, 1145, 622, 905, 916, 1049, 80
        DC32 331, 584, 1075, 89, 639, 988, 961, 770, 720, 798, 699, 492, 447
        DC32 899, 627, 271, 1188, 725, 1333, 87, 603, 832, 1603, 616, 1127, 890
        DC32 1505, 1000, 1156, 866, 1009, 995, 827, 1149, 858, 817, 1450, 773
        DC32 1320, 500, 1389, 312, 1153, -20, 1084, 64, 1283, 2, 1172, 399
        DC32 1869, 514, 1706, 502, 1636, 886, 1522, 416, 600, 1131, 1350, 1275
        DC32 1390, 889, 1795, 914, 1766, 227, 1183, 1250, 1826, 505, 1854, 919
        DC32 2353, -199, 431, 152, 1735, -213, -28, 392, 1334, -153, -52, 978
        DC32 1151, -323, -400, 813, 1703, -136, 84, 1449, 2015, -331, -143
        DC32 -137, 1192, -256, 534, -157, 1031, -307, -439, 542, 731, -329
        DC32 -420, -97, 616, -362, -168, -322, 366, -247, -110, -211, 89, -196
        DC32 -309, 20, 59, -364, -463, -286, 89, -336, 175, -432, 141, -379
        DC32 -190, -434, -196, -79, 150, -278, -227, -280, 166, -555, -422
        DC32 -155, 541, -366, 54, -29, -83, -301, -774, 186, 628, -397, -264
        DC32 242, 293, -197, -585, 124, 410, 53, -133, 10, 340, -570, -1065, 65
        DC32 -446, 68, -493, 383, 937, -357, -711, -359, -250, -677, -1068, 292
        DC32 -26, 363, 6, 607, 1313, -127, -10, 1513, 1886, 713, 972, 1469
        DC32 2181, 1443, 2016
        DC32 -1631, -1600, -1796, -2290, -1027, -1770, -1100, -2025, -1277
        DC32 -1388, -1367, -1534, -947, -1461, -972, -1524, -999, -1222, -1020
        DC32 -1172, -815, -987, -992, -1371, -1216, -1006, -1289, -1094, -744
        DC32 -1268, -755, -1293, -862, -923, -905, -984, -678, -1051, -685
        DC32 -1050, -1087, -985, -1062, -679, -989, -641, -1127, -976, -762
        DC32 -654, -890, -806, -833, -1091, -706, -629, -621, -806, -640, -812
        DC32 -775, -634, -779, -543, -996, -565, -1075, -580, -546, -611, -572
        DC32 -619, -760, -290, -879, -526, -823, -462, -795, -253, -553, -415
        DC32 -589, -439, -533, -340, -692, -935, -505, -772, -702, -1131, -263
        DC32 -306, -971, -483, -445, -74, -555, -548, -614, -129, -693, -234
        DC32 -396, -246, -475, -250, -265, -404, -376, -514, -417, -510, -300
        DC32 -313, -334, -664, -463, -814, -386, -704, -337, -615, -234, -201
        DC32 -233, -239, -167, -567, -203, -619, -147, -415, -115, -352, -166
        DC32 -750, -171, -761, -270, -879, -264, -903, -367, -744, 43, -475, 14
        DC32 -653, 43, -670, 11, -448, -59, -521, -126, -119, -155, -613, -42
        DC32 -863, -27, -931, 136, -483, 183, -468, 55, -298, 55, -304, 313
        DC32 -609, 313, -720, 322, -167, 100, -541, -3, -119, -111, -187, 233
        DC32 -236, 260, -234, 26, -165, 134, -45, -40, -549, 360, -203, 378
        DC32 -388, 450, -383, 275, 20, 182, -103, 246, -111, 431, 37, 462, -146
        DC32 487, -157, -284, -59, 503, -184, 24, 53, -3, 54, 122, 259, 333, 66
        DC32 484, 104, 436, 68, 195, 116, 190, 206, 269, -9, 482, 352, 382, 285
        DC32 399, 277, 452, 256, 69, 186, 13, 297, -13, 259, -95, 30, 56, 394
        DC32 196, 425, 205, 456, 281, 577, 15, 191, 375, 290, 407, 576, -56
        DC32 227, 544, 405, 0, 549, -92, 528, -229, 351, -245, 338, -362, 435
        DC32 167, 527, -75, 302, 91, 824, 129, 599, 496, 679, 186, 749, 153
        DC32 737, -281, 600, -348, 615, -236, 769, 41, 881, 38, 890, -220, 841
        DC32 -357, 883, -393, 903, -634, 474, -444, 850, -175, 678, -493, 242
        DC32 -519, 785, -714, 582, -541, 366, -543, 434, -597, 500, -765, 222
        DC32 -702, 917, -743, 962, -869, 501, -899, 548, -379, 200, -435, 157
        DC32 -819, 214, -861, 157, -614, 40, -632, 94, -883, -54, -741, 516
        DC32 -501, 298, -614, -171, -870, -161, -865, -23, -818, 93, -1015
        DC32 -267, -662, -359, -549, 2, -442, -121, -377, 0, -227, 33, -414
        DC32 -126, -129, 212, -934, 34, -1082, -282, -1119, -268, -710, -825
        DC32 -420, -191, -1076, -928, -917, -93, -628, -358, 97, 7, -206, -393
        DC32 -101, 24, -203, 38, -168, 83, -599, -423, -279, 426, -700, 118
        DC32 -75, 206, -981, -673, -680, 417, -367, 37, -279, 474, -129, -318
        DC32 319, 296, -626, -39, 343, 602, -696, -39, -303, 940, 104, 233
        DC32 -380, 137, -36, 269, -75, -214, 120, 43, -529, -477, 459, 164
        DC32 -202, -229, -49, -167, 609, 792, 98, -220, 915, 148, 293, 283, 869
        DC32 91, 575, 394, 326, -78, 717, 67, 365, -323, 616, -36, 731, 27, 619
        DC32 238, 632, 273, 448, 99, 801, 476, 869, 273, 685, 64, 789, 72, 1021
        DC32 217, 793, 459, 734, 360, 646, 480, 360, 322, 429, 464, 638, 430
        DC32 756, 363, 1000, 404, 683, 528, 602, 615, 655, 413, 946, 687, 937
        DC32 602, 904, 604, 555, 737, 786, 662, 467, 654, 362, 589, 929, 710
        DC32 498, 478, 415, 420, 693, 883, 813, 683, 781, 925, 913, 939, 726
        DC32 732, 491, 853, 531, 948, 734, 963, 315, 808, 761, 755, 1144, 760
        DC32 655, 1076, 826, 1057, 1091, 838, 1003, 808, 1047, 1133, 659, 1101
        DC32 992, 1050, 1074, 1075, 971, 694, 1226, 1054, 571, 841, 884, 1404
        DC32 1379, 1096, 1080, 861, 1231, 735, 1284, 760, 1272, 991, 1367, 1053
        DC32 1257, 700, 1050, 534, 988, 453, 1264, 599, 1140, 679, 1621, 815
        DC32 1384, 521, 1317, 393, 1564, 805, 1448, 686, 1068, 648, 875, 307
        DC32 1083, 361, 1047, 317, 1417, 964, 675, 571, 1152, 79, 1114, -47
        DC32 1530, 311, 1721, 314, 1166, 689, 514, -94, 349, 282, 1412, 328
        DC32 1025, 487, -65, 57, 805, 970, 36, 62, 769, -263, 791, -346, 637
        DC32 699, -137, 620, 534, 541, -735, 194, 711, 300, -268, -863, 926
        DC32 769, -708, -428, 506, 174, -892, -630, 435, 547, -1435, -258, 621
        DC32 471, -1018, -1368, -393, 521, -920, -686, -25, 20, -982, -1156
        DC32 340, 9, -1558, -1135, -352, 48, -1579, -402, -887, 6, -1156, -888
        DC32 -548, -352, -1643, -1168, -159, 610, -2024, -963, -225, 193, -1656
        DC32 -1960, -245, -493, -964, -1680, -936, -635, -1299, -1744, -1388
        DC32 -604, -1540, -835, -1397, -135, -1588, -290, -1670, -712, -2011
        DC32 -1632, -1663, -27, -2258, -811, -1157, 184, -1265, 189, -1367, 586
        DC32 -2011, 201, -790, 712, -1210, 3, -1033, 808, -1251, 830, -111, 635
        DC32 -1636, 447, -463, -949, -445, -928, -504, -1162, -501, -1211, 144
        DC32 -351, -372, -1052, -283, -1059, -279, -1123, -575, -1438, -587
        DC32 -1614, -935, -984, 229, 690, -921, -719, -403, 1362, -685, -465
        DC32 874, 397, -509, -46, 317, 1334, -485, 456, 813, 439, -411, 339
        DC32 898, 1067, -425, 46, 1441, 497, -909, -800, 1465, 1046, -254, -321
        DC32 1430, 1165, 68, 350, 1034, 666, 370, 11, 1311, 790, 143, 232, 1041
        DC32 1562, -114, 663, 1616, 1078, 454, 579, 1275, 1040, -76, 909, 752
        DC32 1067, 153, 512, 348, 1214, 614, 385, 1843, 808, 269, 1034, 203
        DC32 1086, 652, 1017, 1783, 1130, 429, 1327, 387, 1384, -49, 1183, -72
        DC32 1215, -416, 1001, 544, 1749, -352, 1223, -502, 1199, -589, 569
        DC32 -227, 1630, -142, 1578, -230, 1715, -714, 1288, -838, 1398, 1131
        DC32 1357, -208, 1232, 437, 965, -929, 818, 811, 1410, 859, 1507, 164
        DC32 1212, 1387, 1793, 484, 1874, 456, 2063, 996, 1170, 1326, 1402
        DC32 1316, 1360, 1135, 1262, 1234, 1618, 1361, 1768, 1421, 1227, 1584
        DC32 1347, 854, 672, 1685, 1566, 1139, 1270, 2016, 1825, 1773, 1581
        DC32 1532, 1460, 1487, 946, 1659, 1021, 1744, 1212, 1392, 977, 1772
        DC32 1161, 1826, 1164, 1718, 1429, 1973, 1591, 1185, 864, 2132, 1061
        DC32 1799, 814, 1838, 757, 2104, 1315, 2054, 1258, 2113, 915, 2331, 930
        DC32 1467, 1147, 2590, 1439, 2245, 1744, 2090, 1620, 2358, 1454, 2666
        DC32 1506, 1876, 1837, 2070, 1975, 1739, 1577, 682, 1289, 1584, 2045
        DC32 1454, 2098, 2498, 2004, 2711, 2066, 726, 1588, 2756, 2336, 228
        DC32 847, 2456, 1659, 36, 301, 1942, 1957, -446, -96, 2154, 1396, 1533
        DC32 1101, 14, 608, -923, -732, 1383, 1982, 1345, 952, -680, 321, 1281
        DC32 1268, -1594, 365, 941, 946, -1737, -822, 2374, 2787, 1821, 2788
        DC32 -1812, -2275, -1879, -2537, -1640, -1848, -1695, -2004, -1220
        DC32 -1912, -1221, -2106, -1559, -1588, -1573, -1556, -1195, -1615
        DC32 -1224, -1727, -1359, -1151, -1616, -1948, -1274, -1391, -1305
        DC32 -1403, -1607, -1179, -1676, -1311, -1443, -1478, -1367, -898
        DC32 -1256, -1059, -1331, -1134, -982, -1133, -1149, -1504, -1080
        DC32 -1308, -1020, -1183, -980, -1486, -967, -1495, -988, -922, -1047
        DC32 -1077, -838, -1179, -858, -1222, -1131, -1041, -1064, -767, -872
        DC32 -1157, -701, -880, -706, -906, -774, -1016, -578, -1080, -801
        DC32 -1478, -591, -1111, -592, -1146, -713, -1388, -640, -1376, -597
        DC32 -1059, -416, -903, -686, -832, -661, -708, -444, -868, -490, -921
        DC32 -374, -776, -619, -1170, -585, -549, -769, -795, -435, -659, -530
        DC32 -741, -498, -837, -357, -597, -279, -871, -243, -887, -282, -665
        DC32 -280, -667, -165, -560, -394, -903, -362, -410, -448, -583, -409
        DC32 -574, -313, -357, -637, -548, -570, -436, -896, -504, -382, -757
        DC32 -58, -481, -165, -618, -191, -374, -234, -382, -222, -683, -25
        DC32 -480, -418, -359, -730, -353, -324, -157, -432, -322, -394, -303
        DC32 -284, -104, -601, -289, -556, -196, -588, -150, -659, -608, -473
        DC32 -24, -68, -448, -474, -8, -506, -45, -748, -184, -844, -252, -901
        DC32 -91, -584, -97, -652, 138, -764, -131, -678, -12, -670, 165, -259
        DC32 -3, -840, -107, -909, 37, -992, 44, -854, -415, -839, 13, -1001
        DC32 -271, -1026, -309, -798, -478, -832, -488, -943, 168, -1112, -387
        DC32 -1185, -101, -1183, -40, -941, -316, -1030, -770, -1044, -625
        DC32 -1081, -538, -1224, -299, -1312, -436, -1197, -663, -1167, -161
        DC32 -1216, -690, -1237, -831, -1432, -720, -1403, -493, -898, -740
        DC32 -922, -801, -1102, -402, -1579, -964, -1061, -638, -1269, -1438
        DC32 -1499, -934, -1502, -895, -1598, -564, -1723, -717, -606, -597
        DC32 -1166, -1085, -1369, -468, -1946, -1493, -1838, -953, -1932, -931
        DC32 -1499, -188, -1635, -421, -1457, -338, -1448, -22, -1942, -422
        DC32 -2006, -249, -496, -114, -1910, -755, -1289, 174, -1451, -109
        DC32 -482, -257, -1221, -508, -1617, 151, -1694, 208, -654, 107, -1651
        DC32 29, -1141, 279, -1215, 306, -1228, -506, -730, -175, -1236, -101
        DC32 -969, 551, -870, 278, -823, 315, -563, 376, -1051, 228, -507, 280
        DC32 -599, 281, -758, 253, -305, 379, -755, -134, -611, 660, -824, 536
        DC32 -817, 646, -413, 49, -341, 177, -453, 526, -482, 589, -71, 339
        DC32 -657, 264, -244, 295, -237, 315, -387, 569, -506, -9, -377, 14
        DC32 -160, 661, -216, 40, -308, -46, 95, 214, -242, 167, -86, 192, -56
        DC32 27, -76, 31, 36, 309, -106, -182, -113, 74, -441, -22, 23, 139, 81
        DC32 -11, 44, 15, -87, -137, -118, -207, -158, -58, 272, -92, -156
        DC32 -441, 8, -136, 128, -221, 101, -218, 40, -197, -76, -456, 9, -445
        DC32 33, -423, 226, 60, 73, -222, 156, -399, 280, -318, 245, -341, 166
        DC32 -499, 339, -190, 327, -219, 325, -137, -89, -596, 100, -627, 144
        DC32 -677, 487, 28, 252, -391, 214, -41, 282, -28, 99, -286, 331, 49
        DC32 459, -388, 565, -369, 436, 28, 336, -9, 397, -167, 618, 34, 596
        DC32 -17, 561, -140, 299, 79, 522, 125, 203, 2, 244, 288, 255, 211, 175
        DC32 82, 596, 187, 517, 108, 381, 255, 365, 297, 497, 352, 327, -82, 25
        DC32 210, 371, 245, 261, 3, 545, 449, 140, 294, 44, 295, 212, 347, 244
        DC32 494, 331, 528, 201, 307, 349, 411, 613, 284, 614, 413, 464, 322
        DC32 624, 397, 97, 200, -160, 384, 149, 362, 495, 525, 269, 585, 33
        DC32 491, -121, 433, 427, 611, 498, 516, 171, 443, 497, 666, 440, 275
        DC32 566, 575, 146, 639, 155, 670, -33, 173, 212, 696, -166, 601, -191
        DC32 695, -489, 503, 175, 742, 214, 476, 372, 1083, 578, 530, 586, 777
        DC32 425, 874, 315, 841, 374, 848, -165, 565, 35, 991, -39, 1062, 329
        DC32 712, 786, 840, 645, 795, 661, 676, 571, 918, 632, 1079, 673, 817
        DC32 318, 388, 874, 1012, 564, 848, 880, 620, 557, 479, 671, 453, 692
        DC32 468, 840, 642, 844, 645, 506, 428, 897, 567, 837, 387, 962, 499
        DC32 691, 561, 939, 926, 783, 296, 790, 268, 1028, 530, 874, 329, 548
        DC32 143, 675, 291, 503, 66, 1041, 359, 786, 97, 805, 33, 837, 470, 511
        DC32 49, 1092, 327, 1174, 323, 3, 242, 872, 474, 689, 429, 1329, 678
        DC32 1042, 620, 1109, 664, 321, 193, 889, 950, 1153, 874, 893, 635, 877
        DC32 862, 948, 913, 1293, 665, 1320, 639, 997, 793, 1402, 1030, 1176
        DC32 1012, 1110, 959, 1410, 925, 1403, 915, 543, 862, 1116, 1222, 835
        DC32 1190, 835, 1190, 959, 1148, 1147, 1376, 1300, 1193, 1415, 1231
        DC32 1335, 1341, 746, 1092, 1711, 1283, 1389, 1073, 1334, 1566, 1153
        DC32 1475, 1645, 1137, 1825, 1220, 1056, 1382, 1521, 1730, 1632, 1545
        DC32 1620, 1542, 855, 1596, 865, 1667, 693, 885, 1716, 1519, 1167, 1296
        DC32 2209, 1760, 1952, 1493, 2020, 1482, 1534, 1866, 1694, 2008, 1566
        DC32 748, 1761, 825, 294, 1392, 1084, 2058, 621, 1315, 365, 1287, 198
        DC32 1028, 488, 1408, 249, 403, 1014, 1561, 324, 363, 1645, 1044, 193
        DC32 367, 2034, 1859, -251, 579, 750, 994, -243, 30, 1325, 879, -28
        DC32 -169, 624, 917, -453, 159, 186, 1370, -614, 6, 537, 392, -94, -291
        DC32 781, 229, -128, -298, 245, 491, -701, -648, 972, 789, -501, -640
        DC32 178, 255, -365, -390, -255, 317, -958, -294, -191, 228, -775, -447
        DC32 157, -237, -657, -720, -407, 92, -117, -611, 334, -230, -679
        DC32 -1084, -144, -317, -901, -861, -738, -360, -85, -727, -90, -787
        DC32 100, -22, -391, -263, -56, -73, -337, -754, 5, -189, -706, -624
        DC32 89, -344, -135, -1113, -353, -237, -684, -1135, -275, -1102, -269
        DC32 -1203, 152, 145, -722, -1232, 49, 80, -1248, -776, -248, 391, -732
        DC32 -547, 469, 218, -255, -864, 69, 366, -166, -485, -688, 191, -1212
        DC32 -1196, -170, -169, -1308, -1631, 321, 470, -1419, -1243, -64, 272
        DC32 -1361, -248, 492, 565, -721, -609, 195, 485, -573, -133, 427, 202
        DC32 -171, -118, 199, 575, 2, -31, 694, 755, -1366, -39, 552, 557, -489
        DC32 271, 680, 537, 13, -453, 855, 954, -133, -52, -81, 738, -1169, 637
        DC32 1055, 1059, -95, 676, 1259, 1081, 489, 305, -449, 954, -534, 996
        DC32 -969, 866, -1058, 1059, -1294, 618, -1416, 617, -458, 1366, -159
        DC32 1821, -774, -528, -14, 1110, -1202, -901, -772, 433, -1256, -1255
        DC32 -1011, -302, -602, -585, -759, -1618, -760, -1549, -840, -1921
        DC32 -816, -539, -1769, -2235, -227, -36, -2034, -1831, -2107, -1126
        DC32 -2471, -1816, -1470, 252, -2701, -415, -571, -467, 1509, 1554
        DC32 2180, 1975, 2326, 2020
        DC32 -1857, -1681, -1857, -1755, -2056, -1150, -2134, -1654, -1619
        DC32 -1099, -1704, -1131, -1345, -1608, -1359, -1638, -1338, -1293
        DC32 -1325, -1265, -1664, -1649, -1487, -851, -1346, -1832, -1413
        DC32 -2188, -1282, -681, -1785, -1649, -966, -1082, -1183, -1676, -1054
        DC32 -1073, -1142, -1158, -1207, -744, -1274, -997, -934, -1383, -927
        DC32 -1416, -1010, -1305, -783, -955, -1049, -900, -993, -817, -737
        DC32 -823, -972, -1189, -738, -1094, -738, -1154, -784, -801, -810
        DC32 -786, -892, -520, -1000, -818, -644, -965, -577, -882, -541, -694
        DC32 -671, -917, -595, -642, -646, -615, -956, -621, -925, -515, -727
        DC32 -483, -815, -485, -840, -578, -440, -713, -578, -325, -657, -670
        DC32 -386, -570, -441, -666, -514, -787, -392, -529, -522, -453, -487
        DC32 -423, -616, -585, -617, -157, -662, -268, -680, -348, -322, -323
        DC32 -632, -444, -304, -430, -332, -458, -277, -468, -659, -793, -319
        DC32 -636, -227, -554, -373, -347, -334, -210, -456, -192, -530, -242
        DC32 -216, -198, -366, -370, -338, -161, -409, -748, -107, -380, -294
        DC32 -643, -223, -665, -234, -741, -141, -496, -130, -510, -139, -327
        DC32 -172, -305, -306, -580, -164, -263, -262, -172, -67, -402, 31
        DC32 -366, -10, -436, -86, -527, 71, -377, -22, -609, -12, -678, -67
        DC32 -319, 63, -191, 35, -181, -39, -242, 126, -167, -140, -544, 155
        DC32 -297, 174, -297, 38, -8, 117, -380, 197, -452, 240, -522, 223
        DC32 -103, 110, -187, 87, -155, 169, -47, 157, 26, -83, -100, 128, 80
        DC32 209, -62, 6, 7, 22, 5, 318, -20, 248, -45, -200, -63, 156, -69
        DC32 250, -183, 369, -126, -113, -76, -142, -122, -64, -254, -31, 35
        DC32 -177, -71, -7, 171, 93, 27, 108, 212, -330, -209, -123, -70, -279
        DC32 95, -96, 20, -188, -61, -314, 87, -300, -78, -354, -134, 11, 122
        DC32 -140, 122, -275, 152, -293, 140, -82, 138, -321, -111, -480, -156
        DC32 -359, 76, -254, -40, -635, -96, -522, 79, -507, 8, -268, 303, -539
        DC32 68, -446, 61, -522, 306, 111, 189, -435, 122, -379, 166, -571
        DC32 -398, -632, -74, -747, -95, -455, 194, -952, 83, -798, 192, -755
        DC32 192, -781, -162, -619, 234, -663, -297, -488, -109, -964, -132
        DC32 -838, -68, -843, 58, -1112, -86, -805, -299, -944, -253, -778, -50
        DC32 -965, -549, -352, -98, -992, -343, -1117, -315, -1117, -307, -1155
        DC32 -374, -637, -230, -1166, -43, -1299, -100, -925, -393, -1274, -600
        DC32 -689, -130, -1479, -312, -1321, -254, -1464, -442, -1292, -613
        DC32 -1261, -503, -1501, -368, -1322, 26, -1432, -66, -1743, -161
        DC32 -1644, -467, -1760, -548, -1393, -568, -1556, -871, -1495, -1034
        DC32 -1387, -571, -1917, -528, -1783, -123, -1897, -231, -2054, -323
        DC32 -2052, -906, -1976, -567, -1917, -620, -2047, -989, -1077, -370
        DC32 -2031, -704, -2355, -749, -2740, -1089, -1909, 159, -2012, 248
        DC32 -626, -123, -2339, -962, -669, -408, -1379, -1174, -452, -364
        DC32 -1044, -735, -132, 183, -1620, -752, -547, -307, -777, -1261, -98
        DC32 41, -880, -1091, -257, 97, -1602, -1833, 31, -26, -644, -561, -180
        DC32 -546, -385, -1095, -410, -802, -414, -827, -457, -970, -490, -1109
        DC32 -215, -916, -144, -937, -493, -1269, -517, -1507, 181, 101, -332
        DC32 -889, -836, -937, -559, -429, -629, -547, -183, -337, -545, -82
        DC32 -250, -286, 5, -132, -348, -252, -293, -472, -158, 100, -29, 197
        DC32 -236, -424, -861, -213, -140, -7, -427, -443, 187, -97, -684, -736
        DC32 -293, 258, -368, -152, -150, 392, -609, 175, -142, 299, -138, 152
        DC32 -119, 329, -486, -52, 293, 198, -183, 117, 175, 331, -58, -274
        DC32 231, 300, -288, 330, -305, 372, -111, 409, -9, 423, 83, 256, 67
        DC32 367, -19, 248, 91, 113, -35, 406, -191, 154, 238, 296, 5, 197, 141
        DC32 221, 313, 198, 211, 421, 244, 334, 88, 426, -243, 454, 202, 552
        DC32 -5, 403, 291, 185, 219, 301, 251, 138, 128, 69, 197, 288, -140
        DC32 -61, 188, 361, 197, 598, 442, 273, 290, 143, 472, 482, 157, 370
        DC32 415, 321, 372, 385, 402, 552, 155, 24, 550, 263, -11, 21, 360, 227
        DC32 147, -254, 424, 97, 366, -13, 375, 141, 449, 232, 396, 507, 474
        DC32 272, 701, 324, 362, -47, 587, 148, 543, 69, 400, -51, 561, 59, 220
        DC32 -10, 352, 147, 206, 211, 653, 185, 563, 297, 565, 284, 594, 121
        DC32 766, 192, 398, 118, 642, 434, 233, 264, 481, 467, 129, -165, 699
        DC32 239, 90, 26, 342, 474, -55, 27, 388, 94, -172, 0, 725, 379, -60
        DC32 337, 370, 465, 95, 319, 806, 595, 78, 260, 497, 851, 210, 560, 458
        DC32 574, -464, 202, 497, 625, -202, 152, 48, 712, -20, 566, 100, 715
        DC32 455, 468, 411, 605, 319, 646, 195, 615, 401, 538, 680, 739, 201
        DC32 667, 434, 954, 454, 425, 646, 491, 606, 681, 416, 508, 497, 822
        DC32 426, 815, 660, 647, 628, 716, 697, 466, 618, 457, 685, 460, 365
        DC32 309, 721, 567, 836, 601, 609, 300, 825, 459, 943, 687, 681, 533
        DC32 915, 598, 591, 243, 876, 451, 874, 420, 786, 317, 732, 220, 922
        DC32 317, 1108, 367, 531, 466, 1028, 649, 1053, 615, 1034, 553, 829
        DC32 602, 1021, 799, 927, 803, 878, 763, 799, 496, 1373, 773, 585, 770
        DC32 803, 930, 1099, 793, 1222, 862, 1209, 895, 1025, 727, 772, 845
        DC32 1172, 1115, 867, 1021, 830, 1013, 841, 910, 506, 703, 1239, 1077
        DC32 620, 819, 1196, 1083, 1155, 1081, 1142, 907, 1547, 1121, 1309, 648
        DC32 1343, 612, 1484, 988, 1479, 937, 985, 1328, 955, 1341, 429, 910
        DC32 841, 1338, 564, 1179, 412, 1156, 1427, 1320, 1434, 1330, 640, 760
        DC32 1726, 1410, 190, 555, 1073, 1005, 426, 257, 839, 980, 235, 231
        DC32 1520, 1167, 109, 293, 1014, 1569, 305, 142, 1148, 539, -291, -108
        DC32 1213, 972, 22, -216, 667, 828, -482, 438, 453, 1431, -581, -422
        DC32 789, 387, -358, -454, 174, 780, -36, -372, 390, -134, -629, 160
        DC32 -306, 751, -1258, -331, 177, 522, -248, 574, -251, 639, -531, 407
        DC32 -596, 394, -419, 789, -617, 801, -986, 399, -857, 727, -7, 518
        DC32 -703, 310, -1143, -24, -1002, 287, -960, 363, -1299, 312, -1534
        DC32 245, -1557, 305, 28, 153, -859, -175, -33, 332, -1398, -154, 212
        DC32 410, -593, -197, -1092, -704, -904, -65, 282, 367, -918, -686, 345
        DC32 93, -258, -357, 696, 644, -693, -28, 448, 493, -273, 193, 527, 546
        DC32 -243, -513, 384, -136, 273, -353, 512, -142, 537, -198, 941, 750
        DC32 83, 248, 578, 861, -56, 592, 842, 44, 892, 24, 33, 890, -16, 982
        DC32 831, 1398, 1535, 1898, 1716, 1376, 1948, 1465
        DC32 -1002, -929, -1096, -1203, -641, -931, -604, -961, -779, -673
        DC32 -835, -788, -416, -664, -458, -766, -652, -521, -662, -495, -1023
        DC32 -509, -1023, -428, -444, -552, -368, -449, -479, -211, -1054, -903
        DC32 -316, -249, -569, -591, -569, -275, -541, -191, -716, -188, -842
        DC32 -264, -333, -248, -318, -228, -275, 1, -567, -228, -115, -221
        DC32 -238, -374, -197, -507, -222, -579, -258, -432, -61, -244, -345, 2
        DC32 -338, 39, -215, -169, -58, 0, -56, -6, -203, -131, 1, -186, -5
        DC32 -211, 6, -380, 11, -418, -116, 131, -134, 113, 89, -4, 71, -2, -19
        DC32 -192, 262, 24, 189, 151, -133, -109, 186, -153, 166, -219, 37, 139
        DC32 193, 171, 337, 124, 158, -61, 141, 226, -13, 190, 231, 34, 354
        DC32 109, 316, 201, 244, 164, 330, -85, 390, -84, 254, 327, 257, 335
        DC32 491, 147, 476, 105, 54, 77, 437, 370, 421, 314, 449, 342, 329, 126
        DC32 673, 292, 571, 388, 243, 193, 653, 320, 621, 280, 194, 380, 517
        DC32 581, 45, 323, 111, 422, 489, 395, 734, 534, 622, 546, 486, 502
        DC32 318, 572, 189, 550, 385, 422, -157, 153, -125, 382, -197, 386
        DC32 -263, 334, 228, 697, -188, 1, 51, 297, -507, 213, -376, 397, -24
        DC32 255, -547, 89, -502, -94, 387, 179, -620, 68, -684, 112, -642
        DC32 -350, -260, 172, -438, -324, 264, 648, -964, -4, -1121, 7, -134
        DC32 134, -1133, -306, 143, 96, -420, -497, -1221, -350, -1527, -685
        DC32 -161, 72, 873, 691, 732, 283, 921, 353, 334, 475, 1095, 821, 864
        DC32 524, 843, 497, 714, 711, 788, 750, 1076, 714, 1204, 753

        RSEG DATA_C:CONST:SORT:NOROOT(2)
// static long const __data table_gain_MR475[1024]
table_gain_MR475:
        DATA
        DC32 812, 128, 542, 140, 2873, 1135, 2266, 3402, 2067, 563, 12677, 647
        DC32 4132, 1798, 5601, 5285, 7689, 374, 3735, 441, 10912, 2638, 11807
        DC32 2494, 20490, 797, 5218, 675, 6724, 8354, 5282, 1696, 1488, 428
        DC32 5882, 452, 5332, 4072, 3583, 1268, 2469, 901, 15894, 1005, 14982
        DC32 3271, 10331, 4858, 3635, 2021, 2596, 835, 12360, 4892, 12206, 1704
        DC32 13432, 1604, 9118, 2341, 3968, 1538, 5479, 9936, 3795, 417, 1359
        DC32 414, 3640, 1569, 7995, 3541, 11405, 645, 8552, 635, 4056, 1377
        DC32 16608, 6124, 11420, 700, 2007, 607, 12415, 1578, 11119, 4654
        DC32 13680, 1708, 11990, 1229, 7996, 7297, 13231, 5715, 2428, 1159
        DC32 2073, 1941, 6218, 6121, 3546, 1804, 8925, 1802, 8679, 1580, 13935
        DC32 3576, 13313, 6237, 6142, 1130, 5994, 1734, 14141, 4662, 11271
        DC32 3321, 12226, 1551, 13931, 3015, 5081, 10464, 9444, 6706, 1689, 683
        DC32 1436, 1306, 7212, 3933, 4082, 2713, 7793, 704, 15070, 802, 6299
        DC32 5212, 4337, 5357, 6676, 541, 6062, 626, 13651, 3700, 11498, 2408
        DC32 16156, 716, 12177, 751, 8065, 11489, 6314, 2256, 4466, 496, 7293
        DC32 523, 10213, 3833, 8394, 3037, 8403, 966, 14228, 1880, 8703, 5409
        DC32 16395, 4863, 7420, 1979, 6089, 1230, 9371, 4398, 14558, 3363
        DC32 13559, 2873, 13163, 1465, 5534, 1678, 13138, 14771, 7338, 600
        DC32 1318, 548, 4252, 3539, 10044, 2364, 10587, 622, 13088, 669, 14126
        DC32 3526, 5039, 9784, 15338, 619, 3115, 590, 16442, 3013, 15542, 4168
        DC32 15537, 1611, 15405, 1228, 16023, 9299, 7534, 4976, 1990, 1213
        DC32 11447, 1157, 12512, 5519, 9475, 2644, 7716, 2034, 13280, 2239
        DC32 16011, 5093, 8066, 6761, 10083, 1413, 5002, 2347, 12523, 5975
        DC32 15126, 2899, 18264, 2289, 15827, 2527, 16265, 10254, 14651, 11319
        DC32 1797, 337, 3115, 397, 3510, 2928, 4592, 2670, 7519, 628, 11415
        DC32 656, 5946, 2435, 6544, 7367, 8238, 829, 4000, 863, 10032, 2492
        DC32 16057, 3551, 18204, 1054, 6103, 1454, 5884, 7900, 18752, 3468
        DC32 1864, 544, 9198, 683, 11623, 4160, 4594, 1644, 3158, 1157, 15953
        DC32 2560, 12349, 3733, 17420, 5260, 6106, 2004, 2917, 1742, 16467
        DC32 5257, 16787, 1680, 17205, 1759, 4773, 3231, 7386, 6035, 14342
        DC32 10012, 4035, 442, 4194, 458, 9214, 2242, 7427, 4217, 12860, 801
        DC32 11186, 825, 12648, 2084, 12956, 6554, 9505, 996, 6629, 985, 10537
        DC32 2502, 15289, 5006, 12602, 2055, 15484, 1653, 16194, 6921, 14231
        DC32 5790, 2626, 828, 5615, 1686, 13663, 5778, 3668, 1554, 11313, 2633
        DC32 9770, 1459, 14003, 4733, 15897, 6291, 6278, 1870, 7910, 2285
        DC32 16978, 4571, 16576, 3849, 15248, 2311, 16023, 3244, 14459, 17808
        DC32 11847, 2763, 1981, 1407, 1400, 876, 4335, 3547, 4391, 4210, 5405
        DC32 680, 17461, 781, 6501, 5118, 8091, 7677, 7355, 794, 8333, 1182
        DC32 15041, 3160, 14928, 3039, 20421, 880, 14545, 852, 12337, 14708
        DC32 6904, 1920, 4225, 933, 8218, 1087, 10659, 4084, 10082, 4533, 2735
        DC32 840, 20657, 1081, 16711, 5966, 15873, 4578, 10871, 2574, 3773
        DC32 1166, 14519, 4044, 20699, 2627, 15219, 2734, 15274, 2186, 6257
        DC32 3226, 13125, 19480, 7196, 930, 2462, 1618, 4515, 3092, 13852, 4277
        DC32 10460, 833, 17339, 810, 16891, 2289, 15546, 8217, 13603, 1684
        DC32 3197, 1834, 15948, 2820, 15812, 5327, 17006, 2438, 16788, 1326
        DC32 15671, 8156, 11726, 8556, 3762, 2053, 9563, 1317, 13561, 6790
        DC32 12227, 1936, 8180, 3550, 13287, 1778, 16299, 6599, 16291, 7758
        DC32 8521, 2551, 7225, 2645, 18269, 7489, 16885, 2248, 17882, 2884
        DC32 17265, 3328, 9417, 20162, 11042, 8320, 1286, 620, 1431, 583, 5993
        DC32 2289, 3978, 3626, 5144, 752, 13409, 830, 5553, 2860, 11764, 5908
        DC32 10737, 560, 5446, 564, 13321, 3008, 11946, 3683, 19887, 798, 9825
        DC32 728, 13663, 8748, 7391, 3053, 2515, 778, 6050, 833, 6469, 5074
        DC32 8305, 2463, 6141, 1865, 15308, 1262, 14408, 4547, 13663, 4515
        DC32 3137, 2983, 2479, 1259, 15088, 4647, 15382, 2607, 14492, 2392
        DC32 12462, 2537, 7539, 2949, 12909, 12060, 5468, 684, 3141, 722, 5081
        DC32 1274, 12732, 4200, 15302, 681, 7819, 592, 6534, 2021, 16478, 8737
        DC32 13364, 882, 5397, 899, 14656, 2178, 14741, 4227, 14270, 1298
        DC32 13929, 2029, 15477, 7482, 15815, 4572, 2521, 2013, 5062, 1804
        DC32 5159, 6582, 7130, 3597, 10920, 1611, 11729, 1708, 16903, 3455
        DC32 16268, 6640, 9306, 1007, 9369, 2106, 19182, 5037, 12441, 4269
        DC32 15919, 1332, 15357, 3512, 11898, 14141, 16101, 6854, 2010, 737
        DC32 3779, 861, 11454, 2880, 3564, 3540, 9057, 1241, 12391, 896, 8546
        DC32 4629, 11561, 5776, 8129, 589, 8218, 588, 18728, 3755, 12973, 3149
        DC32 15729, 758, 16634, 754, 15222, 11138, 15871, 2208, 4673, 610
        DC32 10218, 678, 15257, 4146, 5729, 3327, 8377, 1670, 19862, 2321
        DC32 15450, 5511, 14054, 5481, 5728, 2888, 7580, 1346, 14384, 5325
        DC32 16236, 3950, 15118, 3744, 15306, 1435, 14597, 4070, 12301, 15696
        DC32 7617, 1699, 2170, 884, 4459, 4567, 18094, 3306, 12742, 815, 14926
        DC32 907, 15016, 4281, 15518, 8368, 17994, 1087, 2358, 865, 16281, 3787
        DC32 15679, 4596, 16356, 1534, 16584, 2210, 16833, 9697, 15929, 4513
        DC32 3277, 1085, 9643, 2187, 11973, 6068, 9199, 4462, 8955, 1629, 10289
        DC32 3062, 16481, 5155, 15466, 7066, 13678, 2543, 5273, 2277, 16746
        DC32 6213, 16655, 3408, 20304, 3363, 18688, 1985, 14172, 12867, 15154
        DC32 15703, 4473, 1020, 1681, 886, 4311, 4301, 8952, 3657, 5893, 1147
        DC32 11647, 1452, 15886, 2227, 4582, 6644, 6929, 1205, 6220, 799, 12415
        DC32 3409, 15968, 3877, 19859, 2109, 9689, 2141, 14742, 8830, 14480
        DC32 2599, 1817, 1238, 7771, 813, 19079, 4410, 5554, 2064, 3687, 2844
        DC32 17435, 2256, 16697, 4486, 16199, 5388, 8028, 2763, 3405, 2119
        DC32 17426, 5477, 13698, 2786, 19879, 2720, 9098, 3880, 18172, 4833
        DC32 17336, 12207, 5116, 996, 4935, 988, 9888, 3081, 6014, 5371, 15881
        DC32 1667, 8405, 1183, 15087, 2366, 19777, 7002, 11963, 1562, 7279
        DC32 1128, 16859, 1532, 15762, 5381, 14708, 2065, 20105, 2155, 17158
        DC32 8245, 17911, 6318, 5467, 1504, 4100, 2574, 17421, 6810, 5673, 2888
        DC32 16636, 3382, 8975, 1831, 20159, 4737, 19550, 7294, 6658, 2781
        DC32 11472, 3321, 19397, 5054, 18878, 4722, 16439, 2373, 20430, 4386
        DC32 11353, 26526, 11593, 3068, 2866, 1566, 5108, 1070, 9614, 4915
        DC32 4939, 3536, 7541, 878, 20717, 851, 6938, 4395, 16799, 7733, 10137
        DC32 1019, 9845, 964, 15494, 3955, 15459, 3430, 18863, 982, 20120, 963
        DC32 16876, 12887, 14334, 4200, 6599, 1220, 9222, 814, 16942, 5134
        DC32 5661, 4898, 5488, 1798, 20258, 3962, 17005, 6178, 17929, 5929
        DC32 9365, 3420, 7474, 1971, 19537, 5177, 19003, 3006, 16454, 3788
        DC32 16070, 2367, 8664, 2743, 9445, 26358, 10856, 1287, 3555, 1009
        DC32 5606, 3622, 19453, 5512, 12453, 797, 20634, 911, 15427, 3066
        DC32 17037, 10275, 18883, 2633, 3913, 1268, 19519, 3371, 18052, 5230
        DC32 19291, 1678, 19508, 3172, 18072, 10754, 16625, 6845, 3134, 2298
        DC32 10869, 2437, 15580, 6913, 12597, 3381, 11116, 3297, 16762, 2424
        DC32 18853, 6715, 17171, 9887, 12743, 2605, 8937, 3140, 19033, 7764
        DC32 18347, 3880, 20475, 3682, 19602, 3380, 13044, 19373, 10526, 23124
        DC32 577, 662, -2692, -16214, 806, 1836, -1185, -7135, 3109, 1052
        DC32 -2008, -12086, 4181, 1387, -1600, -9629, 2373, 1425, -1560, -9394
        DC32 3248, 1985, -1070, -6442, 1827, 2320, -840, -5056, 941, 3314, -313
        DC32 -1885, 2351, 2977, -471, -2838, 3616, 2420, -777, -4681, 3451
        DC32 3096, -414, -2490, 2955, 4301, 72, 434, 1848, 4500, 139, 836, 3884
        DC32 5416, 413, 2484, 1187, 7210, 835, 5030, 3083, 9000, 1163, 7002
        DC32 7384, 883, -2267, -13647, 5962, 1506, -1478, -8900, 5155, 2134
        DC32 -963, -5800, 7944, 2009, -1052, -6335, 6507, 2250, -885, -5327
        DC32 7670, 2752, -588, -3537, 5952, 3016, -452, -2724, 4898, 3764, -125
        DC32 -751, 6989, 3588, -196, -1177, 8174, 3978, -43, -260, 6064, 4404
        DC32 107, 645, 7709, 5087, 320, 1928, 5523, 6021, 569, 3426, 7769, 7126
        DC32 818, 4926, 6060, 7938, 977, 5885, 5594, 11487, 1523, 9172, 10581
        DC32 1356, -1633, -9831, 9049, 1597, -1391, -8380, 9794, 2035, -1033
        DC32 -6220, 8946, 2415, -780, -4700, 10296, 2584, -681, -4099, 9407
        DC32 2734, -597, -3595, 8700, 3218, -356, -2144, 9757, 3395, -277
        DC32 -1669, 10177, 3892, -75, -454, 9170, 4528, 148, 891, 10152, 5004
        DC32 296, 1781, 9114, 5735, 497, 2993, 10500, 6266, 628, 3782, 10110
        DC32 7631, 919, 5534, 8844, 8727, 1117, 6728, 8956, 12496, 1648, 9921
        DC32 12924, 976, -2119, -12753, 11435, 1755, -1252, -7539, 12138, 2328
        DC32 -835, -5024, 11388, 2368, -810, -4872, 10700, 3064, -429, -2580
        DC32 12332, 2861, -530, -3192, 11722, 3327, -307, -1848, 11270, 3700
        DC32 -150, -904, 10861, 4413, 110, 663, 12082, 4533, 150, 902, 11283
        DC32 5205, 354, 2132, 11960, 6305, 637, 3837, 11167, 7534, 900, 5420
        DC32 12128, 8329, 1049, 6312, 10969, 10777, 1429, 8604, 10300, 17376
        DC32 2135, 12853, 13899, 1681, -1316, -7921, 12580, 2045, -1026, -6179
        DC32 13265, 2439, -766, -4610, 14033, 2989, -465, -2802, 13452, 3098
        DC32 -413, -2482, 12396, 3658, -167, -1006, 13510, 3780, -119, -713
        DC32 12880, 4272, 62, 374, 13533, 4861, 253, 1523, 12667, 5457, 424
        DC32 2552, 13854, 6106, 590, 3551, 13031, 6483, 678, 4084, 13557, 7721
        DC32 937, 5639, 12957, 9311, 1213, 7304, 13714, 11551, 1532, 9221
        DC32 12591, 15206, 1938, 11667, 15113, 1540, -1445, -8700, 15072, 2333
        DC32 -832, -5007, 14527, 2511, -723, -4352, 14692, 3199, -365, -2197
        DC32 15382, 3560, -207, -1247, 14133, 3960, -50, -300, 15102, 4236, 50
        DC32 298, 14332, 4824, 242, 1454, 14846, 5451, 422, 2542, 15306, 6083
        DC32 584, 3518, 14329, 6888, 768, 4623, 15060, 7689, 930, 5602, 14406
        DC32 9426, 1231, 7413, 15387, 9741, 1280, 7706, 14824, 14271, 1844
        DC32 11102, 13600, 24939, 2669, 16067, 16396, 1969, -1082, -6517, 16817
        DC32 2832, -545, -3283, 15713, 2843, -539, -3248, 16104, 3336, -303
        DC32 -1825, 16384, 3963, -49, -294, 16940, 4579, 165, 992, 15711, 4599
        DC32 171, 1030, 16222, 5448, 421, 2537, 16832, 6382, 655, 3945, 15745
        DC32 7141, 821, 4944, 16326, 7469, 888, 5343, 16611, 8624, 1100, 6622
        DC32 17028, 10418, 1379, 8303, 15905, 11817, 1565, 9423, 16878, 14690
        DC32 1887, 11360, 16515, 20870, 2406, 14483, 18142, 2083, -999, -6013
        DC32 19401, 3178, -375, -2257, 17508, 3426, -264, -1589, 20054, 4027
        DC32 -25, -151, 18069, 4249, 54, 326, 18952, 5066, 314, 1890, 17711
        DC32 5402, 409, 2461, 19835, 6192, 610, 3676, 17950, 7014, 795, 4784
        DC32 21318, 7877, 966, 5816, 17910, 9289, 1210, 7283, 19144, 9290, 1210
        DC32 7284, 20517, 11381, 1510, 9089, 18075, 14485, 1866, 11234, 19999
        DC32 17882, 2177, 13108, 18842, 32764, 3072, 18494
        DC32 10813, 28753, 2879, 17333, 20480, 2785, -570, -3431, 18841, 6594
        DC32 703, 4235, 6225, 7413, 876, 5276, 17203, 10444, 1383, 8325, 21626
        DC32 1269, -1731, -10422, 21135, 4423, 113, 683, 11304, 1556, -1430
        DC32 -8609, 19005, 12820, 1686, 10148, 17367, 2498, -731, -4398, 17858
        DC32 4833, 244, 1472, 9994, 2498, -731, -4398, 17530, 7864, 964, 5802
        DC32 14254, 1884, -1147, -6907, 15892, 3153, -387, -2327, 6717, 1802
        DC32 -1213, -7303, 18186, 20193, 2357, 14189, 18022, 3031, -445, -2678
        DC32 16711, 5857, 528, 3181, 8847, 4014, -30, -180, 15892, 8970, 1158
        DC32 6972, 18022, 1392, -1594, -9599, 16711, 4096, 0, 0, 8192, 655
        DC32 -2708, -16305, 15237, 13926, 1808, 10884, 14254, 3112, -406, -2444
        DC32 14090, 4669, 193, 1165, 5406, 2703, -614, -3697, 13434, 6553, 694
        DC32 4180, 12451, 901, -2237, -13468, 12451, 2662, -637, -3833, 3768
        DC32 655, -2708, -16305, 14745, 23511, 2582, 15543, 19169, 2457, -755
        DC32 -4546, 20152, 5079, 318, 1913, 6881, 4096, 0, 0, 20480, 8560, 1089
        DC32 6556, 19660, 737, -2534, -15255, 19005, 4259, 58, 347, 7864, 2088
        DC32 -995, -5993, 11468, 12288, 1623, 9771, 15892, 1474, -1510, -9090
        DC32 15728, 4628, 180, 1086, 9175, 1433, -1552, -9341, 16056, 7004, 793
        DC32 4772, 14827, 737, -2534, -15255, 15073, 2252, -884, -5321, 5079
        DC32 1228, -1780, -10714, 13271, 17326, 2131, 12827, 16547, 2334, -831
        DC32 -5002, 15073, 5816, 518, 3118, 3932, 3686, -156, -938, 14254, 8601
        DC32 1096, 6598, 16875, 778, -2454, -14774, 15073, 3809, -107, -646
        DC32 6062, 614, -2804, -16879, 9338, 9256, 1204, 7251, 13271, 1761
        DC32 -1247, -7508, 13271, 3522, -223, -1343, 2457, 1966, -1084, -6529
        DC32 11468, 5529, 443, 2668, 10485, 737, -2534, -15255, 11632, 3194
        DC32 -367, -2212, 1474, 778, -2454, -14774

        RSEG DATA_C:CONST:SORT:NOROOT(2)
// static long const __data inter6[61]
inter6:
        DATA
        DC32 29443, 28346, 25207, 20449, 14701, 8693, 3143, -1352, -4402, -5865
        DC32 -5850, -4673, -2783, -672, 1211, 2536, 3130, 2991, 2259, 1170, 0
        DC32 -1001, -1652, -1868, -1666, -1147, -464, 218, 756, 1060, 1099, 904
        DC32 550, 135, -245, -514, -634, -602, -451, -231, 0, 191, 308, 340
        DC32 296, 198, 78, -36, -120, -163, -165, -132, -79, -19, 34, 73, 91
        DC32 89, 70, 38, 0

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI NoFunction
        THUMB
??Decoder_amr_reset??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock0
        REQUIRE Decoder_amr_reset
//   30 
//   31 /*
//   32  * Declare structure types
//   33  */
//   34 enum DTXStateType
//   35 {
//   36    SPEECH = 0, DTX, DTX_MUTE
//   37 };
//   38 
//   39 /*
//   40  * Decoder memory structure
//   41  */
//   42 typedef struct
//   43 {
//   44    /* history vector of past synthesis speech energy */
//   45    Word32 frameEnergyHist[L_ENERGYHIST];
//   46 
//   47 
//   48    /* state flags */
//   49    Word16 bgHangover;   /* counter; number of frames after last speech frame */
//   50 
//   51 
//   52 }Bgn_scdState;
//   53 typedef struct
//   54 {
//   55    Word32 hangCount;   /* counter; */
//   56    /* history vector of past synthesis speech energy */
//   57    Word32 cbGainHistory[L_CBGAINHIST];
//   58    Word16 hangVar;   /* counter; */
//   59 
//   60 }Cb_gain_averageState;
//   61 typedef struct
//   62 {
//   63    Word32 lsp_meanSave[M];   /* Averaged LSPs saved for efficiency  */
//   64 
//   65 
//   66 }lsp_avgState;
//   67 typedef struct
//   68 {
//   69    Word32 past_r_q[M];   /* Past quantized prediction error, Q15 */
//   70    Word32 past_lsf_q[M];   /* Past dequantized lsfs, Q15 */
//   71 
//   72 
//   73 }D_plsfState;
//   74 typedef struct
//   75 {
//   76    Word32 pbuf[5];
//   77    Word32 past_gain_pit;
//   78    Word32 prev_gp;
//   79 
//   80 
//   81 }ec_gain_pitchState;
//   82 typedef struct
//   83 {
//   84    Word32 gbuf[5];
//   85    Word32 past_gain_code;
//   86    Word32 prev_gc;
//   87 
//   88 
//   89 }ec_gain_codeState;
//   90 typedef struct
//   91 {
//   92    /*
//   93     * normal MA predictor memory, Q10
//   94     * (contains 20*log10(quaErr))
//   95     */
//   96    Word32 past_qua_en[4];
//   97 
//   98 
//   99    /*
//  100     * MA predictor memory for MR122 mode, Q10
//  101     * (contains log2(quaErr))
//  102     */
//  103    Word32 past_qua_en_MR122[4];
//  104 
//  105 
//  106 }gc_predState;
//  107 typedef struct
//  108 {
//  109    Word32 gainMem[PHDGAINMEMSIZE];
//  110    Word32 prevCbGain;
//  111    Word32 prevState;
//  112    Word16 lockFull;
//  113    Word16 onset;
//  114 
//  115 
//  116 }ph_dispState;
//  117 typedef struct
//  118 {
//  119    enum DTXStateType dtxGlobalState;   /* contains previous state */
//  120 
//  121    Word32 log_en;
//  122    Word32 old_log_en;
//  123    Word32 pn_seed_rx;
//  124    Word32 lsp[M];
//  125    Word32 lsp_old[M];
//  126    Word32 lsf_hist[M * DTX_HIST_SIZE];
//  127    Word32 lsf_hist_mean[M * DTX_HIST_SIZE];
//  128    Word32 log_en_hist[DTX_HIST_SIZE];
//  129    Word32 true_sid_period_inv;
//  130    Word16 since_last_sid;
//  131    Word16 lsf_hist_ptr;
//  132    Word16 log_pg_mean;
//  133    Word16 log_en_hist_ptr;
//  134    Word16 log_en_adjust;
//  135    Word16 dtxHangoverCount;
//  136    Word16 decAnaElapsedCount;
//  137    Word16 sid_frame;
//  138    Word16 valid_data;
//  139    Word16 dtxHangoverAdded;
//  140 
//  141 
//  142    /* updated in main decoder */
//  143    Word16 data_updated;   /* marker to know if CNI data is ever renewed */
//  144 
//  145 
//  146 }dtx_decState;
//  147 typedef struct
//  148 {
//  149    Word32 past_gain;
//  150 
//  151 
//  152 }agcState;
//  153 typedef struct
//  154 {
//  155    /* Excitation vector */
//  156    Word32 old_exc[L_SUBFR + PIT_MAX + L_INTERPOL];
//  157    Word32 *exc;
//  158    Word32 lsp_old[M];
//  159 
//  160 
//  161    /* Filter's memory */
//  162    Word32 mem_syn[M];
//  163 
//  164 
//  165    /* pitch sharpening */
//  166    Word32 sharp;
//  167    Word32 old_T0;
//  168 
//  169 
//  170    /* Variable holding received ltpLag, used in background noise and BFI */
//  171    Word32 T0_lagBuff;
//  172 
//  173 
//  174    /* Variables for the source characteristic detector (SCD) */
//  175    Word32 inBackgroundNoise;
//  176    Word32 voicedHangover;
//  177    Word32 ltpGainHistory[9];
//  178 
//  179 
//  180    /* Memories for bad frame handling */
//  181    Word32 excEnergyHist[9];
//  182    Word16 prev_bf;
//  183    Word16 prev_pdf;
//  184    Word16 state;
//  185    Word16 nodataSeed;
//  186 
//  187 
//  188    Bgn_scdState * background_state;
//  189    Cb_gain_averageState * Cb_gain_averState;
//  190    lsp_avgState * lsp_avg_st;
//  191    D_plsfState * lsfState;
//  192    ec_gain_pitchState * ec_gain_p_st;
//  193    ec_gain_codeState * ec_gain_c_st;
//  194    gc_predState * pred_state;
//  195    ph_dispState * ph_disp_st;
//  196    dtx_decState * dtxDecoderState;
//  197 }Decoder_amrState;
//  198 typedef struct
//  199 {
//  200    Word32 res2[L_SUBFR];
//  201    Word32 mem_syn_pst[M];
//  202    Word32 synth_buf[M + L_FRAME];
//  203    Word32 preemph_state_mem_pre;
//  204    agcState * agc_state;
//  205 }Post_FilterState;
//  206 typedef struct
//  207 {
//  208    Word32 y2_hi;
//  209    Word32 y2_lo;
//  210    Word32 y1_hi;
//  211    Word32 y1_lo;
//  212    Word32 x0;
//  213    Word32 x1;
//  214 
//  215 
//  216 }Post_ProcessState;
//  217 typedef struct
//  218 {
//  219    Decoder_amrState * decoder_amrState;
//  220    Post_FilterState * post_state;
//  221    Post_ProcessState * postHP_state;
//  222 }Speech_Decode_FrameState;
//  223 
//  224 
//  225 /*
//  226  * CodAmrReset
//  227  *
//  228  *
//  229  * Parameters:
//  230  *    state             B: state structure
//  231  *    mode              I: AMR mode
//  232  *
//  233  * Function:
//  234  *    Resets state memory
//  235  *
//  236  * Returns:
//  237  *    void
//  238  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock1 Using cfiCommon1
        CFI Function Decoder_amr_reset
        ARM
//  239 static void Decoder_amr_reset( Decoder_amrState *state, enum Mode mode )
//  240 {
Decoder_amr_reset:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
        MOV      R7,R0
//  241    Word32 i;
//  242 
//  243    /* Cb_gain_average_reset */
//  244    memset(state->Cb_gain_averState->cbGainHistory, 0, L_CBGAINHIST << 2);
        ADD      R5,R7,#+776
        LDR      R0,[R5, #+188]
        MOV      R4,R1
        MOV      R2,#+28
        MOV      R1,#+0
        ADD      R0,R0,#+4
        SWI      +187
//  245    state->Cb_gain_averState->hangVar = 0;
        LDR      R0,[R5, #+188]
        MOV      R6,#+0
        STRH     R6,[R0, #+32]
//  246    state->Cb_gain_averState->hangCount= 0;
        STR      R6,[R0, #+0]
//  247 
//  248    /* Initialize static pointer */
//  249    state->exc = state->old_exc + PIT_MAX + L_INTERPOL;
        ADD      R0,R7,#+616
        STR      R0,[R5, #+0]
//  250 
//  251    /* Static vectors to zero */
//  252    memset( state->old_exc, 0, ( PIT_MAX + L_INTERPOL )<<2 );
        MOV      R2,#+616
        MOV      R1,#+0
        MOV      R0,R7
        SWI      +187
//  253 
//  254    if ( mode != MRDTX )
        CMP      R4,#+8
        BEQ      ??Decoder_amr_reset_0
//  255       memset( state->mem_syn, 0, M <<2 );
        MOV      R2,#+40
        MOV      R1,#+0
        ADD      R0,R7,#+820
        SWI      +187
//  256 
//  257    /* initialize pitch sharpening */
//  258    state->sharp = SHARPMIN;
??Decoder_amr_reset_0:
        STR      R6,[R5, #+84]
//  259    state->old_T0 = 40;
        MOV      R0,#+40
        STR      R0,[R5, #+88]
        CMP      R4,#+8
        BEQ      ??Decoder_amr_reset_1
//  260 
//  261    /* Initialize state->lsp_old [] */
//  262    if ( mode != MRDTX ) {
//  263       state->lsp_old[0] = 30000;
        MOV      R1,#+48
        ORR      R1,R1,#0x7500
        STR      R1,[R5, #+4]
//  264       state->lsp_old[1] = 26000;
        SUB      R1,R1,#+4000
        STR      R1,[R5, #+8]
//  265       state->lsp_old[2] = 21000;
        MOV      R1,#+8
        ORR      R1,R1,#0x5200
        STR      R1,[R5, #+12]
//  266       state->lsp_old[3] = 15000;
        MOV      R1,#+152
        ORR      R1,R1,#0x3A00
        STR      R1,[R5, #+16]
//  267       state->lsp_old[4] = 8000;
        MOV      R1,#+8000
        STR      R1,[R5, #+20]
//  268       state->lsp_old[5] = 0;
        STR      R6,[R5, #+24]
//  269       state->lsp_old[6] = -8000;
        RSB      R1,R1,#+0
        STR      R1,[R5, #+28]
//  270       state->lsp_old[7] = -15000;
        MVN      R1,#+151
        BIC      R1,R1,#0x3A00
        STR      R1,[R5, #+32]
//  271       state->lsp_old[8] = -21000;
        MVN      R1,#+7
        BIC      R1,R1,#0x5200
        STR      R1,[R5, #+36]
//  272       state->lsp_old[9] = -26000;
        MVN      R1,#+143
        BIC      R1,R1,#0x6500
        STR      R1,[R5, #+40]
//  273    }
//  274 
//  275    /* Initialize memories of bad frame handling */
//  276    state->prev_bf = 0;
??Decoder_amr_reset_1:
        STRH     R6,[R5, #+176]
//  277    state->prev_pdf = 0;
        STRH     R6,[R5, #+178]
//  278    state->state = 0;
        STRH     R6,[R5, #+180]
//  279    state->T0_lagBuff = 40;
        STR      R0,[R5, #+92]
//  280    state->inBackgroundNoise = 0;
        STR      R6,[R5, #+96]
//  281    state->voicedHangover = 0;
        STR      R6,[R5, #+100]
//  282 
//  283    if ( mode != MRDTX )
        BEQ      ??Decoder_amr_reset_2
//  284       memset( state->excEnergyHist, 0, 9 <<2 );
        MOV      R2,#+36
        MOV      R1,#+0
        ADD      R0,R7,#+916
        SWI      +187
//  285    memset( state->ltpGainHistory, 0, 9 <<2 );
??Decoder_amr_reset_2:
        MOV      R2,#+36
        MOV      R1,#+0
        ADD      R0,R7,#+880
        SWI      +187
        MOV      R7,#+244
        ORR      R7,R7,#0x1300
        MOV      R8,#+92
        ORR      R8,R8,#0xD00
        MOV      R9,#+29
        ORR      R9,R9,#0x800
        MOV      R10,#+104
        ORR      R10,R10,#0x500
        CMP      R4,#+8
        BEQ      ??Decoder_amr_reset_3
//  286 
//  287    if ( mode != MRDTX ) {
//  288       state->lsp_avg_st->lsp_meanSave[0] = 1384;
        LDR      R0,[R5, #+192]
//  289       state->lsp_avg_st->lsp_meanSave[1] = 2077;
//  290       state->lsp_avg_st->lsp_meanSave[2] = 3420;
//  291       state->lsp_avg_st->lsp_meanSave[3] = 5108;
//  292       state->lsp_avg_st->lsp_meanSave[4] = 6742;
        MOV      R1,#+86
        STR      R10,[R0, #+0]
        STR      R9,[R0, #+4]
        STR      R8,[R0, #+8]
        STR      R7,[R0, #+12]
        ORR      R1,R1,#0x1A00
        STR      R1,[R0, #+16]
//  293       state->lsp_avg_st->lsp_meanSave[5] = 8122;
        MOV      R1,#+186
        ORR      R1,R1,#0x1F00
        STR      R1,[R0, #+20]
//  294       state->lsp_avg_st->lsp_meanSave[6] = 9863;
        MOV      R1,#+135
        ORR      R1,R1,#0x2600
        STR      R1,[R0, #+24]
//  295       state->lsp_avg_st->lsp_meanSave[7] = 11092;
        MOV      R1,#+84
        ORR      R1,R1,#0x2B00
        STR      R1,[R0, #+28]
//  296       state->lsp_avg_st->lsp_meanSave[8] = 12714;
        MOV      R1,#+170
        ORR      R1,R1,#0x3100
        STR      R1,[R0, #+32]
//  297       state->lsp_avg_st->lsp_meanSave[9] = 13701;
        MOV      R1,#+133
        ORR      R1,R1,#0x3500
        STR      R1,[R0, #+36]
//  298    }
//  299    memset( state->lsfState->past_r_q, 0, M <<2 );
??Decoder_amr_reset_3:
        LDR      R0,[R5, #+196]
        MOV      R2,#+40
        MOV      R1,#+0
        SWI      +187
//  300 
//  301    /* Past dequantized lsfs */
//  302    state->lsfState->past_lsf_q[0] = 1384;
        LDR      R0,[R5, #+196]
//  303    state->lsfState->past_lsf_q[1] = 2077;
//  304    state->lsfState->past_lsf_q[2] = 3420;
//  305    state->lsfState->past_lsf_q[3] = 5108;
//  306    state->lsfState->past_lsf_q[4] = 6742;
        MOV      R1,#+86
        STR      R10,[R0, #+40]
        STR      R9,[R0, #+44]
        STR      R8,[R0, #+48]
        STR      R7,[R0, #+52]
        ORR      R1,R1,#0x1A00
        STR      R1,[R0, #+56]
//  307    state->lsfState->past_lsf_q[5] = 8122;
        MOV      R1,#+186
        ORR      R1,R1,#0x1F00
        STR      R1,[R0, #+60]
//  308    state->lsfState->past_lsf_q[6] = 9863;
        MOV      R1,#+135
        ORR      R1,R1,#0x2600
        STR      R1,[R0, #+64]
//  309    state->lsfState->past_lsf_q[7] = 11092;
        MOV      R1,#+84
        ORR      R1,R1,#0x2B00
        STR      R1,[R0, #+68]
//  310    state->lsfState->past_lsf_q[8] = 12714;
        MOV      R1,#+170
        ORR      R1,R1,#0x3100
        STR      R1,[R0, #+72]
//  311    state->lsfState->past_lsf_q[9] = 13701;
        MOV      R1,#+133
        ORR      R1,R1,#0x3500
        STR      R1,[R0, #+76]
//  312 
//  313    for ( i = 0; i < 5; i++ )
        MOV      R0,R6
        ADD      R2,R10,#+256
//  314       state->ec_gain_p_st->pbuf[i] = 1640;
??Decoder_amr_reset_4:
        LDR      R1,[R5, #+200]
        STR      R2,[R1, +R0, LSL #+2]
        ADD      R0,R0,#+1
        CMP      R0,#+5
        BLT      ??Decoder_amr_reset_4
//  315    state->ec_gain_p_st->past_gain_pit = 0;
        STR      R6,[R1, #+20]
//  316    state->ec_gain_p_st->prev_gp = 16384;
        MOV      R0,#+16384
        STR      R0,[R1, #+24]
//  317 
//  318    for ( i = 0; i < 5; i++ )
        MOV      R0,#+0
        MOV      R11,#+1
//  319       state->ec_gain_c_st->gbuf[i] = 1;
??Decoder_amr_reset_5:
        LDR      R1,[R5, #+204]
        STR      R11,[R1, +R0, LSL #+2]
        ADD      R0,R0,#+1
        CMP      R0,#+5
        BLT      ??Decoder_amr_reset_5
//  320    state->ec_gain_c_st->past_gain_code = 0;
        STR      R6,[R1, #+20]
//  321    state->ec_gain_c_st->prev_gc = 1;
        STR      R11,[R1, #+24]
//  322 
//  323    if ( mode != MRDTX ) {
        CMP      R4,#+8
        BEQ      ??Decoder_amr_reset_6
//  324       for ( i = 0; i < NPRED; i++ ) {
        MOV      R0,#+0
//  325          state->pred_state->past_qua_en[i] = MIN_ENERGY;
??Decoder_amr_reset_7:
        LDR      R1,[R5, #+208]
        MVN      R2,#+255
        BIC      R2,R2,#0x3700
        STR      R2,[R1, +R0, LSL #+2]
//  326          state->pred_state->past_qua_en_MR122[i] = MIN_ENERGY_MR122;
        ADD      R1,R1,R0, LSL #+2
        MVN      R2,#+76
        BIC      R2,R2,#0x900
        STR      R2,[R1, #+16]
//  327       }
        ADD      R0,R0,#+1
        CMP      R0,#+4
        BLT      ??Decoder_amr_reset_7
//  328    }
//  329    state->nodataSeed = 21845;
??Decoder_amr_reset_6:
        MOV      R0,#+85
        ORR      R0,R0,#0x5500
        STRH     R0,[R5, #+182]
//  330 
//  331    /* Static vectors to zero */
//  332    memset( state->background_state->frameEnergyHist, 0, L_ENERGYHIST <<2 );
        LDR      R0,[R5, #+184]
        MOV      R2,#+240
        MOV      R1,#+0
        SWI      +187
//  333 
//  334    /* Initialize hangover handling */
//  335    state->background_state->bgHangover = 0;
        LDR      R0,[R5, #+184]
//  336 
//  337    /* phDispReset */
//  338    memset( state->ph_disp_st->gainMem, 0, PHDGAINMEMSIZE <<2 );
        MOV      R2,#+20
        STRH     R6,[R0, #+240]
        LDR      R0,[R5, #+212]
        MOV      R1,R6
        SWI      +187
//  339    state->ph_disp_st->prevState = 0;
        LDR      R0,[R5, #+212]
//  340    state->ph_disp_st->prevCbGain = 0;
//  341    state->ph_disp_st->lockFull = 0;
//  342    state->ph_disp_st->onset = 0;   /* assume no onset in start */
//  343 
//  344    if ( mode != MRDTX ) {
        CMP      R4,#+8
        STR      R6,[R0, #+24]
        STR      R6,[R0, #+20]
        STRH     R6,[R0, #+28]
        STRH     R6,[R0, #+30]
        POPEQ    {R4-R11,PC}
//  345       state->dtxDecoderState->since_last_sid = 0;
        LDR      R1,[R5, #+216]
//  346       state->dtxDecoderState->true_sid_period_inv = 8192;
        MOV      R2,#+8192
        ADD      R0,R1,#+772
        STRH     R6,[R0, #+0]
        ADD      R1,R1,#+4
        STR      R2,[R1, #+764]
//  347       state->dtxDecoderState->log_en = 3500;
        ADD      R2,R8,#+80
        STR      R2,[R1, #+0]
//  348       state->dtxDecoderState->old_log_en = 3500;
        STR      R2,[R1, #+4]
//  349 
//  350       /* low level noise for better performance in  DTX handover cases*/
//  351       state->dtxDecoderState->pn_seed_rx = PN_INITIAL_SEED;
        LDR      R2,??Decoder_amr_reset_8  ;; 0x70816958
//  352 
//  353       /* Initialize state->lsp [] */
//  354       state->dtxDecoderState->lsp[0] = 30000;
//  355       state->dtxDecoderState->lsp[1] = 26000;
//  356       state->dtxDecoderState->lsp[2] = 21000;
//  357       state->dtxDecoderState->lsp[3] = 15000;
//  358       state->dtxDecoderState->lsp[4] = 8000;
//  359       state->dtxDecoderState->lsp[5] = 0;
//  360       state->dtxDecoderState->lsp[6] = -8000;
//  361       state->dtxDecoderState->lsp[7] = -15000;
//  362       state->dtxDecoderState->lsp[8] = -21000;
//  363       state->dtxDecoderState->lsp[9] = -26000;
//  364 
//  365       /* Initialize state->lsp_old [] */
//  366       state->dtxDecoderState->lsp_old[0] = 30000;
//  367       state->dtxDecoderState->lsp_old[1] = 26000;
//  368       state->dtxDecoderState->lsp_old[2] = 21000;
//  369       state->dtxDecoderState->lsp_old[3] = 15000;
//  370       state->dtxDecoderState->lsp_old[4] = 8000;
//  371       state->dtxDecoderState->lsp_old[5] = 0;
//  372       state->dtxDecoderState->lsp_old[6] = -8000;
//  373       state->dtxDecoderState->lsp_old[7] = -15000;
//  374       state->dtxDecoderState->lsp_old[8] = -21000;
//  375       state->dtxDecoderState->lsp_old[9] = -26000;
//  376       state->dtxDecoderState->lsf_hist_ptr = 0;
//  377       state->dtxDecoderState->log_pg_mean = 0;
//  378       state->dtxDecoderState->log_en_hist_ptr = 0;
//  379 
//  380       /* initialize decoder lsf history */
//  381       state->dtxDecoderState->lsf_hist[0] = 1384;
//  382       state->dtxDecoderState->lsf_hist[1] = 2077;
//  383       state->dtxDecoderState->lsf_hist[2] = 3420;
//  384       state->dtxDecoderState->lsf_hist[3] = 5108;
//  385       state->dtxDecoderState->lsf_hist[4] = 6742;
//  386       state->dtxDecoderState->lsf_hist[5] = 8122;
//  387       state->dtxDecoderState->lsf_hist[6] = 9863;
//  388       state->dtxDecoderState->lsf_hist[7] = 11092;
//  389       state->dtxDecoderState->lsf_hist[8] = 12714;
//  390       state->dtxDecoderState->lsf_hist[9] = 13701;
//  391 
//  392       for ( i = 1; i < DTX_HIST_SIZE; i++ ) {
        MOV      R4,#+1
        STR      R2,[R1, #+8]
        MOV      R2,#+48
        ORR      R2,R2,#0x7500
        STR      R2,[R1, #+12]
        SUB      R2,R2,#+4000
        STR      R2,[R1, #+16]
        MOV      R2,#+8
        ORR      R2,R2,#0x5200
        STR      R2,[R1, #+20]
        MOV      R2,#+152
        ORR      R2,R2,#0x3A00
        STR      R2,[R1, #+24]
        MOV      R2,#+8000
        STR      R2,[R1, #+28]
        STR      R6,[R1, #+32]
        RSB      R2,R2,#+0
        STR      R2,[R1, #+36]
        MVN      R2,#+151
        BIC      R2,R2,#0x3A00
        STR      R2,[R1, #+40]
        MVN      R2,#+7
        BIC      R2,R2,#0x5200
        STR      R2,[R1, #+44]
        MVN      R2,#+143
        BIC      R2,R2,#0x6500
        STR      R2,[R1, #+48]
        MOV      R2,#+48
        ORR      R2,R2,#0x7500
        STR      R2,[R1, #+52]
        SUB      R2,R2,#+4000
        STR      R2,[R1, #+56]
        MOV      R2,#+8
        ORR      R2,R2,#0x5200
        STR      R2,[R1, #+60]
        MOV      R2,#+152
        ORR      R2,R2,#0x3A00
        STR      R2,[R1, #+64]
        MOV      R2,#+8000
        STR      R2,[R1, #+68]
        STR      R6,[R1, #+72]
        RSB      R2,R2,#+0
        STR      R2,[R1, #+76]
        MVN      R2,#+151
        BIC      R2,R2,#0x3A00
        STR      R2,[R1, #+80]
        MVN      R2,#+7
        BIC      R2,R2,#0x5200
        STR      R2,[R1, #+84]
        MVN      R2,#+143
        BIC      R2,R2,#0x6500
        STR      R2,[R1, #+88]
        STRH     R6,[R0, #+2]
        STRH     R6,[R0, #+4]
        STRH     R6,[R0, #+6]
        STR      R10,[R1, #+92]
        STR      R9,[R1, #+96]
        STR      R8,[R1, #+100]
        STR      R7,[R1, #+104]
        MOV      R0,#+86
        ORR      R0,R0,#0x1A00
        STR      R0,[R1, #+108]
        MOV      R0,#+186
        ORR      R0,R0,#0x1F00
        STR      R0,[R1, #+112]
        MOV      R0,#+135
        ORR      R0,R0,#0x2600
        STR      R0,[R1, #+116]
        MOV      R0,#+84
        ORR      R0,R0,#0x2B00
        STR      R0,[R1, #+120]
        MOV      R0,#+170
        ORR      R0,R0,#0x3100
        STR      R0,[R1, #+124]
        MOV      R0,#+133
        ORR      R0,R0,#0x3500
        STR      R0,[R1, #+128]
//  393          memcpy( &state->dtxDecoderState->lsf_hist[M * i], &state->
//  394                dtxDecoderState->lsf_hist[0], M <<2 );
??Decoder_amr_reset_9:
        LDR      R0,[R5, #+216]
        MOV      R2,#+40
        ADD      R1,R0,#+96
        MLA      R0,R2,R4,R0
//  395       }
        ADD      R4,R4,#+1
        ADD      R0,R0,#+96
        SWI      +286
        CMP      R4,#+8
        BLT      ??Decoder_amr_reset_9
//  396       memset( state->dtxDecoderState->lsf_hist_mean, 0, M * DTX_HIST_SIZE <<2 );
        LDR      R0,[R5, #+216]
        MOV      R2,#+320
        MOV      R1,#+0
        ADD      R0,R0,#+416
        SWI      +187
//  397 
//  398       /* initialize decoder log frame energy */
//  399       for ( i = 0; i < DTX_HIST_SIZE; i++ ) {
        MOV      R0,R6
//  400          state->dtxDecoderState->log_en_hist[i] = state->dtxDecoderState->log_en
//  401          ;
??Decoder_amr_reset_10:
        LDR      R1,[R5, #+216]
        ADD      R2,R1,R0, LSL #+2
        LDR      R3,[R1, #+4]
//  402       }
        ADD      R0,R0,#+1
        STR      R3,[R2, #+736]
        CMP      R0,#+8
        BLT      ??Decoder_amr_reset_10
//  403       state->dtxDecoderState->log_en_adjust = 0;
        ADD      R0,R1,#+780
        STRH     R6,[R0, #+0]
//  404       state->dtxDecoderState->dtxHangoverCount = DTX_HANG_CONST;
        MOV      R2,#+7
        STRH     R2,[R0, #+2]
//  405       state->dtxDecoderState->decAnaElapsedCount = 31;
        MOV      R2,#+31
        STRH     R2,[R0, #+4]
//  406       state->dtxDecoderState->sid_frame = 0;
        STRH     R6,[R0, #+6]
//  407       state->dtxDecoderState->valid_data = 0;
        STRH     R6,[R0, #+8]
//  408       state->dtxDecoderState->dtxHangoverAdded = 0;
        STRH     R6,[R0, #+10]
//  409       state->dtxDecoderState->dtxGlobalState = DTX;
        STRB     R11,[R1, #+0]
//  410       state->dtxDecoderState->data_updated = 0;
        LDR      R0,[R5, #+216]
        ADD      R0,R0,#+792
        STRH     R6,[R0, #+0]
//  411    }
//  412    return;
        POP      {R4-R11,PC}      ;; return
        DATA
??Decoder_amr_reset_8:
        DC32     0x70816958
        CFI EndBlock cfiBlock1
//  413 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock2 Using cfiCommon0
        CFI NoFunction
        THUMB
??rx_dtx_handler??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock2
        REQUIRE rx_dtx_handler
//  414 
//  415 
//  416 /*
//  417  * rx_dtx_handler
//  418  *
//  419  *
//  420  * Parameters:
//  421  *    st->dtxGlobalState      I: DTX state
//  422  *    st->since_last_sid      B: Frames after last SID frame
//  423  *    st->data_updated        I: SID update flag
//  424  *    st->decAnaElapsedCount  B: state machine that synch with the GSMEFR txDtx machine
//  425  *    st->dtxHangoverAdded    B: DTX hangover
//  426  *    st->sid_frame           O: SID frame indicator
//  427  *    st->valid_data          O: Vaild data indicator
//  428  *    frame_type              O: Frame type
//  429  *
//  430  * Function:
//  431  *    Find the new DTX state
//  432  *
//  433  * Returns:
//  434  *    DTXStateType            DTX, DTX_MUTE or SPEECH
//  435  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock3 Using cfiCommon1
        CFI Function rx_dtx_handler
        ARM
//  436 static enum DTXStateType rx_dtx_handler( dtx_decState *st, enum RXFrameType frame_type )
//  437 {
//  438    enum DTXStateType newState;
//  439    enum DTXStateType encState;
//  440 
//  441    /* DTX if SID frame or previously in DTX{_MUTE} and (NO_RX OR BAD_SPEECH) */
//  442    if ( table_SID[frame_type] | ( ( st->dtxGlobalState != SPEECH ) &
//  443          table_speech_bad[frame_type] ) ) {
rx_dtx_handler:
        LDR      R12,??DataTable0  ;; sqrt_table
        PUSH     {R4-R7}
        CFI R7 Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
        ADD      R12,R1,R12
        LDRB     R5,[R0, #+0]
        LDRB     R7,[R12, #+336]
        ADD      R4,R0,#+772
        LDRB     R0,[R12, #+348]
        MOV      R2,#+0
        MOV      R3,#+1
        CMP      R5,#+0
        MOVNE    R6,#+1
        MOVEQ    R6,#+0
        AND      R6,R7,R6
        ORRS     R0,R6,R0
        BEQ      ??rx_dtx_handler_0
//  444       newState = DTX;
//  445 
//  446       /* stay in mute for these input types */
//  447       if ( ( st->dtxGlobalState == DTX_MUTE ) & table_mute[frame_type] ) {
        LDRB     R6,[R12, #+372]
        CMP      R5,#+2
        MOVEQ    R5,#+1
        MOVNE    R5,#+0
        AND      R6,R6,#0x1
        TST      R6,R5
//  448          newState = DTX_MUTE;
//  449       }
//  450 
//  451       /*
//  452        * evaluate if noise parameters are too old
//  453        * since_last_sid is reset when CN parameters have been updated
//  454        */
//  455       st->since_last_sid += 1;
        LDRSH    R5,[R4, #+0]
        MOV      R0,#+1
        MOVNE    R0,#+2
        ADD      R5,R5,#+1
//  456 
//  457       /* no update of sid parameters in DTX for a long while */
//  458       if ((frame_type != RX_SID_UPDATE) & ( st->since_last_sid > DTX_MAX_EMPTY_THRESH )) {
        CMP      R1,#+5
        BEQ      ??rx_dtx_handler_1
        MOV      R5,R5, LSL #+16
        MOV      R5,R5, ASR #+16
        CMP      R5,#+51
        BLT      ??rx_dtx_handler_1
//  459          newState = DTX_MUTE;
        MOV      R0,#+2
        B        ??rx_dtx_handler_1
//  460       }
//  461    }
//  462    else {
//  463       newState = SPEECH;
??rx_dtx_handler_0:
        MOV      R0,#+0
//  464       st->since_last_sid = 0;
        MOV      R5,R0
??rx_dtx_handler_1:
        STRH     R5,[R4, #+0]
//  465    }
//  466 
//  467    /*
//  468     * reset the decAnaElapsed Counter when receiving CNI data the first
//  469     * time, to robustify counter missmatch after handover
//  470     * this might delay the bwd CNI analysis in the new decoder slightly.
//  471     */
//  472    if ( ( st->data_updated == 0 ) & ( frame_type == RX_SID_UPDATE ) ) {
        LDRSH    R5,[R4, #+20]
//  473       st->decAnaElapsedCount = 0;
//  474    }
//  475 
//  476    /*
//  477     * update the SPE-SPD DTX hangover synchronization
//  478     * to know when SPE has added dtx hangover
//  479     */
//  480    st->decAnaElapsedCount += 1;
//  481    st->dtxHangoverAdded = 0;
//  482    encState = SPEECH;
        MOV      R6,#+0
        CMP      R5,#+0
        CMPEQ    R1,#+5
        STRHEQ   R2,[R4, #+12]
        LDRSH    R5,[R4, #+12]
        ADD      R5,R5,#+1
        STRH     R5,[R4, #+12]
        STRH     R2,[R4, #+18]
//  483 
//  484    if ( table_DTX[frame_type] ) {
        LDRB     R7,[R12, #+360]
        CMP      R7,#+0
        BEQ      ??rx_dtx_handler_2
//  485       encState = DTX;
        MOV      R6,#+1
//  486       if( ( frame_type == RX_NO_DATA ) & ( newState == SPEECH ) ) {
        CMP      R1,#+7
        CMPEQ    R0,#+0
//  487          encState = SPEECH;
        MOVEQ    R6,#+0
//  488       }
//  489    }
//  490 
//  491    if ( encState == SPEECH ) {
??rx_dtx_handler_2:
        LDRSH    R12,[R4, #+10]
        CMP      R6,#+0
//  492       st->dtxHangoverCount = DTX_HANG_CONST;
        MOVEQ    R12,#+7
        BEQ      ??rx_dtx_handler_3
//  493    }
//  494    else {
//  495       if ( st->decAnaElapsedCount > DTX_ELAPSED_FRAMES_THRESH ) {
        MOV      R5,R5, LSL #+16
        MOV      R5,R5, ASR #+16
        CMP      R5,#+31
        BLT      ??rx_dtx_handler_4
//  496          st->dtxHangoverAdded = 1;
        STRH     R3,[R4, #+18]
//  497          st->decAnaElapsedCount = 0;
        STRH     R2,[R4, #+12]
//  498          st->dtxHangoverCount = 0;
        MOV      R12,#+0
        B        ??rx_dtx_handler_3
//  499       }
//  500       else if ( st->dtxHangoverCount == 0 ) {
??rx_dtx_handler_4:
        CMP      R12,#+0
//  501          st->decAnaElapsedCount = 0;
        STRHEQ   R2,[R4, #+12]
//  502       }
//  503       else {
//  504          st->dtxHangoverCount -= 1;
        SUBNE    R12,R12,#+1
??rx_dtx_handler_3:
        STRH     R12,[R4, #+10]
//  505       }
//  506    }
//  507 
//  508    if ( newState != SPEECH ) {
        CMP      R0,#+0
        BEQ      ??rx_dtx_handler_5
//  509       /*
//  510        * DTX or DTX_MUTE
//  511        * CN data is not in a first SID, first SIDs are marked as SID_BAD
//  512        * but will do backwards analysis if a hangover period has been added
//  513        * according to the state machine above
//  514        */
//  515       st->sid_frame = 0;
        STRH     R2,[R4, #+14]
//  516       st->valid_data = 0;
        STRH     R2,[R4, #+16]
//  517 
//  518       if ( frame_type == RX_SID_FIRST ) {
        CMP      R1,#+4
//  519          st->sid_frame = 1;
        STRHEQ   R3,[R4, #+14]
        BEQ      ??rx_dtx_handler_5
//  520       }
//  521       else if ( frame_type == RX_SID_UPDATE ) {
        CMP      R1,#+5
//  522          st->sid_frame = 1;
        STRHEQ   R3,[R4, #+14]
//  523          st->valid_data = 1;
        STRHEQ   R3,[R4, #+16]
        BEQ      ??rx_dtx_handler_5
//  524       }
//  525       else if ( frame_type == RX_SID_BAD ) {
        CMP      R1,#+6
//  526          st->sid_frame = 1;
        STRHEQ   R3,[R4, #+14]
//  527 
//  528          /* use old data */
//  529          st->dtxHangoverAdded = 0;
        STRHEQ   R2,[R4, #+18]
//  530       }
//  531    }
//  532 
//  533    /* newState is used by both SPEECH AND DTX synthesis routines */
//  534    return newState;
??rx_dtx_handler_5:
        POP      {R4-R7}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock3
//  535 }

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable0:
        DC32     sqrt_table

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock4 Using cfiCommon0
        CFI NoFunction
        THUMB
??Lsf_lsp??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock4
        REQUIRE Lsf_lsp
//  536 
//  537 
//  538 /*
//  539  * Lsf_lsp
//  540  *
//  541  *
//  542  * Parameters:
//  543  *    lsf               I: vector of LSFs
//  544  *    lsp               O: vector of LSPs
//  545  *
//  546  * Function:
//  547  *    Transformation lsf to lsp, order M
//  548  *
//  549  * Returns:
//  550  *    void
//  551  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock5 Using cfiCommon1
        CFI Function Lsf_lsp
        ARM
//  552 static void Lsf_lsp( Word32 lsf[], Word32 lsp[] )
//  553 {
Lsf_lsp:
        PUSH     {R4}
        CFI R4 Frame(CFA, -4)
        CFI CFA R13+4
//  554    Word32 i, ind, offset, tmp;
//  555 
//  556 
//  557    for ( i = 0; i < M; i++ ) {
        MOV      R2,#+0
//  558       /* ind = b8-b15 of lsf[i] */
//  559       ind = lsf[i] >> 8;
??Lsf_lsp_0:
        LDR      R3,[R0, +R2, LSL #+2]
//  560 
//  561       /* offset = b0-b7  of lsf[i] */
//  562       offset = lsf[i] & 0x00ff;
//  563 
//  564       /* lsp[i] = table[ind]+ ((table[ind+1]-table[ind])*offset) / 256 */
//  565       tmp = ( ( cos_table[ind+1]-cos_table[ind] )*offset ) << 1;
//  566       lsp[i] = cos_table[ind] + ( tmp >> 9 );
        LDR      R12,??Lsf_lsp_1  ;; dtx_log_en_adjust
        ASR      R3,R3,#+8
        ADD      R3,R12,R3, LSL #+2
        LDR      R12,[R3, #+40]
        LDR      R4,[R3, #+44]
        SUB      R3,R4,R12
        LDR      R4,[R0, +R2, LSL #+2]
        AND      R4,R4,#0xFF
        MUL      R3,R4,R3
        LSL      R3,R3,#+1
        ADD      R3,R12,R3, ASR #+9
        STR      R3,[R1, +R2, LSL #+2]
//  567    }
        ADD      R2,R2,#+1
        CMP      R2,#+10
        BLT      ??Lsf_lsp_0
//  568    return;
        POP      {R4}
        CFI R4 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        DATA
??Lsf_lsp_1:
        DC32     dtx_log_en_adjust
        CFI EndBlock cfiBlock5
//  569 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock6 Using cfiCommon0
        CFI NoFunction
        THUMB
??D_plsf_3??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock6
        REQUIRE D_plsf_3
//  570 
//  571 
//  572 /*
//  573  * D_plsf_3
//  574  *
//  575  *
//  576  * Parameters:
//  577  *    st->past_lsf_q    I: Past dequantized LFSs
//  578  *    st->past_r_q      B: past quantized residual
//  579  *    mode              I: AMR mode
//  580  *    bfi               B: bad frame indicator
//  581  *    indice            I: quantization indices of 3 submatrices, Q0
//  582  *    lsp1_q            O: quantized 1st LSP vector
//  583  *
//  584  * Function:
//  585  *    Decodes the LSP parameters using the received quantization indices.
//  586  *    1st order MA prediction and split by 3 vector quantization (split-VQ)
//  587  *
//  588  * Returns:
//  589  *    void
//  590  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock7 Using cfiCommon1
        CFI Function D_plsf_3
        ARM
//  591 static void D_plsf_3( D_plsfState *st, enum Mode mode, Word16 bfi, Word16 *
//  592       indice, Word32 *lsp1_q )
//  593 {
D_plsf_3:
        PUSH     {R4-R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
        SUB      SP,SP,#+80
        CFI CFA R13+100
        LDR      R5,[SP, #+100]
        MOV      R4,R0
//  594    Word32 lsf1_r[M], lsf1_q[M];
//  595    Word32 i, index, temp;
//  596    const Word32 *p_cb1, *p_cb2, *p_cb3, *p_dico;
//  597 
//  598 
//  599    /* if bad frame */
//  600    if ( bfi != 0 ) {
        LDR      R0,??D_plsf_3_0  ;; mean_lsf_3
        CMP      R2,#+0
        BEQ      ??D_plsf_3_1
//  601       /* use the past LSFs slightly shifted towards their mean */
//  602       for ( i = 0; i < M; i++ ) {
        MOV      R2,#+0
        ADD      R3,SP,#+40
//  603          /* lsfi_q[i] = ALPHA*past_lsf_q[i] + ONE_ALPHA*meanLsf[i]; */
//  604          lsf1_q[i] = ( ( st->past_lsf_q[i] * ALPHA ) >> 15 ) + ( ( mean_lsf_3[i]
//  605                * ONE_ALPHA ) >> 15 );
??D_plsf_3_2:
        ADD      R12,R4,R2, LSL #+2
        LDR      R12,[R12, #+40]
        MOV      LR,#+51
        ORR      LR,LR,#0x7300
        MUL      R12,LR,R12
        LDR      LR,[R0, +R2, LSL #+2]
        MOV      R6,#+205
        ORR      R6,R6,#0xC00
        MUL      LR,R6,LR
        ASR      R6,LR,#+15
        ADD      R6,R6,R12, ASR #+15
        STR      R6,[R3, +R2, LSL #+2]
//  606       }
        ADD      R2,R2,#+1
        CMP      R2,#+10
        BLT      ??D_plsf_3_2
//  607 
//  608       /* estimate past quantized residual to be used in next frame */
//  609       if ( mode != MRDTX ) {
        CMP      R1,#+8
        MOV      R1,#+0
        BEQ      ??D_plsf_3_3
//  610          for ( i = 0; i < M; i++ ) {
//  611             /* temp  = meanLsf[i] +  pastR2_q[i] * pred_fac; */
//  612             temp = mean_lsf_3[i] + ( ( st->past_r_q[i] * pred_fac[i] ) >> 15 );
//  613             st->past_r_q[i] = lsf1_q[i] - temp;
??D_plsf_3_4:
        LDR      R3,[R0, +R1, LSL #+2]
        ADD      R2,SP,#+40
        LDR      R2,[R2, +R1, LSL #+2]
        ADD      R6,R0,R1, LSL #+2
        LDR      R6,[R6, #+40]
        SUB      R2,R2,R3
        LDR      R3,[R4, +R1, LSL #+2]
        MUL      R3,R6,R3
        SUB      R2,R2,R3, ASR #+15
        STR      R2,[R4, +R1, LSL #+2]
//  614          }
        ADD      R1,R1,#+1
        CMP      R1,#+10
        BLT      ??D_plsf_3_4
//  615       }
//  616       else {
//  617          for ( i = 0; i < M; i++ ) {
//  618             /* temp  = meanLsf[i] +  pastR2_q[i]; */
//  619             temp = mean_lsf_3[i] + st->past_r_q[i];
//  620             st->past_r_q[i] = lsf1_q[i] - temp;
//  621          }
//  622       }
//  623    }
//  624 
//  625    /* if good LSFs received */
//  626    else {
//  627       if ( ( mode == MR475 ) | ( mode == MR515 ) ) {
//  628          /* MR475, MR515 */
//  629          p_cb1 = dico1_lsf_3;
//  630          p_cb2 = dico2_lsf_3;
//  631          p_cb3 = mr515_3_lsf;
//  632       }
//  633       else if ( mode == MR795 ) {
//  634          /* MR795 */
//  635          p_cb1 = mr795_1_lsf;
//  636          p_cb2 = dico2_lsf_3;
//  637          p_cb3 = dico3_lsf_3;
//  638       }
//  639       else {
//  640          /* MR59, MR67, MR74, MR102, MRDTX */
//  641          p_cb1 = dico1_lsf_3;
//  642          p_cb2 = dico2_lsf_3;
//  643          p_cb3 = dico3_lsf_3;
//  644       }
//  645 
//  646       /* decode prediction residuals from 3 received indices */
//  647       index = *indice++;
//  648       p_dico = &p_cb1[index + index + index];
//  649       index = *indice++;
//  650       lsf1_r[0] = *p_dico++;
//  651       lsf1_r[1] = *p_dico++;
//  652       lsf1_r[2] = *p_dico++;
//  653 
//  654       if ( ( mode == MR475 ) | ( mode == MR515 ) ) {
//  655          /* MR475, MR515 only using every second entry */
//  656          index = index << 1;
//  657       }
//  658       p_dico = &p_cb2[index + index + index];
//  659       index = *indice++;
//  660       lsf1_r[3] = *p_dico++;
//  661       lsf1_r[4] = *p_dico++;
//  662       lsf1_r[5] = *p_dico++;
//  663       p_dico = &p_cb3[index << 2];
//  664       lsf1_r[6] = *p_dico++;
//  665       lsf1_r[7] = *p_dico++;
//  666       lsf1_r[8] = *p_dico++;
//  667       lsf1_r[9] = *p_dico++;
//  668 
//  669       /* Compute quantized LSFs and update the past quantized residual */
//  670       if ( mode != MRDTX ) {
//  671          for ( i = 0; i < M; i++ ) {
//  672             lsf1_q[i] = lsf1_r[i] + ( mean_lsf_3[i] + ( ( st->past_r_q[i] *
//  673                   pred_fac[i] ) >> 15 ) );
//  674          }
//  675          memcpy( st->past_r_q, lsf1_r, M <<2 );
//  676       }
//  677       else {
//  678          for ( i = 0; i < M; i++ ) {
//  679             lsf1_q[i] = lsf1_r[i] + ( mean_lsf_3[i] + st->past_r_q[i] );
//  680          }
//  681          memcpy( st->past_r_q, lsf1_r, M <<2 );
//  682       }
//  683    }
//  684 
//  685    /* verification that LSFs has minimum distance of LSF_GAP Hz */
//  686    temp = LSF_GAP;
??D_plsf_3_5:
        MOV      R0,#+205
//  687 
//  688    for ( i = 0; i < M; i++ ) {
        MOV      R1,#+0
//  689       if ( lsf1_q[i] < temp ) {
??D_plsf_3_6:
        ADD      R2,SP,#+40
        ADD      R2,R2,R1, LSL #+2
        LDR      R3,[R2, #+0]
//  690          lsf1_q[i] = temp;
//  691       }
//  692       temp = lsf1_q[i] + LSF_GAP;
//  693    }
        ADD      R1,R1,#+1
        CMP      R3,R0
        STRLT    R0,[R2, #+0]
        LDR      R0,[R2, #+0]
        CMP      R1,#+10
        ADD      R0,R0,#+205
        BLT      ??D_plsf_3_6
//  694    memcpy( st->past_lsf_q, lsf1_q, M <<2 );
        MOV      R2,#+40
        ADD      R1,SP,#+40
        ADD      R0,R4,#+40
        SWI      +286
//  695 
//  696    /*  convert LSFs to the cosine domain */
//  697    Lsf_lsp( lsf1_q, lsp1_q );
        MOV      R1,R5
        ADD      R0,SP,#+40
        BL       Lsf_lsp
//  698    return;
        ADD      SP,SP,#+80
        CFI CFA R13+20
        POP      {R4-R7,PC}       ;; return
        CFI CFA R13+100
??D_plsf_3_3:
        LDR      R3,[R0, +R1, LSL #+2]
        ADD      R2,SP,#+40
        LDR      R2,[R2, +R1, LSL #+2]
        SUB      R2,R2,R3
        LDR      R3,[R4, +R1, LSL #+2]
        SUB      R2,R2,R3
        STR      R2,[R4, +R1, LSL #+2]
        ADD      R1,R1,#+1
        CMP      R1,#+10
        BGE      ??D_plsf_3_5
        B        ??D_plsf_3_3
??D_plsf_3_1:
        CMP      R1,#+0
        CMPNE    R1,#+1
        BEQ      ??D_plsf_3_7
        MOV      R2,#+80
        ORR      R2,R2,#0x2400
        ADD      R2,R2,R0
        CMP      R1,#+5
        BNE      ??D_plsf_3_8
        MOV      R6,#+80
        ORR      R6,R6,#0x4C00
        ADD      R12,R6,R0
        B        ??D_plsf_3_9
??D_plsf_3_7:
        ADD      R12,R0,#+80
        MOV      R2,#+80
        ORR      R2,R2,#0x4400
        ADD      R2,R2,R0
        B        ??D_plsf_3_9
??D_plsf_3_8:
        ADD      R12,R0,#+80
??D_plsf_3_9:
        LDRSH    LR,[R3], #+2
        CMP      R1,#+0
        CMPNE    R1,#+1
        ADD      R6,LR,LR, LSL #+1
        LDRSH    LR,[R3], #+2
        ADD      R12,R12,R6, LSL #+2
        LDR      R7,[R12], #+4
        LSLEQ    LR,LR,#+1
        STR      R7,[SP, #+0]
        LDR      R7,[R12], #+4
        ADD      R6,LR,LR, LSL #+1
        STR      R7,[SP, #+4]
        LDR      R7,[R12, #+0]
        ADD      R6,R0,R6, LSL #+2
        STR      R7,[SP, #+8]
        ADD      R12,R6,#+3152
        LDR      R7,[R12], #+4
        CMP      R1,#+8
        STR      R7,[SP, #+12]
        LDR      R7,[R12], #+4
        MOV      R1,#+0
        STR      R7,[SP, #+16]
        LDR      R7,[R12, #+0]
        STR      R7,[SP, #+20]
        LDRSH    R3,[R3, #+0]
        ADD      R2,R2,R3, LSL #+4
        LDR      R6,[R2], #+4
        STR      R6,[SP, #+24]
        LDR      R6,[R2], #+4
        STR      R6,[SP, #+28]
        LDR      R6,[R2], #+4
        STR      R6,[SP, #+32]
        LDR      R2,[R2, #+0]
        STR      R2,[SP, #+36]
        ADD      R2,SP,#+40
        BEQ      ??D_plsf_3_10
??D_plsf_3_11:
        LDR      R6,[R0, +R1, LSL #+2]
        MOV      R3,SP
        LDR      R3,[R3, +R1, LSL #+2]
        ADD      R7,R0,R1, LSL #+2
        LDR      R7,[R7, #+40]
        ADD      R3,R6,R3
        LDR      R6,[R4, +R1, LSL #+2]
        MUL      R6,R7,R6
        ADD      R3,R3,R6, ASR #+15
        STR      R3,[R2, +R1, LSL #+2]
        ADD      R1,R1,#+1
        CMP      R1,#+10
        BLT      ??D_plsf_3_11
??D_plsf_3_12:
        MOV      R2,#+40
        MOV      R1,SP
        MOV      R0,R4
        SWI      +286
        B        ??D_plsf_3_5
??D_plsf_3_10:
        LDR      R6,[R0, +R1, LSL #+2]
        MOV      R3,SP
        LDR      R3,[R3, +R1, LSL #+2]
        ADD      R3,R6,R3
        LDR      R6,[R4, +R1, LSL #+2]
        ADD      R3,R6,R3
        STR      R3,[R2, +R1, LSL #+2]
        ADD      R1,R1,#+1
        CMP      R1,#+10
        BGE      ??D_plsf_3_12
        B        ??D_plsf_3_10
        DATA
??D_plsf_3_0:
        DC32     mean_lsf_3
        CFI EndBlock cfiBlock7
//  699 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock8 Using cfiCommon0
        CFI NoFunction
        THUMB
??pseudonoise??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock8
        REQUIRE pseudonoise
//  700 
//  701 
//  702 /*
//  703  * pseudonoise
//  704  *
//  705  *
//  706  * Parameters:
//  707  *    shift_reg         B: Old CN generator shift register state
//  708  *    no_bits           I: Number of bits
//  709  *
//  710  * Function:
//  711  *    pseudonoise
//  712  *
//  713  * Returns:
//  714  *    noise_bits
//  715  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock9 Using cfiCommon1
        CFI Function pseudonoise
        ARM
//  716 static Word32 pseudonoise( Word32 *shift_reg, Word32 no_bits )
//  717 {
pseudonoise:
        PUSH     {R4,R5}
        CFI R5 Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  718    Word32 noise_bits, Sn, i;
//  719    Word32 s_reg;
//  720 
//  721 
//  722    s_reg = *shift_reg;
        LDR      R3,[R0, #+0]
//  723    noise_bits = 0;
        MOV      R2,#+0
//  724 
//  725    for ( i = 0; i < no_bits; i++ ) {
        MOV      R12,#+0
        CMP      R1,#+1
        BGE      ??pseudonoise_0
        B        ??pseudonoise_1
//  726       /* State n == 31 */
//  727       Sn = s_reg & 0x00000001L;
??pseudonoise_2:
        AND      R4,R3,#0x1
//  728 
//  729       /* State n == 3 */
//  730       if ( s_reg & 0x10000000L ) {
        TST      R3,#0x10000000
//  731          Sn = Sn ^ 0x1L;
        EORNE    R4,R4,#0x1
//  732       }
//  733       else {
//  734          Sn = Sn ^ 0x0L;
//  735       }
//  736       noise_bits = ( noise_bits << 1 ) | ( s_reg & 1 );
        AND      R5,R3,#0x1
        ORR      R2,R5,R2, LSL #+1
//  737       s_reg = s_reg >> 1;
        ASR      R3,R3,#+1
//  738 
//  739       if ( Sn & 1 ) {
        TST      R4,#0x1
//  740          s_reg = s_reg | 0x40000000L;
        ORRNE    R3,R3,#0x40000000
//  741       }
//  742    }
        ADD      R12,R12,#+1
??pseudonoise_0:
        CMP      R12,R1
        BLT      ??pseudonoise_2
//  743    *shift_reg = s_reg;
??pseudonoise_1:
        STR      R3,[R0, #+0]
//  744    return noise_bits;
        POP      {R4,R5}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI CFA R13+0
        MOV      R0,R2
        BX       LR               ;; return
        CFI EndBlock cfiBlock9
//  745 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock10 Using cfiCommon0
        CFI NoFunction
        THUMB
??Reorder_lsf??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock10
        REQUIRE Reorder_lsf
//  746 
//  747 
//  748 /*
//  749  * Lsp_lsf
//  750  *
//  751  *
//  752  * Parameters:
//  753  *    lsp               I: LSP vector (range: -1<=val<1)
//  754  *    lsf               O: LSF vector Old CN generator shift register state
//  755  *
//  756  * Function:
//  757  *    Transformation lsp to lsf, LPC order M
//  758  *    lsf[i] = arccos(lsp[i])/(2*pi)
//  759  *
//  760  * Returns:
//  761  *    void
//  762  */
//  763 static void Lsp_lsf( Word32 lsp[], Word32 lsf[] )
//  764 {
//  765    Word32 i, ind = 63;   /* begin at end of table -1 */
//  766 
//  767 
//  768    for ( i = M - 1; i >= 0; i-- ) {
//  769       /* find value in table that is just greater than lsp[i] */
//  770       while ( cos_table[ind] < lsp[i] ) {
//  771          ind--;
//  772       }
//  773       lsf[i] = ( ( ( ( lsp[i] - cos_table[ind] ) * acos_slope[ind] ) + 0x800 )
//  774             >> 12 ) + ( ind << 8 );
//  775    }
//  776    return;
//  777 }
//  778 
//  779 
//  780 /*
//  781  * Reorder_lsf
//  782  *
//  783  *
//  784  * Parameters:
//  785  *    lsf            B: vector of LSFs (range: 0<=val<=0.5)
//  786  *    min_dist       I: minimum required distance
//  787  *
//  788  * Function:
//  789  *    Make sure that the LSFs are properly ordered and to keep a certain minimum
//  790  *    distance between adjacent LSFs. LPC order = M.
//  791  *
//  792  * Returns:
//  793  *    void
//  794  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock11 Using cfiCommon1
        CFI Function Reorder_lsf
        ARM
//  795 static void Reorder_lsf( Word32 *lsf, Word32 min_dist )
//  796 {
//  797    Word32 lsf_min, i;
//  798 
//  799 
//  800    lsf_min = min_dist;
Reorder_lsf:
        MOV      R2,R1
//  801 
//  802    for ( i = 0; i < M; i++ ) {
        MOV      R3,#+0
//  803       if ( lsf[i] < lsf_min ) {
??Reorder_lsf_0:
        LDR      R12,[R0, +R3, LSL #+2]
        CMP      R12,R2
//  804          lsf[i] = lsf_min;
        STRLT    R2,[R0, +R3, LSL #+2]
//  805       }
//  806       lsf_min = lsf[i] + min_dist;
        LDR      R2,[R0, +R3, LSL #+2]
//  807    }
        ADD      R3,R3,#+1
        ADD      R2,R1,R2
        CMP      R3,#+10
        BLT      ??Reorder_lsf_0
//  808 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock11

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock12 Using cfiCommon0
        CFI NoFunction
        THUMB
??Get_lsp_pol??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock12
        REQUIRE Get_lsp_pol
//  809 
//  810 /* VC5.0 Global optimization does not work with this function */
//  811 #if _MSC_VER == 1100
//  812 #pragma optimize( "g", off )
//  813 #endif
//  814 /*
//  815  * Get_lsp_pol
//  816  *
//  817  *
//  818  * Parameters:
//  819  *    lsp               I: line spectral frequencies
//  820  *    f                 O: polynomial F1(z) or F2(z)
//  821  *
//  822  * Function:
//  823  *    Find the polynomial F1(z) or F2(z) from the LSPs.
//  824  *
//  825  *    F1(z) = product ( 1 - 2 lsp[i] z^-1 + z^-2 )
//  826  *             i=0,2,4,6,8
//  827  *    F2(z) = product   ( 1 - 2 lsp[i] z^-1 + z^-2 )
//  828  *             i=1,3,5,7,9
//  829  *
//  830  *    where lsp[] is the LSP vector in the cosine domain.
//  831  *
//  832  *    The expansion is performed using the following recursion:
//  833  *
//  834  *    f[0] = 1
//  835  *    b = -2.0 * lsp[0]
//  836  *    f[1] = b
//  837  *    for i=2 to 5 do
//  838  *       b = -2.0 * lsp[2*i-2];
//  839  *       f[i] = b*f[i-1] + 2.0*f[i-2];
//  840  *       for j=i-1 down to 2 do
//  841  *          f[j] = f[j] + b*f[j-1] + f[j-2];
//  842  *       f[1] = f[1] + b;
//  843  *
//  844  * Returns:
//  845  *    void
//  846  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock13 Using cfiCommon1
        CFI Function Get_lsp_pol
        ARM
//  847 static void Get_lsp_pol( Word32 *lsp, Word32 *f )
//  848 {
Get_lsp_pol:
        PUSH     {R4-R9}
        CFI R9 Frame(CFA, -4)
        CFI R8 Frame(CFA, -8)
        CFI R7 Frame(CFA, -12)
        CFI R6 Frame(CFA, -16)
        CFI R5 Frame(CFA, -20)
        CFI R4 Frame(CFA, -24)
        CFI CFA R13+24
//  849    // volatile Word32 f0, f1, f2, f3, f4, f5;
//  850    Word32 f0, f1, f2, f3, f4, f5;
//  851    Word32 l1, l2, l3, l4;
//  852 
//  853 
//  854    /* f[0] = 1.0; */
//  855    f0 = 16777216L;
//  856 
//  857    /* f1 = *lsp * -1024; */
//  858    f1 = -lsp[0] << 10;
        LDR      R2,[R0, #+0]
//  859    l1 = lsp[2];
        LDR      R5,[R0, #+8]
//  860    l2 = lsp[4];
        LDR      R12,[R0, #+16]
        RSB      R2,R2,#+0
        LSL      R4,R2,#+10
//  861    l3 = lsp[6];
//  862    l4 = lsp[8];
//  863    f2 = f0 << 1;
//  864    f2 -= ( ( ( f1 >> 16 ) * l1 ) + ( ( ( f1 & 0xFFFE ) * l1 ) >> 16 ) ) << 2;
        MOV      R3,#+254
        ORR      R3,R3,#0xFF00
        ASR      R7,R4,#+16
        MUL      R7,R5,R7
        LDR      R2,[R0, #+24]
        LDR      R0,[R0, #+32]
        AND      R8,R3,R4
        MUL      R8,R5,R8
        MOV      R6,#+33554432
        ADD      R7,R7,R8, ASR #+16
        SUB      R6,R6,R7, LSL #+2
//  865    f1 -= l1 << 10;
//  866    f3 = f1 << 1;
//  867    f3 -= ( ( ( f2 >> 16 ) * l2 ) + ( ( ( f2 & 0xFFFE ) * l2 ) >> 16 ) ) << 2;
        ASR      R7,R6,#+16
        MUL      R7,R12,R7
        AND      R8,R3,R6
        MUL      R8,R12,R8
        SUB      R4,R4,R5, LSL #+10
        LSL      R5,R4,#+1
        ADD      R7,R7,R8, ASR #+16
        SUB      R5,R5,R7, LSL #+2
//  868    f2 += f0;
//  869    f2 -= ( ( ( f1 >> 16 ) * l2 ) + ( ( ( f1 & 0xFFFE ) * l2 ) >> 16 ) ) << 2;
        ASR      R7,R4,#+16
        MUL      R7,R12,R7
        AND      R8,R3,R4
        MUL      R8,R12,R8
//  870    f1 -= l2 << 10;
        SUB      R4,R4,R12, LSL #+10
        ADD      R7,R7,R8, ASR #+16
//  871    f4 = f2 << 1;
//  872    f4 -= ( ( ( f3 >> 16 ) * l3 ) + ( ( ( f3 & 0xFFFE ) * l3 ) >> 16 ) ) << 2;
        ASR      R8,R5,#+16
        MUL      R8,R2,R8
        AND      R12,R3,R5
        MUL      R12,R2,R12
        ADD      R6,R6,#+16777216
        SUB      R6,R6,R7, LSL #+2
        LSL      R7,R6,#+1
        ADD      R8,R8,R12, ASR #+16
        SUB      R12,R7,R8, LSL #+2
//  873    f3 += f1;
//  874    f3 -= ( ( ( f2 >> 16 ) * l3 ) + ( ( ( f2 & 0xFFFE ) * l3 ) >> 16 ) ) << 2;
        ASR      R7,R6,#+16
        MUL      R7,R2,R7
        AND      R8,R3,R6
        MUL      R8,R2,R8
        ADD      R5,R4,R5
        ADD      R7,R7,R8, ASR #+16
        SUB      R5,R5,R7, LSL #+2
//  875    f2 += f0;
//  876    f2 -= ( ( ( f1 >> 16 ) * l3 ) + ( ( ( f1 & 0xFFFE ) * l3 ) >> 16 ) ) << 2;
        ASR      R7,R4,#+16
        MUL      R7,R2,R7
        AND      R8,R3,R4
        MUL      R8,R2,R8
        ADD      R6,R6,#+16777216
        ADD      R7,R7,R8, ASR #+16
        SUB      R6,R6,R7, LSL #+2
//  877    f1 -= l3 << 10;
//  878    f5 = f3 << 1;
//  879    f5 -= ( ( ( f4 >> 16 ) * l4 ) + ( ( ( f4 & 0xFFFE ) * l4 ) >> 16 ) ) << 2;
        ASR      R7,R12,#+16
        MUL      R7,R0,R7
        AND      R8,R3,R12
        MUL      R8,R0,R8
        SUB      R2,R4,R2, LSL #+10
        LSL      R4,R5,#+1
        ADD      R7,R7,R8, ASR #+16
        SUB      R4,R4,R7, LSL #+2
//  880    f4 += f2;
//  881    f4 -= ( ( ( f3 >> 16 ) * l4 ) + ( ( ( f3 & 0xFFFE ) * l4 ) >> 16 ) ) << 2;
        ADD      R7,R6,R12
        ASR      R8,R5,#+16
        MUL      R8,R0,R8
        AND      R12,R3,R5
        MUL      R12,R0,R12
//  882    f3 += f1;
//  883    f3 -= ( ( ( f2 >> 16 ) * l4 ) + ( ( ( f2 & 0xFFFE ) * l4 ) >> 16 ) ) << 2;
//  884    f2 += f0;
//  885    f2 -= ( ( ( f1 >> 16 ) * l4 ) + ( ( ( f1 & 0xFFFE ) * l4 ) >> 16 ) ) << 2;
//  886    f1 -= l4 << 10;
//  887    f[0] = f0;
//  888    f[1] = f1;
//  889    f[2] = f2;
        AND      R9,R3,R2
        ADD      R8,R8,R12, ASR #+16
        SUB      R12,R7,R8, LSL #+2
        MOV      R7,#+16777216
        STR      R7,[R1, #+0]
        SUB      R7,R2,R0, LSL #+10
        ASR      R8,R2,#+16
        MUL      R8,R0,R8
        MUL      R9,R0,R9
//  890    f[3] = f3;
        ADD      R2,R2,R5
        ASR      R5,R6,#+16
        MUL      R5,R0,R5
        AND      R3,R3,R6
        MUL      R3,R0,R3
        STR      R7,[R1, #+4]
        ADD      R7,R6,#+16777216
        ADD      R8,R8,R9, ASR #+16
        SUB      R7,R7,R8, LSL #+2
        STR      R7,[R1, #+8]
        ADD      R0,R5,R3, ASR #+16
        SUB      R0,R2,R0, LSL #+2
        STR      R0,[R1, #+12]
//  891    f[4] = f4;
        STR      R12,[R1, #+16]
//  892    f[5] = f5;
        STR      R4,[R1, #+20]
//  893    return;
        POP      {R4-R9}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock13
//  894 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock14 Using cfiCommon0
        CFI NoFunction
        THUMB
??Lsp_Az??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock14
        REQUIRE Lsp_Az
//  895 #if _MSC_VER == 1100
//  896 #pragma optimize( "", on )
//  897 #endif
//  898 
//  899 
//  900 /*
//  901  * Lsp_Az
//  902  *
//  903  *
//  904  * Parameters:
//  905  *    lsp                 I: Line spectral frequencies
//  906  *    a                   O: Predictor coefficients
//  907  *
//  908  * Function:
//  909  *    Converts from the line spectral pairs (LSP) to LP coefficients,
//  910  *    for a 10th order filter.
//  911  *
//  912  *    Find the coefficients of F1(z) and F2(z)
//  913  *    Multiply F1(z) by 1+z^{-1} and F2(z) by 1-z^{-1}
//  914  *    A(z) = ( F1(z) + F2(z) ) / 2
//  915  *
//  916  * Returns:
//  917  *    void
//  918  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock15 Using cfiCommon1
        CFI Function Lsp_Az
        ARM
//  919 static void Lsp_Az( Word32 lsp[], Word32 a[] )
//  920 {
Lsp_Az:
        PUSH     {R4,R5,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R5 Frame(CFA, -8)
        CFI R4 Frame(CFA, -12)
        CFI CFA R13+12
        SUB      SP,SP,#+48
        CFI CFA R13+60
        MOV      R4,R1
        MOV      R5,R0
//  921    Word32 f1[6], f2[6];
//  922    Word32 T0, i, j;
//  923 
//  924 
//  925    Get_lsp_pol( &lsp[0], f1 );
        MOV      R1,SP
        BL       Get_lsp_pol
//  926    Get_lsp_pol( &lsp[1], f2 );
        ADD      R1,SP,#+24
        ADD      R0,R5,#+4
        BL       Get_lsp_pol
//  927 
//  928    for ( i = 5; i > 0; i-- ) {
        MOV      R0,#+5
//  929       f1[i] += f1[i - 1];
??Lsp_Az_0:
        MOV      R1,SP
        ADD      R1,R1,R0, LSL #+2
        LDR      R2,[R1, #+0]
        LDR      R3,[R1, #-4]
        ADD      R2,R3,R2
        STR      R2,[R1, #+0]
//  930       f2[i] -= f2[i - 1];
        ADD      R1,SP,#+24
        ADD      R1,R1,R0, LSL #+2
        LDR      R2,[R1, #+0]
        LDR      R3,[R1, #-4]
//  931    }
        SUB      R0,R0,#+1
        SUB      R2,R2,R3
        STR      R2,[R1, #+0]
        CMP      R0,#+1
        BGE      ??Lsp_Az_0
//  932    a[0] = 4096;
        MOV      R0,#+4096
        STR      R0,[R4, #+0]
//  933 
//  934    for ( i = 1, j = 10; i <= 5; i++, j-- ) {
        MOV      R0,#+1
        MOV      R1,#+10
//  935       T0 = f1[i] + f2[i];
??Lsp_Az_1:
        ADD      R2,SP,#+24
        ADD      R2,R2,R0, LSL #+2
        LDR      R12,[R2, #+0]
        MOV      R3,SP
        ADD      R3,R3,R0, LSL #+2
        LDR      R5,[R3, #+0]
        ADD      R5,R12,R5
//  936       a[i] = (Word16)(T0 >> 13);  /* emulate fixed point bug */
        ASR      R12,R5,#+13
        MOV      R12,R12, LSL #+16
        MOV      R12,R12, ASR #+16
        STR      R12,[R4, +R0, LSL #+2]
//  937       if ( ( T0 & 4096 ) != 0 ) {
        TST      R5,#0x1000
//  938          a[i]++;
        LDRNE    R5,[R4, +R0, LSL #+2]
        ADDNE    R5,R5,#+1
        STRNE    R5,[R4, +R0, LSL #+2]
//  939       }
//  940       T0 = f1[i] - f2[i];
        LDR      R3,[R3, #+0]
        LDR      R2,[R2, #+0]
//  941       a[j] = (Word16)(T0 >> 13);   /* emulate fixed point bug */
//  942 
//  943       if ( ( T0 & 4096 ) != 0 ) {
//  944          a[j]++;
//  945       }
//  946    }
        ADD      R0,R0,#+1
        SUB      R2,R3,R2
        ASR      R3,R2,#+13
        MOV      R3,R3, LSL #+16
        MOV      R3,R3, ASR #+16
        STR      R3,[R4, +R1, LSL #+2]
        TST      R2,#0x1000
        LDRNE    R2,[R4, +R1, LSL #+2]
        ADDNE    R2,R2,#+1
        STRNE    R2,[R4, +R1, LSL #+2]
        SUB      R1,R1,#+1
        CMP      R0,#+6
        BLT      ??Lsp_Az_1
//  947    return;
        ADD      SP,SP,#+48       ;; stack cleaning
        CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
        CFI EndBlock cfiBlock15
//  948 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock16 Using cfiCommon0
        CFI NoFunction
        THUMB
??A_Refl??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock16
        REQUIRE A_Refl
//  949 
//  950 
//  951 /*
//  952  * A_Refl
//  953  *
//  954  *
//  955  * Parameters:
//  956  *    a                 I: Directform coefficients
//  957  *    refl              O: Reflection coefficients
//  958  *
//  959  * Function:
//  960  *    Converts from the directform coefficients to reflection coefficients
//  961  *
//  962  * Returns:
//  963  *    void
//  964  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock17 Using cfiCommon1
        CFI Function A_Refl
        ARM
//  965 static void A_Refl( Word32 a[], Word32 refl[] )
//  966 {
A_Refl:
        PUSH     {R4-R6,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
        SUB      SP,SP,#+80
        CFI CFA R13+96
        MOV      R4,R1
//  967    /* local variables */
//  968    int normShift;
//  969    Word32 aState[M], bState[M];
//  970    Word32 normProd, acc, temp, mult, scale, i, j;
//  971 
//  972 
//  973    /* initialize states */
//  974    memcpy( aState, a, M <<2 );
        MOV      R2,#+40
        MOV      R1,R0
        MOV      R0,SP
        SWI      +286
//  975 
//  976    /* backward Levinson recursion */
//  977    for ( i = M - 1; i >= 0; i-- ) {
        MOV      R5,#+9
        B        ??A_Refl_0
//  978       if ( labs( aState[i] ) >= 4096 ) {
//  979          goto ExitRefl;
//  980       }
//  981       refl[i] = aState[i] << 3;
//  982       temp = ( refl[i] * refl[i] ) << 1;
//  983       acc = ( MAX_32 - temp );
//  984       normShift=0;
//  985       if (acc != 0){
//  986          temp = acc;
//  987          while (!(temp & 0x40000000))
//  988          {
//  989             normShift++;
//  990             temp = temp << 1;
//  991          }
//  992       }
//  993       else{
//  994          normShift = 0;
//  995       }
//  996       scale = 15 - normShift;
//  997       acc = ( acc << normShift );
//  998       temp = ( acc + ( Word32 )0x00008000L );
//  999 
// 1000       if ( temp > 0 ) {
// 1001          normProd = temp >> 16;
// 1002          mult = 0x20000000L / normProd;
// 1003       }
// 1004       else
// 1005          mult = 16384;
// 1006 
// 1007       for ( j = 0; j < i; j++ ) {
// 1008          acc = aState[j] << 16;
// 1009          acc -= ( refl[i] * aState[i - j - 1] ) << 1;
// 1010          temp = ( acc + ( Word32 )0x00008000L ) >> 16;
// 1011          temp = ( mult * temp ) << 1;
// 1012 
// 1013          if ( scale > 0 ) {
// 1014             if ( ( temp & ( ( Word32 )1 << ( scale - 1 ) ) ) != 0 ) {
// 1015                temp = ( temp >> scale ) + 1;
// 1016             }
// 1017             else
// 1018                temp = ( temp >> scale );
// 1019          }
// 1020          else
// 1021             temp = ( temp >> scale );
// 1022 
// 1023          if ( labs( temp ) > 32767 ) {
// 1024             goto ExitRefl;
// 1025          }
// 1026          bState[j] = temp;
// 1027       }
// 1028       memcpy( aState, bState, i <<2 );
??A_Refl_1:
        LSL      R2,R5,#+2
        ADD      R1,SP,#+40
        MOV      R0,SP
        SWI      +286
        SUBS     R5,R5,#+1
        BMI      ??A_Refl_2
??A_Refl_0:
        MOV      R0,SP
        LDR      R0,[R0, +R5, LSL #+2]
        CMP      R0,#+0
        MOV      R1,R0
        RSBMI    R1,R1,#+0
        CMP      R1,#+4096
        BGE      ??A_Refl_3
        LSL      R0,R0,#+3
        STR      R0,[R4, +R5, LSL #+2]
        LDR      R1,[R4, +R5, LSL #+2]
        MVN      R0,#-2147483648
        MOV      R2,R1
        MUL      R1,R2,R1
        SUBS     R0,R0,R1, LSL #+1
        MOV      R1,#+0
        BEQ      ??A_Refl_4
        MOV      R3,R0
        TST      R3,#0x40000000
        BNE      ??A_Refl_4
??A_Refl_5:
        ADD      R1,R1,#+1
        LSL      R3,R3,#+1
        TST      R3,#0x40000000
        BEQ      ??A_Refl_5
??A_Refl_4:
        RSB      R2,R1,#+15
        MOV      R3,#+32768
        ADD      R3,R3,R0, LSL R1
        CMP      R3,#+1
        BLT      ??A_Refl_6
        MOV      R0,#+536870912
        ASR      R1,R3,#+16
        _BLF     ??div32_a,??rA??div32_a
        B        ??A_Refl_7
??A_Refl_6:
        MOV      R1,#+16384
??A_Refl_7:
        MOV      R0,#+0
        B        ??A_Refl_8
??A_Refl_9:
        CMP      R12,#+32768
        BGE      ??A_Refl_3
        ADD      R12,SP,#+40
        STR      R3,[R12, +R0, LSL #+2]
        ADD      R0,R0,#+1
??A_Refl_8:
        CMP      R0,R5
        BGE      ??A_Refl_1
        LDR      R12,[R4, +R5, LSL #+2]
        SUB      LR,R5,R0
        MOV      R6,SP
        ADD      R6,R6,LR, LSL #+2
        LDR      R6,[R6, #-4]
        MOV      R3,SP
        LDR      R3,[R3, +R0, LSL #+2]
        MUL      R12,R6,R12
        LSL      R3,R3,#+16
        SUB      R3,R3,R12, LSL #+1
        ADD      R3,R3,#+32768
        ASR      R3,R3,#+16
        MUL      R6,R3,R1
        CMP      R2,#+1
        LSL      R12,R6,#+1
        ASR      R3,R12,R2
        BLT      ??A_Refl_10
        MOV      R6,#+1
        SUB      LR,R2,#+1
        TST      R12,R6, LSL LR
        ADDNE    R3,R3,#+1
??A_Refl_10:
        CMP      R3,#+0
        MOVPL    R12,R3
        RSBMI    R12,R3,#+0
        B        ??A_Refl_9
// 1029    }
// 1030    return;
// 1031 ExitRefl:
// 1032    memset( refl, 0, M <<2 );
??A_Refl_3:
        MOV      R2,#+40
        MOV      R1,#+0
        MOV      R0,R4
        SWI      +187
// 1033 }
??A_Refl_2:
        ADD      SP,SP,#+80       ;; stack cleaning
        CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
        CFI EndBlock cfiBlock17

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock18 Using cfiCommon0
        CFI NoFunction
        THUMB
??Log2??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock18
        REQUIRE Log2
// 1034 
// 1035 
// 1036 /*
// 1037  * Log2_norm
// 1038  *
// 1039  *
// 1040  * Parameters:
// 1041  *    x                 I: input value
// 1042  *    exp               I: exponent
// 1043  *    exponent          O: Integer part of Log2. (range: 0<=val<=30)
// 1044  *    fraction          O: Fractional part of Log2. (range: 0<=val<1)
// 1045  *
// 1046  * Function:
// 1047  *    Computes log2
// 1048  *
// 1049  *    Computes log2(L_x, exp),  where   L_x is positive and
// 1050  *    normalized, and exp is the normalisation exponent
// 1051  *    If L_x is negative or zero, the result is 0.
// 1052  *
// 1053  *    The function Log2(L_x) is approximated by a table and linear
// 1054  *    interpolation. The following steps are used to compute Log2(L_x)
// 1055  *
// 1056  *    exponent = 30-normExponent
// 1057  *    i = bit25-b31 of L_x;  32<=i<=63  (because of normalization).
// 1058  *    a = bit10-b24
// 1059  *    i -=32
// 1060  *    fraction = table[i]<<16 - (table[i] - table[i+1]) * a * 2
// 1061  *
// 1062  * Returns:
// 1063  *    void
// 1064  */
// 1065 static void Log2_norm( Word32 x, Word32 exp, Word32 *exponent, Word32 *
// 1066       fraction )
// 1067 {
// 1068    Word32 y, i, a;
// 1069 
// 1070 
// 1071    if ( x <= 0 ) {
// 1072       *exponent = 0;
// 1073       *fraction = 0;
// 1074       return;
// 1075    }
// 1076 
// 1077    /* Extract b25-b31 */
// 1078    i = x >> 25;
// 1079    i = i - 32;
// 1080 
// 1081    /* Extract b10-b24 of fraction */
// 1082    a = x >> 9;
// 1083    a = a & 0xFFFE;   /* 2a */
// 1084 
// 1085    /* fraction */
// 1086    y = ( log2_table[i] << 16 ) - a * ( log2_table[i] - log2_table[i + 1] );
// 1087    *fraction = y >> 16;
// 1088    *exponent = 30 - exp;
// 1089    return;
// 1090 }
// 1091 
// 1092 
// 1093 /*
// 1094  * Log2
// 1095  *
// 1096  *
// 1097  * Parameters:
// 1098  *    x                 I: input value
// 1099  *    exponent          O: Integer part of Log2. (range: 0<=val<=30)
// 1100  *    fraction          O: Fractional part of Log2. (range: 0<=val<1)
// 1101  *
// 1102  * Function:
// 1103  *    Computes log2(L_x)
// 1104  *    If x is negative or zero, the result is 0.
// 1105  *
// 1106  * Returns:
// 1107  *    void
// 1108  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock19 Using cfiCommon1
        CFI Function Log2
        ARM
// 1109 static void Log2( Word32 x, Word32 *exponent, Word32 *fraction )
// 1110 {
Log2:
        PUSH     {R4-R6}
        CFI R6 Frame(CFA, -4)
        CFI R5 Frame(CFA, -8)
        CFI R4 Frame(CFA, -12)
        CFI CFA R13+12
// 1111    int tmp, exp=0;
        MOV      R3,#+0
// 1112 
// 1113    if (x != 0){
        CMP      R0,#+0
        BEQ      ??Log2_0
// 1114          tmp = x;
        MOV      R12,R0
        B        ??Log2_1
// 1115          while (!((tmp & 0x80000000) ^ ((tmp & 0x40000000) << 1)))
// 1116          {
// 1117             exp++;
??Log2_2:
        ADD      R3,R3,#+1
// 1118             tmp = tmp << 1;
        LSL      R12,R12,#+1
// 1119          }
??Log2_1:
        AND      R4,R12,#0x80000000
        AND      R5,R12,#0x40000000
        EORS     R4,R4,R5, LSL #+1
        BEQ      ??Log2_2
// 1120       }
// 1121    Log2_norm( x <<exp, exp, exponent, fraction );
??Log2_0:
        LSL      R0,R0,R3
        CMP      R0,#+1
        BGE      ??Log2_3
        MOV      R0,#+0
        STR      R0,[R1, #+0]
        STR      R0,[R2, #+0]
        B        ??Log2_4
??Log2_3:
        ASR      R4,R0,#+25
        SUB      R12,R4,#+32
        LDR      R4,??DataTable1  ;; log2_table
        MOV      R6,#+254
        LDR      R5,[R4, +R12, LSL #+2]
        ORR      R6,R6,#0xFF00
        AND      R0,R6,R0, ASR #+9
        ADD      R6,R4,R12, LSL #+2
        LDR      R6,[R6, #+4]
        SUB      R4,R6,R5
        MUL      R0,R4,R0
        ADD      R0,R0,R5, LSL #+16
        ASR      R0,R0,#+16
        STR      R0,[R2, #+0]
        RSB      R0,R3,#+30
        STR      R0,[R1, #+0]
// 1122 }
??Log2_4:
        POP      {R4-R6}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock19

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable1:
        DC32     log2_table

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock20 Using cfiCommon0
        CFI NoFunction
        THUMB
??Pow2??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock20
        REQUIRE Pow2
// 1123 
// 1124 
// 1125 /*
// 1126  * Pow2
// 1127  *
// 1128  *
// 1129  * Parameters:
// 1130  *    exponent          I: Integer part. (range: 0<=val<=30)
// 1131  *    fraction          O: Fractional part. (range: 0.0<=val<1.0)
// 1132  *
// 1133  * Function:
// 1134  *    pow(2.0, exponent.fraction)
// 1135  *
// 1136  *    The function Pow2(L_x) is approximated by a table and linear interpolation.
// 1137  *
// 1138  *    i = bit10-b15 of fraction, 0 <= i <= 31
// 1139  *    a = biT0-b9   of fraction
// 1140  *    x = table[i]<<16 - (table[i] - table[i+1]) * a * 2
// 1141  *    x = L_x >> (30-exponent) (with rounding)
// 1142  *
// 1143  * Returns:
// 1144  *    result (range: 0<=val<=0x7fffffff)
// 1145  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock21 Using cfiCommon1
        CFI Function Pow2
        ARM
// 1146 static Word32 Pow2( Word32 exponent, Word32 fraction )
// 1147 {
// 1148    Word32 i, a, tmp, x, exp;
// 1149 
// 1150 
// 1151    /* Extract b10-b16 of fraction */
// 1152    i = fraction >> 10;
// 1153 
// 1154    /* Extract b0-b9 of fraction */
// 1155    a = ( fraction << 5 ) & 0x7fff;
// 1156 
// 1157    /* table[i] << 16 */
// 1158    x = pow2_table[i] << 16;
// 1159 
// 1160    /* table[i] - table[i+1] */
// 1161    tmp = pow2_table[i] - pow2_table[i + 1];
// 1162 
// 1163    /* L_x -= tmp*a*2 */
// 1164    x -= ( tmp * a ) << 1;
Pow2:
        LDR      R3,??Pow2_0      ;; pow2_table
        PUSH     {R4}
        CFI R4 Frame(CFA, -4)
        CFI CFA R13+4
        ASR      R2,R1,#+10
        LDR      R12,[R3, +R2, LSL #+2]
        ADD      R2,R3,R2, LSL #+2
        LDR      R2,[R2, #+4]
        LSL      R1,R1,#+5
        SUB      R2,R12,R2
        LSL      R1,R1,#+17
        LSR      R1,R1,#+17
        MUL      R2,R1,R2
        LSL      R4,R12,#+16
        SUB      R1,R4,R2, LSL #+1
// 1165 
// 1166    if ( exponent >= -1 ) {
        CMN      R0,#+1
        BLT      ??Pow2_1
// 1167       exp = ( 30 - exponent );
// 1168 
// 1169       /* Rounding */
// 1170       if ( ( x & ( ( Word32 )1 << ( exp - 1 ) ) ) != 0 ) {
// 1171          x = ( x >> exp ) + 1;
        POP      {R4}
        CFI R4 SameValue
        CFI CFA R13+0
        RSB      R0,R0,#+30
        MOV      R2,#+1
        SUB      R3,R0,#+1
        TST      R1,R2, LSL R3
        ADDNE    R0,R2,R1, ASR R0
        ASREQ    R0,R1,R0
        BX       LR
        CFI R4 Frame(CFA, -4)
        CFI CFA R13+4
// 1172       }
// 1173       else
// 1174          x = x >> exp;
// 1175    }
// 1176    else
// 1177       x = 0;
// 1178    return( x );
??Pow2_1:
        POP      {R4}
        CFI R4 SameValue
        CFI CFA R13+0
        MOV      R0,#+0
        BX       LR               ;; return
        DATA
??Pow2_0:
        DC32     pow2_table
        CFI EndBlock cfiBlock21
// 1179 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock22 Using cfiCommon0
        CFI NoFunction
        THUMB
??Build_CN_param??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock22
        REQUIRE Build_CN_param
// 1180 
// 1181 
// 1182 /*
// 1183  * Build_CN_code
// 1184  *
// 1185  *
// 1186  * Parameters:
// 1187  *    seed              B: Old CN generator shift register state
// 1188  *    cod               O: Generated CN fixed codebook vector
// 1189  *
// 1190  * Function:
// 1191  *    Generate CN fixed codebook vector
// 1192  *
// 1193  * Returns:
// 1194  *    void
// 1195  */
// 1196 static void Build_CN_code( Word32 *seed, Word32 cod[] )
// 1197 {
// 1198    Word32 i, j, k;
// 1199 
// 1200 
// 1201    memset( cod, 0, L_SUBFR <<2 );
// 1202 
// 1203    for ( k = 0; k < 10; k++ ) {
// 1204       i = pseudonoise( seed, 2 );   /* generate pulse position */
// 1205       i = ( i * 20 ) >> 1;
// 1206       i = ( i + k );
// 1207       j = pseudonoise( seed, 1 );   /* generate sign           */
// 1208 
// 1209       if ( j > 0 ) {
// 1210          cod[i] = 4096;
// 1211       }
// 1212       else {
// 1213          cod[i] = -4096;
// 1214       }
// 1215    }
// 1216    return;
// 1217 }
// 1218 
// 1219 
// 1220 /*
// 1221  * Build_CN_param
// 1222  *
// 1223  *
// 1224  * Parameters:
// 1225  *    seed              B: Old CN generator shift register state
// 1226  *    nParam            I: number of params
// 1227  *    paramSizeTable    I: size of params
// 1228  *    parm              O: CN Generated params
// 1229  *
// 1230  * Function:
// 1231  *    Generate parameters for comfort noise generation
// 1232  *
// 1233  * Returns:
// 1234  *    void
// 1235  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock23 Using cfiCommon1
        CFI Function Build_CN_param
        ARM
// 1236 static void Build_CN_param( Word16 *seed, enum Mode mode, Word16 parm[] )
// 1237 {
Build_CN_param:
        PUSH     {R4-R6}
        CFI R6 Frame(CFA, -4)
        CFI R5 Frame(CFA, -8)
        CFI R4 Frame(CFA, -12)
        CFI CFA R13+12
// 1238    Word32 i;
// 1239    const Word32 *p;
// 1240 
// 1241 
// 1242    *seed = ( Word16 )( ( *seed * 31821 ) + 13849L );
        LDRSH    R3,[R0, #+0]
        MOV      R4,#+77
        ORR      R4,R4,#0x7C00
        MOV      R12,#+25
        ORR      R12,R12,#0x3600
        MLA      R3,R4,R3,R12
// 1243    p = &window_200_40[ * seed & 0x7F];
        LDR      R4,??Build_CN_param_1  ;; bitno_MR475
        STRH     R3,[R0, #+0]
        LDRSH    R0,[R0, #+0]
// 1244 
// 1245    switch ( mode ) {
        LDR      R3,??Build_CN_param_1+0x4  ;; bitno_MR102
        MOV      R12,#+255
        AND      R0,R0,#0x7F
        ADD      R0,R4,R0, LSL #+2
        ADD      R0,R0,#+244
        ORR      R12,R12,#0xFF00
        CMP      R1,#+7
        BHI      ??Build_CN_param_2
        ADR      R5,??Build_CN_param_0
        LDRB     R5,[R5, R1]
        ADD      PC,PC,R5, LSL #+2
        DATA
??Build_CN_param_0:
        DC8      +85,+73,+61,+49
        DC8      +37,+25,+13,+1
        ARM
// 1246       case MR122:
// 1247          for ( i = 0; i < PRMNO_MR122; i++ ) {
??Build_CN_param_3:
        MOV      R1,#+0
// 1248             parm[i] = ( Word16 )( *p++ & ~( 0xFFFF << bitno_MR122[i] ) );
??Build_CN_param_4:
        LDR      R5,[R0], #+4
        ADD      R6,R3,R1, LSL #+1
        LDRSH    R6,[R6, #+80]
        ADD      R4,R2,R1, LSL #+1
// 1249          }
        ADD      R1,R1,#+1
        LSL      R6,R12,R6
        BIC      R5,R5,R6
        STRH     R5,[R4, #+0]
        CMP      R1,#+57
        BGE      ??Build_CN_param_2
        B        ??Build_CN_param_4
// 1250          break;
// 1251 
// 1252       case MR102:
// 1253          for ( i = 0; i < PRMNO_MR102; i++ ) {
??Build_CN_param_5:
        MOV      R1,#+0
// 1254             parm[i] = ( Word16 )( *p++ & ~( 0xFFFF << bitno_MR102[i] ) );
??Build_CN_param_6:
        LDR      R5,[R0], #+4
        ADD      R6,R3,R1, LSL #+1
        LDRSH    R6,[R6, #+0]
        ADD      R4,R2,R1, LSL #+1
// 1255          }
        ADD      R1,R1,#+1
        LSL      R6,R12,R6
        BIC      R5,R5,R6
        STRH     R5,[R4, #+0]
        CMP      R1,#+39
        BGE      ??Build_CN_param_2
        B        ??Build_CN_param_6
// 1256          break;
// 1257 
// 1258       case MR795:
// 1259          for ( i = 0; i < PRMNO_MR795; i++ ) {
??Build_CN_param_7:
        MOV      R1,#+0
// 1260             parm[i] = ( Word16 )( *p++ & ~( 0xFFFF << bitno_MR795[i] ) );
??Build_CN_param_8:
        LDR      R5,[R0], #+4
        ADD      R6,R4,R1, LSL #+1
        LDRSH    R6,[R6, #+196]
        ADD      R3,R2,R1, LSL #+1
// 1261          }
        ADD      R1,R1,#+1
        LSL      R6,R12,R6
        BIC      R5,R5,R6
        STRH     R5,[R3, #+0]
        CMP      R1,#+23
        BGE      ??Build_CN_param_2
        B        ??Build_CN_param_8
// 1262          break;
// 1263 
// 1264       case MR74:
// 1265          for ( i = 0; i < PRMNO_MR74; i++ ) {
??Build_CN_param_9:
        MOV      R1,#+0
// 1266             parm[i] = ( Word16 )( *p++ & ~( 0xFFFF << bitno_MR74[i] ) );
??Build_CN_param_10:
        LDR      R5,[R0], #+4
        ADD      R6,R4,R1, LSL #+1
        LDRSH    R6,[R6, #+156]
        ADD      R3,R2,R1, LSL #+1
// 1267          }
        ADD      R1,R1,#+1
        LSL      R6,R12,R6
        BIC      R5,R5,R6
        STRH     R5,[R3, #+0]
        CMP      R1,#+19
        BGE      ??Build_CN_param_2
        B        ??Build_CN_param_10
// 1268          break;
// 1269 
// 1270       case MR67:
// 1271          for ( i = 0; i < PRMNO_MR67; i++ ) {
??Build_CN_param_11:
        MOV      R1,#+0
// 1272             parm[i] = ( Word16 )( *p++ & ~( 0xFFFF << bitno_MR67[i] ) );
??Build_CN_param_12:
        LDR      R5,[R0], #+4
        ADD      R6,R4,R1, LSL #+1
        LDRSH    R6,[R6, #+116]
        ADD      R3,R2,R1, LSL #+1
// 1273          }
        ADD      R1,R1,#+1
        LSL      R6,R12,R6
        BIC      R5,R5,R6
        STRH     R5,[R3, #+0]
        CMP      R1,#+19
        BGE      ??Build_CN_param_2
        B        ??Build_CN_param_12
// 1274          break;
// 1275 
// 1276       case MR59:
// 1277          for ( i = 0; i < PRMNO_MR59; i++ ) {
??Build_CN_param_13:
        MOV      R1,#+0
// 1278             parm[i] = ( Word16 )( *p++ & ~( 0xFFFF << bitno_MR59[i] ) );
??Build_CN_param_14:
        LDR      R5,[R0], #+4
        ADD      R6,R4,R1, LSL #+1
        LDRSH    R6,[R6, #+76]
        ADD      R3,R2,R1, LSL #+1
// 1279          }
        ADD      R1,R1,#+1
        LSL      R6,R12,R6
        BIC      R5,R5,R6
        STRH     R5,[R3, #+0]
        CMP      R1,#+19
        BGE      ??Build_CN_param_2
        B        ??Build_CN_param_14
// 1280          break;
// 1281 
// 1282       case MR515:
// 1283          for ( i = 0; i < PRMNO_MR515; i++ ) {
??Build_CN_param_15:
        MOV      R1,#+0
// 1284             parm[i] = ( Word16 )( *p++ & ~( 0xFFFF << bitno_MR515[i] ) );
??Build_CN_param_16:
        LDR      R5,[R0], #+4
        ADD      R6,R4,R1, LSL #+1
        LDRSH    R6,[R6, #+36]
        ADD      R3,R2,R1, LSL #+1
// 1285          }
        ADD      R1,R1,#+1
        LSL      R6,R12,R6
        BIC      R5,R5,R6
        STRH     R5,[R3, #+0]
        CMP      R1,#+19
        BGE      ??Build_CN_param_2
        B        ??Build_CN_param_16
// 1286          break;
// 1287 
// 1288       case MR475:
// 1289          for ( i = 0; i < PRMNO_MR475; i++ ) {
??Build_CN_param_17:
        MOV      R1,#+0
// 1290             parm[i] = ( Word16 )( *p++ & ~( 0xFFFF << bitno_MR475[i] ) );
??Build_CN_param_18:
        LDR      R5,[R0], #+4
        ADD      R6,R4,R1, LSL #+1
        LDRSH    R6,[R6, #+0]
        ADD      R3,R2,R1, LSL #+1
// 1291          }
        ADD      R1,R1,#+1
        LSL      R6,R12,R6
        BIC      R5,R5,R6
        STRH     R5,[R3, #+0]
        CMP      R1,#+17
        BLT      ??Build_CN_param_18
// 1292          break;
// 1293    }
// 1294 }
??Build_CN_param_2:
        POP      {R4-R6}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        DATA
??Build_CN_param_1:
        DC32     bitno_MR475
        DC32     bitno_MR102
        CFI EndBlock cfiBlock23

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock24 Using cfiCommon0
        CFI NoFunction
        THUMB
??Syn_filt??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock24
        REQUIRE Syn_filt
// 1295 
// 1296 
// 1297 /*
// 1298  * Syn_filt
// 1299  *
// 1300  *
// 1301  * Parameters:
// 1302  *    a                 I: prediction coefficients [M+1]
// 1303  *    x                 I: input signal
// 1304  *    y                 O: output signal
// 1305  *    lg                I: size of filtering
// 1306  *    mem               B: memory associated with this filtering
// 1307  *    update            I: 0=no update, 1=update of memory.
// 1308  *
// 1309  * Function:
// 1310  *    Perform synthesis filtering through 1/A(z).
// 1311  *
// 1312  * Returns:
// 1313  *    void
// 1314  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock25 Using cfiCommon1
        CFI Function Syn_filt
        ARM
// 1315 static Word32 Syn_filt( Word32 a[], Word32 x[], Word32 y[], Word32 lg, Word32 mem[]
// 1316       , Word32 update )
// 1317 {
Syn_filt:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
        SUB      SP,SP,#+200
        CFI CFA R13+236
        LDR      R8,[SP, #+236]
        LDR      R9,[SP, #+240]
        MOV      R4,R0
        MOV      R5,R1
        MOV      R6,R2
        MOV      R7,R3
// 1318    Word32 tmp[50];   /* malloc is slow */
// 1319    Word32 s, a0, overflow = 0;
        MOV      R10,#+0
// 1320    Word32 *yy, *yy_limit;
// 1321 
// 1322 
// 1323    /* Copy mem[] to yy[] */
// 1324    memcpy( tmp, mem, 40 );
        MOV      R2,#+40
        MOV      R1,R8
        MOV      R0,SP
        SWI      +286
// 1325    yy = tmp + M;
// 1326    yy_limit = yy + lg;
// 1327    a0 = a[0];
        LDR      R1,[R4, #+0]
        ADD      R2,SP,#+40
        MOV      R0,SP
        ADD      R0,R0,R7, LSL #+2
        ADD      R0,R0,#+40
        ADD      R3,SP,#+40
        CMP      R3,R0
        BCC      ??Syn_filt_0
// 1328 
// 1329    /* Do the filtering. */
// 1330    while ( yy < yy_limit ) {
// 1331 
// 1332       s = *x++ * a0;
// 1333       s -= yy[-1] * a[1];
// 1334       s -= yy[-2] * a[2];
// 1335       s -= yy[-3] * a[3];
// 1336       s -= yy[-4] * a[4];
// 1337       s -= yy[-5] * a[5];
// 1338       s -= yy[-6] * a[6];
// 1339       s -= yy[-7] * a[7];
// 1340       s -= yy[-8] * a[8];
// 1341       s -= yy[-9] * a[9];
// 1342       s -= yy[-10] * a[10];
// 1343       if ( labs( s ) < 0x7ffffff )
// 1344          *yy = ( s + 0x800L ) >> 12;
// 1345       else if ( s > 0 ) {
// 1346          *yy = 32767;
// 1347          overflow = 1;
// 1348       }
// 1349       else {
// 1350          *yy = -32768;
// 1351          overflow = 1;
// 1352       }
// 1353       yy++;
// 1354    }
// 1355    memcpy( y, &tmp[M], lg <<2 );
??Syn_filt_1:
        LSL      R2,R7,#+2
        ADD      R1,SP,#+40
        MOV      R0,R6
        SWI      +286
// 1356 
// 1357    /* Update of memory if update==1 */
// 1358    if ( update ) {
        CMP      R9,#+0
        BEQ      ??Syn_filt_2
// 1359       memcpy( mem, &y[lg - M], 40 );
        MOV      R2,#+40
        ADD      R0,R6,R7, LSL #+2
        SUB      R1,R0,#+40
        MOV      R0,R8
        SWI      +286
// 1360    }
// 1361    return overflow;
??Syn_filt_2:
        MOV      R0,R10
        ADD      SP,SP,#+200
        CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        CFI CFA R13+236
??Syn_filt_3:
        STR      R3,[R2, #+0]
        MOV      R10,#+1
??Syn_filt_4:
        ADD      R2,R2,#+4
??Syn_filt_0:
        CMP      R2,R0
        BCS      ??Syn_filt_1
        LDR      R3,[R5], #+4
        LDR      R12,[R4, #+4]
        MUL      LR,R1,R3
        SUB      R3,R2,#+40
        LDR      R11,[R3, #+36]
        MUL      R11,R12,R11
        LDR      R12,[R4, #+8]
        SUB      LR,LR,R11
        LDR      R11,[R3, #+32]
        MUL      R11,R12,R11
        LDR      R12,[R4, #+12]
        SUB      LR,LR,R11
        LDR      R11,[R3, #+28]
        MUL      R11,R12,R11
        LDR      R12,[R4, #+16]
        SUB      LR,LR,R11
        LDR      R11,[R3, #+24]
        MUL      R11,R12,R11
        LDR      R12,[R4, #+20]
        SUB      LR,LR,R11
        LDR      R11,[R3, #+20]
        MUL      R11,R12,R11
        LDR      R12,[R4, #+24]
        SUB      LR,LR,R11
        LDR      R11,[R3, #+16]
        MUL      R11,R12,R11
        LDR      R12,[R4, #+28]
        SUB      LR,LR,R11
        LDR      R11,[R3, #+12]
        MUL      R11,R12,R11
        LDR      R12,[R4, #+32]
        SUB      LR,LR,R11
        LDR      R11,[R3, #+8]
        MUL      R11,R12,R11
        LDR      R12,[R4, #+36]
        SUB      LR,LR,R11
        LDR      R11,[R3, #+4]
        LDR      R3,[R3, #+0]
        MUL      R11,R12,R11
        SUB      R12,LR,R11
        LDR      R11,[R4, #+40]
        MUL      R3,R11,R3
        MVN      R11,#-134217728
        SUBS     R3,R12,R3
        RSBMI    R12,R3,#+0
        MOVPL    R12,R3
        CMP      R12,R11
        BGE      ??Syn_filt_5
        ADD      R3,R3,#+2048
        ASR      R3,R3,#+12
        STR      R3,[R2, #+0]
        B        ??Syn_filt_4
??Syn_filt_5:
        CMP      R3,#+1
        MVNLT    R3,#+255
        BICLT    R3,R3,#0x7F00
        MOVGE    R3,R11, LSR #+12
        B        ??Syn_filt_3
        CFI EndBlock cfiBlock25
// 1362 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock26 Using cfiCommon0
        CFI NoFunction
        THUMB
??Syn_filt_overflow??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock26
        REQUIRE Syn_filt_overflow
// 1363 
// 1364 /*
// 1365  * Syn_filt_overflow
// 1366  *
// 1367  *
// 1368  * Parameters:
// 1369  *    a                 I: prediction coefficients [M+1]
// 1370  *    x                 I: input signal
// 1371  *    y                 O: output signal
// 1372  *    lg                I: size of filtering
// 1373  *    mem               B: memory associated with this filtering
// 1374  *    update            I: 0=no update, 1=update of memory.
// 1375  *
// 1376  * Function:
// 1377  *    Perform synthesis filtering through 1/A(z).
// 1378  *    Saturate after every multiplication.
// 1379  * Returns:
// 1380  *    void
// 1381  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock27 Using cfiCommon1
        CFI Function Syn_filt_overflow
        ARM
// 1382 static void Syn_filt_overflow( Word32 a[], Word32 x[], Word32 y[], Word32 lg, Word32 mem[]
// 1383       , Word32 update )
// 1384 {
Syn_filt_overflow:
        PUSH     {R4-R10,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R10 Frame(CFA, -8)
        CFI R9 Frame(CFA, -12)
        CFI R8 Frame(CFA, -16)
        CFI R7 Frame(CFA, -20)
        CFI R6 Frame(CFA, -24)
        CFI R5 Frame(CFA, -28)
        CFI R4 Frame(CFA, -32)
        CFI CFA R13+32
        SUB      SP,SP,#+200
        CFI CFA R13+232
        LDR      R8,[SP, #+232]
        LDR      R9,[SP, #+236]
        MOV      R4,R0
        MOV      R5,R1
        MOV      R6,R2
        MOV      R7,R3
// 1385    Word32 tmp[50];   /* malloc is slow */
// 1386    Word32 i, j, s, a0;
// 1387    Word32 *yy;
// 1388 
// 1389 
// 1390    /* Copy mem[] to yy[] */
// 1391    memcpy( tmp, mem, 40 );
        MOV      R2,#+40
        MOV      R1,R8
        MOV      R0,SP
        SWI      +286
// 1392    yy = tmp + M;
// 1393    a0 = a[0];
        LDR      R0,[R4, #+0]
        ADD      R1,SP,#+40
// 1394 
// 1395    /* Do the filtering. */
// 1396    for ( i = 0; i < lg; i++ ) {
        MOV      R2,#+0
        CMP      R7,#+1
        BGE      ??Syn_filt_overflow_0
// 1397       s = x[i] * a0;
// 1398 
// 1399       for ( j = 1; j <= M; j++ ) {
// 1400          s -= a[j] * yy[ - j];
// 1401          if (s > 1073741823){
// 1402             s = 1073741823;
// 1403          }
// 1404          else if ( s < -1073741824) {
// 1405             s = -1073741824;
// 1406          }
// 1407       }
// 1408 
// 1409       if ( labs( s ) < 0x7FFE800 )
// 1410          *yy = ( s + 0x800L ) >> 12;
// 1411       else if ( s > 0 ) {
// 1412          *yy = 32767;
// 1413       }
// 1414       else {
// 1415          *yy = -32768;
// 1416       }
// 1417       yy++;
// 1418    }
// 1419    memcpy( y, &tmp[M], lg <<2 );
??Syn_filt_overflow_1:
        LSL      R2,R7,#+2
        ADD      R1,SP,#+40
        MOV      R0,R6
        SWI      +286
// 1420 
// 1421    /* Update of memory if update==1 */
// 1422    if ( update ) {
        CMP      R9,#+0
        BEQ      ??Syn_filt_overflow_2
// 1423       memcpy( mem, &y[lg - M], 40 );
        MOV      R2,#+40
        ADD      R0,R6,R7, LSL #+2
        SUB      R1,R0,#+40
        MOV      R0,R8
        SWI      +286
// 1424    }
// 1425    return;
??Syn_filt_overflow_2:
        ADD      SP,SP,#+200      ;; stack cleaning
        CFI CFA R13+32
        POP      {R4-R10,PC}      ;; return
        CFI CFA R13+232
??Syn_filt_overflow_3:
        STR      R3,[R1], #+4
        ADD      R2,R2,#+1
??Syn_filt_overflow_0:
        CMP      R2,R7
        BGE      ??Syn_filt_overflow_1
        LDR      R3,[R5, +R2, LSL #+2]
        MOV      R12,#+1
        MUL      R3,R0,R3
??Syn_filt_overflow_4:
        LDR      LR,[R4, +R12, LSL #+2]
        MOV      R10,R12
        RSB      R10,R10,#+0
        LDR      R10,[R1, +R10, LSL #+2]
        ADD      R12,R12,#+1
        MUL      LR,R10,LR
        SUB      R3,R3,LR
        MOVS     R10,R3, ASR #+30
        MVNSNE   R10,R10
        MVNNE    R10,#+0
        MOVNE    R3,R10, LSL #+30
        MVNMI    R3,R3
        CMP      R12,#+11
        BLT      ??Syn_filt_overflow_4
        LDR      R10,??Syn_filt_overflow_5  ;; 0x7ffe800
        CMP      R3,#+0
        RSBMI    R12,R3,#+0
        MOVPL    R12,R3
        CMP      R12,R10
        ADDLT    R3,R3,#+2048
        ASRLT    R3,R3,#+12
        BLT      ??Syn_filt_overflow_3
        CMP      R3,#+1
        MVNLT    R3,#+255
        BICLT    R3,R3,#0x7F00
        MOVGE    R3,#+255
        ORRGE    R3,R3,#0x7F00
        B        ??Syn_filt_overflow_3
        DATA
??Syn_filt_overflow_5:
        DC32     0x7ffe800
        CFI EndBlock cfiBlock27
// 1426 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock28 Using cfiCommon0
        CFI NoFunction
        THUMB
??dtx_dec??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock28
        REQUIRE dtx_dec
// 1427 
// 1428 /*
// 1429  * dtx_dec
// 1430  *
// 1431  *
// 1432  * Parameters:
// 1433  *    st                            B: DTX state struct
// 1434  *    mem_syn                       I: AMR decoder state
// 1435  *    lsfState                      B: LSF state struct
// 1436  *    pred_state->past_qua_en       O: table of past quantized energies
// 1437  *    pred_state->past_qua_en_MR122 O: table of past quantized energies MR122
// 1438  *    averState->hangVar            O:
// 1439  *    averState->hangCount          O: hangover variable
// 1440  *    new_state                     I: new DTX state
// 1441  *    mode                          I: AMR mode
// 1442  *    parm                          I: vector of synthesis parameters
// 1443  *    synth                         O: synthesised speech
// 1444  *    A_t                           O: decoded LP filter in 4 subframes
// 1445  *
// 1446  * Function:
// 1447  *    DTX
// 1448  *
// 1449  * Returns:
// 1450  *    void
// 1451  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock29 Using cfiCommon1
        CFI Function dtx_dec
        ARM
// 1452 static void dtx_dec( dtx_decState *st, Word32 *mem_syn, D_plsfState *lsfState,
// 1453       gc_predState *pred_state, Cb_gain_averageState *averState, enum
// 1454       DTXStateType new_state, enum Mode mode, Word16 parm[], Word32 synth[],
// 1455       Word32 A_t[] )
// 1456 {
dtx_dec:
        PUSH     {R1,R2,R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+44
        SUB      SP,SP,#+496
        CFI CFA R13+540
        LDRB     R10,[SP, #+548]
        LDR      R7,[SP, #+560]
        LDR      R8,??dtx_dec_0   ;; dtx_log_en_adjust
        MOV      R4,R0
        ADD      R5,R4,#+772
        LDRSH    R0,[R5, #+18]
        MOV      R9,R3
        MOV      R6,#+0
        CMP      R0,#+0
        LDRSHNE  R0,[R5, #+14]
        CMPNE    R0,#+0
        BEQ      ??dtx_dec_1
// 1457    Word32 ex[L_SUBFR], acoeff[11], acoeff_variab[M + 1], lsp_int[M];
// 1458    Word32 refl[M], lsf[M], lsf_int[M], lsf_int_variab[M], lsp_int_variab[M];
// 1459    Word32 i, j, int_fac, log_en_int, pred_err, log_pg_e, log_pg_m, log_pg;
// 1460    Word32 negative, lsf_mean, lsf_variab_index, lsf_variab_factor, ptr;
// 1461    Word16 log_en_index, log_en_int_e, log_en_int_m, level, ma_pred_init,
// 1462          tmp_int_length;
// 1463 
// 1464 
// 1465    if ( ( st->dtxHangoverAdded != 0 ) & ( st->sid_frame != 0 ) ) {
// 1466       /*
// 1467        * sidFirst after dtx hangover period
// 1468        * or sidUpd after dtxhangover
// 1469        */
// 1470       /* set log_en_adjust to correct value */
// 1471       st->log_en_adjust = dtx_log_en_adjust[mode];
        ADD      R0,R8,R10, LSL #+1
        LDRSH    R0,[R0, #+0]
// 1472       ptr = st->lsf_hist_ptr + M;
// 1473 
// 1474       if ( ptr == 80 ) {
// 1475          ptr = 0;
// 1476       }
// 1477       memcpy( &st->lsf_hist[ptr], &st->lsf_hist[st->lsf_hist_ptr], M <<2 );
        MOV      R2,#+40
        STRH     R0,[R5, #+8]
        LDRSH    R0,[R5, #+2]
        LDRSH    R1,[R5, #+2]
        ADD      R0,R0,#+10
        CMP      R0,#+80
        MOVEQ    R0,#+0
        ADD      R1,R4,R1, LSL #+2
        ADD      R1,R1,#+96
        ADD      R0,R4,R0, LSL #+2
        ADD      R0,R0,#+96
        SWI      +286
// 1478       ptr = st->log_en_hist_ptr + 1;
// 1479 
// 1480       if ( ptr == DTX_HIST_SIZE ) {
// 1481          ptr = 0;
// 1482       }
// 1483       st->log_en_hist[ptr] = st->log_en_hist[st->log_en_hist_ptr];   /* Q11 */
        LDRSH    R1,[R5, #+6]
        LDRSH    R0,[R5, #+6]
// 1484 
// 1485       /*
// 1486        * compute mean log energy and lsp
// 1487        * from decoded signal (SID_FIRST)
// 1488        */
// 1489       st->log_en = 0;
// 1490       memset( lsf, 0, M <<2 );
        MOV      R2,#+40
        ADD      R1,R4,R1, LSL #+2
        LDR      R1,[R1, #+736]
        ADD      R0,R0,#+1
        CMP      R0,#+8
        MOVEQ    R0,#+0
        ADD      R0,R4,R0, LSL #+2
        STR      R1,[R0, #+736]
        STR      R6,[R4, #+4]
        MOV      R1,#+0
        ADD      R0,SP,#+92
        SWI      +187
// 1491 
// 1492       /* average energy and lsp */
// 1493       for ( i = 0; i < DTX_HIST_SIZE; i++ ) {
        MOV      R0,R6
// 1494          st->log_en = st->log_en + ( st->log_en_hist[i] >> 3 );
??dtx_dec_2:
        LDR      R1,[R4, #+4]
        ADD      R2,R4,R0, LSL #+2
        LDR      R2,[R2, #+736]
        ADD      R1,R1,R2, ASR #+3
        STR      R1,[R4, #+4]
// 1495 
// 1496          for ( j = 0; j < M; j++ ) {
        MOV      R1,#+0
// 1497             lsf[j] += st->lsf_hist[i * M + j];
??dtx_dec_3:
        MOV      R11,#+10
        MLA      R12,R11,R0,R1
        ADD      R2,SP,#+92
        ADD      R2,R2,R1, LSL #+2
        LDR      R3,[R2, #+0]
        ADD      R11,R4,R12, LSL #+2
        LDR      R11,[R11, #+96]
// 1498          }
        ADD      R1,R1,#+1
        ADD      R3,R11,R3
        STR      R3,[R2, #+0]
        CMP      R1,#+10
        BLT      ??dtx_dec_3
// 1499       }
        ADD      R0,R0,#+1
        CMP      R0,#+8
        BLT      ??dtx_dec_2
// 1500 
// 1501       for ( j = 0; j < M; j++ ) {
        MOV      R0,#+0
// 1502          lsf[j] = lsf[j] >> 3;   /* divide by 8 */
??dtx_dec_4:
        ADD      R1,SP,#+92
        ADD      R1,R1,R0, LSL #+2
        LDR      R2,[R1, #+0]
// 1503       }
        ADD      R0,R0,#+1
        ASR      R2,R2,#+3
        STR      R2,[R1, #+0]
        CMP      R0,#+10
        BLT      ??dtx_dec_4
// 1504       Lsf_lsp( lsf, st->lsp );
        ADD      R1,R4,#+16
        ADD      R0,SP,#+92
        BL       Lsf_lsp
// 1505 
// 1506       /*
// 1507        * make log_en speech coder mode independent
// 1508        * added again later before synthesis
// 1509        */
// 1510       st->log_en = st->log_en - st->log_en_adjust;
        LDRSH    R1,[R5, #+8]
        LDR      R0,[R4, #+4]
// 1511 
// 1512       /* compute lsf variability vector */
// 1513       memcpy( st->lsf_hist_mean, st->lsf_hist, 80 <<2 );
        MOV      R2,#+320
        SUB      R0,R0,R1
        STR      R0,[R4, #+4]
        ADD      R1,R4,#+96
        ADD      R0,R4,#+416
        SWI      +286
// 1514 
// 1515       for ( i = 0; i < M; i++ ) {
        MOV      R1,#+0
// 1516          lsf_mean = 0;
??dtx_dec_5:
        MOV      R0,#+0
// 1517 
// 1518          /* compute mean lsf */
// 1519          for ( j = 0; j < 8; j++ ) {
        MOV      R2,R0
// 1520             lsf_mean += st->lsf_hist_mean[i + j * M];
??dtx_dec_6:
        MOV      R3,#+10
        MLA      R11,R3,R2,R1
// 1521          }
        ADD      R2,R2,#+1
        ADD      R3,R4,R11, LSL #+2
        LDR      R3,[R3, #+416]
        CMP      R2,#+8
        ADD      R0,R3,R0
        BLT      ??dtx_dec_6
// 1522          lsf_mean = lsf_mean >> 3;
        ASR      R2,R0,#+3
// 1523 
// 1524          /*
// 1525           * subtract mean and limit to within reasonable limits
// 1526           * moreover the upper lsf's are attenuated
// 1527           */
// 1528          for ( j = 0; j < 8; j++ ) {
        MOV      R0,#+0
??dtx_dec_7:
        MOV      R3,#+10
        MLA      R11,R3,R0,R1
// 1529             /* subtract mean */
// 1530             st->lsf_hist_mean[i + j * M] = st->lsf_hist_mean[i + j * M] -
// 1531                   lsf_mean;
// 1532 
// 1533             /* attenuate deviation from mean, especially for upper lsf's */
// 1534             st->lsf_hist_mean[i + j * M] = ( st->lsf_hist_mean[i + j * M] *
// 1535                   lsf_hist_mean_scale[i] ) >> 15;
        ADD      R12,R8,R1, LSL #+1
        ADD      R3,R4,R11, LSL #+2
        LDR      R11,[R3, #+416]
        SUB      R11,R11,R2
        STR      R11,[R3, #+416]
        LDRSH    R12,[R12, #+20]
        MUL      R11,R12,R11
        ASR      R11,R11,#+15
        STR      R11,[R3, #+416]
// 1536 
// 1537             /* limit the deviation */
// 1538             if ( st->lsf_hist_mean[i + j * M] < 0 ) {
// 1539                negative = 1;
// 1540             }
// 1541             else {
// 1542                negative = 0;
// 1543             }
// 1544             st->lsf_hist_mean[i + j * M] = labs( st->lsf_hist_mean[i + j * M] );
        LDR      R12,[R3, #+416]
        CMP      R11,#+0
        MOVMI    R11,#+1
        MOVPL    R11,#+0
        CMP      R12,#+0
        RSBMI    R12,R12,#+0
        STR      R12,[R3, #+416]
// 1545 
// 1546             /* apply soft limit */
// 1547             if ( st->lsf_hist_mean[i + j * M] > 655 ) {
        CMP      R12,#+656
        BLT      ??dtx_dec_8
// 1548                st->lsf_hist_mean[i + j * M] = 655 + ( ( st->lsf_hist_mean[i + j
// 1549                      * M] - 655 ) >> 2 );
        MVN      LR,#+142
        BIC      LR,LR,#0x200
        ADD      R12,LR,R12
        RSB      LR,LR,#+0
        ADD      R12,LR,R12, ASR #+2
        STR      R12,[R3, #+416]
// 1550             }
// 1551 
// 1552             /* apply hard limit */
// 1553             if ( st->lsf_hist_mean[i + j * M] > 1310 ) {
??dtx_dec_8:
        LDR      R12,[R3, #+416]
        MOV      LR,#+31
        ORR      LR,LR,#0x500
        CMP      R12,LR
// 1554                st->lsf_hist_mean[i + j * M] = 1310;
        BICGE    R12,LR,#0x1
        STRGE    R12,[R3, #+416]
// 1555             }
// 1556 
// 1557             if ( negative != 0 ) {
        CMP      R11,#+0
// 1558                st->lsf_hist_mean[i + j * M] = -st->lsf_hist_mean[i + j * M];
        LDRNE    R11,[R3, #+416]
// 1559             }
// 1560          }
        ADD      R0,R0,#+1
        RSBNE    R11,R11,#+0
        STRNE    R11,[R3, #+416]
        CMP      R0,#+8
        BLT      ??dtx_dec_7
// 1561       }
        ADD      R1,R1,#+1
        CMP      R1,#+10
        BLT      ??dtx_dec_5
??dtx_dec_1:
        LDRSH    R0,[R5, #+14]
        CMP      R0,#+0
        BEQ      ??dtx_dec_9
// 1562    }
// 1563 
// 1564    if ( st->sid_frame != 0 ) {
// 1565       /*
// 1566        * Set old SID parameters, always shift
// 1567        * even if there is no new valid_data
// 1568        */
// 1569       memcpy( st->lsp_old, st->lsp, M <<2 );
        MOV      R2,#+40
        ADD      R1,R4,#+16
        ADD      R0,R4,#+56
        SWI      +286
// 1570       st->old_log_en = st->log_en;
        LDR      R0,[R4, #+4]
        STR      R0,[R4, #+8]
// 1571 
// 1572       if ( st->valid_data != 0 ) /* new data available (no CRC) */ {
        LDRSH    R0,[R5, #+16]
        CMP      R0,#+0
        BEQ      ??dtx_dec_10
// 1573       /* Compute interpolation factor, since the division only works
// 1574        * for values of since_last_sid < 32 we have to limit the
// 1575        * interpolation to 32 frames
// 1576        */
// 1577          tmp_int_length = st->since_last_sid;
        LDRSH    R1,[R5, #+0]
// 1578          st->since_last_sid = 0;
        STRH     R6,[R5, #+0]
// 1579 
// 1580          if ( tmp_int_length > 32 ) {
        CMP      R1,#+33
// 1581             tmp_int_length = 32;
        MOVGE    R1,#+32
// 1582          }
// 1583 
// 1584          if ( tmp_int_length >= 2 ) {
        CMPLT    R1,#+2
        BLT      ??dtx_dec_11
// 1585             st->true_sid_period_inv = 0x2000000 / ( tmp_int_length
// 1586                   << 10 );
        MOV      R0,#+33554432
        LSL      R1,R1,#+10
        _BLF     ??div32_a,??rA??div32_a
        STR      R1,[R4, #+768]
        B        ??dtx_dec_12
// 1587          }
// 1588          else {
// 1589             st->true_sid_period_inv = 16384;   /* 0.5 it Q15 */
??dtx_dec_11:
        MOV      R0,#+16384
        STR      R0,[R4, #+768]
// 1590          }
// 1591          memcpy( lsfState->past_r_q, &past_rq_init[parm[0] * M], M <<2 );
??dtx_dec_12:
        LDR      R0,[SP, #+552]
        MOV      R2,#+40
        LDRSH    R0,[R0, #+0]
        MLA      R0,R2,R0,R8
        ADD      R1,R0,#+556
        LDR      R0,[SP, #+500]
        SWI      +286
// 1592          D_plsf_3( lsfState, MRDTX, 0, &parm[1], st->lsp );
        ADD      R0,R4,#+16
        PUSH     {R0}
        CFI CFA R13+544
        LDR      R0,[SP, #+556]
        MOV      R2,#+0
        ADD      R3,R0,#+2
        LDR      R0,[SP, #+504]
        MOV      R1,#+8
        BL       D_plsf_3
// 1593 
// 1594          /* reset for next speech frame */
// 1595          memset( lsfState->past_r_q, 0, M <<2 );
        LDR      R0,[SP, #+504]
        MOV      R2,#+40
        MOV      R1,R6
        SWI      +187
// 1596          log_en_index = parm[4];
        LDR      R0,[SP, #+556]
        LDRSH    R0,[R0, #+8]
// 1597 
// 1598          /* Q11 and divide by 4 */
// 1599          st->log_en = ( Word16 )( log_en_index << 9 );
        MOV      R1,R0
        LSL      R1,R1,#+25
        ASR      R1,R1,#+16
        STR      R1,[R4, #+4]
// 1600 
// 1601          /* Subtract 2.5 in Q11 */
// 1602          st->log_en = ( Word16 )( st->log_en - 5120 );
        LDR      R1,[R4, #+4]
// 1603 
// 1604          /* Index 0 is reserved for silence */
// 1605          if ( log_en_index == 0 ) {
        CMP      R0,#+0
        SUB      R1,R1,#+5120
        MOV      R1,R1, LSL #+16
        MOV      R1,R1, ASR #+16
        STR      R1,[R4, #+4]
        ADD      SP,SP,#+4
        CFI CFA R13+540
// 1606             st->log_en = MIN_16;
        MVNEQ    R0,#+255
        BICEQ    R0,R0,#0x7F00
        STREQ    R0,[R4, #+4]
// 1607          }
// 1608 
// 1609          /*
// 1610           * no interpolation at startup after coder reset
// 1611           * or when SID_UPD has been received right after SPEECH
// 1612           */
// 1613          if ( ( st->data_updated == 0 ) || ( st->dtxGlobalState == SPEECH ) ) {
        LDRSH    R0,[R5, #+20]
        CMP      R0,#+0
        LDRBNE   R0,[R4, #+0]
        CMPNE    R0,#+0
        BNE      ??dtx_dec_10
// 1614             memcpy( st->lsp_old, st->lsp, M <<2 );
        MOV      R2,#+40
        ADD      R1,R4,#+16
        ADD      R0,R4,#+56
        SWI      +286
// 1615             st->old_log_en = st->log_en;
        LDR      R0,[R4, #+4]
        STR      R0,[R4, #+8]
// 1616          }
// 1617       }   /* endif valid_data */
// 1618 
// 1619       /* initialize gain predictor memory of other modes */
// 1620       ma_pred_init = ( Word16 )( ( st->log_en >> 1 ) - 9000 );
??dtx_dec_10:
        LDR      R0,[R4, #+4]
        MVN      R1,#+39
        ASR      R0,R0,#+1
        BIC      R1,R1,#0x2300
        ADD      R0,R1,R0
        MOV      R0,R0, LSL #+16
        MOV      R0,R0, ASR #+16
// 1621 
// 1622       if ( ma_pred_init > 0 ) {
        CMP      R0,#+1
// 1623          ma_pred_init = 0;
        MOVGE    R0,#+0
        BGE      ??dtx_dec_13
// 1624       }
// 1625 
// 1626       if ( ma_pred_init < - 14436 ) {
        MVN      R1,#+99
        BIC      R1,R1,#0x3800
        CMP      R0,R1
// 1627          ma_pred_init = -14436;
        MOVLT    R0,R1
// 1628       }
// 1629       pred_state->past_qua_en[0] = ma_pred_init;
??dtx_dec_13:
        MOV      R1,R0
        STR      R1,[R9, #+0]
// 1630       pred_state->past_qua_en[1] = ma_pred_init;
        STR      R1,[R9, #+4]
// 1631       pred_state->past_qua_en[2] = ma_pred_init;
        STR      R1,[R9, #+8]
// 1632       pred_state->past_qua_en[3] = ma_pred_init;
        STR      R1,[R9, #+12]
// 1633 
// 1634       /* past_qua_en for other modes than MR122 */
// 1635       ma_pred_init = ( Word16 )( ( 5443*ma_pred_init ) >> 15 );
        MOV      R1,#+67
        ORR      R1,R1,#0x1500
        MUL      R0,R1,R0
        LSL      R0,R0,#+1
        ASR      R0,R0,#+16
// 1636 
// 1637       /* scale down by factor 20*log10(2) in Q15 */
// 1638       pred_state->past_qua_en_MR122[0] = ma_pred_init;
        STR      R0,[R9, #+16]
// 1639       pred_state->past_qua_en_MR122[1] = ma_pred_init;
        STR      R0,[R9, #+20]
// 1640       pred_state->past_qua_en_MR122[2] = ma_pred_init;
        STR      R0,[R9, #+24]
// 1641       pred_state->past_qua_en_MR122[3] = ma_pred_init;
        STR      R0,[R9, #+28]
// 1642    }   /* endif sid_frame */
// 1643 
// 1644    /*
// 1645     * CN generation
// 1646     * recompute level adjustment factor Q11
// 1647     * st->log_en_adjust = 0.9*st->log_en_adjust +
// 1648     *                     0.1*dtx_log_en_adjust[mode]);
// 1649     */
// 1650    st->log_en_adjust = ( Word16 )( ( ( st->log_en_adjust * 29491 ) >> 15 ) + ( (
// 1651          ( dtx_log_en_adjust[mode] << 5 ) * 3277 ) >> 20 ) );
??dtx_dec_9:
        LDRSH    R0,[R5, #+8]
        MOV      R1,#+51
        ORR      R1,R1,#0x7300
        MUL      R0,R1,R0
        ADD      R1,R8,R10, LSL #+1
        LDRSH    R1,[R1, #+0]
        MOV      R2,#+205
        ORR      R2,R2,#0xC00
        LSL      R1,R1,#+5
        MUL      R1,R2,R1
// 1652 
// 1653    /* Interpolate SID info */
// 1654    /* Q10 */
// 1655    if ( st->since_last_sid > 30 )
// 1656       int_fac = 32767;
// 1657    else
// 1658       int_fac = ( Word16 )( (st->since_last_sid + 1) << 10 );
// 1659 
// 1660    /* Q10 * Q15 -> Q10 */
// 1661    int_fac = ( int_fac * st->true_sid_period_inv ) >> 15;
// 1662 
// 1663    /* Maximize to 1.0 in Q10 */
// 1664    if ( int_fac > 1024 ) {
// 1665       int_fac = 1024;
// 1666    }
// 1667 
// 1668    /* Q10 -> Q14 */
// 1669    int_fac = ( Word16 )( int_fac << 4 );
// 1670 
// 1671    /* Q14 * Q11->Q26 */
// 1672    log_en_int = ( int_fac * st->log_en ) << 1;
// 1673 
// 1674    for ( i = 0; i < M; i++ ) {
        ADD      R3,SP,#+52
        ASR      R1,R1,#+20
        ADD      R0,R1,R0, ASR #+15
        STRH     R0,[R5, #+8]
        LDRSH    R0,[R5, #+0]
        LDR      R1,[R4, #+768]
        CMP      R0,#+31
        MOVGE    R0,#+255
        ORRGE    R0,R0,#0x7F00
        ADDLT    R0,R0,#+1
        LSLLT    R0,R0,#+26
        ASRLT    R0,R0,#+16
        MUL      R0,R1,R0
        MOV      R1,#+1
        ASR      R0,R0,#+15
        ORR      R1,R1,#0x400
        CMP      R0,R1
        LDR      R1,[R4, #+4]
        MOVGE    R0,#+1024
        LSL      R0,R0,#+20
        ASR      R0,R0,#+16
        MUL      R2,R1,R0
        LSL      R1,R2,#+1
        MOV      R2,#+0
// 1675       /* Q14 * Q15 -> Q14 */
// 1676       lsp_int[i] = ( int_fac * st->lsp[i] ) >> 15;
??dtx_dec_14:
        ADD      R9,R4,R2, LSL #+2
        LDR      R9,[R9, #+16]
        MUL      R10,R9,R0
        ASR      R9,R10,#+15
        STR      R9,[R3, +R2, LSL #+2]
// 1677    }
        ADD      R2,R2,#+1
        CMP      R2,#+10
        BLT      ??dtx_dec_14
// 1678 
// 1679    /* 1-k in Q14 */
// 1680    int_fac = 16384 - int_fac;
// 1681 
// 1682    /* (Q14 * Q11 -> Q26) + Q26 -> Q26 */
// 1683    log_en_int += ( int_fac * st->old_log_en ) << 1;
        LDR      R2,[R4, #+8]
        RSB      R0,R0,#+16384
        MUL      R3,R2,R0
        ADD      R9,R1,R3, LSL #+1
// 1684 
// 1685    for ( i = 0; i < M; i++ ) {
        MOV      R1,#+0
// 1686       /* Q14 + (Q14 * Q15 -> Q14) -> Q14 */
// 1687       lsp_int[i] = lsp_int[i] + ( ( int_fac * st->lsp_old[i] ) >> 15 );
// 1688 
// 1689       /* Q14 -> Q15 */
// 1690       lsp_int[i] = lsp_int[i] << 1;
??dtx_dec_15:
        ADD      R10,R4,R1, LSL #+2
        LDR      R10,[R10, #+56]
        ADD      R2,SP,#+52
        ADD      R2,R2,R1, LSL #+2
        LDR      R3,[R2, #+0]
        MUL      R11,R10,R0
// 1691    }
        ADD      R1,R1,#+1
        ADD      R3,R3,R11, ASR #+15
        LSL      R3,R3,#+1
        STR      R3,[R2, #+0]
        CMP      R1,#+10
        BLT      ??dtx_dec_15
// 1692 
// 1693    /* compute the amount of lsf variability */
// 1694    /* -0.6 in Q12 */
// 1695    lsf_variab_factor = st->log_pg_mean - 2457;
// 1696 
// 1697    /* *0.3 Q12*Q15 -> Q12 */
// 1698    lsf_variab_factor = 4096 - ( ( lsf_variab_factor * 9830 ) >> 15 );
        LDRSH    R1,[R5, #+4]
        MVN      R2,#+152
        BIC      R2,R2,#0x900
        ADD      R1,R2,R1
        MOV      R2,#+102
        ORR      R2,R2,#0x2600
        MUL      R1,R2,R1
        MOV      R0,#+4096
        SUB      R0,R0,R1, ASR #+15
// 1699 
// 1700    /* limit to values between 0..1 in Q12 */
// 1701    if ( lsf_variab_factor >= 4096 ) {
        CMP      R0,#+4096
// 1702       lsf_variab_factor = 32767;
        MOVGE    R10,#+255
        ORRGE    R10,R10,#0x7F00
        BGE      ??dtx_dec_16
// 1703    }
// 1704    else if ( lsf_variab_factor < 0 ) {
        CMP      R0,#+0
// 1705       lsf_variab_factor = 0;
        MOVMI    R10,#+0
// 1706    }
// 1707    else
// 1708       lsf_variab_factor = lsf_variab_factor << 3;   /* -> Q15 */
        LSLPL    R10,R0,#+3
// 1709 
// 1710    /* get index of vector to do variability with */
// 1711    lsf_variab_index = pseudonoise( &st->pn_seed_rx, 3 );
??dtx_dec_16:
        MOV      R1,#+3
        ADD      R0,R4,#+12
        BL       pseudonoise
        MOV      R11,R0
// 1712 
// 1713    /* convert to lsf */
// 1714    Lsp_lsf( lsp_int, lsf_int );
        MOV      R1,#+63
        MOV      R0,#+9
        B        ??dtx_dec_17
??dtx_dec_18:
        SUB      R1,R1,#+1
??dtx_dec_17:
        ADD      R2,R8,R1, LSL #+2
        LDR      R3,[R2, #+40]
        ADD      R12,SP,#+52
        LDR      LR,[R12, +R0, LSL #+2]
        CMP      R3,LR
        BLT      ??dtx_dec_18
        LDR      R2,[R2, #+300]
        SUB      R3,LR,R3
        MUL      R3,R2,R3
        ADD      R12,SP,#+132
        ADD      R2,R3,#+2048
        LSL      R3,R1,#+8
        ADD      R2,R3,R2, ASR #+12
        STR      R2,[R12, +R0, LSL #+2]
        SUBS     R0,R0,#+1
        BPL      ??dtx_dec_17
// 1715 
// 1716    /* apply lsf variability */
// 1717    memcpy( lsf_int_variab, lsf_int, M <<2 );
        MOV      R2,#+40
        ADD      R1,SP,#+132
        ADD      R0,SP,#+172
        SWI      +286
// 1718 
// 1719    for ( i = 0; i < M; i++ ) {
        MOV      R0,#+0
// 1720       lsf_int_variab[i] = lsf_int_variab[i] + ( ( lsf_variab_factor * st->
// 1721             lsf_hist_mean[i + lsf_variab_index * M] ) >> 15 );
??dtx_dec_19:
        MOV      R3,#+10
        MLA      R8,R3,R11,R0
        ADD      R1,SP,#+172
        ADD      R3,R4,R8, LSL #+2
        LDR      R3,[R3, #+416]
        ADD      R1,R1,R0, LSL #+2
        LDR      R2,[R1, #+0]
        MUL      R8,R3,R10
// 1722    }
        ADD      R0,R0,#+1
        ADD      R2,R2,R8, ASR #+15
        STR      R2,[R1, #+0]
        CMP      R0,#+10
        BLT      ??dtx_dec_19
// 1723 
// 1724    /* make sure that LSP's are ordered */
// 1725    Reorder_lsf( lsf_int, LSF_GAP );
        MOV      R1,#+205
        ADD      R0,SP,#+132
        BL       Reorder_lsf
// 1726    Reorder_lsf( lsf_int_variab, LSF_GAP );
        MOV      R1,#+205
        ADD      R0,SP,#+172
        BL       Reorder_lsf
// 1727 
// 1728    /* copy lsf to speech decoders lsf state */
// 1729    memcpy( lsfState->past_lsf_q, lsf_int, M <<2 );
        LDR      R0,[SP, #+500]
        MOV      R2,#+40
        ADD      R1,SP,#+132
        ADD      R0,R0,#+40
        SWI      +286
// 1730 
// 1731    /* convert to lsp */
// 1732    Lsf_lsp( lsf_int, lsp_int );
        ADD      R1,SP,#+52
        ADD      R0,SP,#+132
        BL       Lsf_lsp
// 1733    Lsf_lsp( lsf_int_variab, lsp_int_variab );
        ADD      R1,SP,#+456
        ADD      R0,SP,#+172
        BL       Lsf_lsp
// 1734 
// 1735      /* Compute acoeffs Q12 acoeff is used for level
// 1736       * normalization and Post_Filter, acoeff_variab is
// 1737       * used for synthesis filter
// 1738       * by doing this we make sure that the level
// 1739       * in high frequenncies does not jump up and down
// 1740       */
// 1741    Lsp_Az( lsp_int, acoeff );
        ADD      R1,SP,#+8
        ADD      R0,SP,#+52
        BL       Lsp_Az
// 1742    Lsp_Az( lsp_int_variab, acoeff_variab );
        ADD      R1,SP,#+372
        ADD      R0,SP,#+456
        BL       Lsp_Az
// 1743 
// 1744    /* For use in Post_Filter */
// 1745    memcpy( &A_t[0], acoeff, MP1 <<2 );
        MOV      R2,#+44
        ADD      R1,SP,#+8
        MOV      R0,R7
        SWI      +286
// 1746    memcpy( &A_t[MP1], acoeff, MP1 <<2 );
        MOV      R2,#+44
        ADD      R1,SP,#+8
        ADD      R0,R7,#+44
        SWI      +286
// 1747    memcpy( &A_t[MP1 <<1], acoeff, MP1 <<2 );
        MOV      R2,#+44
        ADD      R1,SP,#+8
        ADD      R0,R7,#+88
        SWI      +286
// 1748    memcpy( &A_t[MP1 + MP1 + MP1], acoeff, MP1 <<2 );
        MOV      R2,#+44
        ADD      R1,SP,#+8
        ADD      R0,R7,#+132
        SWI      +286
// 1749 
// 1750    /* Compute reflection coefficients Q15 */
// 1751    A_Refl( &acoeff[1], refl );
        ADD      R1,SP,#+416
        ADD      R0,SP,#+12
        BL       A_Refl
// 1752 
// 1753    /* Compute prediction error in Q15 */
// 1754    /* 0.99997 in Q15 */
// 1755    pred_err = MAX_16;
        MOV      R0,#+255
        ORR      R0,R0,#0x7F00
// 1756 
// 1757    for ( i = 0; i < M; i++ ) {
        MOV      R1,#+0
        MOV      R3,R0
// 1758       pred_err = ( pred_err * ( MAX_16 - ( ( refl[i] * refl[i] ) >> 15 ) ) ) >>
// 1759             15;
??dtx_dec_20:
        ADD      R2,SP,#+416
        LDR      R2,[R2, +R1, LSL #+2]
// 1760    }
        ADD      R1,R1,#+1
        MUL      R7,R2,R2
        CMP      R1,#+10
        SUB      R2,R3,R7, ASR #+15
        MUL      R0,R2,R0
        ASR      R0,R0,#+15
        BLT      ??dtx_dec_20
// 1761 
// 1762    /* compute logarithm of prediction gain */
// 1763    Log2( pred_err, &log_pg_e, &log_pg_m );
        ADD      R2,SP,#+4
        MOV      R1,SP
        BL       Log2
// 1764 
// 1765    /* convert exponent and mantissa to Word16 Q12 */
// 1766    /* Q12 */
// 1767    log_pg = ( log_pg_e - 15 ) << 12;
        LDR      R0,[SP, #+0]
// 1768    /* saturate */
// 1769    if (log_pg < -32768) {
// 1770       log_pg = -32768;
// 1771    }
// 1772    log_pg = ( -( log_pg + ( log_pg_m >> 3 ) ) ) >> 1;
        LDR      R1,[SP, #+4]
        SUB      R0,R0,#+15
        LSL      R0,R0,#+12
        CMN      R0,#+32768
        MVNLT    R0,#+255
        BICLT    R0,R0,#0x7F00
        ADD      R0,R0,R1, ASR #+3
// 1773    st->log_pg_mean = ( Word16 )( ( ( 29491*st->log_pg_mean ) >> 15 ) + ( ( 3277
// 1774          * log_pg ) >> 15 ) );
        LDRSH    R1,[R5, #+4]
        RSB      R0,R0,#+0
        ASR      R0,R0,#+1
        MOV      R2,#+51
        ORR      R2,R2,#0x7300
        MUL      R1,R2,R1
        MOV      R2,#+205
        ORR      R2,R2,#0xC00
        MUL      R3,R2,R0
// 1775 
// 1776    /* Compute interpolated log energy */
// 1777    /* Q26 -> Q16 */
// 1778    log_en_int = log_en_int >> 10;
// 1779 
// 1780    /* Add 4 in Q16 */
// 1781    log_en_int += 262144L;
// 1782 
// 1783    /* subtract prediction gain */
// 1784    log_en_int = log_en_int - ( log_pg << 4 );
// 1785 
// 1786    /* adjust level to speech coder mode */
// 1787    log_en_int += st->log_en_adjust << 5;
// 1788    log_en_int_e = ( Word16 )( log_en_int >> 16 );
// 1789    log_en_int_m = ( Word16 )( ( log_en_int - ( log_en_int_e << 16 ) ) >> 1 );
// 1790 
// 1791    /* Q4 */
// 1792    level = ( Word16 )( Pow2( log_en_int_e, log_en_int_m ) );
// 1793 
// 1794    for ( i = 0; i < 4; i++ ) {
        MOV      R8,#+0
        ASR      R2,R3,#+15
        ADD      R1,R2,R1, ASR #+15
        STRH     R1,[R5, #+4]
        MOV      R1,#+262144
        ADD      R1,R1,R9, ASR #+10
        SUB      R0,R1,R0, LSL #+4
        LDRSH    R1,[R5, #+8]
        ADD      R9,R4,#+12
        ADD      R1,R0,R1, LSL #+5
        ASR      R0,R1,#+16
        SUB      R1,R1,R0, LSL #+16
        LSL      R1,R1,#+15
        ASR      R1,R1,#+16
        BL       Pow2
        MOV      R7,R0, LSL #+16
        MOV      R7,R7, ASR #+16
// 1795       /* Compute innovation vector */
// 1796       Build_CN_code( &st->pn_seed_rx, ex );
??dtx_dec_21:
        MOV      R2,#+160
        MOV      R1,#+0
        ADD      R0,SP,#+212
        SWI      +187
        MOV      R10,R6
??dtx_dec_22:
        MOV      R1,#+2
        MOV      R0,R9
        BL       pseudonoise
        MOV      R1,#+20
        MUL      R0,R1,R0
        MOV      R1,#+1
        ADD      R11,R10,R0, ASR #+1
        MOV      R0,R9
        BL       pseudonoise
        CMP      R0,#+1
        ADD      R0,SP,#+212
        MOVGE    R1,#+4096
        MVNLT    R1,#+255
        BICLT    R1,R1,#0xF00
        STR      R1,[R0, +R11, LSL #+2]
        ADD      R10,R10,#+1
        CMP      R10,#+10
        BLT      ??dtx_dec_22
// 1797 
// 1798       for ( j = 0; j < L_SUBFR; j++ ) {
        MOV      R0,#+0
// 1799          ex[j] = ( level * ex[j] ) >> 15;
??dtx_dec_23:
        ADD      R1,SP,#+212
        ADD      R1,R1,R0, LSL #+2
        LDR      R3,[R1, #+0]
        MOV      R2,R7
        MUL      R2,R3,R2
// 1800       }
        ADD      R0,R0,#+1
        ASR      R2,R2,#+15
        STR      R2,[R1, #+0]
        CMP      R0,#+40
        BLT      ??dtx_dec_23
// 1801 
// 1802       /* Synthesize */
// 1803       Syn_filt( acoeff_variab, ex, &synth[i * L_SUBFR], L_SUBFR, mem_syn, 1 );
        MOV      R0,#+1
        PUSH     {R0}
        CFI CFA R13+544
        LDR      R0,[SP, #+500]
        MOV      R3,#+40
        PUSH     {R0}
        CFI CFA R13+548
        LDR      R1,[SP, #+564]
        MOV      R0,#+160
        MLA      R2,R0,R8,R1
        ADD      R1,SP,#+220
        ADD      R0,SP,#+380
        BL       Syn_filt
// 1804    }   /* next i */
        ADD      R8,R8,#+1
        CMP      R8,#+4
        ADD      SP,SP,#+8
        CFI CFA R13+540
        BLT      ??dtx_dec_21
// 1805 
// 1806    /* reset codebook averaging variables */
// 1807    averState->hangVar = 20;
        LDR      R0,[SP, #+540]
        MOV      R1,#+20
        STRH     R1,[R0, #+32]
// 1808    averState->hangCount = 0;
        LDR      R0,[SP, #+540]
        STR      R6,[R0, #+0]
// 1809 
// 1810    if ( new_state == DTX_MUTE ) {
        LDRB     R0,[SP, #+544]
        CMP      R0,#+2
        BNE      ??dtx_dec_24
// 1811         /*
// 1812          * mute comfort noise as it has been quite a long time since
// 1813          * last SID update  was performed
// 1814          */
// 1815       Word32 num, denom;
// 1816 
// 1817 
// 1818       tmp_int_length = st->since_last_sid;
        LDRSH    R1,[R5, #+0]
// 1819 
// 1820       if ( tmp_int_length > 32 ) {
        CMP      R1,#+33
        BLT      ??dtx_dec_25
// 1821          tmp_int_length = 32;
        MOV      R1,#+32
// 1822       }
// 1823 
// 1824       if ( tmp_int_length == 1 ) {
// 1825          st->true_sid_period_inv = MAX_16;
// 1826       }
// 1827       else {
// 1828          num = 1024;
??dtx_dec_26:
        MOV      R0,#+1024
// 1829          denom = ( tmp_int_length << 10 );
        LSL      R1,R1,#+10
// 1830          st->true_sid_period_inv = 0;
        STR      R6,[R4, #+768]
// 1831 
// 1832          for ( i = 0; i < 15; i++ ) {
        MOV      R8,#+0
// 1833             st->true_sid_period_inv <<= 1;
??dtx_dec_27:
        LDR      R2,[R4, #+768]
// 1834             num <<= 1;
        LSL      R0,R0,#+1
        LSL      R2,R2,#+1
        STR      R2,[R4, #+768]
// 1835 
// 1836             if ( num >= denom ) {
        CMP      R0,R1
// 1837                num = num - denom;
        SUBGE    R0,R0,R1
// 1838                st->true_sid_period_inv += 1;
        ADDGE    R2,R2,#+1
        STRGE    R2,[R4, #+768]
// 1839             }
// 1840          }
        ADD      R8,R8,#+1
        CMP      R8,#+15
        BLT      ??dtx_dec_27
// 1841       }
// 1842       st->since_last_sid = 0;
??dtx_dec_28:
        STRH     R6,[R5, #+0]
// 1843       memcpy( st->lsp_old, st->lsp, M << 2 );
        MOV      R2,#+40
        ADD      R1,R4,#+16
        ADD      R0,R4,#+56
        SWI      +286
// 1844       st->old_log_en = st->log_en;
        LDR      R0,[R4, #+4]
// 1845 
// 1846       /* subtract 1/8 in Q11 i.e -6/8 dB */
// 1847       st->log_en = st->log_en - 256;
        MVN      R1,#+255
        STR      R0,[R4, #+8]
        ADD      R0,R1,R0
        STR      R0,[R4, #+4]
// 1848       if (st->log_en < -32768) st->log_en = -32768;
        CMN      R0,#+32768
        BICLT    R0,R1,#0x7F00
        STRLT    R0,[R4, #+4]
// 1849    }
// 1850 
// 1851      /*
// 1852       * reset interpolation length timer
// 1853       * if data has been updated.
// 1854       */
// 1855    if ( ( st->sid_frame != 0 ) & ( ( st->valid_data != 0 ) || ( ( st->valid_data
// 1856          == 0 ) & ( st->dtxHangoverAdded != 0 ) ) ) ) {
??dtx_dec_24:
        LDRSH    R1,[R5, #+14]
        MOV      R0,#+1
        CMP      R1,#+0
        BEQ      ??dtx_dec_29
        MOV      R1,#+1
        B        ??dtx_dec_29
??dtx_dec_25:
        CMP      R1,#+1
        BNE      ??dtx_dec_26
        MOV      R0,#+255
        ORR      R0,R0,#0x7F00
        STR      R0,[R4, #+768]
        B        ??dtx_dec_28
??dtx_dec_29:
        LDRSH    R2,[R5, #+16]
        CMP      R2,#+0
        BNE      ??dtx_dec_30
        BNE      ??dtx_dec_31
        LDRSH    R2,[R5, #+18]
        CMP      R2,#+0
        BEQ      ??dtx_dec_31
??dtx_dec_30:
        MOV      R2,#+1
        B        ??dtx_dec_32
??dtx_dec_31:
        MOV      R2,#+0
??dtx_dec_32:
        TST      R2,R1
// 1857       st->since_last_sid = 0;
        STRHNE   R6,[R5, #+0]
// 1858       st->data_updated = 1;
        STRHNE   R0,[R5, #+20]
// 1859    }
// 1860    return;
        ADD      SP,SP,#+504
        CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        DATA
??dtx_dec_0:
        DC32     dtx_log_en_adjust
        CFI EndBlock cfiBlock29
// 1861 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock30 Using cfiCommon0
        CFI NoFunction
        THUMB
??Int_lpc_1to3??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock30
        REQUIRE Int_lpc_1to3
// 1862 
// 1863 
// 1864 /*
// 1865  * lsp_avg
// 1866  *
// 1867  *
// 1868  * Parameters:
// 1869  *    st->lsp_meanSave  B: LSP averages
// 1870  *    lsp               I: LSPs
// 1871  *
// 1872  * Function:
// 1873  *    Calculate the LSP averages
// 1874  *
// 1875  * Returns:
// 1876  *    void
// 1877  */
// 1878 static void lsp_avg( lsp_avgState *st, Word32 *lsp )
// 1879 {
// 1880    Word32 i, tmp;
// 1881 
// 1882 
// 1883    for ( i = 0; i < M; i++ ) {
// 1884       /* mean = 0.84*mean */
// 1885       tmp = ( st->lsp_meanSave[i] << 16 );
// 1886       tmp -= ( EXPCONST * st->lsp_meanSave[i] ) << 1;
// 1887 
// 1888       /* Add 0.16 of newest LSPs to mean */
// 1889       tmp += ( EXPCONST * lsp[i] ) << 1;
// 1890 
// 1891       /* Save means */
// 1892       tmp += 0x00008000L;
// 1893       st->lsp_meanSave[i] = tmp >> 16;
// 1894    }
// 1895    return;
// 1896 }
// 1897 
// 1898 
// 1899 /*
// 1900  * Int_lpc_1and3
// 1901  *
// 1902  *
// 1903  * Parameters:
// 1904  *    lsp_old        I: LSP vector at the 4th subfr. of past frame      [M]
// 1905  *    lsp_mid        I: LSP vector at the 2nd subframe of present frame [M]
// 1906  *    lsp_new        I: LSP vector at the 4th subframe of present frame [M]
// 1907  *    Az             O: interpolated LP parameters in subframes 1 and 3
// 1908  *                                                                   [AZ_SIZE]
// 1909  *
// 1910  * Function:
// 1911  *    Interpolates the LSPs and converts to LPC parameters
// 1912  *    to get a different LP filter in each subframe.
// 1913  *
// 1914  *    The 20 ms speech frame is divided into 4 subframes.
// 1915  *    The LSPs are quantized and transmitted at the 2nd and
// 1916  *    4th subframes (twice per frame) and interpolated at the
// 1917  *    1st and 3rd subframe.
// 1918  *
// 1919  * Returns:
// 1920  *    void
// 1921  */
// 1922 static void Int_lpc_1and3( Word32 lsp_old[], Word32 lsp_mid[], Word32 lsp_new[],
// 1923       Word32 Az[] )
// 1924 {
// 1925    Word32 lsp[M];
// 1926    Word32 i;
// 1927 
// 1928 
// 1929    /* lsp[i] = lsp_mid[i] * 0.5 + lsp_old[i] * 0.5 */
// 1930    for ( i = 0; i < 10; i++ ) {
// 1931       lsp[i] = ( lsp_mid[i] >> 1 ) + ( lsp_old[i] >> 1 );
// 1932    }
// 1933 
// 1934    /* Subframe 1 */
// 1935    Lsp_Az( lsp, Az );
// 1936    Az += MP1;
// 1937 
// 1938    /* Subframe 2 */
// 1939    Lsp_Az( lsp_mid, Az );
// 1940    Az += MP1;
// 1941 
// 1942    for ( i = 0; i < 10; i++ ) {
// 1943       lsp[i] = ( lsp_mid[i] >> 1 ) + ( lsp_new[i] >> 1 );
// 1944    }
// 1945 
// 1946    /* Subframe 3 */
// 1947    Lsp_Az( lsp, Az );
// 1948    Az += MP1;
// 1949 
// 1950    /* Subframe 4 */
// 1951    Lsp_Az( lsp_new, Az );
// 1952    return;
// 1953 }
// 1954 
// 1955 
// 1956 /*
// 1957  * Int_lpc_1to3
// 1958  *
// 1959  *
// 1960  * Parameters:
// 1961  *    lsp_old           I: LSP vector at the 4th subframe of past frame    [M]
// 1962  *    lsp_new           I: LSP vector at the 4th subframe of present frame [M]
// 1963  *    Az                O: interpolated LP parameters in all subframes
// 1964  *                                                                   [AZ_SIZE]
// 1965  *
// 1966  * Function:
// 1967  *    Interpolates the LSPs and converts to LPC parameters to get a different
// 1968  *    LP filter in each subframe.
// 1969  *
// 1970  *    The 20 ms speech frame is divided into 4 subframes.
// 1971  *    The LSPs are quantized and transmitted at the 4th
// 1972  *    subframes (once per frame) and interpolated at the
// 1973  *    1st, 2nd and 3rd subframe.
// 1974  *
// 1975  * Returns:
// 1976  *    void
// 1977  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock31 Using cfiCommon1
        CFI Function Int_lpc_1to3
        ARM
// 1978 static void Int_lpc_1to3( Word32 lsp_old[], Word32 lsp_new[], Word32 Az[] )
// 1979 {
Int_lpc_1to3:
        PUSH     {R4-R6,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
        SUB      SP,SP,#+40
        CFI CFA R13+56
        MOV      R4,R0
        MOV      R5,R1
        MOV      R6,R2
// 1980    Word32 lsp[M];
// 1981    Word32 i;
// 1982 
// 1983 
// 1984    for ( i = 0; i < 10; i++ ) {
        MOV      R0,#+0
        MOV      R1,SP
// 1985       lsp[i] = ( lsp_new[i] >> 2 ) + ( lsp_old[i] - ( lsp_old[i] >> 2 ) );
??Int_lpc_1to3_0:
        LDR      R2,[R5, +R0, LSL #+2]
        LDR      R3,[R4, +R0, LSL #+2]
        ADD      R2,R3,R2, ASR #+2
        SUB      R2,R2,R3, ASR #+2
        STR      R2,[R1, +R0, LSL #+2]
// 1986    }
        ADD      R0,R0,#+1
        CMP      R0,#+10
        BLT      ??Int_lpc_1to3_0
// 1987 
// 1988    /* Subframe 1 */
// 1989    Lsp_Az( lsp, Az );
        MOV      R1,R6
        MOV      R0,SP
        BL       Lsp_Az
// 1990    Az += MP1;
        ADD      R6,R6,#+44
// 1991 
// 1992    for ( i = 0; i < 10; i++ ) {
        MOV      R0,#+0
        MOV      R1,SP
// 1993       lsp[i] = ( lsp_old[i] >> 1 ) + ( lsp_new[i] >> 1 );
??Int_lpc_1to3_1:
        LDR      R2,[R4, +R0, LSL #+2]
        LDR      R3,[R5, +R0, LSL #+2]
        ASR      R3,R3,#+1
        ADD      R2,R3,R2, ASR #+1
        STR      R2,[R1, +R0, LSL #+2]
// 1994    }
        ADD      R0,R0,#+1
        CMP      R0,#+10
        BLT      ??Int_lpc_1to3_1
// 1995 
// 1996    /* Subframe 2 */
// 1997    Lsp_Az( lsp, Az );
        MOV      R1,R6
        MOV      R0,SP
        BL       Lsp_Az
// 1998    Az += MP1;
        ADD      R6,R6,#+44
// 1999 
// 2000    for ( i = 0; i < 10; i++ ) {
        MOV      R0,#+0
        MOV      R1,SP
// 2001       lsp[i] = ( lsp_old[i] >> 2 ) + ( lsp_new[i] - ( lsp_new[i] >> 2 ) );
??Int_lpc_1to3_2:
        LDR      R2,[R4, +R0, LSL #+2]
        LDR      R3,[R5, +R0, LSL #+2]
        ADD      R2,R3,R2, ASR #+2
        SUB      R2,R2,R3, ASR #+2
        STR      R2,[R1, +R0, LSL #+2]
// 2002    }
        ADD      R0,R0,#+1
        CMP      R0,#+10
        BLT      ??Int_lpc_1to3_2
// 2003 
// 2004    /* Subframe 3 */
// 2005    Lsp_Az( lsp, Az );
        MOV      R1,R6
        MOV      R0,SP
        BL       Lsp_Az
// 2006    Az += MP1;
// 2007 
// 2008    /* Subframe 4 */
// 2009    Lsp_Az( lsp_new, Az );
        ADD      R1,R6,#+44
        MOV      R0,R5
        BL       Lsp_Az
// 2010    return;
        ADD      SP,SP,#+40
        CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
        CFI EndBlock cfiBlock31
// 2011 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock32 Using cfiCommon0
        CFI NoFunction
        THUMB
??D_plsf_5??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock32
        REQUIRE D_plsf_5
// 2012 
// 2013 
// 2014 /*
// 2015  * D_plsf_5
// 2016  *
// 2017  *
// 2018  * Parameters:
// 2019  *    st->past_lsf_q I: Past dequantized LFSs
// 2020  *    st->past_r_q      B: past quantized residual
// 2021  *    bfi               B: bad frame indicator
// 2022  *    indice            I: quantization indices of 3 submatrices, Q0
// 2023  *    lsp1_q            O: quantized 1st LSP vector
// 2024  *    lsp2_q            O: quantized 2nd LSP vector
// 2025  *
// 2026  * Function:
// 2027  *    Decodes the 2 sets of LSP parameters in a frame
// 2028  *    using the received quantization indices.
// 2029  *
// 2030  * Returns:
// 2031  *    void
// 2032  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock33 Using cfiCommon1
        CFI Function D_plsf_5
        ARM
// 2033 static void D_plsf_5( D_plsfState *st, Word16 bfi, Word16 *indice, Word32 *lsp1_q
// 2034       , Word32 *lsp2_q )
// 2035 {
D_plsf_5:
        PUSH     {R4-R9,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R9 Frame(CFA, -8)
        CFI R8 Frame(CFA, -12)
        CFI R7 Frame(CFA, -16)
        CFI R6 Frame(CFA, -20)
        CFI R5 Frame(CFA, -24)
        CFI R4 Frame(CFA, -28)
        CFI CFA R13+28
// 2036    Word32 lsf1_r[M], lsf2_r[M], lsf1_q[M], lsf2_q[M];
// 2037    Word32 i, temp1, temp2, sign;
// 2038    const Word32 *p_dico;
// 2039 
// 2040 
// 2041    /* if bad frame */
// 2042    if ( bfi != 0 ) {
        LDR      R7,??D_plsf_5_0  ;; mean_lsf_5
        SUB      SP,SP,#+160
        CFI CFA R13+188
        LDR      R6,[SP, #+188]
        MOV      R4,R0
        MOV      R5,R3
        CMP      R1,#+0
        BEQ      ??D_plsf_5_1
// 2043       /* use the past LSFs slightly shifted towards their mean */
// 2044       for ( i = 0; i < M; i += 2 ) {
        MOV      R0,#+0
// 2045          /* lsfi_q[i] = ALPHA*st->past_lsf_q[i] + ONE_ALPHA*meanLsf[i]; */
// 2046          lsf1_q[i] = ( ( st->past_lsf_q[i] * ALPHA_122 ) >> 15 ) + ( ( mean_lsf_5[i]
// 2047                * ONE_ALPHA_122 ) >> 15 );
??D_plsf_5_2:
        ADD      R3,R4,R0, LSL #+2
        LDR      R3,[R3, #+40]
        ADD      R2,R7,R0, LSL #+2
        MOV      R12,#+152
        ORR      R12,R12,#0x7900
        MUL      R3,R12,R3
        LDR      R12,[R2, #+0]
        MOV      LR,#+103
        ORR      LR,LR,#0x600
        MUL      R12,LR,R12
        ADD      R1,SP,#+80
        ADD      R1,R1,R0, LSL #+2
        ASR      R12,R12,#+15
        ADD      R3,R12,R3, ASR #+15
        STR      R3,[R1, #+0]
// 2048          lsf1_q[i + 1] = ( ( st->past_lsf_q[i + 1] * ALPHA_122 ) >> 15 ) + ( (
// 2049                mean_lsf_5[i + 1] * ONE_ALPHA_122 ) >> 15 );
        LDR      R2,[R2, #+4]
        ADD      R3,R0,#+1
        ADD      R3,R4,R3, LSL #+2
        LDR      R3,[R3, #+40]
        MOV      R12,#+152
        ORR      R12,R12,#0x7900
        MUL      R3,R12,R3
        MUL      R2,LR,R2
// 2050       }
        ADD      R0,R0,#+2
        ASR      R2,R2,#+15
        ADD      R2,R2,R3, ASR #+15
        STR      R2,[R1, #+4]
        CMP      R0,#+10
        BLT      ??D_plsf_5_2
// 2051       memcpy( lsf2_q, lsf1_q, M <<2 );
        MOV      R2,#+40
        ADD      R1,SP,#+80
        ADD      R0,SP,#+120
        SWI      +286
// 2052 
// 2053       /* estimate past quantized residual to be used in next frame */
// 2054       for ( i = 0; i < M; i += 2 ) {
        MOV      R0,#+0
        MOV      R9,#+51
        ORR      R9,R9,#0x5300
// 2055          /* temp  = meanLsf[i] +  st->past_r_q[i] * LSPPpred_facMR122; */
// 2056          temp1 = mean_lsf_5[i] + ( ( st->past_r_q[i] * LSP_PRED_FAC_MR122 ) >>
// 2057                15 );
// 2058          temp2 = mean_lsf_5[i + 1] +( ( st->past_r_q[i + 1] *LSP_PRED_FAC_MR122
// 2059                ) >> 15 );
??D_plsf_5_3:
        ADD      R1,R4,R0, LSL #+2
        LDR      R12,[R1, #+4]
        ADD      R2,R7,R0, LSL #+2
        LDR      R3,[R2, #+4]
// 2060          st->past_r_q[i] = lsf2_q[i] - temp1;
        LDR      R2,[R2, #+0]
        MUL      R12,R9,R12
        ADD      LR,SP,#+120
        ADD      LR,LR,R0, LSL #+2
        LDR      R8,[LR, #+0]
        ADD      R3,R3,R12, ASR #+15
        ADD      R12,R4,R0, LSL #+2
        SUB      R2,R8,R2
        LDR      R8,[R12, #+0]
// 2061          st->past_r_q[i + 1] = lsf2_q[i + 1] -temp2;
// 2062       }
        ADD      R0,R0,#+2
        MUL      R8,R9,R8
        CMP      R0,#+10
        SUB      R2,R2,R8, ASR #+15
        STR      R2,[R12, #+0]
        LDR      R2,[LR, #+4]
        SUB      R2,R2,R3
        STR      R2,[R1, #+4]
        BGE      ??D_plsf_5_4
        B        ??D_plsf_5_3
// 2063    }
// 2064 
// 2065    /* if good LSFs received */
// 2066    else {
// 2067       /* decode prediction residuals from 5 received indices */
// 2068       p_dico = &dico1_lsf_5[indice[0] << 2];
??D_plsf_5_1:
        LDRSH    R0,[R2, #+0]
        ADD      R0,R7,R0, LSL #+4
        ADD      R0,R0,#+40
// 2069       lsf1_r[0] = *p_dico++;
        LDR      R3,[R0], #+4
        STR      R3,[SP, #+0]
// 2070       lsf1_r[1] = *p_dico++;
        LDR      R3,[R0], #+4
        STR      R3,[SP, #+4]
// 2071       lsf2_r[0] = *p_dico++;
        LDR      R3,[R0], #+4
        STR      R3,[SP, #+40]
// 2072       lsf2_r[1] = *p_dico++;
        LDR      R0,[R0, #+0]
        STR      R0,[SP, #+44]
// 2073       p_dico = &dico2_lsf_5[indice[1] << 2];
        LDRSH    R1,[R2, #+2]
        MOV      R0,#+40
        ORR      R0,R0,#0x800
        ADD      R1,R7,R1, LSL #+4
        ADD      R0,R0,R1
// 2074       lsf1_r[2] = *p_dico++;
        LDR      R3,[R0], #+4
        STR      R3,[SP, #+8]
// 2075       lsf1_r[3] = *p_dico++;
        LDR      R3,[R0], #+4
        STR      R3,[SP, #+12]
// 2076       lsf2_r[2] = *p_dico++;
        LDR      R3,[R0], #+4
        STR      R3,[SP, #+48]
// 2077       lsf2_r[3] = *p_dico++;
        LDR      R0,[R0, #+0]
        STR      R0,[SP, #+52]
// 2078       sign = ( Word16 )( indice[2] & 1 );
// 2079       i = indice[2] >> 1;
// 2080       p_dico = &dico3_lsf_5[i << 2];
        LDRSH    R1,[R2, #+4]
        MOV      R0,#+40
        ORR      R0,R0,#0x1800
        ASR      R1,R1,#+1
        ADD      R1,R7,R1, LSL #+4
        ADD      R0,R0,R1
// 2081 
// 2082       if ( sign == 0 ) {
        LDRSH    R1,[R2, #+4]
        LDR      R3,[R0], #+4
        TST      R1,#0x1
        BNE      ??D_plsf_5_5
// 2083          lsf1_r[4] = *p_dico++;
        STR      R3,[SP, #+16]
// 2084          lsf1_r[5] = *p_dico++;
        LDR      R3,[R0], #+4
        STR      R3,[SP, #+20]
// 2085          lsf2_r[4] = *p_dico++;
        LDR      R3,[R0], #+4
        STR      R3,[SP, #+56]
// 2086          lsf2_r[5] = *p_dico++;
        LDR      R0,[R0, #+0]
        B        ??D_plsf_5_6
// 2087       }
// 2088       else {
// 2089          lsf1_r[4] = ( Word16 )( -( *p_dico++ ) );
??D_plsf_5_5:
        RSB      R3,R3,#+0
        MOV      R3,R3, LSL #+16
        MOV      R3,R3, ASR #+16
        STR      R3,[SP, #+16]
// 2090          lsf1_r[5] = ( Word16 )( -( *p_dico++ ) );
        LDR      R3,[R0], #+4
        RSB      R3,R3,#+0
        MOV      R3,R3, LSL #+16
        MOV      R3,R3, ASR #+16
        STR      R3,[SP, #+20]
// 2091          lsf2_r[4] = ( Word16 )( -( *p_dico++ ) );
        LDR      R3,[R0], #+4
        RSB      R3,R3,#+0
        MOV      R3,R3, LSL #+16
        MOV      R3,R3, ASR #+16
        STR      R3,[SP, #+56]
// 2092          lsf2_r[5] = ( Word16 )( -( *p_dico++ ) );
        LDR      R0,[R0, #+0]
        RSB      R0,R0,#+0
        MOV      R0,R0, LSL #+16
        MOV      R0,R0, ASR #+16
??D_plsf_5_6:
        STR      R0,[SP, #+60]
// 2093       }
// 2094       p_dico = &dico4_lsf_5[( indice[3]<<2 )];
        LDRSH    R1,[R2, #+6]
        MOV      R0,#+40
        ORR      R0,R0,#0x2800
        ADD      R1,R7,R1, LSL #+4
        ADD      R0,R0,R1
// 2095       lsf1_r[6] = *p_dico++;
        LDR      R3,[R0], #+4
        STR      R3,[SP, #+24]
// 2096       lsf1_r[7] = *p_dico++;
        LDR      R3,[R0], #+4
        STR      R3,[SP, #+28]
// 2097       lsf2_r[6] = *p_dico++;
        LDR      R3,[R0], #+4
        STR      R3,[SP, #+64]
// 2098       lsf2_r[7] = *p_dico++;
        LDR      R0,[R0, #+0]
        STR      R0,[SP, #+68]
// 2099       p_dico = &dico5_lsf_5[( indice[4]<<2 )];
        LDRSH    R1,[R2, #+8]
        MOV      R0,#+40
        ORR      R0,R0,#0x3800
        ADD      R1,R7,R1, LSL #+4
        ADD      R0,R0,R1
// 2100       lsf1_r[8] = *p_dico++;
        LDR      R2,[R0], #+4
        STR      R2,[SP, #+32]
// 2101       lsf1_r[9] = *p_dico++;
        LDR      R2,[R0], #+4
        STR      R2,[SP, #+36]
// 2102       lsf2_r[8] = *p_dico++;
        LDR      R2,[R0], #+4
        STR      R2,[SP, #+72]
// 2103       lsf2_r[9] = *p_dico++;
        LDR      R0,[R0, #+0]
        STR      R0,[SP, #+76]
// 2104 
// 2105       /* Compute quantized LSFs and update the past quantized residual */
// 2106       for ( i = 0; i < M; i++ ) {
        MOV      R0,#+0
// 2107          temp1 = mean_lsf_5[i] + ( ( st->past_r_q[i] * LSP_PRED_FAC_MR122 ) >>
// 2108                15 );
??D_plsf_5_7:
        LDR      R2,[R7, +R0, LSL #+2]
        ADD      R1,R4,R0, LSL #+2
        LDR      R3,[R1, #+0]
        MOV      R8,#+51
        ORR      R8,R8,#0x5300
        MUL      R3,R8,R3
// 2109          lsf1_q[i] = lsf1_r[i] + temp1;
        MOV      R8,SP
        LDR      R8,[R8, +R0, LSL #+2]
        ADD      R2,R2,R3, ASR #+15
        ADD      R3,SP,#+80
        ADD      R8,R2,R8
        STR      R8,[R3, +R0, LSL #+2]
// 2110          lsf2_q[i] = lsf2_r[i] + temp1;
        ADD      R3,SP,#+40
        LDR      R3,[R3, +R0, LSL #+2]
        ADD      R8,SP,#+120
        ADD      R2,R2,R3
        STR      R2,[R8, +R0, LSL #+2]
// 2111          st->past_r_q[i] = lsf2_r[i];
        STR      R3,[R1, #+0]
// 2112       }
        ADD      R0,R0,#+1
        CMP      R0,#+10
        BLT      ??D_plsf_5_7
// 2113    }
// 2114 
// 2115    /* verification that LSFs have minimum distance of LSF_GAP Hz */
// 2116    Reorder_lsf( lsf1_q, LSF_GAP );
??D_plsf_5_4:
        MOV      R1,#+205
        ADD      R0,SP,#+80
        BL       Reorder_lsf
// 2117    Reorder_lsf( lsf2_q, LSF_GAP );
        MOV      R1,#+205
        ADD      R0,SP,#+120
        BL       Reorder_lsf
// 2118    memcpy( st->past_lsf_q, lsf2_q, M <<2 );
        MOV      R2,#+40
        ADD      R1,SP,#+120
        ADD      R0,R4,#+40
        SWI      +286
// 2119 
// 2120    /*  convert LSFs to the cosine domain */
// 2121    Lsf_lsp( lsf1_q, lsp1_q );
        MOV      R1,R5
        ADD      R0,SP,#+80
        BL       Lsf_lsp
// 2122    Lsf_lsp( lsf2_q, lsp2_q );
        MOV      R1,R6
        ADD      R0,SP,#+120
        BL       Lsf_lsp
// 2123    return;
        ADD      SP,SP,#+160
        CFI CFA R13+28
        POP      {R4-R9,PC}       ;; return
        DATA
??D_plsf_5_0:
        DC32     mean_lsf_5
        CFI EndBlock cfiBlock33
// 2124 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock34 Using cfiCommon0
        CFI NoFunction
        THUMB
??Dec_lag3??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock34
        REQUIRE Dec_lag3
// 2125 
// 2126 
// 2127 /*
// 2128  * Dec_lag3
// 2129  *
// 2130  *
// 2131  * Parameters:
// 2132  *    index             I: received pitch index
// 2133  *    t0_min            I: minimum of search range
// 2134  *    t0_max            I: maximum of search range
// 2135  *    i_subfr           I: subframe flag
// 2136  *    T0_prev           I: integer pitch delay of last subframe used
// 2137  *                         in 2nd and 4th subframes
// 2138  *    T0                O: integer part of pitch lag
// 2139  *    T0_frac           O : fractional part of pitch lag
// 2140  *    flag4             I : flag for encoding with 4 bits
// 2141  * Function:
// 2142  *    Decoding of fractional pitch lag with 1/3 resolution.
// 2143  *    Extract the integer and fraction parts of the pitch lag from
// 2144  *    the received adaptive codebook index.
// 2145  *
// 2146  *    The fractional lag in 1st and 3rd subframes is encoded with 8 bits
// 2147  *    while that in 2nd and 4th subframes is relatively encoded with 4, 5
// 2148  *    and 6 bits depending on the mode.
// 2149  *
// 2150  * Returns:
// 2151  *    void
// 2152  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock35 Using cfiCommon1
        CFI Function Dec_lag3
        ARM
// 2153 static void Dec_lag3( Word32 index, Word32 t0_min, Word32 t0_max, Word32 i_subfr
// 2154       , Word32 T0_prev, Word32 *T0, Word32 *T0_frac, Word32 flag4 )
// 2155 {
Dec_lag3:
        PUSH     {R4-R8}
        CFI R8 Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
// 2156    Word32 i, tmp_lag;
// 2157 
// 2158 
// 2159    /* if 1st or 3rd subframe */
// 2160    if ( i_subfr == 0 ) {
        ADD      R7,R0,#+2
        LDR      R12,[SP, #+20]
        LDR      R4,[SP, #+24]
        LDR      R5,[SP, #+28]
        LDR      R6,[SP, #+32]
        MOV      R8,#+171
        ORR      R8,R8,#0x2A00
        MUL      R7,R8,R7
        CMP      R3,#+0
        ASR      R7,R7,#+15
        BNE      ??Dec_lag3_0
// 2161       if ( index < 197 ) {
        CMP      R0,#+197
        BGE      ??Dec_lag3_1
// 2162          *T0 = ( ( ( index + 2 ) * 10923 ) >> 15 ) + 19;
        ADD      R1,R7,#+19
// 2163          i = *T0 + *T0 + *T0;
// 2164          *T0_frac = ( index - i ) + 58;
        MVN      R2,#+2
        MLA      R0,R2,R1,R0
        STR      R1,[R4, #+0]
        ADD      R0,R0,#+58
        B        ??Dec_lag3_2
// 2165       }
// 2166       else {
// 2167          *T0 = index - 112;
??Dec_lag3_1:
        SUB      R0,R0,#+112
        B        ??Dec_lag3_3
// 2168          *T0_frac = 0;
// 2169       }
// 2170    }
// 2171 
// 2172    /* 2nd or 4th subframe */
// 2173    else {
// 2174       if ( flag4 == 0 ) {
??Dec_lag3_0:
        CMP      R6,#+0
        BNE      ??Dec_lag3_4
// 2175          /* 'normal' decoding: either with 5 or 6 bit resolution */
// 2176          i = ( ( ( index + 2 ) * 10923 ) >> 15 ) - 1;
        SUB      R2,R7,#+1
// 2177          *T0 = i + t0_min;
        ADD      R1,R1,R2
        STR      R1,[R4, #+0]
// 2178          i = i + i + i;
// 2179          *T0_frac = ( index - 2 ) - i;
        MVN      R1,#+2
        MLA      R0,R1,R2,R0
        SUB      R0,R0,#+2
??Dec_lag3_2:
        STR      R0,[R5, #+0]
        POP      {R4-R8}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI CFA R13+0
        BX       LR
        CFI R4 Frame(CFA, -20)
        CFI R5 Frame(CFA, -16)
        CFI R6 Frame(CFA, -12)
        CFI R7 Frame(CFA, -8)
        CFI R8 Frame(CFA, -4)
        CFI CFA R13+20
// 2180       }
// 2181       else {
// 2182          /* decoding with 4 bit resolution */
// 2183          tmp_lag = T0_prev;
// 2184 
// 2185          if ( ( tmp_lag - t0_min ) > 5 )
??Dec_lag3_4:
        SUB      R3,R12,R1
        CMP      R3,#+6
// 2186             tmp_lag = t0_min + 5;
        ADDGE    R12,R1,#+5
// 2187 
// 2188          if ( ( t0_max - tmp_lag ) > 4 )
        SUB      R1,R2,R12
        CMP      R1,#+5
// 2189             tmp_lag = t0_max - 4;
        SUBGE    R12,R2,#+4
// 2190 
// 2191          if ( index < 4 ) {
        CMP      R0,#+4
// 2192             i = ( tmp_lag - 5 );
// 2193             *T0 = i + index;
        ADDLT    R0,R0,R12
        SUBLT    R0,R0,#+5
        BLT      ??Dec_lag3_3
// 2194             *T0_frac = 0;
// 2195          }
// 2196          else {
// 2197             if ( index < 12 ) {
        CMP      R0,#+12
        BGE      ??Dec_lag3_5
// 2198                i = ( ( ( index - 5 ) * 10923 ) >> 15 ) - 1;
        SUB      R1,R0,#+5
        MUL      R1,R8,R1
        ASR      R1,R1,#+15
        SUB      R2,R1,#+1
// 2199                *T0 = i + tmp_lag;
        ADD      R1,R12,R2
        STR      R1,[R4, #+0]
// 2200                i = i + i + i;
// 2201                *T0_frac = ( index - 9 ) - i;
        MVN      R1,#+2
        MLA      R0,R1,R2,R0
        SUB      R0,R0,#+9
        B        ??Dec_lag3_2
// 2202             }
// 2203             else {
// 2204                i = ( index - 12 ) + tmp_lag;
// 2205                *T0 = i + 1;
??Dec_lag3_5:
        ADD      R0,R12,R0
        SUB      R0,R0,#+11
??Dec_lag3_3:
        STR      R0,[R4, #+0]
// 2206                *T0_frac = 0;
        MOV      R0,#+0
        B        ??Dec_lag3_2
        CFI EndBlock cfiBlock35
// 2207             }
// 2208          }
// 2209       }   /* end if (decoding with 4 bit resolution) */
// 2210    }
// 2211    return;
// 2212 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock36 Using cfiCommon0
        CFI NoFunction
        THUMB
??Pred_lt_3or6_40??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock36
        REQUIRE Pred_lt_3or6_40
// 2213 
// 2214 
// 2215 /*
// 2216  * Pred_lt_3or6_40
// 2217  *
// 2218  *
// 2219  * Parameters:
// 2220  *    exc               B: excitation buffer
// 2221  *    T0                I: integer pitch lag
// 2222  *    frac              I: fraction of lag
// 2223  *    flag3             I: if set, upsampling rate = 3 (6 otherwise)
// 2224  *
// 2225  * Function:
// 2226  *    Compute the result of long term prediction with fractional
// 2227  *    interpolation of resolution 1/3 or 1/6. (Interpolated past excitation).
// 2228  *
// 2229  *    Once the fractional pitch lag is determined,
// 2230  *    the adaptive codebook vector v(n) is computed by interpolating
// 2231  *    the past excitation signal u(n) at the given integer delay k
// 2232  *    and phase (fraction)  :
// 2233  *
// 2234  *          9                       9
// 2235  *    v(n) = SUM[ u(n-k-i) * b60(t+i*6) ] + SUM[ u(n-k+1+i) * b60(6-t+i*6) ],
// 2236  *          i=0                       i=0
// 2237  *    n = 0, ...,39, t = 0, ...,5.
// 2238  *
// 2239  *    The interpolation filter b60 is based on a Hamming windowed sin(x)/x
// 2240  *    function truncated at  59 and padded with zeros at  60 (b60(60)=0)).
// 2241  *    The filter has a cut-off frequency (-3 dB) at 3 600 Hz in
// 2242  *    the over-sampled domain.
// 2243  *
// 2244  * Returns:
// 2245  *    void
// 2246  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock37 Using cfiCommon1
        CFI Function Pred_lt_3or6_40
        ARM
// 2247 static void Pred_lt_3or6_40( Word32 exc[], Word32 T0, Word32 frac, Word32 flag3 )
// 2248 {
// 2249    Word32 s, i;
// 2250    Word32 *x0, *x1, *x2;
// 2251    const Word32 *c1, *c2;
// 2252 
// 2253 
// 2254    x0 = &exc[ - T0];
// 2255    frac = -frac;
// 2256 
// 2257    if ( flag3 != 0 ) {
Pred_lt_3or6_40:
        CMP      R3,#+0
// 2258       frac <<= 1;   /* inter_3l[k] = inter6[2*k] -> k' = 2*k */
// 2259    }
// 2260 
// 2261    if ( frac < 0 ) {
// 2262       frac += 6;
// 2263       x0--;
// 2264    }
// 2265    c1 = &inter6[frac];
        LDR      R3,??Pred_lt_3or6_40_0  ;; inter6
        PUSH     {R4-R8}
        CFI R8 Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
        RSB      R1,R1,#+0
        ADD      R1,R0,R1, LSL #+2
        RSB      R4,R2,#+0
        LSLNE    R4,R4,#+1
        CMP      R4,#+0
        ADDMI    R4,R4,#+6
        SUBMI    R1,R1,#+4
        ADD      R2,R3,R4, LSL #+2
// 2266    c2 = &inter6[6 - frac];
        RSB      R4,R4,#+0
        ADD      R3,R3,R4, LSL #+2
        ADD      R3,R3,#+24
// 2267 
// 2268    for ( i = 0; i < 40; i++ ) {
        MOV      R12,#+0
// 2269       x1 = x0++;
// 2270       x2 = x0;
// 2271       s = x1[0] * c1[0];
// 2272       s += x1[ - 1] * c1[6];
// 2273       s += x1[ - 2] * c1[12];
// 2274       s += x1[ - 3] * c1[18];
// 2275       s += x1[ - 4] * c1[24];
// 2276       s += x1[ - 5] * c1[30];
// 2277       s += x1[ - 6] * c1[36];
// 2278       s += x1[ - 7] * c1[42];
// 2279       s += x1[ - 8] * c1[48];
// 2280       s += x1[ - 9] * c1[54];
// 2281       s += x2[0] * c2[0];
// 2282       s += x2[1] * c2[6];
// 2283       s += x2[2] * c2[12];
// 2284       s += x2[3] * c2[18];
// 2285       s += x2[4] * c2[24];
// 2286       s += x2[5] * c2[30];
// 2287       s += x2[6] * c2[36];
// 2288       s += x2[7] * c2[42];
// 2289       s += x2[8] * c2[48];
// 2290       s += x2[9] * c2[54];
// 2291       exc[i] = ( s + 0x4000 ) >> 15;
??Pred_lt_3or6_40_1:
        LDR      R7,[R3, #+216]
        LDR      R8,[R2, #+0]
        MOV      R5,R1
        ADD      R1,R1,#+4
        LDR      R6,[R1, #+36]
        SUB      R4,R5,#+36
        LDR      R5,[R5, #+0]
        MUL      R5,R8,R5
        MLA      R5,R7,R6,R5
        LDR      R6,[R4, #+32]
        LDR      R7,[R2, #+24]
        MLA      R5,R7,R6,R5
        LDR      R6,[R4, #+28]
        LDR      R7,[R2, #+48]
        MLA      R5,R7,R6,R5
        LDR      R6,[R4, #+24]
        LDR      R7,[R2, #+72]
        MLA      R5,R7,R6,R5
        LDR      R6,[R4, #+20]
        LDR      R7,[R2, #+96]
        MLA      R5,R7,R6,R5
        LDR      R6,[R4, #+16]
        LDR      R7,[R2, #+120]
        MLA      R5,R7,R6,R5
        LDR      R6,[R4, #+12]
        LDR      R7,[R2, #+144]
        MLA      R5,R7,R6,R5
        LDR      R6,[R4, #+8]
        LDR      R7,[R2, #+168]
        MLA      R5,R7,R6,R5
        LDR      R6,[R4, #+4]
        LDR      R7,[R2, #+192]
        LDR      R4,[R4, #+0]
        MLA      R5,R7,R6,R5
        LDR      R6,[R2, #+216]
        MLA      R4,R6,R4,R5
        LDR      R5,[R1, #+0]
        LDR      R6,[R3, #+0]
        MLA      R4,R6,R5,R4
        LDR      R5,[R1, #+4]
        LDR      R6,[R3, #+24]
        MLA      R4,R6,R5,R4
        LDR      R5,[R1, #+8]
        LDR      R6,[R3, #+48]
        MLA      R4,R6,R5,R4
        LDR      R5,[R1, #+12]
        LDR      R6,[R3, #+72]
        MLA      R4,R6,R5,R4
        LDR      R5,[R1, #+16]
        LDR      R6,[R3, #+96]
        MLA      R4,R6,R5,R4
        LDR      R5,[R1, #+20]
        LDR      R6,[R3, #+120]
        MLA      R4,R6,R5,R4
        LDR      R5,[R1, #+24]
        LDR      R6,[R3, #+144]
        MLA      R4,R6,R5,R4
        LDR      R5,[R1, #+28]
        LDR      R6,[R3, #+168]
        MLA      R4,R6,R5,R4
        LDR      R5,[R1, #+32]
        LDR      R6,[R3, #+192]
        MLA      R4,R6,R5,R4
        ADD      R4,R4,#+16384
        ASR      R4,R4,#+15
        STR      R4,[R0, +R12, LSL #+2]
// 2292 
// 2293    }
        ADD      R12,R12,#+1
        CMP      R12,#+40
        BLT      ??Pred_lt_3or6_40_1
// 2294 }
        POP      {R4-R8}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        DATA
??Pred_lt_3or6_40_0:
        DC32     inter6
        CFI EndBlock cfiBlock37

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock38 Using cfiCommon0
        CFI NoFunction
        THUMB
??decompress_codewords??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock38
        REQUIRE decompress_codewords
// 2295 
// 2296 
// 2297 /*
// 2298  * Dec_lag6
// 2299  *
// 2300  *
// 2301  * Parameters:
// 2302  *    index             I: received pitch index
// 2303  *    pit_min           I: minimum pitch lag
// 2304  *    pit_max           I: maximum pitch lag
// 2305  *    i_subfr           I: subframe flag
// 2306  *    T0                B: integer part of pitch lag
// 2307  *    T0_frac           O : fractional part of pitch lag
// 2308  *
// 2309  * Function:
// 2310  *    Decoding of fractional pitch lag with 1/6 resolution.
// 2311  *    Extract the integer and fraction parts of the pitch lag from
// 2312  *    the received adaptive codebook index.
// 2313  *
// 2314  *    The fractional lag in 1st and 3rd subframes is encoded with 9 bits
// 2315  *    while that in 2nd and 4th subframes is relatively encoded with 6 bits.
// 2316  *    Note that in relative encoding only 61 values are used. If the
// 2317  *    decoder receives 61, 62, or 63 as the relative pitch index, it means
// 2318  *    that a transmission error occurred. In this case, the pitch lag from
// 2319  *    previous subframe (actually from previous frame) is used.
// 2320  *
// 2321  * Returns:
// 2322  *    void
// 2323  */
// 2324 static void Dec_lag6( Word32 index, Word32 pit_min, Word32 pit_max, Word32
// 2325       i_subfr, Word32 *T0, Word32 *T0_frac )
// 2326 {
// 2327    Word32 t0_min, t0_max, i;
// 2328 
// 2329 
// 2330    /* if 1st or 3rd subframe */
// 2331    if ( i_subfr == 0 ) {
// 2332       if ( index < 463 ) {
// 2333          /* T0 = (index+5)/6 + 17 */
// 2334          *T0 = ( index + 5 ) / 6 + 17;
// 2335          i = *T0 + *T0 + *T0;
// 2336 
// 2337          /* *T0_frac = index - T0*6 + 105 */
// 2338          *T0_frac = ( index - ( i + i ) ) + 105;
// 2339       }
// 2340       else {
// 2341          *T0 = index - 368;
// 2342          *T0_frac = 0;
// 2343       }
// 2344    }
// 2345 
// 2346    /* second or fourth subframe */
// 2347    else {
// 2348       /* find t0_min and t0_max for 2nd (or 4th) subframe */
// 2349       t0_min = *T0 - 5;
// 2350 
// 2351       if ( t0_min < pit_min ) {
// 2352          t0_min = pit_min;
// 2353       }
// 2354       t0_max = t0_min + 9;
// 2355 
// 2356       if ( t0_max > pit_max ) {
// 2357          t0_max = pit_max;
// 2358          t0_min = t0_max - 9;
// 2359       }
// 2360 
// 2361       /* i = (index+5)/6 - 1 */
// 2362       i = ( index + 5 ) / 6 - 1;
// 2363       *T0 = i + t0_min;
// 2364       i = i + i + i;
// 2365       *T0_frac = ( index - 3 ) - ( i + i );
// 2366    }
// 2367 }
// 2368 
// 2369 
// 2370 /*
// 2371  * decompress10
// 2372  *
// 2373  *
// 2374  * Parameters:
// 2375  *    MSBs              I: MSB part of the index
// 2376  *    LSBs              I: LSB part of the index
// 2377  *    index1            I: index for first pos in posIndex
// 2378  *    index2            I: index for second pos in posIndex
// 2379  *    index3            I: index for third pos in posIndex
// 2380  *    pos_indx          O: position of 3 pulses (decompressed)
// 2381  * Function:
// 2382  *    Decompression of the linear codeword
// 2383  *
// 2384  * Returns:
// 2385  *    void
// 2386  */
// 2387 static void decompress10( Word32 MSBs, Word32 LSBs, Word32 index1, Word32 index2
// 2388       , Word32 index3, Word32 pos_indx[] )
// 2389 {
// 2390    Word32 divMSB;
// 2391 
// 2392    if (MSBs > 124)
// 2393    {
// 2394       MSBs = 124;
// 2395    }
// 2396    /*
// 2397     * pos_indx[index1] = ((MSBs-25*(MSBs/25))%5)*2 + (LSBs-4*(LSBs/4))%2;
// 2398     * pos_indx[index2] = ((MSBs-25*(MSBs/25))/5)*2 + (LSBs-4*(LSBs/4))/2;
// 2399     * pos_indx[index3] = (MSBs/25)*2 + LSBs/4;
// 2400     */
// 2401    divMSB = MSBs / 25;
// 2402    pos_indx[index1] = ( ( ( MSBs - 25 * ( divMSB ) ) % 5 ) << 1 ) + ( LSBs & 0x1
// 2403          );
// 2404    pos_indx[index2] = ( ( ( MSBs - 25 * ( divMSB ) ) / 5 ) << 1 ) + ( ( LSBs &
// 2405          0x2 ) >> 1 );
// 2406    pos_indx[index3] = ( divMSB << 1 ) + ( LSBs >> 2 );
// 2407    return;
// 2408 }
// 2409 
// 2410 
// 2411 /*
// 2412  * decompress_codewords
// 2413  *
// 2414  *
// 2415  * Parameters:
// 2416  *    indx              I: position of 8 pulses (compressed)
// 2417  *    pos_indx          O: position index of 8 pulses (position only)
// 2418  *
// 2419  * Function:
// 2420  *    Decompression of the linear codewords to 4+three indeces
// 2421  *    one bit from each pulse is made robust to errors by
// 2422  *    minimizing the phase shift of a bit error.
// 2423  *
// 2424  *    i0,i4,i1 => one index (7+3) bits, 3   LSBs more robust
// 2425  *    i2,i6,i5 => one index (7+3) bits, 3   LSBs more robust
// 2426  *    i3,i7    => one index (5+2) bits, 2-3 LSbs more robust
// 2427  *
// 2428  * Returns:
// 2429  *    void
// 2430  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock39 Using cfiCommon1
        CFI Function decompress_codewords
        ARM
// 2431 static void decompress_codewords( Word16 indx[], Word32 pos_indx[] )
// 2432 {
decompress_codewords:
        PUSH     {R4-R6}
        CFI R6 Frame(CFA, -4)
        CFI R5 Frame(CFA, -8)
        CFI R4 Frame(CFA, -12)
        CFI CFA R13+12
// 2433    Word32 ia, ib, MSBs, LSBs, MSBs0_24, tmp;
// 2434 
// 2435 
// 2436     /*
// 2437      * First index: 10x10x10 -> 2x5x2x5x2x5-> 125x2x2x2 -> 7+1x3 bits
// 2438      * MSBs = indx[NB_TRACK]/8;
// 2439      * LSBs = indx[NB_TRACK]%8;
// 2440      */
// 2441    MSBs = *indx >> 3;
// 2442    LSBs = *indx & 0x7;
// 2443    decompress10( MSBs, LSBs, 0, 4, 1, pos_indx );
        LDRSH    R3,[R0, #+0]
        LDRSH    R2,[R0, #+0]
        ASR      R12,R3,#+3
        LDR      R3,??decompress_codewords_0  ;; 0x51eb851f
        CMP      R12,#+125
        MOVGE    R12,#+124
        SMULL    R4,R5,R3,R12
        MOV      R4,#+25
        ASR      R5,R5,#+3
        ADD      R3,R5,R12, LSR #+31
        MUL      R5,R4,R3
        LDR      R4,??decompress_codewords_0+0x4  ;; 0x66666667
        SUB      R12,R12,R5
        SMULL    R5,R6,R12,R4
        MOV      R5,#+5
        ASR      R6,R6,#+1
        ADD      R6,R6,R12, LSR #+31
        MUL      R6,R5,R6
        AND      R2,R2,#0x7
        SUB      R4,R12,R6
        AND      R5,R2,#0x1
        ADD      R4,R5,R4, LSL #+1
        STR      R4,[R1, #+0]
        LDR      R4,??decompress_codewords_0+0x4  ;; 0x66666667
        SMULL    R5,R6,R4,R12
        AND      R5,R2,#0x2
        ASR      R6,R6,#+1
        ADD      R4,R6,R12, LSR #+31
        ASR      R5,R5,#+1
        ADD      R4,R5,R4, LSL #+1
        STR      R4,[R1, #+16]
        ASR      R2,R2,#+2
        ADD      R2,R2,R3, LSL #+1
        STR      R2,[R1, #+4]
// 2444 
// 2445     /*
// 2446      * Second index: 10x10x10 -> 2x5x2x5x2x5-> 125x2x2x2 -> 7+1x3 bits
// 2447      * MSBs = indx[NB_TRACK+1]/8;
// 2448      * LSBs = indx[NB_TRACK+1]%8;
// 2449      */
// 2450    MSBs = indx[1] >> 3;
// 2451    LSBs = indx[1] & 0x7;
// 2452    decompress10( MSBs, LSBs, 2, 6, 5, pos_indx );
        LDRSH    R3,[R0, #+2]
        LDRSH    R2,[R0, #+2]
        ASR      R12,R3,#+3
        LDR      R3,??decompress_codewords_0  ;; 0x51eb851f
        CMP      R12,#+125
        MOVGE    R12,#+124
        SMULL    R4,R5,R3,R12
        MOV      R4,#+25
        ASR      R5,R5,#+3
        ADD      R3,R5,R12, LSR #+31
        MUL      R5,R4,R3
        LDR      R4,??decompress_codewords_0+0x4  ;; 0x66666667
        SUB      R12,R12,R5
        SMULL    R5,R6,R12,R4
        MOV      R5,#+5
        ASR      R6,R6,#+1
        ADD      R6,R6,R12, LSR #+31
        MUL      R6,R5,R6
        AND      R2,R2,#0x7
        SUB      R4,R12,R6
        AND      R5,R2,#0x1
        ADD      R4,R5,R4, LSL #+1
        STR      R4,[R1, #+8]
        LDR      R4,??decompress_codewords_0+0x4  ;; 0x66666667
        SMULL    R5,R6,R4,R12
        AND      R5,R2,#0x2
        ASR      R6,R6,#+1
        ADD      R4,R6,R12, LSR #+31
        ASR      R5,R5,#+1
        ADD      R4,R5,R4, LSL #+1
        STR      R4,[R1, #+24]
        ASR      R2,R2,#+2
        ADD      R2,R2,R3, LSL #+1
        STR      R2,[R1, #+20]
// 2453 
// 2454     /*
// 2455      * Third index: 10x10 -> 2x5x2x5-> 25x2x2 -> 5+1x2 bits
// 2456      * MSBs = indx[NB_TRACK+2]/4;
// 2457      * LSBs = indx[NB_TRACK+2]%4;
// 2458      * MSBs0_24 = (MSBs*25+12)/32;
// 2459      * if ((MSBs0_24/5)%2==1)
// 2460      *    pos_indx[3] = (4-(MSBs0_24%5))*2 + LSBs%2;
// 2461      * else
// 2462      *    pos_indx[3] = (MSBs0_24%5)*2 + LSBs%2;
// 2463      * pos_indx[7] = (MSBs0_24/5)*2 + LSBs/2;
// 2464      */
// 2465    MSBs = indx[2] >> 2;
// 2466    LSBs = indx[2] & 0x3;
        LDRSH    R2,[R0, #+4]
// 2467    MSBs0_24 = ( ( ( MSBs * 25 ) + 12 ) >> 5 );
        LDRSH    R0,[R0, #+4]
        MOV      R3,#+25
        AND      R2,R2,#0x3
        ASR      R0,R0,#+2
        MUL      R0,R3,R0
// 2468    tmp = ( MSBs0_24 * 6554 ) >> 15;
        MOV      R3,#+154
        ADD      R0,R0,#+12
        ASR      R0,R0,#+5
        ORR      R3,R3,#0x1900
        MUL      R4,R3,R0
        ASR      R3,R4,#+15
// 2469    ia = tmp & 0x1;
// 2470    ib = ( MSBs0_24 - ( tmp * 5 ) );
        ADD      R4,R3,R3, LSL #+2
        SUB      R0,R0,R4
// 2471 
// 2472    if ( ia == 1 ) {
        TST      R3,#0x1
// 2473       ib = 4 - ib;
        RSBNE    R0,R0,#+4
// 2474    }
// 2475    pos_indx[3] = ( ib << 1 ) + ( LSBs & 0x1 );
        AND      R4,R2,#0x1
        ADD      R0,R4,R0, LSL #+1
        STR      R0,[R1, #+12]
// 2476    pos_indx[7] = ( tmp << 1 ) + ( LSBs >> 1 );
        ASR      R0,R2,#+1
        ADD      R0,R0,R3, LSL #+1
        STR      R0,[R1, #+28]
// 2477 }
        POP      {R4-R6}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        DATA
??decompress_codewords_0:
        DC32     0x51eb851f
        DC32     0x66666667
        CFI EndBlock cfiBlock39

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock40 Using cfiCommon0
        CFI NoFunction
        THUMB
??decode_3i40_14bits??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock40
        REQUIRE decode_3i40_14bits
// 2478 
// 2479 
// 2480 /*
// 2481  * decode_2i40_9bits
// 2482  *
// 2483  *
// 2484  * Parameters:
// 2485  *    subNr             I: subframe number
// 2486  *    sign              I: signs of 2 pulses
// 2487  *    index             I: Positions of the 2 pulses
// 2488  *    cod               O: algebraic (fixed) codebook excitation
// 2489  *
// 2490  * Function:
// 2491  *    Algebraic codebook decoder
// 2492  *
// 2493  * Returns:
// 2494  *    void
// 2495  */
// 2496 static void decode_2i40_9bits( Word32 subNr, Word32 sign, Word32 index, Word32
// 2497       cod[] )
// 2498 {
// 2499    Word32 pos[2];
// 2500    Word32 i, j, k;
// 2501 
// 2502 
// 2503    /* Decode the positions */
// 2504    /* table bit  is the MSB */
// 2505    j = ( index & 64 ) >> 6;
// 2506    i = index & 7;
// 2507 
// 2508    /* pos0 =i*5+startPos[j*8+subNr*2] */
// 2509    i = ( i + ( i << 2 ) );
// 2510    k = startPos[( j <<3 )+( subNr << 1 )];
// 2511    pos[0] = i + k;
// 2512    index = index >> 3;
// 2513    i = index & 7;
// 2514 
// 2515    /* pos1 =i*5+startPos[j*8+subNr*2+1] */
// 2516    i = ( i + ( i << 2 ) );
// 2517    k = startPos[( ( j <<3 )+ ( subNr <<1 ) ) + 1];
// 2518    pos[1] = ( Word16 )( i + k );
// 2519 
// 2520    /* decode the signs  and build the codeword */
// 2521    memset( cod, 0, L_SUBFR <<2 );
// 2522 
// 2523    for ( j = 0; j < 2; j++ ) {
// 2524       i = sign & 1;
// 2525       sign = sign >> 1;
// 2526 
// 2527       if ( i != 0 ) {
// 2528          cod[pos[j]] = 8191;   /* +1.0 */
// 2529       }
// 2530       else {
// 2531          cod[pos[j]] = -8192;   /* -1.0 */
// 2532       }
// 2533    }
// 2534    return;
// 2535 }
// 2536 
// 2537 
// 2538 /*
// 2539  * decode_2i40_11bits
// 2540  *
// 2541  *
// 2542  * Parameters:
// 2543  *    sign              I: signs of 2 pulses
// 2544  *    index             I: Positions of the 2 pulses
// 2545  *    cod               O: algebraic (fixed) codebook excitation
// 2546  *
// 2547  * Function:
// 2548  *    Algebraic codebook decoder
// 2549  *
// 2550  * Returns:
// 2551  *    void
// 2552  */
// 2553 static void decode_2i40_11bits( Word32 sign, Word32 index, Word32 cod[] )
// 2554 {
// 2555    Word32 pos[2];
// 2556    Word32 i, j;
// 2557 
// 2558 
// 2559    /* Decode the positions */
// 2560    j = index & 1;
// 2561    index = index >> 1;
// 2562    i = index & 7;
// 2563 
// 2564    /* pos0 =i*5+1+j*2 */
// 2565    i = ( i + ( i << 2 ) );
// 2566    i = ( i + 1 );
// 2567    j = ( j << 1 );
// 2568    pos[0] = i + j;
// 2569    index = index >> 3;
// 2570    j = index & 3;
// 2571    index = index >> 2;
// 2572    i = index & 7;
// 2573 
// 2574    if ( j == 3 ) {
// 2575       /* pos1 =i*5+4 */
// 2576       i = ( i + ( i << 2 ) );
// 2577       pos[1] = i + 4;
// 2578    }
// 2579    else {
// 2580       /* pos1 =i*5+j */
// 2581       i = ( i + ( i << 2 ) );
// 2582       pos[1] = i + j;
// 2583    }
// 2584 
// 2585    /* decode the signs  and build the codeword */
// 2586    memset( cod, 0, L_SUBFR <<2 );
// 2587 
// 2588    for ( j = 0; j < 2; j++ ) {
// 2589       i = sign & 1;
// 2590       sign = sign >> 1;
// 2591 
// 2592       if ( i != 0 ) {
// 2593          cod[pos[j]] = 8191;   /* +1.0 */
// 2594       }
// 2595       else {
// 2596          cod[pos[j]] = -8192;   /* -1.0 */
// 2597       }
// 2598    }
// 2599    return;
// 2600 }
// 2601 
// 2602 
// 2603 /*
// 2604  * decode_3i40_14bits
// 2605  *
// 2606  *
// 2607  * Parameters:
// 2608  *    sign              I: signs of 3 pulses
// 2609  *    index             I: Positions of the 3 pulses
// 2610  *    cod               O: algebraic (fixed) codebook excitation
// 2611  *
// 2612  * Function:
// 2613  *    Algebraic codebook decoder
// 2614  *
// 2615  * Returns:
// 2616  *    void
// 2617  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock41 Using cfiCommon1
        CFI Function decode_3i40_14bits
        ARM
// 2618 static void decode_3i40_14bits( Word32 sign, Word32 index, Word32 cod[] )
// 2619 {
decode_3i40_14bits:
        PUSH     {R4,R5,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R5 Frame(CFA, -8)
        CFI R4 Frame(CFA, -12)
        CFI CFA R13+12
        SUB      SP,SP,#+12
        CFI CFA R13+24
        MOV      R4,R2
        MOV      R5,R0
// 2620    Word32 pos[3];
// 2621    Word32 i, j;
// 2622 
// 2623 
// 2624    /* Decode the positions */
// 2625    i = index & 7;
// 2626 
// 2627    /* pos0 =i*5 */
// 2628    pos[0] = i + ( i << 2 );
        AND      R2,R1,#0x7
        ADD      R2,R2,R2, LSL #+2
        STR      R2,[SP, #+0]
// 2629    index = index >> 3;
        ASR      R0,R1,#+3
// 2630    j = index & 1;
        AND      R1,R0,#0x1
// 2631    index = index >> 1;
        ASR      R0,R0,#+1
// 2632    i = index & 7;
// 2633 
// 2634    /* pos1 =i*5+1+j*2 */
// 2635    i = ( i + ( i << 2 ) );
// 2636    i = ( i + 1 );
// 2637    j = ( j << 1 );
// 2638    pos[1] = i + j;
        AND      R3,R0,#0x7
        ADD      R3,R3,R3, LSL #+2
        ADD      R1,R3,R1, LSL #+1
        ADD      R1,R1,#+1
        STR      R1,[SP, #+4]
// 2639    index = index >> 3;
        ASR      R0,R0,#+3
// 2640    j = index & 1;
// 2641    index = index >> 1;
// 2642    i = index & 7;
// 2643 
// 2644    /* pos2 =i*5+2+j*2 */
// 2645    i = ( i + ( i << 2 ) );
// 2646    i = ( i + 2 );
// 2647    j = ( j << 1 );
// 2648    pos[2] = i + j;
        MOV      R2,#+7
        AND      R2,R2,R0, ASR #+1
        ADD      R2,R2,R2, LSL #+2
        AND      R0,R0,#0x1
        ADD      R0,R2,R0, LSL #+1
        ADD      R0,R0,#+2
        STR      R0,[SP, #+8]
// 2649 
// 2650    /* decode the signs  and build the codeword */
// 2651    memset( cod, 0, L_SUBFR <<2 );
        MOV      R2,#+160
        MOV      R1,#+0
        MOV      R0,R4
        SWI      +187
// 2652 
// 2653    for ( j = 0; j < 3; j++ ) {
        MOV      R0,#+0
// 2654       i = sign & 1;
// 2655       sign = sign >> 1;
??decode_3i40_14bits_0:
        MOV      R2,SP
        LDR      R2,[R2, +R0, LSL #+2]
        AND      R1,R5,#0x1
        ASR      R5,R5,#+1
        ADD      R2,R4,R2, LSL #+2
        CMP      R1,#+1
// 2656 
// 2657       if ( i > 0 ) {
// 2658          cod[pos[j]] = 8191;   /* +1.0 */
        MOVGE    R1,#+255
        ORRGE    R1,R1,#0x1F00
// 2659       }
// 2660       else {
// 2661          cod[pos[j]] = -8192;   /* -1.0 */
        MVNLT    R1,#+255
        BICLT    R1,R1,#0x1F00
        STR      R1,[R2, #+0]
// 2662       }
// 2663    }
        ADD      R0,R0,#+1
        CMP      R0,#+3
        BLT      ??decode_3i40_14bits_0
// 2664    return;
        POP      {R0-R2,R4,R5,PC}  ;; return
        CFI EndBlock cfiBlock41
// 2665 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock42 Using cfiCommon0
        CFI NoFunction
        THUMB
??decode_4i40_17bits??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock42
        REQUIRE decode_4i40_17bits
// 2666 
// 2667 
// 2668 /*
// 2669  * decode_3i40_14bits
// 2670  *
// 2671  *
// 2672  * Parameters:
// 2673  *    sign              I: signs of 4 pulses
// 2674  *    index             I: Positions of the 4 pulses
// 2675  *    cod               O: algebraic (fixed) codebook excitation
// 2676  *
// 2677  * Function:
// 2678  *    Algebraic codebook decoder
// 2679  *
// 2680  * Returns:
// 2681  *    void
// 2682  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock43 Using cfiCommon1
        CFI Function decode_4i40_17bits
        ARM
// 2683 static void decode_4i40_17bits( Word32 sign, Word32 index, Word32 cod[] )
// 2684 {
decode_4i40_17bits:
        PUSH     {R4,R5,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R5 Frame(CFA, -8)
        CFI R4 Frame(CFA, -12)
        CFI CFA R13+12
        SUB      SP,SP,#+16
        CFI CFA R13+28
        MOV      R4,R0
// 2685    Word32 pos[4];
// 2686    Word32 i, j;
// 2687 
// 2688 
// 2689    /* Decode the positions */
// 2690    i = index & 7;
// 2691    i = dgray[i];
// 2692 
// 2693    /* pos0 =i*5 */
// 2694    pos[0] = i + ( i << 2 );
        LDR      R0,??DataTable2  ;; sqrt_table
        AND      R3,R1,#0x7
        ADD      R3,R0,R3, LSL #+2
        LDR      R3,[R3, #+288]
// 2695    index = index >> 3;
        ASR      R1,R1,#+3
        ADD      R3,R3,R3, LSL #+2
        STR      R3,[SP, #+0]
// 2696    i = index & 7;
// 2697    i = dgray[i];
// 2698 
// 2699    /* pos1 =i*5+1 */
// 2700    i = ( i + ( i << 2 ) );
// 2701    pos[1] = i + 1;
        AND      R3,R1,#0x7
        ADD      R3,R0,R3, LSL #+2
        LDR      R3,[R3, #+288]
// 2702    index = index >> 3;
        ASR      R1,R1,#+3
        ADD      R3,R3,R3, LSL #+2
        ADD      R3,R3,#+1
        STR      R3,[SP, #+4]
// 2703    i = index & 7;
// 2704    i = dgray[i];
// 2705 
// 2706    /* pos2 =i*5+1 */
// 2707    i = ( i + ( i << 2 ) );
// 2708    pos[2] = i + 2;
        AND      R3,R1,#0x7
        ADD      R3,R0,R3, LSL #+2
        LDR      R3,[R3, #+288]
// 2709    index = index >> 3;
        ASR      R1,R1,#+3
        ADD      R3,R3,R3, LSL #+2
        ADD      R3,R3,#+2
        STR      R3,[SP, #+8]
// 2710    j = index & 1;
// 2711    index = index >> 1;
// 2712    i = index & 7;
// 2713    i = dgray[i];
// 2714 
// 2715    /* pos3 =i*5+3+j */
// 2716    i = ( i + ( i << 2 ) );
// 2717    i = ( i + 3 );
// 2718    pos[3] = i + j;
        MOV      R3,#+7
        AND      R3,R3,R1, ASR #+1
        ADD      R0,R0,R3, LSL #+2
        LDR      R0,[R0, #+288]
        MOV      R5,R2
        ADD      R0,R0,R0, LSL #+2
        AND      R1,R1,#0x1
        ADD      R0,R1,R0
        ADD      R0,R0,#+3
        STR      R0,[SP, #+12]
// 2719 
// 2720    /* decode the signs  and build the codeword */
// 2721    memset( cod, 0, L_SUBFR <<2 );
        MOV      R2,#+160
        MOV      R1,#+0
        MOV      R0,R5
        SWI      +187
// 2722 
// 2723    for ( j = 0; j < 4; j++ ) {
        MOV      R0,#+0
// 2724       i = sign & 1;
// 2725       sign = sign >> 1;
??decode_4i40_17bits_0:
        MOV      R2,SP
        LDR      R2,[R2, +R0, LSL #+2]
        AND      R1,R4,#0x1
        ASR      R4,R4,#+1
        ADD      R2,R5,R2, LSL #+2
        CMP      R1,#+0
// 2726 
// 2727       if ( i != 0 ) {
// 2728          cod[pos[j]] = 8191;
        MOVNE    R1,#+255
        ORRNE    R1,R1,#0x1F00
// 2729       }
// 2730       else {
// 2731          cod[pos[j]] = -8192;
        MVNEQ    R1,#+255
        BICEQ    R1,R1,#0x1F00
        STR      R1,[R2, #+0]
// 2732       }
// 2733    }
        ADD      R0,R0,#+1
        CMP      R0,#+4
        BLT      ??decode_4i40_17bits_0
// 2734    return;
        POP      {R0-R5,PC}       ;; return
        CFI EndBlock cfiBlock43
// 2735 }

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable2:
        DC32     sqrt_table

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock44 Using cfiCommon0
        CFI NoFunction
        THUMB
??gmed_n??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock44
        REQUIRE gmed_n
// 2736 
// 2737 
// 2738 /*
// 2739  * decode_8i40_31bits
// 2740  *
// 2741  *
// 2742  * Parameters:
// 2743  *    index             I: index of 8 pulses (sign+position)
// 2744  *    cod               O: algebraic (fixed) codebook excitation
// 2745  *
// 2746  * Function:
// 2747  *    Algebraic codebook decoder
// 2748  *
// 2749  * Returns:
// 2750  *    void
// 2751  */
// 2752 static void decode_8i40_31bits( Word16 index[], Word32 cod[] )
// 2753 {
// 2754    Word32 linear_codewords[8];
// 2755    Word32 i, j, pos1, pos2, sign;
// 2756 
// 2757 
// 2758    memset( cod, 0, L_CODE <<2 );
// 2759    decompress_codewords( &index[NB_TRACK_MR102], linear_codewords );
// 2760 
// 2761    /* decode the positions and signs of pulses and build the codeword */
// 2762    for ( j = 0; j < NB_TRACK_MR102; j++ ) {
// 2763       /* compute index i */
// 2764       i = linear_codewords[j];
// 2765       i <<= 2;
// 2766 
// 2767       /* position of pulse "j" */
// 2768       pos1 = i + j;
// 2769 
// 2770       if ( index[j] == 0 ) {
// 2771          sign = POS_CODE;   /* +1.0 */
// 2772       }
// 2773       else {
// 2774          sign = -NEG_CODE;   /* -1.0 */
// 2775       }
// 2776 
// 2777       /* compute index i */
// 2778       i = linear_codewords[j + 4];
// 2779       i = i << 2;
// 2780 
// 2781       /* position of pulse "j+4" */
// 2782       pos2 = i + j;
// 2783       cod[pos1] = sign;
// 2784 
// 2785       if ( pos2 < pos1 ) {
// 2786          sign = -( sign );
// 2787       }
// 2788       cod[pos2] = cod[pos2] + sign;
// 2789    }
// 2790    return;
// 2791 }
// 2792 
// 2793 
// 2794 /*
// 2795  * decode_10i40_35bits
// 2796  *
// 2797  *
// 2798  * Parameters:
// 2799  *    index             I: index of 10 pulses (sign+position)
// 2800  *    cod               O: algebraic (fixed) codebook excitation
// 2801  *
// 2802  * Function:
// 2803  *    Algebraic codebook decoder
// 2804  *
// 2805  * Returns:
// 2806  *    void
// 2807  */
// 2808 static void decode_10i40_35bits( Word16 index[], Word32 cod[] )
// 2809 {
// 2810    Word32 i, j, pos1, pos2, sign, tmp;
// 2811 
// 2812 
// 2813    memset( cod, 0, L_CODE <<2 );
// 2814 
// 2815    /* decode the positions and signs of pulses and build the codeword */
// 2816    for ( j = 0; j < 5; j++ ) {
// 2817       /* compute index i */
// 2818       tmp = index[j];
// 2819       i = tmp & 7;
// 2820       i = dgray[i];
// 2821       i = ( i * 5 );
// 2822 
// 2823       /* position of pulse "j" */
// 2824       pos1 = ( i + j );
// 2825       i = ( tmp >> 3 ) & 1;
// 2826 
// 2827       if ( i == 0 ) {
// 2828          sign = 4096;   /* +1.0 */
// 2829       }
// 2830       else {
// 2831          sign = -4096;   /* -1.0 */
// 2832       }
// 2833 
// 2834       /* compute index i */
// 2835       i = index[j + 5] & 7;
// 2836       i = dgray[i];
// 2837       i = i * 5;
// 2838 
// 2839       /* position of pulse "j+5" */
// 2840       pos2 = ( i + j );
// 2841       cod[pos1] = sign;
// 2842 
// 2843       if ( pos2 < pos1 ) {
// 2844          sign = -( sign );
// 2845       }
// 2846       cod[pos2] = cod[pos2] + sign;
// 2847    }
// 2848    return;
// 2849 }
// 2850 
// 2851 
// 2852 /*
// 2853  * gmed_n
// 2854  *
// 2855  *
// 2856  * Parameters:
// 2857  *    ind               I: values
// 2858  *    n                 I: The number of gains (odd)
// 2859  *
// 2860  * Function:
// 2861  *    Calculates N-point median.
// 2862  *
// 2863  * Returns:
// 2864  *    index of the median value
// 2865  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock45 Using cfiCommon1
        CFI Function gmed_n
        ARM
// 2866 static Word32 gmed_n( Word32 ind[], Word32 n )
// 2867 {
gmed_n:
        PUSH     {R4,R5}
        CFI R5 Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
        SUB      SP,SP,#+72
        CFI CFA R13+80
// 2868    Word32 tmp[NMAX], tmp2[NMAX];
// 2869    Word32 max, medianIndex, i, j, ix = 0;
        MOV      R2,#+0
// 2870 
// 2871 
// 2872    for ( i = 0; i < n; i++ ) {
        MOV      R3,#+0
        CMP      R1,#+1
        ADD      R4,SP,#+36
        BGE      ??gmed_n_0
        B        ??gmed_n_1
// 2873       tmp2[i] = ind[i];
??gmed_n_2:
        LDR      R5,[R0, +R3, LSL #+2]
        STR      R5,[R4, +R3, LSL #+2]
// 2874    }
        ADD      R3,R3,#+1
??gmed_n_0:
        CMP      R3,R1
        BLT      ??gmed_n_2
// 2875 
// 2876    for ( i = 0; i < n; i++ ) {
??gmed_n_1:
        MOV      R3,#+0
        CMP      R1,#+1
        BGE      ??gmed_n_3
// 2877       max = -32767;
// 2878 
// 2879       for ( j = 0; j < n; j++ ) {
// 2880          if ( tmp2[j] >= max ) {
// 2881             max = tmp2[j];
// 2882             ix = j;
// 2883          }
// 2884       }
// 2885       tmp2[ix] = -32768;
// 2886       tmp[i] = ix;
// 2887    }
// 2888    medianIndex = tmp[( n >>1 )];
// 2889    return( ind[medianIndex] );
??gmed_n_4:
        ASR      R1,R1,#+1
        MOV      R2,SP
        LDR      R1,[R2, +R1, LSL #+2]
        LDR      R0,[R0, +R1, LSL #+2]
        ADD      SP,SP,#+72
        CFI CFA R13+8
        POP      {R4,R5}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        CFI R4 Frame(CFA, -8)
        CFI R5 Frame(CFA, -4)
        CFI CFA R13+80
??gmed_n_5:
        ADD      R12,SP,#+36
        LDR      R12,[R12, +R4, LSL #+2]
        CMP      R12,R5
        MOVGE    R5,R12
        MOVGE    R2,R4
        ADD      R4,R4,#+1
??gmed_n_6:
        CMP      R4,R1
        BLT      ??gmed_n_5
        ADD      R4,SP,#+36
        MVN      R5,#+255
        BIC      R5,R5,#0x7F00
        STR      R5,[R4, +R2, LSL #+2]
        MOV      R4,SP
        STR      R2,[R4, +R3, LSL #+2]
        ADD      R3,R3,#+1
??gmed_n_3:
        CMP      R3,R1
        BGE      ??gmed_n_4
        MVN      R5,#+254
        BIC      R5,R5,#0x7F00
        MOV      R4,#+0
        B        ??gmed_n_6
        CFI EndBlock cfiBlock45
// 2890 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock46 Using cfiCommon0
        CFI NoFunction
        THUMB
??ec_gain_pitch_update??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock46
        REQUIRE ec_gain_pitch_update
// 2891 
// 2892 
// 2893 /*
// 2894  * ec_gain_pitch
// 2895  *
// 2896  *
// 2897  * Parameters:
// 2898  *    st->pbuf          I: last five gains
// 2899  *    st->past_gain_pit I: past gain
// 2900  *    state             I: state of the state machine
// 2901  *    gain_pitch        O: pitch gain
// 2902  *
// 2903  * Function:
// 2904  *    Calculates pitch from previous values.
// 2905  *
// 2906  * Returns:
// 2907  *    void
// 2908  */
// 2909 static void ec_gain_pitch( ec_gain_pitchState *st, Word16 state, Word32 *
// 2910       gain_pitch )
// 2911 {
// 2912    Word32 tmp;
// 2913 
// 2914 
// 2915    /* calculate median of last five gains */
// 2916    tmp = gmed_n( st->pbuf, 5 );
// 2917 
// 2918    /* new gain = minimum(median, past_gain) * pdown[state] */
// 2919    if ( tmp > st->past_gain_pit ) {
// 2920       tmp = st->past_gain_pit;
// 2921    }
// 2922    *gain_pitch = ( tmp * pdown[state] ) >> 15;
// 2923 }
// 2924 
// 2925 
// 2926 /*
// 2927  * d_gain_pitch
// 2928  *
// 2929  *
// 2930  * Parameters:
// 2931  *    mode              I: AMR mode
// 2932  *    index             I: index of quantization
// 2933  *
// 2934  * Function:
// 2935  *    Decodes the pitch gain using the received index
// 2936  *
// 2937  * Returns:
// 2938  *    gain
// 2939  */
// 2940 static Word32 d_gain_pitch( enum Mode mode, Word32 index )
// 2941 {
// 2942    Word32 gain;
// 2943 
// 2944 
// 2945    if ( mode == MR122 ) {
// 2946       /* clear 2 LSBits */
// 2947       gain = ( qua_gain_pitch[index] >> 2 ) << 2;
// 2948    }
// 2949    else {
// 2950       gain = qua_gain_pitch[index];
// 2951    }
// 2952    return gain;
// 2953 }
// 2954 
// 2955 
// 2956 /*
// 2957  * ec_gain_pitch_update
// 2958  *
// 2959  *
// 2960  * Parameters:
// 2961  *    st->prev_gp       B: previous pitch gain
// 2962  *    st->past_gain_pit O: past gain
// 2963  *    st->pbuf          B: past gain buffer
// 2964  *    bfi               I: bad frame indicator
// 2965  *    prev_bf           I: previous frame was bad
// 2966  *    gain_pitch        B: pitch gain
// 2967  *
// 2968  * Function:
// 2969  *    Update the pitch gain concealment state
// 2970  *    Limit gain_pitch if the previous frame was bad
// 2971  *
// 2972  * Returns:
// 2973  *    gain
// 2974  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock47 Using cfiCommon1
        CFI Function ec_gain_pitch_update
        ARM
// 2975 static void ec_gain_pitch_update( ec_gain_pitchState *st, Word32 bfi,
// 2976       Word32 prev_bf, Word32 *gain_pitch )
// 2977 {
// 2978    if ( bfi == 0 ) {
ec_gain_pitch_update:
        CMP      R1,#+0
        BNE      ??ec_gain_pitch_update_0
// 2979       if ( prev_bf != 0 ) {
        CMP      R2,#+0
        BEQ      ??ec_gain_pitch_update_1
// 2980          if ( *gain_pitch > st->prev_gp ) {
        LDR      R1,[R0, #+24]
        LDR      R2,[R3, #+0]
        CMP      R1,R2
// 2981             *gain_pitch = st->prev_gp;
        STRLT    R1,[R3, #+0]
// 2982          }
// 2983       }
// 2984       st->prev_gp = *gain_pitch;
??ec_gain_pitch_update_1:
        LDR      R1,[R3, #+0]
        STR      R1,[R0, #+24]
// 2985    }
// 2986    st->past_gain_pit = *gain_pitch;
??ec_gain_pitch_update_0:
        LDR      R1,[R3, #+0]
// 2987 
// 2988    /* if (st->past_gain_pit > 1.0) */
// 2989    if ( st->past_gain_pit > 16384 ) {
        MOV      R2,#+1
        ORR      R2,R2,#0x4000
        CMP      R1,R2
// 2990       st->past_gain_pit = 16384;
        MOVGE    R1,#+16384
        STR      R1,[R0, #+20]
// 2991    }
// 2992    st->pbuf[0] = st->pbuf[1];
        LDR      R1,[R0, #+4]
        STR      R1,[R0, #+0]
// 2993    st->pbuf[1] = st->pbuf[2];
        LDR      R1,[R0, #+8]
        STR      R1,[R0, #+4]
// 2994    st->pbuf[2] = st->pbuf[3];
        LDR      R1,[R0, #+12]
        STR      R1,[R0, #+8]
// 2995    st->pbuf[3] = st->pbuf[4];
        LDR      R1,[R0, #+16]
        STR      R1,[R0, #+12]
// 2996    st->pbuf[4] = st->past_gain_pit;
        LDR      R1,[R0, #+20]
        STR      R1,[R0, #+16]
// 2997 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock47

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock48 Using cfiCommon0
        CFI NoFunction
        THUMB
??gc_pred??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock48
        REQUIRE gc_pred
// 2998 
// 2999 
// 3000 /*
// 3001  * gc_pred (366)
// 3002  *
// 3003  *
// 3004  * Parameters:
// 3005  *    st->past_qua_en         I: MA predictor
// 3006  *    st->past_qua_en_MR122   I: MA predictor MR122
// 3007  *    mode                    I: AMR mode
// 3008  *    code                    I: innovative codebook vector
// 3009  *    exp_gcode0              O: predicted gain factor (exponent)
// 3010  *    frac_gcode0             O: predicted gain factor (fraction)
// 3011  *    exp_en                  I: innovation energy (MR795) (exponent)
// 3012  *    frac_en                 I: innovation energy (MR795) (fraction)
// 3013  *
// 3014  * Function:
// 3015  *    MA prediction of the innovation energy
// 3016  *
// 3017  *    Mean removed innovation energy (dB) in subframe n
// 3018  *                          N-1
// 3019  *    E(n) = 10*log(gc*gc * SUM[(code(i) * code(i)]/N) - EMean
// 3020  *                          i=0
// 3021  *    N=40
// 3022  *
// 3023  *    Mean innovation energy (dB)
// 3024  *                   N-1
// 3025  *    Ei(n) = 10*log(SUM[(code(i) * code(i)]/N)
// 3026  *                   i=0
// 3027  *
// 3028  *    Predicted energy
// 3029  *              4
// 3030  *    Ep(n) = SUM[b(i) * R(n-i)]
// 3031  *            i=1
// 3032  *    b = [0.68 0.58 0.34 0.19]
// 3033  *    R(k) is quantified prediction error at subframe k
// 3034  *
// 3035  *    E_Mean = 36 dB (MR122)
// 3036  *
// 3037  *    Predicted gain gc is found by
// 3038  *
// 3039  *    gc = POW[10, 0.05 * (Ep(n) + EMean - Ei)]
// 3040  *
// 3041  * Returns:
// 3042  *    void
// 3043  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock49 Using cfiCommon1
        CFI Function gc_pred
        ARM
// 3044 static void gc_pred( gc_predState *st, enum Mode mode, Word32 *code, Word32 *
// 3045       exp_gcode0, Word32 *frac_gcode0, Word32 *exp_en, Word32 *frac_en )
// 3046 {
gc_pred:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
        SUB      SP,SP,#+8
        CFI CFA R13+44
        LDR      R6,[SP, #+44]
        LDR      R12,[SP, #+52]
        MOV      R4,R0
        MOV      R5,R3
        LDR      R3,[SP, #+48]
// 3047    Word32 exp, frac, ener_code = 0, i = 0;
        MOV      R0,#+0
        MOV      R7,#+0
// 3048 
// 3049 
// 3050     /* energy of code:
// 3051      * ener_code = sum(code[i]^2)
// 3052      */
// 3053    while ( i < L_SUBFR ) {
// 3054       ener_code += code[i] * code[i];
??gc_pred_0:
        LDR      R8,[R2, +R7, LSL #+2]
// 3055       i++;
        ADD      R7,R7,#+1
        MLA      R0,R8,R8,R0
// 3056    }
        CMP      R7,#+40
        BLT      ??gc_pred_0
// 3057 
// 3058    if ( ( 0x3fffffff <= ener_code ) | ( ener_code < 0 ) )
        MVN      R2,#-1073741824
        CMP      R0,R2
        BGE      ??gc_pred_1
        CMP      R0,#+0
// 3059       ener_code = MAX_32;
// 3060    else
// 3061       ener_code <<= 1;
        LSLPL    R0,R0,#+1
        BPL      ??gc_pred_2
??gc_pred_1:
        ORR      R0,R2,#0x40000000
// 3062 
// 3063    if ( mode == MR122 ) {
??gc_pred_2:
        LDR      R7,??DataTable3  ;; log2_table
        CMP      R1,#+7
        BNE      ??gc_pred_3
// 3064       Word32 ener;
// 3065 
// 3066 
// 3067       /* ener_code = ener_code / lcode; lcode = 40; 1/40 = 26214 Q20       */
// 3068       ener_code = ( ( ener_code + 0x00008000L ) >> 16 ) * 52428;
// 3069 
// 3070       /* Q9  * Q20 -> Q30 */
// 3071         /* energy of code:
// 3072          * ener_code(Q17) = 10 * Log10(energy) / constant
// 3073          *                = 1/2 * Log2(energy)
// 3074          * constant = 20*Log10(2)
// 3075          */
// 3076       /* ener_code = 1/2 * Log2(ener_code); Note: Log2=log2+30 */
// 3077       Log2( ener_code, &exp, &frac );
        ADD      R2,SP,#+4
        MOV      R1,SP
        ADD      R0,R0,#+32768
        ASR      R0,R0,#+16
        MOV      R3,#+204
        ORR      R3,R3,#0xCC00
        MUL      R0,R3,R0
        BL       Log2
// 3078       ener_code = ( ( exp - 30 ) << 16 ) + ( frac << 1 );
        LDR      R0,[SP, #+0]
        LDR      R1,[SP, #+4]
        SUB      R0,R0,#+30
        LSL      R1,R1,#+1
        ADD      R0,R1,R0, LSL #+16
// 3079 
// 3080       /* Q16 for log(), ->Q17 for 1/2 log() */
// 3081          /*
// 3082           * predicted energy:
// 3083           * ener(Q24) = (Emean + sum{pred[i]*pastEn[i]})/constant
// 3084           *           = MEAN_ENER + sum(pred[i]*past_qua_en[i])
// 3085           * constant = 20*Log10(2)
// 3086           */
// 3087       ener = 0;
        MOV      R1,#+0
// 3088       i = 0;
        MOV      R2,#+0
// 3089 
// 3090       while ( i < 4 ) {
// 3091          ener += st->past_qua_en_MR122[i] * pred_MR122[i];
??gc_pred_4:
        ADD      R3,R4,R2, LSL #+2
        LDR      R3,[R3, #+16]
        ADD      R8,R7,R2, LSL #+2
        LDR      R8,[R8, #+148]
// 3092          i++;
        ADD      R2,R2,#+1
        MLA      R1,R8,R3,R1
// 3093       }
        CMP      R2,#+4
        BLT      ??gc_pred_4
// 3094       ener <<= 1;
// 3095       ener += MEAN_ENER_MR122;
// 3096 
// 3097         /*
// 3098          * predicted codebook gain
// 3099 
// 3100          * gc0 = Pow10( (ener*constant - ener_code*constant) / 20 )
// 3101          *     = Pow2(ener-ener_code)
// 3102          *     = Pow2(int(d)+frac(d))
// 3103          */
// 3104       ener = ( ener - ener_code ) >> 1;   /* Q16 */
        LDR      R2,??gc_pred_5   ;; 0xbf57d
        ADD      R1,R2,R1, LSL #+1
        SUB      R0,R1,R0
        ASR      R0,R0,#+1
// 3105       *exp_gcode0 = ener >> 16;
        ASR      R1,R0,#+16
        STR      R1,[R5, #+0]
// 3106       *frac_gcode0 = ( ener >> 1 ) - ( *exp_gcode0 << 15 );
        ASR      R0,R0,#+1
        SUB      R0,R0,R1, LSL #+15
        STR      R0,[R6, #+0]
        POP      {R0,R1,R4-R11,PC}
// 3107    }
// 3108 
// 3109    /* all modes except 12.2 */
// 3110    else {
// 3111       Word32 tmp, gcode0;
// 3112       int exp_code;
// 3113 
// 3114 
// 3115         /*
// 3116          * Compute: meansEner - 10log10(ener_code/ LSufr)
// 3117          */
// 3118       exp_code=0;
??gc_pred_3:
        MOV      R2,#+0
// 3119       if (ener_code != 0){
        CMP      R0,#+0
        BNE      ??gc_pred_6
        B        ??gc_pred_7
// 3120          while (!(ener_code & 0x40000000))
// 3121          {
// 3122             exp_code++;
??gc_pred_8:
        ADD      R2,R2,#+1
// 3123             ener_code = ener_code << 1;
        LSL      R0,R0,#+1
// 3124          }
??gc_pred_6:
        TST      R0,#0x40000000
        BEQ      ??gc_pred_8
// 3125       }
// 3126 
// 3127       /* Log2 = log2 + 27 */
// 3128       Log2_norm( ener_code, exp_code, &exp, &frac );
??gc_pred_7:
        CMP      R0,#+1
        BGE      ??gc_pred_9
        MOV      R9,#+0
        STR      R9,[SP, #+0]
        STR      R9,[SP, #+4]
        B        ??gc_pred_10
??gc_pred_9:
        ASR      R8,R0,#+25
        SUB      R10,R8,#+32
        LDR      R8,[R7, +R10, LSL #+2]
        ADD      R11,R7,R10, LSL #+2
        LDR      R11,[R11, #+4]
        MOV      R9,#+254
        ORR      R9,R9,#0xFF00
        AND      R9,R9,R0, ASR #+9
        SUB      R10,R11,R8
        MUL      R9,R10,R9
        ADD      R8,R9,R8, LSL #+16
        ASR      R8,R8,#+16
        STR      R8,[SP, #+4]
        RSB      R9,R2,#+30
        STR      R9,[SP, #+0]
// 3129 
// 3130       /* fact = 10/log2(10) = 3.01 = 24660 Q13 */
// 3131       /* Q0.Q15 * Q13 -> Q14 */
// 3132       tmp = ( exp * ( -49320 ) ) + ( ( ( frac * ( -24660 ) ) >> 15 ) << 1 );
??gc_pred_10:
        LDR      R8,[SP, #+0]
        MVN      R9,#+167
        BIC      R9,R9,#0xC000
        MUL      R8,R9,R8
        LDR      R9,[SP, #+4]
        MVN      R10,#+83
        BIC      R10,R10,#0x6000
        MUL      R9,R10,R9
// 3133 
// 3134       /*
// 3135        * tmp = meansEner - 10log10(ener_code/L_SUBFR)
// 3136        *       = meansEner - 10log10(ener_code) + 10log10(L_SUBFR)
// 3137        *       = K - fact * Log2(ener_code)
// 3138        *     = K - fact * log2(ener_code) - fact*27
// 3139        *
// 3140        *   ==> K = meansEner + fact*27 + 10log10(L_SUBFR)
// 3141        *
// 3142        *   meansEner =       33    =  540672    Q14  (MR475, MR515, MR59)
// 3143        *   meansEner =       28.75 =  471040    Q14  (MR67)
// 3144        *   meansEner =       30    =  491520    Q14  (MR74)
// 3145        *   meansEner =       36    =  589824    Q14  (MR795)
// 3146        *   meansEner =       33    =  540672    Q14  (MR102)
// 3147        *   10log10(L_SUBFR) = 16.02 =  262481.51 Q14
// 3148        *   fact * 27                = 1331640    Q14
// 3149        *   -----------------------------------------
// 3150        *   (MR475, MR515, MR59)   K = 2134793.51 Q14 ~= 16678 * 64 * 2
// 3151        *   (MR67)                 K = 2065161.51 Q14 ~= 32268 * 32 * 2
// 3152        *   (MR74)                 K = 2085641.51 Q14 ~= 32588 * 32 * 2
// 3153        *   (MR795)                K = 2183945.51 Q14 ~= 17062 * 64 * 2
// 3154        *   (MR102)                K = 2134793.51 Q14 ~= 16678 * 64 * 2
// 3155        */
// 3156       if ( mode == MR102 ) {
        CMP      R1,#+6
        ASR      R9,R9,#+15
        ADD      R8,R8,R9, LSL #+1
        MOV      R9,#+2097152
        ORR      R9,R9,#0x9300
        BEQ      ??gc_pred_11
// 3157          /* mean = 33 dB */
// 3158          tmp += 2134784;   /* Q14 */
// 3159       }
// 3160       else if ( mode == MR795 ) {
        CMP      R1,#+5
        BNE      ??gc_pred_12
// 3161          /* mean = 36 dB */
// 3162          tmp += 2183936;   /* Q14 */
        ADD      R9,R9,#+49152
        ADD      R8,R9,R8
// 3163 
// 3164          /*
// 3165           * ener_code  = <xn xn> * 2^27*2^exp_code
// 3166           * frac_en    = ener_code / 2^16
// 3167           *            = <xn xn> * 2^11*2^exp_code
// 3168           * <xn xn>    = <xn xn>*2^11*2^exp * 2^exp_en
// 3169           *           := frac_en            * 2^exp_en
// 3170           *
// 3171           * ==> exp_en = -11-exp_code;
// 3172           */
// 3173          *frac_en = ener_code >> 16;
        ASR      R0,R0,#+16
        STR      R0,[R12, #+0]
// 3174          *exp_en = -11 - exp_code;
        MVN      R0,#+10
        SUB      R0,R0,R2
        STR      R0,[R3, #+0]
        B        ??gc_pred_13
// 3175       }
// 3176       else if ( mode == MR74 ) {
??gc_pred_12:
        CMP      R1,#+4
        BNE      ??gc_pred_14
// 3177          /* mean = 30 dB */
// 3178          tmp += 2085632;   /* Q14 */
        SUB      R0,R9,#+49152
??gc_pred_15:
        ADD      R8,R0,R8
        B        ??gc_pred_13
// 3179       }
// 3180       else if ( mode == MR67 ) {
??gc_pred_14:
        CMP      R1,#+3
// 3181          /* mean = 28.75 dB */
// 3182          tmp += 2065152;   /* Q14 */
        SUBEQ    R0,R9,#+69632
        BEQ      ??gc_pred_15
// 3183       }
// 3184       else /* MR59, MR515, MR475 */ {
// 3185          /* mean = 33 dB */
// 3186          tmp += 2134784;   /* Q14 */
??gc_pred_11:
        ADD      R8,R9,R8
// 3187       }
// 3188 
// 3189         /*
// 3190          * Compute gcode0
// 3191          * = Sum(i=0,3) pred[i]*past_qua_en[i] - ener_code + meanEner
// 3192          */
// 3193       tmp = tmp << 9;   /* Q23 */
??gc_pred_13:
        LSL      R0,R8,#+9
// 3194 
// 3195       /* Q13 * Q10 -> Q23 */
// 3196       i = 0;
        MOV      R2,#+0
// 3197 
// 3198       while ( i < 4 ) {
// 3199          tmp += pred[i] * st->past_qua_en[i];
??gc_pred_16:
        LDR      R8,[R4, +R2, LSL #+2]
        ADD      R3,R7,R2, LSL #+2
        LDR      R3,[R3, #+132]
// 3200          i++;
        ADD      R2,R2,#+1
        MLA      R0,R8,R3,R0
// 3201       }
        CMP      R2,#+4
        BLT      ??gc_pred_16
// 3202       gcode0 = tmp >> 15;   /* Q8  */
        ASR      R0,R0,#+15
// 3203 
// 3204         /*
// 3205          * gcode0 = pow(10.0, gcode0/20)
// 3206          *        = pow(2, 3.3219*gcode0/20)
// 3207          *        = pow(2, 0.166*gcode0)
// 3208          */
// 3209       /* 5439 Q15 = 0.165985                                        */
// 3210       /* (correct: 1/(20*log10(2)) 0.166096 = 5443 Q15)             */
// 3211       /* For IS641 bitexactness */
// 3212       if ( mode == MR74 ) {
        CMP      R1,#+4
// 3213          /* Q8 * Q15 -> Q24 */
// 3214          tmp = gcode0 * 10878;
        MOVEQ    R1,#+126
// 3215       }
// 3216       else {
// 3217          /* Q8 * Q15 -> Q24 */
// 3218          tmp = gcode0 * 10886;
        MOVNE    R1,#+134
        ORR      R1,R1,#0x2A00
        MUL      R0,R1,R0
// 3219       }
// 3220       tmp = tmp >> 9;   /* -> Q15 */
        ASR      R0,R0,#+9
// 3221 
// 3222       /* -> Q0.Q15 */
// 3223       *exp_gcode0 = tmp >> 15;
        ASR      R1,R0,#+15
        STR      R1,[R5, #+0]
// 3224       *frac_gcode0 = tmp - ( *exp_gcode0 * 32768 );
        SUB      R0,R0,R1, LSL #+15
        STR      R0,[R6, #+0]
// 3225    }
// 3226 }
        POP      {R0,R1,R4-R11,PC}  ;; return
        DATA
??gc_pred_5:
        DC32     0xbf57d
        CFI EndBlock cfiBlock49

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable3:
        DC32     log2_table

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock50 Using cfiCommon0
        CFI NoFunction
        THUMB
??Dec_gain??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock50
        REQUIRE Dec_gain
// 3227 
// 3228 
// 3229 /*
// 3230  * gc_pred_update
// 3231  *
// 3232  *
// 3233  * Parameters:
// 3234  *    st->past_qua_en         B: MA predictor
// 3235  *    st->past_qua_en_MR122   B: MA predictor MR122
// 3236  *    qua_ener_MR122          I: quantized energy for update (log2(quaErr))
// 3237  *    qua_ener                I: quantized energy for update (20*log10(quaErr))
// 3238  *
// 3239  * Function:
// 3240  *    Update MA predictor with last quantized energy
// 3241  *
// 3242  * Returns:
// 3243  *    void
// 3244  */
// 3245 static void gc_pred_update( gc_predState *st, Word32 qua_ener_MR122,
// 3246       Word32 qua_ener )
// 3247 {
// 3248    Word32 i;
// 3249 
// 3250 
// 3251    for ( i = 3; i > 0; i-- ) {
// 3252       st->past_qua_en[i] = st->past_qua_en[i - 1];
// 3253       st->past_qua_en_MR122[i] = st->past_qua_en_MR122[i - 1];
// 3254    }
// 3255    st->past_qua_en_MR122[0] = qua_ener_MR122;   /* log2 (quaErr), Q10 */
// 3256    st->past_qua_en[0] = qua_ener;   /* 20*log10(quaErr), Q10 */
// 3257 }
// 3258 
// 3259 
// 3260 /*
// 3261  * Dec_gain
// 3262  *
// 3263  *
// 3264  * Parameters:
// 3265  *    pred_state->past_qua_en       B: MA predictor
// 3266  *    pred_state->past_qua_en_MR122 B: MA predictor MR122
// 3267  *    mode                          I: AMR mode
// 3268  *    index                         I: index of quantization
// 3269  *    code                          I: Innovative vector
// 3270  *    evenSubfr                     I: Flag for even subframes
// 3271  *    gain_pit                      O: Pitch gain
// 3272  *    gain_cod                      O: Code gain
// 3273  *
// 3274  * Function:
// 3275  *    Decode the pitch and codebook gains
// 3276  *
// 3277  * Returns:
// 3278  *    void
// 3279  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock51 Using cfiCommon1
        CFI Function Dec_gain
        ARM
// 3280 static void Dec_gain( gc_predState *pred_state, enum Mode mode, Word32 index,
// 3281       Word32 code[], Word32 evenSubfr, Word32 *gain_pit, Word32 *gain_cod )
// 3282 {
Dec_gain:
        PUSH     {R4-R10,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R10 Frame(CFA, -8)
        CFI R9 Frame(CFA, -12)
        CFI R8 Frame(CFA, -16)
        CFI R7 Frame(CFA, -20)
        CFI R6 Frame(CFA, -24)
        CFI R5 Frame(CFA, -28)
        CFI R4 Frame(CFA, -32)
        CFI CFA R13+32
        SUB      SP,SP,#+8
        CFI CFA R13+40
        MOV      R5,R1
        LDR      R1,[SP, #+40]
        LDR      R7,[SP, #+48]
        MOV      R6,R3
// 3283    Word32 frac, gcode0, exp, qua_ener, qua_ener_MR122, g_code, tmp;
// 3284    const Word32 *p;
// 3285 
// 3286 
// 3287    /* Read the quantized gains (table depends on mode) */
// 3288    index = index << 2;
// 3289 
// 3290    if ( ( mode == MR102 ) || ( mode == MR74 ) || ( mode == MR67 ) ) {
        LDR      R3,??Dec_gain_0  ;; table_gain_MR475
        MOV      R4,R0
        LDR      R0,[SP, #+44]
        LSL      R2,R2,#+2
        CMP      R5,#+6
        CMPNE    R5,#+4
        CMPNE    R5,#+3
// 3291       p = &table_gain_highrates[index];
        ADDEQ    R1,R3,R2, LSL #+2
        ADDEQ    R1,R1,#+4096
// 3292       *gain_pit = *p++;
        BEQ      ??Dec_gain_1
// 3293       g_code = *p++;
// 3294       qua_ener_MR122 = *p++;
// 3295       qua_ener = *p;
// 3296    }
// 3297    else {
// 3298       if ( mode == MR475 ) {
        CMP      R5,#+0
        BNE      ??Dec_gain_2
// 3299          index = index + ( ( 1 - evenSubfr ) << 1 );
// 3300          p = &table_gain_MR475[index];
        RSB      R1,R1,#+0
        ADD      R1,R2,R1, LSL #+1
        ADD      R1,R3,R1, LSL #+2
        ADD      R1,R1,#+8
// 3301          *gain_pit = *p++;
        LDR      R2,[R1], #+4
        STR      R2,[R0, #+0]
// 3302          g_code = *p++;
        LDR      R8,[R1, #+0]
// 3303 
// 3304             /*
// 3305              * calculate predictor update values (not stored in 4.75
// 3306              * quantizer table to save space):
// 3307              *   qua_ener       = log2(g)
// 3308              *   qua_ener_MR122 = 20*log10(g)
// 3309              */
// 3310          /* Log2(x Q12) = log2(x) + 12 */
// 3311          Log2( g_code, &exp, &frac );
        ADD      R2,SP,#+4
        MOV      R1,SP
        MOV      R0,R8
        BL       Log2
// 3312          exp = exp - 12;
        LDR      R1,[SP, #+0]
// 3313          tmp = frac >> 5;
// 3314 
// 3315          if ( ( frac & ( ( Word16 )1 << 4 ) ) != 0 ) {
// 3316             tmp++;
// 3317          }
// 3318          qua_ener_MR122 = tmp + ( exp << 10 );
// 3319 
// 3320          /* 24660 Q12 ~= 6.0206 = 20*log10(2) */
// 3321          tmp = exp * 49320;
// 3322          tmp += ( ( ( frac * 24660 ) >> 15 ) << 1 );
// 3323 
// 3324          /* Q12 * Q0 = Q13 -> Q10 */
// 3325          qua_ener = ( ( tmp << 13 ) + 0x00008000L ) >> 16;
        MOV      R2,#+84
        SUB      R1,R1,#+12
        STR      R1,[SP, #+0]
        LDR      R1,[SP, #+4]
        LDR      R0,[SP, #+4]
        TST      R1,#0x10
        LDR      R1,[SP, #+0]
        ASR      R0,R0,#+5
        ADDNE    R0,R0,#+1
        ADD      R9,R0,R1, LSL #+10
        MOV      R0,R1
        MOV      R1,#+168
        ORR      R1,R1,#0xC000
        MUL      R0,R1,R0
        LDR      R1,[SP, #+4]
        ORR      R2,R2,#0x6000
        MUL      R1,R2,R1
        ASR      R1,R1,#+15
        ADD      R0,R0,R1, LSL #+1
        MOV      R1,#+32768
        ADD      R0,R1,R0, LSL #+13
        ASR      R10,R0,#+16
        B        ??Dec_gain_3
// 3326       }
// 3327       else {
// 3328          p = &table_gain_lowrates[index];
??Dec_gain_2:
        ADD      R1,R3,R2, LSL #+2
        ADD      R1,R1,#+6144
// 3329          *gain_pit = *p++;
??Dec_gain_1:
        LDR      R2,[R1], #+4
        STR      R2,[R0, #+0]
// 3330          g_code = *p++;
        LDR      R8,[R1], #+4
// 3331          qua_ener_MR122 = *p++;
        LDR      R9,[R1], #+4
// 3332          qua_ener = *p;
        LDR      R10,[R1, #+0]
// 3333       }
// 3334    }
// 3335 
// 3336     /*
// 3337      * predict codebook gain
// 3338      * gc0 = Pow2(int(d)+frac(d))
// 3339      *     = 2^exp + 2^frac
// 3340      * gcode0 (Q14) = 2^14*2^frac = gc0 * 2^(14-exp)
// 3341      */
// 3342    gc_pred( pred_state, mode, code, &exp, &frac, NULL, NULL );
??Dec_gain_3:
        MOV      R0,#+0
        PUSH     {R0}
        CFI CFA R13+44
        PUSH     {R0}
        CFI CFA R13+48
        MOV      R2,R6
        MOV      R1,R5
        ADD      R0,SP,#+12
        PUSH     {R0}
        CFI CFA R13+52
        ADD      R3,SP,#+12
        MOV      R0,R4
        BL       gc_pred
// 3343    gcode0 = Pow2( 14, frac );
        LDR      R1,[SP, #+16]
        MOV      R0,#+14
        BL       Pow2
// 3344 
// 3345     /*
// 3346      * read quantized gains, update table of past quantized energies
// 3347      * st->past_qua_en(Q10) = 20 * Log10(gFac) / constant
// 3348      *                      = Log2(gFac)
// 3349      *                      = qua_ener
// 3350      * constant = 20*Log10(2)
// 3351      */
// 3352    if ( exp < 11 ) {
        LDR      R1,[SP, #+12]
        ADD      SP,SP,#+12
        CFI CFA R13+40
        CMP      R1,#+11
        BGE      ??Dec_gain_4
// 3353       *gain_cod = ( g_code * gcode0 ) >> ( 25 - exp );
        MUL      R1,R0,R8
        LDR      R0,[SP, #+0]
        RSB      R0,R0,#+25
        ASR      R0,R1,R0
        B        ??Dec_gain_5
// 3354    }
// 3355    else {
// 3356       tmp = ( ( g_code * gcode0 ) << ( exp - 9 ) );
??Dec_gain_4:
        MUL      R2,R0,R8
        ADD      R1,R1,#+247
        LSL      R0,R2,R1
// 3357 
// 3358       if ( ( tmp >> ( exp - 9 ) ) != ( g_code * gcode0 ) ) {
        CMP      R2,R0, ASR R1
// 3359          *gain_cod = 0x7FFF;
        MOVNE    R0,#+255
        ORRNE    R0,R0,#0x7F00
// 3360       }
// 3361       else {
// 3362          *gain_cod = tmp >> 16;
        ASREQ    R0,R0,#+16
??Dec_gain_5:
        STR      R0,[R7, #+0]
// 3363       }
// 3364    }
// 3365 
// 3366    /* update table of past quantized energies */
// 3367    gc_pred_update( pred_state, qua_ener_MR122, qua_ener );
        MOV      R0,#+3
??Dec_gain_6:
        ADD      R1,R4,R0, LSL #+2
        LDR      R2,[R1, #-4]
        STR      R2,[R4, +R0, LSL #+2]
        LDR      R2,[R1, #+12]!
        SUB      R0,R0,#+1
        STR      R2,[R1, #+4]
        CMP      R0,#+1
        BGE      ??Dec_gain_6
        STR      R9,[R4, #+16]
        STR      R10,[R4, #+0]
// 3368    return;
        POP      {R0,R1,R4-R10,PC}  ;; return
        DATA
??Dec_gain_0:
        DC32     table_gain_MR475
        CFI EndBlock cfiBlock51
// 3369 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock52 Using cfiCommon0
        CFI NoFunction
        THUMB
??ec_gain_code??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock52
        REQUIRE ec_gain_code
// 3370 
// 3371 
// 3372 /*
// 3373  * gc_pred_average_limited
// 3374  *
// 3375  *
// 3376  * Parameters:
// 3377  *    st->past_qua_en         I: MA predictor
// 3378  *    st->past_qua_en_MR122   I: MA predictor MR122
// 3379  *    ener_avg_MR122          O: everaged quantized energy (log2(quaErr))
// 3380  *    ener_avg                O: averaged quantized energy (20*log10(quaErr))
// 3381  *
// 3382  * Function:
// 3383  *    Compute average limited quantized energy
// 3384  * Returns:
// 3385  *    void
// 3386  */
// 3387 static void gc_pred_average_limited( gc_predState *st, Word32 *ener_avg_MR122,
// 3388       Word32 *ener_avg )
// 3389 {
// 3390    Word32 av_pred_en, i;
// 3391 
// 3392 
// 3393    /* do average in MR122 mode (log2() domain) */
// 3394    av_pred_en = 0;
// 3395 
// 3396    for ( i = 0; i < NPRED; i++ ) {
// 3397       av_pred_en = ( av_pred_en + st->past_qua_en_MR122[i] );
// 3398    }
// 3399 
// 3400    /* av_pred_en = 0.25*av_pred_en */
// 3401    av_pred_en = ( av_pred_en * 8192 ) >> 15;
// 3402 
// 3403    /* if (av_pred_en < -14/(20Log10(2))) av_pred_en = .. */
// 3404    if ( av_pred_en < MIN_ENERGY_MR122 ) {
// 3405       av_pred_en = MIN_ENERGY_MR122;
// 3406    }
// 3407    *ener_avg_MR122 = ( Word16 )av_pred_en;
// 3408 
// 3409    /* do average for other modes (20*log10() domain) */
// 3410    av_pred_en = 0;
// 3411 
// 3412    for ( i = 0; i < NPRED; i++ ) {
// 3413       av_pred_en = ( av_pred_en + st->past_qua_en[i] );
// 3414       if (av_pred_en < -32768)
// 3415          av_pred_en = -32768;
// 3416       else if (av_pred_en > 32767)
// 3417          av_pred_en = 32767;
// 3418    }
// 3419 
// 3420    /* av_pred_en = 0.25*av_pred_en */
// 3421    av_pred_en = ( av_pred_en * 8192 ) >> 15;
// 3422 
// 3423    *ener_avg = av_pred_en;
// 3424 }
// 3425 
// 3426 
// 3427 /*
// 3428  * ec_gain_code
// 3429  *
// 3430  *
// 3431  * Parameters:
// 3432  *    st->gbuf             I: last five gains
// 3433  *    st->past_gain_code   I: past gain
// 3434  *    pred_state           B: MA predictor state
// 3435  *    state                I: state of the state machine
// 3436  *    gain_code            O: decoded innovation gain
// 3437  *
// 3438  * Function:
// 3439  *    Conceal the codebook gain
// 3440  *
// 3441  * Returns:
// 3442  *    void
// 3443  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock53 Using cfiCommon1
        CFI Function ec_gain_code
        ARM
// 3444 static void ec_gain_code( ec_gain_codeState *st, gc_predState *pred_state,
// 3445       Word16 state, Word32 *gain_code )
// 3446 {
ec_gain_code:
        PUSH     {R4-R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
        MOV      R4,R1
        MOV      R6,R0
        MOV      R7,R2
        MOV      R5,R3
// 3447    Word32 tmp, qua_ener_MR122, qua_ener;
// 3448 
// 3449 
// 3450    /* calculate median of last five gain values */
// 3451    tmp = gmed_n( st->gbuf, 5 );
        MOV      R1,#+5
        BL       gmed_n
// 3452 
// 3453    /* new gain = minimum(median, past_gain) * cdown[state] */
// 3454    if ( tmp > st->past_gain_code ) {
        LDR      R1,[R6, #+20]
        CMP      R1,R0
// 3455       tmp = st->past_gain_code;
        MOVLT    R0,R1
// 3456    }
// 3457    tmp = ( tmp * cdown[state] ) >> 15;
// 3458    *gain_code = tmp;
        LDR      R1,??ec_gain_code_0  ;; cdown
        LDR      R1,[R1, +R7, LSL #+2]
        MUL      R0,R1,R0
// 3459 
// 3460       /*
// 3461        * update table of past quantized energies with average of
// 3462        * current values
// 3463        */
// 3464    gc_pred_average_limited( pred_state, &qua_ener_MR122, &qua_ener );
        MOV      R1,#+0
        ASR      R0,R0,#+15
        STR      R0,[R5, #+0]
        MOV      R0,#+0
??ec_gain_code_1:
        ADD      R2,R4,R1, LSL #+2
        LDR      R2,[R2, #+16]
        ADD      R1,R1,#+1
        ADD      R0,R2,R0
        CMP      R1,#+4
        BLT      ??ec_gain_code_1
        LSL      R0,R0,#+13
        ASR      R0,R0,#+15
        MVN      R1,#+76
        BIC      R1,R1,#0x900
        CMP      R0,R1
        MOVLT    R0,R1
        MOV      R0,R0, LSL #+16
        MOV      R0,R0, ASR #+16
        MOV      R1,#+0
        MOV      R2,#+0
??ec_gain_code_2:
        LDR      R3,[R4, +R2, LSL #+2]
        ADD      R2,R2,#+1
        ADD      R1,R3,R1
        MOVS     R3,R1, ASR #+15
        MVNSNE   R3,R3
        MVNNE    R3,#+0
        MOVNE    R1,R3, LSL #+15
        MVNMI    R1,R1
        CMP      R2,#+4
        BLT      ??ec_gain_code_2
// 3465    gc_pred_update( pred_state, qua_ener_MR122, qua_ener );
        LSL      R1,R1,#+13
        ASR      R1,R1,#+15
        MOV      R2,#+3
??ec_gain_code_3:
        ADD      R3,R4,R2, LSL #+2
        LDR      R5,[R3, #-4]
        STR      R5,[R4, +R2, LSL #+2]
        LDR      R5,[R3, #+12]!
        SUB      R2,R2,#+1
        STR      R5,[R3, #+4]
        CMP      R2,#+1
        BGE      ??ec_gain_code_3
        STR      R0,[R4, #+16]
        STR      R1,[R4, #+0]
// 3466 }
        POP      {R4-R7,PC}       ;; return
        DATA
??ec_gain_code_0:
        DC32     cdown
        CFI EndBlock cfiBlock53

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock54 Using cfiCommon0
        CFI NoFunction
        THUMB
??ec_gain_code_update??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock54
        REQUIRE ec_gain_code_update
// 3467 
// 3468 
// 3469 /*
// 3470  * ec_gain_code_update
// 3471  *
// 3472  *
// 3473  * Parameters:
// 3474  *    st->gbuf             B: last five gains
// 3475  *    st->past_gain_code   O: past gain
// 3476  *    st->prev_gc          B  previous gain
// 3477  *    bfi                  I: bad indicator
// 3478  *    prev_bf              I: previous frame bad indicator
// 3479  *    gain_code            O: decoded innovation gain
// 3480  *
// 3481  * Function:
// 3482  *    Update the codebook gain concealment state
// 3483  *
// 3484  * Returns:
// 3485  *    void
// 3486  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock55 Using cfiCommon1
        CFI Function ec_gain_code_update
        ARM
// 3487 static void ec_gain_code_update( ec_gain_codeState *st, Word16 bfi,
// 3488       Word16 prev_bf, Word32 *gain_code )
// 3489 {
// 3490    /* limit gain_code by previous good gain if previous frame was bad */
// 3491    if ( bfi == 0 ) {
ec_gain_code_update:
        CMP      R1,#+0
        BNE      ??ec_gain_code_update_0
// 3492       if ( prev_bf != 0 ) {
        CMP      R2,#+0
        BEQ      ??ec_gain_code_update_1
// 3493          if ( *gain_code > st->prev_gc ) {
        LDR      R1,[R0, #+24]
        LDR      R2,[R3, #+0]
        CMP      R1,R2
// 3494             *gain_code = st->prev_gc;
        STRLT    R1,[R3, #+0]
// 3495          }
// 3496       }
// 3497       st->prev_gc = *gain_code;
??ec_gain_code_update_1:
        LDR      R1,[R3, #+0]
        STR      R1,[R0, #+24]
// 3498    }
// 3499 
// 3500    /* update EC states: previous gain, gain buffer */
// 3501    st->past_gain_code = *gain_code;
??ec_gain_code_update_0:
        LDR      R1,[R3, #+0]
        STR      R1,[R0, #+20]
// 3502    st->gbuf[0] = st->gbuf[1];
        LDR      R1,[R0, #+4]
        STR      R1,[R0, #+0]
// 3503    st->gbuf[1] = st->gbuf[2];
        LDR      R1,[R0, #+8]
        STR      R1,[R0, #+4]
// 3504    st->gbuf[2] = st->gbuf[3];
        LDR      R1,[R0, #+12]
        STR      R1,[R0, #+8]
// 3505    st->gbuf[3] = st->gbuf[4];
        LDR      R1,[R0, #+16]
        STR      R1,[R0, #+12]
// 3506    st->gbuf[4] = *gain_code;
        LDR      R1,[R3, #+0]
        STR      R1,[R0, #+16]
// 3507    return;
        BX       LR               ;; return
        CFI EndBlock cfiBlock55
// 3508 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock56 Using cfiCommon0
        CFI NoFunction
        THUMB
??d_gain_code??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock56
        REQUIRE d_gain_code
// 3509 
// 3510 
// 3511 /*
// 3512  * d_gain_code
// 3513  *
// 3514  *
// 3515  * Parameters:
// 3516  *    pred_state        B: MA predictor state
// 3517  *    mode              I: AMR mode (MR795 or MR122)
// 3518  *    index             I: received quantization index
// 3519  *    code              I: innovation codevector
// 3520  *    gain_code         O: decoded innovation gain
// 3521  *
// 3522  * Function:
// 3523  *    Decode the fixed codebook gain using the received index
// 3524  *
// 3525  * Returns:
// 3526  *    void
// 3527  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock57 Using cfiCommon1
        CFI Function d_gain_code
        ARM
// 3528 static void d_gain_code( gc_predState *pred_state, enum Mode mode, Word32 index,
// 3529                         Word32 code[], Word32 *gain_code )
// 3530 {
d_gain_code:
        PUSH     {R4-R9,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R9 Frame(CFA, -8)
        CFI R8 Frame(CFA, -12)
        CFI R7 Frame(CFA, -16)
        CFI R6 Frame(CFA, -20)
        CFI R5 Frame(CFA, -24)
        CFI R4 Frame(CFA, -28)
        CFI CFA R13+28
        SUB      SP,SP,#+16
        CFI CFA R13+44
        LDR      R5,[SP, #+44]
        MOV      R4,R0
// 3531    Word32 g_code0, exp, frac, qua_ener_MR122, qua_ener;
// 3532    Word32 exp_inn_en, frac_inn_en, tmp, tmp2, i;
// 3533    const Word32 *p;
// 3534 
// 3535 
// 3536    /*
// 3537     * Decode codebook gain
// 3538     */
// 3539    gc_pred( pred_state, mode, code, &exp, &frac, &exp_inn_en, &frac_inn_en );
        ADD      R0,SP,#+12
        PUSH     {R0}
        CFI CFA R13+48
        MOV      R9,R1
        MOV      R6,R2
        MOV      R2,R3
        ADD      R0,SP,#+12
        PUSH     {R0}
        CFI CFA R13+52
// 3540    p = &qua_gain_code[( ( index + index )+ index )];
// 3541 
// 3542    /* Different scalings between MR122 and the other modes */
// 3543    if ( mode == MR122 ) {
        MOV      R7,#+255
        ORR      R7,R7,#0x7F00
        MVN      R8,R7
        ADD      R0,SP,#+12
        PUSH     {R0}
        CFI CFA R13+56
        ADD      R3,SP,#+12
        MOV      R0,R4
        BL       gc_pred
        LDR      R1,??d_gain_code_0  ;; qua_gain_code
        ADD      R0,R6,R6, LSL #+1
        ADD      R6,R1,R0, LSL #+2
        CMP      R9,#+7
        ADD      SP,SP,#+12
        CFI CFA R13+44
        BNE      ??d_gain_code_1
// 3544       /* predicted gain */
// 3545       g_code0 = Pow2( exp, frac );
        LDR      R1,[SP, #+4]
        LDR      R0,[SP, #+0]
        BL       Pow2
// 3546 
// 3547       if ( g_code0 <= 2047 )
// 3548          g_code0 = g_code0 << 4;
// 3549       else
// 3550          g_code0 = 32767;
// 3551       *gain_code = ( ( g_code0 * *p++ ) >> 15 ) << 1;
        LDR      R1,[R6], #+4
        CMP      R0,#+2048
        LSLLT    R0,R0,#+4
        MOVGE    R0,R7
        MUL      R0,R1,R0
        ASR      R0,R0,#+15
        LSL      R0,R0,#+1
// 3552       if (*gain_code & 0xFFFF8000)
        B        ??d_gain_code_2
// 3553          *gain_code = 32767;
// 3554 
// 3555    }
// 3556    else {
// 3557       g_code0 = Pow2( 14, frac );
// 3558       tmp = ( *p++ * g_code0 ) << 1;
??d_gain_code_1:
        LDR      R9,[R6], #+4
        LDR      R1,[SP, #+4]
        MOV      R0,#+14
        BL       Pow2
// 3559       exp = 9 - exp;
        LDR      R2,[SP, #+0]
        MUL      R1,R0,R9
        RSB      R2,R2,#+9
        LSL      R0,R1,#+1
        STR      R2,[SP, #+0]
// 3560 
// 3561       if ( exp > 0 ) {
        MOV      R1,R2
        CMP      R1,#+1
        BLT      ??d_gain_code_3
// 3562          tmp = tmp >> exp;
        ASR      R0,R0,R1
        B        ??d_gain_code_4
// 3563       }
// 3564       else {
// 3565          for (i = exp; i < 0; i++) {
// 3566             tmp2 = tmp << 1;
// 3567             if ((tmp ^ tmp2) & 0x80000000) {
// 3568                tmp = (tmp & 0x80000000) ? 0x80000000 : 0x7FFFFFFF;
// 3569                break;
// 3570             }
// 3571             else {
// 3572                tmp = tmp2;
??d_gain_code_5:
        MOV      R0,R2
// 3573             }
        ADD      R1,R1,#+1
??d_gain_code_3:
        CMP      R1,#+0
        BPL      ??d_gain_code_4
        LSL      R2,R0,#+1
        EOR      R3,R2,R0
        TST      R3,#0x80000000
        BEQ      ??d_gain_code_5
        TST      R0,#0x80000000
        MOVNE    R0,#-2147483648
        MVNEQ    R0,#-2147483648
// 3574          }
// 3575       }
// 3576       *gain_code = tmp >> 16;
??d_gain_code_4:
        ASR      R0,R0,#+16
// 3577       if (*gain_code & 0xFFFF8000)
??d_gain_code_2:
        TST      R8,R0
// 3578          *gain_code = 32767;
        MOVNE    R0,R7
        STR      R0,[R5, #+0]
// 3579    }
// 3580 
// 3581    /*
// 3582     * update table of past quantized energies
// 3583     */
// 3584    qua_ener_MR122 = *p++;
        LDR      R0,[R6], #+4
// 3585    qua_ener = *p++;
// 3586    gc_pred_update( pred_state, qua_ener_MR122, qua_ener );
        LDR      R1,[R6, #+0]
        MOV      R2,#+3
??d_gain_code_6:
        ADD      R3,R4,R2, LSL #+2
        LDR      R5,[R3, #-4]
        STR      R5,[R4, +R2, LSL #+2]
        LDR      R5,[R3, #+12]!
        SUB      R2,R2,#+1
        STR      R5,[R3, #+4]
        CMP      R2,#+1
        BGE      ??d_gain_code_6
        STR      R0,[R4, #+16]
        STR      R1,[R4, #+0]
// 3587    return;
        POP      {R0-R9,PC}       ;; return
        DATA
??d_gain_code_0:
        DC32     qua_gain_code
        CFI EndBlock cfiBlock57
// 3588 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock58 Using cfiCommon0
        CFI NoFunction
        THUMB
??Int_lsf??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock58
        REQUIRE Int_lsf
// 3589 
// 3590 
// 3591 /*
// 3592  * Int_lsf
// 3593  *
// 3594  *
// 3595  * Parameters:
// 3596  *    lsf_old           I: LSF vector at the 4th subframe of past frame
// 3597  *    lsf_new           I: LSF vector at the 4th subframe of present frame
// 3598  *    i_subfr           I: current subframe
// 3599  *    lsf_out           O: interpolated LSF parameters for current subframe
// 3600  *
// 3601  * Function:
// 3602  *    Interpolates the LSFs for selected subframe
// 3603  *
// 3604  *    The LSFs are interpolated at the 1st, 2nd and 3rd
// 3605  *    ubframe and only forwarded at the 4th subframe.
// 3606  *
// 3607  *    sf1:  3/4 F0 + 1/4 F1
// 3608  *    sf2:  1/2 F0 + 1/2 F1
// 3609  *    sf3:  1/4 F0 + 3/4 F1
// 3610  *    sf4:  F1
// 3611  *
// 3612  * Returns:
// 3613  *    void
// 3614  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock59 Using cfiCommon1
        CFI Function Int_lsf
        ARM
// 3615 static void Int_lsf( Word32 lsf_old[], Word32 lsf_new[], int i_subfr, Word32
// 3616       lsf_out[] )
// 3617 {
Int_lsf:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
        MOV      R12,R0
        MOV      R0,R3
// 3618    Word32 i;
// 3619 
// 3620 
// 3621    switch ( i_subfr ) {
        CMP      R2,#+0
        BEQ      ??Int_lsf_0
        SUBS     R2,R2,#+40
        BEQ      ??Int_lsf_1
        SUBS     R2,R2,#+40
        BEQ      ??Int_lsf_2
        SUBS     R2,R2,#+40
        BEQ      ??Int_lsf_3
        POP      {R4,PC}
// 3622       case 0:
// 3623          for ( i = 0; i < 10; i++ ) {
// 3624             lsf_out[i] = lsf_old[i] - ( lsf_old[i] >> 2 ) + ( lsf_new[i] >> 2 );
??Int_lsf_0:
        LDR      R3,[R12, +R2, LSL #+2]
        LDR      R4,[R1, +R2, LSL #+2]
        SUB      R3,R3,R3, ASR #+2
        ADD      R3,R3,R4, ASR #+2
        STR      R3,[R0, +R2, LSL #+2]
// 3625          }
        ADD      R2,R2,#+1
        CMP      R2,#+10
        POPGE    {R4,PC}
        B        ??Int_lsf_0
// 3626          break;
// 3627 
// 3628       case 40:
// 3629          for ( i = 0; i < 10; i++ ) {
??Int_lsf_1:
        MOV      R2,#+0
// 3630             lsf_out[i] = ( lsf_old[i] >> 1 ) + ( lsf_new[i] >> 1 );
??Int_lsf_4:
        LDR      R3,[R12, +R2, LSL #+2]
        LDR      R4,[R1, +R2, LSL #+2]
        ASR      R4,R4,#+1
        ADD      R3,R4,R3, ASR #+1
        STR      R3,[R0, +R2, LSL #+2]
// 3631          }
        ADD      R2,R2,#+1
        CMP      R2,#+10
        POPGE    {R4,PC}
        B        ??Int_lsf_4
// 3632          break;
// 3633 
// 3634       case 80:
// 3635          for ( i = 0; i < 10; i++ ) {
??Int_lsf_2:
        MOV      R2,#+0
// 3636             lsf_out[i] = ( lsf_old[i] >> 2 ) - ( lsf_new[i] >> 2 ) +
// 3637                   lsf_new[i];
??Int_lsf_5:
        LDR      R3,[R12, +R2, LSL #+2]
        LDR      R4,[R1, +R2, LSL #+2]
        ASR      R3,R3,#+2
        SUB      R3,R3,R4, ASR #+2
        ADD      R3,R4,R3
        STR      R3,[R0, +R2, LSL #+2]
// 3638          }
        ADD      R2,R2,#+1
        CMP      R2,#+10
        POPGE    {R4,PC}
        B        ??Int_lsf_5
// 3639          break;
// 3640 
// 3641       case 120:
// 3642          memcpy( lsf_out, lsf_new, M <<2 );
??Int_lsf_3:
        MOV      R2,#+40
        SWI      +286
// 3643          break;
// 3644    }
// 3645 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock59

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock60 Using cfiCommon0
        CFI NoFunction
        THUMB
??Cb_gain_average??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock60
        REQUIRE Cb_gain_average
// 3646 
// 3647 
// 3648 /*
// 3649  * Cb_gain_average
// 3650  *
// 3651  *
// 3652  * Parameters:
// 3653  *    st->cbGainHistory B: codebook gain history
// 3654  *    st->hangCount     B: hangover counter
// 3655  *    mode              I: AMR mode
// 3656  *    gain_code         I: codebook gain
// 3657  *    lsp               I: The LSP for the current frame
// 3658  *    lspAver           I: The average of LSP for 8 frames
// 3659  *    bfi               I: bad frame indication
// 3660  *    prev_bf           I: previous bad frame indication
// 3661  *    pdfi              I: potential degraded bad frame indication
// 3662  *    prev_pdf          I: previous potential degraded bad frame indication
// 3663  *    inBackgroundNoise I: background noise decision
// 3664  *    voicedHangover    I: number of frames after last voiced frame
// 3665  *
// 3666  * Function:
// 3667  *    The mixed codebook gain, used to make codebook gain more smooth in background
// 3668  *
// 3669  *
// 3670  * Returns:
// 3671  *    void
// 3672  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock61 Using cfiCommon1
        CFI Function Cb_gain_average
        ARM
// 3673 static Word32 Cb_gain_average( Cb_gain_averageState *st, enum Mode mode, Word32
// 3674       gain_code, Word32 lsp[], Word32 lspAver[], Word16 bfi, Word16 prev_bf,
// 3675       Word16 pdfi, Word16 prev_pdf, Word32 inBackgroundNoise, Word32
// 3676       voicedHangover )
// 3677 {
Cb_gain_average:
        PUSH     {R3-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+40
        SUB      SP,SP,#+52
        CFI CFA R13+92
        MOV      R3,R0
        MOV      R4,R1
        LDRSH    R5,[SP, #+96]
        LDRSH    R6,[SP, #+100]
        LDRSH    R7,[SP, #+104]
        LDRSH    R8,[SP, #+108]
        MOV      R0,R2
        LDR      R2,[SP, #+92]
// 3678    Word32 tmp[M];
// 3679    Word32 i, cbGainMix, tmp_diff, bgMix, cbGainMean, sum, diff, tmp1, tmp2;
// 3680    int shift1, shift2, shift;
// 3681 
// 3682 
// 3683    /* set correct cbGainMix for MR74, MR795, MR122 */
// 3684    cbGainMix = gain_code;
        STR      R0,[SP, #+4]
// 3685 
// 3686    /*
// 3687     * Store list of CB gain needed in the CB gain averaging                                           *
// 3688     */
// 3689    st->cbGainHistory[0] = st->cbGainHistory[1];
        LDR      R1,[R3, #+8]
// 3690    st->cbGainHistory[1] = st->cbGainHistory[2];
// 3691    st->cbGainHistory[2] = st->cbGainHistory[3];
// 3692    st->cbGainHistory[3] = st->cbGainHistory[4];
// 3693    st->cbGainHistory[4] = st->cbGainHistory[5];
// 3694    st->cbGainHistory[5] = st->cbGainHistory[6];
// 3695    st->cbGainHistory[6] = gain_code;
// 3696 
// 3697    /* compute lsp difference */
// 3698    for ( i = 0; i < M; i++ ) {
        MOV      R9,#+0
        STR      R1,[R3, #+4]
        LDR      R1,[R3, #+12]
        STR      R1,[R3, #+8]
        LDR      R1,[R3, #+16]
        STR      R1,[R3, #+12]
        LDR      R1,[R3, #+20]
        STR      R1,[R3, #+16]
        LDR      R1,[R3, #+24]
        STR      R1,[R3, #+20]
        LDR      R1,[R3, #+28]
        STR      R1,[R3, #+24]
        STR      R0,[R3, #+28]
// 3699       tmp1 = labs( lspAver[i]- lsp[i] );
??Cb_gain_average_0:
        LDR      R0,[SP, #+52]
        ADD      R1,R2,R9, LSL #+2
        LDR      R10,[R1, #+0]
        ADD      R0,R0,R9, LSL #+2
        LDR      R11,[R0, #+0]
        SUBS     R10,R10,R11
        LDRMI    R10,[R1, #+0]
        SUBMI    R0,R11,R10
        LDRPL    R10,[R1, #+0]
        SUBPL    R0,R10,R11
// 3700       shift1 = 0;
        MOV      R10,#+0
// 3701       if (tmp1 != 0){
        CMP      R0,#+0
        BNE      ??Cb_gain_average_1
        B        ??Cb_gain_average_2
// 3702          while (!(tmp1 & 0x2000))
// 3703          {
// 3704             shift1++;
??Cb_gain_average_3:
        ADD      R10,R10,#+1
// 3705             tmp1 = tmp1 << 1;
        LSL      R0,R0,#+1
// 3706          }
??Cb_gain_average_1:
        TST      R0,#0x2000
        BEQ      ??Cb_gain_average_3
// 3707       }
// 3708       tmp2 = lspAver[i];
??Cb_gain_average_2:
        LDR      R1,[R1, #+0]
// 3709       shift2 = 0;
        MOV      R11,#+0
// 3710       if (tmp2 != 0){
        CMP      R1,#+0
        BNE      ??Cb_gain_average_4
        B        ??Cb_gain_average_5
// 3711          while (!(tmp2 & 0x4000))
// 3712          {
// 3713             shift2++;
??Cb_gain_average_6:
        ADD      R11,R11,#+1
// 3714             tmp2 = tmp2 << 1;
        LSL      R1,R1,#+1
// 3715          }
??Cb_gain_average_4:
        TST      R1,#0x4000
        BEQ      ??Cb_gain_average_6
// 3716       }
// 3717       tmp[i] = ( tmp1 << 15 ) / tmp2;
??Cb_gain_average_5:
        LSL      R0,R0,#+15
        _BLF     ??div32_a,??rA??div32_a
        ADD      R0,SP,#+12
        ADD      R0,R0,R9, LSL #+2
        STR      R1,[R0, #+0]
// 3718       shift = 2 + shift1 - shift2;
        ADD      R10,R10,#+2
        SUBS     R10,R10,R11
// 3719 
// 3720       if ( shift >= 0 ) {
// 3721          tmp[i] = tmp[i] >> shift;
        ASRPL    R1,R1,R10
// 3722       }
// 3723       else {
// 3724          tmp[i] = tmp[i] << -( shift );
        RSBMI    R10,R10,#+0
        LSLMI    R1,R1,R10
        STR      R1,[R0, #+0]
// 3725       }
// 3726    }
        ADD      R9,R9,#+1
        CMP      R9,#+10
        BLT      ??Cb_gain_average_0
// 3727    diff = *tmp + tmp[1] + tmp[2] + tmp[3] + tmp[4] + tmp[5] + tmp[6] + tmp[7] +
// 3728          tmp[8] + tmp[9];
        LDR      R0,[SP, #+12]
        LDR      R1,[SP, #+16]
// 3729 
// 3730    /* saturate */
// 3731    if ( diff > 32767 ) {
// 3732       diff = 32767;
// 3733    }
// 3734 
// 3735    /* Compute hangover */
// 3736    st->hangVar += 1;
// 3737 
// 3738    if ( diff <= 5325 ) {
        MOV      R10,#+206
        ADD      R0,R1,R0
        LDR      R1,[SP, #+20]
        ORR      R10,R10,#0x1400
        ADD      R0,R1,R0
        LDR      R1,[SP, #+24]
// 3739       st->hangVar = 0;
// 3740    }
// 3741 
// 3742    if ( st->hangVar > 10 ) {
// 3743       /* Speech period, reset hangover variable */
// 3744       st->hangCount = 0;
// 3745    }
// 3746 
// 3747    /* Compute mix constant (bgMix) */
// 3748    bgMix = 8192;
        MOV      R9,#+8192
        ADD      R0,R1,R0
        LDR      R1,[SP, #+28]
        ADD      R0,R1,R0
        LDR      R1,[SP, #+32]
        ADD      R0,R1,R0
        LDR      R1,[SP, #+36]
        ADD      R0,R1,R0
        LDR      R1,[SP, #+40]
        ADD      R0,R1,R0
        LDR      R1,[SP, #+44]
        ADD      R0,R1,R0
        LDR      R1,[SP, #+48]
        ADD      R0,R1,R0
        LDRSH    R1,[R3, #+32]
        CMP      R0,#+32768
        MOVGE    R0,#+255
        ORRGE    R0,R0,#0x7F00
        ADD      R2,R1,#+1
        MOV      R1,#+0
        CMP      R0,R10
        MOVLT    R2,#+0
        STRH     R2,[R3, #+32]
        MOV      R2,R2, LSL #+16
        MOV      R2,R2, ASR #+16
        CMP      R2,#+11
        STRGE    R1,[R3, #+0]
// 3749 
// 3750    /* MR475, MR515, MR59, MR67, MR102 */
// 3751    if ( ( mode <= MR67 ) | ( mode == MR102 ) ) {
        LDR      R11,[R3, #+0]
        CMP      R4,#+4
        STR      R11,[SP, #+8]
        BCC      ??Cb_gain_average_7
        CMP      R4,#+6
        BNE      ??Cb_gain_average_8
// 3752       /* disable mix if too short time since */
// 3753       if ( ( st->hangCount >= 40 ) & ( diff <= 5325 ) ) /* 0.65 in Q13 */ {
??Cb_gain_average_7:
        MOV      R2,#+1
        CMP      R11,#+40
        BLT      ??Cb_gain_average_9
        CMP      R0,R10
        BGE      ??Cb_gain_average_9
// 3754          /* if errors and presumed noise make smoothing probability stronger */
// 3755          if ( ( ( ( ( pdfi != 0 ) & ( prev_pdf != 0 ) ) | ( bfi != 0 ) | (
// 3756                prev_bf != 0 ) ) & ( ( voicedHangover > 1 ) ) & (
// 3757                inBackgroundNoise != 0 ) & ( mode < MR67 ) ) ) {
        CMP      R7,#+0
        STRBNE   R2,[SP, #+0]
        MOVEQ    R10,#+0
        STRBEQ   R10,[SP, #+0]
        LDRB     R12,[SP, #+0]
        LDR      R10,[SP, #+112]
        CMP      R8,#+0
        STRBNE   R2,[SP, #+1]
        STRBEQ   R8,[SP, #+1]
        LDRB     LR,[SP, #+1]
        CMP      R5,#+0
        STRBNE   R2,[SP, #+2]
        MOVEQ    R8,#+0
        STRBEQ   R8,[SP, #+2]
        LDR      R8,[SP, #+116]
        AND      R12,LR,R12
        LDRB     LR,[SP, #+2]
        CMP      R6,#+0
        MOVNE    R7,#+1
        MOVEQ    R7,#+0
        CMP      R8,#+2
        MOVGE    R8,#+1
        MOVLT    R8,#+0
        CMP      R10,#+0
        MOVNE    R10,#+1
        CMP      R4,#+3
        MOVCC    R11,#+1
        MOVCS    R11,#+0
        ORR      R12,LR,R12
        ORR      R7,R7,R12
        AND      R7,R8,R7
        AND      R7,R10,R7
        TST      R11,R7
// 3758             /* bgMix = min(0.25, max(0.0, diff-0.55)) / 0.25; */
// 3759             tmp_diff = diff - 4506;   /* 0.55 in Q13 */
        MVNNE    R7,#+153
        BICNE    R7,R7,#0x1100
// 3760 
// 3761             /* max(0.0, diff-0.55) */
// 3762             tmp1 = 0;
// 3763 
// 3764             if ( tmp_diff > 0 ) {
// 3765                tmp1 = tmp_diff;
// 3766             }
// 3767 
// 3768             /* min(0.25, tmp1) */
// 3769             if ( 2048 >= tmp1 ) {
// 3770                bgMix = tmp1 << 2;
// 3771             }
// 3772          }
// 3773          else {
// 3774             /* bgMix = min(0.25, max(0.0, diff-0.40)) / 0.25; */
// 3775             tmp_diff = diff - 3277;   /* 0.4 in Q13 */
        MVNEQ    R7,#+204
        BICEQ    R7,R7,#0xC00
        ADD      R7,R7,R0
// 3776 
// 3777             /* max(0.0, diff-0.40) */
// 3778             tmp1 = 0;
        MOV      R0,#+0
// 3779 
// 3780             if ( tmp_diff > 0 ) {
        CMP      R7,#+1
        BLT      ??Cb_gain_average_10
// 3781                tmp1 = tmp_diff;
        MOV      R0,R7
// 3782             }
// 3783 
// 3784             /* min(0.25, tmp1) */
// 3785             if ( 2048 >= tmp1 ) {
        ORR      R7,R2,#0x800
        CMP      R0,R7
        BGE      ??Cb_gain_average_9
// 3786                bgMix = tmp1 << 2;
??Cb_gain_average_10:
        LSL      R9,R0,#+2
// 3787             }
// 3788          }
// 3789       }
// 3790 
// 3791       /*
// 3792        * Smoothen the cb gain trajectory
// 3793        * smoothing depends on mix constant bgMix
// 3794        */
// 3795       sum = st->cbGainHistory[2] + st->cbGainHistory[3] + st->cbGainHistory[4] +
// 3796             st->cbGainHistory[5] + st->cbGainHistory[6];
??Cb_gain_average_9:
        LDR      R0,[R3, #+28]
        LDR      R7,[R3, #+24]
        LDR      R8,[R3, #+20]
        LDR      R10,[R3, #+16]
        LDR      R11,[R3, #+12]
// 3797 
// 3798       if ( sum > 163822 ) {
        LDR      LR,??Cb_gain_average_11  ;; 0x27fef
        ADD      R12,R10,R11
        ADD      R12,R8,R12
        ADD      R12,R7,R12
        ADD      R12,R0,R12
        CMP      R12,LR
// 3799          cbGainMean = 32767;
        MOVGE    R12,#+255
        ORRGE    R12,R12,#0x7F00
        BGE      ??Cb_gain_average_12
// 3800       }
// 3801       else {
// 3802          cbGainMean = ( 3277 * sum + 0x00002000L ) >> 14;   /* Q1 */
        MOV      LR,#+205
        ORR      LR,LR,#0xC00
        MUL      R12,LR,R12
        ADD      R12,R12,#+8192
        ASR      R12,R12,#+14
// 3803       }
// 3804 
// 3805       /* more smoothing in error and bg noise (NB no DFI used  here) */
// 3806       if ( ( ( bfi != 0 ) | ( prev_bf != 0 ) ) & ( inBackgroundNoise != 0 ) & (
// 3807             mode < MR67 ) ) {
??Cb_gain_average_12:
        LDR      LR,[SP, #+112]
        CMP      R5,#+0
        MOVNE    R5,#+1
        CMP      R6,#+0
        MOVNE    R6,#+1
        CMP      LR,#+0
        MOVNE    LR,#+1
        CMP      R4,#+3
        MOVCS    R2,#+0
        ORR      R1,R6,R5
        AND      R1,LR,R1
        TST      R2,R1
        BEQ      ??Cb_gain_average_13
// 3808          sum = 9362 * ( st->cbGainHistory[0] + st->cbGainHistory[1] + st->
// 3809                cbGainHistory[2] + st->cbGainHistory[3] + st->cbGainHistory[4] +
// 3810                st->cbGainHistory[5] + st->cbGainHistory[6] );
// 3811          cbGainMean = ( sum + 0x00008000L ) >> 16;   /* Q1 */
        LDR      R1,[R3, #+4]
        LDR      R2,[R3, #+8]
        ADD      R1,R2,R1
        ADD      R1,R11,R1
        ADD      R1,R10,R1
        ADD      R1,R8,R1
        ADD      R1,R7,R1
        ADD      R0,R0,R1
        MOV      R1,#+146
        ORR      R1,R1,#0x2400
        MUL      R0,R1,R0
        ADD      R0,R0,#+32768
        ASR      R12,R0,#+16
// 3812       }
// 3813 
// 3814       /* cbGainMix = bgMix*cbGainMix + (1-bgMix)*cbGainMean; */
// 3815       sum = bgMix * cbGainMix;   /* sum in Q14 */
// 3816       sum += cbGainMean << 13;
// 3817       sum -= bgMix * cbGainMean;
// 3818       cbGainMix = ( sum + 0x00001000L ) >> 13;
??Cb_gain_average_13:
        LDR      R1,[SP, #+4]
        MUL      R2,R1,R9
        ADD      R1,R2,R12, LSL #+13
        MUL      R2,R12,R9
        SUB      R1,R1,R2
        ADD      R1,R1,#+4096
        ASR      R1,R1,#+13
        STR      R1,[SP, #+4]
// 3819 
// 3820       /* Q1 */
// 3821    }
// 3822    st->hangCount += 1;
??Cb_gain_average_8:
        LDR      R0,[SP, #+8]
        ADD      R0,R0,#+1
        STR      R0,[R3, #+0]
// 3823    if (st->hangCount & 0x80000000)
        TST      R0,#0x80000000
// 3824       st->hangCount = 40;
        MOVNE    R0,#+40
        STRNE    R0,[R3, #+0]
// 3825    return cbGainMix;
        LDR      R0,[SP, #+4]
        ADD      SP,SP,#+56
        CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        DATA
??Cb_gain_average_11:
        DC32     0x27fef
        CFI EndBlock cfiBlock61
// 3826 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock62 Using cfiCommon0
        CFI NoFunction
        THUMB
??ph_disp??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock62
        REQUIRE ph_disp
// 3827 
// 3828 
// 3829 /*
// 3830  * ph_disp
// 3831  *
// 3832  *
// 3833  * Parameters:
// 3834  *    state->gainMem    B: LTP gain memory
// 3835  *    state->prevCbGain B: Codebook gain memory
// 3836  *    mode              I: AMR mode
// 3837  *    x                 B: LTP excitation signal -> total excitation signal
// 3838  *    cbGain            I: Codebook gain
// 3839  *    ltpGain           I: LTP gain
// 3840  *    inno              B: Innovation vector
// 3841  *    pitch_fac         I: pitch factor used to scale the LTP excitation
// 3842  *    tmp_shift         I: shift factor applied to sum of scaled LTP ex & innov.
// 3843  *                         before rounding
// 3844  *
// 3845  * Function:
// 3846  *    Adaptive phase dispersion; forming of total excitation
// 3847  *
// 3848  *
// 3849  * Returns:
// 3850  *    void
// 3851  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock63 Using cfiCommon1
        CFI Function ph_disp
        ARM
// 3852 static void ph_disp( ph_dispState *state, enum Mode mode, Word32 x[],
// 3853                     Word32 cbGain, Word32 ltpGain, Word32 inno[],
// 3854                     Word32 pitch_fac, Word32 tmp_shift)
// 3855 {
ph_disp:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
        SUB      SP,SP,#+320
        CFI CFA R13+356
        LDR      R7,[SP, #+360]
        LDR      R8,[SP, #+364]
        LDR      R9,[SP, #+368]
        MOV      R5,R2
// 3856    Word32 inno_sav[L_SUBFR], ps_poss[L_SUBFR];
// 3857    Word32 i, i1, impNr, temp1, temp2, j, nze, nPulse, ppos;
// 3858    const Word32 *ph_imp;   /* Pointer to phase dispersion filter */
// 3859 
// 3860 
// 3861    /* Update LTP gain memory */
// 3862    state->gainMem[4] = state->gainMem[3];
        LDR      R2,[R0, #+12]
        MOV      R4,R1
        LDR      R1,[SP, #+356]
        STR      R2,[R0, #+16]
// 3863    state->gainMem[3] = state->gainMem[2];
        LDR      R2,[R0, #+8]
        MOV      R6,R3
        STR      R2,[R0, #+12]
// 3864    state->gainMem[2] = state->gainMem[1];
        LDR      R2,[R0, #+4]
// 3865    state->gainMem[1] = state->gainMem[0];
// 3866    state->gainMem[0] = ltpGain;
// 3867 
// 3868    /* basic adaption of phase dispersion */
// 3869    /* no dispersion */
// 3870    impNr = 2;
        MOV      R10,#+2
        STR      R2,[R0, #+8]
        LDR      R2,[R0, #+0]
        STR      R2,[R0, #+4]
        STR      R1,[R0, #+0]
// 3871 
// 3872    /* if (ltpGain < 0.9) */
// 3873    if ( ltpGain < PHDTHR2LTP ) {
        MOV      R2,#+154
        ORR      R2,R2,#0x3900
        CMP      R1,R2
        BGE      ??ph_disp_0
// 3874       /* maximum dispersion */
// 3875       impNr = 0;
        MOV      R10,#+0
// 3876 
// 3877       /* if (ltpGain > 0.6 */
// 3878       if ( ltpGain > PHDTHR1LTP ) {
        MOV      R2,#+103
        ORR      R2,R2,#0x2600
        CMP      R1,R2
// 3879          /* medium dispersion */
// 3880          impNr = 1;
        MOVGE    R10,#+1
// 3881       }
// 3882    }
// 3883 
// 3884    /* onset indicator */
// 3885    /* onset = (cbGain  > onFact * cbGainMem[0]) */
// 3886    temp1 = ( ( state->prevCbGain * ONFACTPLUS1 ) + 0x1000 ) >> 13;
// 3887 
// 3888    if ( cbGain > temp1 ) {
??ph_disp_0:
        LDR      R1,[R0, #+20]
        MOV      R2,#+4096
        ADD      R1,R2,R1, LSL #+14
        CMP      R6,R1, ASR #+13
// 3889       state->onset = ONLENGTH;
        MOVGT    R1,#+2
        BGT      ??ph_disp_1
// 3890    }
// 3891    else {
// 3892       if ( state->onset > 0 ) {
        LDRSH    R1,[R0, #+30]
        CMP      R1,#+1
        BLT      ??ph_disp_2
// 3893          state->onset--;
        SUB      R1,R1,#+1
??ph_disp_1:
        STRH     R1,[R0, #+30]
// 3894       }
// 3895    }
// 3896 
// 3897    /*
// 3898     * if not onset, check ltpGain buffer and use max phase dispersion if
// 3899     * half or more of the ltpGain-parameters say so
// 3900     */
// 3901    if ( state->onset == 0 ) {
??ph_disp_2:
        LDRSH    R1,[R0, #+30]
        CMP      R1,#+0
        BNE      ??ph_disp_3
// 3902       /* Check LTP gain memory and set filter accordingly */
// 3903       i1 = 0;
        MOV      R2,#+0
// 3904 
// 3905       for ( i = 0; i < PHDGAINMEMSIZE; i++ ) {
        MOV      R11,#+102
        ORR      R11,R11,#0x2600
// 3906          if ( state->gainMem[i] < PHDTHR1LTP ) {
??ph_disp_4:
        LDR      R3,[R0, +R1, LSL #+2]
// 3907             i1++;
// 3908          }
// 3909       }
        ADD      R1,R1,#+1
        CMP      R3,R11
        ADDLT    R2,R2,#+1
        CMP      R1,#+5
        BLT      ??ph_disp_4
// 3910 
// 3911       if ( i1 > 2 ) {
        CMP      R2,#+3
// 3912          impNr = 0;
        MOVGE    R10,#+0
// 3913       }
// 3914    }
// 3915 
// 3916    /* Restrict decrease in phase dispersion to one step if not onset */
// 3917    if ( ( impNr > ( state->prevState + 1 ) ) & ( state->onset == 0 ) ) {
??ph_disp_3:
        LDR      R1,[R0, #+24]
        ADD      R1,R1,#+1
        CMP      R1,R10
        BGE      ??ph_disp_5
        LDRSH    R1,[R0, #+30]
        CMP      R1,#+0
// 3918       impNr--;
        SUBEQ    R10,R10,#+1
// 3919    }
// 3920 
// 3921    /* if onset, use one step less phase dispersion */
// 3922    if ( ( impNr<2 )&( state->onset>0 ) ) {
??ph_disp_5:
        CMP      R10,#+2
        BGE      ??ph_disp_6
        LDRSH    R1,[R0, #+30]
        CMP      R1,#+1
// 3923       impNr++;
        ADDGE    R10,R10,#+1
// 3924    }
// 3925 
// 3926    /* disable for very low levels */
// 3927    if ( cbGain < 10 ) {
// 3928       impNr = 2;
// 3929    }
// 3930 
// 3931    if ( state->lockFull == 1 ) {
??ph_disp_6:
        LDRSH    R1,[R0, #+28]
        CMP      R6,#+10
        MOVLT    R10,#+2
        CMP      R1,#+1
// 3932       impNr = 0;
        MOVEQ    R10,#+0
// 3933    }
// 3934 
// 3935    /* update static memory */
// 3936    state->prevState = impNr;
        STR      R10,[R0, #+24]
// 3937    state->prevCbGain = cbGain;
        STR      R6,[R0, #+20]
// 3938 
// 3939    /*
// 3940     * do phase dispersion for all modes but 12.2 and 7.4;
// 3941     * don't modify the innovation if impNr >=2 (= no phase disp)
// 3942     */
// 3943    if ( ( mode != MR122 ) & ( mode != MR102 ) & ( mode != MR74 ) & ( impNr < 2 )
// 3944       ) {
        CMP      R4,#+7
        CMPNE    R4,#+6
        CMPNE    R4,#+4
        BEQ      ??ph_disp_7
        CMP      R10,#+2
        BGE      ??ph_disp_7
// 3945       /*
// 3946        * track pulse positions, save innovation,
// 3947        * and initialize new innovation
// 3948        */
// 3949       nze = 0;
        MOV      R11,#+0
// 3950 
// 3951       for ( i = 0; i < L_SUBFR; i++ ) {
        MOV      R1,#+0
// 3952          if ( inno[i] != 0 ) {
??ph_disp_8:
        LDR      R0,[R7, +R1, LSL #+2]
        CMP      R0,#+0
// 3953             ps_poss[nze] = i;
        MOVNE    R0,SP
        STRNE    R1,[R0, +R11, LSL #+2]
// 3954             nze++;
        ADDNE    R11,R11,#+1
// 3955          }
// 3956       }
        ADD      R1,R1,#+1
        CMP      R1,#+40
        BLT      ??ph_disp_8
// 3957       memcpy( inno_sav, inno, L_SUBFR <<2 );
        MOV      R2,#+160
        MOV      R1,R7
        ADD      R0,SP,#+160
        SWI      +286
// 3958       memset( inno, 0, L_SUBFR <<2 );
        MOV      R2,#+160
        MOV      R1,#+0
        MOV      R0,R7
        SWI      +187
// 3959 
// 3960       /* Choose filter corresponding to codec mode and dispersion criterium */
// 3961       ph_imp = ph_imp_mid;
        LDR      R0,??ph_disp_9   ;; ph_imp_low_MR795
// 3962 
// 3963       if ( impNr == 0 ) {
        CMP      R10,#+0
        ADD      R2,R0,#+480
// 3964          ph_imp = ph_imp_low;
        ADDEQ    R2,R0,#+320
// 3965       }
// 3966 
// 3967       if ( mode == MR795 ) {
        CMP      R4,#+5
// 3968          ph_imp = ph_imp_mid_MR795;
        ADDEQ    R2,R0,#+160
// 3969 
// 3970          if ( impNr == 0 ) {
        CMPEQ    R10,#+0
// 3971             ph_imp = ph_imp_low_MR795;
        MOVEQ    R2,R0
// 3972          }
// 3973       }
// 3974 
// 3975       /* Do phase dispersion of innovation */
// 3976       for ( nPulse = 0; nPulse < nze; nPulse++ ) {
        MOV      R3,#+0
        CMP      R11,#+1
        BGE      ??ph_disp_10
// 3977          ppos = ps_poss[nPulse];
// 3978 
// 3979          /* circular convolution with impulse response */
// 3980          j = 0;
// 3981 
// 3982          for ( i = ppos; i < L_SUBFR; i++ ) {
// 3983             /* inno[i1] += inno_sav[ppos] * ph_imp[i1-ppos] */
// 3984             temp1 = ( inno_sav[ppos] * ph_imp[j++] ) >> 15;
// 3985             inno[i] = inno[i] + temp1;
// 3986          }
// 3987 
// 3988          for ( i = 0; i < ppos; i++ ) {
// 3989             /* inno[i] += inno_sav[ppos] * ph_imp[L_SUBFR-ppos+i] */
// 3990             temp1 = ( inno_sav[ppos] * ph_imp[j++] ) >> 15;
// 3991             inno[i] = inno[i] + temp1;
// 3992          }
// 3993       }
// 3994    }
// 3995 
// 3996    /*
// 3997     * compute total excitation for synthesis part of decoder
// 3998     * (using modified innovation if phase dispersion is active)
// 3999     */
// 4000    for ( i = 0; i < L_SUBFR; i++ ) {
??ph_disp_7:
        MOV      R1,#+0
// 4001       /* x[i] = gain_pit*x[i] + cbGain*code[i]; */
// 4002       temp1 = x[i] * pitch_fac + inno[i] * cbGain;
??ph_disp_11:
        LDR      R3,[R7, +R1, LSL #+2]
        ADD      R2,R5,R1, LSL #+2
        LDR      R0,[R2, #+0]
        MUL      R3,R6,R3
        MLA      R0,R8,R0,R3
// 4003       temp2 = temp1 << tmp_shift;
        LSL      R3,R0,R9
// 4004       x[i] = ( temp2 + 0x4000 ) >> 15;
        ADD      R4,R3,#+16384
        ASR      R4,R4,#+15
        STR      R4,[R2, #+0]
// 4005       if (labs(x[i]) > 32767)
        CMP      R4,#+0
        BPL      ??ph_disp_12
        RSB      R4,R4,#+0
        B        ??ph_disp_12
??ph_disp_13:
        LDR      R12,[R2, +R10, LSL #+2]
        ADD      R0,SP,#+160
        LDR      R0,[R0, +R4, LSL #+2]
        ADD      R10,R10,#+1
        MUL      R0,R12,R0
        ADD      R12,R7,R1, LSL #+2
        LDR      LR,[R12, #+0]
        ASR      R0,R0,#+15
        ADD      R0,R0,LR
        STR      R0,[R12, #+0]
        ADD      R1,R1,#+1
??ph_disp_14:
        CMP      R1,R4
        BLT      ??ph_disp_13
??ph_disp_15:
        ADD      R3,R3,#+1
??ph_disp_10:
        CMP      R3,R11
        BGE      ??ph_disp_7
        MOV      R0,SP
        LDR      R4,[R0, +R3, LSL #+2]
        MOV      R10,#+0
        MOV      R1,R4
        CMP      R1,#+40
        BGE      ??ph_disp_16
??ph_disp_17:
        LDR      R12,[R2, +R10, LSL #+2]
        ADD      R0,SP,#+160
        LDR      R0,[R0, +R4, LSL #+2]
        ADD      R10,R10,#+1
        MUL      R0,R12,R0
        ADD      R12,R7,R1, LSL #+2
        LDR      LR,[R12, #+0]
        ASR      R0,R0,#+15
        ADD      R0,R0,LR
        STR      R0,[R12, #+0]
        ADD      R1,R1,#+1
        CMP      R1,#+40
        BLT      ??ph_disp_17
??ph_disp_16:
        MOV      R1,#+0
        CMP      R4,#+1
        BGE      ??ph_disp_14
        B        ??ph_disp_15
??ph_disp_12:
        CMP      R4,#+32768
        BLT      ??ph_disp_18
// 4006       {
// 4007          if ((temp1 ^ temp2) & 0x80000000) {
        MOV      R4,#+255
        ORR      R4,R4,#0x7F00
        EOR      R10,R3,R0
        TST      R10,#0x80000000
        BEQ      ??ph_disp_19
// 4008             x[i] = (temp1 & 0x80000000) ? -32768: 32767;
        TST      R0,#0x80000000
        B        ??ph_disp_20
// 4009          }
// 4010          else {
// 4011             x[i] = (temp2 & 0x80000000) ? -32768: 32767;
??ph_disp_19:
        TST      R3,#0x80000000
??ph_disp_20:
        MVNNE    R4,R4
        STR      R4,[R2, #+0]
// 4012          }
// 4013       }
// 4014    }
??ph_disp_18:
        ADD      R1,R1,#+1
        CMP      R1,#+40
        BLT      ??ph_disp_11
// 4015    return;
        ADD      SP,SP,#+320      ;; stack cleaning
        CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        DATA
??ph_disp_9:
        DC32     ph_imp_low_MR795
        CFI EndBlock cfiBlock63
// 4016 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock64 Using cfiCommon0
        CFI NoFunction
        THUMB
??Ex_ctrl??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock64
        REQUIRE Ex_ctrl
// 4017 
// 4018 
// 4019 /*
// 4020  * sqrt_l_exp
// 4021  *
// 4022  *
// 4023  * Parameters:
// 4024  *    x                 I: input value
// 4025  *    exp               O: right shift to be applied to result
// 4026  *
// 4027  * Function:
// 4028  *    Sqrt with exponent value.
// 4029  *
// 4030  *    y = sqrt(x)
// 4031  *    x = f * 2^-e,   0.5 <= f < 1   (normalization)
// 4032  *    y = sqrt(f) * 2^(-e/2)
// 4033  *
// 4034  *    a) e = 2k   --> y = sqrt(f)   * 2^-k
// 4035  *       (k = e div 2, 0.707 <= sqrt(f) < 1)
// 4036  *    b) e = 2k+1 --> y = sqrt(f/2) * 2^-k
// 4037  *       (k = e div 2, 0.5 <= sqrt(f/2) < 0.707)
// 4038  *
// 4039  *
// 4040  * Returns:
// 4041  *    y                 output value
// 4042  */
// 4043 static Word32 sqrt_l_exp( Word32 x, Word32 *exp )
// 4044 {
// 4045    Word32 y, a, i, tmp;
// 4046    int e;
// 4047 
// 4048 
// 4049    if ( x <= ( Word32 )0 ) {
// 4050       *exp = 0;
// 4051       return( Word32 )0;
// 4052    }
// 4053    e=0;
// 4054    if (x != 0){
// 4055       tmp = x;
// 4056       while (!(tmp & 0x40000000))
// 4057       {
// 4058          e++;
// 4059          tmp = tmp << 1;
// 4060       }
// 4061    }
// 4062    e = e & 0xFFFE;
// 4063    x = ( x << e );
// 4064    *exp = ( Word16 )e;
// 4065    x = ( x >> 9 );
// 4066    i = ( Word16 )( x >> 16 );
// 4067    x = ( x >> 1 );
// 4068    a = x & ( Word16 )0x7fff;
// 4069    i = ( i - 16 );
// 4070    y = ( sqrt_table[i] << 16 );
// 4071    tmp = ( sqrt_table[i] - sqrt_table[i + 1] );
// 4072    y -= ( tmp * a ) << 1;
// 4073    return( y );
// 4074 }
// 4075 
// 4076 
// 4077 /*
// 4078  * Ex_ctrl
// 4079  *
// 4080  *
// 4081  * Parameters:
// 4082  *    excitation        B: Current subframe excitation
// 4083  *    excEnergy         I: Exc. Energy, sqrt(totEx*totEx)
// 4084  *    exEnergyHist      I: History of subframe energies
// 4085  *    voicedHangover    I: number of frames after last voiced frame
// 4086  *    prevBFI           I: Set i previous bad frame indicators
// 4087  *    carefulFlag       I: Restrict dymamic in scaling
// 4088  *
// 4089  * Function:
// 4090  *    Charaterice synthesis speech and detect background noise
// 4091  *
// 4092  * Returns:
// 4093  *    background noise decision; 0 = no bgn, 1 = bgn
// 4094  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock65 Using cfiCommon1
        CFI Function Ex_ctrl
        ARM
// 4095 static Word16 Ex_ctrl( Word32 excitation[], Word32 excEnergy, Word32
// 4096       exEnergyHist[], Word32 voicedHangover, Word16 prevBFI, Word16 carefulFlag
// 4097       )
// 4098 {
Ex_ctrl:
        PUSH     {R4-R9,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R9 Frame(CFA, -8)
        CFI R8 Frame(CFA, -12)
        CFI R7 Frame(CFA, -16)
        CFI R6 Frame(CFA, -20)
        CFI R5 Frame(CFA, -24)
        CFI R4 Frame(CFA, -28)
        CFI CFA R13+28
        LDRSH    R7,[SP, #+28]
        LDRSH    R8,[SP, #+32]
        MOV      R4,R0
        MOV      R5,R1
        MOV      R9,R2
        MOV      R6,R3
// 4099    Word32 i, testEnergy, scaleFactor, avgEnergy, prevEnergy, T0;
// 4100    int exp;
// 4101 
// 4102 
// 4103    /* get target level */
// 4104    avgEnergy = gmed_n( exEnergyHist, 9 );
        MOV      R1,#+9
        MOV      R0,R9
        BL       gmed_n
// 4105    prevEnergy = ( exEnergyHist[7] + exEnergyHist[8] ) >> 1;
        LDR      R1,[R9, #+32]
        MOV      R2,R0
        LDR      R0,[R9, #+28]
        ADD      R0,R1,R0
        ASR      R0,R0,#+1
// 4106 
// 4107    if ( exEnergyHist[8] < prevEnergy ) {
        CMP      R1,R0
// 4108       prevEnergy = exEnergyHist[8];
        MOVLT    R0,R1
// 4109    }
// 4110 
// 4111    /* upscaling to avoid too rapid energy rises  for some cases */
// 4112    if ( ( excEnergy<avgEnergy )&( excEnergy>5 ) ) {
        CMP      R5,R2
        BGE      ??Ex_ctrl_0
        CMP      R5,#+6
        BLT      ??Ex_ctrl_0
// 4113       /* testEnergy = 4*prevEnergy; */
// 4114       testEnergy = prevEnergy << 2;
        LSL      R1,R0,#+2
// 4115 
// 4116       if ( ( voicedHangover < 7 ) || prevBFI != 0 ) {
        CMP      R6,#+7
        BLT      ??Ex_ctrl_1
        CMP      R7,#+0
        BEQ      ??Ex_ctrl_2
// 4117          /* testEnergy = 3*prevEnergy */
// 4118          testEnergy = testEnergy - prevEnergy;
??Ex_ctrl_1:
        SUB      R1,R1,R0
// 4119       }
// 4120 
// 4121       if ( avgEnergy > testEnergy ) {
??Ex_ctrl_2:
        CMP      R1,R2
// 4122          avgEnergy = testEnergy;
        MOVLT    R2,R1
// 4123       }
// 4124 
// 4125       /* scaleFactor=avgEnergy/excEnergy in Q0 */
// 4126       exp=0;
        MOV      R3,#+0
// 4127       if (excEnergy != 0){
        B        ??Ex_ctrl_3
// 4128          while (!(excEnergy & 0x4000))
// 4129          {
// 4130             exp++;
??Ex_ctrl_4:
        ADD      R3,R3,#+1
// 4131             excEnergy = excEnergy << 1;
        LSL      R5,R5,#+1
// 4132          }
??Ex_ctrl_3:
        TST      R5,#0x4000
        BEQ      ??Ex_ctrl_4
// 4133       }
// 4134       excEnergy = 536838144 / excEnergy;
// 4135       T0 = ( avgEnergy * excEnergy ) << 1;
// 4136       T0 = ( T0 >> ( 20 - exp ) );
        MOV      R0,#+532676608
        ORR      R0,R0,#0x3F8000
        MOV      R1,R5
        _BLF     ??div32_a,??rA??div32_a
        MUL      R0,R1,R2
        RSB      R1,R3,#+20
        LSL      R0,R0,#+1
        ASR      R0,R0,R1
// 4137 
// 4138       if ( T0 > 32767 ) {
        CMP      R0,#+32768
// 4139          /* saturate  */
// 4140          T0 = 32767;
        MOVGE    R0,#+255
        ORRGE    R0,R0,#0x7F00
// 4141       }
// 4142       scaleFactor = T0;
// 4143 
// 4144       /* test if scaleFactor > 3.0 */
// 4145       if ( ( carefulFlag != 0 ) & ( scaleFactor > 3072 ) ) {
        CMP      R8,#+0
        BEQ      ??Ex_ctrl_5
        MOV      R1,#+1
        ORR      R1,R1,#0xC00
        CMP      R0,R1
// 4146          scaleFactor = 3072;
        MOVGE    R0,#+3072
// 4147       }
// 4148 
// 4149       /* scale the excitation by scaleFactor */
// 4150       for ( i = 0; i < L_SUBFR; i++ ) {
??Ex_ctrl_5:
        MOV      R1,#+0
// 4151          T0 = ( scaleFactor * excitation[i] ) << 1;
// 4152          T0 = ( T0 >> 11 );
// 4153          excitation[i] = T0;
??Ex_ctrl_6:
        LDR      R2,[R4, +R1, LSL #+2]
        MUL      R3,R2,R0
        LSL      R2,R3,#+1
        ASR      R2,R2,#+11
        STR      R2,[R4, +R1, LSL #+2]
// 4154       }
        ADD      R1,R1,#+1
        CMP      R1,#+40
        BLT      ??Ex_ctrl_6
// 4155    }
// 4156    return 0;
??Ex_ctrl_0:
        MOV      R0,#+0
        POP      {R4-R9,PC}       ;; return
        CFI EndBlock cfiBlock65
// 4157 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock66 Using cfiCommon0
        CFI NoFunction
        THUMB
??energy_old??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock66
        REQUIRE energy_old
// 4158 
// 4159 
// 4160 /*
// 4161  * Inv_sqrt
// 4162  *
// 4163  *
// 4164  * Parameters:
// 4165  *    x                 I: input value
// 4166  *
// 4167  * Function:
// 4168  *    1/sqrt(x)
// 4169  *
// 4170  * Returns:
// 4171  *    y                 1/sqrt(x)
// 4172  */
// 4173 static Word32 Inv_sqrt( Word32 x )
// 4174 {
// 4175    int i, a, tmp, exp;
// 4176    Word32 y;
// 4177 
// 4178 
// 4179    if ( x <= ( Word32 )0 )
// 4180       return( ( Word32 )0x3fffffffL );
// 4181    exp=0;
// 4182    while (!(x & 0x40000000))
// 4183    {
// 4184       exp++;
// 4185       x = x << 1;
// 4186    }
// 4187 
// 4188    /* x is normalized */
// 4189    exp = ( 30 - exp );
// 4190 
// 4191    /* If exponent even -> shift right */
// 4192    if ( ( exp & 1 ) == 0 ) {
// 4193       x = ( x >> 1 );
// 4194    }
// 4195    exp = ( exp >> 1 );
// 4196    exp = ( exp + 1 );
// 4197    x = ( x >> 9 );
// 4198 
// 4199    /* Extract b25-b31 */
// 4200    i = ( Word16 )( x >> 16 );
// 4201 
// 4202    /* Extract b10-b24 */
// 4203    x = ( x >> 1 );
// 4204    a = x & ( Word16 )0x7fff;
// 4205    i = ( i - 16 );
// 4206 
// 4207    /* table[i] << 16 */
// 4208    y = inv_sqrt_table[i] << 16;
// 4209 
// 4210    /* table[i] - table[i+1]) */
// 4211    tmp = ( inv_sqrt_table[i] - inv_sqrt_table[i + 1] );
// 4212 
// 4213    /* y -= tmp*a*2 */
// 4214    y -= ( tmp * a ) << 1;
// 4215 
// 4216    /* denormalization */
// 4217    y = ( y >> exp );
// 4218    return( y );
// 4219 }
// 4220 
// 4221 
// 4222 /*
// 4223  * energy_old
// 4224  *
// 4225  *
// 4226  * Parameters:
// 4227  *    in                I: input value
// 4228  *
// 4229  * Function:
// 4230  *    Energy of signal
// 4231  *
// 4232  * Returns:
// 4233  *    Energy
// 4234  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock67 Using cfiCommon1
        CFI Function energy_old
        ARM
// 4235 static Word32 energy_old( Word32 in[] )
// 4236 {
// 4237    Word32 temp, i, sum = 0;
energy_old:
        MOV      R2,#+0
// 4238 
// 4239 
// 4240    for ( i = 0; i < L_SUBFR; i += 8 ) {
        MOV      R1,#+0
// 4241       temp = in[i] >> 2;
??energy_old_0:
        LDR      R3,[R0, +R1, LSL #+2]
        ASR      R3,R3,#+2
// 4242       sum += temp * temp;
        MLA      R12,R3,R3,R2
// 4243       temp = in[i + 1] >> 2;
        ADD      R2,R0,R1, LSL #+2
        LDR      R3,[R2, #+4]
// 4244       sum += temp * temp;
// 4245       temp = in[i + 2] >> 2;
// 4246       sum += temp * temp;
// 4247       temp = in[i + 3] >> 2;
// 4248       sum += temp * temp;
// 4249       temp = in[i + 4] >> 2;
// 4250       sum += temp * temp;
// 4251       temp = in[i + 5] >> 2;
// 4252       sum += temp * temp;
// 4253       temp = in[i + 6] >> 2;
// 4254       sum += temp * temp;
// 4255       temp = in[i + 7] >> 2;
// 4256       sum += temp * temp;
// 4257    }
        ADD      R1,R1,#+8
        ASR      R3,R3,#+2
        MLA      R12,R3,R3,R12
        LDR      R3,[R2, #+8]
        CMP      R1,#+40
        ASR      R3,R3,#+2
        MLA      R12,R3,R3,R12
        LDR      R3,[R2, #+12]
        ASR      R3,R3,#+2
        MLA      R12,R3,R3,R12
        LDR      R3,[R2, #+16]
        ASR      R3,R3,#+2
        MLA      R12,R3,R3,R12
        LDR      R3,[R2, #+20]
        ASR      R3,R3,#+2
        MLA      R12,R3,R3,R12
        LDR      R3,[R2, #+24]
        LDR      R2,[R2, #+28]
        ASR      R3,R3,#+2
        MLA      R12,R3,R3,R12
        ASR      R3,R2,#+2
        MLA      R2,R3,R3,R12
        BLT      ??energy_old_0
// 4258 
// 4259    if ( sum & 0xC0000000 ) {
        TST      R2,#0xC0000000
// 4260       return 0x7FFFFFFF;
        MVNNE    R0,#-2147483648
        BXNE     LR
// 4261    }
// 4262    return( sum << 1 );
        LSL      R0,R2,#+1
        BX       LR               ;; return
        CFI EndBlock cfiBlock67
// 4263 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock68 Using cfiCommon0
        CFI NoFunction
        THUMB
??energy_new??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock68
        REQUIRE energy_new
// 4264 
// 4265 
// 4266 /*
// 4267  * energy_new
// 4268  *
// 4269  *
// 4270  * Parameters:
// 4271  *    in                I: input value
// 4272  *
// 4273  * Function:
// 4274  *    Energy of signal
// 4275  *
// 4276  * Returns:
// 4277  *    Energy
// 4278  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock69 Using cfiCommon1
        CFI Function energy_new
        ARM
// 4279 static Word32 energy_new( Word32 in[] )
// 4280 {
energy_new:
        PUSH     {R4-R6}
        CFI R6 Frame(CFA, -4)
        CFI R5 Frame(CFA, -8)
        CFI R4 Frame(CFA, -12)
        CFI CFA R13+12
// 4281    Word32 i, s = 0, overflow = 0;
// 4282 
// 4283    s += in[0] * in[0];
        LDR      R1,[R0, #+0]
        MOV      R2,R1
        MUL      R1,R2,R1
// 4284    for ( i = 1; i < L_SUBFR; i += 3 ) {
        MOV      R2,#+1
// 4285       s += in[i] * in[i];
// 4286       s += in[i + 1] *in[i + 1];
// 4287       s += in[i + 2] * in[i + 2];
??energy_new_0:
        LDR      R12,[R0, +R2, LSL #+2]
        ADD      R3,R0,R2, LSL #+2
        LDR      R5,[R3, #+4]
        LDR      R4,[R3, #+8]
        MOV      R6,R5
        MUL      R5,R6,R5
        MOV      R3,R4
        MLA      R5,R12,R12,R5
        MLA      R4,R3,R4,R5
        ADD      R1,R4,R1
// 4288 
// 4289 
// 4290       if ( s & 0xC0000000 ) {
        TST      R1,#0xC0000000
        BEQ      ??energy_new_1
// 4291          overflow = 1;
// 4292          break;
// 4293       }
// 4294    }
// 4295 
// 4296    /* check for overflow */
// 4297    if ( overflow ) {
// 4298       s = energy_old( in );
        POP      {R4-R6}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI CFA R13+0
        B        energy_old       ;; tailcall
        CFI R4 Frame(CFA, -12)
        CFI R5 Frame(CFA, -8)
        CFI R6 Frame(CFA, -4)
        CFI CFA R13+12
// 4299    }
??energy_new_1:
        ADD      R2,R2,#+3
        CMP      R2,#+40
        BLT      ??energy_new_0
// 4300    else {
// 4301       s = ( s >> 3 );
        ASR      R0,R1,#+3
// 4302    }
// 4303    return s;
        POP      {R4-R6}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI CFA R13+0
        BX       LR
        CFI EndBlock cfiBlock69
// 4304 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock70 Using cfiCommon0
        CFI NoFunction
        THUMB
??agc2??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock70
        REQUIRE agc2
// 4305 
// 4306 
// 4307 /*
// 4308  * agc2
// 4309  *
// 4310  *
// 4311  * Parameters:
// 4312  *    sig_in            I: Post_Filter input signal
// 4313  *    sig_out           B: Post_Filter output signal
// 4314  *
// 4315  * Function:
// 4316  *    Scales the excitation on a subframe basis
// 4317  *
// 4318  * Returns:
// 4319  *    Energy
// 4320  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock71 Using cfiCommon1
        CFI Function agc2
        ARM
// 4321 static void agc2( Word32 *sig_in, Word32 *sig_out )
// 4322 {
agc2:
        PUSH     {R4-R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
        MOV      R4,R1
        MOV      R6,R0
// 4323    Word32 s;
// 4324    int i, exp;
// 4325    Word16 gain_in, gain_out, g0;
// 4326 
// 4327 
// 4328    /* calculate gain_out with exponent */
// 4329    s = energy_new( sig_out );
        MOV      R0,R4
        BL       energy_new
// 4330 
// 4331    if ( s == 0 ) {
        CMP      R0,#+0
        POPEQ    {R4-R7,PC}
// 4332       return;
// 4333    }
// 4334    exp=0;
        MOV      R5,#+0
        TST      R0,#0x20000000
        BNE      ??agc2_0
// 4335    while (!(s & 0x20000000))
// 4336    {
// 4337       exp++;
??agc2_1:
        ADD      R5,R5,#+1
// 4338       s = s << 1;
        LSL      R0,R0,#+1
// 4339    }
        TST      R0,#0x20000000
        BEQ      ??agc2_1
// 4340 
// 4341    gain_out = ( Word16 )( ( s + 0x00008000L ) >> 16 );
??agc2_0:
        ADD      R0,R0,#+32768
        ASR      R7,R0,#+16
// 4342 
// 4343    /* calculate gain_in with exponent */
// 4344    s = energy_new( sig_in );
        MOV      R0,R6
        BL       energy_new
// 4345 
// 4346    if ( s == 0 ) {
        CMP      R0,#+0
        BEQ      ??agc2_2
// 4347       g0 = 0;
// 4348    }
// 4349    else {
// 4350       i = 0;
        MOV      R3,#+0
        TST      R0,#0x40000000
        BNE      ??agc2_3
// 4351       while (!(s & 0x40000000))
// 4352       {
// 4353          i++;
??agc2_4:
        ADD      R3,R3,#+1
// 4354          s = s << 1;
        LSL      R0,R0,#+1
// 4355       }
        TST      R0,#0x40000000
        BEQ      ??agc2_4
// 4356 
// 4357       if ( s < 0x7fff7fff )
??agc2_3:
        MOV      R2,#+255
        ORR      R2,R2,#0x7F00
        MVN      R1,#-2147483648
        BIC      R1,R1,#0x8000
        CMP      R0,R1
// 4358          gain_in = ( Word16 )( ( s + 0x00008000L ) >> 16 );
        ADDLT    R0,R0,#+32768
        ASRLT    R1,R0,#+16
// 4359       else
// 4360          gain_in = 32767;
        MOVGE    R1,R2
// 4361       exp = ( exp - i );
        SUB      R5,R5,R3
// 4362 
// 4363         /*
// 4364          * g0 = sqrt(gain_in/gain_out);
// 4365          */
// 4366       /* s = gain_out / gain_in */
// 4367       s = ( gain_out << 15 ) / gain_in;
// 4368       s = ( s << 7 );
        LSL      R0,R7,#+15
        _BLF     ??div32_a,??rA??div32_a
        LSL      R0,R1,#+7
// 4369 
// 4370       if ( exp > 0 )
        CMP      R5,#+1
// 4371          s = ( s >> exp );
        ASRGE    R1,R0,R5
// 4372       else
// 4373          s = ( s << ( -exp ) );
        RSBLT    R1,R5,#+0
        LSLLT    R1,R0,R1
// 4374       s = Inv_sqrt( s );
        CMP      R1,#+1
        MVNLT    R0,#-1073741824
        BLT      ??agc2_5
        MOV      R0,#+0
        TST      R1,#0x40000000
        BNE      ??agc2_6
??agc2_7:
        ADD      R0,R0,#+1
        LSL      R1,R1,#+1
        TST      R1,#0x40000000
        BEQ      ??agc2_7
??agc2_6:
        LDR      R5,??DataTable4  ;; inv_sqrt_table
        RSB      R0,R0,#+30
        TST      R0,#0x1
        ASREQ    R1,R1,#+1
        ASR      R1,R1,#+9
        ASR      R3,R1,#+16
        SUB      R3,R3,#+16
        LDR      R6,[R5, +R3, LSL #+2]
        ADD      R3,R5,R3, LSL #+2
        LDR      R3,[R3, #+4]
        AND      R1,R2,R1, ASR #+1
        SUB      R3,R6,R3
        MUL      R2,R1,R3
        LSL      R7,R6,#+16
        SUB      R1,R7,R2, LSL #+1
        MOV      R2,#+1
        ADD      R0,R2,R0, ASR #+1
        ASR      R0,R1,R0
// 4375       g0 = ( Word16 )( ( ( s << 9 ) + 0x00008000L ) >> 16 );
??agc2_5:
        MOV      R1,#+32768
        ADD      R0,R1,R0, LSL #+9
        ASR      R0,R0,#+16
// 4376    }
// 4377 
// 4378    /* sig_out(n) = gain(n) * sig_out(n) */
// 4379    for ( i = 0; i < L_SUBFR; i++ ) {
??agc2_2:
        MOV      R1,#+0
// 4380       sig_out[i] = ( sig_out[i] * g0 ) >> 12;
??agc2_8:
        LDR      R2,[R4, +R1, LSL #+2]
        MUL      R2,R0,R2
        ASR      R2,R2,#+12
        STR      R2,[R4, +R1, LSL #+2]
// 4381    }
        ADD      R1,R1,#+1
        CMP      R1,#+40
        BLT      ??agc2_8
        POP      {R4-R7,PC}       ;; return
        CFI EndBlock cfiBlock71
// 4382    return;
// 4383 }

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable4:
        DC32     inv_sqrt_table

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock72 Using cfiCommon0
        CFI NoFunction
        THUMB
??Bgn_scd??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock72
        REQUIRE Bgn_scd
// 4384 
// 4385 
// 4386 /*
// 4387  * Bgn_scd
// 4388  *
// 4389  *
// 4390  * Parameters:
// 4391  *    st->frameEnergyHist  B: Frame Energy memory
// 4392  *    st->bgHangover       B: Background hangover counter
// 4393  *    ltpGainHist          I: LTP gain history
// 4394  *    speech               I: synthesis speech frame
// 4395  *    voicedHangover       O: number of frames after last voiced frame
// 4396  *
// 4397  * Function:
// 4398  *    Charaterice synthesis speech and detect background noise
// 4399  *
// 4400  * Returns:
// 4401  *    inbgNoise         background noise decision; 0 = no bgn, 1 = bgn
// 4402  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock73 Using cfiCommon1
        CFI Function Bgn_scd
        ARM
// 4403 static Word16 Bgn_scd( Bgn_scdState *st, Word32 ltpGainHist[], Word32 speech[],
// 4404       Word32 *voicedHangover )
// 4405 {
Bgn_scd:
        PUSH     {R4-R10,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R10 Frame(CFA, -8)
        CFI R9 Frame(CFA, -12)
        CFI R8 Frame(CFA, -16)
        CFI R7 Frame(CFA, -20)
        CFI R6 Frame(CFA, -24)
        CFI R5 Frame(CFA, -28)
        CFI R4 Frame(CFA, -32)
        CFI CFA R13+32
        MOV      R5,R0
        MOV      R6,R1
        MOV      R7,R3
// 4406    Word32 temp, ltpLimit, frame_energyMin, currEnergy, noiseFloor, maxEnergy,
// 4407          maxEnergyLastPart, s, i;
// 4408    Word16 prevVoiced, inbgNoise;
// 4409 
// 4410 
// 4411    /*
// 4412     * Update the inBackgroundNoise flag (valid for use in next frame if BFI)
// 4413     * it now works as a energy detector floating on top
// 4414     * not as good as a VAD.
// 4415     */
// 4416    s = 0;
        MOV      R0,#+0
// 4417 
// 4418    for ( i = 0; i < L_FRAME; i++ ) {
        MOV      R1,#+0
// 4419       s += speech[i] * speech[i];
??Bgn_scd_0:
        ADD      R3,R2,R1, LSL #+2
        LDR      R4,[R3, #+0]
// 4420    }
        ADD      R1,R1,#+1
        MLA      R0,R4,R4,R0
        CMP      R1,#+160
        BLT      ??Bgn_scd_0
// 4421 
// 4422    if ( (s < 0xFFFFFFF) & (s >= 0) )
        MOV      R1,#+255
        ORR      R1,R1,#0x7F00
        MVN      R2,#-268435456
        CMP      R0,R2
        BGE      ??Bgn_scd_1
        CMP      R0,#+0
// 4423       currEnergy = s >> 13;
        ASRPL    R0,R0,#+13
        BPL      ??Bgn_scd_2
// 4424    else
// 4425       currEnergy = 32767;
??Bgn_scd_1:
        MOV      R0,R1
// 4426    frame_energyMin = 32767;
// 4427 
// 4428    for ( i = 0; i < L_ENERGYHIST; i++ ) {
??Bgn_scd_2:
        MOV      R2,#+0
// 4429       if ( st->frameEnergyHist[i] < frame_energyMin )
??Bgn_scd_3:
        ADD      R3,R5,R2, LSL #+2
        LDR      R4,[R3, #+0]
// 4430          frame_energyMin = st->frameEnergyHist[i];
// 4431    }
        ADD      R2,R2,#+1
        CMP      R4,R1
        MOVLT    R1,R4
        CMP      R2,#+60
        BLT      ??Bgn_scd_3
// 4432 
// 4433    /* Frame Energy Margin of 16 */
// 4434    noiseFloor = frame_energyMin << 4;
// 4435    maxEnergy = st->frameEnergyHist[0];
        LDR      R3,[R5, #+0]
        LSL      R1,R1,#+4
// 4436 
// 4437    for ( i = 1; i < L_ENERGYHIST - 4; i++ ) {
        MOV      R2,#+1
// 4438       if ( maxEnergy < st->frameEnergyHist[i] ) {
??Bgn_scd_4:
        ADD      R4,R5,R2, LSL #+2
        LDR      R8,[R4, #+0]
// 4439          maxEnergy = st->frameEnergyHist[i];
// 4440       }
// 4441    }
        ADD      R2,R2,#+1
        CMP      R3,R8
        MOVLT    R3,R8
        CMP      R2,#+56
        BLT      ??Bgn_scd_4
// 4442    maxEnergyLastPart = st->frameEnergyHist[2 * L_ENERGYHIST / 3];
        LDR      R2,[R5, #+160]
// 4443 
// 4444    for ( i = 2 * L_ENERGYHIST / 3 + 1; i < L_ENERGYHIST; i++ ) {
        MOV      R4,#+41
// 4445       if ( maxEnergyLastPart < st->frameEnergyHist[i] ) {
??Bgn_scd_5:
        ADD      R8,R5,R4, LSL #+2
        LDR      R9,[R8, #+0]
// 4446          maxEnergyLastPart = st->frameEnergyHist[i];
// 4447       }
// 4448    }
        ADD      R4,R4,#+1
        CMP      R2,R9
        MOVLT    R2,R9
        CMP      R4,#+60
        BLT      ??Bgn_scd_5
// 4449 
// 4450    /* false */
// 4451    inbgNoise = 0;
        MOV      R4,#+0
        MOV      R8,#+0
// 4452 
// 4453    /*
// 4454     * Do not consider silence as noise
// 4455     * Do not consider continuous high volume as noise
// 4456     * Or if the current noise level is very low
// 4457     * Mark as noise if under current noise limit
// 4458     * OR if the maximum energy is below the upper limit
// 4459     */
// 4460    if ( ( maxEnergy> LOWERNOISELIMIT )&( currEnergy<FRAMEENERGYLIMIT )&(
// 4461          currEnergy>LOWERNOISELIMIT ) & ( ( currEnergy < noiseFloor ) || (
// 4462          maxEnergyLastPart < UPPERNOISELIMIT ) ) ) {
        CMP      R3,#+21
        MOVGE    R3,#+1
        MOVLT    R3,#+0
        MOV      R10,#+170
        ORR      R10,R10,#0x4400
        CMP      R0,R10
        BGE      ??Bgn_scd_6
        MOV      R12,#+1
        CMP      R0,#+21
        BGE      ??Bgn_scd_7
        MOV      LR,#+0
??Bgn_scd_8:
        CMP      R0,R1
        BLT      ??Bgn_scd_9
        MOV      R1,#+161
        ORR      R1,R1,#0x700
        CMP      R2,R1
        BGE      ??Bgn_scd_10
??Bgn_scd_9:
        MOV      R1,#+1
        B        ??Bgn_scd_11
??Bgn_scd_6:
        MOV      R12,#+0
??Bgn_scd_7:
        MOV      LR,#+1
        B        ??Bgn_scd_8
??Bgn_scd_10:
        MOV      R1,#+0
??Bgn_scd_11:
        AND      R2,R12,R3
        AND      R2,LR,R2
        TST      R1,R2
        BEQ      ??Bgn_scd_12
// 4463       if ( ( st->bgHangover + 1 ) > 30 ) {
        LDRSH    R1,[R5, #+240]
        ADD      R1,R1,#+1
        CMP      R1,#+31
        LDRSHLT  R1,[R5, #+240]
        ADDLT    R1,R1,#+1
// 4464          st->bgHangover = 30;
        MOVGE    R1,#+30
        STRH     R1,[R5, #+240]
        B        ??Bgn_scd_13
// 4465       }
// 4466       else {
// 4467          st->bgHangover += 1;
// 4468       }
// 4469    }
// 4470    else {
// 4471       st->bgHangover = 0;
??Bgn_scd_12:
        STRH     R4,[R5, #+240]
// 4472    }
// 4473 
// 4474    /* make final decision about frame state, act somewhat cautiosly */
// 4475    if ( st->bgHangover > 1 )
??Bgn_scd_13:
        LDRSH    R1,[R5, #+240]
        CMP      R1,#+2
// 4476       inbgNoise = 1;   /* true  */
        MOVGE    R8,#+1
// 4477 
// 4478    for ( i = 0; i < L_ENERGYHIST - 1; i++ ) {
        MOV      R1,#+0
// 4479       st->frameEnergyHist[i] = st->frameEnergyHist[i + 1];
??Bgn_scd_14:
        ADD      R2,R5,R1, LSL #+2
        LDR      R2,[R2, #+4]
        STR      R2,[R5, +R1, LSL #+2]
// 4480    }
        ADD      R1,R1,#+1
        CMP      R1,#+59
        BLT      ??Bgn_scd_14
// 4481    st->frameEnergyHist[L_ENERGYHIST - 1] = currEnergy;
        STR      R0,[R5, #+236]
// 4482 
// 4483    /*
// 4484     * prepare for voicing decision;
// 4485     * tighten the threshold after some time in noise
// 4486     */
// 4487    ltpLimit = 13926;   /* 0.85  Q14 */
// 4488 
// 4489    if ( st->bgHangover > 8 ) {
        LDRSH    R0,[R5, #+240]
        MOV      R10,#+102
        ORR      R10,R10,#0x3600
        CMP      R0,#+9
// 4490       ltpLimit = 15565;   /* 0.95  Q14 */
        MOVGE    R10,#+205
        ORRGE    R10,R10,#0x3C00
// 4491    }
// 4492 
// 4493    if ( st->bgHangover > 15 ) {
        CMP      R0,#+16
// 4494       ltpLimit = 16383;   /* 1.00  Q14 */
        MOVGE    R10,#+255
        ORRGE    R10,R10,#0x3F00
// 4495    }
// 4496 
// 4497    /* weak sort of voicing indication. */
// 4498    prevVoiced = 0;   /* false */
// 4499 
// 4500    if ( gmed_n( &ltpGainHist[4], 5 ) > ltpLimit ) {
        MOV      R1,#+5
        ADD      R0,R6,#+16
        BL       gmed_n
        CMP      R10,R0
// 4501       prevVoiced = 1;   /* true  */
// 4502    }
// 4503 
// 4504    if ( st->bgHangover > 20 ) {
        LDRSH    R0,[R5, #+240]
        MOVLT    R4,#+1
        CMP      R0,#+21
        BLT      ??Bgn_scd_15
// 4505       if ( gmed_n( ltpGainHist, 9 ) > ltpLimit ) {
        MOV      R1,#+9
        MOV      R0,R6
        BL       gmed_n
        CMP      R10,R0
        BLT      ??Bgn_scd_16
// 4506          prevVoiced = 1;   /* true  */
// 4507       }
// 4508       else {
// 4509          prevVoiced = 0;   /* false  */
// 4510       }
// 4511    }
// 4512 
// 4513    if ( prevVoiced ) {
// 4514       *voicedHangover = 0;
// 4515    }
// 4516    else {
// 4517       temp = *voicedHangover + 1;
??Bgn_scd_17:
        LDR      R0,[R7, #+0]
        ADD      R0,R0,#+1
// 4518 
// 4519       if ( temp > 10 ) {
        CMP      R0,#+11
        BLT      ??Bgn_scd_18
// 4520          *voicedHangover = 10;
        MOV      R0,#+10
        STR      R0,[R7, #+0]
        MOV      R0,R8
        POP      {R4-R10,PC}
// 4521       }
??Bgn_scd_15:
        CMP      R4,#+0
        BEQ      ??Bgn_scd_17
??Bgn_scd_16:
        MOV      R0,#+0
// 4522       else {
// 4523          *voicedHangover = temp;
??Bgn_scd_18:
        STR      R0,[R7, #+0]
// 4524       }
// 4525    }
// 4526    return inbgNoise;
        MOV      R0,R8
        POP      {R4-R10,PC}      ;; return
        CFI EndBlock cfiBlock73
// 4527 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock74 Using cfiCommon0
        CFI NoFunction
        THUMB
??dtx_dec_activity_update??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock74
        REQUIRE dtx_dec_activity_update
// 4528 
// 4529 
// 4530 /*
// 4531  * dtx_dec_activity_update
// 4532  *
// 4533  *
// 4534  * Parameters:
// 4535  *    st->lsf_hist_ptr  B: LSF history pointer
// 4536  *    st->lsf_hist      B: LSF history
// 4537  *    lsf               I: lsf
// 4538  *    frame             I: noise frame
// 4539  *
// 4540  * Function:
// 4541  *    Update lsp history and compute log energy.
// 4542  *
// 4543  * Returns:
// 4544  *    void
// 4545  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock75 Using cfiCommon1
        CFI Function dtx_dec_activity_update
        ARM
// 4546 static void dtx_dec_activity_update( dtx_decState *st, Word32 lsf[], Word32
// 4547       frame[] )
// 4548 {
dtx_dec_activity_update:
        PUSH     {R4-R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
        SUB      SP,SP,#+8
        CFI CFA R13+28
        MOV      R4,R0
        MOV      R0,#+6
        ORR      R0,R0,#0x300
        ADD      R6,R0,R4
        LDRSH    R0,[R6, #+0]
// 4549    Word32 frame_en;
// 4550    Word32 log_en_e, log_en_m, log_en, i;
// 4551 
// 4552 
// 4553    /* update lsp history */
// 4554    st->lsf_hist_ptr += M;
// 4555 
// 4556    if ( st->lsf_hist_ptr == 80 ) {
        MOV      R7,#+0
        MOV      R5,R2
        ADD      R0,R0,#+10
        STRH     R0,[R6, #+0]
        LDRSH    R0,[R6, #+0]
// 4557       st->lsf_hist_ptr = 0;
// 4558    }
// 4559    memcpy( &st->lsf_hist[st->lsf_hist_ptr], lsf, M <<2 );
        MOV      R2,#+40
        CMP      R0,#+80
        STRHEQ   R7,[R6, #+0]
        LDRSH    R0,[R6, #+0]
        ADD      R0,R4,R0, LSL #+2
        ADD      R0,R0,#+96
        SWI      +286
// 4560 
// 4561    /* compute log energy based on frame energy */
// 4562    frame_en = 0;   /* Q0 */
        MOV      R0,#+0
// 4563 
// 4564    for ( i = 0; (i < L_FRAME); i ++ ) {
        MOV      R1,R0
// 4565       frame_en += frame[i] * frame[i];
??dtx_dec_activity_update_0:
        LDR      R2,[R5, +R1, LSL #+2]
        MLA      R0,R2,R2,R0
// 4566       if (frame_en & 0x80000000)
        TST      R0,#0x80000000
        BNE      ??dtx_dec_activity_update_1
// 4567          break;
// 4568    }
        ADD      R1,R1,#+1
        CMP      R1,#+160
        BLT      ??dtx_dec_activity_update_0
// 4569 
// 4570    log_en = (frame_en & 0xC0000000) ? 0x7FFFFFFE: (Word32)frame_en << 1;
??dtx_dec_activity_update_1:
        TST      R0,#0xC0000000
        MVNNE    R0,#-2147483647
        LSLEQ    R0,R0,#+1
// 4571 
// 4572    Log2( log_en , &log_en_e, &log_en_m );
        ADD      R2,SP,#+4
        MOV      R1,SP
        BL       Log2
// 4573 
// 4574    /* convert exponent and mantissa to Word16 Q10 */
// 4575    log_en = log_en_e << 10;   /* Q10 */
// 4576    log_en = log_en + ( log_en_m >> 5 );
// 4577 
// 4578    /* divide with L_FRAME i.e subtract with log2(L_FRAME) = 7.32193 */
// 4579    log_en = log_en - 8521;
// 4580 
// 4581    /*
// 4582     * insert into log energy buffer, no division by two as
// 4583     * log_en in decoder is Q11
// 4584     */
// 4585    st->log_en_hist_ptr += 1;
        LDRSH    R0,[R6, #+4]
        ADD      R0,R0,#+1
        STRH     R0,[R6, #+4]
// 4586 
// 4587    if ( st->log_en_hist_ptr == DTX_HIST_SIZE ) {
        LDRSH    R0,[R6, #+4]
        CMP      R0,#+8
// 4588       st->log_en_hist_ptr = 0;
        STRHEQ   R7,[R6, #+4]
// 4589    }
// 4590    st->log_en_hist[st->log_en_hist_ptr] = log_en;   /* Q11 */
        LDRSH    R0,[R6, #+4]
        LDR      R1,[SP, #+0]
        LDR      R2,[SP, #+4]
        ADD      R0,R4,R0, LSL #+2
        ASR      R2,R2,#+5
        ADD      R1,R2,R1, LSL #+10
        MVN      R2,#+72
        BIC      R2,R2,#0x2100
        ADD      R1,R2,R1
        STR      R1,[R0, #+736]
// 4591 }
        POP      {R0,R1,R4-R7,PC}  ;; return
        CFI EndBlock cfiBlock75

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock76 Using cfiCommon0
        CFI NoFunction
        THUMB
??Decoder_amr??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock76
        REQUIRE Decoder_amr
// 4592 
// 4593 
// 4594 /*
// 4595  * Decoder_amr
// 4596  *
// 4597  *
// 4598  * Parameters:
// 4599  *    st                B: State variables
// 4600  *    mode              I: AMR mode
// 4601  *    parm              I: vector of synthesis parameters
// 4602  *    frame_type        I: received frame type
// 4603  *    synth             O: synthesis speech
// 4604  *    A_t               O: decoded LP filter in 4 subframes
// 4605  *
// 4606  * Function:
// 4607  *    Speech decoder routine
// 4608  *
// 4609  * Returns:
// 4610  *    void
// 4611  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock77 Using cfiCommon1
        CFI Function Decoder_amr
        ARM
// 4612 static void Decoder_amr( Decoder_amrState *st, enum Mode mode, Word16 parm[],
// 4613       enum RXFrameType frame_type, Word32 synth[], Word32 A_t[] )
// 4614 {
Decoder_amr:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
        SUB      SP,SP,#+776
        CFI CFA R13+812
        MOV      R5,R0
        MOV      R6,R1
// 4615    /* LSPs */
// 4616    Word32 lsp_new[M];
// 4617    Word32 lsp_mid[M];
// 4618 
// 4619 
// 4620    /* LSFs */
// 4621    Word32 prev_lsf[M];
// 4622    Word32 lsf_i[M];
// 4623 
// 4624 
// 4625    /* Algebraic codevector */
// 4626    Word32 code[L_SUBFR];
// 4627 
// 4628 
// 4629    /* excitation */
// 4630    Word32 excp[L_SUBFR];
// 4631    Word32 exc_enhanced[L_SUBFR];
// 4632 
// 4633 
// 4634    /* Scalars */
// 4635    Word32 i, i_subfr, overflow, T0_frac, index, temp, temp2, subfrNr, excEnergy;
// 4636    Word32 gain_code, gain_code_mix, pit_sharp, pit_flag, pitch_fac, t0_min, t0_max;
// 4637    Word32 gain_pit = 0, evenSubfr = 0, T0 = 0, index_mr475 = 0;
        MOV      R1,#+0
        STR      R1,[SP, #+0]
        STR      R1,[SP, #+8]
        STR      R1,[SP, #+60]
// 4638    Word32 *Az;   /* Pointer on A_t */
// 4639    Word16 flag4, carefulFlag;
// 4640    Word16 delta_frc_low, delta_frc_range, tmp_shift;
// 4641    Word16 bfi = 0, pdfi = 0;
        STR      R1,[SP, #+36]
        LDR      R11,[SP, #+816]
// 4642    /* bad frame indication flag, potential degraded bad frame flag */
// 4643 
// 4644 
// 4645    enum DTXStateType newDTXState;   /* SPEECH , DTX, DTX_MUTE */
// 4646 
// 4647    /* find the new  DTX state  SPEECH OR DTX */
// 4648    newDTXState = rx_dtx_handler( st->dtxDecoderState, frame_type );
        ADD      R4,R5,#+776
        LDR      R0,[R4, #+216]
        MOV      R10,R2
        MOV      R9,R3
        MOV      R8,#+0
        MOV      R1,R9
        BL       rx_dtx_handler
        STR      R0,[SP, #+56]
        CMP      R0,#+0
        BEQ      ??Decoder_amr_0
// 4649 
// 4650    /* DTX actions */
// 4651    if ( newDTXState != SPEECH ) {
// 4652       Decoder_amr_reset( st, MRDTX );
        MOV      R1,#+8
        MOV      R0,R5
        BL       Decoder_amr_reset
// 4653       dtx_dec( st->dtxDecoderState, st->mem_syn, st->lsfState, st->pred_state,
// 4654             st->Cb_gain_averState, newDTXState, mode, parm, synth, A_t );
        PUSH     {R11}
        CFI CFA R13+816
        LDR      R0,[SP, #+816]
        ADD      R1,R5,#+820
        PUSH     {R0}
        CFI CFA R13+820
        PUSH     {R10}
        CFI CFA R13+824
        PUSH     {R6}
        CFI CFA R13+828
        LDR      R0,[SP, #+72]
        AND      R0,R0,#0xFF
        PUSH     {R0}
        CFI CFA R13+832
        LDR      R0,[R4, #+188]
        PUSH     {R0}
        CFI CFA R13+836
        LDR      R3,[R4, #+208]
        LDR      R2,[R4, #+196]
        LDR      R0,[R4, #+216]
        BL       dtx_dec
// 4655 
// 4656       /* update average lsp */
// 4657       Lsf_lsp( st->lsfState->past_lsf_q, st->lsp_old );
        LDR      R0,[R4, #+196]
        ADD      R1,R5,#+780
        ADD      R0,R0,#+40
        BL       Lsf_lsp
// 4658       lsp_avg( st->lsp_avg_st, st->lsfState->past_lsf_q );
        LDR      R0,[R4, #+196]
        LDR      R1,[R4, #+192]
        ADD      R0,R0,#+40
        MOV      R2,#+0
        ADD      SP,SP,#+24
        CFI CFA R13+812
??Decoder_amr_1:
        LDR      R7,[R0, +R2, LSL #+2]
        ADD      R3,R1,R2, LSL #+2
        LDR      R6,[R3, #+0]
        LDR      R5,[R3, #+0]
        SUB      R6,R6,R7
        MOV      R7,#+123
        ORR      R7,R7,#0x1400
        MUL      R6,R7,R6
        LSL      R5,R5,#+16
        SUB      R5,R5,R6, LSL #+1
        ADD      R5,R5,#+32768
        ASR      R5,R5,#+16
        STR      R5,[R3, #+0]
        ADD      R2,R2,#+1
        CMP      R2,#+10
        BGE      ??Decoder_amr_2
        B        ??Decoder_amr_1
// 4659       goto theEnd;
// 4660    }
??Decoder_amr_0:
        LDR      R1,??Decoder_amr_3  ;; sqrt_table
        MOV      R7,#+0
        ADD      R0,R9,R1
        LDRB     R0,[R0, #+336]
        CMP      R0,#+0
        BEQ      ??Decoder_amr_4
// 4661 
// 4662    /* SPEECH action state machine  */
// 4663    if ( table_speech_bad[frame_type] ) {
// 4664       bfi = 1;
        MOV      R8,#+1
// 4665 
// 4666       if ( frame_type != RX_SPEECH_BAD ) {
        CMP      R9,#+3
        BEQ      ??Decoder_amr_5
// 4667          Build_CN_param( &st->nodataSeed, mode, parm );
        MOV      R2,R10
        MOV      R1,R6
        MOV      R0,#+190
        ORR      R0,R0,#0x300
        ADD      R0,R0,R5
        BL       Build_CN_param
// 4668       }
// 4669    }
// 4670    else if ( frame_type == RX_SPEECH_DEGRADED ) {
// 4671       pdfi = 1;
// 4672    }
// 4673 
// 4674    if ( bfi != 0 ) {
// 4675       st->state += 1;
??Decoder_amr_5:
        LDRSH    R0,[R4, #+180]
        ADD      R0,R0,#+1
??Decoder_amr_6:
        STRH     R0,[R4, #+180]
        B        ??Decoder_amr_7
// 4676    }
??Decoder_amr_4:
        CMP      R9,#+1
        MOVEQ    R1,#+1
        STREQ    R1,[SP, #+36]
// 4677    else if ( st->state == 6 ) {
        LDRSH    R0,[R4, #+180]
        CMP      R0,#+6
// 4678       st->state = 5;
        MOVEQ    R0,#+5
        BEQ      ??Decoder_amr_6
// 4679    }
// 4680    else {
// 4681       st->state = 0;
        STRH     R7,[R4, #+180]
// 4682    }
// 4683 
// 4684    if ( st->state > 6 ) {
??Decoder_amr_7:
        LDRSH    R0,[R4, #+180]
// 4685       st->state = 6;
// 4686    }
// 4687 
// 4688     /*
// 4689      * If this frame is the first speech frame after CNI period,
// 4690      * set the BFH state machine to an appropriate state depending
// 4691      * on whether there was DTX muting before start of speech or not
// 4692      * If there was DTX muting, the first speech frame is muted.
// 4693      * If there was no DTX muting, the first speech frame is not
// 4694      * muted. The BFH state machine starts from state 5, however, to
// 4695      * keep the audible noise resulting from a SID frame which is
// 4696      * erroneously interpreted as a good speech frame as small as
// 4697      * possible (the decoder output in this case is quickly muted)
// 4698      */
// 4699    if ( st->dtxDecoderState->dtxGlobalState == DTX ) {
        MOV      R9,#+1
        CMP      R0,#+7
        MOVGE    R0,#+6
        STRHGE   R0,[R4, #+180]
        LDR      R0,[R4, #+216]
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE      ??Decoder_amr_8
// 4700       st->state = 5;
        MOV      R0,#+5
        STRH     R0,[R4, #+180]
// 4701       st->prev_bf = 0;
        STRH     R7,[R4, #+176]
        B        ??Decoder_amr_9
// 4702    }
// 4703    else if ( st->dtxDecoderState->dtxGlobalState == DTX_MUTE ) {
??Decoder_amr_8:
        LDR      R0,[R4, #+216]
        LDRB     R0,[R0, #+0]
        CMP      R0,#+2
// 4704       st->state = 5;
        MOVEQ    R0,#+5
        STRHEQ   R0,[R4, #+180]
// 4705       st->prev_bf = 1;
        STRHEQ   R9,[R4, #+176]
// 4706    }
// 4707 
// 4708    /* save old LSFs for CB gain smoothing */
// 4709    memcpy( prev_lsf, st->lsfState->past_lsf_q, M <<2 );
??Decoder_amr_9:
        LDR      R0,[R4, #+196]
        MOV      R2,#+40
        ADD      R1,R0,#+40
        ADD      R0,SP,#+664
        SWI      +286
// 4710 
// 4711     /*
// 4712      * decode LSF parameters and generate interpolated lpc coefficients
// 4713      * for the 4 subframes
// 4714      */
// 4715    if ( mode != MR122 ) {
        ADD      R0,SP,#+264
        PUSH     {R0}
        CFI CFA R13+816
        CMP      R6,#+7
        BEQ      ??Decoder_amr_10
// 4716       D_plsf_3( st->lsfState, mode, bfi, parm, lsp_new );
        LDR      R0,[R4, #+196]
        MOV      R3,R10
        MOV      R2,R8
        MOV      R1,R6
        BL       D_plsf_3
// 4717 
// 4718       /* Advance synthesis parameters pointer */
// 4719       parm += 3;
        ADD      R10,R10,#+6
// 4720       Int_lpc_1to3( st->lsp_old, lsp_new, A_t );
        MOV      R2,R11
        ADD      R1,SP,#+268
        ADD      R0,R5,#+780
        BL       Int_lpc_1to3
        ADD      SP,SP,#+4
        CFI CFA R13+812
        B        ??Decoder_amr_11
        CFI CFA R13+816
// 4721    }
// 4722    else {
// 4723       D_plsf_5( st->lsfState, bfi, parm, lsp_mid, lsp_new );
??Decoder_amr_10:
        LDR      R0,[R4, #+196]
        ADD      R3,SP,#+308
        MOV      R2,R10
        MOV      R1,R8
        BL       D_plsf_5
// 4724 
// 4725       /* Advance synthesis parameters pointer */
// 4726       parm += 5;
        ADD      R10,R10,#+10
// 4727       Int_lpc_1and3( st->lsp_old, lsp_mid, lsp_new, A_t );
        ADD      R0,R5,#+780
        MOV      R1,#+0
        ADD      SP,SP,#+4
        CFI CFA R13+812
        ADD      R2,SP,#+224
??Decoder_amr_12:
        LDR      R12,[R0, +R1, LSL #+2]
        ADD      R3,SP,#+304
        LDR      R3,[R3, +R1, LSL #+2]
        ASR      R12,R12,#+1
        ADD      R3,R12,R3, ASR #+1
        STR      R3,[R2, +R1, LSL #+2]
        ADD      R1,R1,#+1
        CMP      R1,#+10
        BLT      ??Decoder_amr_12
        MOV      R1,R11
        ADD      R0,SP,#+224
        BL       Lsp_Az
        ADD      R1,R11,#+44
        STR      R1,[SP, #+24]
        ADD      R0,SP,#+304
        BL       Lsp_Az
        LDR      R1,[SP, #+24]
        MOV      R0,#+0
        ADD      R1,R1,#+44
        STR      R1,[SP, #+4]
        ADD      R1,SP,#+224
??Decoder_amr_13:
        ADD      R2,SP,#+304
        LDR      R2,[R2, +R0, LSL #+2]
        ADD      R3,SP,#+264
        LDR      R3,[R3, +R0, LSL #+2]
        ASR      R3,R3,#+1
        ADD      R2,R3,R2, ASR #+1
        STR      R2,[R1, +R0, LSL #+2]
        ADD      R0,R0,#+1
        CMP      R0,#+10
        BLT      ??Decoder_amr_13
        LDR      R1,[SP, #+4]
        ADD      R0,SP,#+224
        BL       Lsp_Az
        LDR      R0,[SP, #+4]
        ADD      R1,R0,#+44
        ADD      R0,SP,#+264
        BL       Lsp_Az
// 4728    }
// 4729 
// 4730    /* update the LSPs for the next frame */
// 4731    memcpy( st->lsp_old, lsp_new, M <<2 );
??Decoder_amr_11:
        MOV      R2,#+40
        ADD      R1,SP,#+264
        ADD      R0,R5,#+780
        SWI      +286
// 4732 
// 4733    /*
// 4734     * Loop for every subframe in the analysis frame
// 4735     *
// 4736     * The subframe size is L_SUBFR and the loop is repeated
// 4737     * L_FRAME/L_SUBFR times                                                                 *
// 4738     *  - decode the pitch delay
// 4739     *  - decode algebraic code
// 4740     *  - decode pitch and codebook gains
// 4741     *  - find the excitation and compute synthesis speech
// 4742     */
// 4743    /* pointer to interpolated LPC parameters */
// 4744    Az = A_t;
        STR      R11,[SP, #+32]
// 4745    evenSubfr = 0;
        MOV      R1,#+0
        STR      R1,[SP, #+28]
// 4746    subfrNr = -1;
        MVN      R1,R1
        STR      R1,[SP, #+52]
// 4747 
// 4748    for ( i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR ) {
        MOV      R1,R7
        STR      R1,[SP, #+20]
// 4749       subfrNr += 1;
??Decoder_amr_14:
        LDR      R1,[SP, #+52]
        ADD      R1,R1,#+1
        STR      R1,[SP, #+52]
// 4750       evenSubfr = 1 - evenSubfr;
        LDR      R1,[SP, #+28]
        RSB      R1,R1,#+1
        STR      R1,[SP, #+28]
// 4751 
// 4752       /* flag for first and 3th subframe */
// 4753       pit_flag = i_subfr;
        LDR      R3,[SP, #+20]
// 4754 
// 4755       if ( i_subfr == L_FRAME_BY2 ) {
        CMP      R3,#+80
        BNE      ??Decoder_amr_15
// 4756          if ( ( mode != MR475 ) & ( mode != MR515 ) ) {
        CMP      R6,#+0
        CMPNE    R6,#+1
// 4757             pit_flag = 0;
        MOVNE    R3,#+0
// 4758          }
// 4759       }
// 4760 
// 4761       /* pitch index */
// 4762       index = *parm++;
??Decoder_amr_15:
        LDRSH    R12,[R10], #+2
        CMP      R6,#+7
        BEQ      ??Decoder_amr_16
// 4763 
// 4764        /*
// 4765         * decode pitch lag and find adaptive codebook vector.
// 4766         */
// 4767       if ( mode != MR122 ) {
// 4768           /*
// 4769            * flag4 indicates encoding with 4 bit resolution;
// 4770            * this is needed for mode MR475, MR515, MR59 and MR67
// 4771            */
// 4772          flag4 = 0;
// 4773 
// 4774          if ( ( mode == MR475 ) || ( mode == MR515 ) || ( mode == MR59 ) || (
// 4775                mode == MR67 ) ) {
// 4776             flag4 = 1;
// 4777          }
// 4778 
// 4779           /*
// 4780            * get ranges for the t0_min and t0_max
// 4781            * only needed in delta decoding
// 4782            */
// 4783          delta_frc_low = 5;
// 4784          delta_frc_range = 9;
// 4785 
// 4786          if ( mode == MR795 ) {
// 4787             delta_frc_low = 10;
// 4788             delta_frc_range = 19;
// 4789          }
// 4790          t0_min = st->old_T0 - delta_frc_low;
        LDR      R2,[R4, #+88]
        MOV      R0,#+0
        CMP      R6,#+0
        CMPNE    R6,#+1
        CMPNE    R6,#+2
        CMPNE    R6,#+3
        MOVEQ    R0,#+1
// 4791 
// 4792          if ( t0_min < PIT_MIN ) {
// 4793             t0_min = PIT_MIN;
// 4794          }
// 4795          t0_max = t0_min + delta_frc_range;
// 4796 
// 4797          if ( t0_max > PIT_MAX ) {
// 4798             t0_max = PIT_MAX;
// 4799             t0_min = t0_max - delta_frc_range;
// 4800          }
// 4801          Dec_lag3( index, t0_min, t0_max, pit_flag, st->old_T0, &T0, &T0_frac,
// 4802                flag4 );
        PUSH     {R0}
        CFI CFA R13+816
        MOV      R1,#+5
        MOV      R11,#+9
        CMP      R6,#+5
        ADD      R0,SP,#+20
        PUSH     {R0}
        CFI CFA R13+820
        MOVEQ    R1,#+10
        MOVEQ    R11,#+19
        SUB      R1,R2,R1
        ADD      R0,SP,#+16
        PUSH     {R0}
        CFI CFA R13+824
        LDR      R0,[R4, #+88]
        CMP      R1,#+20
        PUSH     {R0}
        CFI CFA R13+828
        MOVLT    R1,#+20
        ADD      R2,R11,R1
        CMP      R2,#+144
        MOVGE    R2,#+143
        RSBGE    R1,R11,#+143
        MOV      R0,R12
        BL       Dec_lag3
// 4803          st->T0_lagBuff = T0;
        LDR      R0,[SP, #+24]
// 4804 
// 4805          if ( bfi != 0 ) {
        CMP      R8,#+0
        STR      R0,[R4, #+92]
        ADD      SP,SP,#+16
        CFI CFA R13+812
        BEQ      ??Decoder_amr_17
// 4806             if ( st->old_T0 < PIT_MAX ) {
        LDR      R0,[R4, #+88]
        CMP      R0,#+143
// 4807                /* Graceful pitch degradation */
// 4808                st->old_T0 += 1;
        ADDLT    R0,R0,#+1
        STRLT    R0,[R4, #+88]
// 4809             }
// 4810             T0 = st->old_T0;
        LDR      R1,[R4, #+88]
        STR      R1,[SP, #+8]
// 4811             T0_frac = 0;
        MOV      R1,#+0
        STR      R1,[SP, #+16]
// 4812 
// 4813             if ( ( st->inBackgroundNoise != 0 ) & ( st->voicedHangover > 4 ) & (
// 4814                   ( mode == MR475 ) || ( mode == MR515 ) || ( mode == MR59 ) ) )
        LDR      R0,[R4, #+96]
        LDR      R1,[R4, #+100]
        CMP      R0,#+0
        MOVNE    R0,#+1
        CMP      R1,#+5
        MOVGE    R1,#+1
        MOVLT    R1,#+0
        CMP      R6,#+0
        CMPNE    R6,#+1
        CMPNE    R6,#+2
        MOVEQ    R2,#+1
        MOVNE    R2,#+0
        AND      R0,R1,R0
        TST      R2,R0
// 4815             {
// 4816                T0 = st->T0_lagBuff;
        LDRNE    R1,[R4, #+92]
        STRNE    R1,[SP, #+8]
// 4817             }
// 4818          }
// 4819          Pred_lt_3or6_40( st->exc, T0, T0_frac, 1 );
??Decoder_amr_17:
        LDR      R2,[SP, #+16]
        LDR      R1,[SP, #+8]
        LDR      R0,[R4, #+0]
        MOV      R3,#+1
        BL       Pred_lt_3or6_40
        CMP      R6,#+0
        CMPNE    R6,#+1
        BNE      ??Decoder_amr_18
// 4820       }
// 4821       else {
// 4822          Dec_lag6( index, PIT_MIN_MR122, PIT_MAX, pit_flag, &T0, &T0_frac );
// 4823 
// 4824          if ( ( bfi != 0 ) || ( ( pit_flag != 0 ) & ( index > 60 ) ) ) {
// 4825             st->T0_lagBuff = T0;
// 4826             T0 = st->old_T0;
// 4827             T0_frac = 0;
// 4828          }
// 4829          Pred_lt_3or6_40( st->exc, T0, T0_frac, 0 );
// 4830       }
// 4831 
// 4832        /*
// 4833         * (MR122 only: Decode pitch gain.)
// 4834         * Decode innovative codebook.
// 4835         * set pitch sharpening factor
// 4836         */
// 4837       /* MR475, MR515 */
// 4838       if ( ( mode == MR475 ) || ( mode == MR515 ) ) {
// 4839          /* index of position */
// 4840          index = *parm++;
        LDRSH    R12,[R10], #+2
// 4841 
// 4842          /* signs */
// 4843          i = *parm++;
        LDRSH    R0,[R10], #+2
// 4844          decode_2i40_9bits( subfrNr, i, index, code );
        LDR      R1,[SP, #+52]
        MOV      R11,R0
        AND      R0,R12,#0x40
        ASR      R0,R0,#+6
        LSL      R1,R1,#+1
        ADD      R0,R1,R0, LSL #+3
        LDR      R1,??Decoder_amr_3  ;; sqrt_table
        AND      R2,R12,#0x7
        ADD      R0,R0,R1
        LDRB     R3,[R0, #+320]
        ADD      R2,R2,R2, LSL #+2
        MOV      R1,#+0
        ADD      R2,R3,R2
        STR      R2,[SP, #+44]
        LDRB     R0,[R0, #+321]
        ASR      R2,R12,#+3
        AND      R2,R2,#0x7
        ADD      R2,R2,R2, LSL #+2
        ADD      R0,R0,R2
        STR      R0,[SP, #+48]
        MOV      R2,#+160
        ADD      R0,SP,#+64
        SWI      +187
        MOV      R0,R7
        ADD      R3,SP,#+64
        B        ??Decoder_amr_19
??Decoder_amr_16:
        CMP      R3,#+0
        BNE      ??Decoder_amr_20
        MOV      R0,#+207
        ORR      R0,R0,#0x100
        CMP      R12,R0
        BGE      ??Decoder_amr_21
        LDR      R2,??Decoder_amr_22  ;; 0x2aaaaaab
        ADD      R1,R12,#+5
        SMULL    R11,LR,R2,R1
        ADD      R1,LR,R1, LSR #+31
        ADD      R1,R1,#+17
        STR      R1,[SP, #+8]
        ADD      R1,R1,R1, LSL #+1
        SUB      R1,R12,R1, LSL #+1
        ADD      R1,R1,#+105
        B        ??Decoder_amr_23
??Decoder_amr_21:
        MVN      R1,#+111
        BIC      R1,R1,#0x100
        ADD      R1,R1,R12
        STR      R1,[SP, #+8]
        MOV      R1,#+0
        B        ??Decoder_amr_23
??Decoder_amr_20:
        LDR      R0,[SP, #+8]
        LDR      R2,??Decoder_amr_22  ;; 0x2aaaaaab
        SUB      R0,R0,#+5
        CMP      R0,#+18
        MOVLT    R0,#+18
        ADD      R1,R0,#+9
        CMP      R1,#+144
        ADD      R1,R12,#+5
        SMULL    R11,LR,R2,R1
        MOVGE    R0,#+134
        ADD      R1,LR,R1, LSR #+31
        SUB      R1,R1,#+1
        ADD      R0,R0,R1
        STR      R0,[SP, #+8]
        SUB      R2,R12,#+3
        ADD      R1,R1,R1, LSL #+1
        SUB      R1,R2,R1, LSL #+1
??Decoder_amr_23:
        STR      R1,[SP, #+16]
        CMP      R8,#+0
        BNE      ??Decoder_amr_24
        CMP      R3,#+0
        BEQ      ??Decoder_amr_25
        CMP      R12,#+61
        BLT      ??Decoder_amr_26
??Decoder_amr_24:
        LDR      R0,[SP, #+8]
        STR      R0,[R4, #+92]
        LDR      R1,[R4, #+88]
        STR      R1,[SP, #+8]
        MOV      R1,#+0
        STR      R1,[SP, #+16]
??Decoder_amr_26:
        MOV      R3,#+0
??Decoder_amr_25:
        LDR      R2,[SP, #+16]
        LDR      R1,[SP, #+8]
        LDR      R0,[R4, #+0]
        BL       Pred_lt_3or6_40
// 4845          pit_sharp = st->sharp << 1;
// 4846       }
// 4847 
// 4848       /* MR59 */
// 4849       else if ( mode == MR59 ) {
// 4850          /* index of position */
// 4851          index = *parm++;
// 4852 
// 4853          /* signs */
// 4854          i = *parm++;
// 4855          decode_2i40_11bits( i, index, code );
// 4856          pit_sharp = st->sharp << 1;
// 4857       }
// 4858 
// 4859       /* MR67 */
// 4860       else if ( mode == MR67 ) {
// 4861          /* index of position */
// 4862          index = *parm++;
// 4863 
// 4864          /* signs */
// 4865          i = *parm++;
// 4866          decode_3i40_14bits( i, index, code );
// 4867          pit_sharp = st->sharp << 1;
// 4868       }
// 4869 
// 4870       /* MR74, MR795 */
// 4871       else if ( mode <= MR795 ) {
// 4872          /* index of position */
// 4873          index = *parm++;
// 4874 
// 4875          /* signs */
// 4876          i = *parm++;
// 4877          decode_4i40_17bits( i, index, code );
// 4878          pit_sharp = st->sharp << 1;
// 4879       }
// 4880 
// 4881       /* MR102 */
// 4882       else if ( mode == MR102 ) {
// 4883          decode_8i40_31bits( parm, code );
// 4884          parm += 7;
// 4885          pit_sharp = st->sharp << 1;
// 4886       }
// 4887 
// 4888       /* MR122 */
// 4889       else {
// 4890          index = *parm++;
??Decoder_amr_27:
        LDRSH    R12,[R10], #+2
// 4891 
// 4892          if ( bfi != 0 ) {
        CMP      R8,#+0
        BEQ      ??Decoder_amr_28
// 4893             ec_gain_pitch( st->ec_gain_p_st, st->state, &gain_pit );
        LDRSH    R11,[R4, #+180]
        LDR      R1,[R4, #+200]
        STR      R1,[SP, #+4]
        LDR      R0,[SP, #+4]
        MOV      R1,#+5
        BL       gmed_n
        LDR      R1,[SP, #+4]
        LDR      R2,??Decoder_amr_3  ;; sqrt_table
        LDR      R1,[R1, #+20]
        ADD      R2,R2,R11, LSL #+2
        LDR      R2,[R2, #+196]
        CMP      R1,R0
        MOVLT    R0,R1
        MUL      R0,R2,R0
        ASR      R0,R0,#+15
        B        ??Decoder_amr_29
// 4894          }
??Decoder_amr_30:
        STR      R2,[R1, #+0]
        ADD      R0,R0,#+1
        CMP      R0,#+2
        BGE      ??Decoder_amr_31
??Decoder_amr_19:
        ADD      R1,SP,#+44
        LDR      R1,[R1, +R0, LSL #+2]
        AND      R2,R11,#0x1
        ASR      R11,R11,#+1
        ADD      R1,R3,R1, LSL #+2
        CMP      R2,#+0
        MVNEQ    R2,#+255
        BICEQ    R2,R2,#0x1F00
        MOVNE    R2,#+255
        ORRNE    R2,R2,#0x1F00
        B        ??Decoder_amr_30
??Decoder_amr_18:
        CMP      R6,#+2
        BNE      ??Decoder_amr_32
        LDRSH    R12,[R10], #+2
        LDRSH    R0,[R10], #+2
        AND      R2,R12,#0x1
        MOV      R11,R0
        ASR      R0,R12,#+1
        AND      R3,R0,#0x7
        ADD      R3,R3,R3, LSL #+2
        ADD      R2,R3,R2, LSL #+1
        ADD      R2,R2,#+1
        STR      R2,[SP, #+44]
        ASR      R0,R0,#+3
        AND      R1,R0,#0x3
        MOV      R2,#+7
        AND      R0,R2,R0, ASR #+2
        CMP      R1,#+3
        ADD      R0,R0,R0, LSL #+2
        ADDEQ    R0,R0,#+4
        ADDNE    R0,R1,R0
        STR      R0,[SP, #+48]
        MOV      R2,#+160
        MOV      R1,#+0
        ADD      R0,SP,#+64
        SWI      +187
        MOV      R1,R7
        ADD      R3,SP,#+64
??Decoder_amr_33:
        ADD      R2,SP,#+44
        LDR      R2,[R2, +R1, LSL #+2]
        AND      R0,R11,#0x1
        ASR      R11,R11,#+1
        ADD      R2,R3,R2, LSL #+2
        CMP      R0,#+0
        MOVNE    R0,#+255
        ORRNE    R0,R0,#0x1F00
        MVNEQ    R0,#+255
        BICEQ    R0,R0,#0x1F00
        STR      R0,[R2, #+0]
        ADD      R1,R1,#+1
        CMP      R1,#+2
        BLT      ??Decoder_amr_33
??Decoder_amr_31:
        LDR      R0,[R4, #+84]
        B        ??Decoder_amr_34
??Decoder_amr_32:
        CMP      R6,#+3
        BNE      ??Decoder_amr_35
        LDRSH    R12,[R10], #+2
        LDRSH    R0,[R10], #+2
        ADD      R2,SP,#+64
        MOV      R1,R12
        BL       decode_3i40_14bits
        B        ??Decoder_amr_31
??Decoder_amr_35:
        CMP      R6,#+6
        BCS      ??Decoder_amr_36
        LDRSH    R12,[R10], #+2
        LDRSH    R0,[R10], #+2
        ADD      R2,SP,#+64
        MOV      R1,R12
        BL       decode_4i40_17bits
        LDR      R0,[R4, #+84]
        B        ??Decoder_amr_34
??Decoder_amr_36:
        BNE      ??Decoder_amr_27
        MOV      R2,#+160
        MOV      R1,#+0
        ADD      R0,SP,#+64
        SWI      +187
        ADD      R1,SP,#+744
        ADD      R0,R10,#+8
        BL       decompress_codewords
        MOV      R0,R7
        ADD      R11,SP,#+64
??Decoder_amr_37:
        ADD      R2,R10,R0, LSL #+1
        LDRSH    R2,[R2, #+0]
        ADD      R1,SP,#+744
        ADD      R3,R1,R0, LSL #+2
        LDR      R1,[R3, #+0]
        LDR      R3,[R3, #+16]
        ADD      R1,R0,R1, LSL #+2
        CMP      R2,#+0
        MOVEQ    R2,#+255
        ORREQ    R2,R2,#0x1F00
        MVNNE    R2,#+254
        BICNE    R2,R2,#0x1F00
        ADD      R3,R0,R3, LSL #+2
        STR      R2,[R11, +R1, LSL #+2]
        CMP      R3,R1
        ADD      R1,SP,#+64
        ADD      R1,R1,R3, LSL #+2
        LDR      R3,[R1, #+0]
        RSBLT    R2,R2,#+0
        ADD      R2,R2,R3
        STR      R2,[R1, #+0]
        ADD      R0,R0,#+1
        CMP      R0,#+4
        BLT      ??Decoder_amr_37
        LDR      R0,[R4, #+84]
        ADD      R10,R10,#+14
        B        ??Decoder_amr_34
??Decoder_amr_28:
        LDR      R0,??Decoder_amr_3  ;; sqrt_table
        CMP      R6,#+7
        ADD      R0,R0,R12, LSL #+2
        LDR      R0,[R0, #+224]
// 4895          else {
// 4896             gain_pit = d_gain_pitch( mode, index );
        ASREQ    R0,R0,#+2
        LSLEQ    R0,R0,#+2
??Decoder_amr_29:
        STR      R0,[SP, #+0]
// 4897          }
// 4898          ec_gain_pitch_update( st->ec_gain_p_st, bfi, st->prev_bf, &gain_pit );
        LDRSH    R2,[R4, #+176]
        LDR      R0,[R4, #+200]
        MOV      R3,SP
        MOV      R1,R8
        BL       ec_gain_pitch_update
// 4899          decode_10i40_35bits( parm, code );
        MOV      R2,#+160
        MOV      R1,#+0
        ADD      R0,SP,#+64
        SWI      +187
        MOV      R0,R7
??Decoder_amr_38:
        LDR      R11,??Decoder_amr_3  ;; sqrt_table
        ADD      R1,R10,R0, LSL #+1
        LDRSH    R2,[R1, #+0]
        LDRSH    R1,[R1, #+10]
        AND      R3,R2,#0x7
        ADD      R3,R11,R3, LSL #+2
        LDR      R3,[R3, #+288]
        AND      R1,R1,#0x7
        ADD      R1,R11,R1, LSL #+2
        LDR      R1,[R1, #+288]
        ADD      R3,R3,R3, LSL #+2
        ADD      R3,R0,R3
        TST      R2,#0x8
        MOVEQ    R2,#+4096
        MVNNE    R2,#+255
        BICNE    R2,R2,#0xF00
        ADD      R1,R1,R1, LSL #+2
        ADD      R1,R0,R1
        ADD      R11,SP,#+64
        STR      R2,[R11, +R3, LSL #+2]
        CMP      R1,R3
        ADD      R3,SP,#+64
        ADD      R1,R3,R1, LSL #+2
        LDR      R3,[R1, #+0]
        RSBLT    R2,R2,#+0
        ADD      R2,R2,R3
        STR      R2,[R1, #+0]
        ADD      R0,R0,#+1
        CMP      R0,#+5
        BLT      ??Decoder_amr_38
// 4900          parm += 10;
// 4901 
// 4902            /*
// 4903             * pit_sharp = gain_pit;
// 4904             * if (pit_sharp > 1.0) pit_sharp = 1.0;
// 4905             */
// 4906          pit_sharp = gain_pit;
// 4907 
// 4908          if ( pit_sharp > 16383 )
        LDR      R0,[SP, #+0]
        ADD      R10,R10,#+20
        CMP      R0,#+16384
// 4909             pit_sharp = 32767;
        MOVGE    R1,#+255
        ORRGE    R1,R1,#0x7F00
        BGE      ??Decoder_amr_39
// 4910          else
// 4911             pit_sharp *= 2;
??Decoder_amr_34:
        LSL      R1,R0,#+1
// 4912       }
// 4913 
// 4914         /*
// 4915          * Add the pitch contribution to code[].
// 4916          */
// 4917       for ( i = T0; i < L_SUBFR; i++ ) {
??Decoder_amr_39:
        LDR      R0,[SP, #+8]
        ADD      R12,SP,#+64
        CMP      R0,#+40
        BGE      ??Decoder_amr_40
// 4918          temp = ( code[i - T0] * pit_sharp ) >> 15;
// 4919          code[i] = code[i] + temp;
??Decoder_amr_41:
        LDR      R11,[SP, #+8]
        ADD      R2,SP,#+64
        SUB      R11,R0,R11
        LDR      R11,[R12, +R11, LSL #+2]
        ADD      R2,R2,R0, LSL #+2
        LDR      R3,[R2, #+0]
        MUL      R11,R1,R11
// 4920       }
        ADD      R0,R0,#+1
        ADD      R3,R3,R11, ASR #+15
        STR      R3,[R2, #+0]
        CMP      R0,#+40
        BLT      ??Decoder_amr_41
??Decoder_amr_40:
        CMP      R6,#+0
        BNE      ??Decoder_amr_42
// 4921 
// 4922         /*
// 4923          * Decode codebook gain (MR122) or both pitch
// 4924          * gain and codebook gain (all others)
// 4925          * Update pitch sharpening "sharp" with quantized gain_pit
// 4926          */
// 4927       if ( mode == MR475 ) {
// 4928          /* read and decode pitch and code gain */
// 4929          if ( evenSubfr != 0 ) {
        LDR      R0,[SP, #+28]
        CMP      R0,#+0
// 4930             /* index of gain(s) */
// 4931             index_mr475 = *parm++;
        LDRSHNE  R1,[R10], #+2
        STRNE    R1,[SP, #+60]
// 4932          }
// 4933 
// 4934          if ( bfi == 0 ) {
        CMP      R8,#+0
        BNE      ??Decoder_amr_43
// 4935             Dec_gain( st->pred_state, mode, index_mr475, code, evenSubfr, &
// 4936                   gain_pit, &gain_code );
        ADD      R0,SP,#+12
        PUSH     {R0}
        CFI CFA R13+816
        MOV      R1,#+0
        ADD      R0,SP,#+4
        PUSH     {R0}
        CFI CFA R13+820
        LDR      R0,[SP, #+36]
        PUSH     {R0}
        CFI CFA R13+824
        LDR      R2,[SP, #+72]
        LDR      R0,[R4, #+208]
        ADD      R3,SP,#+76
        BL       Dec_gain
        ADD      SP,SP,#+12
        CFI CFA R13+812
        B        ??Decoder_amr_44
// 4937          }
// 4938          else {
// 4939             ec_gain_pitch( st->ec_gain_p_st, st->state, &gain_pit );
??Decoder_amr_43:
        LDRSH    R11,[R4, #+180]
        LDR      R1,[R4, #+200]
        STR      R1,[SP, #+4]
        LDR      R0,[SP, #+4]
        MOV      R1,#+5
        BL       gmed_n
        LDR      R1,[SP, #+4]
        LDR      R2,??Decoder_amr_3  ;; sqrt_table
        LDR      R1,[R1, #+20]
        ADD      R2,R2,R11, LSL #+2
        LDR      R2,[R2, #+196]
        CMP      R1,R0
        MOVLT    R0,R1
        MUL      R0,R2,R0
// 4940             ec_gain_code( st->ec_gain_c_st, st->pred_state, st->state, &
// 4941                   gain_code );
        ADD      R3,SP,#+12
        ASR      R0,R0,#+15
        STR      R0,[SP, #+0]
        LDRSH    R2,[R4, #+180]
        LDR      R1,[R4, #+208]
        LDR      R0,[R4, #+204]
        BL       ec_gain_code
// 4942          }
// 4943          ec_gain_pitch_update( st->ec_gain_p_st, bfi, st->prev_bf, &gain_pit );
??Decoder_amr_44:
        LDRSH    R2,[R4, #+176]
        LDR      R0,[R4, #+200]
        MOV      R3,SP
        MOV      R1,R8
        BL       ec_gain_pitch_update
// 4944          ec_gain_code_update( st->ec_gain_c_st, bfi, st->prev_bf, &gain_code );
        LDRSH    R2,[R4, #+176]
        LDR      R0,[R4, #+204]
        ADD      R3,SP,#+12
        MOV      R1,R8
        BL       ec_gain_code_update
// 4945          pit_sharp = gain_pit;
        LDR      R0,[SP, #+0]
// 4946 
// 4947          if ( pit_sharp > SHARPMAX ) {
        MOV      R1,#+218
        ORR      R1,R1,#0x3200
        CMP      R0,R1
// 4948             pit_sharp = SHARPMAX;
        SUBGE    R0,R1,#+1
        LDR      R1,[SP, #+28]
        CMP      R1,#+0
        BNE      ??Decoder_amr_45
// 4949          }
// 4950       }
// 4951       else if ( ( mode <= MR74 ) || ( mode == MR102 ) ) {
// 4952          /* read and decode pitch and code gain */
// 4953          /* index of gain(s) */
// 4954          index = *parm++;
// 4955 
// 4956          if ( bfi == 0 ) {
// 4957             Dec_gain( st->pred_state, mode, index, code, evenSubfr, &gain_pit, &
// 4958                   gain_code );
// 4959          }
// 4960          else {
// 4961             ec_gain_pitch( st->ec_gain_p_st, st->state, &gain_pit );
// 4962             ec_gain_code( st->ec_gain_c_st, st->pred_state, st->state, &
// 4963                   gain_code );
// 4964          }
// 4965          ec_gain_pitch_update( st->ec_gain_p_st, bfi, st->prev_bf, &gain_pit );
// 4966          ec_gain_code_update( st->ec_gain_c_st, bfi, st->prev_bf, &gain_code );
// 4967          pit_sharp = gain_pit;
// 4968 
// 4969          if ( pit_sharp > SHARPMAX ) {
// 4970             pit_sharp = SHARPMAX;
// 4971          }
// 4972 
// 4973          if ( mode == MR102 ) {
// 4974             if ( st->old_T0 > ( L_SUBFR + 5 ) ) {
// 4975                pit_sharp = pit_sharp >> 2;
// 4976             }
// 4977          }
// 4978       }
// 4979       else {
// 4980          /* read and decode pitch gain */
// 4981          /* index of gain(s) */
// 4982          index = *parm++;
// 4983 
// 4984          if ( mode == MR795 ) {
// 4985             /* decode pitch gain */
// 4986             if ( bfi != 0 ) {
// 4987                ec_gain_pitch( st->ec_gain_p_st, st->state, &gain_pit );
// 4988             }
// 4989             else {
// 4990                gain_pit = d_gain_pitch( mode, index );
// 4991             }
// 4992             ec_gain_pitch_update( st->ec_gain_p_st, bfi, st->prev_bf, &gain_pit
// 4993                   );
// 4994 
// 4995             /* read and decode code gain */
// 4996             index = *parm++;
// 4997 
// 4998             if ( bfi == 0 ) {
// 4999                d_gain_code( st->pred_state, mode, index, code, &gain_code );
// 5000             }
// 5001             else {
// 5002                ec_gain_code( st->ec_gain_c_st, st->pred_state, st->state, &
// 5003                      gain_code );
// 5004             }
// 5005             ec_gain_code_update( st->ec_gain_c_st, bfi, st->prev_bf, &gain_code
// 5006                   );
// 5007             pit_sharp = gain_pit;
// 5008 
// 5009             if ( pit_sharp > SHARPMAX ) {
// 5010                pit_sharp = SHARPMAX;
// 5011             }
// 5012          }
// 5013          else {   /* MR122 */
// 5014 
// 5015             if ( bfi == 0 ) {
// 5016                d_gain_code( st->pred_state, mode, index, code, &gain_code );
// 5017             }
// 5018             else {
// 5019                ec_gain_code( st->ec_gain_c_st, st->pred_state, st->state, &
// 5020                      gain_code );
// 5021             }
// 5022             ec_gain_code_update( st->ec_gain_c_st, bfi, st->prev_bf, &gain_code
// 5023                   );
// 5024             pit_sharp = gain_pit;
// 5025          }
// 5026       }
// 5027 
// 5028         /*
// 5029          * store pitch sharpening for next subframe
// 5030          * (for modes which use the previous pitch gain for
// 5031          *  pitch sharpening in the search phase)
// 5032          * do not update sharpening in even subframes for MR475
// 5033          */
// 5034       if ( ( mode != MR475 ) || evenSubfr == 0 ) {
// 5035          st->sharp = gain_pit;
??Decoder_amr_46:
        LDR      R1,[SP, #+0]
// 5036 
// 5037          if ( st->sharp > SHARPMAX ) {
        MOV      R2,#+218
        STR      R1,[R4, #+84]
        ORR      R2,R2,#0x3200
        CMP      R1,R2
// 5038             st->sharp = SHARPMAX;
        SUBGE    R1,R2,#+1
        STRGE    R1,[R4, #+84]
??Decoder_amr_45:
        CMP      R0,#+16384
        BLT      ??Decoder_amr_47
// 5039          }
// 5040       }
// 5041 
// 5042       if ( pit_sharp > 16383 )
// 5043          pit_sharp = 32767;
        MOV      R1,#+255
        ORR      R1,R1,#0x7F00
        STR      R1,[SP, #+40]
        B        ??Decoder_amr_48
??Decoder_amr_42:
        CMP      R6,#+5
        BCC      ??Decoder_amr_49
        CMP      R6,#+6
        BNE      ??Decoder_amr_50
??Decoder_amr_49:
        LDRSH    R12,[R10], #+2
        CMP      R8,#+0
        BNE      ??Decoder_amr_51
        ADD      R0,SP,#+12
        PUSH     {R0}
        CFI CFA R13+816
        MOV      R2,R12
        MOV      R1,R6
        ADD      R0,SP,#+4
        PUSH     {R0}
        CFI CFA R13+820
        LDR      R0,[SP, #+36]
        PUSH     {R0}
        CFI CFA R13+824
        LDR      R0,[R4, #+208]
        ADD      R3,SP,#+76
        BL       Dec_gain
        ADD      SP,SP,#+12
        CFI CFA R13+812
        B        ??Decoder_amr_52
??Decoder_amr_51:
        LDRSH    R11,[R4, #+180]
        LDR      R1,[R4, #+200]
        STR      R1,[SP, #+4]
        LDR      R0,[SP, #+4]
        MOV      R1,#+5
        BL       gmed_n
        LDR      R1,[SP, #+4]
        LDR      R2,??Decoder_amr_3  ;; sqrt_table
        LDR      R1,[R1, #+20]
        ADD      R2,R2,R11, LSL #+2
        LDR      R2,[R2, #+196]
        CMP      R1,R0
        MOVLT    R0,R1
        MUL      R0,R2,R0
        ADD      R3,SP,#+12
        ASR      R0,R0,#+15
        STR      R0,[SP, #+0]
        LDRSH    R2,[R4, #+180]
        LDR      R1,[R4, #+208]
        LDR      R0,[R4, #+204]
        BL       ec_gain_code
??Decoder_amr_52:
        LDRSH    R2,[R4, #+176]
        LDR      R0,[R4, #+200]
        MOV      R3,SP
        MOV      R1,R8
        BL       ec_gain_pitch_update
        LDRSH    R2,[R4, #+176]
        LDR      R0,[R4, #+204]
        ADD      R3,SP,#+12
        MOV      R1,R8
        BL       ec_gain_code_update
        LDR      R0,[SP, #+0]
        MOV      R1,#+218
        ORR      R1,R1,#0x3200
        CMP      R0,R1
        SUBGE    R0,R1,#+1
        CMP      R6,#+6
        BNE      ??Decoder_amr_46
        LDR      R1,[R4, #+88]
        CMP      R1,#+46
        BLT      ??Decoder_amr_46
        ASR      R0,R0,#+2
        B        ??Decoder_amr_46
??Decoder_amr_50:
        LDRSH    R12,[R10], #+2
        CMP      R6,#+5
        BNE      ??Decoder_amr_53
        CMP      R8,#+0
        BEQ      ??Decoder_amr_54
        LDRSH    R11,[R4, #+180]
        LDR      R1,[R4, #+200]
        STR      R1,[SP, #+4]
        LDR      R0,[SP, #+4]
        MOV      R1,#+5
        BL       gmed_n
        LDR      R1,[SP, #+4]
        LDR      R2,??Decoder_amr_3  ;; sqrt_table
        LDR      R1,[R1, #+20]
        ADD      R2,R2,R11, LSL #+2
        LDR      R2,[R2, #+196]
        CMP      R1,R0
        MOVLT    R0,R1
        MUL      R0,R2,R0
        ASR      R0,R0,#+15
        STR      R0,[SP, #+0]
        B        ??Decoder_amr_55
??Decoder_amr_54:
        LDR      R1,??Decoder_amr_3  ;; sqrt_table
        ADD      R1,R1,R12, LSL #+2
        LDR      R1,[R1, #+224]
        STR      R1,[SP, #+0]
??Decoder_amr_55:
        LDRSH    R2,[R4, #+176]
        LDR      R0,[R4, #+200]
        MOV      R3,SP
        MOV      R1,R8
        BL       ec_gain_pitch_update
        LDRSH    R12,[R10], #+2
        CMP      R8,#+0
        BNE      ??Decoder_amr_56
        ADD      R0,SP,#+12
        PUSH     {R0}
        CFI CFA R13+816
        ADD      R3,SP,#+68
        MOV      R2,R12
        LDR      R0,[R4, #+208]
        MOV      R1,#+5
        BL       d_gain_code
        ADD      SP,SP,#+4
        CFI CFA R13+812
        B        ??Decoder_amr_57
??Decoder_amr_56:
        LDRSH    R2,[R4, #+180]
        LDR      R1,[R4, #+208]
        LDR      R0,[R4, #+204]
        ADD      R3,SP,#+12
        BL       ec_gain_code
??Decoder_amr_57:
        LDRSH    R2,[R4, #+176]
        LDR      R0,[R4, #+204]
        ADD      R3,SP,#+12
        MOV      R1,R8
        BL       ec_gain_code_update
        LDR      R0,[SP, #+0]
        MOV      R1,#+218
        ORR      R1,R1,#0x3200
        CMP      R0,R1
        BLT      ??Decoder_amr_46
        SUB      R0,R1,#+1
        B        ??Decoder_amr_46
??Decoder_amr_53:
        CMP      R8,#+0
        BNE      ??Decoder_amr_58
        ADD      R0,SP,#+12
        PUSH     {R0}
        CFI CFA R13+816
        ADD      R3,SP,#+68
        MOV      R2,R12
        LDR      R0,[R4, #+208]
        MOV      R1,R6
        BL       d_gain_code
        ADD      SP,SP,#+4
        CFI CFA R13+812
        B        ??Decoder_amr_59
??Decoder_amr_58:
        LDRSH    R2,[R4, #+180]
        LDR      R1,[R4, #+208]
        LDR      R0,[R4, #+204]
        ADD      R3,SP,#+12
        BL       ec_gain_code
??Decoder_amr_59:
        LDRSH    R2,[R4, #+176]
        LDR      R0,[R4, #+204]
        ADD      R3,SP,#+12
        MOV      R1,R8
        BL       ec_gain_code_update
        LDR      R0,[SP, #+0]
        B        ??Decoder_amr_46
// 5044       else
// 5045          pit_sharp *= 2;
??Decoder_amr_47:
        LSL      R0,R0,#+1
        STR      R0,[SP, #+40]
// 5046 
// 5047       if ( pit_sharp > 16384 ) {
        ORR      R1,R9,#0x4000
        CMP      R0,R1
        BLT      ??Decoder_amr_60
// 5048          for ( i = 0; i < L_SUBFR; i++ ) {
??Decoder_amr_48:
        MOV      R0,#+0
// 5049             temp = ( st->exc[i] * pit_sharp ) >> 15;
// 5050             temp2 = ( temp * gain_pit ) << 1;
??Decoder_amr_61:
        LDR      R1,[R4, #+0]
        LDR      R2,[SP, #+40]
        LDR      R1,[R1, +R0, LSL #+2]
// 5051 
// 5052             if ( mode == MR122 ) {
        CMP      R6,#+7
        MUL      R1,R2,R1
        LDR      R2,[SP, #+0]
        ASR      R1,R1,#+15
        MUL      R1,R2,R1
// 5053                temp2 = ( temp2 >> 1 );
// 5054             }
// 5055             excp[i] = ( temp2 + 0x00008000L ) >> 16;
        ADD      R2,SP,#+344
        LSL      R1,R1,#+1
        ASREQ    R1,R1,#+1
        ADD      R1,R1,#+32768
        ASR      R1,R1,#+16
        STR      R1,[R2, +R0, LSL #+2]
// 5056          }
        ADD      R0,R0,#+1
        CMP      R0,#+40
        BLT      ??Decoder_amr_61
// 5057       }
// 5058 
// 5059         /*
// 5060          * Store list of LTP gains needed in the source
// 5061          * characteristic detector (SCD)
// 5062          */
// 5063       if ( bfi == 0 ) {
??Decoder_amr_60:
        CMP      R8,#+0
        BNE      ??Decoder_amr_62
// 5064          for (i = 0; i < 8; i++){
        MOV      R0,#+0
// 5065             st->ltpGainHistory[i] = st->ltpGainHistory[i+1];
??Decoder_amr_63:
        ADD      R1,R0,#+1
        ADD      R2,R5,R1, LSL #+2
        LDR      R2,[R2, #+880]
        ADD      R0,R5,R0, LSL #+2
        STR      R2,[R0, #+880]
// 5066          }
        MOV      R0,R1
        CMP      R0,#+8
        BLT      ??Decoder_amr_63
// 5067          st->ltpGainHistory[8] = gain_pit;
        LDR      R0,[SP, #+0]
        STR      R0,[R4, #+136]
// 5068       }
// 5069 
// 5070 
// 5071         /*
// 5072          * Limit gain_pit if in background noise and BFI
// 5073          * for MR475, MR515, MR59
// 5074          */
// 5075       if ( ( st->prev_bf != 0 || bfi != 0 ) & ( st->inBackgroundNoise != 0 ) & (
// 5076             ( mode == MR475 ) || ( mode == MR515 ) || ( mode == MR59 ) ) ) {
??Decoder_amr_62:
        LDRSH    R0,[R4, #+176]
        LDR      R1,[R4, #+96]
        CMP      R0,#+0
        CMPEQ    R8,#+0
        MOVNE    R0,#+1
        CMP      R1,#+0
        MOVNE    R1,#+1
        CMP      R6,#+0
        CMPNE    R6,#+1
        CMPNE    R6,#+2
        MOVEQ    R2,#+1
        MOVNE    R2,#+0
        AND      R0,R1,R0
        TST      R2,R0
        BEQ      ??Decoder_amr_64
// 5077          /* if (gain_pit > 0.75) in Q14*/
// 5078          if ( gain_pit > 12288 )
        LDR      R0,[SP, #+0]
        ORR      R1,R9,#0x3000
        CMP      R0,R1
        BLT      ??Decoder_amr_65
// 5079             /* gain_pit = (gain_pit-0.75)/2.0 + 0.75; */
// 5080             gain_pit = ( ( gain_pit - 12288 ) >> 1 ) + 12288;
        SUB      R1,R0,#+12288
        MOV      R2,#+12288
        ADD      R1,R2,R1, ASR #+1
        STR      R1,[SP, #+0]
// 5081 
// 5082          /* if (gain_pit > 0.90) in Q14*/
// 5083          if ( gain_pit > 14745 ) {
??Decoder_amr_65:
        LDR      R0,[SP, #+0]
        MOV      R1,#+154
        ORR      R1,R1,#0x3900
        CMP      R0,R1
// 5084             gain_pit = 14745;
        SUBGE    R1,R1,#+1
        STRGE    R1,[SP, #+0]
// 5085          }
// 5086       }
// 5087 
// 5088         /*
// 5089          * Calculate CB mixed gain
// 5090          */
// 5091       Int_lsf( prev_lsf, st->lsfState->past_lsf_q, i_subfr, lsf_i );
??Decoder_amr_64:
        LDR      R0,[R4, #+196]
        LDR      R2,[SP, #+20]
        ADD      R3,SP,#+704
        ADD      R1,R0,#+40
        ADD      R0,SP,#+664
        BL       Int_lsf
// 5092       gain_code_mix = Cb_gain_average( st->Cb_gain_averState, mode, gain_code,
// 5093             lsf_i, st->lsp_avg_st->lsp_meanSave, bfi, st->prev_bf, pdfi, st->
// 5094             prev_pdf, st->inBackgroundNoise, st->voicedHangover );
        LDR      R0,[R4, #+100]
        MOV      R1,R6
        PUSH     {R0}
        CFI CFA R13+816
        LDR      R0,[R4, #+96]
        PUSH     {R0}
        CFI CFA R13+820
        LDRSH    R0,[R4, #+178]
        PUSH     {R0}
        CFI CFA R13+824
        LDR      R0,[SP, #+48]
        MOV      R0,R0, LSL #+16
        MOV      R0,R0, ASR #+16
        PUSH     {R0}
        CFI CFA R13+828
        LDRSH    R0,[R4, #+176]
        PUSH     {R0}
        CFI CFA R13+832
        MOV      R0,R8
        PUSH     {R0}
        CFI CFA R13+836
        LDR      R0,[R4, #+192]
        PUSH     {R0}
        CFI CFA R13+840
        LDR      R2,[SP, #+40]
        LDR      R0,[R4, #+188]
        ADD      R3,SP,#+732
        BL       Cb_gain_average
        STR      R0,[SP, #+32]
// 5095 
// 5096       /* make sure that MR74, MR795, MR122 have original codeGain*/
// 5097       /* MR74, MR795, MR122 */
// 5098       if ( ( mode > MR67 ) & ( mode != MR102 ) ) {
        CMP      R6,#+4
        ADD      SP,SP,#+28
        CFI CFA R13+812
        BCC      ??Decoder_amr_66
        CMP      R6,#+6
// 5099          gain_code_mix = gain_code;
        LDRNE    R1,[SP, #+12]
        STRNE    R1,[SP, #+4]
// 5100       }
// 5101 
// 5102         /*
// 5103          * Find the total excitation.
// 5104          * Find synthesis speech corresponding to st->exc[].
// 5105          */
// 5106       /* MR475, MR515, MR59, MR67, MR74, MR795, MR102*/
// 5107       if ( mode <= MR102 ) {
??Decoder_amr_66:
        LDR      R1,[SP, #+0]
        CMP      R6,#+7
// 5108          pitch_fac = gain_pit;
        STRCC    R1,[SP, #+24]
// 5109          tmp_shift = 1;
        MOVCC    R11,#+1
// 5110       }
// 5111 
// 5112       /* MR122 */
// 5113       else {
// 5114          pitch_fac = gain_pit >> 1;
        ASRCS    R1,R1,#+1
        STRCS    R1,[SP, #+24]
// 5115          tmp_shift = 2;
// 5116       }
// 5117 
// 5118         /*
// 5119          * copy unscaled LTP excitation to exc_enhanced (used in phase
// 5120          * dispersion below) and compute total excitation for LTP feedback
// 5121          */
// 5122       memcpy( exc_enhanced, st->exc, L_SUBFR <<2 );
        LDR      R1,[R4, #+0]
        MOVCS    R11,#+2
        MOV      R2,#+160
        ADD      R0,SP,#+504
        SWI      +286
// 5123 
// 5124       for ( i = 0; i < L_SUBFR; i++ ) {
        MOV      R2,#+0
// 5125          /* st->exc[i] = gain_pit*st->exc[i] + gain_code*code[i]; */
// 5126          temp = ( st->exc[i] * pitch_fac ) + ( code[i] * gain_code );
??Decoder_amr_67:
        LDR      R0,[R4, #+0]
        LDR      R1,[SP, #+24]
        LDR      R0,[R0, +R2, LSL #+2]
        LDR      R12,[SP, #+12]
        ADD      R3,SP,#+64
        LDR      R3,[R3, +R2, LSL #+2]
        MUL      R3,R12,R3
        MLA      R0,R1,R0,R3
// 5127          temp2 = ( temp << tmp_shift );
        LSL      R1,R0,R11
// 5128          if (((temp2 >> 1) ^ temp2) & 0x40000000) {
        EOR      R3,R1,R1, ASR #+1
        TST      R3,#0x40000000
        BEQ      ??Decoder_amr_68
// 5129             if ((temp ^ temp2) & 0x80000000) {
        MVN      R3,#-1073741824
        BIC      R3,R3,#0x4000
        EOR      R12,R1,R0
        TST      R12,#0x80000000
        BEQ      ??Decoder_amr_69
// 5130                temp2 = (temp & 0x80000000) ? (-1073741824L) : 1073725439;
        TST      R0,#0x80000000
        B        ??Decoder_amr_70
        DATA
??Decoder_amr_3:
        DC32     sqrt_table
        ARM
// 5131             }
// 5132             else {
// 5133                temp2 = (temp2 & 0x80000000) ? (-1073741824L) : 1073725439;
??Decoder_amr_69:
        TST      R1,#0x80000000
??Decoder_amr_70:
        MOVNE    R1,#-1073741824
        MOVEQ    R1,R3
// 5134             }
// 5135          }
// 5136          st->exc[i] = ( temp2 + 0x00004000L ) >> 15;
??Decoder_amr_68:
        LDR      R0,[R4, #+0]
        ADD      R1,R1,#+16384
        ASR      R1,R1,#+15
        STR      R1,[R0, +R2, LSL #+2]
// 5137       }
        ADD      R2,R2,#+1
        CMP      R2,#+40
        BLT      ??Decoder_amr_67
// 5138       /*
// 5139        * Adaptive phase dispersion
// 5140        */
// 5141 
// 5142       /* mfree phase dispersion adaption */
// 5143       st->ph_disp_st->lockFull = 0;
        LDR      R0,[R4, #+212]
// 5144 
// 5145       if ( ( ( mode == MR475 ) || ( mode == MR515 ) || ( mode == MR59 ) ) & ( st
// 5146             ->voicedHangover > 3 ) & ( st->inBackgroundNoise != 0 ) & ( bfi != 0
// 5147             ) ) {
        CMP      R6,#+0
        STRH     R7,[R0, #+28]
        LDR      R1,[R4, #+100]
        LDR      R2,[R4, #+96]
        CMPNE    R6,#+1
        CMPNE    R6,#+2
        MOVEQ    R0,#+1
        MOVNE    R0,#+0
        CMP      R1,#+4
        MOVGE    R1,#+1
        MOVLT    R1,#+0
        CMP      R2,#+0
        MOVNE    R2,#+1
        CMP      R8,#+0
        MOVNE    R3,#+1
        MOVEQ    R3,#+0
        AND      R0,R1,R0
        AND      R0,R2,R0
        TST      R3,R0
// 5148            /*
// 5149             * Always Use full Phase Disp.
// 5150             * if error in bg noise
// 5151             */
// 5152          st->ph_disp_st->lockFull = 1;
        LDRNE    R0,[R4, #+212]
// 5153       }
// 5154 
// 5155         /*
// 5156          * apply phase dispersion to innovation (if enabled) and
// 5157          * compute total excitation for synthesis part
// 5158          */
// 5159       ph_disp( st->ph_disp_st, mode, exc_enhanced, gain_code_mix, gain_pit, code
// 5160             , pitch_fac, tmp_shift );
        MOV      R1,R6
        STRHNE   R9,[R0, #+28]
        PUSH     {R11}
        CFI CFA R13+816
        LDR      R0,[SP, #+28]
        PUSH     {R0}
        CFI CFA R13+820
        ADD      R0,SP,#+72
        PUSH     {R0}
        CFI CFA R13+824
        LDR      R0,[SP, #+12]
        PUSH     {R0}
        CFI CFA R13+828
        LDR      R3,[SP, #+20]
        LDR      R0,[R4, #+212]
        ADD      R2,SP,#+520
        BL       ph_disp
// 5161 
// 5162         /*
// 5163          * The Excitation control module are active during BFI.
// 5164          * Conceal drops in signal energy if in bg noise.
// 5165          */
// 5166       temp2 = 0;
        MOV      R1,#+0
// 5167 
// 5168       for ( i = 0; i < L_SUBFR; i++ ) {
        MOV      R0,R1
        ADD      SP,SP,#+16
        CFI CFA R13+812
// 5169          temp2 += ( exc_enhanced[i] * exc_enhanced[i] );
??Decoder_amr_71:
        ADD      R2,SP,#+504
        LDR      R2,[R2, +R0, LSL #+2]
// 5170       }
        ADD      R0,R0,#+1
        MLA      R1,R2,R2,R1
        CMP      R0,#+40
        BLT      ??Decoder_amr_71
// 5171 
// 5172       if ( temp2 > 0x3FFFFFFF ) {
        CMP      R1,#+1073741824
// 5173          excEnergy = 11584;
        MOVGE    R11,#+11584
        BGE      ??Decoder_amr_72
// 5174       }
// 5175       else {
// 5176          temp2 = sqrt_l_exp( temp2, &temp );
        CMP      R1,#+1
        MOV      R0,#+0
        MOVLT    R1,#+0
        BLT      ??Decoder_amr_73
        MOV      R2,R1
        TST      R2,#0x40000000
        BNE      ??Decoder_amr_74
??Decoder_amr_75:
        ADD      R0,R0,#+1
        LSL      R2,R2,#+1
        TST      R2,#0x40000000
        BEQ      ??Decoder_amr_75
??Decoder_amr_74:
        LDR      R3,??Decoder_amr_22+0x4  ;; sqrt_table
        MOV      R2,#+254
        ORR      R2,R2,#0xFF00
        AND      R2,R2,R0
        MOV      R0,R2, LSL #+16
        LSL      R1,R1,R2
        ASR      R1,R1,#+9
        ASR      R2,R1,#+16
        SUB      R2,R2,#+16
        ADD      R3,R3,R2, LSL #+2
        LDR      R11,[R3, #+0]
        LDR      R3,[R3, #+4]
        ASR      R1,R1,#+1
        SUB      R3,R11,R3
        LSL      R1,R1,#+17
        LSR      R1,R1,#+17
        MUL      R3,R1,R3
        MOV      R0,R0, ASR #+16
        LSL      R2,R11,#+16
        SUB      R1,R2,R3, LSL #+1
// 5177          temp2 = ( temp2 >> ( ( temp >> 1 ) + 15 ) );
// 5178          excEnergy = temp2 >> 2;
??Decoder_amr_73:
        MOV      R2,#+15
        ADD      R0,R2,R0, ASR #+1
        ASR      R0,R1,R0
        ASR      R11,R0,#+2
// 5179       }
// 5180 
// 5181       if ( ( ( mode == MR475 ) || ( mode == MR515 ) || ( mode == MR59 ) ) & ( st
// 5182             ->voicedHangover > 5 ) & ( st->inBackgroundNoise != 0 ) & ( st->
// 5183             state < 4 ) & ( ( ( pdfi != 0 ) & ( st->prev_pdf != 0 ) ) || bfi !=
// 5184             0 || st->prev_bf != 0 ) ) {
??Decoder_amr_72:
        LDRSH    R3,[R4, #+180]
        LDR      R1,[R4, #+100]
        LDR      R2,[R4, #+96]
        LDR      R12,[SP, #+36]
        CMP      R6,#+0
        CMPNE    R6,#+1
        CMPNE    R6,#+2
        MOVEQ    R0,#+1
        MOVNE    R0,#+0
        CMP      R1,#+6
        MOVGE    R1,#+1
        MOVLT    R1,#+0
        CMP      R2,#+0
        MOVNE    R2,#+1
        CMP      R3,#+4
        MOVLT    R3,#+1
        MOVGE    R3,#+0
        CMP      R12,#+0
        LDRSHNE  R12,[R4, #+178]
        AND      R0,R1,R0
        AND      R0,R2,R0
        CMPNE    R12,#+0
        CMPEQ    R8,#+0
        LDRSHEQ  R12,[R4, #+176]
        AND      R0,R3,R0
        CMPEQ    R12,#+0
        MOVNE    R12,#+1
        TST      R12,R0
        BEQ      ??Decoder_amr_76
// 5185          carefulFlag = 0;
// 5186 
// 5187          if ( ( pdfi != 0 ) & ( bfi == 0 ) ) {
        LDR      R1,[SP, #+36]
        MOV      R0,#+0
        CMP      R1,#+0
        BEQ      ??Decoder_amr_77
        CMP      R8,#+0
// 5188             carefulFlag = 1;
        MOVEQ    R0,#+1
// 5189          }
// 5190          Ex_ctrl( exc_enhanced, excEnergy, st->excEnergyHist, st->voicedHangover
// 5191                , st->prev_bf, carefulFlag );
??Decoder_amr_77:
        PUSH     {R0}
        CFI CFA R13+816
        LDRSH    R0,[R4, #+176]
        ADD      R2,R5,#+916
        MOV      R1,R11
        PUSH     {R0}
        CFI CFA R13+820
        LDR      R3,[R4, #+100]
        ADD      R0,SP,#+512
        BL       Ex_ctrl
        ADD      SP,SP,#+8
        CFI CFA R13+812
// 5192       }
// 5193 
// 5194       if ( ( st->inBackgroundNoise != 0 ) & ( bfi != 0 || st->prev_bf != 0 ) & (
// 5195             st->state < 4 ) ) {;   /* do nothing! */
??Decoder_amr_76:
        LDR      R0,[R4, #+96]
        LDRSH    R2,[R4, #+180]
        CMP      R0,#+0
        MOVNE    R0,#+1
        CMP      R8,#+0
        LDRSHEQ  R1,[R4, #+176]
        CMPEQ    R1,#+0
        MOVNE    R1,#+1
        CMP      R2,#+4
        MOVLT    R2,#+1
        MOVGE    R2,#+0
        AND      R0,R1,R0
        TST      R2,R0
        BNE      ??Decoder_amr_78
// 5196       }
// 5197       else {
// 5198          /* Update energy history for all modes */
// 5199          for (i = 0; i < 8; i++){
        MOV      R0,#+0
// 5200             st->excEnergyHist[i] = st->excEnergyHist[i+1];
??Decoder_amr_79:
        ADD      R1,R0,#+1
        ADD      R2,R5,R1, LSL #+2
        LDR      R2,[R2, #+916]
        ADD      R0,R5,R0, LSL #+2
        STR      R2,[R0, #+916]
// 5201          }
        MOV      R0,R1
        CMP      R0,#+8
        BLT      ??Decoder_amr_79
// 5202          st->excEnergyHist[8] = excEnergy;
        STR      R11,[R4, #+172]
// 5203       }
// 5204 
// 5205         /*
// 5206          * Excitation control module end.
// 5207          */
// 5208       if ( pit_sharp > 16384 ) {
??Decoder_amr_78:
        LDR      R0,[SP, #+20]
        LDR      R1,[SP, #+812]
        ADD      R11,R1,R0, LSL #+2
        LDR      R0,[SP, #+40]
        ORR      R1,R9,#0x4000
        CMP      R0,R1
        MOV      R0,#+0
        BLT      ??Decoder_amr_80
// 5209          for ( i = 0; i < L_SUBFR; i++ ) {
// 5210             excp[i] = excp[i] + exc_enhanced[i];
??Decoder_amr_81:
        ADD      R1,R1,R0, LSL #+2
        LDR      R2,[R1, #+0]
        ADD      R3,SP,#+504
        LDR      R3,[R3, +R0, LSL #+2]
        ADDS     R2,R3,R2
        STR      R2,[R1, #+0]
// 5211             if (labs(excp[i]) > 32767)
        MOV      R3,R2
        RSBMI    R3,R3,#+0
        CMP      R3,#+32768
        BLT      ??Decoder_amr_82
// 5212                excp[i] = (excp[i] & 0x80000000) ? -32768 : 32767;
        TST      R2,#0x80000000
        MVNNE    R2,#+255
        BICNE    R2,R2,#0x7F00
        MOVEQ    R2,#+255
        ORREQ    R2,R2,#0x7F00
        STR      R2,[R1, #+0]
// 5213          }
??Decoder_amr_82:
        ADD      R0,R0,#+1
        CMP      R0,#+40
        ADD      R1,SP,#+344
        BLT      ??Decoder_amr_81
// 5214          agc2( exc_enhanced, excp );
        ADD      R0,SP,#+504
        BL       agc2
// 5215          overflow = Syn_filt( Az, excp, &synth[i_subfr], L_SUBFR, st->mem_syn, 0
// 5216             );
        MOV      R0,#+0
        PUSH     {R0}
        CFI CFA R13+816
        MOV      R3,#+40
        MOV      R2,R11
        ADD      R0,R5,#+820
        PUSH     {R0}
        CFI CFA R13+820
        ADD      R1,SP,#+352
        B        ??Decoder_amr_83
        CFI CFA R13+812
// 5217       }
// 5218       else {
// 5219          overflow = Syn_filt( Az, exc_enhanced, &synth[i_subfr], L_SUBFR, st->
// 5220             mem_syn, 0 );
??Decoder_amr_80:
        PUSH     {R0}
        CFI CFA R13+816
        MOV      R3,#+40
        MOV      R2,R11
        ADD      R0,R5,#+820
        PUSH     {R0}
        CFI CFA R13+820
        ADD      R1,SP,#+512
??Decoder_amr_83:
        LDR      R0,[SP, #+40]
        BL       Syn_filt
        ADD      SP,SP,#+8
        CFI CFA R13+812
// 5221       }
// 5222 
// 5223       if ( overflow ) {
        CMP      R0,#+0
        BEQ      ??Decoder_amr_84
// 5224          for ( i = 0; i < PIT_MAX + L_INTERPOL + L_SUBFR; i++ ) {
        MOV      R0,#+0
// 5225             st->old_exc[i] = st->old_exc[i] >> 2;
??Decoder_amr_85:
        ADD      R1,R5,R0, LSL #+2
        LDR      R2,[R1, #+0]
// 5226          }
        ADD      R0,R0,#+1
        ASR      R2,R2,#+2
        STR      R2,[R1, #+0]
        CMP      R0,#+194
        BLT      ??Decoder_amr_85
// 5227 
// 5228          for ( i = 0; i < L_SUBFR; i++ ) {
        MOV      R0,#+0
// 5229             exc_enhanced[i] = exc_enhanced[i] >> 2;
??Decoder_amr_86:
        ADD      R1,SP,#+504
        ADD      R1,R1,R0, LSL #+2
        LDR      R2,[R1, #+0]
// 5230          }
        ADD      R0,R0,#+1
        ASR      R2,R2,#+2
        STR      R2,[R1, #+0]
        CMP      R0,#+40
        BLT      ??Decoder_amr_86
// 5231          Syn_filt_overflow( Az, exc_enhanced, &synth[i_subfr], L_SUBFR, st->mem_syn, 1 );
        MOV      R0,#+1
        PUSH     {R0}
        CFI CFA R13+816
        MOV      R3,#+40
        MOV      R2,R11
        ADD      R0,R5,#+820
        PUSH     {R0}
        CFI CFA R13+820
        LDR      R0,[SP, #+40]
        ADD      R1,SP,#+512
        BL       Syn_filt_overflow
        ADD      SP,SP,#+8
        CFI CFA R13+812
        B        ??Decoder_amr_87
// 5232       }
// 5233       else {
// 5234          memcpy( st->mem_syn, &synth[i_subfr + 30], 40 );
??Decoder_amr_84:
        MOV      R2,#+40
        ADD      R1,R11,#+120
        ADD      R0,R5,#+820
        SWI      +286
// 5235       }
// 5236 
// 5237         /*
// 5238          * Update signal for next frame.
// 5239          * -> shift to the left by L_SUBFR  st->exc[]
// 5240          */
// 5241       memcpy( &st->old_exc[0], &st->old_exc[L_SUBFR], ( PIT_MAX + L_INTERPOL )<<
// 5242             2 );
??Decoder_amr_87:
        MOV      R2,#+616
        ADD      R1,R5,#+160
        MOV      R0,R5
        SWI      +286
// 5243 
// 5244       /* interpolated LPC parameters for next subframe */
// 5245       Az += MP1;
        LDR      R1,[SP, #+32]
        ADD      R1,R1,#+44
        STR      R1,[SP, #+32]
// 5246 
// 5247       /* store T0 for next subframe */
// 5248       st->old_T0 = T0;
        LDR      R0,[SP, #+8]
        STR      R0,[R4, #+88]
// 5249    }
        LDR      R1,[SP, #+20]
        ADD      R1,R1,#+40
        STR      R1,[SP, #+20]
        CMP      R1,#+160
        BLT      ??Decoder_amr_14
// 5250 
// 5251     /*
// 5252      * Call the Source Characteristic Detector which updates
// 5253      * st->inBackgroundNoise and st->voicedHangover.
// 5254      */
// 5255    st->inBackgroundNoise = Bgn_scd( st->background_state, &( st->ltpGainHistory[
// 5256          0] ), &( synth[0] ), &( st->voicedHangover ) );
        LDR      R0,[R4, #+184]
        LDR      R2,[SP, #+812]
        ADD      R3,R5,#+876
        ADD      R1,R5,#+880
        BL       Bgn_scd
        STR      R0,[R4, #+96]
// 5257    dtx_dec_activity_update( st->dtxDecoderState, st->lsfState->past_lsf_q, synth
// 5258          );
        LDR      R0,[R4, #+196]
        LDR      R2,[SP, #+812]
        ADD      R1,R0,#+40
        LDR      R0,[R4, #+216]
        BL       dtx_dec_activity_update
// 5259 
// 5260    /* store bfi for next subframe */
// 5261    st->prev_bf = bfi;
        STRH     R8,[R4, #+176]
// 5262    st->prev_pdf = pdfi;
        LDR      R0,[SP, #+36]
// 5263 
// 5264     /*
// 5265      * Calculate the LSF averages on the eight
// 5266      * previous frames
// 5267      */
// 5268    lsp_avg( st->lsp_avg_st, st->lsfState->past_lsf_q );
        MOV      R2,#+0
        STRH     R0,[R4, #+178]
        LDR      R0,[R4, #+196]
        LDR      R1,[R4, #+192]
        ADD      R0,R0,#+40
??Decoder_amr_88:
        LDR      R7,[R0, +R2, LSL #+2]
        ADD      R3,R1,R2, LSL #+2
        LDR      R6,[R3, #+0]
        LDR      R5,[R3, #+0]
        SUB      R6,R6,R7
        MOV      R7,#+123
        ORR      R7,R7,#0x1400
        MUL      R6,R7,R6
        LSL      R5,R5,#+16
        SUB      R5,R5,R6, LSL #+1
        ADD      R5,R5,#+32768
        ASR      R5,R5,#+16
        STR      R5,[R3, #+0]
        ADD      R2,R2,#+1
        CMP      R2,#+10
        BLT      ??Decoder_amr_88
// 5269 theEnd:
// 5270    st->dtxDecoderState->dtxGlobalState = newDTXState;
??Decoder_amr_2:
        LDR      R0,[R4, #+216]
        LDR      R1,[SP, #+56]
        STRB     R1,[R0, #+0]
// 5271    return;
        ADD      SP,SP,#+776
        CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        DATA
??Decoder_amr_22:
        DC32     0x2aaaaaab
        DC32     sqrt_table
        CFI EndBlock cfiBlock77
// 5272 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock78 Using cfiCommon0
        CFI NoFunction
        THUMB
??Residu40??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock78
        REQUIRE Residu40
// 5273 
// 5274 
// 5275 /*
// 5276  * Residu40
// 5277  *
// 5278  *
// 5279  * Parameters:
// 5280  *    a                 I: prediction coefficients
// 5281  *    x                 I: speech signal
// 5282  *    y                 O: residual signal
// 5283  *
// 5284  * Function:
// 5285  *    The LP residual is computed by filtering the input
// 5286  *    speech through the LP inverse filter a(z)
// 5287  *
// 5288  * Returns:
// 5289  *    void
// 5290  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock79 Using cfiCommon1
        CFI Function Residu40
        ARM
// 5291 static void Residu40( Word32 a[], Word32 x[], Word32 y[] )
// 5292 {
Residu40:
        PUSH     {R4-R7}
        CFI R7 Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
// 5293    Word32 s, i, j;
// 5294 
// 5295 
// 5296    for ( i = 0; i < 40; i++ ) {
        MOV      R3,#+0
// 5297       s = a[0] * x[i] + a[1] * x[i - 1] + a[2] * x[i - 2] + a[3] * x[i - 3];
// 5298       s += a[4] * x[i - 4] + a[5] * x[i - 5] + a[6] * x[i - 6] + a[7] * x[i - 7]
// 5299          ;
// 5300       s += a[8] * x[i - 8] + a[9] * x[i - 9] + a[10] * x[i - 10];
// 5301       y[i] = ( s + 0x800 ) >> 12;
??Residu40_0:
        LDR      R6,[R0, #+0]
        LDR      R7,[R1, +R3, LSL #+2]
        ADD      R4,R1,R3, LSL #+2
        SUB      R12,R4,#+40
        LDR      R4,[R0, #+40]
        LDR      R5,[R12, #+0]
        MUL      R6,R7,R6
        MLA      R4,R5,R4,R6
        LDR      R5,[R0, #+4]
        LDR      R6,[R12, #+36]
        MLA      R4,R6,R5,R4
        LDR      R5,[R0, #+8]
        LDR      R6,[R12, #+32]
        MLA      R4,R6,R5,R4
        LDR      R5,[R0, #+12]
        LDR      R6,[R12, #+28]
        MLA      R4,R6,R5,R4
        LDR      R5,[R0, #+16]
        LDR      R6,[R12, #+24]
        MLA      R4,R6,R5,R4
        LDR      R5,[R0, #+20]
        LDR      R6,[R12, #+20]
        MLA      R4,R6,R5,R4
        LDR      R5,[R0, #+24]
        LDR      R6,[R12, #+16]
        MLA      R4,R6,R5,R4
        LDR      R5,[R0, #+28]
        LDR      R6,[R12, #+12]
        MLA      R4,R6,R5,R4
        LDR      R5,[R0, #+32]
        LDR      R6,[R12, #+8]
        MLA      R4,R6,R5,R4
        LDR      R5,[R0, #+36]
        LDR      R6,[R12, #+4]
        MLA      R4,R6,R5,R4
        ADD      R4,R4,#+2048
        ASR      R4,R4,#+12
        STR      R4,[R2, +R3, LSL #+2]
// 5302       if (abs(y[i]) > 32767){
        CMP      R4,#+0
        RSBMI    R12,R4,#+0
        MOVPL    R12,R4
        CMP      R12,#+32768
        BLT      ??Residu40_1
// 5303          /* go to safe mode */
// 5304          for (i = 0; i < 40; i++) {
        MOV      R3,#+0
        B        ??Residu40_2
// 5305             s = a[0] * x[i];
// 5306             for (j = 1; j <= 10; j++) {
// 5307                s += a[j] * x[i - j];
// 5308                if (s > 1073741823){
// 5309                   s = 1073741823;
// 5310                }
// 5311                else if ( s < -1073741824) {
// 5312                   s = -1073741824;
// 5313                }
// 5314             }
// 5315             y[i] = ( s + 0x800 ) >> 12;
// 5316             if (abs(y[i]) > 32767)
// 5317                y[i] = (y[i] & 0x80000000) ? -32768 : 32767;
??Residu40_3:
        STR      R12,[R2, +R3, LSL #+2]
??Residu40_4:
        ADD      R3,R3,#+1
        CMP      R3,#+40
        BGE      ??Residu40_5
??Residu40_2:
        LDR      R4,[R0, #+0]
        LDR      R5,[R1, +R3, LSL #+2]
        MUL      R12,R5,R4
        MOV      R4,#+1
??Residu40_6:
        LDR      R5,[R0, +R4, LSL #+2]
        SUB      R6,R3,R4
        LDR      R6,[R1, +R6, LSL #+2]
        ADD      R4,R4,#+1
        MLA      R12,R6,R5,R12
        MOVS     R5,R12, ASR #+30
        MVNSNE   R5,R5
        MVNNE    R5,#+0
        MOVNE    R12,R5, LSL #+30
        MVNMI    R12,R12
        CMP      R4,#+11
        BLT      ??Residu40_6
        ADD      R4,R12,#+2048
        ASR      R4,R4,#+12
        STR      R4,[R2, +R3, LSL #+2]
        CMP      R4,#+0
        RSBMI    R4,R4,#+0
        CMP      R4,#+32768
        BLT      ??Residu40_4
        LDR      R4,[R2, +R3, LSL #+2]
        TST      R4,#0x80000000
        MOVEQ    R12,#+255
        ORREQ    R12,R12,#0x7F00
        MVNNE    R12,#+255
        BICNE    R12,R12,#0x7F00
        B        ??Residu40_3
// 5318          }
// 5319          return;
// 5320       }
// 5321 
// 5322    }
??Residu40_1:
        ADD      R3,R3,#+1
        CMP      R3,#+40
        BLT      ??Residu40_0
??Residu40_5:
        POP      {R4-R7}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock79
// 5323    return;
// 5324 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock80 Using cfiCommon0
        CFI NoFunction
        THUMB
??agc??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock80
        REQUIRE agc
// 5325 
// 5326 
// 5327 /*
// 5328  * agc
// 5329  *
// 5330  *
// 5331  * Parameters:
// 5332  *    st->past_gain     B: gain memory
// 5333  *    sig_in            I: Post_Filter input signal
// 5334  *    sig_out           B: Post_Filter output signal
// 5335  *    agc_fac           I: AGC factor
// 5336  *
// 5337  * Function:
// 5338  *    Scales the Post_Filter output on a subframe basis
// 5339  *
// 5340  * Returns:
// 5341  *    void
// 5342  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock81 Using cfiCommon1
        CFI Function agc
        ARM
// 5343 static void agc( agcState *st, Word32 *sig_in, Word32 *sig_out, Word16 agc_fac )
// 5344 {
agc:
        PUSH     {R4-R10,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R10 Frame(CFA, -8)
        CFI R9 Frame(CFA, -12)
        CFI R8 Frame(CFA, -16)
        CFI R7 Frame(CFA, -20)
        CFI R6 Frame(CFA, -24)
        CFI R5 Frame(CFA, -28)
        CFI R4 Frame(CFA, -32)
        CFI CFA R13+32
        MOV      R6,R0
        MOV      R7,R2
        MOV      R10,R1
        MOV      R4,R3
// 5345    Word32 s, gain_in, gain_out, g0, gain;
// 5346    int exp, i;
// 5347 
// 5348 
// 5349    /* calculate gain_out with exponent */
// 5350    s = energy_new( sig_out );
        MOV      R0,R7
        BL       energy_new
// 5351 
// 5352    if ( s == 0 ) {
        MOV      R5,#+0
        CMP      R0,#+0
// 5353       st->past_gain = 0;
        STREQ    R5,[R6, #+0]
// 5354       return;
        POPEQ    {R4-R10,PC}
// 5355    }
// 5356    exp=0;
        MOV      R1,#+0
// 5357    i = s;
        MOV      R3,R0
        TST      R3,#0x40000000
        BNE      ??agc_0
// 5358    while (!(i & 0x40000000))
// 5359    {
// 5360       exp++;
??agc_1:
        ADD      R1,R1,#+1
// 5361       i = i << 1;
        LSL      R3,R3,#+1
// 5362    }
        TST      R3,#0x40000000
        BEQ      ??agc_1
// 5363    exp -=1;
??agc_0:
        SUB      R8,R1,#+1
// 5364    if (exp & 0x80000000) {
        TST      R8,#0x80000000
// 5365       s >>= 1;
        ASRNE    R0,R0,#+1
// 5366    }
// 5367    else {
// 5368       s <<= exp;
        LSLEQ    R0,R0,R8
// 5369    }
// 5370    gain_out = ( s + 0x00008000L ) >> 16;
        ADD      R0,R0,#+32768
        ASR      R9,R0,#+16
// 5371 
// 5372    /* calculate gain_in with exponent */
// 5373    s = energy_new( sig_in );
        MOV      R0,R10
        BL       energy_new
// 5374 
// 5375    if ( s == 0 ) {
        MOV      R2,#+255
        ORR      R2,R2,#0x7F00
        CMP      R0,#+0
        BEQ      ??agc_2
// 5376       g0 = 0;
// 5377    }
// 5378    else {
// 5379       i=0;
        MOV      R3,#+0
        TST      R0,#0x40000000
        BNE      ??agc_3
// 5380    while (!(s & 0x40000000))
// 5381    {
// 5382       i++;
??agc_4:
        ADD      R3,R3,#+1
// 5383       s = s << 1;
        LSL      R0,R0,#+1
// 5384    }
        TST      R0,#0x40000000
        BEQ      ??agc_4
// 5385       s = s + 0x00008000L;
??agc_3:
        ADDS     R0,R0,#+32768
// 5386 
// 5387       if ( s >= 0 )
// 5388          gain_in = s >> 16;
        ASRPL    R1,R0,#+16
// 5389       else
// 5390          gain_in = 32767;
        MOVMI    R1,R2
// 5391       exp = ( exp - i );
// 5392 
// 5393       /*
// 5394        * g0 = (1-agc_fac) * sqrt(gain_in/gain_out);
// 5395        */
// 5396       /* s = gain_out / gain_in */
// 5397       s = ( gain_out << 15 ) / gain_in;
        LSL      R0,R9,#+15
        _BLF     ??div32_a,??rA??div32_a
// 5398       exp = 7 - exp;
        RSB      R0,R8,#+7
        ADD      R8,R3,R0
// 5399 
// 5400       if ( exp > 0 ){
        CMP      R8,#+1
        BLT      ??agc_5
// 5401          if (exp > 31)
        CMP      R8,#+32
        BLT      ??agc_6
// 5402          {
// 5403             if(s){
        CMP      R1,#+0
        BEQ      ??agc_7
// 5404                s = 2147483647;
        B        ??agc_8
// 5405             }
// 5406          }
// 5407          else {
// 5408             s = s << exp ;
??agc_6:
        LSL      R1,R1,R8
        B        ??agc_7
// 5409          }
// 5410       }
// 5411       else
// 5412          s = ( s >> ( -exp ) );
??agc_5:
        RSB      R0,R8,#+0
        ASR      R1,R1,R0
// 5413       if (s < 0)
??agc_7:
        CMP      R1,#+0
        BPL      ??agc_9
// 5414          s = 2147483647;
??agc_8:
        MVN      R1,#-2147483648
// 5415       s = Inv_sqrt( s );
??agc_9:
        CMP      R1,#+1
        MVNLT    R0,#-1073741824
        BLT      ??agc_10
        MOV      R0,#+0
        TST      R1,#0x40000000
        BNE      ??agc_11
??agc_12:
        ADD      R0,R0,#+1
        LSL      R1,R1,#+1
        TST      R1,#0x40000000
        BEQ      ??agc_12
??agc_11:
        LDR      R9,??DataTable5  ;; inv_sqrt_table
        RSB      R0,R0,#+30
        TST      R0,#0x1
        ASREQ    R1,R1,#+1
        ASR      R1,R1,#+9
        ASR      R3,R1,#+16
        SUB      R8,R3,#+16
        LDR      R10,[R9, +R8, LSL #+2]
        ADD      R8,R9,R8, LSL #+2
        LDR      R8,[R8, #+4]
        AND      R1,R2,R1, ASR #+1
        SUB      R8,R10,R8
        MUL      R8,R1,R8
        LSL      R3,R10,#+16
        SUB      R1,R3,R8, LSL #+1
        MOV      R3,#+1
        ADD      R0,R3,R0, ASR #+1
        ASR      R0,R1,R0
// 5416       i = ( ( s << 9 ) + 0x00008000L ) >> 16;
??agc_10:
        MOV      R1,#+32768
        ADD      R0,R1,R0, LSL #+9
        ASR      R3,R0,#+16
// 5417       if (i & 0xFFFF8000)
        LSR      R0,R3,#+15
        LSLS     R0,R0,#+15
// 5418          i = 32767;
        MOVNE    R3,R2
// 5419 
// 5420       /* g0 = i * (1-agc_fac) */
// 5421       g0 = ( i * ( 32767 - agc_fac ) ) >> 15;
        SUB      R0,R2,R4
        MUL      R1,R0,R3
        ASR      R0,R1,#+15
// 5422    }
// 5423 
// 5424    /*
// 5425     * compute gain[n] = agc_fac * gain[n-1] + (1-agc_fac) * sqrt(gain_in/gain_out)
// 5426     * sig_out[n] = gain[n] * sig_out[n]
// 5427     */
// 5428    gain = st->past_gain;
??agc_2:
        LDR      R1,[R6, #+0]
// 5429 
// 5430    for ( i = 0; i < L_SUBFR; i++ ) {
// 5431       gain = ( gain * agc_fac ) >> 15;
// 5432       gain = gain + g0;
// 5433       sig_out[i] = ( sig_out[i] * gain ) >> 12;
??agc_13:
        LDR      R3,[R7, +R5, LSL #+2]
        MUL      R1,R4,R1
        ADD      R1,R0,R1, ASR #+15
        MUL      R3,R1,R3
        ASR      R3,R3,#+12
        STR      R3,[R7, +R5, LSL #+2]
// 5434       if (labs(sig_out[i]) > 32767)
        CMP      R3,#+0
        RSBMI    R3,R3,#+0
        CMP      R3,#+32768
        BLT      ??agc_14
// 5435          sig_out[i] = (sig_out[i] & 0x8000000) ? -32768 : 32767;
        LDR      R3,[R7, +R5, LSL #+2]
        TST      R3,#0x8000000
        MVNNE    R3,R2
        MOVEQ    R3,R2
        STR      R3,[R7, +R5, LSL #+2]
// 5436    }
??agc_14:
        ADD      R5,R5,#+1
        CMP      R5,#+40
        BLT      ??agc_13
// 5437    st->past_gain = gain;
        STR      R1,[R6, #+0]
// 5438    return;
        POP      {R4-R10,PC}      ;; return
        CFI EndBlock cfiBlock81
// 5439 }

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable5:
        DC32     inv_sqrt_table

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock82 Using cfiCommon0
        CFI NoFunction
        THUMB
??Post_Filter??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock82
        REQUIRE Post_Filter
// 5440 
// 5441 
// 5442 /*
// 5443  * Post_Filter
// 5444  *
// 5445  *
// 5446  * Parameters:
// 5447  *    st                B: post filter states
// 5448  *    mode              I: AMR mode
// 5449  *    syn               B: synthesis speech
// 5450  *    Az_4              I: interpolated LPC parameters in all subfr.
// 5451  *
// 5452  * Function:
// 5453  *    Post_Filtering of synthesis speech.
// 5454  *
// 5455  *    inverse filtering of syn[] through A(z/0.7) to get res2[]
// 5456  *    tilt compensation filtering; 1 - MU*k*z^-1
// 5457  *    synthesis filtering through 1/A(z/0.75)
// 5458  *    adaptive gain control
// 5459  *
// 5460  * Returns:
// 5461  *    void
// 5462  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock83 Using cfiCommon1
        CFI Function Post_Filter
        ARM
// 5463 static void Post_Filter( Post_FilterState *st, enum Mode mode, Word32 *syn,
// 5464       Word32 *Az_4 )
// 5465 {
Post_Filter:
        PUSH     {R2,R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+40
// 5466    Word32 h[22], Ap3[MP1], Ap4[MP1];   /* bandwidth expanded LP parameters */
// 5467    Word32 tmp, i_subfr, i, temp1, temp2, overflow = 0;
// 5468    Word32 *Az, *p1, *p2, *syn_work = &st->synth_buf[M];
// 5469    const Word32 *pgamma3 = &gamma3[0];
        LDR      R9,??Post_Filter_0  ;; gamma4_gamma3_MR122
        SUB      SP,SP,#+184
        CFI CFA R13+224
        MOV      R4,R0
        MOV      R8,R1
        MOV      R5,R3
        ADD      R1,R4,#+240
        STR      R1,[SP, #+0]
// 5470    const Word32 *pgamma4 = &gamma4_gamma3_MR122[0];
// 5471 
// 5472 
// 5473    /*
// 5474     * Post filtering
// 5475     */
// 5476    memcpy( syn_work, syn, L_FRAME <<2 );
        LDR      R1,[SP, #+184]
        LDR      R0,[SP, #+0]
        ADD      R6,R9,#+40
        MOV      R7,R9
        MOV      R2,#+640
        SWI      +286
// 5477    Az = Az_4;
// 5478 
// 5479    if ( ( mode == MR122 ) || ( mode == MR102 ) ) {
        CMP      R8,#+7
        CMPNE    R8,#+6
// 5480       pgamma3 = &gamma4_gamma3_MR122[0];
        MOVEQ    R6,R9
// 5481       pgamma4 = &gamma4_MR122[0];
        ADDEQ    R7,R9,#+80
// 5482    }
// 5483 
// 5484    for ( i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR ) {
        MOV      R8,#+0
// 5485       /* Find weighted filter coefficients Ap3[] and Ap[4] */
// 5486       Ap3[0] = Az[0];
??Post_Filter_1:
        LDR      R1,[R5, #+0]
// 5487       Ap4[0] = Az[0];
// 5488 
// 5489       for ( i = 1; i <= 10; i++ ) {
        MOV      R0,#+1
        STR      R1,[SP, #+140]
        LDR      R1,[R5, #+0]
        STR      R1,[SP, #+8]
// 5490          Ap3[i] = ( Az[i] * pgamma3[i - 1] +0x4000 ) >> 15;
??Post_Filter_2:
        ADD      R1,R5,R0, LSL #+2
        LDR      R3,[R1, #+0]
        ADD      R9,R6,R0, LSL #+2
        LDR      R9,[R9, #-4]
        ADD      R2,SP,#+140
        MUL      R3,R9,R3
        ADD      R3,R3,#+16384
        ASR      R3,R3,#+15
        STR      R3,[R2, +R0, LSL #+2]
// 5491          Ap4[i] = ( Az[i] * pgamma4[i - 1] +0x4000 ) >> 15;
        LDR      R1,[R1, #+0]
        ADD      R3,R7,R0, LSL #+2
        LDR      R3,[R3, #-4]
        ADD      R2,SP,#+8
        MUL      R1,R3,R1
        ADD      R1,R1,#+16384
        ASR      R1,R1,#+15
        STR      R1,[R2, +R0, LSL #+2]
// 5492       }
        ADD      R0,R0,#+1
        CMP      R0,#+11
        BLT      ??Post_Filter_2
// 5493 
// 5494       /* filtering of synthesis speech by A(z/0.7) to find res2[] */
// 5495       Residu40( Ap3, &syn_work[i_subfr], st->res2 );
        LDR      R0,[SP, #+0]
        MOV      R2,R4
        ADD      R9,R0,R8, LSL #+2
        MOV      R1,R9
        ADD      R0,SP,#+140
        BL       Residu40
// 5496 
// 5497       /* tilt compensation filter */
// 5498       /* impulse response of A(z/0.7)/A(z/0.75) */
// 5499       memcpy( h, Ap3, MP1 <<2 );
        MOV      R2,#+44
        ADD      R1,SP,#+140
        ADD      R0,SP,#+52
        SWI      +286
// 5500       memset( &h[M +1], 0, ( 22 - M - 1 )<<2 );
        MOV      R2,#+44
        MOV      R1,#+0
        ADD      R0,SP,#+96
        SWI      +187
// 5501       Syn_filt( Ap4, h, h, 22, &h[M +1], 0 );
        MOV      R0,#+0
        PUSH     {R0}
        CFI CFA R13+228
        MOV      R3,#+22
        ADD      R0,SP,#+100
        PUSH     {R0}
        CFI CFA R13+232
        ADD      R2,SP,#+60
        ADD      R1,SP,#+60
        ADD      R0,SP,#+16
        BL       Syn_filt
// 5502 
// 5503       /* 1st correlation of h[] */
// 5504       tmp = 16777216 + h[1] * h[1];
        LDR      R3,[SP, #+64]
// 5505 
// 5506       for ( i = 2; i < 22; i++ ) {
        MOV      R1,#+2
        MUL      R0,R3,R3
        ADD      SP,SP,#+8
        CFI CFA R13+224
        ADD      R0,R0,#+16777216
// 5507          tmp += h[i] * h[i];
??Post_Filter_3:
        ADD      R2,SP,#+52
        LDR      R2,[R2, +R1, LSL #+2]
        MLA      R0,R2,R2,R0
// 5508          if (tmp > 0x3FFF8000)
        LDR      R2,??Post_Filter_0+0x4  ;; 0x3fff8001
        CMP      R0,R2
// 5509             break;
// 5510       }
        ADDLT    R1,R1,#+1
        CMPLT    R1,#+22
        BLT      ??Post_Filter_3
// 5511       temp1 = tmp >> 15;
// 5512       if (temp1 & 0xFFFF8000)
// 5513          temp1 = 32767;
// 5514 
// 5515       tmp = h[0] * h[1];
        LDR      R10,[SP, #+52]
        ASR      R1,R0,#+15
        MVN      R0,#+255
        BIC      R0,R0,#0x7F00
        MVN      R2,R0
        TST      R0,R1
        MOVNE    R1,R2
        MUL      R12,R3,R10
// 5516 
// 5517       for ( i = 1; i < 21; i++ ) {
        MOV      R3,#+1
// 5518          tmp += h[i] * h[i + 1];
??Post_Filter_4:
        ADD      R10,SP,#+52
        ADD      R10,R10,R3, LSL #+2
        LDR      LR,[R10, #+0]
        LDR      R10,[R10, #+4]
// 5519          if (abs(tmp) > 1073741823)
// 5520             tmp = 1073741823;
// 5521       }
        ADD      R3,R3,#+1
        MLA      R12,R10,LR,R12
        CMP      R12,#+0
        MOV      R10,R12
        RSBMI    R10,R10,#+0
        CMP      R10,#+1073741824
        MVNGE    R12,#-1073741824
        CMP      R3,#+21
        BLT      ??Post_Filter_4
// 5522       temp2 = tmp >> 15;
        ASR      R3,R12,#+15
// 5523 
// 5524       if ( temp2 <= 0 ) {
        CMP      R3,#+1
// 5525          temp2 = 0;
        MOVLT    R1,#+0
        BLT      ??Post_Filter_5
// 5526       }
// 5527       else {
// 5528          tmp = temp2 * 26214;
// 5529          temp2 = ( tmp & 0xffff8000 ) / temp1;
        MOV      R10,#+102
        ORR      R10,R10,#0x6600
        MUL      R3,R10,R3
        AND      R0,R0,R3
        _BLF     ??divu32_a,??rA??divu32_a
// 5530       }
// 5531 
// 5532       /* preemphasis */
// 5533       p1 = st->res2 + 39;
??Post_Filter_5:
        ADD      R0,R4,#+156
// 5534       p2 = p1 - 1;
// 5535       tmp = *p1;
        LDR      R12,[R0, #+0]
        SUB      R3,R0,#+4
        STR      R12,[SP, #+4]
// 5536 
// 5537       do {
// 5538          *p1 = *p1 - ( ( temp2 * *p2-- ) >> 15 );
??Post_Filter_6:
        LDR      LR,[R3], #-4
        LDR      R10,[R0, #+0]
        MUL      R11,LR,R1
        SUB      R10,R10,R11, ASR #+15
        STR      R10,[R0, #+0]
// 5539          if (abs(*p1) > 32767) {
        CMP      R10,#+0
        RSBMI    LR,R10,#+0
        MOVPL    LR,R10
        CMP      LR,#+32768
        BLT      ??Post_Filter_7
// 5540             *p1 = (*p1 & 0x80000000) ? -32768 : 32767;
        TST      R10,#0x80000000
        MVNNE    R10,R2
        MOVEQ    R10,R2
        STR      R10,[R0, #+0]
// 5541          }
// 5542          p1--;
// 5543          *p1 = *p1 - ( ( temp2 * *p2-- ) >> 15 );
??Post_Filter_7:
        LDR      R11,[R3], #-4
        LDR      R10,[R0, #-4]!
        MUL      LR,R11,R1
        SUB      R10,R10,LR, ASR #+15
        STR      R10,[R0, #+0]
// 5544          if (abs(*p1) > 32767) {
        CMP      R10,#+0
        RSBMI    LR,R10,#+0
        MOVPL    LR,R10
        CMP      LR,#+32768
        BLT      ??Post_Filter_8
// 5545             *p1 = (*p1 & 0x80000000) ? -32768 : 32767;
        TST      R10,#0x80000000
        MVNNE    R10,R2
        MOVEQ    R10,R2
        STR      R10,[R0, #+0]
// 5546          }
// 5547          p1--;
// 5548          *p1 = *p1 - ( ( temp2 * *p2-- ) >> 15 );
??Post_Filter_8:
        LDR      R11,[R3], #-4
        LDR      R10,[R0, #-4]!
        MUL      LR,R11,R1
        SUB      R10,R10,LR, ASR #+15
        STR      R10,[R0, #+0]
// 5549          if (abs(*p1) > 32767) {
        CMP      R10,#+0
        RSBMI    LR,R10,#+0
        MOVPL    LR,R10
        CMP      LR,#+32768
        BLT      ??Post_Filter_9
// 5550             *p1 = (*p1 & 0x80000000) ? -32768 : 32767;
        TST      R10,#0x80000000
        MVNNE    R10,R2
        MOVEQ    R10,R2
        STR      R10,[R0, #+0]
// 5551          }
// 5552          p1--;
// 5553       } while( p1 > st->res2 );
??Post_Filter_9:
        SUB      R0,R0,#+4
        CMP      R4,R0
        BCC      ??Post_Filter_6
// 5554       *p1 = *p1 - ( ( temp2 * st->preemph_state_mem_pre ) >> 15 );
        LDR      R10,[R4, #+880]
        LDR      R3,[R0, #+0]
        MUL      R1,R10,R1
        SUBS     R1,R3,R1, ASR #+15
        STR      R1,[R0, #+0]
// 5555       if (abs(*p1) > 32767) {
        MOV      R3,R1
        RSBMI    R3,R3,#+0
        CMP      R3,#+32768
        BLT      ??Post_Filter_10
// 5556          *p1 = (*p1 & 0x80000000) ? -32768 : 32767;
        TST      R1,#0x80000000
        MVNNE    R2,R2
        STR      R2,[R0, #+0]
// 5557       }
// 5558       st->preemph_state_mem_pre = tmp;
??Post_Filter_10:
        LDR      R0,[SP, #+4]
// 5559 
// 5560       /* filtering through  1/A(z/0.75) */
// 5561       overflow = Syn_filt( Ap4, st->res2, &syn[i_subfr], L_SUBFR, st->mem_syn_pst, 0 );
// 5562       if (overflow){
        MOV      R3,#+40
        STR      R0,[R4, #+880]
        LDR      R0,[SP, #+184]
        MOV      R1,R4
        ADD      R10,R0,R8, LSL #+2
        MOV      R0,#+0
        PUSH     {R0}
        CFI CFA R13+228
        MOV      R2,R10
        ADD      R0,R4,#+160
        PUSH     {R0}
        CFI CFA R13+232
        ADD      R0,SP,#+16
        BL       Syn_filt
        CMP      R0,#+0
        ADD      SP,SP,#+8
        CFI CFA R13+224
        BEQ      ??Post_Filter_11
// 5563          Syn_filt_overflow( Ap4, st->res2, &syn[i_subfr], L_SUBFR, st->mem_syn_pst, 1 );
        MOV      R0,#+1
        PUSH     {R0}
        CFI CFA R13+228
        MOV      R3,#+40
        MOV      R2,R10
        MOV      R1,R4
        ADD      R0,R4,#+160
        PUSH     {R0}
        CFI CFA R13+232
        ADD      R0,SP,#+16
        BL       Syn_filt_overflow
// 5564          overflow = 0;
        ADD      SP,SP,#+8
        CFI CFA R13+224
        B        ??Post_Filter_12
// 5565       }
// 5566       else {
// 5567          memcpy(st->mem_syn_pst, &syn[i_subfr + 30], 40);
??Post_Filter_11:
        MOV      R2,#+40
        ADD      R1,R10,#+120
        ADD      R0,R4,#+160
        SWI      +286
// 5568       }
// 5569 
// 5570       /* scale output to input */
// 5571       agc( st->agc_state, &syn_work[i_subfr], &syn[i_subfr], AGC_FAC );
??Post_Filter_12:
        LDR      R0,[R4, #+884]
        MOV      R3,#+51
        ORR      R3,R3,#0x7300
        MOV      R2,R10
        MOV      R1,R9
        BL       agc
// 5572       Az += MP1;
        ADD      R5,R5,#+44
// 5573    }
        ADD      R8,R8,#+40
        CMP      R8,#+160
        BLT      ??Post_Filter_1
// 5574 
// 5575    /* update syn_work[] buffer */
// 5576    memcpy( &syn_work[- M], &syn_work[L_FRAME - M], M <<2 );
        LDR      R0,[SP, #+0]
        MOV      R2,#+40
        ADD      R1,R0,#+600
        SUB      R0,R0,#+40
        SWI      +286
// 5577    return;
        ADD      SP,SP,#+188
        CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        DATA
??Post_Filter_0:
        DC32     gamma4_gamma3_MR122
        DC32     0x3fff8001
        CFI EndBlock cfiBlock83
// 5578 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock84 Using cfiCommon0
        CFI NoFunction
        THUMB
??Post_Process??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock84
        REQUIRE Post_Process
// 5579 
// 5580 
// 5581 /*
// 5582  * Post_Process
// 5583  *
// 5584  *
// 5585  * Parameters:
// 5586  *    st                B: post filter states
// 5587  *    signal            B: signal
// 5588  *
// 5589  * Function:
// 5590  *    Postprocessing of input speech.
// 5591  *
// 5592  *    2nd order high pass filtering with cut off frequency at 60 Hz.
// 5593  *    Multiplication of output by two.
// 5594  *
// 5595  *
// 5596  * Returns:
// 5597  *    void
// 5598  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock85 Using cfiCommon1
        CFI Function Post_Process
        ARM
// 5599  static void Post_Process( Post_ProcessState *st, Word32 signal[] )
// 5600  {
// 5601     Word32 x2, tmp, i = 0;
// 5602     Word32 mask = 0x40000000;
Post_Process:
        LDR      R3,??Post_Process_0  ;; 0x1fffe000
        PUSH     {R4-R8}
        CFI R8 Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
        MOV      R2,#+0
// 5603 
// 5604     do {
// 5605        x2 = st->x1;
// 5606        st->x1 = st->x0;
??Post_Process_1:
        LDR      R4,[R0, #+16]
        LDR      R12,[R0, #+20]
        STR      R4,[R0, #+20]
// 5607        st->x0 = signal[i];
        LDR      R5,[R1, +R2, LSL #+2]
// 5608 
// 5609        /*
// 5610        * y[i] = b[0]*x[i]*2 + b[1]*x[i-1]*2 + b140[2]*x[i-2]/2
// 5611        *                    + a[1]*y[i-1] + a[2] * y[i-2];
// 5612        */
// 5613        tmp = ( st->y1_hi * 15836) + ( ( ( st->y1_lo * 15836 ) & ( Word32 )0xffff8000 ) >> 15);
// 5614        tmp += (st->y2_hi * -7667) + ( ( ( st->y2_lo * ( -7667 ) ) & ( Word32 )0xffff8000 ) >> 15);
// 5615        tmp += st->x0 * 7699;
// 5616        tmp += st->x1 * -15398;
        MOV      R7,#+220
        STR      R5,[R0, #+16]
        LDR      R6,[R0, #+8]
        ORR      R7,R7,#0x3D00
        MUL      R6,R7,R6
        LDR      R7,[R0, #+12]
        MOV      R8,#+220
        ORR      R8,R8,#0x3D00
        MUL      R7,R8,R7
        MVN      R8,#+242
        ADD      R6,R6,R7, ASR #+15
        LDR      R7,[R0, #+0]
        BIC      R8,R8,#0x1D00
        MLA      R6,R8,R7,R6
        LDR      R7,[R0, #+4]
        MUL      R7,R8,R7
        ADD      R6,R6,R7, ASR #+15
        MOV      R7,#+19
        ORR      R7,R7,#0x1E00
        MLA      R5,R7,R5,R6
        MVN      R6,#+37
        BIC      R6,R6,#0x3C00
        MLA      R4,R6,R4,R5
// 5617        if ( ( (tmp >> 1) ^ tmp ) & mask)
        EOR      R5,R4,R4, ASR #+1
        TST      R5,#0x40000000
        BEQ      ??Post_Process_2
// 5618           tmp = (tmp & 0x80000000) ? -1073741824 : 1073741823;
        TST      R4,#0x80000000
        MOVNE    R4,#-1073741824
        MVNEQ    R4,#-1073741824
// 5619 
// 5620        tmp += x2 * 7699;
??Post_Process_2:
        MLA      R4,R7,R12,R4
// 5621        if ( ( (tmp >> 1) ^ tmp ) & mask)
        EOR      R5,R4,R4, ASR #+1
        TST      R5,#0x40000000
        BEQ      ??Post_Process_3
// 5622           tmp = (tmp & 0x80000000) ? -1073741824 : 1073741823;
        TST      R4,#0x80000000
        MOVNE    R4,#-1073741824
        MVNEQ    R4,#-1073741824
// 5623 
// 5624        tmp = tmp << 1;
??Post_Process_3:
        LSL      R4,R4,#+1
// 5625        if ( ( (tmp >> 1) ^ tmp ) & mask)
        EOR      R5,R4,R4, ASR #+1
        TST      R5,#0x40000000
        BEQ      ??Post_Process_4
// 5626           tmp = (tmp & 0x80000000) ? -1073741824 : 1073741823;
        TST      R4,#0x80000000
        MOVNE    R4,#-1073741824
        MVNEQ    R4,#-1073741824
// 5627 
// 5628        tmp = tmp << 1;
??Post_Process_4:
        LSL      R4,R4,#+1
// 5629        if ( ( (tmp >> 1) ^ tmp ) & mask)
        EOR      R5,R4,R4, ASR #+1
        TST      R5,#0x40000000
        BEQ      ??Post_Process_5
// 5630           tmp = (tmp & 0x80000000) ? -1073741824 : 1073741823;
        TST      R4,#0x80000000
        MOVNE    R4,#-1073741824
        BNE      ??Post_Process_6
        MVN      R4,#-1073741824
??Post_Process_7:
        MOV      R5,R4
??Post_Process_8:
        ADD      R12,R2,#+1
        CMP      R5,R3
        BGE      ??Post_Process_9
// 5631 
// 5632        if ( labs( tmp ) < 536862720 ) {
// 5633           signal[i++] = ( tmp + 0x00002000L ) >> 14;
        ADD      R5,R4,#+8192
        ASR      R5,R5,#+14
        B        ??Post_Process_10
// 5634        }
??Post_Process_5:
        CMP      R4,#+0
        BPL      ??Post_Process_7
??Post_Process_6:
        MOV      R5,R4
        RSB      R5,R5,#+0
        B        ??Post_Process_8
// 5635        else if ( tmp > 0 ) {
??Post_Process_9:
        CMP      R4,#+1
// 5636           signal[i++] = 32767;
        MOVGE    R5,R3, LSR #+14
// 5637        }
// 5638        else {
// 5639           signal[i++] = -32768;
        MVNLT    R5,#+255
        BICLT    R5,R5,#0x7F00
??Post_Process_10:
        STR      R5,[R1, +R2, LSL #+2]
// 5640        }
// 5641        st->y2_hi = st->y1_hi;
        LDR      R5,[R0, #+8]
        MOV      R2,R12
        STR      R5,[R0, #+0]
// 5642        st->y2_lo = st->y1_lo;
        LDR      R5,[R0, #+12]
// 5643        st->y1_hi = tmp >> 15;
// 5644        st->y1_lo = ( ( tmp << 1 ) - ( st->y1_hi << 16 ) ) >> 1;
// 5645     } while( i < 160 );
        CMP      R2,#+160
        STR      R5,[R0, #+4]
        ASR      R5,R4,#+15
        STR      R5,[R0, #+8]
        LSL      R4,R4,#+1
        SUB      R4,R4,R5, LSL #+16
        ASR      R4,R4,#+1
        STR      R4,[R0, #+12]
        BLT      ??Post_Process_1
// 5646     return;
        POP      {R4-R8}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        DATA
??Post_Process_0:
        DC32     0x1fffe000
        CFI EndBlock cfiBlock85
// 5647 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock86 Using cfiCommon0
        CFI NoFunction
        THUMB
??Speech_Decode_Frame??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock86
        REQUIRE Speech_Decode_Frame
// 5648 
// 5649 
// 5650 /*
// 5651  * Speech_Decode_Frame
// 5652  *
// 5653  *
// 5654  * Parameters:
// 5655  *    st                B: decoder memory
// 5656  *    mode              I: AMR mode
// 5657  *    parm              I: speech parameters
// 5658  *    frame_type        I: Frame type
// 5659  *    synth             O: synthesis speech
// 5660 
// 5661  * Function:
// 5662  *    Decode one frame
// 5663  *
// 5664  * Returns:
// 5665  *    void
// 5666  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock87 Using cfiCommon1
        CFI Function Speech_Decode_Frame
        ARM
// 5667 void Speech_Decode_Frame( void *st, enum Mode mode, Word16 *parm, enum
// 5668       RXFrameType frame_type, Word16 *synth )
// 5669 {
Speech_Decode_Frame:
        PUSH     {R4-R6,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
        SUB      SP,SP,#+816
        CFI CFA R13+832
        LDR      R4,[SP, #+832]
        MOV      R5,R0
// 5670    Word32 Az_dec[AZ_SIZE];   /* Decoded Az for post-filter in 4 subframes*/
// 5671    Word32 synth_speech[L_FRAME];
// 5672 
// 5673 
// 5674 #ifndef NO13BIT
// 5675 
// 5676    Word32 i;
// 5677 #endif
// 5678 
// 5679    /* Synthesis */
// 5680    Decoder_amr( ( ( Speech_Decode_FrameState * ) st )->decoder_amrState, mode,
// 5681          parm, frame_type, synth_speech, Az_dec );
        ADD      R0,SP,#+640
        PUSH     {R0}
        CFI CFA R13+836
        MOV      R6,R1
        ADD      R0,SP,#+4
        PUSH     {R0}
        CFI CFA R13+840
        LDR      R0,[R5, #+0]
        BL       Decoder_amr
// 5682    Post_Filter( ( ( Speech_Decode_FrameState * ) st )->post_state, mode,
// 5683          synth_speech, Az_dec );
        LDR      R0,[R5, #+4]
        ADD      R3,SP,#+648
        ADD      R2,SP,#+8
        MOV      R1,R6
        BL       Post_Filter
// 5684 
// 5685    /* post HP filter, and 15->16 bits */
// 5686    Post_Process( ( ( Speech_Decode_FrameState * ) st )->postHP_state,
// 5687          synth_speech );
        LDR      R0,[R5, #+8]
        ADD      R1,SP,#+8
        BL       Post_Process
// 5688 
// 5689 #ifndef NO13BIT
// 5690 
// 5691    /* Truncate to 13 bits */
// 5692    for ( i = 0; i < L_FRAME; i++ ) {
        MOV      R0,#+0
        ADD      SP,SP,#+8
        CFI CFA R13+832
        MVN      R3,#+7
// 5693       synth[i] = ( Word16 )( synth_speech[i] & 0xfff8 );
??Speech_Decode_Frame_0:
        MOV      R2,SP
        LDR      R2,[R2, +R0, LSL #+2]
        ADD      R1,R4,R0, LSL #+1
        AND      R2,R3,R2
        STRH     R2,[R1, #+0]
// 5694    }
        ADD      R0,R0,#+1
        CMP      R0,#+160
        BLT      ??Speech_Decode_Frame_0
// 5695 #endif
// 5696 
// 5697    return;
        ADD      SP,SP,#+816      ;; stack cleaning
        CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
        CFI EndBlock cfiBlock87
// 5698 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock88 Using cfiCommon0
        CFI NoFunction
        THUMB
??Decoder_amr_init??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock88
        REQUIRE Decoder_amr_init
// 5699 
// 5700 
// 5701 /*
// 5702  * Decoder_amr_exit
// 5703  *
// 5704  *
// 5705  * Parameters:
// 5706  *    state                I: state structure
// 5707  *
// 5708  * Function:
// 5709  *    The memory used for state memory is mfreed
// 5710  *
// 5711  * Returns:
// 5712  *    Void
// 5713  */
// 5714 static void Decoder_amr_exit( Decoder_amrState **state )
// 5715 {
// 5716    if ( state == NULL || *state == NULL )
// 5717       return;
// 5718    mfree( ( *state )->lsfState );
// 5719    mfree( ( *state )->ec_gain_p_st );
// 5720    mfree( ( *state )->ec_gain_c_st );
// 5721    mfree( ( *state )->pred_state );
// 5722    mfree( ( *state )->background_state );
// 5723    mfree( ( *state )->ph_disp_st );
// 5724    mfree( ( *state )->Cb_gain_averState );
// 5725    mfree( ( *state )->lsp_avg_st );
// 5726    mfree( ( *state )->dtxDecoderState );
// 5727 
// 5728    /* deallocate memory */
// 5729    mfree( *state );
// 5730    *state = NULL;
// 5731    return;
// 5732 }
// 5733 
// 5734 
// 5735 /*
// 5736  * Post_Filter_exit
// 5737  *
// 5738  *
// 5739  * Parameters:
// 5740  *    state                I: state structure
// 5741  *
// 5742  * Function:
// 5743  *    The memory used for state memory is mfreed
// 5744  *
// 5745  * Returns:
// 5746  *    Void
// 5747  */
// 5748 static void Post_Filter_exit( Post_FilterState **state )
// 5749 {
// 5750    if ( state == NULL || *state == NULL )
// 5751       return;
// 5752    mfree( ( *state )->agc_state );
// 5753 
// 5754    /* deallocate memory */
// 5755    mfree( *state );
// 5756    *state = NULL;
// 5757    return;
// 5758 }
// 5759 
// 5760 
// 5761 /*
// 5762  * Post_Process_reset
// 5763  *
// 5764  *
// 5765  * Parameters:
// 5766  *    state             B: state structure
// 5767  *
// 5768  * Function:
// 5769  *    Resets state memory
// 5770  *
// 5771  * Returns:
// 5772  *    -1 failure
// 5773  */
// 5774 static int Post_Process_reset( Post_ProcessState *state )
// 5775 {
// 5776    if ( ( Post_ProcessState * )state == NULL ) {
// 5777       //fprintf( stderr, "Post_Process_reset: invalid parameter\n" );
// 5778       return-1;
// 5779    }
// 5780    state->y2_hi = 0;
// 5781    state->y2_lo = 0;
// 5782    state->y1_hi = 0;
// 5783    state->y1_lo = 0;
// 5784    state->x0 = 0;
// 5785    state->x1 = 0;
// 5786    return 0;
// 5787 }
// 5788 
// 5789 
// 5790 /*
// 5791  * Post_Process_exit
// 5792  *
// 5793  *
// 5794  * Parameters:
// 5795  *    state                I: state structure
// 5796  *
// 5797  * Function:
// 5798  *    The memory used for state memory is mfreed
// 5799  *
// 5800  * Returns:
// 5801  *    Void
// 5802  */
// 5803 static void Post_Process_exit( Post_ProcessState **state )
// 5804 {
// 5805    if ( state == NULL || *state == NULL )
// 5806       return;
// 5807 
// 5808    /* deallocate memory */
// 5809    mfree( *state );
// 5810    *state = NULL;
// 5811    return;
// 5812 }
// 5813 
// 5814 
// 5815 /*
// 5816  * Decoder_amr_init
// 5817  *
// 5818  *
// 5819  * Parameters:
// 5820  *    state             O: state structure
// 5821  *
// 5822  * Function:
// 5823  *    Allocates state memory and initializes state memory
// 5824  *
// 5825  * Returns:
// 5826  *    success = 0
// 5827  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock89 Using cfiCommon1
        CFI Function Decoder_amr_init
        ARM
// 5828 static int Decoder_amr_init( Decoder_amrState **state )
// 5829 {
Decoder_amr_init:
        PUSH     {R4-R6,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
        MOVS     R4,R0
// 5830    Decoder_amrState * s;
// 5831 
// 5832    if ( ( Decoder_amrState * )state == NULL ) {
// 5833       //fprintf( stderr, "Decoder_amr_init: invalid parameter\n" );
// 5834       return-1;
        MVNEQ    R0,#+0
        POPEQ    {R4-R6,PC}
// 5835    }
// 5836    *state = NULL;
        MOV      R5,#+0
        STR      R5,[R4, #+0]
// 5837 
// 5838    /* allocate memory */
// 5839    if ( ( s = ( Decoder_amrState * ) malloc( sizeof( Decoder_amrState ) ) ) ==
// 5840          NULL ) {
        MOV      R0,#+996
        SWI      +20
        MOVS     R6,R0
        BEQ      ??Decoder_amr_init_0
// 5841       //fprintf( stderr, "Decoder_amr_init: can not malloc state structure\n" );
// 5842       return-1;
// 5843    }
// 5844 
// 5845    /* DPlsf_init */
// 5846    /* allocate memory */
// 5847    if ( ( s->lsfState = ( D_plsfState * ) malloc( sizeof( D_plsfState ) ) ) ==
// 5848          NULL ) {
        MOV      R0,#+80
        SWI      +20
        STR      R0,[R6, #+972]
        CMP      R0,#+0
        BNE      ??Decoder_amr_init_1
// 5849       //fprintf( stderr, "DPlsf_init: can not malloc state structure\n" );
// 5850       return-1;
??Decoder_amr_init_0:
        MVN      R0,R5
        POP      {R4-R6,PC}
// 5851    }
// 5852 
// 5853    /* ecGainPitchInit */
// 5854    /* allocate memory */
// 5855    if ( ( s->ec_gain_p_st = ( ec_gain_pitchState * ) malloc( sizeof(
// 5856          ec_gain_pitchState ) ) ) == NULL ) {
??Decoder_amr_init_1:
        MOV      R0,#+28
        SWI      +20
        STR      R0,[R6, #+976]
        CMP      R0,#+0
        BEQ      ??Decoder_amr_init_0
// 5857       //fprintf( stderr, "ecGainPitchInit: can not malloc state structure\n" );
// 5858       return-1;
// 5859    }
// 5860 
// 5861    /* ecGainCodeInit */
// 5862    /* allocate memory */
// 5863    if ( ( s->ec_gain_c_st = ( ec_gain_codeState * ) malloc( sizeof(
// 5864          ec_gain_codeState ) ) ) == NULL ) {
        MOV      R0,#+28
        SWI      +20
        STR      R0,[R6, #+980]
        CMP      R0,#+0
        BEQ      ??Decoder_amr_init_0
// 5865       //fprintf( stderr, "ecGainCodeInit: can not malloc state structure\n" );
// 5866       return-1;
// 5867    }
// 5868 
// 5869    /* gcPredInit */
// 5870    /* allocate memory */
// 5871    if ( ( s->pred_state = ( gc_predState * ) malloc( sizeof( gc_predState ) ) )
// 5872          == NULL ) {
        MOV      R0,#+32
        SWI      +20
        STR      R0,[R6, #+984]
        CMP      R0,#+0
        BEQ      ??Decoder_amr_init_0
// 5873       //fprintf( stderr, "gcPredInit: can not malloc state structure\n" );
// 5874       return-1;
// 5875    }
// 5876 
// 5877    /* Cb_gain_averageInit */
// 5878    /* allocate memory */
// 5879    if ( ( s->Cb_gain_averState = ( Cb_gain_averageState * ) malloc( sizeof(
// 5880          Cb_gain_averageState ) ) ) == NULL ) {
        MOV      R0,#+36
        SWI      +20
        STR      R0,[R6, #+964]
        CMP      R0,#+0
        BEQ      ??Decoder_amr_init_0
// 5881       //fprintf( stderr, "Cb_gain_averageInit: can not malloc state structure\n" )
// 5882       ;
// 5883       return-1;
// 5884    }
// 5885    memset( s->Cb_gain_averState->cbGainHistory, 0, L_CBGAINHIST <<2 );
        MOV      R2,#+28
        MOV      R1,#+0
        ADD      R0,R0,#+4
        SWI      +187
// 5886 
// 5887    /* Initialize hangover handling */
// 5888    s->Cb_gain_averState->hangVar = 0;
        LDR      R0,[R6, #+964]
        STRH     R5,[R0, #+32]
// 5889    s->Cb_gain_averState->hangCount = 0;
        LDR      R0,[R6, #+964]
        STR      R5,[R0, #+0]
// 5890 
// 5891    /* lsp_avgInit */
// 5892    /* allocate memory */
// 5893    if ( ( s->lsp_avg_st = ( lsp_avgState * ) malloc( sizeof( lsp_avgState ) ) )
// 5894          == NULL ) {
        MOV      R0,#+40
        SWI      +20
        STR      R0,[R6, #+968]
        CMP      R0,#+0
        BEQ      ??Decoder_amr_init_0
// 5895       //fprintf( stderr, "lsp_avgInit: can not malloc state structure\n" );
// 5896       return-1;
// 5897    }
// 5898 
// 5899    /* Bgn_scdInit */
// 5900    /* allocate memory */
// 5901    if ( ( s->background_state = ( Bgn_scdState * ) malloc( sizeof( Bgn_scdState
// 5902          ) ) ) == NULL ) {
        MOV      R0,#+244
        SWI      +20
        STR      R0,[R6, #+960]
        CMP      R0,#+0
        BEQ      ??Decoder_amr_init_0
// 5903       //fprintf( stderr, "Bgn_scdInit: can not malloc state structure\n" );
// 5904       return-1;
// 5905    }
// 5906 
// 5907    /* phDispInit */
// 5908    /* allocate memory */
// 5909    if ( ( s->ph_disp_st = ( ph_dispState * ) malloc( sizeof( ph_dispState ) ) )
// 5910          == NULL ) {
        MOV      R0,#+32
        SWI      +20
        STR      R0,[R6, #+988]
        CMP      R0,#+0
        BEQ      ??Decoder_amr_init_0
// 5911       //fprintf( stderr, "phDispInit: can not malloc state structure\n" );
// 5912       return-1;
// 5913    }
// 5914 
// 5915    /* dtxDecInit */
// 5916    /* allocate memory */
// 5917    if ( ( s->dtxDecoderState = ( dtx_decState * ) malloc( sizeof( dtx_decState )
// 5918          ) ) == NULL ) {
        MOV      R0,#+796
        SWI      +20
        STR      R0,[R6, #+992]
        CMP      R0,#+0
        BEQ      ??Decoder_amr_init_0
// 5919       //fprintf( stderr, "dtxDecInit: can not malloc state structure\n" );
// 5920       return-1;
// 5921    }
// 5922 
// 5923    Decoder_amr_reset( s,  ( enum Mode ) 0  );
        MOV      R1,#+0
        MOV      R0,R6
        BL       Decoder_amr_reset
// 5924    *state = s;
        STR      R6,[R4, #+0]
// 5925    return 0;
        MOV      R0,R5
        POP      {R4-R6,PC}       ;; return
        CFI EndBlock cfiBlock89
// 5926 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock90 Using cfiCommon0
        CFI NoFunction
        THUMB
??Speech_Decode_Frame_exit??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock90
        REQUIRE Speech_Decode_Frame_exit
// 5927 
// 5928 
// 5929 /*
// 5930  * Post_Filter_reset
// 5931  *
// 5932  *
// 5933  * Parameters:
// 5934  *    state             B: state structure
// 5935  *
// 5936  * Function:
// 5937  *    Resets state memory
// 5938  *
// 5939  * Returns:
// 5940  *    -1 failure
// 5941  */
// 5942 static int Post_Filter_reset( Post_FilterState *state )
// 5943 {
// 5944    if ( ( Post_FilterState * )state == NULL ) {
// 5945       //fprintf( stderr, "Post_Filter_reset: invalid parameter\n" );
// 5946       return-1;
// 5947    }
// 5948    state->preemph_state_mem_pre = 0;
// 5949    state->agc_state->past_gain = 4096;
// 5950    memset( state->mem_syn_pst, 0, M <<2 );
// 5951    memset( state->res2, 0, L_SUBFR <<2 );
// 5952    memset( state->synth_buf, 0, ( L_FRAME + M )<<2 );
// 5953    return 0;
// 5954 }
// 5955 
// 5956 
// 5957 /*
// 5958  * Post_Filter_init
// 5959  *
// 5960  *
// 5961  * Parameters:
// 5962  *    state             O: state structure
// 5963  *
// 5964  * Function:
// 5965  *    Allocates state memory and initializes state memory
// 5966  *
// 5967  * Returns:
// 5968  *    success = 0
// 5969  */
// 5970 static int Post_Filter_init( Post_FilterState **state )
// 5971 {
// 5972    Post_FilterState * s;
// 5973 
// 5974    if ( ( Post_FilterState * )state == NULL ) {
// 5975       //fprintf( stderr, "F057:invalid parameter\n" );
// 5976       return-1;
// 5977    }
// 5978    *state = NULL;
// 5979 
// 5980    /* allocate memory */
// 5981    if ( ( s = ( Post_FilterState * ) malloc( sizeof( Post_FilterState ) ) ) ==
// 5982          NULL ) {
// 5983       //fprintf( stderr, "F057:can not malloc filter structure\n" );
// 5984       return-1;
// 5985    }
// 5986    s->agc_state = NULL;
// 5987 
// 5988    /* allocate memory */
// 5989    if ( ( s->agc_state = ( agcState * ) malloc( sizeof( agcState ) ) ) == NULL )
// 5990    {
// 5991       //fprintf( stderr, "agcInit: can not malloc state structure\n" );
// 5992       return-1;
// 5993    }
// 5994    Post_Filter_reset( s );
// 5995    *state = s;
// 5996    return 0;
// 5997 }
// 5998 
// 5999 
// 6000 /*
// 6001  * Post_Process_init
// 6002  *
// 6003  *
// 6004  * Parameters:
// 6005  *    state             O: state structure
// 6006  *
// 6007  * Function:
// 6008  *    Allocates state memory and initializes state memory
// 6009  *
// 6010  * Returns:
// 6011  *    success = 0
// 6012  */
// 6013 static int Post_Process_init( Post_ProcessState **state )
// 6014 {
// 6015    Post_ProcessState * s;
// 6016 
// 6017    if ( ( Post_ProcessState * )state == NULL ) {
// 6018       //fprintf( stderr, "Post_Process_init: invalid parameter\n" );
// 6019       return-1;
// 6020    }
// 6021    *state = NULL;
// 6022 
// 6023    /* allocate memory */
// 6024    if ( ( s = ( Post_ProcessState * ) malloc( sizeof( Post_ProcessState ) ) ) ==
// 6025          NULL ) {
// 6026       //fprintf( stderr, "Post_Process_init: can not malloc state structure\n" );
// 6027       return-1;
// 6028    }
// 6029    Post_Process_reset( s );
// 6030    *state = s;
// 6031    return 0;
// 6032 }
// 6033 
// 6034 
// 6035 /*
// 6036  * Speech_Decode_Frame_exit
// 6037  *
// 6038  *
// 6039  * Parameters:
// 6040  *    state                I: state structure
// 6041  *
// 6042  * Function:
// 6043  *    The memory used for state memory is mfreed
// 6044  *
// 6045  * Returns:
// 6046  *    Void
// 6047  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock91 Using cfiCommon1
        CFI Function Speech_Decode_Frame_exit
        ARM
// 6048 void Speech_Decode_Frame_exit( void **st )
// 6049 {
Speech_Decode_Frame_exit:
        PUSH     {R4-R6,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
        MOVS     R4,R0
// 6050    if ( (( Speech_Decode_FrameState * )( st )) == NULL )
        POPEQ    {R4-R6,PC}
// 6051       return;
// 6052    Decoder_amr_exit( &( ( ( Speech_Decode_FrameState * ) st )->decoder_amrState
// 6053          ) );
        LDRNE    R0,[R4, #+0]
        MOV      R5,#+0
        CMPNE    R0,#+0
        BEQ      ??Speech_Decode_Frame_exit_0
        LDR      R0,[R0, #+972]
        SWI      +21
        LDR      R0,[R4, #+0]
        LDR      R0,[R0, #+976]
        SWI      +21
        LDR      R0,[R4, #+0]
        LDR      R0,[R0, #+980]
        SWI      +21
        LDR      R0,[R4, #+0]
        LDR      R0,[R0, #+984]
        SWI      +21
        LDR      R0,[R4, #+0]
        LDR      R0,[R0, #+960]
        SWI      +21
        LDR      R0,[R4, #+0]
        LDR      R0,[R0, #+988]
        SWI      +21
        LDR      R0,[R4, #+0]
        LDR      R0,[R0, #+964]
        SWI      +21
        LDR      R0,[R4, #+0]
        LDR      R0,[R0, #+968]
        SWI      +21
        LDR      R0,[R4, #+0]
        LDR      R0,[R0, #+992]
        SWI      +21
        LDR      R0,[R4, #+0]
        SWI      +21
        STR      R5,[R4, #+0]
// 6054    Post_Filter_exit( &( ( ( Speech_Decode_FrameState * ) st )->post_state ) );
??Speech_Decode_Frame_exit_0:
        ADDS     R6,R4,#+4
        LDRNE    R0,[R6, #+0]
        CMPNE    R0,#+0
        BEQ      ??Speech_Decode_Frame_exit_1
        LDR      R0,[R0, #+884]
        SWI      +21
        LDR      R0,[R6, #+0]
        SWI      +21
        STR      R5,[R6, #+0]
// 6055    Post_Process_exit( &( ( ( Speech_Decode_FrameState * ) st )->postHP_state ) )
// 6056    ;
??Speech_Decode_Frame_exit_1:
        ADDS     R6,R4,#+8
        LDRNE    R0,[R6, #+0]
        CMPNE    R0,#+0
        BEQ      ??Speech_Decode_Frame_exit_2
        SWI      +21
        STR      R5,[R6, #+0]
// 6057 
// 6058    /* deallocate memory */
// 6059    mfree( (( Speech_Decode_FrameState * )st) );
??Speech_Decode_Frame_exit_2:
        MOV      R0,R4
        SWI      +21
// 6060    return;
        POP      {R4-R6,PC}       ;; return
        CFI EndBlock cfiBlock91
// 6061 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock92 Using cfiCommon0
        CFI NoFunction
        THUMB
??Speech_Decode_Frame_reset??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock92
        REQUIRE Speech_Decode_Frame_reset
// 6062 
// 6063 
// 6064 /*
// 6065  * Speech_Decode_Frame_reset
// 6066  *
// 6067  *
// 6068  * Parameters:
// 6069  *    state             B: state structure
// 6070  *
// 6071  * Function:
// 6072  *    Resets state memory
// 6073  *
// 6074  * Returns:
// 6075  *    -1 = failure
// 6076  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock93 Using cfiCommon1
        CFI Function Speech_Decode_Frame_reset
        ARM
// 6077 int Speech_Decode_Frame_reset( void **st )
// 6078 {
Speech_Decode_Frame_reset:
        PUSH     {R4-R6,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
        MOVS     R4,R0
// 6079    Speech_Decode_FrameState * state;
// 6080 
// 6081    if ( st == NULL || *st == NULL )
        LDRNE    R0,[R4, #+0]
        CMPNE    R0,#+0
// 6082       return (-1);
        MVNEQ    R0,#+0
        POPEQ    {R4-R6,PC}
// 6083    state = ( Speech_Decode_FrameState * )st;
// 6084    Decoder_amr_reset( state->decoder_amrState, ( enum Mode ) 0 );
        MOV      R1,#+0
        BL       Decoder_amr_reset
// 6085    Post_Filter_reset( state->post_state );
        LDR      R5,[R4, #+4]
        MOV      R6,#+0
        CMP      R5,#+0
        BEQ      ??Speech_Decode_Frame_reset_0
        STR      R6,[R5, #+880]
        LDR      R0,[R5, #+884]
        MOV      R1,#+4096
        STR      R1,[R0, #+0]
        MOV      R2,#+40
        MOV      R1,#+0
        ADD      R0,R5,#+160
        SWI      +187
        MOV      R2,#+160
        MOV      R1,R6
        MOV      R0,R5
        SWI      +187
        MOV      R2,#+680
        MOV      R1,R6
        ADD      R0,R5,#+200
        SWI      +187
// 6086    Post_Process_reset( state->postHP_state );
??Speech_Decode_Frame_reset_0:
        LDR      R0,[R4, #+8]
        CMP      R0,#+0
        POPEQ    {R4-R6,PC}
        STR      R6,[R0, #+0]
        STR      R6,[R0, #+4]
        STR      R6,[R0, #+8]
        STR      R6,[R0, #+12]
        STR      R6,[R0, #+16]
        STR      R6,[R0, #+20]
// 6087    return 0;
        MOV      R0,#+0
        POP      {R4-R6,PC}       ;; return
        CFI EndBlock cfiBlock93
// 6088 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock94 Using cfiCommon0
        CFI NoFunction
        THUMB
??Speech_Decode_Frame_init??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock94
        REQUIRE Speech_Decode_Frame_init
// 6089 
// 6090 
// 6091 /*
// 6092  * Speech_Decode_Frame_init
// 6093  *
// 6094  *
// 6095  * Parameters:
// 6096  *    state             O: state structure
// 6097  *
// 6098  * Function:
// 6099  *    Allocates state memory and initializes state memory
// 6100  *
// 6101  * Returns:
// 6102  *    success = 0
// 6103  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock95 Using cfiCommon1
        CFI Function Speech_Decode_Frame_init
        ARM
// 6104 void * Speech_Decode_Frame_init( )
// 6105 {
Speech_Decode_Frame_init:
        PUSH     {R4-R6,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
        SUB      SP,SP,#+4
        CFI CFA R13+20
// 6106    Speech_Decode_FrameState * s;
// 6107 
// 6108    /* allocate memory */
// 6109    if ( ( s = ( Speech_Decode_FrameState * ) malloc( sizeof(
// 6110          Speech_Decode_FrameState ) ) ) == NULL ) {
        MOV      R0,#+12
        SWI      +20
        STR      R0,[SP, #+0]
        CMP      R0,#+0
// 6111      // //fprintf( stderr, "Speech_Decode_Frame_init: can not malloc state "
// 6112           //  "structure\n" );
// 6113       return NULL;
        POPEQ    {R1,R4-R6,PC}
// 6114    }
// 6115    s->decoder_amrState = NULL;
        MOV      R4,#+0
        STR      R4,[R0, #+0]
// 6116    s->post_state = NULL;
        LDR      R0,[SP, #+0]
        STR      R4,[R0, #+4]
// 6117    s->postHP_state = NULL;
        LDR      R0,[SP, #+0]
        STR      R4,[R0, #+8]
// 6118 
// 6119    if ( Decoder_amr_init( &s->decoder_amrState ) || Post_Filter_init( &s->
// 6120          post_state ) || Post_Process_init( &s->postHP_state ) ) {
        LDR      R0,[SP, #+0]
        BL       Decoder_amr_init
        CMP      R0,#+0
        BNE      ??Speech_Decode_Frame_init_0
        LDR      R0,[SP, #+0]
        ADDS     R5,R0,#+4
        BEQ      ??Speech_Decode_Frame_init_0
        STR      R4,[R5, #+0]
        MOV      R0,#+888
        SWI      +20
        MOVS     R6,R0
        BEQ      ??Speech_Decode_Frame_init_0
        STR      R4,[R6, #+884]
        MOV      R0,#+4
        SWI      +20
        STR      R0,[R6, #+884]
        CMP      R0,#+0
        BEQ      ??Speech_Decode_Frame_init_0
        STR      R4,[R6, #+880]
        MOV      R1,#+4096
        STR      R1,[R0, #+0]
        MOV      R2,#+40
        MOV      R1,#+0
        ADD      R0,R6,#+160
        SWI      +187
        MOV      R2,#+160
        MOV      R1,R4
        MOV      R0,R6
        SWI      +187
        MOV      R2,#+680
        MOV      R1,R4
        ADD      R0,R6,#+200
        SWI      +187
        STR      R6,[R5, #+0]
        LDR      R0,[SP, #+0]
        ADDS     R5,R0,#+8
        BEQ      ??Speech_Decode_Frame_init_0
        STR      R4,[R5, #+0]
        MOV      R0,#+24
        SWI      +20
        CMP      R0,#+0
        BEQ      ??Speech_Decode_Frame_init_0
        STR      R4,[R0, #+0]
        STR      R4,[R0, #+4]
        STR      R4,[R0, #+8]
        STR      R4,[R0, #+12]
        STR      R4,[R0, #+16]
        STR      R4,[R0, #+20]
        STR      R0,[R5, #+0]
// 6121       Speech_Decode_Frame_exit( ( void ** )( &s ) );
// 6122       return NULL;
// 6123    }
// 6124    return s;
        LDR      R0,[SP, #+0]
        POP      {R1,R4-R6,PC}
??Speech_Decode_Frame_init_0:
        MOV      R0,SP
        BL       Speech_Decode_Frame_exit
        MOV      R0,#+0
        POP      {R1,R4-R6,PC}    ;; return
        CFI EndBlock cfiBlock95
// 6125 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock96 Using cfiCommon1
        CFI NoFunction
        ARM
??rA??div32_a:
        LDR      R12,??Subroutine48_0  ;; ??div32_a
        MOV      PC,R12
        DATA
??Subroutine48_0:
        DC32     ??div32_a
        CFI EndBlock cfiBlock96

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock97 Using cfiCommon1
        CFI NoFunction
        ARM
??rA??divu32_a:
        LDR      R12,??Subroutine49_0  ;; ??divu32_a
        MOV      PC,R12
        DATA
??Subroutine49_0:
        DC32     ??divu32_a
        CFI EndBlock cfiBlock97

        END
// 
// 22 768 bytes in segment CODE
// 52 816 bytes in segment DATA_C
// 
// 22 552 bytes of CODE  memory (+ 216 bytes shared)
// 52 816 bytes of CONST memory
//
//Errors: none
//Warnings: none
