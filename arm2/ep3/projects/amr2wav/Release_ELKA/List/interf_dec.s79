//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION   29/Mar/2011  10:39:10 /
// Copyright 1999-2005 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Cpu mode        =  interwork                                           /
//    Endian          =  little                                              /
//    Stack alignment =  4                                                   /
//    Source file     =  C:\arm\vkcom\interf_dec.c                           /
//    Command line    =  C:\arm\vkcom\interf_dec.c -D NEWSGOLD -D ELKA -lA   /
//                       C:\arm\vkcom\Release_ELKA\List\ -o                  /
//                       C:\arm\vkcom\Release_ELKA\Obj\ -s9 --cpu_mode arm   /
//                       --endian little --cpu ARM926EJ-S --stack_align 4    /
//                       --interwork -e --fpu None --dlib_config             /
//                       "C:\arm2\Embedded Workbench 4.0                     /
//                       Evaluation\ARM\LIB\dl5tpainl8n.h" -I                /
//                       "C:\arm2\Embedded Workbench 4.0                     /
//                       Evaluation\ARM\INC\" --inline_threshold=2           /
//    List file       =  C:\arm\vkcom\Release_ELKA\List\interf_dec.s79       /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME interf_dec

        RTMODEL "StackAlign4", "USED"
        RTMODEL "__cpu_mode", "__pcs__interwork"
        RTMODEL "__data_model", "absolute"
        RTMODEL "__endian", "little"
        RTMODEL "__rt_version", "6"

        RSEG CSTACK:DATA:NOROOT(2)

        PUBWEAK `?*?DATA_ID`
        MULTWEAK ??Decoder3GPP??rT
        MULTWEAK ??Decoder_Interface_Decode??rT
        MULTWEAK ??Decoder_Interface_exit??rT
        MULTWEAK ??Decoder_Interface_init??rT
        MULTWEAK ??Decoder_Interface_reset??rT
        MULTWEAK ??Speech_Decode_Frame??rA
        MULTWEAK ??Speech_Decode_Frame_exit??rA
        MULTWEAK ??Speech_Decode_Frame_init??rA
        MULTWEAK ??Speech_Decode_Frame_reset??rA
        PUBWEAK ?init?tab?DATA_I
        PUBLIC Decoder3GPP
        FUNCTION Decoder3GPP,0203H
        LOCFRAME CSTACK, 20, STACK
        PUBLIC Decoder_Interface_Decode
        FUNCTION Decoder_Interface_Decode,0203H
        LOCFRAME CSTACK, 160, STACK
        PUBLIC Decoder_Interface_exit
        FUNCTION Decoder_Interface_exit,0203H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC Decoder_Interface_init
        FUNCTION Decoder_Interface_init,0203H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC Decoder_Interface_reset
        FUNCTION Decoder_Interface_reset,0203H
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 HUGEDATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, CPSR:32, R13:32
        CFI Resource R14:32, SPSR:32
        CFI VirtualResource ?RET:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon0
        
        
        CFI Common cfiCommon1 Using cfiNames0
        CFI CodeAlign 4
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon1
        
Speech_Decode_Frame SYMBOL "Speech_Decode_Frame"
Speech_Decode_Frame_exit SYMBOL "Speech_Decode_Frame_exit"
Speech_Decode_Frame_init SYMBOL "Speech_Decode_Frame_init"
Speech_Decode_Frame_reset SYMBOL "Speech_Decode_Frame_reset"
Decoder3GPP         SYMBOL "Decoder3GPP"
??Decoder3GPP??rT   SYMBOL "??rT", Decoder3GPP
Decoder_Interface_Decode SYMBOL "Decoder_Interface_Decode"
??Decoder_Interface_Decode??rT SYMBOL "??rT", Decoder_Interface_Decode
Decoder_Interface_exit SYMBOL "Decoder_Interface_exit"
??Decoder_Interface_exit??rT SYMBOL "??rT", Decoder_Interface_exit
Decoder_Interface_init SYMBOL "Decoder_Interface_init"
??Decoder_Interface_init??rT SYMBOL "??rT", Decoder_Interface_init
Decoder_Interface_reset SYMBOL "Decoder_Interface_reset"
??Decoder_Interface_reset??rT SYMBOL "??rT", Decoder_Interface_reset
??Speech_Decode_Frame??rA SYMBOL "??rA", Speech_Decode_Frame
??Speech_Decode_Frame_exit??rA SYMBOL "??rA", Speech_Decode_Frame_exit
??Speech_Decode_Frame_init??rA SYMBOL "??rA", Speech_Decode_Frame_init
??Speech_Decode_Frame_reset??rA SYMBOL "??rA", Speech_Decode_Frame_reset

        EXTERN Speech_Decode_Frame
        FUNCTION Speech_Decode_Frame,0202H
        EXTERN Speech_Decode_Frame_exit
        FUNCTION Speech_Decode_Frame_exit,0202H
        EXTERN Speech_Decode_Frame_init
        FUNCTION Speech_Decode_Frame_init,0200H
        EXTERN Speech_Decode_Frame_reset
        FUNCTION Speech_Decode_Frame_reset,0202H

// C:\arm\vkcom\interf_dec.c
//    1 /*
//    2  * ===================================================================
//    3  *  TS 26.104
//    4  *  R99   V3.4.0 2002-02
//    5  *  REL-4 V4.3.0 2002-02
//    6  *  3GPP AMR Floating-point Speech Codec
//    7  * ===================================================================
//    8  *
//    9  */
//   10 
//   11 /*
//   12  * interf_dec.c
//   13  *
//   14  *
//   15  * Project:
//   16  *     AMR Floating-Point Codec
//   17  *
//   18  * Contains:
//   19  *    This module provides means to conversion from 3GPP or ETSI
//   20  *    bitstream to AMR parameters
//   21  */
//   22 
//   23 /*
//   24  * include files
//   25  */
//   26 
//   27 //#include <memory.h>
//   28 #include "typedef.h"
//   29 #include "sp_dec.h"
//   30 #include "interf_rom.h"

        RSEG DATA_I:DATA:SORT:NOROOT(2)
// static short __data order_MR475[190]
order_MR475:
        DS8 380
        REQUIRE `?<Initializer for order_MR475>`
        DS8 412
        REQUIRE `?<Initializer for order_MR515>`
        DS8 472
        REQUIRE `?<Initializer for order_MR59>`
        DS8 536
        REQUIRE `?<Initializer for order_MR67>`
        DS8 592
        REQUIRE `?<Initializer for order_MR74>`
        DS8 1272
        REQUIRE `?<Initializer for order_MR795>`
        DS8 816
        REQUIRE `?<Initializer for order_MR102>`
        DS8 976
        REQUIRE `?<Initializer for order_MR122>`
        DS8 140
        REQUIRE `?<Initializer for order_MRDTX>`

        RSEG DATA_C:CONST:SORT:NOROOT(2)
// static short const __data dhf_MR475[17]
dhf_MR475:
        DATA
        DC16 248, 157, 28, 102, 0, 3, 40, 15, 56, 1, 15, 49, 2, 8, 15, 38, 3
        DC8 0, 0
        DC16 248, 157, 28, 102, 0, 3, 55, 15, 0, 3, 5, 15, 55, 3, 55, 15, 35, 3
        DC16 31
        DC8 0, 0
        DC16 248, 227, 47, 189, 0, 3, 55, 15, 1, 3, 15, 96, 249, 3, 55, 15, 0
        DC16 3, 55
        DC8 0, 0
        DC16 248, 227, 47, 189, 2, 7, 0, 15, 152, 7, 97, 96, 1477, 7, 0, 15
        DC16 792, 7, 0
        DC8 0, 0
        DC16 248, 227, 47, 189, 6, 15, 0, 27, 520, 15, 98, 96, 7078, 15, 0, 27
        DC16 6, 15, 0
        DC8 0, 0
        DC16 194, 227, 47, 189, 6, 15, 10, 0, 57, 7176, 7, 10, 11, 99, 4518, 15
        DC16 1, 0, 57, 2464, 15, 2, 1
        DC8 0, 0
        DC16 248, 227, 47, 69, 0, 0, 0, 0, 0, 0, 0, 0, 27, 0, 1, 0, 1, 806, 206
        DC16 126, 81, 98, 0, 0, 0, 0, 346, 857, 118, 0, 27, 0, 0, 0, 0, 380
        DC16 533, 56, 48
        DC8 0, 0
        DC16 4, 42, 219, 150, 42, 342, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 54
        DC16 11, 0, 15, 14, 12, 13, 0, 1, 5, 7, 1, 8, 36, 0, 1, 0, 5, 6, 1, 2
        DC16 4, 7, 4, 2, 3, 54, 11, 0, 2, 4, 0, 3, 6, 1, 7, 6, 5, 0
        DC8 0, 0

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI NoFunction
        THUMB
??Decoder3GPP??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock0
        REQUIRE Decoder3GPP
//   31 #include "rom_dec.h"
//   32 
//   33 /*
//   34  * definition of constants
//   35  */
//   36 #define EHF_MASK 0x0008 /* encoder homing frame pattern */
//   37 typedef
//   38 
//   39 struct
//   40 {
//   41    int reset_flag_old;   /* previous was homing frame */
//   42 
//   43 
//   44    enum RXFrameType prev_ft;   /* previous frame type */
//   45    enum Mode prev_mode;   /* previous mode */
//   46    void *decoder_State;   /* Points decoder state */
//   47 
//   48 
//   49 }dec_interface_State;
//   50 
//   51 #ifdef ETSI
//   52 
//   53 
//   54 /*
//   55  * Bin2Int
//   56  *
//   57  *
//   58  * Parameters:
//   59  *    no_of_bits        I: number of bits associated with value
//   60  *    bits              O: address where bits are written
//   61  *
//   62  * Function:
//   63  *    Read nuber of bits from the array and convert to integer.
//   64  *
//   65  * Returns:
//   66  *    value
//   67  */
//   68 static Word16 Bin2Int( Word16 no_of_bits, Word16 *bitstream )
//   69 {
//   70    Word32 value, i, bit;
//   71 
//   72 
//   73    value = 0;
//   74 
//   75    for ( i = 0; i < no_of_bits; i++ ) {
//   76       value = value << 1;
//   77       bit = *bitstream++;
//   78 
//   79       if ( bit == 0x1 )
//   80          value = value + 1;
//   81    }
//   82    return( Word16 )( value );
//   83 }
//   84 
//   85 
//   86 /*
//   87  * Bits2Prm
//   88  *
//   89  *
//   90  * Parameters:
//   91  *    mode              I: AMR mode
//   92  *    bits              I: serial bits
//   93  *    param             O: AMR parameters
//   94  *
//   95  * Function:
//   96  *    Retrieves the vector of encoder parameters from
//   97  *    the received serial bits in a frame.
//   98  *
//   99  * Returns:
//  100  *    void
//  101  */
//  102 static void Bits2Prm( enum Mode mode, Word16 bits[], Word16 prm[] )
//  103 {
//  104    Word32 i;
//  105 
//  106 
//  107    switch ( mode ) {
//  108       case MR122:
//  109          for ( i = 0; i < PRMNO_MR122; i++ ) {
//  110             prm[i] = Bin2Int( bitno_MR122[i], bits );
//  111             bits += bitno_MR122[i];
//  112          }
//  113          break;
//  114 
//  115       case MR102:
//  116          for ( i = 0; i < PRMNO_MR102; i++ ) {
//  117             prm[i] = Bin2Int( bitno_MR102[i], bits );
//  118             bits += bitno_MR102[i];
//  119          }
//  120          break;
//  121 
//  122       case MR795:
//  123          for ( i = 0; i < PRMNO_MR795; i++ ) {
//  124             prm[i] = Bin2Int( bitno_MR795[i], bits );
//  125             bits += bitno_MR795[i];
//  126          }
//  127          break;
//  128 
//  129       case MR74:
//  130          for ( i = 0; i < PRMNO_MR74; i++ ) {
//  131             prm[i] = Bin2Int( bitno_MR74[i], bits );
//  132             bits += bitno_MR74[i];
//  133          }
//  134          break;
//  135 
//  136       case MR67:
//  137          for ( i = 0; i < PRMNO_MR67; i++ ) {
//  138             prm[i] = Bin2Int( bitno_MR67[i], bits );
//  139             bits += bitno_MR67[i];
//  140          }
//  141          break;
//  142 
//  143       case MR59:
//  144          for ( i = 0; i < PRMNO_MR59; i++ ) {
//  145             prm[i] = Bin2Int( bitno_MR59[i], bits );
//  146             bits += bitno_MR59[i];
//  147          }
//  148          break;
//  149 
//  150       case MR515:
//  151          for ( i = 0; i < PRMNO_MR515; i++ ) {
//  152             prm[i] = Bin2Int( bitno_MR515[i], bits );
//  153             bits += bitno_MR515[i];
//  154          }
//  155          break;
//  156 
//  157       case MR475:
//  158          for ( i = 0; i < PRMNO_MR475; i++ ) {
//  159             prm[i] = Bin2Int( bitno_MR475[i], bits );
//  160             bits += bitno_MR475[i];
//  161          }
//  162          break;
//  163 
//  164       case MRDTX:
//  165          for ( i = 0; i < PRMNO_MRDTX; i++ ) {
//  166             prm[i] = Bin2Int( bitno_MRDTX[i], bits );
//  167             bits += bitno_MRDTX[i];
//  168          }
//  169          break;
//  170    }
//  171    return;
//  172 }
//  173 
//  174 #else
//  175 
//  176 
//  177 /*
//  178  * Decoder3GPP
//  179  *
//  180  *
//  181  * Parameters:
//  182  *    param             O: AMR parameters
//  183  *    stream            I: input bitstream
//  184  *    frame_type        O: frame type
//  185  *    speech_mode       O: speech mode in DTX
//  186  *
//  187  * Function:
//  188  *    Resets state memory
//  189  *
//  190  * Returns:
//  191  *    mode              used mode
//  192  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock1 Using cfiCommon1
        CFI Function Decoder3GPP
        ARM
//  193 enum Mode Decoder3GPP( Word16 *param, UWord8 *stream, enum RXFrameType
//  194                       *frame_type, enum Mode *speech_mode )
//  195 {
Decoder3GPP:
        PUSH     {R4-R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
        MOV      R4,R0
        MOV      R5,R1
        MOV      R6,R2
        MOV      R7,R3
//  196    enum Mode mode;
//  197    Word32 j;
//  198    Word16 *mask;
//  199 
//  200   
//  201    memset( param, 0, PRMNO_MR122 <<1 );
        MOV      R2,#+114
        MOV      R1,#+0
        SWI      +187
//  202    mode = ( enum Mode )(0xF & *stream);
        LDRB     R1,[R5, #+0]
        AND      R0,R1,#0xF
//  203    *stream >>= 4;
        LSR      R1,R1,#+4
        STRB     R1,[R5, #+0]
//  204 
//  205    if ( mode == MRDTX ) {
        LDR      R1,??Decoder3GPP_0  ;; order_MR475
        CMP      R0,#+8
        BNE      ??Decoder3GPP_1
//  206       mask = order_MRDTX;
        MOV      R2,#+80
        ORR      R2,R2,#0x1500
        ADD      R1,R2,R1
//  207 
//  208       for ( j = 5; j < 40; j++ ) {
        MOV      R2,#+5
//  209          if ( *stream & 0x1 )
??Decoder3GPP_2:
        LDRB     R3,[R5, #+0]
        TST      R3,#0x1
        BEQ      ??Decoder3GPP_3
//  210             param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
        LDRSH    R12,[R1, #+0]
        LDRSH    R3,[R1, #+0]
        LDRSH    LR,[R1, #+2]
        ADD      R12,R4,R12, LSL #+1
        LDRSH    R12,[R12, #+0]
        ADD      R3,R4,R3, LSL #+1
        ADD      R12,LR,R12
        STRH     R12,[R3, #+0]
//  211          mask += 2;
??Decoder3GPP_3:
        ADD      R1,R1,#+4
//  212 
//  213          if ( j % 8 )
        ASR      R3,R2,#+2
        ADD      R3,R2,R3, LSR #+29
        ASR      R3,R3,#+3
        SUBS     R3,R2,R3, LSL #+3
        BEQ      ??Decoder3GPP_4
//  214             *stream >>= 1;
        LDRB     R3,[R5, #+0]
        LSR      R3,R3,#+1
        STRB     R3,[R5, #+0]
        B        ??Decoder3GPP_5
//  215          else
//  216             stream++;
??Decoder3GPP_4:
        ADD      R5,R5,#+1
//  217       }
??Decoder3GPP_5:
        ADD      R2,R2,#+1
        CMP      R2,#+40
        BLT      ??Decoder3GPP_2
//  218 
//  219       /* get SID type bit */
//  220 
//  221       *frame_type = RX_SID_FIRST;
        MOV      R1,#+4
        STRB     R1,[R6, #+0]
//  222       if (*stream)
        LDRB     R1,[R5, #+0]
        CMP      R1,#+0
//  223          *frame_type = RX_SID_UPDATE;
        MOVNE    R1,#+5
        STRBNE   R1,[R6, #+0]
//  224 
//  225       /* since there is update, use it */
//  226       /* *frame_type = RX_SID_UPDATE; */
//  227       stream++;
//  228 
//  229       /* speech mode indicator */
//  230       *speech_mode = ( enum Mode )*stream;
        LDRB     R1,[R5, #+1]
        STRB     R1,[R7, #+0]
        POP      {R4-R7,PC}
//  231    }
//  232    else if ( mode == 15 ) {
??Decoder3GPP_1:
        CMP      R0,#+15
//  233       *frame_type = RX_NO_DATA;
        MOVEQ    R1,#+7
        BEQ      ??Decoder3GPP_6
//  234    }
//  235    else if ( mode == MR475 ) {
        MOVS     R2,R0
        BNE      ??Decoder3GPP_7
//  236       mask = order_MR475;
//  237 
//  238       for ( j = 5; j < 100; j++ ) {
        MOV      R2,#+5
//  239          if ( *stream & 0x1 )
??Decoder3GPP_8:
        LDRB     R3,[R5, #+0]
        TST      R3,#0x1
        BEQ      ??Decoder3GPP_9
//  240             param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
        LDRSH    R7,[R1, #+0]
        LDRSH    R3,[R1, #+0]
        LDRSH    R12,[R1, #+2]
        ADD      R7,R4,R7, LSL #+1
        LDRSH    R7,[R7, #+0]
        ADD      R3,R4,R3, LSL #+1
        ADD      R7,R12,R7
        STRH     R7,[R3, #+0]
//  241          mask += 2;
??Decoder3GPP_9:
        ADD      R1,R1,#+4
//  242 
//  243          if ( j % 8 )
        ASR      R3,R2,#+2
        ADD      R3,R2,R3, LSR #+29
        ASR      R3,R3,#+3
        SUBS     R3,R2,R3, LSL #+3
        BEQ      ??Decoder3GPP_10
//  244             *stream >>= 1;
        LDRB     R3,[R5, #+0]
        LSR      R3,R3,#+1
        STRB     R3,[R5, #+0]
        B        ??Decoder3GPP_11
//  245          else
//  246             stream++;
??Decoder3GPP_10:
        ADD      R5,R5,#+1
//  247       }
??Decoder3GPP_11:
        ADD      R2,R2,#+1
        CMP      R2,#+100
        BLT      ??Decoder3GPP_8
//  248       *frame_type = RX_SPEECH_GOOD;
??Decoder3GPP_12:
        MOV      R1,#+0
??Decoder3GPP_6:
        STRB     R1,[R6, #+0]
        POP      {R4-R7,PC}
//  249    }
//  250    else if ( mode == MR515 ) {
??Decoder3GPP_7:
        CMP      R0,#+1
        BNE      ??Decoder3GPP_13
//  251       mask = order_MR515;
        ADD      R1,R1,#+380
//  252 
//  253       for ( j = 5; j < 108; j++ ) {
        MOV      R2,#+5
        B        ??Decoder3GPP_14
//  254          if ( *stream & 0x1 )
//  255             param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
//  256          mask += 2;
//  257 
//  258          if ( j % 8 )
//  259             *stream >>= 1;
//  260          else
//  261             stream++;
??Decoder3GPP_15:
        ADD      R5,R5,#+1
??Decoder3GPP_16:
        ADD      R2,R2,#+1
        CMP      R2,#+108
        BGE      ??Decoder3GPP_12
??Decoder3GPP_14:
        LDRB     R3,[R5, #+0]
        TST      R3,#0x1
        BEQ      ??Decoder3GPP_17
        LDRSH    R7,[R1, #+0]
        LDRSH    R3,[R1, #+0]
        LDRSH    R12,[R1, #+2]
        ADD      R7,R4,R7, LSL #+1
        LDRSH    R7,[R7, #+0]
        ADD      R3,R4,R3, LSL #+1
        ADD      R7,R12,R7
        STRH     R7,[R3, #+0]
??Decoder3GPP_17:
        ADD      R1,R1,#+4
        ASR      R3,R2,#+2
        ADD      R3,R2,R3, LSR #+29
        ASR      R3,R3,#+3
        SUBS     R3,R2,R3, LSL #+3
        BEQ      ??Decoder3GPP_15
        LDRB     R3,[R5, #+0]
        LSR      R3,R3,#+1
        STRB     R3,[R5, #+0]
        B        ??Decoder3GPP_16
//  262       }
//  263       *frame_type = RX_SPEECH_GOOD;
//  264    }
//  265    else if ( mode == MR59 ) {
??Decoder3GPP_13:
        CMP      R0,#+2
        BNE      ??Decoder3GPP_18
//  266       mask = order_MR59;
        ADD      R1,R1,#+792
//  267 
//  268       for ( j = 5; j < 123; j++ ) {
        MOV      R2,#+5
        B        ??Decoder3GPP_19
//  269          if ( *stream & 0x1 )
//  270             param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
//  271          mask += 2;
//  272 
//  273          if ( j % 8 )
//  274             *stream >>= 1;
//  275          else
//  276             stream++;
??Decoder3GPP_20:
        ADD      R5,R5,#+1
??Decoder3GPP_21:
        ADD      R2,R2,#+1
        CMP      R2,#+123
        BGE      ??Decoder3GPP_12
??Decoder3GPP_19:
        LDRB     R3,[R5, #+0]
        TST      R3,#0x1
        BEQ      ??Decoder3GPP_22
        LDRSH    R7,[R1, #+0]
        LDRSH    R3,[R1, #+0]
        LDRSH    R12,[R1, #+2]
        ADD      R7,R4,R7, LSL #+1
        LDRSH    R7,[R7, #+0]
        ADD      R3,R4,R3, LSL #+1
        ADD      R7,R12,R7
        STRH     R7,[R3, #+0]
??Decoder3GPP_22:
        ADD      R1,R1,#+4
        ASR      R3,R2,#+2
        ADD      R3,R2,R3, LSR #+29
        ASR      R3,R3,#+3
        SUBS     R3,R2,R3, LSL #+3
        BEQ      ??Decoder3GPP_20
        LDRB     R3,[R5, #+0]
        LSR      R3,R3,#+1
        STRB     R3,[R5, #+0]
        B        ??Decoder3GPP_21
//  277       }
//  278       *frame_type = RX_SPEECH_GOOD;
//  279    }
//  280    else if ( mode == MR67 ) {
??Decoder3GPP_18:
        CMP      R0,#+3
        BNE      ??Decoder3GPP_23
//  281       mask = order_MR67;
        ADD      R1,R1,#+1264
//  282 
//  283       for ( j = 5; j < 139; j++ ) {
        MOV      R2,#+5
        B        ??Decoder3GPP_24
//  284          if ( *stream & 0x1 )
//  285             param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
//  286          mask += 2;
//  287 
//  288          if ( j % 8 )
//  289             *stream >>= 1;
//  290          else
//  291             stream++;
??Decoder3GPP_25:
        ADD      R5,R5,#+1
??Decoder3GPP_26:
        ADD      R2,R2,#+1
        CMP      R2,#+139
        BGE      ??Decoder3GPP_12
??Decoder3GPP_24:
        LDRB     R3,[R5, #+0]
        TST      R3,#0x1
        BEQ      ??Decoder3GPP_27
        LDRSH    R7,[R1, #+0]
        LDRSH    R3,[R1, #+0]
        LDRSH    R12,[R1, #+2]
        ADD      R7,R4,R7, LSL #+1
        LDRSH    R7,[R7, #+0]
        ADD      R3,R4,R3, LSL #+1
        ADD      R7,R12,R7
        STRH     R7,[R3, #+0]
??Decoder3GPP_27:
        ADD      R1,R1,#+4
        ASR      R3,R2,#+2
        ADD      R3,R2,R3, LSR #+29
        ASR      R3,R3,#+3
        SUBS     R3,R2,R3, LSL #+3
        BEQ      ??Decoder3GPP_25
        LDRB     R3,[R5, #+0]
        LSR      R3,R3,#+1
        STRB     R3,[R5, #+0]
        B        ??Decoder3GPP_26
//  292       }
//  293       *frame_type = RX_SPEECH_GOOD;
//  294    }
//  295    else if ( mode == MR74 ) {
??Decoder3GPP_23:
        CMP      R0,#+4
        BNE      ??Decoder3GPP_28
//  296       mask = order_MR74;
        MOV      R2,#+8
        ORR      R2,R2,#0x700
        ADD      R1,R2,R1
//  297 
//  298       for ( j = 5; j < 153; j++ ) {
        MOV      R2,#+5
        B        ??Decoder3GPP_29
//  299          if ( *stream & 0x1 )
//  300             param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
//  301          mask += 2;
//  302 
//  303          if ( j % 8 )
//  304             *stream >>= 1;
//  305          else
//  306             stream++;
??Decoder3GPP_30:
        ADD      R5,R5,#+1
??Decoder3GPP_31:
        ADD      R2,R2,#+1
        CMP      R2,#+153
        BGE      ??Decoder3GPP_12
??Decoder3GPP_29:
        LDRB     R3,[R5, #+0]
        TST      R3,#0x1
        BEQ      ??Decoder3GPP_32
        LDRSH    R7,[R1, #+0]
        LDRSH    R3,[R1, #+0]
        LDRSH    R12,[R1, #+2]
        ADD      R7,R4,R7, LSL #+1
        LDRSH    R7,[R7, #+0]
        ADD      R3,R4,R3, LSL #+1
        ADD      R7,R12,R7
        STRH     R7,[R3, #+0]
??Decoder3GPP_32:
        ADD      R1,R1,#+4
        ASR      R3,R2,#+2
        ADD      R3,R2,R3, LSR #+29
        ASR      R3,R3,#+3
        SUBS     R3,R2,R3, LSL #+3
        BEQ      ??Decoder3GPP_30
        LDRB     R3,[R5, #+0]
        LSR      R3,R3,#+1
        STRB     R3,[R5, #+0]
        B        ??Decoder3GPP_31
//  307       }
//  308       *frame_type = RX_SPEECH_GOOD;
//  309    }
//  310    else if ( mode == MR795 ) {
??Decoder3GPP_28:
        CMP      R0,#+5
        BNE      ??Decoder3GPP_33
//  311       mask = order_MR795;
        MOV      R2,#+88
        ORR      R2,R2,#0x900
        ADD      R1,R2,R1
//  312 
//  313       for ( j = 5; j < 164; j++ ) {
        MOV      R2,#+5
        B        ??Decoder3GPP_34
//  314          if ( *stream & 0x1 )
//  315             param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
//  316          mask += 2;
//  317 
//  318          if ( j % 8 )
//  319             *stream >>= 1;
//  320          else
//  321             stream++;
??Decoder3GPP_35:
        ADD      R5,R5,#+1
??Decoder3GPP_36:
        ADD      R2,R2,#+1
        CMP      R2,#+164
        BGE      ??Decoder3GPP_12
??Decoder3GPP_34:
        LDRB     R3,[R5, #+0]
        TST      R3,#0x1
        BEQ      ??Decoder3GPP_37
        LDRSH    R7,[R1, #+0]
        LDRSH    R3,[R1, #+0]
        LDRSH    R12,[R1, #+2]
        ADD      R7,R4,R7, LSL #+1
        LDRSH    R7,[R7, #+0]
        ADD      R3,R4,R3, LSL #+1
        ADD      R7,R12,R7
        STRH     R7,[R3, #+0]
??Decoder3GPP_37:
        ADD      R1,R1,#+4
        ASR      R3,R2,#+2
        ADD      R3,R2,R3, LSR #+29
        ASR      R3,R3,#+3
        SUBS     R3,R2,R3, LSL #+3
        BEQ      ??Decoder3GPP_35
        LDRB     R3,[R5, #+0]
        LSR      R3,R3,#+1
        STRB     R3,[R5, #+0]
        B        ??Decoder3GPP_36
//  322       }
//  323       *frame_type = RX_SPEECH_GOOD;
//  324    }
//  325    else if ( mode == MR102 ) {
??Decoder3GPP_33:
        CMP      R0,#+6
        BNE      ??Decoder3GPP_38
//  326       mask = order_MR102;
        ADD      R1,R1,#+3664
//  327 
//  328       for ( j = 5; j < 209; j++ ) {
        MOV      R2,#+5
        B        ??Decoder3GPP_39
//  329          if ( *stream & 0x1 )
//  330             param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
//  331          mask += 2;
//  332 
//  333          if ( j % 8 )
//  334             *stream >>= 1;
//  335          else
//  336             stream++;
??Decoder3GPP_40:
        ADD      R5,R5,#+1
??Decoder3GPP_41:
        ADD      R2,R2,#+1
        CMP      R2,#+209
        BGE      ??Decoder3GPP_12
??Decoder3GPP_39:
        LDRB     R3,[R5, #+0]
        TST      R3,#0x1
        BEQ      ??Decoder3GPP_42
        LDRSH    R7,[R1, #+0]
        LDRSH    R3,[R1, #+0]
        LDRSH    R12,[R1, #+2]
        ADD      R7,R4,R7, LSL #+1
        LDRSH    R7,[R7, #+0]
        ADD      R3,R4,R3, LSL #+1
        ADD      R7,R12,R7
        STRH     R7,[R3, #+0]
??Decoder3GPP_42:
        ADD      R1,R1,#+4
        ASR      R3,R2,#+2
        ADD      R3,R2,R3, LSR #+29
        ASR      R3,R3,#+3
        SUBS     R3,R2,R3, LSL #+3
        BEQ      ??Decoder3GPP_40
        LDRB     R3,[R5, #+0]
        LSR      R3,R3,#+1
        STRB     R3,[R5, #+0]
        B        ??Decoder3GPP_41
//  337       }
//  338       *frame_type = RX_SPEECH_GOOD;
//  339    }
//  340    else if ( mode == MR122 ) {
??Decoder3GPP_38:
        CMP      R0,#+7
        BNE      ??Decoder3GPP_43
//  341       mask = order_MR122;
        ADD      R1,R1,#+4480
//  342 
//  343       for ( j = 5; j < 249; j++ ) {
        MOV      R2,#+5
        B        ??Decoder3GPP_44
//  344          if ( *stream & 0x1 )
//  345             param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
//  346          mask += 2;
//  347 
//  348          if ( j % 8 )
//  349             *stream >>= 1;
//  350          else
//  351             stream++;
??Decoder3GPP_45:
        ADD      R5,R5,#+1
??Decoder3GPP_46:
        ADD      R2,R2,#+1
        CMP      R2,#+249
        BGE      ??Decoder3GPP_12
??Decoder3GPP_44:
        LDRB     R3,[R5, #+0]
        TST      R3,#0x1
        BEQ      ??Decoder3GPP_47
        LDRSH    R7,[R1, #+0]
        LDRSH    R3,[R1, #+0]
        LDRSH    R12,[R1, #+2]
        ADD      R7,R4,R7, LSL #+1
        LDRSH    R7,[R7, #+0]
        ADD      R3,R4,R3, LSL #+1
        ADD      R7,R12,R7
        STRH     R7,[R3, #+0]
??Decoder3GPP_47:
        ADD      R1,R1,#+4
        ASR      R3,R2,#+2
        ADD      R3,R2,R3, LSR #+29
        ASR      R3,R3,#+3
        SUBS     R3,R2,R3, LSL #+3
        BEQ      ??Decoder3GPP_45
        LDRB     R3,[R5, #+0]
        LSR      R3,R3,#+1
        STRB     R3,[R5, #+0]
        B        ??Decoder3GPP_46
//  352       }
//  353       *frame_type = RX_SPEECH_GOOD;
//  354    }
//  355    else
//  356       *frame_type = RX_SPEECH_BAD;
??Decoder3GPP_43:
        MOV      R1,#+3
        STRB     R1,[R6, #+0]
        POP      {R4-R7,PC}
        DATA
??Decoder3GPP_0:
        DC32     order_MR475
        CFI EndBlock cfiBlock1
//  357    return mode;
//  358 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock2 Using cfiCommon0
        CFI NoFunction
        THUMB
??Decoder_Interface_reset??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock2
        REQUIRE Decoder_Interface_reset
//  359 #endif
//  360 
//  361 
//  362 /*
//  363  * Decoder_Interface_reset
//  364  *
//  365  *
//  366  * Parameters:
//  367  *    st                O: state struct
//  368  *
//  369  * Function:
//  370  *    Reset homing frame counter
//  371  *
//  372  * Returns:
//  373  *    void
//  374  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock3 Using cfiCommon1
        CFI Function Decoder_Interface_reset
        ARM
//  375 void Decoder_Interface_reset( dec_interface_State *st )
//  376 {
//  377    st->reset_flag_old = 1;
Decoder_Interface_reset:
        MOV      R1,#+1
        STR      R1,[R0, #+0]
//  378    st->prev_ft = RX_SPEECH_GOOD;
        MOV      R1,#+0
        STRB     R1,[R0, #+4]
//  379    st->prev_mode = MR475;   /* minimum bitrate */
        STRB     R1,[R0, #+5]
//  380 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock3

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock4 Using cfiCommon0
        CFI NoFunction
        THUMB
??Decoder_Interface_init??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock4
        REQUIRE Decoder_Interface_init
//  381 
//  382 
//  383 /*
//  384  * Decoder_Interface_init
//  385  *
//  386  *
//  387  * Parameters:
//  388  *    void
//  389  *
//  390  * Function:
//  391  *    Allocates state memory and initializes state memory
//  392  *
//  393  * Returns:
//  394  *    success           : pointer to structure
//  395  *    failure           : NULL
//  396  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock5 Using cfiCommon1
        CFI Function Decoder_Interface_init
        ARM
//  397 void * Decoder_Interface_init( void )
//  398 {
Decoder_Interface_init:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  399    dec_interface_State * s;
//  400 
//  401    /* allocate memory */
//  402    if ( ( s = ( dec_interface_State * ) malloc( sizeof( dec_interface_State ) ) ) ==
//  403          NULL ) {
        MOV      R0,#+12
        SWI      +20
        MOVS     R4,R0
        BEQ      ??Decoder_Interface_init_0
//  404       //fprintf( stderr, "Decoder_Interface_init: "
//  405            // "can not malloc state structure\n" );
//  406       return NULL;
//  407    }
//  408    s->decoder_State = Speech_Decode_Frame_init( );
        _BLF     Speech_Decode_Frame_init,??Speech_Decode_Frame_init??rA
        STR      R0,[R4, #+8]
//  409 
//  410    if ( s->decoder_State == NULL ) {
        CMP      R0,#+0
        MOV      R0,R4
        BNE      ??Decoder_Interface_init_1
//  411       mfree( s );
        SWI      +21
//  412       return NULL;
??Decoder_Interface_init_0:
        MOV      R0,#+0
        POP      {R4,PC}
//  413    }
//  414    Decoder_Interface_reset( s );
??Decoder_Interface_init_1:
        BL       Decoder_Interface_reset
//  415    return s;
        MOV      R0,R4
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock5
//  416 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock6 Using cfiCommon0
        CFI NoFunction
        THUMB
??Decoder_Interface_exit??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock6
        REQUIRE Decoder_Interface_exit
//  417 
//  418 
//  419 /*
//  420  * Decoder_Interface_exit
//  421  *
//  422  *
//  423  * Parameters:
//  424  *    state                I: state structure
//  425  *
//  426  * Function:
//  427  *    The memory used for state memory is mfreed
//  428  *
//  429  * Returns:
//  430  *    Void
//  431  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock7 Using cfiCommon1
        CFI Function Decoder_Interface_exit
        ARM
//  432 void Decoder_Interface_exit( void *state )
//  433 {
Decoder_Interface_exit:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
        MOV      R4,R0
//  434    dec_interface_State * s;
//  435    s = ( dec_interface_State * )state;
//  436 
//  437    /* mfree memory */
//  438    Speech_Decode_Frame_exit(s->decoder_State );
        LDR      R0,[R4, #+8]
        _BLF     Speech_Decode_Frame_exit,??Speech_Decode_Frame_exit??rA
//  439    mfree( s );
        MOV      R0,R4
        SWI      +21
//  440    s = NULL;
//  441    state = NULL;
//  442 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock7

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock8 Using cfiCommon0
        CFI NoFunction
        THUMB
??Decoder_Interface_Decode??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock8
        REQUIRE Decoder_Interface_Decode
//  443 
//  444 
//  445 /*
//  446  * Decoder_Interface_Decode
//  447  *
//  448  *
//  449  * Parameters:
//  450  *    st                B: state structure
//  451  *    bits              I: bit stream
//  452  *    synth             O: synthesized speech
//  453  *    bfi               I: bad frame indicator
//  454  *
//  455  * Function:
//  456  *    Decode bit stream to synthesized speech
//  457  *
//  458  * Returns:
//  459  *    Void
//  460  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock9 Using cfiCommon1
        CFI Function Decoder_Interface_Decode
        ARM
//  461 void Decoder_Interface_Decode( void *st,
//  462 
//  463 #ifndef ETSI
//  464       UWord8 *bits,
//  465 
//  466 #else
//  467       Word16 *bits,
//  468 #endif
//  469 
//  470       Word16 *synth, int bfi)
//  471 {
Decoder_Interface_Decode:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
        SUB      SP,SP,#+120
        CFI CFA R13+156
        MOV      R4,R0
        MOV      R5,R2
        MOV      R9,R3
//  472    enum Mode mode;   /* AMR mode */
//  473 
//  474 #ifndef ETSI
//  475    enum Mode speech_mode = MR475;   /* speech mode */
        MOV      R6,#+0
        STRB     R6,[SP, #+1]
//  476 #endif
//  477 
//  478    Word16 prm[PRMNO_MR122];   /* AMR parameters */
//  479 
//  480    enum RXFrameType frame_type;   /* frame type */
//  481    dec_interface_State * s;   /* pointer to structure */
//  482 
//  483    const Word16 *homing;   /* pointer to homing frame */
//  484    Word16 homingSize;   /* frame size for homing frame */
//  485    Word32 i;   /* counter */
//  486    Word32 resetFlag = 1;   /* homing frame */
//  487 
//  488 
//  489    s = ( dec_interface_State * )st;
//  490 
//  491 #ifndef ETSI
//  492 
//  493    /*
//  494     * extract mode information and frametype,
//  495     * octets to parameters
//  496     */
//  497    mode = Decoder3GPP( prm, bits, &frame_type, &speech_mode );
        ADD      R3,SP,#+1
        MOV      R2,SP
        ADD      R0,SP,#+4
        BL       Decoder3GPP
//  498 
//  499    /*
//  500     * if no mode information
//  501     * guess one from the previous frame
//  502     */
//  503    if ( frame_type == RX_SPEECH_BAD ) {
        LDRB     R1,[SP, #+0]
        MOV      R7,#+1
        MOV      R8,R0
        MOV      R0,#+8
        CMP      R1,#+3
        BNE      ??Decoder_Interface_Decode_2
//  504       if ( s->prev_ft > 3 ) {
        LDRB     R1,[R4, #+4]
        CMP      R1,#+4
        BCC      ??Decoder_Interface_Decode_3
//  505          frame_type = RX_SID_BAD;
        MOV      R2,#+6
        STRB     R2,[SP, #+0]
//  506          mode = MRDTX;
        MOV      R8,#+8
        B        ??Decoder_Interface_Decode_4
//  507       }
//  508       else {
//  509          mode = s->prev_mode;
//  510       }
//  511    }
//  512    else if ( frame_type == RX_NO_DATA ) {
??Decoder_Interface_Decode_2:
        CMP      R1,#+7
        BNE      ??Decoder_Interface_Decode_4
//  513       mode = s->prev_mode;
??Decoder_Interface_Decode_3:
        LDRB     R8,[R4, #+5]
//  514    }
//  515 
//  516    if ( bfi == 1 ) {
??Decoder_Interface_Decode_4:
        CMP      R9,#+1
        BNE      ??Decoder_Interface_Decode_5
//  517       if ( mode < 8 ) {
        CMP      R8,#+8
//  518          frame_type = RX_SPEECH_BAD;
        MOVCC    R2,#+3
        BCC      ??Decoder_Interface_Decode_6
//  519       }
//  520       else if ( mode != 15 ) {
        CMP      R8,#+15
        BEQ      ??Decoder_Interface_Decode_5
//  521          frame_type = RX_SID_BAD;
        MOV      R2,#+6
??Decoder_Interface_Decode_6:
        STRB     R2,[SP, #+0]
//  522       }
//  523    }
//  524 
//  525 #else
//  526    bfi = 0;
//  527    frame_type = bits[0];
//  528 
//  529    switch ( frame_type ) {
//  530       case 0:
//  531          frame_type = RX_SPEECH_GOOD;
//  532          mode = bits[245];
//  533          Bits2Prm( mode, &bits[1], prm );
//  534          break;
//  535 
//  536       case 1:
//  537          frame_type = RX_SID_FIRST;
//  538          mode = s->prev_mode;
//  539          break;
//  540 
//  541       case 2:
//  542          frame_type = RX_SID_UPDATE;
//  543          mode = s->prev_mode;
//  544          Bits2Prm( MRDTX, &bits[1], prm );
//  545          break;
//  546 
//  547       case 3:
//  548          frame_type = RX_NO_DATA;
//  549          mode = s->prev_mode;
//  550          break;
//  551    }
//  552 
//  553 #endif
//  554 
//  555    /* test for homing frame */
//  556    if ( s->reset_flag_old == 1 ) {
??Decoder_Interface_Decode_5:
        LDR      R1,[R4, #+0]
        LDR      R11,??Decoder_Interface_Decode_7  ;; dhf_MR475
        MOV      R9,R8
        MOV      R10,#+324
        CMP      R1,#+1
        BNE      ??Decoder_Interface_Decode_8
//  557       switch ( mode ) {
        MOV      R1,R9
        CMP      R1,#+7
        BHI      ??Decoder_Interface_Decode_9
        ADR      R2,??Decoder_Interface_Decode_0
        LDRB     R2,[R2, R1]
        ADD      PC,PC,R2, LSL #+2
        DATA
??Decoder_Interface_Decode_0:
        DC8      +19,+17,+15,+13
        DC8      +10,+7,+4,+1
        ARM
//  558          case MR122:
//  559             homing = dhf_MR122;
??Decoder_Interface_Decode_10:
        ADD      R1,R10,R11
//  560             homingSize = 18;
        MOV      R3,#+18
        B        ??Decoder_Interface_Decode_11
//  561             break;
//  562 
//  563          case MR102:
//  564             homing = dhf_MR102;
??Decoder_Interface_Decode_12:
        ADD      R1,R11,#+244
//  565             homingSize = 12;
        MOV      R3,#+12
        B        ??Decoder_Interface_Decode_11
//  566             break;
//  567 
//  568          case MR795:
//  569             homing = dhf_MR795;
??Decoder_Interface_Decode_13:
        ADD      R1,R11,#+196
//  570             homingSize = 8;
        MOV      R3,#+8
        B        ??Decoder_Interface_Decode_11
//  571             break;
//  572 
//  573          case MR74:
//  574             homing = dhf_MR74;
??Decoder_Interface_Decode_14:
        ADD      R1,R11,#+156
//  575             homingSize = 7;
??Decoder_Interface_Decode_15:
        MOV      R3,#+7
        B        ??Decoder_Interface_Decode_11
//  576             break;
//  577 
//  578          case MR67:
//  579             homing = dhf_MR67;
??Decoder_Interface_Decode_16:
        ADD      R1,R11,#+116
//  580             homingSize = 7;
        B        ??Decoder_Interface_Decode_15
//  581             break;
//  582 
//  583          case MR59:
//  584             homing = dhf_MR59;
??Decoder_Interface_Decode_17:
        ADD      R1,R11,#+76
//  585             homingSize = 7;
??Decoder_Interface_Decode_18:
        B        ??Decoder_Interface_Decode_15
//  586             break;
//  587 
//  588          case MR515:
//  589             homing = dhf_MR515;
??Decoder_Interface_Decode_19:
        ADD      R1,R11,#+36
//  590             homingSize = 7;
        B        ??Decoder_Interface_Decode_15
//  591             break;
//  592 
//  593          case MR475:
//  594             homing = dhf_MR475;
??Decoder_Interface_Decode_20:
        MOV      R1,R11
//  595             homingSize = 7;
        B        ??Decoder_Interface_Decode_15
//  596             break;
//  597 
//  598          default:
//  599             homing = NULL;
??Decoder_Interface_Decode_9:
        MOV      R1,#+0
//  600             homingSize = 0;
        MOV      R3,R1
//  601             break;
//  602       }
//  603 
//  604       for ( i = 0; i < homingSize; i++ ) {
??Decoder_Interface_Decode_11:
        MOV      R2,#+0
        B        ??Decoder_Interface_Decode_21
??Decoder_Interface_Decode_22:
        ADD      R2,R2,#+1
??Decoder_Interface_Decode_21:
        CMP      R2,R3
        BGE      ??Decoder_Interface_Decode_23
//  605          resetFlag = prm[i] ^ homing[i];
        ADD      R7,SP,#+4
        ADD      R7,R7,R2, LSL #+1
        LDRSH    R7,[R7, #+0]
        ADD      R12,R1,R2, LSL #+1
        LDRSH    R12,[R12, #+0]
        EORS     R7,R12,R7
//  606 
//  607          if ( resetFlag )
        BEQ      ??Decoder_Interface_Decode_22
//  608             break;
//  609       }
//  610    }
//  611 
//  612    if ( ( resetFlag == 0 ) && ( s->reset_flag_old != 0 ) ) {
??Decoder_Interface_Decode_23:
        CMP      R7,#+0
        BNE      ??Decoder_Interface_Decode_8
        LDR      R1,[R4, #+0]
        CMP      R1,#+0
        BEQ      ??Decoder_Interface_Decode_8
//  613       for ( i = 0; i < 160; i++ ) {
        MOV      R2,#+0
//  614          synth[i] = EHF_MASK;
??Decoder_Interface_Decode_24:
        ADD      R1,R5,R2, LSL #+1
        STRH     R0,[R1, #+0]
//  615       }
        ADD      R2,R2,#+1
        CMP      R2,#+160
        BGE      ??Decoder_Interface_Decode_25
        B        ??Decoder_Interface_Decode_24
//  616    }
//  617    else
//  618       Speech_Decode_Frame( s->decoder_State, mode, prm, frame_type, synth );
??Decoder_Interface_Decode_8:
        PUSH     {R5}
        CFI CFA R13+160
        LDRB     R3,[SP, #+4]
        LDR      R0,[R4, #+8]
        ADD      R2,SP,#+8
        MOV      R1,R8
        _BLF     Speech_Decode_Frame,??Speech_Decode_Frame??rA
        ADD      SP,SP,#+4
        CFI CFA R13+156
//  619 
//  620    if ( s->reset_flag_old == 0 ) {
??Decoder_Interface_Decode_25:
        LDR      R0,[R4, #+0]
        CMP      R0,#+0
        BNE      ??Decoder_Interface_Decode_26
//  621       /* check whole frame */
//  622       switch ( mode ) {
        CMP      R9,#+7
        BHI      ??Decoder_Interface_Decode_27
        ADR      R0,??Decoder_Interface_Decode_1
        LDRB     R0,[R0, R9]
        ADD      PC,PC,R0, LSL #+2
        DATA
??Decoder_Interface_Decode_1:
        DC8      +19,+17,+15,+13
        DC8      +10,+7,+4,+1
        ARM
//  623          case MR122:
//  624             homing = dhf_MR122;
??Decoder_Interface_Decode_28:
        ADD      R1,R10,R11
//  625             homingSize = PRMNO_MR122;
        MOV      R3,#+57
        B        ??Decoder_Interface_Decode_29
//  626             break;
//  627 
//  628          case MR102:
//  629             homing = dhf_MR102;
??Decoder_Interface_Decode_30:
        ADD      R1,R11,#+244
//  630             homingSize = PRMNO_MR102;
        MOV      R3,#+39
        B        ??Decoder_Interface_Decode_29
//  631             break;
//  632 
//  633          case MR795:
//  634             homing = dhf_MR795;
??Decoder_Interface_Decode_31:
        ADD      R1,R11,#+196
//  635             homingSize = PRMNO_MR795;
        MOV      R3,#+23
        B        ??Decoder_Interface_Decode_29
//  636             break;
//  637 
//  638          case MR74:
//  639             homing = dhf_MR74;
??Decoder_Interface_Decode_32:
        ADD      R1,R11,#+156
//  640             homingSize = PRMNO_MR74;
??Decoder_Interface_Decode_33:
        MOV      R3,#+19
        B        ??Decoder_Interface_Decode_29
//  641             break;
//  642 
//  643          case MR67:
//  644             homing = dhf_MR67;
??Decoder_Interface_Decode_34:
        ADD      R1,R11,#+116
//  645             homingSize = PRMNO_MR67;
        B        ??Decoder_Interface_Decode_33
//  646             break;
//  647 
//  648          case MR59:
//  649             homing = dhf_MR59;
??Decoder_Interface_Decode_35:
        ADD      R1,R11,#+76
//  650             homingSize = PRMNO_MR59;
        B        ??Decoder_Interface_Decode_33
//  651             break;
//  652 
//  653          case MR515:
//  654             homing = dhf_MR515;
??Decoder_Interface_Decode_36:
        ADD      R1,R11,#+36
//  655             homingSize = PRMNO_MR515;
        B        ??Decoder_Interface_Decode_33
//  656             break;
//  657 
//  658          case MR475:
//  659             homing = dhf_MR475;
??Decoder_Interface_Decode_37:
        MOV      R1,R11
//  660             homingSize = PRMNO_MR475;
        MOV      R3,#+17
        B        ??Decoder_Interface_Decode_29
//  661             break;
//  662 
//  663          default:
//  664             homing = NULL;
??Decoder_Interface_Decode_27:
        MOV      R1,#+0
//  665             homingSize = 0;
        MOV      R3,R1
//  666       }
//  667 
//  668       for ( i = 0; i < homingSize; i++ ) {
??Decoder_Interface_Decode_29:
        MOV      R2,#+0
        B        ??Decoder_Interface_Decode_38
??Decoder_Interface_Decode_39:
        ADD      R2,R2,#+1
??Decoder_Interface_Decode_38:
        CMP      R2,R3
        BGE      ??Decoder_Interface_Decode_26
//  669          resetFlag = prm[i] ^ homing[i];
        ADD      R0,SP,#+4
        ADD      R0,R0,R2, LSL #+1
        LDRSH    R0,[R0, #+0]
        ADD      R5,R1,R2, LSL #+1
        LDRSH    R5,[R5, #+0]
        EORS     R7,R5,R0
//  670 
//  671          if ( resetFlag )
        BEQ      ??Decoder_Interface_Decode_39
//  672             break;
//  673       }
//  674    }
//  675 
//  676    /* reset decoder if current frame is a homing frame */
//  677    if ( resetFlag == 0 ) {
??Decoder_Interface_Decode_26:
        CMP      R7,#+0
        BNE      ??Decoder_Interface_Decode_40
//  678       Speech_Decode_Frame_reset( s->decoder_State );
        LDR      R0,[R4, #+8]
        _BLF     Speech_Decode_Frame_reset,??Speech_Decode_Frame_reset??rA
        MOV      R0,#+1
        B        ??Decoder_Interface_Decode_41
//  679    }
//  680    s->reset_flag_old = !resetFlag;
??Decoder_Interface_Decode_40:
        MOV      R0,#+0
??Decoder_Interface_Decode_41:
        STR      R0,[R4, #+0]
//  681    s->prev_ft = frame_type;
        LDRB     R0,[SP, #+0]
        STRB     R0,[R4, #+4]
//  682    s->prev_mode = mode;
        STRB     R8,[R4, #+5]
//  683 }
        ADD      SP,SP,#+120
        CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        DATA
??Decoder_Interface_Decode_7:
        DC32     dhf_MR475
        CFI EndBlock cfiBlock9

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock10 Using cfiCommon1
        CFI NoFunction
        ARM
??Speech_Decode_Frame_init??rA:
        LDR      R12,??Subroutine5_0  ;; Speech_Decode_Frame_init
        BX       R12
        DATA
??Subroutine5_0:
        DC32     Speech_Decode_Frame_init
        CFI EndBlock cfiBlock10

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock11 Using cfiCommon1
        CFI NoFunction
        ARM
??Speech_Decode_Frame_exit??rA:
        LDR      R12,??Subroutine6_0  ;; Speech_Decode_Frame_exit
        BX       R12
        DATA
??Subroutine6_0:
        DC32     Speech_Decode_Frame_exit
        CFI EndBlock cfiBlock11

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock12 Using cfiCommon1
        CFI NoFunction
        ARM
??Speech_Decode_Frame??rA:
        LDR      R12,??Subroutine7_0  ;; Speech_Decode_Frame
        BX       R12
        DATA
??Subroutine7_0:
        DC32     Speech_Decode_Frame
        CFI EndBlock cfiBlock12

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock13 Using cfiCommon1
        CFI NoFunction
        ARM
??Speech_Decode_Frame_reset??rA:
        LDR      R12,??Subroutine8_0  ;; Speech_Decode_Frame_reset
        BX       R12
        DATA
??Subroutine8_0:
        DC32     Speech_Decode_Frame_reset
        CFI EndBlock cfiBlock13

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for order_MR475>`:
        DATA
        DC16 0, 128, 0, 64, 0, 32, 0, 16, 0, 8, 0, 4, 0, 2, 0, 1, 1, 128, 1, 64
        DC16 1, 32, 1, 16, 1, 8, 1, 4, 1, 2, 1, 1, 3, 128, 3, 64, 3, 32, 3, 16
        DC16 3, 8, 3, 4, 7, 8, 7, 4, 10, 8, 10, 4, 14, 8, 14, 4, 6, 1, 6, 2, 6
        DC16 4, 6, 8, 13, 1, 13, 2, 13, 4, 13, 8, 2, 32, 2, 16, 2, 4, 2, 1, 13
        DC16 16, 13, 32, 13, 64, 13, 128, 3, 2, 3, 1, 6, 16, 6, 32, 6, 64, 6
        DC16 128, 5, 2, 5, 1, 2, 64, 2, 8, 2, 2, 7, 2, 7, 1, 9, 2, 9, 1, 10, 2
        DC16 10, 1, 12, 2, 12, 1, 14, 2, 14, 1, 16, 2, 16, 1, 4, 32, 4, 16, 4
        DC16 4, 4, 2, 8, 32, 8, 16, 8, 4, 8, 2, 11, 32, 11, 16, 11, 4, 11, 2
        DC16 15, 32, 15, 16, 15, 4, 15, 2, 4, 8, 8, 8, 11, 8, 15, 8, 4, 1, 8, 1
        DC16 11, 1, 15, 1, 4, 64, 8, 64, 11, 64, 15, 64
`?<Initializer for order_MR515>`:
        DC16 0, 1, 0, 2, 0, 4, 0, 8, 0, 16, 0, 32, 0, 64, 0, 128, 1, 1, 1, 2, 1
        DC16 4, 1, 8, 1, 16, 1, 32, 1, 64, 1, 128, 3, 128, 3, 64, 3, 32, 3, 16
        DC16 3, 8, 7, 8, 11, 8, 15, 8, 6, 1, 6, 2, 6, 4, 10, 1, 10, 2, 10, 4
        DC16 14, 1, 14, 2, 14, 4, 18, 1, 18, 2, 18, 4, 6, 8, 10, 8, 14, 8, 18
        DC16 8, 3, 4, 7, 4, 11, 4, 15, 4, 2, 16, 6, 16, 10, 16, 14, 16, 18, 16
        DC16 3, 2, 7, 2, 11, 2, 2, 32, 2, 4, 2, 1, 6, 32, 10, 32, 14, 32, 18
        DC16 32, 2, 2, 3, 1, 7, 1, 11, 1, 15, 2, 2, 8, 2, 64, 15, 1, 5, 1, 5, 2
        DC16 9, 1, 9, 2, 13, 1, 4, 4, 8, 4, 12, 4, 16, 4, 13, 2, 17, 1, 17, 2
        DC16 4, 2, 8, 2, 12, 2, 16, 2, 4, 32, 8, 32, 4, 16, 8, 16, 12, 32, 12
        DC16 16, 16, 32, 16, 16, 4, 64, 8, 64, 12, 64, 16, 64, 4, 1, 8, 1, 12
        DC16 1, 16, 1, 4, 8, 8, 8, 12, 8, 16, 8
`?<Initializer for order_MR59>`:
        DC16 0, 128, 0, 64, 0, 8, 0, 4, 0, 16, 0, 2, 0, 1, 0, 32, 1, 8, 1, 2, 1
        DC16 256, 1, 128, 1, 32, 1, 16, 1, 4, 1, 64, 1, 1, 3, 32, 11, 32, 3, 16
        DC16 11, 16, 3, 64, 11, 64, 3, 128, 11, 128, 3, 8, 11, 8, 7, 8, 15, 8
        DC16 6, 1, 10, 1, 14, 1, 18, 1, 3, 4, 11, 4, 7, 4, 15, 4, 6, 2, 10, 2
        DC16 14, 2, 18, 2, 7, 2, 15, 2, 3, 2, 11, 2, 3, 1, 11, 1, 6, 4, 10, 4
        DC16 14, 4, 18, 4, 6, 8, 10, 8, 14, 8, 18, 8, 6, 16, 10, 16, 14, 16, 18
        DC16 16, 2, 64, 2, 16, 2, 4, 2, 8, 2, 128, 2, 256, 2, 32, 2, 2, 17, 1
        DC16 5, 2, 13, 2, 17, 2, 9, 2, 9, 1, 5, 1, 13, 1, 2, 1, 6, 32, 10, 32
        DC16 14, 32, 18, 32, 7, 1, 15, 1, 4, 4, 8, 4, 12, 4, 16, 4, 4, 8, 8, 8
        DC16 12, 8, 16, 8, 4, 64, 8, 64, 12, 64, 16, 64, 4, 128, 8, 128, 12
        DC16 128, 16, 128, 4, 256, 8, 256, 12, 256, 16, 256, 4, 1, 8, 1, 12, 1
        DC16 16, 1, 4, 2, 8, 2, 12, 2, 16, 2, 4, 16, 8, 16, 12, 16, 16, 16, 4
        DC16 32, 8, 32, 12, 32, 16, 32
`?<Initializer for order_MR67>`:
        DC16 0, 128, 0, 64, 0, 8, 0, 16, 0, 4, 0, 2, 1, 8, 0, 1, 0, 32, 1, 256
        DC16 1, 128, 1, 32, 1, 2, 1, 16, 1, 4, 1, 64, 3, 32, 11, 32, 3, 16, 11
        DC16 16, 3, 64, 11, 64, 3, 128, 11, 128, 3, 8, 11, 8, 1, 1, 7, 8, 15, 8
        DC16 7, 4, 15, 4, 3, 4, 11, 4, 7, 2, 15, 2, 6, 64, 10, 64, 14, 64, 18
        DC16 64, 3, 2, 11, 2, 6, 8, 10, 8, 14, 8, 18, 8, 6, 4, 10, 4, 14, 4, 18
        DC16 4, 7, 1, 15, 1, 3, 1, 11, 1, 2, 64, 2, 4, 6, 2, 10, 2, 14, 2, 18
        DC16 2, 2, 16, 2, 8, 2, 128, 2, 256, 2, 32, 2, 2, 2, 1, 6, 16, 10, 16
        DC16 14, 16, 18, 16, 5, 1, 9, 1, 13, 1, 17, 1, 6, 1, 10, 1, 14, 1, 18
        DC16 1, 5, 2, 9, 2, 13, 2, 17, 2, 18, 32, 14, 32, 10, 32, 6, 32, 5, 4
        DC16 9, 4, 13, 4, 17, 4, 4, 4, 8, 4, 12, 4, 16, 4, 4, 32, 8, 32, 12, 32
        DC16 16, 32, 4, 64, 8, 64, 12, 64, 16, 64, 4, 512, 8, 512, 12, 512, 16
        DC16 512, 4, 1024, 8, 1024, 12, 1024, 16, 1024, 4, 1, 8, 1, 12, 1, 16
        DC16 1, 4, 2, 8, 2, 12, 2, 16, 2, 4, 8, 8, 8, 12, 8, 16, 8, 4, 16, 8
        DC16 16, 12, 16, 16, 16, 4, 128, 8, 128, 12, 128, 16, 128, 4, 256, 8
        DC16 256, 12, 256, 16, 256
`?<Initializer for order_MR74>`:
        DC16 0, 128, 0, 64, 0, 32, 0, 16, 0, 8, 0, 4, 0, 2, 0, 1, 1, 256, 1
        DC16 128, 1, 64, 1, 32, 1, 16, 1, 8, 1, 4, 1, 2, 1, 1, 3, 128, 11, 128
        DC16 3, 64, 11, 64, 3, 32, 11, 32, 3, 16, 11, 16, 3, 8, 11, 8, 6, 64
        DC16 10, 64, 14, 64, 18, 64, 6, 32, 10, 32, 14, 32, 18, 32, 6, 8, 10, 8
        DC16 14, 8, 18, 8, 6, 4, 10, 4, 14, 4, 18, 4, 7, 16, 15, 16, 7, 8, 15
        DC16 8, 2, 16, 2, 8, 2, 4, 2, 256, 2, 128, 2, 64, 3, 4, 7, 4, 11, 4, 15
        DC16 4, 6, 2, 10, 2, 14, 2, 18, 2, 2, 32, 2, 2, 2, 1, 5, 1, 9, 1, 13, 1
        DC16 17, 1, 6, 1, 10, 1, 14, 1, 18, 1, 5, 2, 9, 2, 13, 2, 17, 2, 5, 4
        DC16 9, 4, 6, 16, 10, 16, 14, 16, 18, 16, 13, 4, 17, 4, 5, 8, 9, 8, 13
        DC16 8, 17, 8, 3, 2, 3, 1, 7, 2, 7, 1, 11, 2, 11, 1, 15, 2, 15, 1, 4
        DC16 32, 4, 16, 4, 8, 4, 4, 4, 2, 4, 1, 8, 32, 8, 16, 8, 8, 8, 4, 8, 2
        DC16 8, 1, 12, 32, 12, 16, 12, 8, 12, 4, 12, 2, 12, 1, 16, 32, 16, 16
        DC16 16, 8, 16, 4, 16, 2, 16, 1, 4, 4096, 8, 4096, 12, 4096, 16, 4096
        DC16 4, 2048, 8, 2048, 12, 2048, 16, 2048, 4, 1024, 8, 1024, 12, 1024
        DC16 16, 1024, 4, 512, 8, 512, 12, 512, 16, 512, 4, 256, 8, 256, 12
        DC16 256, 16, 256, 4, 128, 8, 128, 12, 128, 16, 128, 4, 64, 8, 64, 12
        DC16 64, 16, 64
`?<Initializer for order_MR795>`:
        DC16 0, 1, 0, 2, 0, 4, 0, 8, 0, 16, 0, 32, 0, 64, 1, 8, 1, 2, 1, 256, 1
        DC16 128, 1, 32, 1, 16, 1, 4, 1, 64, 1, 1, 2, 64, 2, 16, 2, 4, 2, 8, 2
        DC16 128, 2, 256, 2, 32, 7, 16, 12, 16, 17, 16, 22, 16, 7, 8, 12, 8, 17
        DC16 8, 22, 8, 7, 4, 12, 4, 17, 4, 22, 4, 6, 8, 11, 8, 16, 8, 21, 8, 6
        DC16 4, 11, 4, 16, 4, 21, 4, 3, 128, 13, 128, 3, 64, 13, 64, 3, 32, 13
        DC16 32, 3, 16, 13, 16, 3, 8, 13, 8, 8, 32, 18, 32, 8, 16, 18, 16, 8, 8
        DC16 18, 8, 7, 2, 12, 2, 17, 2, 22, 2, 3, 4, 13, 4, 8, 4, 18, 4, 0, 128
        DC16 0, 256, 2, 2, 2, 1, 3, 2, 13, 2, 3, 1, 13, 1, 8, 2, 18, 2, 8, 1
        DC16 18, 1, 6, 2, 11, 2, 16, 2, 21, 2, 7, 1, 12, 1, 17, 1, 22, 1, 6, 1
        DC16 11, 1, 16, 1, 21, 1, 15, 1, 15, 2, 15, 4, 4, 2, 9, 2, 14, 2, 19, 2
        DC16 4, 16, 9, 16, 14, 16, 19, 16, 4, 128, 9, 128, 14, 128, 19, 128, 4
        DC16 2048, 9, 2048, 14, 2048, 19, 2048, 15, 8, 20, 1, 20, 2, 20, 4, 20
        DC16 8, 10, 1, 10, 2, 10, 4, 10, 8, 5, 1, 5, 2, 5, 4, 5, 8, 4, 1, 4, 4
        DC16 4, 8, 4, 32, 4, 256, 4, 4096, 9, 1, 9, 4, 9, 8, 9, 32, 9, 256, 9
        DC16 4096, 14, 1, 14, 4, 14, 8, 14, 32, 14, 256, 14, 4096, 19, 1, 19, 4
        DC16 19, 8, 19, 32, 19, 256, 19, 4096, 4, 64, 9, 64, 14, 64, 19, 64, 4
        DC16 1024, 9, 1024, 14, 1024, 19, 1024, 4, 512, 9, 512, 14, 512, 19
        DC16 512, 0, 1, 0, 2, 0, 4, 0, 8, 0, 16, 0, 32, 0, 64, 1, 8, 1, 2, 1
        DC16 256, 1, 128, 1, 32, 1, 16, 1, 4, 1, 64, 1, 1, 2, 64, 2, 16, 2, 4
        DC16 2, 8, 2, 128, 2, 256, 2, 32, 7, 16, 12, 16, 17, 16, 22, 16, 7, 8
        DC16 12, 8, 17, 8, 22, 8, 7, 4, 12, 4, 17, 4, 22, 4, 6, 8, 11, 8, 16, 8
        DC16 21, 8, 6, 4, 11, 4, 16, 4, 21, 4, 3, 128, 13, 128, 3, 64, 13, 64
        DC16 3, 32, 13, 32, 3, 16, 13, 16, 3, 8, 13, 8, 8, 32, 18, 32, 8, 16
        DC16 18, 16, 8, 8, 18, 8, 7, 2, 12, 2, 17, 2, 22, 2, 3, 4, 13, 4, 8, 4
        DC16 18, 4, 0, 128, 0, 256, 2, 2, 2, 1, 3, 2, 13, 2, 3, 1, 13, 1, 8, 2
        DC16 18, 2, 8, 1, 18, 1, 6, 2, 11, 2, 16, 2, 21, 2, 7, 1, 12, 1, 17, 1
        DC16 22, 1, 6, 1, 11, 1, 16, 1, 21, 1, 15, 1, 15, 2, 15, 4, 4, 2, 9, 2
        DC16 14, 2, 19, 2, 4, 16, 9, 16, 14, 16, 19, 16, 4, 128, 9, 128, 14
        DC16 128, 19, 128, 4, 2048, 9, 2048, 14, 2048, 19, 2048, 15, 8, 20, 1
        DC16 20, 2, 20, 4, 20, 8, 10, 1, 10, 2, 10, 4, 10, 8, 5, 1, 5, 2, 5, 4
        DC16 5, 8, 4, 1, 4, 4, 4, 8, 4, 32, 4, 256, 4, 4096, 9, 1, 9, 4, 9, 8
        DC16 9, 32, 9, 256, 9, 4096, 14, 1, 14, 4, 14, 8, 14, 32, 14, 256, 14
        DC16 4096, 19, 1, 19, 4, 19, 8, 19, 32, 19, 256, 19, 4096, 4, 64, 9, 64
        DC16 14, 64, 19, 64, 4, 1024, 9, 1024, 14, 1024, 19, 1024, 4, 512, 9
        DC16 512, 14, 512, 19, 512
`?<Initializer for order_MR102>`:
        DC16 0, 1, 0, 2, 0, 4, 0, 8, 0, 16, 0, 32, 0, 64, 0, 128, 1, 1, 1, 2, 1
        DC16 4, 1, 8, 1, 16, 1, 32, 1, 64, 1, 128, 1, 256, 3, 128, 3, 64, 3, 32
        DC16 3, 16, 3, 8, 3, 4, 21, 128, 21, 64, 21, 32, 21, 16, 21, 8, 21, 4
        DC16 12, 16, 12, 8, 30, 16, 30, 8, 11, 64, 11, 8, 11, 4, 20, 64, 20, 8
        DC16 20, 4, 29, 64, 29, 8, 29, 4, 38, 64, 38, 8, 38, 4, 3, 2, 3, 1, 21
        DC16 2, 21, 1, 12, 4, 12, 2, 30, 4, 30, 2, 11, 32, 20, 32, 29, 32, 38
        DC16 32, 2, 64, 2, 4, 2, 16, 2, 8, 2, 128, 2, 256, 2, 32, 2, 2, 2, 1, 7
        DC16 1, 6, 1, 5, 1, 4, 1, 16, 1, 15, 1, 14, 1, 13, 1, 25, 1, 24, 1, 23
        DC16 1, 22, 1, 34, 1, 33, 1, 32, 1, 31, 1, 11, 2, 11, 16, 11, 1, 20, 2
        DC16 20, 16, 20, 1, 29, 2, 29, 16, 29, 1, 38, 2, 38, 16, 38, 1, 12, 1
        DC16 30, 1, 17, 512, 17, 256, 18, 256, 18, 512, 18, 128, 17, 128, 18
        DC16 32, 17, 32, 17, 64, 18, 64, 19, 64, 19, 32, 18, 16, 19, 8, 17, 16
        DC16 19, 16, 17, 8, 18, 8, 26, 512, 26, 256, 27, 256, 27, 512, 27, 128
        DC16 26, 128, 27, 32, 26, 32, 26, 64, 27, 64, 28, 64, 28, 32, 27, 16
        DC16 28, 8, 26, 16, 28, 16, 26, 8, 27, 8, 35, 512, 35, 256, 36, 256, 36
        DC16 512, 36, 128, 35, 128, 36, 32, 35, 32, 35, 64, 36, 64, 37, 64, 37
        DC16 32, 36, 16, 37, 8, 35, 16, 37, 16, 35, 8, 36, 8, 8, 512, 8, 256, 9
        DC16 256, 9, 512, 9, 128, 8, 128, 9, 32, 8, 32, 8, 64, 9, 64, 10, 64
        DC16 10, 32, 9, 16, 10, 8, 8, 16, 10, 16, 8, 8, 9, 8, 37, 4, 35, 1, 36
        DC16 1, 37, 1, 35, 4, 37, 2, 35, 2, 36, 4, 36, 2, 28, 4, 26, 1, 27, 1
        DC16 28, 1, 26, 4, 28, 2, 26, 2, 27, 4, 27, 2, 19, 4, 17, 1, 18, 1, 19
        DC16 1, 17, 4, 19, 2, 17, 2, 18, 4, 18, 2, 10, 4, 8, 1, 9, 1, 10, 1, 8
        DC16 4, 10, 2, 8, 2, 9, 4, 9, 2
`?<Initializer for order_MR122>`:
        DC16 0, 64, 0, 32, 0, 16, 0, 8, 0, 4, 0, 2, 0, 1, 1, 128, 1, 64, 1, 32
        DC16 1, 16, 1, 8, 1, 4, 1, 2, 1, 1, 2, 1, 2, 256, 2, 128, 2, 64, 2, 32
        DC16 2, 16, 2, 8, 2, 4, 2, 2, 3, 128, 3, 64, 3, 32, 3, 16, 3, 8, 5, 256
        DC16 31, 256, 5, 128, 31, 128, 5, 64, 31, 64, 5, 32, 31, 32, 5, 16, 31
        DC16 16, 5, 8, 31, 8, 5, 4, 31, 4, 5, 2, 31, 2, 5, 1, 31, 1, 6, 8, 19
        DC16 8, 32, 8, 45, 8, 6, 4, 19, 4, 32, 4, 45, 4, 6, 2, 19, 2, 32, 2, 45
        DC16 2, 17, 16, 30, 16, 43, 16, 56, 16, 17, 8, 30, 8, 43, 8, 56, 8, 17
        DC16 4, 30, 4, 43, 4, 56, 4, 18, 32, 44, 32, 18, 16, 44, 16, 18, 8, 44
        DC16 8, 18, 4, 44, 4, 18, 2, 44, 2, 3, 4, 3, 2, 3, 1, 4, 32, 4, 16, 4
        DC16 8, 4, 4, 6, 1, 19, 1, 32, 1, 45, 1, 17, 2, 30, 2, 43, 2, 56, 2, 7
        DC16 8, 20, 8, 33, 8, 46, 8, 8, 8, 21, 8, 34, 8, 47, 8, 17, 1, 30, 1
        DC16 43, 1, 56, 1, 9, 8, 22, 8, 35, 8, 48, 8, 10, 8, 23, 8, 36, 8, 49
        DC16 8, 11, 8, 24, 8, 37, 8, 50, 8, 4, 2, 4, 1, 7, 1, 7, 2, 7, 4, 8, 1
        DC16 8, 2, 8, 4, 9, 1, 9, 2, 9, 4, 10, 1, 10, 2, 10, 4, 11, 1, 11, 2
        DC16 11, 4, 20, 1, 20, 2, 20, 4, 21, 1, 21, 2, 21, 4, 22, 1, 22, 2, 22
        DC16 4, 23, 1, 23, 2, 23, 4, 24, 1, 24, 2, 24, 4, 33, 1, 33, 2, 33, 4
        DC16 34, 1, 34, 2, 34, 4, 35, 1, 35, 2, 35, 4, 36, 1, 36, 2, 36, 4, 37
        DC16 1, 37, 2, 37, 4, 46, 1, 46, 2, 46, 4, 47, 1, 47, 2, 47, 4, 48, 1
        DC16 48, 2, 48, 4, 49, 1, 49, 2, 49, 4, 50, 1, 50, 2, 50, 4, 12, 1, 12
        DC16 2, 12, 4, 13, 1, 13, 2, 13, 4, 14, 1, 14, 2, 14, 4, 15, 1, 15, 2
        DC16 15, 4, 16, 1, 16, 2, 16, 4, 25, 1, 25, 2, 25, 4, 26, 1, 26, 2, 26
        DC16 4, 27, 1, 27, 2, 27, 4, 28, 1, 28, 2, 28, 4, 29, 1, 29, 2, 29, 4
        DC16 38, 1, 38, 2, 38, 4, 39, 1, 39, 2, 39, 4, 40, 1, 40, 2, 40, 4, 41
        DC16 1, 41, 2, 41, 4, 42, 1, 42, 2, 42, 4, 51, 1, 51, 2, 51, 4, 52, 1
        DC16 52, 2, 52, 4, 53, 1, 53, 2, 53, 4, 54, 1, 54, 2, 54, 4, 55, 1, 55
        DC16 2, 55, 4, 18, 1, 44, 1
`?<Initializer for order_MRDTX>`:
        DC16 0, 4, 0, 2, 0, 1, 1, 128, 1, 64, 1, 32, 1, 16, 1, 8, 1, 4, 1, 2, 1
        DC16 1, 2, 256, 2, 128, 2, 64, 2, 32, 2, 16, 2, 8, 2, 4, 2, 2, 2, 1, 3
        DC16 256, 3, 128, 3, 64, 3, 32, 3, 16, 3, 8, 3, 4, 3, 2, 3, 1, 4, 32, 4
        DC16 16, 4, 8, 4, 4, 4, 2, 4, 1

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?*?DATA_ID`:

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_I:
        DCD      sfe(DATA_I) - sfb(DATA_I), sfb(DATA_I), sfb(DATA_ID)

        END
// 
// 2 052 bytes in segment CODE
//   440 bytes in segment DATA_C
// 5 596 bytes in segment DATA_I
// 5 596 bytes in segment DATA_ID
//    12 bytes in segment INITTAB
// 
// 1 984 bytes of CODE  memory (+ 80 bytes shared)
// 6 036 bytes of CONST memory
// 5 596 bytes of DATA  memory
//
//Errors: none
//Warnings: none
