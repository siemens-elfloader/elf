##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    31/Mar/2011  22:53:54 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\CBN\Arc\Zlib\CRC32.C                          #
#    Command line    =  C:\arm\CBN\Arc\Zlib\CRC32.C -D NEWSGOLD -D UNPACK    #
#                       -lC C:\arm\CBN\Z80\Release\List\ -o                  #
#                       C:\arm\CBN\Z80\Release\Obj\ -s9 --no_unroll          #
#                       --no_clustering --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --char_is_signed --fpu None -I "C:\arm2\Embedded     #
#                       Workbench 4.0 Evaluation\ARM\INC\"                   #
#                       --inline_threshold=2                                 #
#    List file       =  C:\arm\CBN\Z80\Release\List\CRC32.lst                #
#    Object file     =  C:\arm\CBN\Z80\Release\Obj\CRC32.r79                 #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\CBN\Arc\Zlib\CRC32.C
      1          /* crc32.c -- compute the CRC-32 of a data stream
      2           * Copyright (C) 1995-2005 Mark Adler
      3           * For conditions of distribution and use, see copyright notice in zlib.h
      4           *
      5           * Thanks to Rodney Brown <rbrown64@csc.com.au> for his contribution of faster
      6           * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing
      7           * tables for updating the shift register in one step with three exclusive-ors
      8           * instead of four steps with four exclusive-ors.  This results in about a
      9           * factor of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.
     10           */
     11          
     12          /* @(#) $Id$ */
     13          
     14          /*
     15            Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore
     16            protection on the static variables used to control the first-use generation
     17            of the crc tables.  Therefore, if you #define DYNAMIC_CRC_TABLE, you should
     18            first call get_crc_table() to initialize the tables before allowing more than
     19            one thread to use crc32().
     20           */
     21          
     22          #ifdef MAKECRCH
     23          //#  include <stdio.h>
     24          #  ifndef DYNAMIC_CRC_TABLE
     25          #    define DYNAMIC_CRC_TABLE
     26          #  endif /* !DYNAMIC_CRC_TABLE */
     27          #endif /* MAKECRCH */
     28          
     29          #include "zutil.h"      /* for STDC and FAR definitions */
     30          
     31          #define local static
     32          
     33          /* Find a four-byte integer type for crc32_little() and crc32_big(). */
     34          #ifndef NOBYFOUR
     35          #  ifdef STDC           /* need ANSI C limits.h to determine sizes */
     36          //#    include <limits.h>
     37          #    define BYFOUR
     38          #    if (UINT_MAX == 0xffffffffUL)
     39                 typedef unsigned int u4;
     40          #    else
     41          #      if (ULONG_MAX == 0xffffffffUL)
     42                   typedef unsigned long u4;
     43          #      else
     44          #        if (USHRT_MAX == 0xffffffffUL)
     45                     typedef unsigned short u4;
     46          #        else
     47          #          undef BYFOUR     /* can't find a four-byte integer type! */
     48          #        endif
     49          #      endif
     50          #    endif
     51          #  endif /* STDC */
     52          #endif /* !NOBYFOUR */
     53          
     54          /* Definitions for doing the crc four data bytes at a time. */
     55          #ifdef BYFOUR
     56          #  define REV(w) (((w)>>24)+(((w)>>8)&0xff00)+ \
     57                          (((w)&0xff00)<<8)+(((w)&0xff)<<24))
     58             local unsigned long crc32_little OF((unsigned long,
     59                                  const unsigned char FAR *, unsigned));
     60             local unsigned long crc32_big OF((unsigned long,
     61                                  const unsigned char FAR *, unsigned));
     62          #  define TBLS 8
     63          #else
     64          #  define TBLS 1
     65          #endif /* BYFOUR */
     66          
     67          /* Local functions for crc concatenation */
     68          local unsigned long gf2_matrix_times OF((unsigned long *mat,
     69                                                   unsigned long vec));
     70          local void gf2_matrix_square OF((unsigned long *square, unsigned long *mat));
     71          
     72          #ifdef DYNAMIC_CRC_TABLE
     73          
     74          local volatile int crc_table_empty = 1;
     75          local unsigned long FAR crc_table[TBLS][256];
     76          local void make_crc_table OF((void));
     77          #ifdef MAKECRCH
     78             local void write_table OF((FILE *, const unsigned long FAR *));
     79          #endif /* MAKECRCH */
     80          /*
     81            Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:
     82            x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
     83          
     84            Polynomials over GF(2) are represented in binary, one bit per coefficient,
     85            with the lowest powers in the most significant bit.  Then adding polynomials
     86            is just exclusive-or, and multiplying a polynomial by x is a right shift by
     87            one.  If we call the above polynomial p, and represent a byte as the
     88            polynomial q, also with the lowest power in the most significant bit (so the
     89            byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
     90            where a mod b means the remainder after dividing a by b.
     91          
     92            This calculation is done using the shift-register method of multiplying and
     93            taking the remainder.  The register is initialized to zero, and for each
     94            incoming bit, x^32 is added mod p to the register if the bit is a one (where
     95            x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
     96            x (which is shifting right by one and adding x^32 mod p if the bit shifted
     97            out is a one).  We start with the highest power (least significant bit) of
     98            q and repeat for all eight bits of q.
     99          
    100            The first table is simply the CRC of all possible eight bit values.  This is
    101            all the information needed to generate CRCs on data a byte at a time for all
    102            combinations of CRC register values and incoming bytes.  The remaining tables
    103            allow for word-at-a-time CRC calculation for both big-endian and little-
    104            endian machines, where a word is four bytes.
    105          */
    106          local void make_crc_table()
    107          {
    108              unsigned long c;
    109              int n, k;
    110              unsigned long poly;                 /* polynomial exclusive-or pattern */
    111              /* terms of polynomial defining this crc (except x^32): */
    112              static volatile int first = 1;      /* flag to limit concurrent making */
    113              static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
    114          
    115              /* See if another task is already doing this (not thread-safe, but better
    116                 than nothing -- significantly reduces duration of vulnerability in
    117                 case the advice about DYNAMIC_CRC_TABLE is ignored) */
    118              if (first) {
    119                  first = 0;
    120          
    121                  /* make exclusive-or pattern from polynomial (0xedb88320UL) */
    122                  poly = 0UL;
    123                  for (n = 0; n < sizeof(p)/sizeof(unsigned char); n++)
    124                      poly |= 1UL << (31 - p[n]);
    125          
    126                  /* generate a crc for every 8-bit value */
    127                  for (n = 0; n < 256; n++) {
    128                      c = (unsigned long)n;
    129                      for (k = 0; k < 8; k++)
    130                          c = c & 1 ? poly ^ (c >> 1) : c >> 1;
    131                      crc_table[0][n] = c;
    132                  }
    133          
    134          #ifdef BYFOUR
    135                  /* generate crc for each value followed by one, two, and three zeros,
    136                     and then the byte reversal of those as well as the first table */
    137                  for (n = 0; n < 256; n++) {
    138                      c = crc_table[0][n];
    139                      crc_table[4][n] = REV(c);
    140                      for (k = 1; k < 4; k++) {
    141                          c = crc_table[0][c & 0xff] ^ (c >> 8);
    142                          crc_table[k][n] = c;
    143                          crc_table[k + 4][n] = REV(c);
    144                      }
    145                  }
    146          #endif /* BYFOUR */
    147          
    148                  crc_table_empty = 0;
    149              }
    150              else {      /* not first */
    151                  /* wait for the other guy to finish (not efficient, but rare) */
    152                  while (crc_table_empty)
    153                      ;
    154              }
    155          
    156          #ifdef MAKECRCH
    157              /* write out CRC tables to crc32.h */
    158              {
    159                  FILE *out;
    160          
    161                  out = fopen("crc32.h", "w");
    162                  if (out == NULL) return;
    163                  fprintf(out, "/* crc32.h -- tables for rapid CRC calculation\n");
    164                  fprintf(out, " * Generated automatically by crc32.c\n */\n\n");
    165                  fprintf(out, "local const unsigned long FAR ");
    166                  fprintf(out, "crc_table[TBLS][256] =\n{\n  {\n");
    167                  write_table(out, crc_table[0]);
    168          #  ifdef BYFOUR
    169                  fprintf(out, "#ifdef BYFOUR\n");
    170                  for (k = 1; k < 8; k++) {
    171                      fprintf(out, "  },\n  {\n");
    172                      write_table(out, crc_table[k]);
    173                  }
    174                  fprintf(out, "#endif\n");
    175          #  endif /* BYFOUR */
    176                  fprintf(out, "  }\n};\n");
    177                  fclose(out);
    178              }
    179          #endif /* MAKECRCH */
    180          }
    181          
    182          #ifdef MAKECRCH
    183          local void write_table(out, table)
    184              FILE *out;
    185              const unsigned long FAR *table;
    186          {
    187              int n;
    188          
    189              for (n = 0; n < 256; n++)
    190                  fprintf(out, "%s0x%08lxUL%s", n % 5 ? "" : "    ", table[n],
    191                          n == 255 ? "\n" : (n % 5 == 4 ? ",\n" : ", "));
    192          }
    193          #endif /* MAKECRCH */
    194          
    195          #else /* !DYNAMIC_CRC_TABLE */
    196          /* ========================================================================
    197           * Tables of CRC-32s of all single-byte values, made by make_crc_table().
    198           */
    199          #include "crc32.h"

   \                                 In segment DATA_C, align 4, align-sorted
   \   static unsigned long const __data crc_table[1][256]
   \                     crc_table:
   \   00000000   000000009630       DC32 0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615
   \              07772C610EEE
   \              BA51099919C4
   \              6D078FF46A70
   \   00000018   35A563E9A395       DC32 3915621685, 2657392035, 249268274, 2044508324, 3772115230
   \              649E3288DB0E
   \              A4B8DC791EE9
   \              D5E0        
   \   0000002C   88D9D2972B4C       DC32 2547177864, 162941995, 2125561021, 3887607047, 2428444049
   \              B609BD7CB17E
   \              072DB8E7911D
   \              BF90        
   \   00000040   6410B71DF220       DC32 498536548, 1789927666, 4089016648, 2227061214, 450548861
   \              B06A4871B9F3
   \              DE41BE847DD4
   \              DA1A        
   \   00000054   EBE4DD6D51B5       DC32 1843258603, 4107580753, 2211677639, 325883990, 1684777152
   \              D4F4C785D383
   \              56986C13C0A8
   \              6B64        
   \   00000068   7AF962FDECC9       DC32 4251122042, 2321926636, 335633487, 1661365465, 4195302755
   \              658A4F5C0114
   \              D96C0663633D
   \              0FFA        
   \   0000007C   F50D088DC820       DC32 2366115317, 997073096, 1281953886, 3579855332, 2724688242
   \              6E3B5E10694C
   \              E44160D57271
   \              67A2        
   \   00000090   D1E4033C47D4       DC32 1006888145, 1258607687, 3524101629, 2768942443, 901097722
   \              044BFD850DD2
   \              6BB50AA5FAA8
   \              B535        
   \   000000A4   6C98B242D6C9       DC32 1119000684, 3686517206, 2898065728, 853044451, 1172266101
   \              BBDB40F9BCAC
   \              E36CD832755C
   \              DF45        
   \   000000B8   CF0DD6DC593D       DC32 3705015759, 2882616665, 651767980, 1373503546, 3369554304
   \              D1ABAC30D926
   \              3A00DE518051
   \              D7C8        
   \   000000CC   1661D0BFB5F4       DC32 3218104598, 565507253, 1454621731, 3485111705, 3099436303
   \              B42123C4B356
   \              9995BACF0FA5
   \              BDB8        
   \   000000E0   9EB802280888       DC32 671266974, 1594198024, 3322730930, 2970347812, 795835527
   \              055FB2D90CC6
   \              24E90BB1877C
   \              6F2F        
   \   000000F4   114C6858AB1D       DC32 1483230225, 3244367275, 3060149565, 1994146192, 31158534
   \              61C13D2D66B6
   \              9041DC760671
   \              DB01        
   \   00000108   BC20D2982A10       DC32 2563907772, 4023717930, 1907459465, 112637215, 2680153253
   \              D5EF8985B171
   \              1FB5B606A5E4
   \              BF9F        
   \   0000011C   33D4B8E8A2C9       DC32 3904427059, 2013776290, 251722036, 2517215374, 3775830040
   \              077834F9000F
   \              8EA809961898
   \              0EE1        
   \   00000130   BB0D6A7F2D3D       DC32 2137656763, 141376813, 2439277719, 3865271297, 1802195444
   \              6D08976C6491
   \              015C63E6F451
   \              6B6B        
   \   00000144   62616C1CD830       DC32 476864866, 2238001368, 4066508878, 1812370925, 453092731
   \              65854E0062F2
   \              ED95066C7BA5
   \              011B        
   \   00000158   C1F4088257C4       DC32 2181625025, 4111451223, 1706088902, 314042704, 2344532202
   \              0FF5C6D9B065
   \              50E9B712EAB8
   \              BE8B        
   \   0000016C   7C88B9FCDF1D       DC32 4240017532, 1658658271, 366619977, 2362670323, 4224994405
   \              DD62492DDA15
   \              F37CD38C654C
   \              D4FB        
   \   00000180   5861B24DCE51       DC32 1303535960, 984961486, 2747007092, 3569037538, 1256170817
   \              B53A7400BCA3
   \              E230BBD441A5
   \              DF4A        
   \   00000194   D795D83D6DC4       DC32 1037604311, 2765210733, 3554079995, 1131014506, 879679996
   \              D1A4FBF4D6D3
   \              6AE96943FCD9
   \              6E34        
   \   000001A8   468867ADD0B8       DC32 2909243462, 3663771856, 1141124467, 855842277, 2852801631
   \              60DA732D0444
   \              E51D03335F4C
   \              0AAA        
   \   000001BC   C97C0DDD3C71       DC32 3708648649, 1342533948, 654459306, 3188396048, 3373015174
   \              0550AA410227
   \              10100BBE8620
   \              0CC9        
   \   000001D0   25B56857B385       DC32 1466479909, 544179635, 3110523913, 3462522015, 1591671054
   \              6F2009D466B9
   \              9FE461CE0EF9
   \              DE5E        
   \   000001E4   98C9D9292298       DC32 702138776, 2966460450, 3352799412, 1504918807, 783551873
   \              D0B0B4A8D7C7
   \              173DB359810D
   \              B42E        
   \   000001F8   3B5CBDB7AD6C       DC32 3082640443, 3233442989, 3988292384, 2596254646, 62317068
   \              BAC02083B8ED
   \              B6B3BF9A0CE2
   \              B603        
   \   0000020C   9AD2B1743947       DC32 1957810842, 3939845945, 2647816111, 81470997, 1943803523
   \              D5EAAF77D29D
   \              1526DB048316
   \              DC73        
   \   00000220   120B63E3843B       DC32 3814918930, 2489596804, 225274430, 2053790376, 3826175755
   \              64943E6A6D0D
   \              A85A6A7A0BCF
   \              0EE4        
   \   00000234   9DFF099327AE       DC32 2466906013, 167816743, 2097651377, 4027552580, 2265490386
   \              000AB19E077D
   \              44930FF0D2A3
   \              0887        
   \   00000248   68F2011EFEC2       DC32 503444072, 1762050814, 4150417245, 2154129355, 426522225
   \              06695D5762F7
   \              CB6765807136
   \              6C19        
   \   0000025C   E7066B6E761B       DC32 1852507879, 4275313526, 2312317920, 282753626, 1742555852
   \              D4FEE02BD389
   \              5A7ADA10CC4A
   \              DD67        
   \   00000270   6FDFB9F9F9EF       DC32 4189708143, 2394877945, 397917763, 1622183637, 3604390888
   \              BE8E43BEB717
   \              D58EB060E8A3
   \              D6D6        
   \   00000284   7E93D1A1C4C2       DC32 2714866558, 953729732, 1340076626, 3518719985, 2797360999
   \              D83852F2DF4F
   \              F167BBD16757
   \              BCA6        
   \   00000298   DD06B53F4B36       DC32 1068828381, 1219638859, 3624741850, 2936675148, 906185462
   \              B248DA2B0DD8
   \              4C1B0AAFF64A
   \              0336        
   \   000002AC   607A0441C3EF       DC32 1090812512, 3747672003, 2825379669, 829329135, 1181335161
   \              60DF55DF67A8
   \              EF8E6E3179BE
   \              6946        
   \   000002C0   8CB361CB1A83       DC32 3412177804, 3160834842, 628085408, 1382605366, 3423369109
   \              66BCA0D26F25
   \              36E268529577
   \              0CCC        
   \   000002D4   03470BBBB916       DC32 3138078467, 570562233, 1426400815, 3317316542, 2998733608
   \              02222F260555
   \              BE3BBAC5280B
   \              BDB2        
   \   000002E8   925AB42B046A       DC32 733239954, 1555261956, 3268935591, 3050360625, 752459403
   \              B35CA7FFD7C2
   \              31CFD0B58B9E
   \              D92C        
   \   000002FC   1DAEDE5BB0C2       DC32 1541320221, 2607071920, 3965973030, 1969922972, 40735498
   \              649B26F263EC
   \              9CA36A750A93
   \              6D02        
   \   00000310   A906099C3F36       DC32 2617837225, 3943577151, 1913087877, 83908371, 2512341634
   \              0EEB85670772
   \              13570005824A
   \              BF95        
   \   00000324   147AB8E2AE2B       DC32 3803740692, 2075208622, 213261112, 2463272603, 3855990285
   \              B17B381BB60C
   \              9B8ED2920DBE
   \              D5E5        
   \   00000338   B7EFDC7C21DF       DC32 2094854071, 198958881, 2262029012, 4057260610, 1759359992
   \              DB0BD4D2D386
   \              42E2D4F1F8B3
   \              DD68        
   \   0000034C   6E83DA1FCD16       DC32 534414190, 2176718541, 4139329115, 1873836001, 414664567
   \              BE815B26B9F6
   \              E177B06F7747
   \              B718        
   \   00000360   E65A0888706A       DC32 2282248934, 4279200368, 1711684554, 285281116, 2405801727
   \              0FFFCA3B0666
   \              5C0B0111FF9E
   \              658F        
   \   00000374   69AE62F8D3FF       DC32 4167216745, 1634467795, 376229701, 2685067896, 3608007406
   \              6B6145CF6C16
   \              78E20AA0EED2
   \              0DD7        
   \   00000388   5483044EC2B3       DC32 1308918612, 956543938, 2808555105, 3495958263, 1231636301
   \              0339612667A7
   \              F71660D04D47
   \              6949        
   \   0000039C   DB776E3E4A6A       DC32 1047427035, 2932959818, 3654703836, 1088359270, 936918000
   \              D1AEDC5AD6D9
   \              660BDF40F03B
   \              D837        
   \   000003B0   53AEBCA9C59E       DC32 2847714899, 3736837829, 1202900863, 817233897, 3183342108
   \              BBDE7FCFB247
   \              E9FFB5301CF2
   \              BDBD        
   \   000003C4   8AC2BACA3093       DC32 3401237130, 1404277552, 615818150, 3134207493, 3453421203
   \              B353A6A3B424
   \              0536D0BA9306
   \              D7CD        
   \   000003D8   2957DE54BF67       DC32 1423857449, 601450431, 3009837614, 3294710456, 1567103746
   \              D9232E7A66B3
   \              B84A61C4021B
   \              685D        
   \   000003EC   942B6F2A37BE       DC32 711928724, 3020668471, 3272380065, 1510334235, 755167117
   \              0BB4A18E0CC3
   \              1BDF055A8DEF
   \              022D        
    200          #endif /* DYNAMIC_CRC_TABLE */
    201          
    202          /* =========================================================================
    203           * This function can be used by asm versions of crc32()
    204           */

   \                                 In segment CODE, align 4, keep-with-next
    205          const unsigned long FAR * ZEXPORT get_crc_table()
    206          {
    207          #ifdef DYNAMIC_CRC_TABLE
    208              if (crc_table_empty)
    209                  make_crc_table();
    210          #endif /* DYNAMIC_CRC_TABLE */
    211              return (const unsigned long FAR *)crc_table;
   \                     get_crc_table:
   \   00000000   ........           LDR      R0,??DataTable1  ;; crc_table
   \   00000004   1EFF2FE1           BX       LR               ;; return
    212          }
    213          
    214          /* ========================================================================= */
    215          #define DO1 crc = crc_table[0][((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8)
    216          #define DO8 DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1
    217          
    218          /* ========================================================================= */

   \                                 In segment CODE, align 4, keep-with-next
    219          unsigned long ZEXPORT crc32(crc, buf, len)
    220              unsigned long crc;
    221              const unsigned char FAR *buf;
    222              unsigned len;
    223          {
   \                     crc32:
   \   00000000   10002DE9           PUSH     {R4}
    224              if (buf == Z_NULL) return 0UL;
   \   00000004   000051E3           CMP      R1,#+0
   \   00000008   0000A003           MOVEQ    R0,#+0
   \   0000000C   3900000A           BEQ      ??crc32_0
    225          
    226          #ifdef DYNAMIC_CRC_TABLE
    227              if (crc_table_empty)
    228                  make_crc_table();
    229          #endif /* DYNAMIC_CRC_TABLE */
    230          
    231          #ifdef BYFOUR
    232              if (sizeof(void *) == sizeof(ptrdiff_t)) {
    233                  u4 endian;
    234          
    235                  endian = 1;
    236                  if (*((unsigned char *)(&endian)))
    237                      return crc32_little(crc, buf, len);
    238                  else
    239                      return crc32_big(crc, buf, len);
    240              }
    241          #endif /* BYFOUR */
    242              crc = crc ^ 0xffffffffUL;
   \   00000010   ........           LDR      R12,??DataTable1  ;; crc_table
   \   00000014   0030E0E3           MVN      R3,#+0
   \   00000018   000023E0           EOR      R0,R3,R0
   \   0000001C   080052E3           CMP      R2,#+8
   \   00000020   2A00003A           BCC      ??crc32_1
    243              while (len >= 8) {
    244                  DO8;
   \                     ??crc32_2:
   \   00000024   ........           LDRB     R4,[R1], #+1
    245                  len -= 8;
   \   00000028   082042E2           SUB      R2,R2,#+8
    246              }
   \   0000002C   080052E3           CMP      R2,#+8
   \   00000030   004024E0           EOR      R4,R4,R0
   \   00000034   FF4004E2           AND      R4,R4,#0xFF
   \   00000038   04419CE7           LDR      R4,[R12, +R4, LSL #+2]
   \   0000003C   200424E0           EOR      R0,R4,R0, LSR #+8
   \   00000040   ........           LDRB     R4,[R1], #+1
   \   00000044   004024E0           EOR      R4,R4,R0
   \   00000048   FF4004E2           AND      R4,R4,#0xFF
   \   0000004C   04419CE7           LDR      R4,[R12, +R4, LSL #+2]
   \   00000050   200424E0           EOR      R0,R4,R0, LSR #+8
   \   00000054   ........           LDRB     R4,[R1], #+1
   \   00000058   004024E0           EOR      R4,R4,R0
   \   0000005C   FF4004E2           AND      R4,R4,#0xFF
   \   00000060   04419CE7           LDR      R4,[R12, +R4, LSL #+2]
   \   00000064   200424E0           EOR      R0,R4,R0, LSR #+8
   \   00000068   ........           LDRB     R4,[R1], #+1
   \   0000006C   004024E0           EOR      R4,R4,R0
   \   00000070   FF4004E2           AND      R4,R4,#0xFF
   \   00000074   04419CE7           LDR      R4,[R12, +R4, LSL #+2]
   \   00000078   200424E0           EOR      R0,R4,R0, LSR #+8
   \   0000007C   ........           LDRB     R4,[R1], #+1
   \   00000080   004024E0           EOR      R4,R4,R0
   \   00000084   FF4004E2           AND      R4,R4,#0xFF
   \   00000088   04419CE7           LDR      R4,[R12, +R4, LSL #+2]
   \   0000008C   200424E0           EOR      R0,R4,R0, LSR #+8
   \   00000090   ........           LDRB     R4,[R1], #+1
   \   00000094   004024E0           EOR      R4,R4,R0
   \   00000098   FF4004E2           AND      R4,R4,#0xFF
   \   0000009C   04419CE7           LDR      R4,[R12, +R4, LSL #+2]
   \   000000A0   200424E0           EOR      R0,R4,R0, LSR #+8
   \   000000A4   ........           LDRB     R4,[R1], #+1
   \   000000A8   004024E0           EOR      R4,R4,R0
   \   000000AC   FF4004E2           AND      R4,R4,#0xFF
   \   000000B0   04419CE7           LDR      R4,[R12, +R4, LSL #+2]
   \   000000B4   200424E0           EOR      R0,R4,R0, LSR #+8
   \   000000B8   ........           LDRB     R4,[R1], #+1
   \   000000BC   004024E0           EOR      R4,R4,R0
   \   000000C0   FF4004E2           AND      R4,R4,#0xFF
   \   000000C4   04419CE7           LDR      R4,[R12, +R4, LSL #+2]
   \   000000C8   200424E0           EOR      R0,R4,R0, LSR #+8
   \   000000CC   D4FFFF2A           BCS      ??crc32_2
    247              if (len) do {
   \                     ??crc32_1:
   \   000000D0   000052E3           CMP      R2,#+0
   \   000000D4   0600000A           BEQ      ??crc32_3
    248                  DO1;
   \                     ??crc32_4:
   \   000000D8   ........           LDRB     R4,[R1], #+1
    249              } while (--len);
   \   000000DC   012052E2           SUBS     R2,R2,#+1
   \   000000E0   004024E0           EOR      R4,R4,R0
   \   000000E4   FF4004E2           AND      R4,R4,#0xFF
   \   000000E8   04419CE7           LDR      R4,[R12, +R4, LSL #+2]
   \   000000EC   200424E0           EOR      R0,R4,R0, LSR #+8
   \   000000F0   F8FFFF1A           BNE      ??crc32_4
    250              return crc ^ 0xffffffffUL;
   \                     ??crc32_3:
   \   000000F4   000023E0           EOR      R0,R3,R0
   \                     ??crc32_0:
   \   000000F8   1000BDE8           POP      {R4}
   \   000000FC   1EFF2FE1           BX       LR               ;; return
    251          }
    252          
    253          #ifdef BYFOUR
    254          
    255          /* ========================================================================= */
    256          #define DOLIT4 c ^= *buf4++; \
    257                  c = crc_table[3][c & 0xff] ^ crc_table[2][(c >> 8) & 0xff] ^ \
    258                      crc_table[1][(c >> 16) & 0xff] ^ crc_table[0][c >> 24]
    259          #define DOLIT32 DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4
    260          
    261          /* ========================================================================= */
    262          local unsigned long crc32_little(crc, buf, len)
    263              unsigned long crc;
    264              const unsigned char FAR *buf;
    265              unsigned len;
    266          {
    267              register u4 c;
    268              register const u4 FAR *buf4;
    269          
    270              c = (u4)crc;
    271              c = ~c;
    272              while (len && ((ptrdiff_t)buf & 3)) {
    273                  c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
    274                  len--;
    275              }
    276          
    277              buf4 = (const u4 FAR *)(const void FAR *)buf;
    278              while (len >= 32) {
    279                  DOLIT32;
    280                  len -= 32;
    281              }
    282              while (len >= 4) {
    283                  DOLIT4;
    284                  len -= 4;
    285              }
    286              buf = (const unsigned char FAR *)buf4;
    287          
    288              if (len) do {
    289                  c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
    290              } while (--len);
    291              c = ~c;
    292              return (unsigned long)c;
    293          }
    294          
    295          /* ========================================================================= */
    296          #define DOBIG4 c ^= *++buf4; \
    297                  c = crc_table[4][c & 0xff] ^ crc_table[5][(c >> 8) & 0xff] ^ \
    298                      crc_table[6][(c >> 16) & 0xff] ^ crc_table[7][c >> 24]
    299          #define DOBIG32 DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4
    300          
    301          /* ========================================================================= */
    302          local unsigned long crc32_big(crc, buf, len)
    303              unsigned long crc;
    304              const unsigned char FAR *buf;
    305              unsigned len;
    306          {
    307              register u4 c;
    308              register const u4 FAR *buf4;
    309          
    310              c = REV((u4)crc);
    311              c = ~c;
    312              while (len && ((ptrdiff_t)buf & 3)) {
    313                  c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
    314                  len--;
    315              }
    316          
    317              buf4 = (const u4 FAR *)(const void FAR *)buf;
    318              buf4--;
    319              while (len >= 32) {
    320                  DOBIG32;
    321                  len -= 32;
    322              }
    323              while (len >= 4) {
    324                  DOBIG4;
    325                  len -= 4;
    326              }
    327              buf4++;
    328              buf = (const unsigned char FAR *)buf4;
    329          
    330              if (len) do {
    331                  c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
    332              } while (--len);
    333              c = ~c;
    334              return (unsigned long)(REV(c));
    335          }
    336          
    337          #endif /* BYFOUR */
    338          
    339          #define GF2_DIM 32      /* dimension of GF(2) vectors (length of CRC) */
    340          
    341          /* ========================================================================= */

   \                                 In segment CODE, align 4, keep-with-next
    342          local unsigned long gf2_matrix_times(mat, vec)
    343              unsigned long *mat;
    344              unsigned long vec;
    345          {
    346              unsigned long sum;
    347          
    348              sum = 0;
   \                     gf2_matrix_times:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   000051E3           CMP      R1,#+0
   \   00000008   0600000A           BEQ      ??gf2_matrix_times_0
    349              while (vec) {
    350                  if (vec & 1)
   \                     ??gf2_matrix_times_1:
   \   0000000C   010011E3           TST      R1,#0x1
    351                      sum ^= *mat;
   \   00000010   00309015           LDRNE    R3,[R0, #+0]
    352                  vec >>= 1;
   \   00000014   A110A0E1           LSR      R1,R1,#+1
   \   00000018   02202310           EORNE    R2,R3,R2
    353                  mat++;
   \   0000001C   040080E2           ADD      R0,R0,#+4
    354              }
   \   00000020   000051E3           CMP      R1,#+0
   \   00000024   F8FFFF1A           BNE      ??gf2_matrix_times_1
    355              return sum;
   \                     ??gf2_matrix_times_0:
   \   00000028   0200A0E1           MOV      R0,R2
   \   0000002C   1EFF2FE1           BX       LR               ;; return
    356          }
    357          
    358          /* ========================================================================= */

   \                                 In segment CODE, align 4, keep-with-next
    359          local void gf2_matrix_square(square, mat)
    360              unsigned long *square;
    361              unsigned long *mat;
    362          {
   \                     gf2_matrix_square:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    363              int n;
    364          
    365              for (n = 0; n < GF2_DIM; n++)
   \   0000000C   0060A0E3           MOV      R6,#+0
    366                  square[n] = gf2_matrix_times(mat, mat[n]);
   \                     ??gf2_matrix_square_0:
   \   00000010   061195E7           LDR      R1,[R5, +R6, LSL #+2]
   \   00000014   0500A0E1           MOV      R0,R5
   \   00000018   ........           BL       gf2_matrix_times
   \   0000001C   060184E7           STR      R0,[R4, +R6, LSL #+2]
   \   00000020   016086E2           ADD      R6,R6,#+1
   \   00000024   200056E3           CMP      R6,#+32
   \   00000028   F8FFFFBA           BLT      ??gf2_matrix_square_0
    367          }
   \   0000002C   7080BDE8           POP      {R4-R6,PC}       ;; return
    368          
    369          /* ========================================================================= */

   \                                 In segment CODE, align 4, keep-with-next
    370          uLong ZEXPORT crc32_combine(crc1, crc2, len2)
    371              uLong crc1;
    372              uLong crc2;
    373              z_off_t len2;
    374          {
   \                     crc32_combine:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   40DF4DE2           SUB      SP,SP,#+256
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260B0E1           MOVS     R6,R2
    375              int n;
    376              unsigned long row;
    377              unsigned long even[GF2_DIM];    /* even-power-of-two zeros operator */
    378              unsigned long odd[GF2_DIM];     /* odd-power-of-two zeros operator */
    379          
    380              /* degenerate case */
    381              if (len2 == 0)
   \   00000014   2600000A           BEQ      ??crc32_combine_0
    382                  return crc1;
    383          
    384              /* put operator for one zero bit in odd */
    385              odd[0] = 0xedb88320L;           /* CRC-32 polynomial */
   \   00000018   9C109FE5           LDR      R1,??crc32_combine_1  ;; 0xffffffffedb88320
    386              row = 1;
   \   0000001C   0100A0E3           MOV      R0,#+1
   \   00000020   80108DE5           STR      R1,[SP, #+128]
    387              for (n = 1; n < GF2_DIM; n++) {
   \   00000024   0110A0E3           MOV      R1,#+1
   \   00000028   80208DE2           ADD      R2,SP,#+128
    388                  odd[n] = row;
   \                     ??crc32_combine_2:
   \   0000002C   010182E7           STR      R0,[R2, +R1, LSL #+2]
    389                  row <<= 1;
   \   00000030   8000A0E1           LSL      R0,R0,#+1
    390              }
   \   00000034   011081E2           ADD      R1,R1,#+1
   \   00000038   200051E3           CMP      R1,#+32
   \   0000003C   FAFFFFBA           BLT      ??crc32_combine_2
    391          
    392              /* put operator for two zero bits in even */
    393              gf2_matrix_square(even, odd);
   \   00000040   80108DE2           ADD      R1,SP,#+128
   \   00000044   0D00A0E1           MOV      R0,SP
   \   00000048   ........           BL       gf2_matrix_square
    394          
    395              /* put operator for four zero bits in odd */
    396              gf2_matrix_square(odd, even);
   \   0000004C   0D10A0E1           MOV      R1,SP
   \   00000050   80008DE2           ADD      R0,SP,#+128
   \   00000054   ........           BL       gf2_matrix_square
    397          
    398              /* apply len2 zeros to crc1 (first square will put the operator for one
    399                 zero byte, eight zero bits, in even) */
    400              do {
    401                  /* apply zeros operator for this bit of len2 */
    402                  gf2_matrix_square(even, odd);
   \                     ??crc32_combine_3:
   \   00000058   80108DE2           ADD      R1,SP,#+128
   \   0000005C   0D00A0E1           MOV      R0,SP
   \   00000060   ........           BL       gf2_matrix_square
    403                  if (len2 & 1)
   \   00000064   010016E3           TST      R6,#0x1
   \   00000068   0300000A           BEQ      ??crc32_combine_4
    404                      crc1 = gf2_matrix_times(even, crc1);
   \   0000006C   0410A0E1           MOV      R1,R4
   \   00000070   0D00A0E1           MOV      R0,SP
   \   00000074   ........           BL       gf2_matrix_times
   \   00000078   0040A0E1           MOV      R4,R0
    405                  len2 >>= 1;
   \                     ??crc32_combine_4:
   \   0000007C   C660B0E1           ASRS     R6,R6,#+1
    406          
    407                  /* if no more bits set, then done */
    408                  if (len2 == 0)
   \   00000080   0A00000A           BEQ      ??crc32_combine_5
    409                      break;
    410          
    411                  /* another iteration of the loop with odd and even swapped */
    412                  gf2_matrix_square(odd, even);
   \   00000084   0D10A0E1           MOV      R1,SP
   \   00000088   80008DE2           ADD      R0,SP,#+128
   \   0000008C   ........           BL       gf2_matrix_square
    413                  if (len2 & 1)
   \   00000090   010016E3           TST      R6,#0x1
   \   00000094   0300000A           BEQ      ??crc32_combine_6
    414                      crc1 = gf2_matrix_times(odd, crc1);
   \   00000098   0410A0E1           MOV      R1,R4
   \   0000009C   80008DE2           ADD      R0,SP,#+128
   \   000000A0   ........           BL       gf2_matrix_times
   \   000000A4   0040A0E1           MOV      R4,R0
    415                  len2 >>= 1;
   \                     ??crc32_combine_6:
   \   000000A8   C660B0E1           ASRS     R6,R6,#+1
    416          
    417                  /* if no more bits set, then done */
    418              } while (len2 != 0);
   \   000000AC   E9FFFF1A           BNE      ??crc32_combine_3
    419          
    420              /* return combined crc */
    421              crc1 ^= crc2;
    422              return crc1;
   \                     ??crc32_combine_5:
   \   000000B0   040025E0           EOR      R0,R5,R4
   \                     ??crc32_combine_0:
   \   000000B4   40DF8DE2           ADD      SP,SP,#+256      ;; stack cleaning
   \   000000B8   7080BDE8           POP      {R4-R6,PC}       ;; return
   \                     ??crc32_combine_1:
   \   000000BC   2083B8ED           DC32     0xffffffffedb88320
    423          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   ........           DC32     crc_table

   Maximum stack usage in bytes:

     Function          CSTACK
     --------          ------
     crc32                 4
     crc32_combine       272
     get_crc_table         0
     gf2_matrix_square    16
     gf2_matrix_times      0


   Segment part sizes:

     Function/Label    Bytes
     --------------    -----
     crc_table         1024
     get_crc_table        8
     crc32              256
     gf2_matrix_times    48
     gf2_matrix_square   48
     crc32_combine      192
     ??DataTable1         4
      Others             20

 
   576 bytes in segment CODE
 1 024 bytes in segment DATA_C
 
   556 bytes of CODE  memory (+ 20 bytes shared)
 1 024 bytes of CONST memory

Errors: none
Warnings: none
