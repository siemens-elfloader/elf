##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    31/Mar/2011  22:54:04 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\CBN\Arc\LzmaTest.c                            #
#    Command line    =  C:\arm\CBN\Arc\LzmaTest.c -D NEWSGOLD -D UNPACK -lC  #
#                       C:\arm\CBN\Z80\Release\List\ -o                      #
#                       C:\arm\CBN\Z80\Release\Obj\ -s9 --no_unroll          #
#                       --no_clustering --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --char_is_signed --fpu None -I "C:\arm2\Embedded     #
#                       Workbench 4.0 Evaluation\ARM\INC\"                   #
#                       --inline_threshold=2                                 #
#    List file       =  C:\arm\CBN\Z80\Release\List\LzmaTest.lst             #
#    Object file     =  C:\arm\CBN\Z80\Release\Obj\LzmaTest.r79              #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\CBN\Arc\LzmaTest.c
      1          
      2          // LZMA decoder
      3          // Не менять!!!
      4          #undef _LZMA_IN_CB 
      5          #undef _LZMA_OUT_READ 
      6          
      7          #include "..\swilib.h"
      8          #include "LzmaDecode.h"
      9          
     10          extern int loadfilesize;
     11          
     12          #define byte unsigned char
     13          #define true 1
     14          #define false 0
     15          

   \                                 In segment DATA_C, align 4, align-sorted
     16          const int waitEOS = 1; 
   \                     waitEOS:
   \   00000000   01000000           DC32 1
     17          // waitEOS = 1, if there is no uncompressed size in headers, 
     18          // so decoder will wait EOS (End of Stream Marker) in compressed stream 

   \                                 In segment DATA_C, align 4, align-sorted
     19          const int maxdirsize=4096;//32 kb
   \                     maxdirsize:
   \   00000000   00100000           DC32 4096

   \                                 In segment DATA_C, align 4, align-sorted
     20          const unsigned int hsize=0x20;//, bufSize=64*(1<<10);
   \                     hsize:
   \   00000000   20000000           DC32 32
     21          

   \                                 In segment DATA_I, align 4, align-sorted
     22          unsigned char properties[]={0x5d,0,0,0x80,0};
   \                     properties:
   \   00000000                      DS8 8
   \   00000008                      REQUIRE `?<Initializer for properties>`

   \                                 In segment DATA_Z, align 4, align-sorted
     23          CLzmaDecoderState state;  // it's about 24-80 bytes structure, if int is 32-bit 
   \                     state:
   \   00000000                      DS8 16

   \                                 In segment DATA_Z, align 4, align-sorted
     24          unsigned int getpos=0;
   \                     getpos:
   \   00000000                      DS8 4

   \                                 In segment DATA_Z, align 4, align-sorted
     25          SizeT outProcessed=0; //Сколько распаковалось
   \                     outProcessed:
   \   00000000                      DS8 4

   \                                 In segment DATA_Z, align 4, align-sorted
     26          char filename2[256];
   \                     filename2:
   \   00000000                      DS8 256
     27          
     28          
     29          //int getint(unsigned char *ptr){
     30          //  return ptr[0]|(ptr[1]<<8)|((ptr[2])<<16)|((ptr[3])<<24);
     31          //}
     32          

   \                                 In segment CODE, align 4, keep-with-next
     33          void prepname(char *file){
   \                     prepname:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   080000EA           B        ??prepname_0
     34            unsigned int err;
     35            do{
     36              while(*++file && *file!='/');
   \                     ??prepname_1:
   \   00000010   2F0050E3           CMP      R0,#+47
   \   00000014   0600001A           BNE      ??prepname_0
     37              if(!*file) break;
     38              *file=0;
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   0000C4E5           STRB     R0,[R4, #+0]
     39              mkdir(filename2,&err);
   \   00000020   1C009FE5           LDR      R0,??prepname_2  ;; filename2
   \   00000024   0D10A0E1           MOV      R1,SP
   \   00000028   100000EF           SWI      +16
     40              *file='\\';
   \   0000002C   5C00A0E3           MOV      R0,#+92
   \   00000030   0000C4E5           STRB     R0,[R4, #+0]
     41            }while(1);
   \                     ??prepname_0:
   \   00000034   D100F4E1           LDRSB    R0,[R4, #+1]!
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   F3FFFF1A           BNE      ??prepname_1
     42          }
   \   00000040   1180BDE8           POP      {R0,R4,PC}       ;; return
   \                     ??prepname_2:
   \   00000044   ........           DC32     filename2
     43          

   \                                 In segment CODE, align 4, keep-with-next
     44          int strcmp2(char *s, int p1, int p2, int size){
   \                     strcmp2:
   \   00000000   10002DE9           PUSH     {R4}
     45          	while(--size>=0)
   \                     ??strcmp2_0:
   \   00000004   013053E2           SUBS     R3,R3,#+1
   \   00000008   0A00004A           BMI      ??strcmp2_1
     46          	  if(s[p1++]!=s[p2++]) return false;
   \   0000000C   01C0A0E1           MOV      R12,R1
   \   00000010   01108CE2           ADD      R1,R12,#+1
   \   00000014   D0C09CE1           LDRSB    R12,[R12, +R0]
   \   00000018   0240A0E1           MOV      R4,R2
   \   0000001C   012084E2           ADD      R2,R4,#+1
   \   00000020   D04094E1           LDRSB    R4,[R4, +R0]
   \   00000024   04005CE1           CMP      R12,R4
   \   00000028   F5FFFF0A           BEQ      ??strcmp2_0
   \   0000002C   1000BDE8           POP      {R4}
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   1EFF2FE1           BX       LR
     47          	return true;
   \                     ??strcmp2_1:
   \   00000038   1000BDE8           POP      {R4}
   \   0000003C   0100A0E3           MOV      R0,#+1
   \   00000040   1EFF2FE1           BX       LR               ;; return
     48          }
     49          

   \                                 In segment CODE, align 4, keep-with-next
     50          int getempty(byte *buf, int pos, int cnt){
     51          	int i,k,rez=0;
   \                     getempty:
   \   00000000   0020A0E3           MOV      R2,#+0
     52          	do{
     53          	  k=buf[pos++]&0xff;
   \                     ??getempty_0:
   \   00000004   0030D1E7           LDRB     R3,[R1, +R0]
   \   00000008   011081E2           ADD      R1,R1,#+1
     54          	  for(i=0;i<8;i++){
   \   0000000C   00C0A0E3           MOV      R12,#+0
   \   00000010   040000EA           B        ??getempty_1
     55          	    if((k&0x80)==0) return rez;
     56          	    k<<=1;
   \                     ??getempty_2:
   \   00000014   8330A0E1           LSL      R3,R3,#+1
     57          	    ++rez;
   \   00000018   012082E2           ADD      R2,R2,#+1
   \   0000001C   01C08CE2           ADD      R12,R12,#+1
   \   00000020   08005CE3           CMP      R12,#+8
   \   00000024   F6FFFFAA           BGE      ??getempty_0
   \                     ??getempty_1:
   \   00000028   800013E3           TST      R3,#0x80
   \   0000002C   F8FFFF1A           BNE      ??getempty_2
   \   00000030   0200A0E1           MOV      R0,R2
   \   00000034   1EFF2FE1           BX       LR               ;; return
     58          	  }
     59          	}while(true);
     60          }
     61          

   \                                 In segment CODE, align 4, keep-with-next
     62          unsigned char *goun7z(char *inStream, UInt32 compressedSize, UInt32 outSize){ //* на буфер с распак. данными
   \                     goun7z:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0050A0E1           MOV      R5,R0
   \   0000000C   0160A0E1           MOV      R6,R1
   \   00000010   0270A0E1           MOV      R7,R2
     63          //  int res;                                            //outProcessed = сколько распаковалось
     64            SizeT inProcessed;
     65          //  unsigned char *inStream;
     66            unsigned char *outStream=0;
   \   00000014   0040A0E3           MOV      R4,#+0
     67          
     68            if(compressedSize && outSize){ //&& inFile!=-1
   \   00000018   000056E3           CMP      R6,#+0
   \   0000001C   00005713           CMPNE    R7,#+0
   \   00000020   2600000A           BEQ      ??goun7z_0
     69          //    if(!(inStream = (unsigned char *)malloc(compressedSize))) return 0;
     70             do{
     71          //    if(fread32(inFile,(char*)inStream,compressedSize,&err)!=compressedSize)  break;
     72              if(!(outStream =(unsigned char *)malloc(outSize))) break;
   \   00000024   0700A0E1           MOV      R0,R7
   \   00000028   140000EF           SWI      +20
   \   0000002C   0040B0E1           MOVS     R4,R0
   \   00000030   2200000A           BEQ      ??goun7z_0
     73              if (LzmaDecodeProperties(&state.Properties, properties, LZMA_PROPERTIES_SIZE) != LZMA_RESULT_OK){ mfree(outStream); outStream=0; break;}
   \   00000034   8C809FE5           LDR      R8,??goun7z_1    ;; state
   \   00000038   8C109FE5           LDR      R1,??goun7z_1+0x4  ;; properties
   \   0000003C   0520A0E3           MOV      R2,#+5
   \   00000040   0800A0E1           MOV      R0,R8
   \   00000044   ........           _BLF     LzmaDecodeProperties,??LzmaDecodeProperties??rA
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0400000A           BEQ      ??goun7z_2
   \   00000050   0400A0E1           MOV      R0,R4
   \   00000054   150000EF           SWI      +21
   \   00000058   0040A0E3           MOV      R4,#+0
   \   0000005C   0400A0E1           MOV      R0,R4
   \   00000060   F281BDE8           POP      {R1,R4-R8,PC}
     74              state.Probs = (CProb *)malloc(LzmaGetNumProbs(&state.Properties) * sizeof(CProb));
   \                     ??goun7z_2:
   \   00000064   001098E5           LDR      R1,[R8, #+0]
   \   00000068   042098E5           LDR      R2,[R8, #+4]
   \   0000006C   C00FA0E3           MOV      R0,#+768
   \   00000070   011082E0           ADD      R1,R2,R1
   \   00000074   3620A0E3           MOV      R2,#+54
   \   00000078   702E82E3           ORR      R2,R2,#0x700
   \   0000007C   100182E0           ADD      R0,R2,R0, LSL R1
   \   00000080   8000A0E1           LSL      R0,R0,#+1
   \   00000084   140000EF           SWI      +20
   \   00000088   0C0088E5           STR      R0,[R8, #+12]
     75              LzmaDecode(&state, (unsigned char*)inStream, compressedSize, &inProcessed, outStream, outSize, &outProcessed);
   \   0000008C   3C009FE5           LDR      R0,??goun7z_1+0x8  ;; outProcessed
   \   00000090   0620A0E1           MOV      R2,R6
   \   00000094   01002DE9           PUSH     {R0}
   \   00000098   80002DE9           PUSH     {R7}
   \   0000009C   0510A0E1           MOV      R1,R5
   \   000000A0   0400A0E1           MOV      R0,R4
   \   000000A4   01002DE9           PUSH     {R0}
   \   000000A8   0C308DE2           ADD      R3,SP,#+12
   \   000000AC   0800A0E1           MOV      R0,R8
   \   000000B0   ........           _BLF     LzmaDecode,??LzmaDecode??rA
     76              mfree(state.Probs);
   \   000000B4   0C0098E5           LDR      R0,[R8, #+12]
   \   000000B8   150000EF           SWI      +21
     77             }while(0); 
   \   000000BC   0CD08DE2           ADD      SP,SP,#+12
     78          //    mfree(inStream);
     79            }
     80            return outStream;
   \                     ??goun7z_0:
   \   000000C0   0400A0E1           MOV      R0,R4
   \   000000C4   F281BDE8           POP      {R1,R4-R8,PC}
   \                     ??goun7z_1:
   \   000000C8   ........           DC32     state
   \   000000CC   ........           DC32     properties
   \   000000D0   ........           DC32     outProcessed
     81          }
     82          
     83          //SevenZip

   \                                 In segment CODE, align 4, keep-with-next
     84                int get8b(byte *b){	//перекодировка 8байт
     85          		int i=0,v;
     86          		byte bb=b[getpos];
   \                     get8b:
   \   00000000   ........           LDR      R2,??DataTable1  ;; getpos
   \   00000004   10002DE9           PUSH     {R4}
   \   00000008   00C092E5           LDR      R12,[R2, #+0]
   \   0000000C   0030A0E3           MOV      R3,#+0
   \   00000010   0010DCE7           LDRB     R1,[R12, +R0]
   \   00000014   800011E3           TST      R1,#0x80
   \   00000018   0400000A           BEQ      ??get8b_0
     87          		while(bb&0x80){ bb<<=1; ++i;}
   \                     ??get8b_1:
   \   0000001C   811CA0E1           LSL      R1,R1,#+25
   \   00000020   211CA0E1           LSR      R1,R1,#+24
   \   00000024   013083E2           ADD      R3,R3,#+1
   \   00000028   800011E3           TST      R1,#0x80
   \   0000002C   FAFFFF1A           BNE      ??get8b_1
     88          		v=bb>>i;
   \                     ??get8b_0:
   \   00000030   5113A0E1           ASR      R1,R1,R3
     89          		switch(i){
   \   00000034   01C08CE2           ADD      R12,R12,#+1
   \   00000038   013053E2           SUBS     R3,R3,#+1
   \   0000003C   0400000A           BEQ      ??get8b_2
   \   00000040   013053E2           SUBS     R3,R3,#+1
   \   00000044   0600000A           BEQ      ??get8b_3
   \   00000048   013053E2           SUBS     R3,R3,#+1
   \   0000004C   0C00000A           BEQ      ??get8b_4
   \   00000050   160000EA           B        ??get8b_5
     90          		  case 1: v=(v<<8)|(b[++getpos]&0xff); break;
   \                     ??get8b_2:
   \   00000054   00C082E5           STR      R12,[R2, #+0]
   \   00000058   0000DCE7           LDRB     R0,[R12, +R0]
   \   0000005C   011480E1           ORR      R1,R0,R1, LSL #+8
   \   00000060   120000EA           B        ??get8b_5
     91          		  case 2: v=(v<<16)|(b[++getpos]&0xff)|((b[++getpos]&0xff)<<8); break;
                 		                                                              ^
Warning[Pa079]: undefined behavior: variable "getpos" (or a value reached by
          some form of indirection through it) is modified more than once
          without an intervening sequence point in this statement
   \                     ??get8b_3:
   \   00000064   00C082E5           STR      R12,[R2, #+0]
   \   00000068   01308CE2           ADD      R3,R12,#+1
   \   0000006C   003082E5           STR      R3,[R2, #+0]
   \   00000070   0040DCE7           LDRB     R4,[R12, +R0]
   \   00000074   0000D3E7           LDRB     R0,[R3, +R0]
   \   00000078   011884E1           ORR      R1,R4,R1, LSL #+16
   \   0000007C   001481E1           ORR      R1,R1,R0, LSL #+8
   \   00000080   0A0000EA           B        ??get8b_5
     92          		  case 3: v=(v<<24)|(b[++getpos]&0xff)|((b[++getpos]&0xff)<<8)|((b[++getpos]&0xff)<<16); break;
                 		                                                                                       ^
Warning[Pa079]: undefined behavior: variable "getpos" (or a value reached by
          some form of indirection through it) is modified more than once
          without an intervening sequence point in this statement
   \                     ??get8b_4:
   \   00000084   00C082E5           STR      R12,[R2, #+0]
   \   00000088   01308CE2           ADD      R3,R12,#+1
   \   0000008C   003082E5           STR      R3,[R2, #+0]
   \   00000090   014083E2           ADD      R4,R3,#+1
   \   00000094   004082E5           STR      R4,[R2, #+0]
   \   00000098   00C0DCE7           LDRB     R12,[R12, +R0]
   \   0000009C   0030D3E7           LDRB     R3,[R3, +R0]
   \   000000A0   0000D4E7           LDRB     R0,[R4, +R0]
   \   000000A4   011C8CE1           ORR      R1,R12,R1, LSL #+24
   \   000000A8   031481E1           ORR      R1,R1,R3, LSL #+8
   \   000000AC   001881E1           ORR      R1,R1,R0, LSL #+16
     93          		}
     94          		++getpos;
   \                     ??get8b_5:
   \   000000B0   000092E5           LDR      R0,[R2, #+0]
   \   000000B4   010080E2           ADD      R0,R0,#+1
   \   000000B8   000082E5           STR      R0,[R2, #+0]
     95          		return v;
   \   000000BC   1000BDE8           POP      {R4}
   \   000000C0   0100A0E1           MOV      R0,R1
   \   000000C4   1EFF2FE1           BX       LR               ;; return
     96          	}
     97          

   \                                 In segment CODE, align 4, keep-with-next
     98          char *un7z(char *buf){
   \                     un7z:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
     99            byte *b=(unsigned char*)buf;
    100          //  unsigned int err;
    101            char *buffer=0, *outbuf=0;
   \   00000008   3C049FE5           LDR      R0,??un7z_0      ;; loadfilesize
   \   0000000C   10D04DE2           SUB      SP,SP,#+16
   \   00000010   000090E5           LDR      R0,[R0, #+0]
   \   00000014   0010A0E3           MOV      R1,#+0
   \   00000018   08108DE5           STR      R1,[SP, #+8]
   \   0000001C   200050E3           CMP      R0,#+32
   \   00000020   0401003A           BCC      ??un7z_1
    102          //  int inFile=-1, outFile=-1;
    103            int headoff,headsize,h2size,pos,cnt,maxcnt,p,pp,empty;
    104            int *filesize, *fileunsize;
    105            char *name;//, *file;
    106            int ii;
    107          do{
    108            if(loadfilesize<hsize)  break;
    109            if(buf[0]!=0x37 || buf[1]!=0x7a) break;
   \   00000024   D000D4E1           LDRSB    R0,[R4, #+0]
   \   00000028   370050E3           CMP      R0,#+55
   \   0000002C   D100D401           LDRSBEQ  R0,[R4, #+1]
   \   00000030   7A005003           CMPEQ    R0,#+122
   \   00000034   FF00001A           BNE      ??un7z_1
    110            headoff=(buf[12]&0xff)|((buf[13]&0xff)<<8)|
    111            ((buf[14]&0xff)<<16)|((buf[15]&0xff)<<24);
   \   00000038   DC00D4E1           LDRSB    R0,[R4, #+12]
   \   0000003C   DD10D4E1           LDRSB    R1,[R4, #+13]
   \   00000040   FF0000E2           AND      R0,R0,#0xFF
    112            headsize=(buf[20]&0xff)|((buf[21]&0xff)<<8)|
    113            ((buf[22]&0xff)<<16)|((buf[23]&0xff)<<24);
    114            //inStream.skip(headoff+0x20);
    115            //lseek(inFile,headoff+0x20,0,&err,&err);
    116            //if(fread(inFile,b,hsize,&err)!=hsize)  break;
    117            b=(byte*)buf+headoff+0x20;
    118            if (b[0]==1 && b[1]==4 && b[2]==6){ //Распакованный заголовок!!
   \   00000044   ........           LDR      R5,??DataTable1  ;; getpos
   \   00000048   FF1001E2           AND      R1,R1,#0xFF
   \   0000004C   010480E1           ORR      R0,R0,R1, LSL #+8
   \   00000050   DE10D4E1           LDRSB    R1,[R4, #+14]
   \   00000054   FF1001E2           AND      R1,R1,#0xFF
   \   00000058   010880E1           ORR      R0,R0,R1, LSL #+16
   \   0000005C   DF10D4E1           LDRSB    R1,[R4, #+15]
   \   00000060   017C80E1           ORR      R7,R0,R1, LSL #+24
   \   00000064   D401D4E1           LDRSB    R0,[R4, #+20]
   \   00000068   D511D4E1           LDRSB    R1,[R4, #+21]
   \   0000006C   FF0000E2           AND      R0,R0,#0xFF
   \   00000070   FF1001E2           AND      R1,R1,#0xFF
   \   00000074   010480E1           ORR      R0,R0,R1, LSL #+8
   \   00000078   D611D4E1           LDRSB    R1,[R4, #+22]
   \   0000007C   FF1001E2           AND      R1,R1,#0xFF
   \   00000080   010880E1           ORR      R0,R0,R1, LSL #+16
   \   00000084   D711D4E1           LDRSB    R1,[R4, #+23]
   \   00000088   018C80E1           ORR      R8,R0,R1, LSL #+24
   \   0000008C   040087E0           ADD      R0,R7,R4
   \   00000090   206080E2           ADD      R6,R0,#+32
   \   00000094   0000D6E5           LDRB     R0,[R6, #+0]
   \   00000098   010050E3           CMP      R0,#+1
   \   0000009C   0100D605           LDRBEQ   R0,[R6, #+1]
   \   000000A0   04005003           CMPEQ    R0,#+4
   \   000000A4   0200D605           LDRBEQ   R0,[R6, #+2]
   \   000000A8   06005003           CMPEQ    R0,#+6
   \   000000AC   0900001A           BNE      ??un7z_2
    119              buffer=malloc(headsize);//-hsize);
   \   000000B0   0800A0E1           MOV      R0,R8
   \   000000B4   140000EF           SWI      +20
   \   000000B8   0060A0E1           MOV      R6,R0
    120              memcpy(buffer,buf+headoff+0x20,headsize);//-hsize);
   \   000000BC   0820A0E1           MOV      R2,R8
   \   000000C0   040087E0           ADD      R0,R7,R4
   \   000000C4   201080E2           ADD      R1,R0,#+32
   \   000000C8   0600A0E1           MOV      R0,R6
   \   000000CC   ........           _BLF     memcpy,??memcpy??rA
    121              //lseek(inFile,headoff+0x20,0,&err,&err);
    122              //fread32(inFile,buffer,headsize-hsize,&err);
    123              h2size=headsize;
   \   000000D0   00808DE5           STR      R8,[SP, #+0]
   \   000000D4   280000EA           B        ??un7z_3
    124            }else{
    125             	if (b[0]!=0x17 || b[1]!=6) break;
   \                     ??un7z_2:
   \   000000D8   0000D6E5           LDRB     R0,[R6, #+0]
   \   000000DC   170050E3           CMP      R0,#+23
   \   000000E0   0100D605           LDRBEQ   R0,[R6, #+1]
   \   000000E4   06005003           CMPEQ    R0,#+6
   \   000000E8   D200001A           BNE      ??un7z_1
    126          	  for(getpos=2;getpos<hsize-1;getpos++)
   \   000000EC   0280A0E3           MOV      R8,#+2
   \   000000F0   008085E5           STR      R8,[R5, #+0]
    127          	    if(b[getpos]==0 && b[getpos+1]==0xc) break;
   \                     ??un7z_4:
   \   000000F4   000095E5           LDR      R0,[R5, #+0]
   \   000000F8   061080E0           ADD      R1,R0,R6
   \   000000FC   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000100   000052E3           CMP      R2,#+0
   \   00000104   0110D105           LDRBEQ   R1,[R1, #+1]
   \   00000108   0C005103           CMPEQ    R1,#+12
   \   0000010C   0300000A           BEQ      ??un7z_5
   \   00000110   010080E2           ADD      R0,R0,#+1
   \   00000114   000085E5           STR      R0,[R5, #+0]
   \   00000118   1F0050E3           CMP      R0,#+31
   \   0000011C   F4FFFF3A           BCC      ??un7z_4
    128          	  if(b[++getpos]!=0xc) break;
   \                     ??un7z_5:
   \   00000120   000095E5           LDR      R0,[R5, #+0]
   \   00000124   010080E2           ADD      R0,R0,#+1
   \   00000128   000085E5           STR      R0,[R5, #+0]
   \   0000012C   0610D0E7           LDRB     R1,[R0, +R6]
   \   00000130   0C0051E3           CMP      R1,#+12
   \   00000134   BF00001A           BNE      ??un7z_1
    129          	  ++getpos;
   \   00000138   010080E2           ADD      R0,R0,#+1
   \   0000013C   000085E5           STR      R0,[R5, #+0]
    130          	  h2size=get8b(b);
   \   00000140   0600A0E1           MOV      R0,R6
   \   00000144   ........           BL       get8b
    131            	getpos=2;
   \   00000148   008085E5           STR      R8,[R5, #+0]
    132              ii=0x20+get8b(b);
   \   0000014C   0600A0E1           MOV      R0,R6
   \   00000150   ........           BL       get8b
   \   00000154   200080E2           ADD      R0,R0,#+32
    133              //lseek(inFile,ii,0,&err,&err);
    134              h2size=headoff+0x20-ii;
    135             //inStream.skip(0x20+get8b(b));//buf,ii
    136              if(!(buffer=(char*)goun7z(buf+ii,h2size,maxdirsize))) break;
   \   00000158   402DA0E3           MOV      R2,#+4096
   \   0000015C   201087E2           ADD      R1,R7,#+32
   \   00000160   001041E0           SUB      R1,R1,R0
   \   00000164   040080E0           ADD      R0,R0,R4
   \   00000168   ........           BL       goun7z
   \   0000016C   0060B0E1           MOVS     R6,R0
   \   00000170   B000000A           BEQ      ??un7z_1
    137              h2size=maxdirsize;
   \   00000174   401DA0E3           MOV      R1,#+4096
   \   00000178   00108DE5           STR      R1,[SP, #+0]
    138            }
    139          	b=(byte*)buffer;
    140          //////////// отладка (табл.симв.)
    141          //  int f;
    142          //  unsigned int err;
    143          //  if((f=fopen("0:\\ZBin\\234",A_ReadWrite+A_BIN+A_Create,P_READ+P_WRITE,&err))==-1) break;
    144          //  fwrite(f, buffer, headsize, &err);
    145          //  fclose(f,&err);
    146          //////////
    147          	if (b[0]!=1 || b[1]!=4 || b[2]!=6 || b[3]!=0) //Распакованный заголовок!! 00000
   \                     ??un7z_3:
   \   0000017C   0000D6E5           LDRB     R0,[R6, #+0]
   \   00000180   010050E3           CMP      R0,#+1
   \   00000184   0100D605           LDRBEQ   R0,[R6, #+1]
   \   00000188   04005003           CMPEQ    R0,#+4
   \   0000018C   0200D605           LDRBEQ   R0,[R6, #+2]
   \   00000190   06005003           CMPEQ    R0,#+6
   \   00000194   0300D605           LDRBEQ   R0,[R6, #+3]
   \   00000198   00005003           CMPEQ    R0,#+0
   \   0000019C   A500001A           BNE      ??un7z_1
    148                    break;
    149          	getpos=4;
   \   000001A0   0400A0E3           MOV      R0,#+4
   \   000001A4   000085E5           STR      R0,[R5, #+0]
    150          	maxcnt=get8b(b);
   \   000001A8   0600A0E1           MOV      R0,R6
   \   000001AC   ........           BL       get8b
   \   000001B0   0070A0E1           MOV      R7,R0
    151          	if(b[getpos++]!=9) break;
   \   000001B4   000095E5           LDR      R0,[R5, #+0]
   \   000001B8   011080E2           ADD      R1,R0,#+1
   \   000001BC   001085E5           STR      R1,[R5, #+0]
   \   000001C0   0600D0E7           LDRB     R0,[R0, +R6]
   \   000001C4   090050E3           CMP      R0,#+9
   \   000001C8   9A00001A           BNE      ??un7z_1
    152          	
    153                  filesize=(int *)malloc(maxcnt*2*sizeof(int));
   \   000001CC   8701A0E1           LSL      R0,R7,#+3
   \   000001D0   140000EF           SWI      +20
   \   000001D4   0080A0E1           MOV      R8,R0
    154                  fileunsize=filesize+maxcnt;
   \   000001D8   071188E0           ADD      R1,R8,R7, LSL #+2
   \   000001DC   04108DE5           STR      R1,[SP, #+4]
    155          	for(cnt=0;cnt<maxcnt;cnt++){
   \   000001E0   0090A0E3           MOV      R9,#+0
   \   000001E4   010057E3           CMP      R7,#+1
   \   000001E8   040000AA           BGE      ??un7z_6
   \   000001EC   050000EA           B        ??un7z_7
    156          	   filesize[cnt]=get8b(b);
   \                     ??un7z_8:
   \   000001F0   0600A0E1           MOV      R0,R6
   \   000001F4   ........           BL       get8b
   \   000001F8   090188E7           STR      R0,[R8, +R9, LSL #+2]
    157                  }
   \   000001FC   019089E2           ADD      R9,R9,#+1
   \                     ??un7z_6:
   \   00000200   070059E1           CMP      R9,R7
   \   00000204   F9FFFFBA           BLT      ??un7z_8
    158          	for(;getpos<h2size-1;getpos++)
   \                     ??un7z_7:
   \   00000208   000095E5           LDR      R0,[R5, #+0]
   \   0000020C   00209DE5           LDR      R2,[SP, #+0]
   \   00000210   011080E2           ADD      R1,R0,#+1
   \   00000214   01A042E2           SUB      R10,R2,#+1
   \   00000218   0A0050E1           CMP      R0,R10
   \   0000021C   0600002A           BCS      ??un7z_9
    159          	  if(b[getpos]==0 && b[getpos+1]==0xc) break;
   \   00000220   060080E0           ADD      R0,R0,R6
   \   00000224   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000228   000052E3           CMP      R2,#+0
   \   0000022C   0100D005           LDRBEQ   R0,[R0, #+1]
   \   00000230   0C005003           CMPEQ    R0,#+12
   \   00000234   00108515           STRNE    R1,[R5, #+0]
   \   00000238   F2FFFF1A           BNE      ??un7z_7
    160                  if(b[++getpos]!=0xc) break;
   \                     ??un7z_9:
   \   0000023C   001085E5           STR      R1,[R5, #+0]
   \   00000240   0600D1E7           LDRB     R0,[R1, +R6]
   \   00000244   0C0050E3           CMP      R0,#+12
   \   00000248   7A00001A           BNE      ??un7z_1
    161          	++getpos;
   \   0000024C   010081E2           ADD      R0,R1,#+1
   \   00000250   000085E5           STR      R0,[R5, #+0]
    162                  for(cnt=0;cnt<maxcnt;cnt++){
   \   00000254   0090A0E3           MOV      R9,#+0
   \   00000258   010057E3           CMP      R7,#+1
   \   0000025C   050000AA           BGE      ??un7z_10
   \   00000260   060000EA           B        ??un7z_11
    163          	   fileunsize[cnt]=get8b(b);
   \                     ??un7z_12:
   \   00000264   0600A0E1           MOV      R0,R6
   \   00000268   ........           BL       get8b
   \   0000026C   04109DE5           LDR      R1,[SP, #+4]
   \   00000270   090181E7           STR      R0,[R1, +R9, LSL #+2]
    164                  }
   \   00000274   019089E2           ADD      R9,R9,#+1
   \                     ??un7z_10:
   \   00000278   070059E1           CMP      R9,R7
   \   0000027C   F8FFFFBA           BLT      ??un7z_12
    165                  for(;getpos<h2size-1;getpos++)
   \                     ??un7z_11:
   \   00000280   000095E5           LDR      R0,[R5, #+0]
   \   00000284   011080E2           ADD      R1,R0,#+1
   \   00000288   0A0050E1           CMP      R0,R10
   \   0000028C   0600002A           BCS      ??un7z_13
    166          	  if(b[getpos]==0 && b[getpos+1]==5) break;
   \   00000290   060080E0           ADD      R0,R0,R6
   \   00000294   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000298   000052E3           CMP      R2,#+0
   \   0000029C   0100D005           LDRBEQ   R0,[R0, #+1]
   \   000002A0   05005003           CMPEQ    R0,#+5
   \   000002A4   00108515           STRNE    R1,[R5, #+0]
   \   000002A8   F4FFFF1A           BNE      ??un7z_11
    167          	if(b[++getpos]!=5) break;
   \                     ??un7z_13:
   \   000002AC   001085E5           STR      R1,[R5, #+0]
   \   000002B0   0600D1E7           LDRB     R0,[R1, +R6]
   \   000002B4   050050E3           CMP      R0,#+5
   \   000002B8   5E00001A           BNE      ??un7z_1
    168                  ++getpos;
   \   000002BC   010081E2           ADD      R0,R1,#+1
   \   000002C0   000085E5           STR      R0,[R5, #+0]
    169          	get8b(b);
   \   000002C4   0600A0E1           MOV      R0,R6
   \   000002C8   ........           BL       get8b
    170          	empty=0;
    171          	if(b[getpos]==0xe){	//Пустые заголовки
   \   000002CC   000095E5           LDR      R0,[R5, #+0]
   \   000002D0   00A0A0E3           MOV      R10,#+0
   \   000002D4   0610D0E7           LDRB     R1,[R0, +R6]
   \   000002D8   0E0051E3           CMP      R1,#+14
   \   000002DC   0F00001A           BNE      ??un7z_14
   \   000002E0   020080E2           ADD      R0,R0,#+2
   \   000002E4   000085E5           STR      R0,[R5, #+0]
   \   000002E8   C921A0E1           ASR      R2,R9,#+3
   \   000002EC   0010A0E1           MOV      R1,R0
   \   000002F0   0600A0E1           MOV      R0,R6
    172          	    ++getpos;
    173          	    empty=getempty(b,++getpos,cnt>>3);
   \   000002F4   ........           BL       getempty
   \   000002F8   00A0A0E1           MOV      R10,R0
    174          	    getpos+=(cnt>>3);//?
   \   000002FC   000095E5           LDR      R0,[R5, #+0]
   \   00000300   C90180E0           ADD      R0,R0,R9, ASR #+3
   \   00000304   000085E5           STR      R0,[R5, #+0]
    175          	    while(b[++getpos]==0);// ++getpos;
   \                     ??un7z_15:
   \   00000308   000095E5           LDR      R0,[R5, #+0]
   \   0000030C   010080E2           ADD      R0,R0,#+1
   \   00000310   000085E5           STR      R0,[R5, #+0]
   \   00000314   0600D0E7           LDRB     R0,[R0, +R6]
   \   00000318   000050E3           CMP      R0,#+0
   \   0000031C   F9FFFF0A           BEQ      ??un7z_15
    176          	 }
    177          	 if(b[getpos]==0x11){
   \                     ??un7z_14:
   \   00000320   000095E5           LDR      R0,[R5, #+0]
   \   00000324   0610D0E7           LDRB     R1,[R0, +R6]
   \   00000328   110051E3           CMP      R1,#+17
   \   0000032C   0300001A           BNE      ??un7z_16
    178          	    ++getpos;
   \   00000330   010080E2           ADD      R0,R0,#+1
   \   00000334   000085E5           STR      R0,[R5, #+0]
    179          	    get8b(b);
   \   00000338   0600A0E1           MOV      R0,R6
   \   0000033C   ........           BL       get8b
    180                   }
    181                --getpos;
   \                     ??un7z_16:
   \   00000340   000095E5           LDR      R0,[R5, #+0]
   \   00000344   010040E2           SUB      R0,R0,#+1
   \   00000348   000085E5           STR      R0,[R5, #+0]
    182                while(b[++getpos]==0);
   \                     ??un7z_17:
   \   0000034C   000095E5           LDR      R0,[R5, #+0]
   \   00000350   010080E2           ADD      R0,R0,#+1
   \   00000354   000085E5           STR      R0,[R5, #+0]
   \   00000358   0600D0E7           LDRB     R0,[R0, +R6]
   \   0000035C   000050E3           CMP      R0,#+0
   \   00000360   F9FFFF0A           BEQ      ??un7z_17
   \   00000364   00009DE5           LDR      R0,[SP, #+0]
   \   00000368   C000A0E1           ASR      R0,R0,#+1
    183                name = malloc(h2size>>1);
   \   0000036C   140000EF           SWI      +20
   \   00000370   00B0A0E1           MOV      R11,R0
    184                for(p=pp=0;p<(h2size>>1) && pp<cnt;p++){
   \   00000374   0000A0E3           MOV      R0,#+0
   \   00000378   0010A0E3           MOV      R1,#+0
   \   0000037C   010000EA           B        ??un7z_18
    185                  name[p]=(char)((b[getpos++]&0xff)+((b[getpos++]&0xff)<<8));
                                                                                   ^
Warning[Pa079]: undefined behavior: variable "getpos" (or a value reached by
          some form of indirection through it) is modified more than once
          without an intervening sequence point in this statement
    186                  if(name[p]==0)
    187                  if(empty>0){
    188                    p=pp=0; --p; --empty;
    189                  }else ++pp;
   \                     ??un7z_19:
   \   00000380   010080E2           ADD      R0,R0,#+1
   \                     ??un7z_20:
   \   00000384   011081E2           ADD      R1,R1,#+1
   \                     ??un7z_18:
   \   00000388   00209DE5           LDR      R2,[SP, #+0]
   \   0000038C   C20051E1           CMP      R1,R2, ASR #+1
   \   00000390   090050B1           CMPLT    R0,R9
   \   00000394   0E0000AA           BGE      ??un7z_21
   \   00000398   002095E5           LDR      R2,[R5, #+0]
   \   0000039C   D62092E1           LDRSB    R2,[R2, +R6]
   \   000003A0   0B20C1E7           STRB     R2,[R1, +R11]
   \   000003A4   002095E5           LDR      R2,[R5, #+0]
   \   000003A8   022082E2           ADD      R2,R2,#+2
   \   000003AC   002085E5           STR      R2,[R5, #+0]
   \   000003B0   DB2091E1           LDRSB    R2,[R1, +R11]
   \   000003B4   000052E3           CMP      R2,#+0
   \   000003B8   F1FFFF1A           BNE      ??un7z_20
   \   000003BC   01005AE3           CMP      R10,#+1
   \   000003C0   EEFFFFBA           BLT      ??un7z_19
   \   000003C4   0000A0E3           MOV      R0,#+0
   \   000003C8   0010E0E1           MVN      R1,R0
   \   000003CC   01A04AE2           SUB      R10,R10,#+1
   \   000003D0   EBFFFFEA           B        ??un7z_20
    190                }
    191                p=pp=0;
    192                pos=0x20;
    193               for(cnt=0;cnt<maxcnt; cnt++){ // && !main.stop
   \                     ??un7z_21:
   \   000003D4   010057E3           CMP      R7,#+1
   \   000003D8   0E0000BA           BLT      ??un7z_22
    194          	//while(name[pp]!=0) ++pp;
    195                  ///////
    196                  //memcpy(file,name+p,pp-p+1);
    197                  //prepname(file);
    198                  //outFile=-1;//fopen(filename2,A_ReadWrite+A_BIN+A_Create,P_READ+P_WRITE,&err);//tonewname(name+p,pp-p)
    199          	//p=++pp;
    200                  //lseek(inFile,pos,0,&err,&err);
    201                  mfree(buffer);/////(outbuf)!!!!
   \   000003DC   0600A0E1           MOV      R0,R6
   \   000003E0   150000EF           SWI      +21
    202                  buffer=0;     
    203          
    204                  if(!(outbuf=(char*)goun7z(buf+pos,filesize[cnt],fileunsize[cnt]))){
   \   000003E4   04009DE5           LDR      R0,[SP, #+4]
   \   000003E8   001098E5           LDR      R1,[R8, #+0]
   \   000003EC   002090E5           LDR      R2,[R0, #+0]
   \   000003F0   200084E2           ADD      R0,R4,#+32
   \   000003F4   ........           BL       goun7z
   \   000003F8   08008DE5           STR      R0,[SP, #+8]
   \   000003FC   000050E3           CMP      R0,#+0
   \   00000400   0800000A           BEQ      ??un7z_23
    205            	   //free(filesize); fclose(inFile); 
    206                     //if(outFile!=-1) fclose(outFile,&err);
    207                     goto lexit;
    208                     //return 11;
    209                  } loadfilesize=fileunsize[cnt];
   \   00000404   04109DE5           LDR      R1,[SP, #+4]
   \   00000408   3C009FE5           LDR      R0,??un7z_0      ;; loadfilesize
   \   0000040C   001091E5           LDR      R1,[R1, #+0]
   \   00000410   001080E5           STR      R1,[R0, #+0]
    210                    goto lexit;
   \   00000414   030000EA           B        ??un7z_23
    211          	//pos+=filesize[cnt];
    212                  //if(outFile!=-1){
    213                  //  fwrite32(outFile,buffer,fileunsize[cnt],&err);
    214                  //  fclose(outFile,&err);
    215                  //}
    216              }
    217              if(buffer) mfree(buffer);
   \                     ??un7z_22:
   \   00000418   000056E3           CMP      R6,#+0
   \   0000041C   0100000A           BEQ      ??un7z_23
   \   00000420   0600A0E1           MOV      R0,R6
   \   00000424   150000EF           SWI      +21
    218          lexit:
    219              mfree(name);
   \                     ??un7z_23:
   \   00000428   0B00A0E1           MOV      R0,R11
   \   0000042C   150000EF           SWI      +21
    220              mfree(filesize);
   \   00000430   0800A0E1           MOV      R0,R8
   \   00000434   150000EF           SWI      +21
    221           }while(0);
    222          // if(inFile!=-1) fclose(inFile,&err);
    223          // SUBPROC((void *)ElfKiller);
    224           mfree(buf);
   \                     ??un7z_1:
   \   00000438   0400A0E1           MOV      R0,R4
   \   0000043C   150000EF           SWI      +21
    225           return outbuf;
   \   00000440   08009DE5           LDR      R0,[SP, #+8]
   \   00000444   10D08DE2           ADD      SP,SP,#+16
   \   00000448   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??un7z_0:
   \   0000044C   ........           DC32     loadfilesize
    226          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   ........           DC32     getpos

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for properties>`:
   \   00000000   5D0000800000       DC8 93, 0, 0, 128, 0, 0, 0, 0
   \              0000        
    227          

   Maximum stack usage in bytes:

     Function CSTACK
     -------- ------
     get8b        4
     getempty     0
     goun7z      44
     prepname    12
     strcmp2      4
     un7z        52


   Segment part sizes:

     Function/Label                Bytes
     --------------                -----
     waitEOS                          4
     maxdirsize                       4
     hsize                            4
     properties                       8
     state                           16
     getpos                           4
     outProcessed                     4
     filename2                      256
     prepname                        72
     strcmp2                         68
     getempty                        56
     goun7z                         212
     get8b                          200
     un7z                          1104
     ??DataTable1                     4
     ?<Initializer for properties>    8
      Others                         84

 
 1 776 bytes in segment CODE
    12 bytes in segment DATA_C
     8 bytes in segment DATA_I
     8 bytes in segment DATA_ID
   280 bytes in segment DATA_Z
    24 bytes in segment INITTAB
 
 1 716 bytes of CODE  memory (+ 84 bytes shared)
    20 bytes of CONST memory
   288 bytes of DATA  memory

Errors: none
Warnings: 3
