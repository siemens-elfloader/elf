##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    31/Mar/2011  22:54:03 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\CBN\Arc\Zlib\INFLATE.C                        #
#    Command line    =  C:\arm\CBN\Arc\Zlib\INFLATE.C -D NEWSGOLD -D UNPACK  #
#                       -lC C:\arm\CBN\Z80\Release\List\ -o                  #
#                       C:\arm\CBN\Z80\Release\Obj\ -s9 --no_unroll          #
#                       --no_clustering --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --char_is_signed --fpu None -I "C:\arm2\Embedded     #
#                       Workbench 4.0 Evaluation\ARM\INC\"                   #
#                       --inline_threshold=2                                 #
#    List file       =  C:\arm\CBN\Z80\Release\List\INFLATE.lst              #
#    Object file     =  C:\arm\CBN\Z80\Release\Obj\INFLATE.r79               #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\CBN\Arc\Zlib\INFLATE.C
      1          /* inflate.c -- zlib decompression
      2           * Copyright (C) 1995-2005 Mark Adler
      3           * For conditions of distribution and use, see copyright notice in zlib.h
      4           */
      5          
      6          /*
      7           * Change history:
      8           *
      9           * 1.2.beta0    24 Nov 2002
     10           * - First version -- complete rewrite of inflate to simplify code, avoid
     11           *   creation of window when not needed, minimize use of window when it is
     12           *   needed, make inffast.c even faster, implement gzip decoding, and to
     13           *   improve code readability and style over the previous zlib inflate code
     14           *
     15           * 1.2.beta1    25 Nov 2002
     16           * - Use pointers for available input and output checking in inffast.c
     17           * - Remove input and output counters in inffast.c
     18           * - Change inffast.c entry and loop from avail_in >= 7 to >= 6
     19           * - Remove unnecessary second byte pull from length extra in inffast.c
     20           * - Unroll direct copy to three copies per loop in inffast.c
     21           *
     22           * 1.2.beta2    4 Dec 2002
     23           * - Change external routine names to reduce potential conflicts
     24           * - Correct filename to inffixed.h for fixed tables in inflate.c
     25           * - Make hbuf[] unsigned char to match parameter type in inflate.c
     26           * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset)
     27           *   to avoid negation problem on Alphas (64 bit) in inflate.c
     28           *
     29           * 1.2.beta3    22 Dec 2002
     30           * - Add comments on state->bits assertion in inffast.c
     31           * - Add comments on op field in inftrees.h
     32           * - Fix bug in reuse of allocated window after inflateReset()
     33           * - Remove bit fields--back to byte structure for speed
     34           * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths
     35           * - Change post-increments to pre-increments in inflate_fast(), PPC biased?
     36           * - Add compile time option, POSTINC, to use post-increments instead (Intel?)
     37           * - Make MATCH copy in inflate() much faster for when inflate_fast() not used
     38           * - Use local copies of stream next and avail values, as well as local bit
     39           *   buffer and bit count in inflate()--for speed when inflate_fast() not used
     40           *
     41           * 1.2.beta4    1 Jan 2003
     42           * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings
     43           * - Move a comment on output buffer sizes from inffast.c to inflate.c
     44           * - Add comments in inffast.c to introduce the inflate_fast() routine
     45           * - Rearrange window copies in inflate_fast() for speed and simplification
     46           * - Unroll last copy for window match in inflate_fast()
     47           * - Use local copies of window variables in inflate_fast() for speed
     48           * - Pull out common write == 0 case for speed in inflate_fast()
     49           * - Make op and len in inflate_fast() unsigned for consistency
     50           * - Add FAR to lcode and dcode declarations in inflate_fast()
     51           * - Simplified bad distance check in inflate_fast()
     52           * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new
     53           *   source file infback.c to provide a call-back interface to inflate for
     54           *   programs like gzip and unzip -- uses window as output buffer to avoid
     55           *   window copying
     56           *
     57           * 1.2.beta5    1 Jan 2003
     58           * - Improved inflateBack() interface to allow the caller to provide initial
     59           *   input in strm.
     60           * - Fixed stored blocks bug in inflateBack()
     61           *
     62           * 1.2.beta6    4 Jan 2003
     63           * - Added comments in inffast.c on effectiveness of POSTINC
     64           * - Typecasting all around to reduce compiler warnings
     65           * - Changed loops from while (1) or do {} while (1) to for (;;), again to
     66           *   make compilers happy
     67           * - Changed type of window in inflateBackInit() to unsigned char *
     68           *
     69           * 1.2.beta7    27 Jan 2003
     70           * - Changed many types to unsigned or unsigned short to avoid warnings
     71           * - Added inflateCopy() function
     72           *
     73           * 1.2.0        9 Mar 2003
     74           * - Changed inflateBack() interface to provide separate opaque descriptors
     75           *   for the in() and out() functions
     76           * - Changed inflateBack() argument and in_func typedef to swap the length
     77           *   and buffer address return values for the input function
     78           * - Check next_in and next_out for Z_NULL on entry to inflate()
     79           *
     80           * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.
     81           */
     82          #pragma swi_number=0x011E
     83          __swi	__arm	void * memcpy (void *dest,const void *source,int cnt);
     84          
     85          //#include "E:\ARM\swilib.h"
     86          #include "zutil.h"
     87          #include "inftrees.h"
     88          #include "inflate.h"
     89          #include "inffast.h"
     90          
     91          #ifdef MAKEFIXED
     92          #  ifndef BUILDFIXED
     93          #    define BUILDFIXED
     94          #  endif
     95          #endif
     96          
     97          /* function prototypes */
     98          local void fixedtables OF((struct inflate_state FAR *state));
     99          local int updatewindow OF((z_streamp strm, unsigned out));
    100          #ifdef BUILDFIXED
    101             void makefixed OF((void));
    102          #endif
    103          local unsigned syncsearch OF((unsigned FAR *have, unsigned char FAR *buf,
    104                                        unsigned len));
    105          

   \                                 In segment CODE, align 4, keep-with-next
    106          int ZEXPORT inflateReset(strm)
    107          z_streamp strm;
    108          {
    109              struct inflate_state FAR *state;
    110          
    111              if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
   \                     inflateReset:
   \   00000000   000050E3           CMP      R0,#+0
   \   00000004   1C109015           LDRNE    R1,[R0, #+28]
   \   00000008   00005113           CMPNE    R1,#+0
   \   0000000C   0100E003           MVNEQ    R0,#+1
   \   00000010   1EFF2F01           BXEQ     LR
    112              state = (struct inflate_state FAR *)strm->state;
    113              strm->total_in = strm->total_out = state->total = 0;
   \   00000014   0020A0E3           MOV      R2,#+0
   \   00000018   1C2081E5           STR      R2,[R1, #+28]
   \   0000001C   142080E5           STR      R2,[R0, #+20]
   \   00000020   082080E5           STR      R2,[R0, #+8]
    114              strm->msg = Z_NULL;
   \   00000024   182080E5           STR      R2,[R0, #+24]
    115              strm->adler = 1;        /* to support ill-conceived Java test suite */
   \   00000028   0130A0E3           MOV      R3,#+1
   \   0000002C   303080E5           STR      R3,[R0, #+48]
    116              state->mode = HEAD;
   \   00000030   0020C1E5           STRB     R2,[R1, #+0]
    117              state->last = 0;
   \   00000034   042081E5           STR      R2,[R1, #+4]
    118              state->havedict = 0;
   \   00000038   0C2081E5           STR      R2,[R1, #+12]
    119              state->dmax = 32768U;
   \   0000003C   800CA0E3           MOV      R0,#+32768
   \   00000040   140081E5           STR      R0,[R1, #+20]
    120              state->head = Z_NULL;
   \   00000044   202081E5           STR      R2,[R1, #+32]
    121              state->wsize = 0;
   \   00000048   282081E5           STR      R2,[R1, #+40]
    122              state->whave = 0;
   \   0000004C   2C2081E5           STR      R2,[R1, #+44]
    123              state->write = 0;
   \   00000050   302081E5           STR      R2,[R1, #+48]
    124              state->hold = 0;
   \   00000054   382081E5           STR      R2,[R1, #+56]
    125              state->bits = 0;
   \   00000058   3C2081E5           STR      R2,[R1, #+60]
    126              state->lencode = state->distcode = state->next = state->codes;
   \   0000005C   530E81E2           ADD      R0,R1,#+1328
   \   00000060   6C0081E5           STR      R0,[R1, #+108]
   \   00000064   500081E5           STR      R0,[R1, #+80]
   \   00000068   4C0081E5           STR      R0,[R1, #+76]
    127              Tracev((stderr, "inflate: reset\n"));
    128              return Z_OK;
   \   0000006C   0000A0E3           MOV      R0,#+0
   \   00000070   1EFF2FE1           BX       LR               ;; return
    129          }
    130          

   \                                 In segment CODE, align 4, keep-with-next
    131          int ZEXPORT inflatePrime(strm, bits, value)
    132          z_streamp strm;
    133          int bits;
    134          int value;
    135          {
   \                     inflatePrime:
   \   00000000   30002DE9           PUSH     {R4,R5}
    136              struct inflate_state FAR *state;
    137          
    138              if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   1C009015           LDRNE    R0,[R0, #+28]
   \   0000000C   00005013           CMPNE    R0,#+0
   \   00000010   0200001A           BNE      ??inflatePrime_0
   \                     ??inflatePrime_1:
   \   00000014   3000BDE8           POP      {R4,R5}
   \   00000018   0100E0E3           MVN      R0,#+1
   \   0000001C   1EFF2FE1           BX       LR
    139              state = (struct inflate_state FAR *)strm->state;
    140              if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;
   \                     ??inflatePrime_0:
   \   00000020   110051E3           CMP      R1,#+17
   \   00000024   FAFFFFAA           BGE      ??inflatePrime_1
   \   00000028   3C3090E5           LDR      R3,[R0, #+60]
   \   0000002C   03C081E0           ADD      R12,R1,R3
   \   00000030   21005CE3           CMP      R12,#+33
   \   00000034   F6FFFF2A           BCS      ??inflatePrime_1
    141              value &= (1L << bits) - 1;
    142              state->hold += value << state->bits;
   \   00000038   384090E5           LDR      R4,[R0, #+56]
   \   0000003C   0150A0E3           MOV      R5,#+1
   \   00000040   1511A0E1           LSL      R1,R5,R1
   \   00000044   011041E2           SUB      R1,R1,#+1
   \   00000048   021001E0           AND      R1,R1,R2
   \   0000004C   111384E0           ADD      R1,R4,R1, LSL R3
   \   00000050   381080E5           STR      R1,[R0, #+56]
    143              state->bits += bits;
   \   00000054   3CC080E5           STR      R12,[R0, #+60]
    144              return Z_OK;
   \   00000058   3000BDE8           POP      {R4,R5}
   \   0000005C   0000A0E3           MOV      R0,#+0
   \   00000060   1EFF2FE1           BX       LR               ;; return
    145          }
    146          

   \                                 In segment CODE, align 4, keep-with-next
    147          int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
    148          z_streamp strm;
    149          int windowBits;
    150          const char *version;
    151          int stream_size;
    152          {
   \                     inflateInit2_:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    153              struct inflate_state FAR *state;
    154          
    155              if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
    156                  stream_size != (int)(sizeof(z_stream)))
   \   0000000C   000052E3           CMP      R2,#+0
   \   00000010   0300000A           BEQ      ??inflateInit2__0
   \   00000014   D000D2E1           LDRSB    R0,[R2, #+0]
   \   00000018   310050E3           CMP      R0,#+49
   \   0000001C   38005303           CMPEQ    R3,#+56
   \   00000020   0100000A           BEQ      ??inflateInit2__1
    157                  return Z_VERSION_ERROR;
   \                     ??inflateInit2__0:
   \   00000024   0500E0E3           MVN      R0,#+5
   \   00000028   7080BDE8           POP      {R4-R6,PC}
    158              if (strm == Z_NULL) return Z_STREAM_ERROR;
   \                     ??inflateInit2__1:
   \   0000002C   000054E3           CMP      R4,#+0
   \   00000030   2600000A           BEQ      ??inflateInit2__2
    159              strm->msg = Z_NULL;                 /* in case we return an error */
   \   00000034   0060A0E3           MOV      R6,#+0
   \   00000038   186084E5           STR      R6,[R4, #+24]
    160              if (strm->zalloc == (alloc_func)0) {
   \   0000003C   200094E5           LDR      R0,[R4, #+32]
    161                  strm->zalloc = zcalloc;
    162                  strm->opaque = (voidpf)0;
    163              }
    164              if (strm->zfree == (free_func)0) strm->zfree = zcfree;
    165              state = (struct inflate_state FAR *)
    166                      ZALLOC(strm, 1, sizeof(struct inflate_state));
   \   00000040   3020A0E3           MOV      R2,#+48
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   9C009F05           LDREQ    R0,??inflateInit2__3  ;; zcalloc
   \   0000004C   942D82E3           ORR      R2,R2,#0x2500
   \   00000050   20008405           STREQ    R0,[R4, #+32]
   \   00000054   28608405           STREQ    R6,[R4, #+40]
   \   00000058   240094E5           LDR      R0,[R4, #+36]
   \   0000005C   0110A0E3           MOV      R1,#+1
   \   00000060   000050E3           CMP      R0,#+0
   \   00000064   84009F05           LDREQ    R0,??inflateInit2__3+0x4  ;; zcfree
   \   00000068   24008405           STREQ    R0,[R4, #+36]
   \   0000006C   280094E5           LDR      R0,[R4, #+40]
   \   00000070   203094E5           LDR      R3,[R4, #+32]
   \   00000074   33FF2FE1           BLX      R3
    167              if (state == Z_NULL) return Z_MEM_ERROR;
   \   00000078   000050E3           CMP      R0,#+0
   \   0000007C   0300E003           MVNEQ    R0,#+3
   \   00000080   7080BD08           POPEQ    {R4-R6,PC}
    168              Tracev((stderr, "inflate: allocated\n"));
    169              strm->state = (struct internal_state FAR *)state;
   \   00000084   1C0084E5           STR      R0,[R4, #+28]
    170              if (windowBits < 0) {
   \   00000088   000055E3           CMP      R5,#+0
    171                  state->wrap = 0;
   \   0000008C   0010A043           MOVMI    R1,#+0
    172                  windowBits = -windowBits;
   \   00000090   00506542           RSBMI    R5,R5,#+0
   \   00000094   0300004A           BMI      ??inflateInit2__4
    173              }
    174              else {
    175                  state->wrap = (windowBits >> 4) + 1;
   \   00000098   0110A0E3           MOV      R1,#+1
   \   0000009C   451281E0           ADD      R1,R1,R5, ASR #+4
    176          #ifdef GUNZIP
    177                  if (windowBits < 48) windowBits &= 15;
   \   000000A0   300055E3           CMP      R5,#+48
   \   000000A4   0F5005B2           ANDLT    R5,R5,#0xF
   \                     ??inflateInit2__4:
   \   000000A8   081080E5           STR      R1,[R0, #+8]
    178          #endif
    179              }
    180              if (windowBits < 8 || windowBits > 15) {
   \   000000AC   080055E3           CMP      R5,#+8
   \   000000B0   010000BA           BLT      ??inflateInit2__5
   \   000000B4   100055E3           CMP      R5,#+16
   \   000000B8   060000BA           BLT      ??inflateInit2__6
    181                  ZFREE(strm, state);
   \                     ??inflateInit2__5:
   \   000000BC   242094E5           LDR      R2,[R4, #+36]
   \   000000C0   0010A0E1           MOV      R1,R0
   \   000000C4   280094E5           LDR      R0,[R4, #+40]
   \   000000C8   32FF2FE1           BLX      R2
    182                  strm->state = Z_NULL;
   \   000000CC   1C6084E5           STR      R6,[R4, #+28]
    183                  return Z_STREAM_ERROR;
   \                     ??inflateInit2__2:
   \   000000D0   0100E0E3           MVN      R0,#+1
   \   000000D4   7080BDE8           POP      {R4-R6,PC}
    184              }
    185              state->wbits = (unsigned)windowBits;
   \                     ??inflateInit2__6:
   \   000000D8   245080E5           STR      R5,[R0, #+36]
    186              state->window = Z_NULL;
   \   000000DC   346080E5           STR      R6,[R0, #+52]
    187              return inflateReset(strm);
   \   000000E0   0400A0E1           MOV      R0,R4
   \   000000E4   ........           BL       inflateReset
   \   000000E8   7080BDE8           POP      {R4-R6,PC}       ;; return
   \                     ??inflateInit2__3:
   \   000000EC   ........           DC32     zcalloc
   \   000000F0   ........           DC32     zcfree
    188          }
    189          

   \                                 In segment CODE, align 4, keep-with-next
    190          int ZEXPORT inflateInit_(strm, version, stream_size)
    191          z_streamp strm;
    192          const char *version;
    193          int stream_size;
    194          {
    195              return inflateInit2_(strm, DEF_WBITS, version, stream_size);
   \                     inflateInit_:
   \   00000000   0230A0E1           MOV      R3,R2
   \   00000004   0120A0E1           MOV      R2,R1
   \   00000008   0F10A0E3           MOV      R1,#+15
   \   0000000C   ........           B        inflateInit2_    ;; tailcall
    196          }
    197          
    198          /*
    199             Return state with length and distance decoding tables and index sizes set to
    200             fixed code decoding.  Normally this returns fixed tables from inffixed.h.
    201             If BUILDFIXED is defined, then instead this routine builds the tables the
    202             first time it's called, and returns those tables the first time and
    203             thereafter.  This reduces the size of the code by about 2K bytes, in
    204             exchange for a little execution time.  However, BUILDFIXED should not be
    205             used for threaded applications, since the rewriting of the tables and virgin
    206             may not be thread-safe.
    207           */

   \                                 In segment CODE, align 4, keep-with-next
    208          local void fixedtables(state)
    209          struct inflate_state FAR *state;
    210          {
    211          #ifdef BUILDFIXED
    212              static int virgin = 1;
    213              static code *lenfix, *distfix;
    214              static code fixed[544];
    215          
    216              /* build fixed huffman tables if first call (may not be thread safe) */
    217              if (virgin) {
    218                  unsigned sym, bits;
    219                  static code *next;
    220          
    221                  /* literal/length table */
    222                  sym = 0;
    223                  while (sym < 144) state->lens[sym++] = 8;
    224                  while (sym < 256) state->lens[sym++] = 9;
    225                  while (sym < 280) state->lens[sym++] = 7;
    226                  while (sym < 288) state->lens[sym++] = 8;
    227                  next = fixed;
    228                  lenfix = next;
    229                  bits = 9;
    230                  inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
    231          
    232                  /* distance table */
    233                  sym = 0;
    234                  while (sym < 32) state->lens[sym++] = 5;
    235                  distfix = next;
    236                  bits = 5;
    237                  inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
    238          
    239                  /* do this just once */
    240                  virgin = 0;
    241              }
    242          #else /* !BUILDFIXED */
    243          #   include "inffixed.h"
    244          #endif /* BUILDFIXED */
    245              state->lencode = lenfix;
   \                     fixedtables:
   \   00000000   1C109FE5           LDR      R1,??fixedtables_0  ;; ??lenfix
   \   00000004   4C1080E5           STR      R1,[R0, #+76]
    246              state->lenbits = 9;
   \   00000008   0910A0E3           MOV      R1,#+9
   \   0000000C   541080E5           STR      R1,[R0, #+84]
    247              state->distcode = distfix;
   \   00000010   10109FE5           LDR      R1,??fixedtables_0+0x4  ;; ??distfix
   \   00000014   501080E5           STR      R1,[R0, #+80]
    248              state->distbits = 5;
   \   00000018   0510A0E3           MOV      R1,#+5
   \   0000001C   581080E5           STR      R1,[R0, #+88]
    249          }
   \   00000020   1EFF2FE1           BX       LR               ;; return
   \                     ??fixedtables_0:
   \   00000024   ........           DC32     ??lenfix
   \   00000028   ........           DC32     ??distfix

   \                                 In segment DATA_C, align 4, align-sorted
   \   struct <unnamed> const __data lenfix[512]
   \                     ??lenfix:
   \   00000000   6007               DC8 96, 7
   \   00000002   0000               DC16 0
   \   00000004   0008               DC8 0, 8
   \   00000006   5000               DC16 80
   \   00000008   0008               DC8 0, 8
   \   0000000A   1000               DC16 16
   \   0000000C   1408               DC8 20, 8
   \   0000000E   7300               DC16 115
   \   00000010   1207               DC8 18, 7
   \   00000012   1F00               DC16 31
   \   00000014   0008               DC8 0, 8
   \   00000016   7000               DC16 112
   \   00000018   0008               DC8 0, 8
   \   0000001A   3000               DC16 48
   \   0000001C   0009               DC8 0, 9
   \   0000001E   C000               DC16 192
   \   00000020   1007               DC8 16, 7
   \   00000022   0A00               DC16 10
   \   00000024   0008               DC8 0, 8
   \   00000026   6000               DC16 96
   \   00000028   0008               DC8 0, 8
   \   0000002A   2000               DC16 32
   \   0000002C   0009               DC8 0, 9
   \   0000002E   A000               DC16 160
   \   00000030   0008               DC8 0, 8
   \   00000032   0000               DC16 0
   \   00000034   0008               DC8 0, 8
   \   00000036   8000               DC16 128
   \   00000038   0008               DC8 0, 8
   \   0000003A   4000               DC16 64
   \   0000003C   0009               DC8 0, 9
   \   0000003E   E000               DC16 224
   \   00000040   1007               DC8 16, 7
   \   00000042   0600               DC16 6
   \   00000044   0008               DC8 0, 8
   \   00000046   5800               DC16 88
   \   00000048   0008               DC8 0, 8
   \   0000004A   1800               DC16 24
   \   0000004C   0009               DC8 0, 9
   \   0000004E   9000               DC16 144
   \   00000050   1307               DC8 19, 7
   \   00000052   3B00               DC16 59
   \   00000054   0008               DC8 0, 8
   \   00000056   7800               DC16 120
   \   00000058   0008               DC8 0, 8
   \   0000005A   3800               DC16 56
   \   0000005C   0009               DC8 0, 9
   \   0000005E   D000               DC16 208
   \   00000060   1107               DC8 17, 7
   \   00000062   1100               DC16 17
   \   00000064   0008               DC8 0, 8
   \   00000066   6800               DC16 104
   \   00000068   0008               DC8 0, 8
   \   0000006A   2800               DC16 40
   \   0000006C   0009               DC8 0, 9
   \   0000006E   B000               DC16 176
   \   00000070   0008               DC8 0, 8
   \   00000072   0800               DC16 8
   \   00000074   0008               DC8 0, 8
   \   00000076   8800               DC16 136
   \   00000078   0008               DC8 0, 8
   \   0000007A   4800               DC16 72
   \   0000007C   0009               DC8 0, 9
   \   0000007E   F000               DC16 240
   \   00000080   1007               DC8 16, 7
   \   00000082   0400               DC16 4
   \   00000084   0008               DC8 0, 8
   \   00000086   5400               DC16 84
   \   00000088   0008               DC8 0, 8
   \   0000008A   1400               DC16 20
   \   0000008C   1508               DC8 21, 8
   \   0000008E   E300               DC16 227
   \   00000090   1307               DC8 19, 7
   \   00000092   2B00               DC16 43
   \   00000094   0008               DC8 0, 8
   \   00000096   7400               DC16 116
   \   00000098   0008               DC8 0, 8
   \   0000009A   3400               DC16 52
   \   0000009C   0009               DC8 0, 9
   \   0000009E   C800               DC16 200
   \   000000A0   1107               DC8 17, 7
   \   000000A2   0D00               DC16 13
   \   000000A4   0008               DC8 0, 8
   \   000000A6   6400               DC16 100
   \   000000A8   0008               DC8 0, 8
   \   000000AA   2400               DC16 36
   \   000000AC   0009               DC8 0, 9
   \   000000AE   A800               DC16 168
   \   000000B0   0008               DC8 0, 8
   \   000000B2   0400               DC16 4
   \   000000B4   0008               DC8 0, 8
   \   000000B6   8400               DC16 132
   \   000000B8   0008               DC8 0, 8
   \   000000BA   4400               DC16 68
   \   000000BC   0009               DC8 0, 9
   \   000000BE   E800               DC16 232
   \   000000C0   1007               DC8 16, 7
   \   000000C2   0800               DC16 8
   \   000000C4   0008               DC8 0, 8
   \   000000C6   5C00               DC16 92
   \   000000C8   0008               DC8 0, 8
   \   000000CA   1C00               DC16 28
   \   000000CC   0009               DC8 0, 9
   \   000000CE   9800               DC16 152
   \   000000D0   1407               DC8 20, 7
   \   000000D2   5300               DC16 83
   \   000000D4   0008               DC8 0, 8
   \   000000D6   7C00               DC16 124
   \   000000D8   0008               DC8 0, 8
   \   000000DA   3C00               DC16 60
   \   000000DC   0009               DC8 0, 9
   \   000000DE   D800               DC16 216
   \   000000E0   1207               DC8 18, 7
   \   000000E2   1700               DC16 23
   \   000000E4   0008               DC8 0, 8
   \   000000E6   6C00               DC16 108
   \   000000E8   0008               DC8 0, 8
   \   000000EA   2C00               DC16 44
   \   000000EC   0009               DC8 0, 9
   \   000000EE   B800               DC16 184
   \   000000F0   0008               DC8 0, 8
   \   000000F2   0C00               DC16 12
   \   000000F4   0008               DC8 0, 8
   \   000000F6   8C00               DC16 140
   \   000000F8   0008               DC8 0, 8
   \   000000FA   4C00               DC16 76
   \   000000FC   0009               DC8 0, 9
   \   000000FE   F800               DC16 248
   \   00000100   1007               DC8 16, 7
   \   00000102   0300               DC16 3
   \   00000104   0008               DC8 0, 8
   \   00000106   5200               DC16 82
   \   00000108   0008               DC8 0, 8
   \   0000010A   1200               DC16 18
   \   0000010C   1508               DC8 21, 8
   \   0000010E   A300               DC16 163
   \   00000110   1307               DC8 19, 7
   \   00000112   2300               DC16 35
   \   00000114   0008               DC8 0, 8
   \   00000116   7200               DC16 114
   \   00000118   0008               DC8 0, 8
   \   0000011A   3200               DC16 50
   \   0000011C   0009               DC8 0, 9
   \   0000011E   C400               DC16 196
   \   00000120   1107               DC8 17, 7
   \   00000122   0B00               DC16 11
   \   00000124   0008               DC8 0, 8
   \   00000126   6200               DC16 98
   \   00000128   0008               DC8 0, 8
   \   0000012A   2200               DC16 34
   \   0000012C   0009               DC8 0, 9
   \   0000012E   A400               DC16 164
   \   00000130   0008               DC8 0, 8
   \   00000132   0200               DC16 2
   \   00000134   0008               DC8 0, 8
   \   00000136   8200               DC16 130
   \   00000138   0008               DC8 0, 8
   \   0000013A   4200               DC16 66
   \   0000013C   0009               DC8 0, 9
   \   0000013E   E400               DC16 228
   \   00000140   1007               DC8 16, 7
   \   00000142   0700               DC16 7
   \   00000144   0008               DC8 0, 8
   \   00000146   5A00               DC16 90
   \   00000148   0008               DC8 0, 8
   \   0000014A   1A00               DC16 26
   \   0000014C   0009               DC8 0, 9
   \   0000014E   9400               DC16 148
   \   00000150   1407               DC8 20, 7
   \   00000152   4300               DC16 67
   \   00000154   0008               DC8 0, 8
   \   00000156   7A00               DC16 122
   \   00000158   0008               DC8 0, 8
   \   0000015A   3A00               DC16 58
   \   0000015C   0009               DC8 0, 9
   \   0000015E   D400               DC16 212
   \   00000160   1207               DC8 18, 7
   \   00000162   1300               DC16 19
   \   00000164   0008               DC8 0, 8
   \   00000166   6A00               DC16 106
   \   00000168   0008               DC8 0, 8
   \   0000016A   2A00               DC16 42
   \   0000016C   0009               DC8 0, 9
   \   0000016E   B400               DC16 180
   \   00000170   0008               DC8 0, 8
   \   00000172   0A00               DC16 10
   \   00000174   0008               DC8 0, 8
   \   00000176   8A00               DC16 138
   \   00000178   0008               DC8 0, 8
   \   0000017A   4A00               DC16 74
   \   0000017C   0009               DC8 0, 9
   \   0000017E   F400               DC16 244
   \   00000180   1007               DC8 16, 7
   \   00000182   0500               DC16 5
   \   00000184   0008               DC8 0, 8
   \   00000186   5600               DC16 86
   \   00000188   0008               DC8 0, 8
   \   0000018A   1600               DC16 22
   \   0000018C   4008               DC8 64, 8
   \   0000018E   0000               DC16 0
   \   00000190   1307               DC8 19, 7
   \   00000192   3300               DC16 51
   \   00000194   0008               DC8 0, 8
   \   00000196   7600               DC16 118
   \   00000198   0008               DC8 0, 8
   \   0000019A   3600               DC16 54
   \   0000019C   0009               DC8 0, 9
   \   0000019E   CC00               DC16 204
   \   000001A0   1107               DC8 17, 7
   \   000001A2   0F00               DC16 15
   \   000001A4   0008               DC8 0, 8
   \   000001A6   6600               DC16 102
   \   000001A8   0008               DC8 0, 8
   \   000001AA   2600               DC16 38
   \   000001AC   0009               DC8 0, 9
   \   000001AE   AC00               DC16 172
   \   000001B0   0008               DC8 0, 8
   \   000001B2   0600               DC16 6
   \   000001B4   0008               DC8 0, 8
   \   000001B6   8600               DC16 134
   \   000001B8   0008               DC8 0, 8
   \   000001BA   4600               DC16 70
   \   000001BC   0009               DC8 0, 9
   \   000001BE   EC00               DC16 236
   \   000001C0   1007               DC8 16, 7
   \   000001C2   0900               DC16 9
   \   000001C4   0008               DC8 0, 8
   \   000001C6   5E00               DC16 94
   \   000001C8   0008               DC8 0, 8
   \   000001CA   1E00               DC16 30
   \   000001CC   0009               DC8 0, 9
   \   000001CE   9C00               DC16 156
   \   000001D0   1407               DC8 20, 7
   \   000001D2   6300               DC16 99
   \   000001D4   0008               DC8 0, 8
   \   000001D6   7E00               DC16 126
   \   000001D8   0008               DC8 0, 8
   \   000001DA   3E00               DC16 62
   \   000001DC   0009               DC8 0, 9
   \   000001DE   DC00               DC16 220
   \   000001E0   1207               DC8 18, 7
   \   000001E2   1B00               DC16 27
   \   000001E4   0008               DC8 0, 8
   \   000001E6   6E00               DC16 110
   \   000001E8   0008               DC8 0, 8
   \   000001EA   2E00               DC16 46
   \   000001EC   0009               DC8 0, 9
   \   000001EE   BC00               DC16 188
   \   000001F0   0008               DC8 0, 8
   \   000001F2   0E00               DC16 14
   \   000001F4   0008               DC8 0, 8
   \   000001F6   8E00               DC16 142
   \   000001F8   0008               DC8 0, 8
   \   000001FA   4E00               DC16 78
   \   000001FC   0009               DC8 0, 9
   \   000001FE   FC00               DC16 252
   \   00000200   6007               DC8 96, 7
   \   00000202   0000               DC16 0
   \   00000204   0008               DC8 0, 8
   \   00000206   5100               DC16 81
   \   00000208   0008               DC8 0, 8
   \   0000020A   1100               DC16 17
   \   0000020C   1508               DC8 21, 8
   \   0000020E   8300               DC16 131
   \   00000210   1207               DC8 18, 7
   \   00000212   1F00               DC16 31
   \   00000214   0008               DC8 0, 8
   \   00000216   7100               DC16 113
   \   00000218   0008               DC8 0, 8
   \   0000021A   3100               DC16 49
   \   0000021C   0009               DC8 0, 9
   \   0000021E   C200               DC16 194
   \   00000220   1007               DC8 16, 7
   \   00000222   0A00               DC16 10
   \   00000224   0008               DC8 0, 8
   \   00000226   6100               DC16 97
   \   00000228   0008               DC8 0, 8
   \   0000022A   2100               DC16 33
   \   0000022C   0009               DC8 0, 9
   \   0000022E   A200               DC16 162
   \   00000230   0008               DC8 0, 8
   \   00000232   0100               DC16 1
   \   00000234   0008               DC8 0, 8
   \   00000236   8100               DC16 129
   \   00000238   0008               DC8 0, 8
   \   0000023A   4100               DC16 65
   \   0000023C   0009               DC8 0, 9
   \   0000023E   E200               DC16 226
   \   00000240   1007               DC8 16, 7
   \   00000242   0600               DC16 6
   \   00000244   0008               DC8 0, 8
   \   00000246   5900               DC16 89
   \   00000248   0008               DC8 0, 8
   \   0000024A   1900               DC16 25
   \   0000024C   0009               DC8 0, 9
   \   0000024E   9200               DC16 146
   \   00000250   1307               DC8 19, 7
   \   00000252   3B00               DC16 59
   \   00000254   0008               DC8 0, 8
   \   00000256   7900               DC16 121
   \   00000258   0008               DC8 0, 8
   \   0000025A   3900               DC16 57
   \   0000025C   0009               DC8 0, 9
   \   0000025E   D200               DC16 210
   \   00000260   1107               DC8 17, 7
   \   00000262   1100               DC16 17
   \   00000264   0008               DC8 0, 8
   \   00000266   6900               DC16 105
   \   00000268   0008               DC8 0, 8
   \   0000026A   2900               DC16 41
   \   0000026C   0009               DC8 0, 9
   \   0000026E   B200               DC16 178
   \   00000270   0008               DC8 0, 8
   \   00000272   0900               DC16 9
   \   00000274   0008               DC8 0, 8
   \   00000276   8900               DC16 137
   \   00000278   0008               DC8 0, 8
   \   0000027A   4900               DC16 73
   \   0000027C   0009               DC8 0, 9
   \   0000027E   F200               DC16 242
   \   00000280   1007               DC8 16, 7
   \   00000282   0400               DC16 4
   \   00000284   0008               DC8 0, 8
   \   00000286   5500               DC16 85
   \   00000288   0008               DC8 0, 8
   \   0000028A   1500               DC16 21
   \   0000028C   1008               DC8 16, 8
   \   0000028E   0201               DC16 258
   \   00000290   1307               DC8 19, 7
   \   00000292   2B00               DC16 43
   \   00000294   0008               DC8 0, 8
   \   00000296   7500               DC16 117
   \   00000298   0008               DC8 0, 8
   \   0000029A   3500               DC16 53
   \   0000029C   0009               DC8 0, 9
   \   0000029E   CA00               DC16 202
   \   000002A0   1107               DC8 17, 7
   \   000002A2   0D00               DC16 13
   \   000002A4   0008               DC8 0, 8
   \   000002A6   6500               DC16 101
   \   000002A8   0008               DC8 0, 8
   \   000002AA   2500               DC16 37
   \   000002AC   0009               DC8 0, 9
   \   000002AE   AA00               DC16 170
   \   000002B0   0008               DC8 0, 8
   \   000002B2   0500               DC16 5
   \   000002B4   0008               DC8 0, 8
   \   000002B6   8500               DC16 133
   \   000002B8   0008               DC8 0, 8
   \   000002BA   4500               DC16 69
   \   000002BC   0009               DC8 0, 9
   \   000002BE   EA00               DC16 234
   \   000002C0   1007               DC8 16, 7
   \   000002C2   0800               DC16 8
   \   000002C4   0008               DC8 0, 8
   \   000002C6   5D00               DC16 93
   \   000002C8   0008               DC8 0, 8
   \   000002CA   1D00               DC16 29
   \   000002CC   0009               DC8 0, 9
   \   000002CE   9A00               DC16 154
   \   000002D0   1407               DC8 20, 7
   \   000002D2   5300               DC16 83
   \   000002D4   0008               DC8 0, 8
   \   000002D6   7D00               DC16 125
   \   000002D8   0008               DC8 0, 8
   \   000002DA   3D00               DC16 61
   \   000002DC   0009               DC8 0, 9
   \   000002DE   DA00               DC16 218
   \   000002E0   1207               DC8 18, 7
   \   000002E2   1700               DC16 23
   \   000002E4   0008               DC8 0, 8
   \   000002E6   6D00               DC16 109
   \   000002E8   0008               DC8 0, 8
   \   000002EA   2D00               DC16 45
   \   000002EC   0009               DC8 0, 9
   \   000002EE   BA00               DC16 186
   \   000002F0   0008               DC8 0, 8
   \   000002F2   0D00               DC16 13
   \   000002F4   0008               DC8 0, 8
   \   000002F6   8D00               DC16 141
   \   000002F8   0008               DC8 0, 8
   \   000002FA   4D00               DC16 77
   \   000002FC   0009               DC8 0, 9
   \   000002FE   FA00               DC16 250
   \   00000300   1007               DC8 16, 7
   \   00000302   0300               DC16 3
   \   00000304   0008               DC8 0, 8
   \   00000306   5300               DC16 83
   \   00000308   0008               DC8 0, 8
   \   0000030A   1300               DC16 19
   \   0000030C   1508               DC8 21, 8
   \   0000030E   C300               DC16 195
   \   00000310   1307               DC8 19, 7
   \   00000312   2300               DC16 35
   \   00000314   0008               DC8 0, 8
   \   00000316   7300               DC16 115
   \   00000318   0008               DC8 0, 8
   \   0000031A   3300               DC16 51
   \   0000031C   0009               DC8 0, 9
   \   0000031E   C600               DC16 198
   \   00000320   1107               DC8 17, 7
   \   00000322   0B00               DC16 11
   \   00000324   0008               DC8 0, 8
   \   00000326   6300               DC16 99
   \   00000328   0008               DC8 0, 8
   \   0000032A   2300               DC16 35
   \   0000032C   0009               DC8 0, 9
   \   0000032E   A600               DC16 166
   \   00000330   0008               DC8 0, 8
   \   00000332   0300               DC16 3
   \   00000334   0008               DC8 0, 8
   \   00000336   8300               DC16 131
   \   00000338   0008               DC8 0, 8
   \   0000033A   4300               DC16 67
   \   0000033C   0009               DC8 0, 9
   \   0000033E   E600               DC16 230
   \   00000340   1007               DC8 16, 7
   \   00000342   0700               DC16 7
   \   00000344   0008               DC8 0, 8
   \   00000346   5B00               DC16 91
   \   00000348   0008               DC8 0, 8
   \   0000034A   1B00               DC16 27
   \   0000034C   0009               DC8 0, 9
   \   0000034E   9600               DC16 150
   \   00000350   1407               DC8 20, 7
   \   00000352   4300               DC16 67
   \   00000354   0008               DC8 0, 8
   \   00000356   7B00               DC16 123
   \   00000358   0008               DC8 0, 8
   \   0000035A   3B00               DC16 59
   \   0000035C   0009               DC8 0, 9
   \   0000035E   D600               DC16 214
   \   00000360   1207               DC8 18, 7
   \   00000362   1300               DC16 19
   \   00000364   0008               DC8 0, 8
   \   00000366   6B00               DC16 107
   \   00000368   0008               DC8 0, 8
   \   0000036A   2B00               DC16 43
   \   0000036C   0009               DC8 0, 9
   \   0000036E   B600               DC16 182
   \   00000370   0008               DC8 0, 8
   \   00000372   0B00               DC16 11
   \   00000374   0008               DC8 0, 8
   \   00000376   8B00               DC16 139
   \   00000378   0008               DC8 0, 8
   \   0000037A   4B00               DC16 75
   \   0000037C   0009               DC8 0, 9
   \   0000037E   F600               DC16 246
   \   00000380   1007               DC8 16, 7
   \   00000382   0500               DC16 5
   \   00000384   0008               DC8 0, 8
   \   00000386   5700               DC16 87
   \   00000388   0008               DC8 0, 8
   \   0000038A   1700               DC16 23
   \   0000038C   4008               DC8 64, 8
   \   0000038E   0000               DC16 0
   \   00000390   1307               DC8 19, 7
   \   00000392   3300               DC16 51
   \   00000394   0008               DC8 0, 8
   \   00000396   7700               DC16 119
   \   00000398   0008               DC8 0, 8
   \   0000039A   3700               DC16 55
   \   0000039C   0009               DC8 0, 9
   \   0000039E   CE00               DC16 206
   \   000003A0   1107               DC8 17, 7
   \   000003A2   0F00               DC16 15
   \   000003A4   0008               DC8 0, 8
   \   000003A6   6700               DC16 103
   \   000003A8   0008               DC8 0, 8
   \   000003AA   2700               DC16 39
   \   000003AC   0009               DC8 0, 9
   \   000003AE   AE00               DC16 174
   \   000003B0   0008               DC8 0, 8
   \   000003B2   0700               DC16 7
   \   000003B4   0008               DC8 0, 8
   \   000003B6   8700               DC16 135
   \   000003B8   0008               DC8 0, 8
   \   000003BA   4700               DC16 71
   \   000003BC   0009               DC8 0, 9
   \   000003BE   EE00               DC16 238
   \   000003C0   1007               DC8 16, 7
   \   000003C2   0900               DC16 9
   \   000003C4   0008               DC8 0, 8
   \   000003C6   5F00               DC16 95
   \   000003C8   0008               DC8 0, 8
   \   000003CA   1F00               DC16 31
   \   000003CC   0009               DC8 0, 9
   \   000003CE   9E00               DC16 158
   \   000003D0   1407               DC8 20, 7
   \   000003D2   6300               DC16 99
   \   000003D4   0008               DC8 0, 8
   \   000003D6   7F00               DC16 127
   \   000003D8   0008               DC8 0, 8
   \   000003DA   3F00               DC16 63
   \   000003DC   0009               DC8 0, 9
   \   000003DE   DE00               DC16 222
   \   000003E0   1207               DC8 18, 7
   \   000003E2   1B00               DC16 27
   \   000003E4   0008               DC8 0, 8
   \   000003E6   6F00               DC16 111
   \   000003E8   0008               DC8 0, 8
   \   000003EA   2F00               DC16 47
   \   000003EC   0009               DC8 0, 9
   \   000003EE   BE00               DC16 190
   \   000003F0   0008               DC8 0, 8
   \   000003F2   0F00               DC16 15
   \   000003F4   0008               DC8 0, 8
   \   000003F6   8F00               DC16 143
   \   000003F8   0008               DC8 0, 8
   \   000003FA   4F00               DC16 79
   \   000003FC   0009               DC8 0, 9
   \   000003FE   FE00               DC16 254
   \   00000400   6007               DC8 96, 7
   \   00000402   0000               DC16 0
   \   00000404   0008               DC8 0, 8
   \   00000406   5000               DC16 80
   \   00000408   0008               DC8 0, 8
   \   0000040A   1000               DC16 16
   \   0000040C   1408               DC8 20, 8
   \   0000040E   7300               DC16 115
   \   00000410   1207               DC8 18, 7
   \   00000412   1F00               DC16 31
   \   00000414   0008               DC8 0, 8
   \   00000416   7000               DC16 112
   \   00000418   0008               DC8 0, 8
   \   0000041A   3000               DC16 48
   \   0000041C   0009               DC8 0, 9
   \   0000041E   C100               DC16 193
   \   00000420   1007               DC8 16, 7
   \   00000422   0A00               DC16 10
   \   00000424   0008               DC8 0, 8
   \   00000426   6000               DC16 96
   \   00000428   0008               DC8 0, 8
   \   0000042A   2000               DC16 32
   \   0000042C   0009               DC8 0, 9
   \   0000042E   A100               DC16 161
   \   00000430   0008               DC8 0, 8
   \   00000432   0000               DC16 0
   \   00000434   0008               DC8 0, 8
   \   00000436   8000               DC16 128
   \   00000438   0008               DC8 0, 8
   \   0000043A   4000               DC16 64
   \   0000043C   0009               DC8 0, 9
   \   0000043E   E100               DC16 225
   \   00000440   1007               DC8 16, 7
   \   00000442   0600               DC16 6
   \   00000444   0008               DC8 0, 8
   \   00000446   5800               DC16 88
   \   00000448   0008               DC8 0, 8
   \   0000044A   1800               DC16 24
   \   0000044C   0009               DC8 0, 9
   \   0000044E   9100               DC16 145
   \   00000450   1307               DC8 19, 7
   \   00000452   3B00               DC16 59
   \   00000454   0008               DC8 0, 8
   \   00000456   7800               DC16 120
   \   00000458   0008               DC8 0, 8
   \   0000045A   3800               DC16 56
   \   0000045C   0009               DC8 0, 9
   \   0000045E   D100               DC16 209
   \   00000460   1107               DC8 17, 7
   \   00000462   1100               DC16 17
   \   00000464   0008               DC8 0, 8
   \   00000466   6800               DC16 104
   \   00000468   0008               DC8 0, 8
   \   0000046A   2800               DC16 40
   \   0000046C   0009               DC8 0, 9
   \   0000046E   B100               DC16 177
   \   00000470   0008               DC8 0, 8
   \   00000472   0800               DC16 8
   \   00000474   0008               DC8 0, 8
   \   00000476   8800               DC16 136
   \   00000478   0008               DC8 0, 8
   \   0000047A   4800               DC16 72
   \   0000047C   0009               DC8 0, 9
   \   0000047E   F100               DC16 241
   \   00000480   1007               DC8 16, 7
   \   00000482   0400               DC16 4
   \   00000484   0008               DC8 0, 8
   \   00000486   5400               DC16 84
   \   00000488   0008               DC8 0, 8
   \   0000048A   1400               DC16 20
   \   0000048C   1508               DC8 21, 8
   \   0000048E   E300               DC16 227
   \   00000490   1307               DC8 19, 7
   \   00000492   2B00               DC16 43
   \   00000494   0008               DC8 0, 8
   \   00000496   7400               DC16 116
   \   00000498   0008               DC8 0, 8
   \   0000049A   3400               DC16 52
   \   0000049C   0009               DC8 0, 9
   \   0000049E   C900               DC16 201
   \   000004A0   1107               DC8 17, 7
   \   000004A2   0D00               DC16 13
   \   000004A4   0008               DC8 0, 8
   \   000004A6   6400               DC16 100
   \   000004A8   0008               DC8 0, 8
   \   000004AA   2400               DC16 36
   \   000004AC   0009               DC8 0, 9
   \   000004AE   A900               DC16 169
   \   000004B0   0008               DC8 0, 8
   \   000004B2   0400               DC16 4
   \   000004B4   0008               DC8 0, 8
   \   000004B6   8400               DC16 132
   \   000004B8   0008               DC8 0, 8
   \   000004BA   4400               DC16 68
   \   000004BC   0009               DC8 0, 9
   \   000004BE   E900               DC16 233
   \   000004C0   1007               DC8 16, 7
   \   000004C2   0800               DC16 8
   \   000004C4   0008               DC8 0, 8
   \   000004C6   5C00               DC16 92
   \   000004C8   0008               DC8 0, 8
   \   000004CA   1C00               DC16 28
   \   000004CC   0009               DC8 0, 9
   \   000004CE   9900               DC16 153
   \   000004D0   1407               DC8 20, 7
   \   000004D2   5300               DC16 83
   \   000004D4   0008               DC8 0, 8
   \   000004D6   7C00               DC16 124
   \   000004D8   0008               DC8 0, 8
   \   000004DA   3C00               DC16 60
   \   000004DC   0009               DC8 0, 9
   \   000004DE   D900               DC16 217
   \   000004E0   1207               DC8 18, 7
   \   000004E2   1700               DC16 23
   \   000004E4   0008               DC8 0, 8
   \   000004E6   6C00               DC16 108
   \   000004E8   0008               DC8 0, 8
   \   000004EA   2C00               DC16 44
   \   000004EC   0009               DC8 0, 9
   \   000004EE   B900               DC16 185
   \   000004F0   0008               DC8 0, 8
   \   000004F2   0C00               DC16 12
   \   000004F4   0008               DC8 0, 8
   \   000004F6   8C00               DC16 140
   \   000004F8   0008               DC8 0, 8
   \   000004FA   4C00               DC16 76
   \   000004FC   0009               DC8 0, 9
   \   000004FE   F900               DC16 249
   \   00000500   1007               DC8 16, 7
   \   00000502   0300               DC16 3
   \   00000504   0008               DC8 0, 8
   \   00000506   5200               DC16 82
   \   00000508   0008               DC8 0, 8
   \   0000050A   1200               DC16 18
   \   0000050C   1508               DC8 21, 8
   \   0000050E   A300               DC16 163
   \   00000510   1307               DC8 19, 7
   \   00000512   2300               DC16 35
   \   00000514   0008               DC8 0, 8
   \   00000516   7200               DC16 114
   \   00000518   0008               DC8 0, 8
   \   0000051A   3200               DC16 50
   \   0000051C   0009               DC8 0, 9
   \   0000051E   C500               DC16 197
   \   00000520   1107               DC8 17, 7
   \   00000522   0B00               DC16 11
   \   00000524   0008               DC8 0, 8
   \   00000526   6200               DC16 98
   \   00000528   0008               DC8 0, 8
   \   0000052A   2200               DC16 34
   \   0000052C   0009               DC8 0, 9
   \   0000052E   A500               DC16 165
   \   00000530   0008               DC8 0, 8
   \   00000532   0200               DC16 2
   \   00000534   0008               DC8 0, 8
   \   00000536   8200               DC16 130
   \   00000538   0008               DC8 0, 8
   \   0000053A   4200               DC16 66
   \   0000053C   0009               DC8 0, 9
   \   0000053E   E500               DC16 229
   \   00000540   1007               DC8 16, 7
   \   00000542   0700               DC16 7
   \   00000544   0008               DC8 0, 8
   \   00000546   5A00               DC16 90
   \   00000548   0008               DC8 0, 8
   \   0000054A   1A00               DC16 26
   \   0000054C   0009               DC8 0, 9
   \   0000054E   9500               DC16 149
   \   00000550   1407               DC8 20, 7
   \   00000552   4300               DC16 67
   \   00000554   0008               DC8 0, 8
   \   00000556   7A00               DC16 122
   \   00000558   0008               DC8 0, 8
   \   0000055A   3A00               DC16 58
   \   0000055C   0009               DC8 0, 9
   \   0000055E   D500               DC16 213
   \   00000560   1207               DC8 18, 7
   \   00000562   1300               DC16 19
   \   00000564   0008               DC8 0, 8
   \   00000566   6A00               DC16 106
   \   00000568   0008               DC8 0, 8
   \   0000056A   2A00               DC16 42
   \   0000056C   0009               DC8 0, 9
   \   0000056E   B500               DC16 181
   \   00000570   0008               DC8 0, 8
   \   00000572   0A00               DC16 10
   \   00000574   0008               DC8 0, 8
   \   00000576   8A00               DC16 138
   \   00000578   0008               DC8 0, 8
   \   0000057A   4A00               DC16 74
   \   0000057C   0009               DC8 0, 9
   \   0000057E   F500               DC16 245
   \   00000580   1007               DC8 16, 7
   \   00000582   0500               DC16 5
   \   00000584   0008               DC8 0, 8
   \   00000586   5600               DC16 86
   \   00000588   0008               DC8 0, 8
   \   0000058A   1600               DC16 22
   \   0000058C   4008               DC8 64, 8
   \   0000058E   0000               DC16 0
   \   00000590   1307               DC8 19, 7
   \   00000592   3300               DC16 51
   \   00000594   0008               DC8 0, 8
   \   00000596   7600               DC16 118
   \   00000598   0008               DC8 0, 8
   \   0000059A   3600               DC16 54
   \   0000059C   0009               DC8 0, 9
   \   0000059E   CD00               DC16 205
   \   000005A0   1107               DC8 17, 7
   \   000005A2   0F00               DC16 15
   \   000005A4   0008               DC8 0, 8
   \   000005A6   6600               DC16 102
   \   000005A8   0008               DC8 0, 8
   \   000005AA   2600               DC16 38
   \   000005AC   0009               DC8 0, 9
   \   000005AE   AD00               DC16 173
   \   000005B0   0008               DC8 0, 8
   \   000005B2   0600               DC16 6
   \   000005B4   0008               DC8 0, 8
   \   000005B6   8600               DC16 134
   \   000005B8   0008               DC8 0, 8
   \   000005BA   4600               DC16 70
   \   000005BC   0009               DC8 0, 9
   \   000005BE   ED00               DC16 237
   \   000005C0   1007               DC8 16, 7
   \   000005C2   0900               DC16 9
   \   000005C4   0008               DC8 0, 8
   \   000005C6   5E00               DC16 94
   \   000005C8   0008               DC8 0, 8
   \   000005CA   1E00               DC16 30
   \   000005CC   0009               DC8 0, 9
   \   000005CE   9D00               DC16 157
   \   000005D0   1407               DC8 20, 7
   \   000005D2   6300               DC16 99
   \   000005D4   0008               DC8 0, 8
   \   000005D6   7E00               DC16 126
   \   000005D8   0008               DC8 0, 8
   \   000005DA   3E00               DC16 62
   \   000005DC   0009               DC8 0, 9
   \   000005DE   DD00               DC16 221
   \   000005E0   1207               DC8 18, 7
   \   000005E2   1B00               DC16 27
   \   000005E4   0008               DC8 0, 8
   \   000005E6   6E00               DC16 110
   \   000005E8   0008               DC8 0, 8
   \   000005EA   2E00               DC16 46
   \   000005EC   0009               DC8 0, 9
   \   000005EE   BD00               DC16 189
   \   000005F0   0008               DC8 0, 8
   \   000005F2   0E00               DC16 14
   \   000005F4   0008               DC8 0, 8
   \   000005F6   8E00               DC16 142
   \   000005F8   0008               DC8 0, 8
   \   000005FA   4E00               DC16 78
   \   000005FC   0009               DC8 0, 9
   \   000005FE   FD00               DC16 253
   \   00000600   6007               DC8 96, 7
   \   00000602   0000               DC16 0
   \   00000604   0008               DC8 0, 8
   \   00000606   5100               DC16 81
   \   00000608   0008               DC8 0, 8
   \   0000060A   1100               DC16 17
   \   0000060C   1508               DC8 21, 8
   \   0000060E   8300               DC16 131
   \   00000610   1207               DC8 18, 7
   \   00000612   1F00               DC16 31
   \   00000614   0008               DC8 0, 8
   \   00000616   7100               DC16 113
   \   00000618   0008               DC8 0, 8
   \   0000061A   3100               DC16 49
   \   0000061C   0009               DC8 0, 9
   \   0000061E   C300               DC16 195
   \   00000620   1007               DC8 16, 7
   \   00000622   0A00               DC16 10
   \   00000624   0008               DC8 0, 8
   \   00000626   6100               DC16 97
   \   00000628   0008               DC8 0, 8
   \   0000062A   2100               DC16 33
   \   0000062C   0009               DC8 0, 9
   \   0000062E   A300               DC16 163
   \   00000630   0008               DC8 0, 8
   \   00000632   0100               DC16 1
   \   00000634   0008               DC8 0, 8
   \   00000636   8100               DC16 129
   \   00000638   0008               DC8 0, 8
   \   0000063A   4100               DC16 65
   \   0000063C   0009               DC8 0, 9
   \   0000063E   E300               DC16 227
   \   00000640   1007               DC8 16, 7
   \   00000642   0600               DC16 6
   \   00000644   0008               DC8 0, 8
   \   00000646   5900               DC16 89
   \   00000648   0008               DC8 0, 8
   \   0000064A   1900               DC16 25
   \   0000064C   0009               DC8 0, 9
   \   0000064E   9300               DC16 147
   \   00000650   1307               DC8 19, 7
   \   00000652   3B00               DC16 59
   \   00000654   0008               DC8 0, 8
   \   00000656   7900               DC16 121
   \   00000658   0008               DC8 0, 8
   \   0000065A   3900               DC16 57
   \   0000065C   0009               DC8 0, 9
   \   0000065E   D300               DC16 211
   \   00000660   1107               DC8 17, 7
   \   00000662   1100               DC16 17
   \   00000664   0008               DC8 0, 8
   \   00000666   6900               DC16 105
   \   00000668   0008               DC8 0, 8
   \   0000066A   2900               DC16 41
   \   0000066C   0009               DC8 0, 9
   \   0000066E   B300               DC16 179
   \   00000670   0008               DC8 0, 8
   \   00000672   0900               DC16 9
   \   00000674   0008               DC8 0, 8
   \   00000676   8900               DC16 137
   \   00000678   0008               DC8 0, 8
   \   0000067A   4900               DC16 73
   \   0000067C   0009               DC8 0, 9
   \   0000067E   F300               DC16 243
   \   00000680   1007               DC8 16, 7
   \   00000682   0400               DC16 4
   \   00000684   0008               DC8 0, 8
   \   00000686   5500               DC16 85
   \   00000688   0008               DC8 0, 8
   \   0000068A   1500               DC16 21
   \   0000068C   1008               DC8 16, 8
   \   0000068E   0201               DC16 258
   \   00000690   1307               DC8 19, 7
   \   00000692   2B00               DC16 43
   \   00000694   0008               DC8 0, 8
   \   00000696   7500               DC16 117
   \   00000698   0008               DC8 0, 8
   \   0000069A   3500               DC16 53
   \   0000069C   0009               DC8 0, 9
   \   0000069E   CB00               DC16 203
   \   000006A0   1107               DC8 17, 7
   \   000006A2   0D00               DC16 13
   \   000006A4   0008               DC8 0, 8
   \   000006A6   6500               DC16 101
   \   000006A8   0008               DC8 0, 8
   \   000006AA   2500               DC16 37
   \   000006AC   0009               DC8 0, 9
   \   000006AE   AB00               DC16 171
   \   000006B0   0008               DC8 0, 8
   \   000006B2   0500               DC16 5
   \   000006B4   0008               DC8 0, 8
   \   000006B6   8500               DC16 133
   \   000006B8   0008               DC8 0, 8
   \   000006BA   4500               DC16 69
   \   000006BC   0009               DC8 0, 9
   \   000006BE   EB00               DC16 235
   \   000006C0   1007               DC8 16, 7
   \   000006C2   0800               DC16 8
   \   000006C4   0008               DC8 0, 8
   \   000006C6   5D00               DC16 93
   \   000006C8   0008               DC8 0, 8
   \   000006CA   1D00               DC16 29
   \   000006CC   0009               DC8 0, 9
   \   000006CE   9B00               DC16 155
   \   000006D0   1407               DC8 20, 7
   \   000006D2   5300               DC16 83
   \   000006D4   0008               DC8 0, 8
   \   000006D6   7D00               DC16 125
   \   000006D8   0008               DC8 0, 8
   \   000006DA   3D00               DC16 61
   \   000006DC   0009               DC8 0, 9
   \   000006DE   DB00               DC16 219
   \   000006E0   1207               DC8 18, 7
   \   000006E2   1700               DC16 23
   \   000006E4   0008               DC8 0, 8
   \   000006E6   6D00               DC16 109
   \   000006E8   0008               DC8 0, 8
   \   000006EA   2D00               DC16 45
   \   000006EC   0009               DC8 0, 9
   \   000006EE   BB00               DC16 187
   \   000006F0   0008               DC8 0, 8
   \   000006F2   0D00               DC16 13
   \   000006F4   0008               DC8 0, 8
   \   000006F6   8D00               DC16 141
   \   000006F8   0008               DC8 0, 8
   \   000006FA   4D00               DC16 77
   \   000006FC   0009               DC8 0, 9
   \   000006FE   FB00               DC16 251
   \   00000700   1007               DC8 16, 7
   \   00000702   0300               DC16 3
   \   00000704   0008               DC8 0, 8
   \   00000706   5300               DC16 83
   \   00000708   0008               DC8 0, 8
   \   0000070A   1300               DC16 19
   \   0000070C   1508               DC8 21, 8
   \   0000070E   C300               DC16 195
   \   00000710   1307               DC8 19, 7
   \   00000712   2300               DC16 35
   \   00000714   0008               DC8 0, 8
   \   00000716   7300               DC16 115
   \   00000718   0008               DC8 0, 8
   \   0000071A   3300               DC16 51
   \   0000071C   0009               DC8 0, 9
   \   0000071E   C700               DC16 199
   \   00000720   1107               DC8 17, 7
   \   00000722   0B00               DC16 11
   \   00000724   0008               DC8 0, 8
   \   00000726   6300               DC16 99
   \   00000728   0008               DC8 0, 8
   \   0000072A   2300               DC16 35
   \   0000072C   0009               DC8 0, 9
   \   0000072E   A700               DC16 167
   \   00000730   0008               DC8 0, 8
   \   00000732   0300               DC16 3
   \   00000734   0008               DC8 0, 8
   \   00000736   8300               DC16 131
   \   00000738   0008               DC8 0, 8
   \   0000073A   4300               DC16 67
   \   0000073C   0009               DC8 0, 9
   \   0000073E   E700               DC16 231
   \   00000740   1007               DC8 16, 7
   \   00000742   0700               DC16 7
   \   00000744   0008               DC8 0, 8
   \   00000746   5B00               DC16 91
   \   00000748   0008               DC8 0, 8
   \   0000074A   1B00               DC16 27
   \   0000074C   0009               DC8 0, 9
   \   0000074E   9700               DC16 151
   \   00000750   1407               DC8 20, 7
   \   00000752   4300               DC16 67
   \   00000754   0008               DC8 0, 8
   \   00000756   7B00               DC16 123
   \   00000758   0008               DC8 0, 8
   \   0000075A   3B00               DC16 59
   \   0000075C   0009               DC8 0, 9
   \   0000075E   D700               DC16 215
   \   00000760   1207               DC8 18, 7
   \   00000762   1300               DC16 19
   \   00000764   0008               DC8 0, 8
   \   00000766   6B00               DC16 107
   \   00000768   0008               DC8 0, 8
   \   0000076A   2B00               DC16 43
   \   0000076C   0009               DC8 0, 9
   \   0000076E   B700               DC16 183
   \   00000770   0008               DC8 0, 8
   \   00000772   0B00               DC16 11
   \   00000774   0008               DC8 0, 8
   \   00000776   8B00               DC16 139
   \   00000778   0008               DC8 0, 8
   \   0000077A   4B00               DC16 75
   \   0000077C   0009               DC8 0, 9
   \   0000077E   F700               DC16 247
   \   00000780   1007               DC8 16, 7
   \   00000782   0500               DC16 5
   \   00000784   0008               DC8 0, 8
   \   00000786   5700               DC16 87
   \   00000788   0008               DC8 0, 8
   \   0000078A   1700               DC16 23
   \   0000078C   4008               DC8 64, 8
   \   0000078E   0000               DC16 0
   \   00000790   1307               DC8 19, 7
   \   00000792   3300               DC16 51
   \   00000794   0008               DC8 0, 8
   \   00000796   7700               DC16 119
   \   00000798   0008               DC8 0, 8
   \   0000079A   3700               DC16 55
   \   0000079C   0009               DC8 0, 9
   \   0000079E   CF00               DC16 207
   \   000007A0   1107               DC8 17, 7
   \   000007A2   0F00               DC16 15
   \   000007A4   0008               DC8 0, 8
   \   000007A6   6700               DC16 103
   \   000007A8   0008               DC8 0, 8
   \   000007AA   2700               DC16 39
   \   000007AC   0009               DC8 0, 9
   \   000007AE   AF00               DC16 175
   \   000007B0   0008               DC8 0, 8
   \   000007B2   0700               DC16 7
   \   000007B4   0008               DC8 0, 8
   \   000007B6   8700               DC16 135
   \   000007B8   0008               DC8 0, 8
   \   000007BA   4700               DC16 71
   \   000007BC   0009               DC8 0, 9
   \   000007BE   EF00               DC16 239
   \   000007C0   1007               DC8 16, 7
   \   000007C2   0900               DC16 9
   \   000007C4   0008               DC8 0, 8
   \   000007C6   5F00               DC16 95
   \   000007C8   0008               DC8 0, 8
   \   000007CA   1F00               DC16 31
   \   000007CC   0009               DC8 0, 9
   \   000007CE   9F00               DC16 159
   \   000007D0   1407               DC8 20, 7
   \   000007D2   6300               DC16 99
   \   000007D4   0008               DC8 0, 8
   \   000007D6   7F00               DC16 127
   \   000007D8   0008               DC8 0, 8
   \   000007DA   3F00               DC16 63
   \   000007DC   0009               DC8 0, 9
   \   000007DE   DF00               DC16 223
   \   000007E0   1207               DC8 18, 7
   \   000007E2   1B00               DC16 27
   \   000007E4   0008               DC8 0, 8
   \   000007E6   6F00               DC16 111
   \   000007E8   0008               DC8 0, 8
   \   000007EA   2F00               DC16 47
   \   000007EC   0009               DC8 0, 9
   \   000007EE   BF00               DC16 191
   \   000007F0   0008               DC8 0, 8
   \   000007F2   0F00               DC16 15
   \   000007F4   0008               DC8 0, 8
   \   000007F6   8F00               DC16 143
   \   000007F8   0008               DC8 0, 8
   \   000007FA   4F00               DC16 79
   \   000007FC   0009               DC8 0, 9
   \   000007FE   FF00               DC16 255

   \                                 In segment DATA_C, align 4, align-sorted
   \   struct <unnamed> const __data distfix[32]
   \                     ??distfix:
   \   00000000   1005               DC8 16, 5
   \   00000002   0100               DC16 1
   \   00000004   1705               DC8 23, 5
   \   00000006   0101               DC16 257
   \   00000008   1305               DC8 19, 5
   \   0000000A   1100               DC16 17
   \   0000000C   1B05               DC8 27, 5
   \   0000000E   0110               DC16 4097
   \   00000010   1105               DC8 17, 5
   \   00000012   0500               DC16 5
   \   00000014   1905               DC8 25, 5
   \   00000016   0104               DC16 1025
   \   00000018   1505               DC8 21, 5
   \   0000001A   4100               DC16 65
   \   0000001C   1D05               DC8 29, 5
   \   0000001E   0140               DC16 16385
   \   00000020   1005               DC8 16, 5
   \   00000022   0300               DC16 3
   \   00000024   1805               DC8 24, 5
   \   00000026   0102               DC16 513
   \   00000028   1405               DC8 20, 5
   \   0000002A   2100               DC16 33
   \   0000002C   1C05               DC8 28, 5
   \   0000002E   0120               DC16 8193
   \   00000030   1205               DC8 18, 5
   \   00000032   0900               DC16 9
   \   00000034   1A05               DC8 26, 5
   \   00000036   0108               DC16 2049
   \   00000038   1605               DC8 22, 5
   \   0000003A   8100               DC16 129
   \   0000003C   4005               DC8 64, 5
   \   0000003E   0000               DC16 0
   \   00000040   1005               DC8 16, 5
   \   00000042   0200               DC16 2
   \   00000044   1705               DC8 23, 5
   \   00000046   8101               DC16 385
   \   00000048   1305               DC8 19, 5
   \   0000004A   1900               DC16 25
   \   0000004C   1B05               DC8 27, 5
   \   0000004E   0118               DC16 6145
   \   00000050   1105               DC8 17, 5
   \   00000052   0700               DC16 7
   \   00000054   1905               DC8 25, 5
   \   00000056   0106               DC16 1537
   \   00000058   1505               DC8 21, 5
   \   0000005A   6100               DC16 97
   \   0000005C   1D05               DC8 29, 5
   \   0000005E   0160               DC16 24577
   \   00000060   1005               DC8 16, 5
   \   00000062   0400               DC16 4
   \   00000064   1805               DC8 24, 5
   \   00000066   0103               DC16 769
   \   00000068   1405               DC8 20, 5
   \   0000006A   3100               DC16 49
   \   0000006C   1C05               DC8 28, 5
   \   0000006E   0130               DC16 12289
   \   00000070   1205               DC8 18, 5
   \   00000072   0D00               DC16 13
   \   00000074   1A05               DC8 26, 5
   \   00000076   010C               DC16 3073
   \   00000078   1605               DC8 22, 5
   \   0000007A   C100               DC16 193
   \   0000007C   4005               DC8 64, 5
   \   0000007E   0000               DC16 0
    250          
    251          #ifdef MAKEFIXED
    252          //#include <stdio.h>
    253          
    254          /*
    255             Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also
    256             defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes
    257             those tables to stdout, which would be piped to inffixed.h.  A small program
    258             can simply call makefixed to do this:
    259          
    260              void makefixed(void);
    261          
    262              int main(void)
    263              {
    264                  makefixed();
    265                  return 0;
    266              }
    267          
    268             Then that can be linked with zlib built with MAKEFIXED defined and run:
    269          
    270              a.out > inffixed.h
    271           */
    272          void makefixed()
    273          {
    274              unsigned low, size;
    275              struct inflate_state state;
    276          
    277              fixedtables(&state);
    278              puts("    /* inffixed.h -- table for decoding fixed codes");
    279              puts("     * Generated automatically by makefixed().");
    280              puts("     */");
    281              puts("");
    282              puts("    /* WARNING: this file should *not* be used by applications.");
    283              puts("       It is part of the implementation of this library and is");
    284              puts("       subject to change. Applications should only use zlib.h.");
    285              puts("     */");
    286              puts("");
    287              size = 1U << 9;
    288              printf("    static const code lenfix[%u] = {", size);
    289              low = 0;
    290              for (;;) {
    291                  if ((low % 7) == 0) printf("\n        ");
    292                  printf("{%u,%u,%d}", state.lencode[low].op, state.lencode[low].bits,
    293                         state.lencode[low].val);
    294                  if (++low == size) break;
    295                  putchar(',');
    296              }
    297              puts("\n    };");
    298              size = 1U << 5;
    299              printf("\n    static const code distfix[%u] = {", size);
    300              low = 0;
    301              for (;;) {
    302                  if ((low % 6) == 0) printf("\n        ");
    303                  printf("{%u,%u,%d}", state.distcode[low].op, state.distcode[low].bits,
    304                         state.distcode[low].val);
    305                  if (++low == size) break;
    306                  putchar(',');
    307              }
    308              puts("\n    };");
    309          }
    310          #endif /* MAKEFIXED */
    311          
    312          /*
    313             Update the window with the last wsize (normally 32K) bytes written before
    314             returning.  If window does not exist yet, create it.  This is only called
    315             when a window is already in use, or when output has been written during this
    316             inflate call, but the end of the deflate stream has not been reached yet.
    317             It is also called to create a window for dictionary data when a dictionary
    318             is loaded.
    319          
    320             Providing output buffers larger than 32K to inflate() should provide a speed
    321             advantage, since only the last 32K of output is copied to the sliding window
    322             upon return from inflate(), and since all distances after the first 32K of
    323             output will fall in the output data, making match copies simpler and faster.
    324             The advantage may be dependent on the size of the processor's data caches.
    325           */

   \                                 In segment CODE, align 4, keep-with-next
    326          local int updatewindow(strm, out)
    327          z_streamp strm;
    328          unsigned out;
    329          {
   \                     updatewindow:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    330              struct inflate_state FAR *state;
    331              unsigned copy, dist;
    332          
    333              state = (struct inflate_state FAR *)strm->state;
   \   00000008   1C5094E5           LDR      R5,[R4, #+28]
   \   0000000C   0170A0E1           MOV      R7,R1
    334          
    335              /* if it hasn't been done already, allocate space for the window */
    336              if (state->window == Z_NULL) {
   \   00000010   340095E5           LDR      R0,[R5, #+52]
   \   00000014   0180A0E3           MOV      R8,#+1
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0900001A           BNE      ??updatewindow_0
    337                  state->window = (unsigned char FAR *)
    338                                  ZALLOC(strm, 1U << state->wbits,
    339                                         sizeof(unsigned char));
   \   00000020   240095E5           LDR      R0,[R5, #+36]
   \   00000024   203094E5           LDR      R3,[R4, #+32]
   \   00000028   1810A0E1           LSL      R1,R8,R0
   \   0000002C   280094E5           LDR      R0,[R4, #+40]
   \   00000030   0120A0E3           MOV      R2,#+1
   \   00000034   33FF2FE1           BLX      R3
   \   00000038   340085E5           STR      R0,[R5, #+52]
    340                  if (state->window == Z_NULL) return 1;
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   0100A003           MOVEQ    R0,#+1
   \   00000044   F081BD08           POPEQ    {R4-R8,PC}
    341              }
    342          
    343              /* if window not in use yet, initialize */
    344              if (state->wsize == 0) {
   \                     ??updatewindow_0:
   \   00000048   280095E5           LDR      R0,[R5, #+40]
   \   0000004C   0060A0E3           MOV      R6,#+0
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   0400001A           BNE      ??updatewindow_1
    345                  state->wsize = 1U << state->wbits;
   \   00000058   240095E5           LDR      R0,[R5, #+36]
   \   0000005C   1800A0E1           LSL      R0,R8,R0
   \   00000060   280085E5           STR      R0,[R5, #+40]
    346                  state->write = 0;
   \   00000064   306085E5           STR      R6,[R5, #+48]
    347                  state->whave = 0;
   \   00000068   2C6085E5           STR      R6,[R5, #+44]
    348              }
    349          
    350              /* copy state->wsize or less output bytes into the circular window */
    351              copy = out - strm->avail_out;
   \                     ??updatewindow_1:
   \   0000006C   100094E5           LDR      R0,[R4, #+16]
    352              if (copy >= state->wsize) {
   \   00000070   283095E5           LDR      R3,[R5, #+40]
   \   00000074   0C1094E5           LDR      R1,[R4, #+12]
   \   00000078   007047E0           SUB      R7,R7,R0
   \   0000007C   340095E5           LDR      R0,[R5, #+52]
   \   00000080   030057E1           CMP      R7,R3
   \   00000084   0600003A           BCC      ??updatewindow_2
    353                  zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);
   \   00000088   0320A0E1           MOV      R2,R3
   \   0000008C   003063E2           RSB      R3,R3,#+0
   \   00000090   011083E0           ADD      R1,R3,R1
   \   00000094   1E0100EF           SWI      +286
    354                  state->write = 0;
   \   00000098   306085E5           STR      R6,[R5, #+48]
    355                  state->whave = state->wsize;
   \                     ??updatewindow_3:
   \   0000009C   280095E5           LDR      R0,[R5, #+40]
   \   000000A0   1E0000EA           B        ??updatewindow_4
    356              }
    357              else {
    358                  dist = state->wsize - state->write;
   \                     ??updatewindow_2:
   \   000000A4   30C095E5           LDR      R12,[R5, #+48]
   \   000000A8   0C8043E0           SUB      R8,R3,R12
    359                  if (dist > copy) dist = copy;
   \   000000AC   080057E1           CMP      R7,R8
   \   000000B0   0780A031           MOVCC    R8,R7
    360                  zmemcpy(state->window + state->write, strm->next_out - copy, dist);
   \   000000B4   0820A0E1           MOV      R2,R8
   \   000000B8   0730A0E1           MOV      R3,R7
   \   000000BC   003063E2           RSB      R3,R3,#+0
   \   000000C0   011083E0           ADD      R1,R3,R1
   \   000000C4   00008CE0           ADD      R0,R12,R0
   \   000000C8   1E0100EF           SWI      +286
    361                  copy -= dist;
   \   000000CC   087057E0           SUBS     R7,R7,R8
    362                  if (copy) {
   \   000000D0   0800000A           BEQ      ??updatewindow_5
    363                      zmemcpy(state->window, strm->next_out - copy, copy);
   \   000000D4   0C1094E5           LDR      R1,[R4, #+12]
   \   000000D8   0720A0E1           MOV      R2,R7
   \   000000DC   0700A0E1           MOV      R0,R7
   \   000000E0   000060E2           RSB      R0,R0,#+0
   \   000000E4   011080E0           ADD      R1,R0,R1
   \   000000E8   340095E5           LDR      R0,[R5, #+52]
   \   000000EC   1E0100EF           SWI      +286
    364                      state->write = copy;
   \   000000F0   307085E5           STR      R7,[R5, #+48]
    365                      state->whave = state->wsize;
   \   000000F4   E8FFFFEA           B        ??updatewindow_3
    366                  }
    367                  else {
    368                      state->write += dist;
   \                     ??updatewindow_5:
   \   000000F8   300095E5           LDR      R0,[R5, #+48]
   \   000000FC   000088E0           ADD      R0,R8,R0
   \   00000100   300085E5           STR      R0,[R5, #+48]
    369                      if (state->write == state->wsize) state->write = 0;
   \   00000104   281095E5           LDR      R1,[R5, #+40]
   \   00000108   010050E1           CMP      R0,R1
   \   0000010C   30608505           STREQ    R6,[R5, #+48]
    370                      if (state->whave < state->wsize) state->whave += dist;
   \   00000110   2C0095E5           LDR      R0,[R5, #+44]
   \   00000114   010050E1           CMP      R0,R1
   \   00000118   0100002A           BCS      ??updatewindow_6
   \   0000011C   000088E0           ADD      R0,R8,R0
   \                     ??updatewindow_4:
   \   00000120   2C0085E5           STR      R0,[R5, #+44]
    371                  }
    372              }
    373              return 0;
   \                     ??updatewindow_6:
   \   00000124   0000A0E3           MOV      R0,#+0
   \   00000128   F081BDE8           POP      {R4-R8,PC}       ;; return
    374          }
    375          
    376          /* Macros for inflate(): */
    377          
    378          /* check function to use adler32() for zlib or crc32() for gzip */
    379          #ifdef GUNZIP
    380          #  define UPDATE(check, buf, len) \
    381              (state->flags ? crc32(check, buf, len) : adler32(check, buf, len))
    382          #else
    383          #  define UPDATE(check, buf, len) adler32(check, buf, len)
    384          #endif
    385          
    386          /* check macros for header crc */
    387          #ifdef GUNZIP
    388          #  define CRC2(check, word) \
    389              do { \
    390                  hbuf[0] = (unsigned char)(word); \
    391                  hbuf[1] = (unsigned char)((word) >> 8); \
    392                  check = crc32(check, hbuf, 2); \
    393              } while (0)
    394          
    395          #  define CRC4(check, word) \
    396              do { \
    397                  hbuf[0] = (unsigned char)(word); \
    398                  hbuf[1] = (unsigned char)((word) >> 8); \
    399                  hbuf[2] = (unsigned char)((word) >> 16); \
    400                  hbuf[3] = (unsigned char)((word) >> 24); \
    401                  check = crc32(check, hbuf, 4); \
    402              } while (0)
    403          #endif
    404          
    405          /* Load registers with state in inflate() for speed */
    406          #define LOAD() \
    407              do { \
    408                  put = strm->next_out; \
    409                  left = strm->avail_out; \
    410                  next = strm->next_in; \
    411                  have = strm->avail_in; \
    412                  hold = state->hold; \
    413                  bits = state->bits; \
    414              } while (0)
    415          
    416          /* Restore state from registers in inflate() */
    417          #define RESTORE() \
    418              do { \
    419                  strm->next_out = put; \
    420                  strm->avail_out = left; \
    421                  strm->next_in = next; \
    422                  strm->avail_in = have; \
    423                  state->hold = hold; \
    424                  state->bits = bits; \
    425              } while (0)
    426          
    427          /* Clear the input bit accumulator */
    428          #define INITBITS() \
    429              do { \
    430                  hold = 0; \
    431                  bits = 0; \
    432              } while (0)
    433          
    434          /* Get a byte of input into the bit accumulator, or return from inflate()
    435             if there is no input available. */
    436          #define PULLBYTE() \
    437              do { \
    438                  if (have == 0) goto inf_leave; \
    439                  have--; \
    440                  hold += (unsigned long)(*next++) << bits; \
    441                  bits += 8; \
    442              } while (0)
    443          
    444          /* Assure that there are at least n bits in the bit accumulator.  If there is
    445             not enough available input to do that, then return from inflate(). */
    446          #define NEEDBITS(n) \
    447              do { \
    448                  while (bits < (unsigned)(n)) \
    449                      PULLBYTE(); \
    450              } while (0)
    451          
    452          /* Return the low n bits of the bit accumulator (n < 16) */
    453          #define BITS(n) \
    454              ((unsigned)hold & ((1U << (n)) - 1))
    455          
    456          /* Remove n bits from the bit accumulator */
    457          #define DROPBITS(n) \
    458              do { \
    459                  hold >>= (n); \
    460                  bits -= (unsigned)(n); \
    461              } while (0)
    462          
    463          /* Remove zero to seven bits as needed to go to a byte boundary */
    464          #define BYTEBITS() \
    465              do { \
    466                  hold >>= bits & 7; \
    467                  bits -= bits & 7; \
    468              } while (0)
    469          
    470          /* Reverse the bytes in a 32-bit value */
    471          #define REVERSE(q) \
    472              ((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \
    473               (((q) & 0xff00) << 8) + (((q) & 0xff) << 24))
    474          
    475          /*
    476             inflate() uses a state machine to process as much input data and generate as
    477             much output data as possible before returning.  The state machine is
    478             structured roughly as follows:
    479          
    480              for (;;) switch (state) {
    481              ...
    482              case STATEn:
    483                  if (not enough input data or output space to make progress)
    484                      return;
    485                  ... make progress ...
    486                  state = STATEm;
    487                  break;
    488              ...
    489              }
    490          
    491             so when inflate() is called again, the same case is attempted again, and
    492             if the appropriate resources are provided, the machine proceeds to the
    493             next state.  The NEEDBITS() macro is usually the way the state evaluates
    494             whether it can proceed or should return.  NEEDBITS() does the return if
    495             the requested bits are not available.  The typical use of the BITS macros
    496             is:
    497          
    498                  NEEDBITS(n);
    499                  ... do something with BITS(n) ...
    500                  DROPBITS(n);
    501          
    502             where NEEDBITS(n) either returns from inflate() if there isn't enough
    503             input left to load n bits into the accumulator, or it continues.  BITS(n)
    504             gives the low n bits in the accumulator.  When done, DROPBITS(n) drops
    505             the low n bits off the accumulator.  INITBITS() clears the accumulator
    506             and sets the number of available bits to zero.  BYTEBITS() discards just
    507             enough bits to put the accumulator on a byte boundary.  After BYTEBITS()
    508             and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.
    509          
    510             NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return
    511             if there is no input available.  The decoding of variable length codes uses
    512             PULLBYTE() directly in order to pull just enough bytes to decode the next
    513             code, and no more.
    514          
    515             Some states loop until they get enough input, making sure that enough
    516             state information is maintained to continue the loop where it left off
    517             if NEEDBITS() returns in the loop.  For example, want, need, and keep
    518             would all have to actually be part of the saved state in case NEEDBITS()
    519             returns:
    520          
    521              case STATEw:
    522                  while (want < need) {
    523                      NEEDBITS(n);
    524                      keep[want++] = BITS(n);
    525                      DROPBITS(n);
    526                  }
    527                  state = STATEx;
    528              case STATEx:
    529          
    530             As shown above, if the next state is also the next case, then the break
    531             is omitted.
    532          
    533             A state may also return if there is not enough output space available to
    534             complete that state.  Those states are copying stored data, writing a
    535             literal byte, and copying a matching string.
    536          
    537             When returning, a "goto inf_leave" is used to update the total counters,
    538             update the check value, and determine whether any progress has been made
    539             during that inflate() call in order to return the proper return code.
    540             Progress is defined as a change in either strm->avail_in or strm->avail_out.
    541             When there is a window, goto inf_leave will update the window with the last
    542             output written.  If a goto inf_leave occurs in the middle of decompression
    543             and there is no window currently, goto inf_leave will create one and copy
    544             output to the window for the next call of inflate().
    545          
    546             In this implementation, the flush parameter of inflate() only affects the
    547             return code (per zlib.h).  inflate() always writes as much as possible to
    548             strm->next_out, given the space available and the provided input--the effect
    549             documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers
    550             the allocation of and copying into a sliding window until necessary, which
    551             provides the effect documented in zlib.h for Z_FINISH when the entire input
    552             stream available.  So the only thing the flush parameter actually does is:
    553             when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
    554             will return Z_BUF_ERROR if it has not reached the end of the stream.
    555           */
    556          

   \                                 In segment CODE, align 4, keep-with-next
    557          int ZEXPORT inflate(strm, flush)
    558          z_streamp strm;
    559          int flush;
    560          {
   \                     inflate:
   \   00000000   F24F2DE9           PUSH     {R1,R4-R11,LR}
   \   00000004   20D04DE2           SUB      SP,SP,#+32
   \   00000008   0040B0E1           MOVS     R4,R0
    561              struct inflate_state FAR *state;
    562              unsigned char FAR *next;    /* next input */
    563              unsigned char FAR *put;     /* next output */
    564              unsigned have, left;        /* available input and output */
    565              unsigned long hold;         /* bit buffer */
    566              unsigned bits;              /* bits in bit buffer */
    567              unsigned in, out;           /* save starting available input and output */
    568              unsigned copy;              /* number of stored or match bytes to copy */
    569              unsigned char FAR *from;    /* where to copy match bytes from */
    570              code this;                  /* current decoding table entry */
    571              code last;                  /* parent table entry */
    572              unsigned len;               /* length to copy for repeats, bits to drop */
    573              int ret;                    /* return code */
    574          #ifdef GUNZIP
    575              unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
    576          #endif
    577              static const unsigned short order[19] = /* permutation of code lengths */
    578                  {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
    579          
    580              if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
    581                  (strm->next_in == Z_NULL && strm->avail_in != 0))
   \   0000000C   1C509415           LDRNE    R5,[R4, #+28]
   \   00000010   00005513           CMPNE    R5,#+0
   \   00000014   0C009415           LDRNE    R0,[R4, #+12]
   \   00000018   00005013           CMPNE    R0,#+0
   \   0000001C   0500000A           BEQ      ??inflate_1
   \   00000020   000094E5           LDR      R0,[R4, #+0]
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   0400001A           BNE      ??inflate_2
   \   0000002C   040094E5           LDR      R0,[R4, #+4]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0100000A           BEQ      ??inflate_2
    582                  return Z_STREAM_ERROR;
   \                     ??inflate_1:
   \   00000038   0100E0E3           MVN      R0,#+1
   \   0000003C   F50400EA           B        ??inflate_3
    583          
    584              state = (struct inflate_state FAR *)strm->state;
   \                     ??inflate_2:
   \   00000040   D000D5E1           LDRSB    R0,[R5, #+0]
   \   00000044   0B0050E3           CMP      R0,#+11
    585              if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
   \   00000048   0C00A003           MOVEQ    R0,#+12
   \   0000004C   0000C505           STRBEQ   R0,[R5, #+0]
    586              LOAD();
   \   00000050   0C1094E5           LDR      R1,[R4, #+12]
   \   00000054   0C108DE5           STR      R1,[SP, #+12]
   \   00000058   101094E5           LDR      R1,[R4, #+16]
   \   0000005C   00108DE5           STR      R1,[SP, #+0]
   \   00000060   047094E5           LDR      R7,[R4, #+4]
   \   00000064   006094E5           LDR      R6,[R4, #+0]
   \   00000068   388095E5           LDR      R8,[R5, #+56]
   \   0000006C   3C9095E5           LDR      R9,[R5, #+60]
    587              in = have;
   \   00000070   14708DE5           STR      R7,[SP, #+20]
    588              out = left;
   \   00000074   08108DE5           STR      R1,[SP, #+8]
    589              ret = Z_OK;
   \   00000078   0010A0E3           MOV      R1,#+0
   \   0000007C   10108DE5           STR      R1,[SP, #+16]
   \   00000080   110000EA           B        ??inflate_4
    590              for (;;)
    591                  switch (state->mode) {
    592                  case HEAD:
    593                      if (state->wrap == 0) {
    594                          state->mode = TYPEDO;
    595                          break;
    596                      }
    597                      NEEDBITS(16);
    598          #ifdef GUNZIP
    599                      if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
    600                          state->check = crc32(0L, Z_NULL, 0);
   \                     ??inflate_5:
   \   00000084   0020A0E3           MOV      R2,#+0
   \   00000088   0010A0E3           MOV      R1,#+0
   \   0000008C   0100A0E1           MOV      R0,R1
   \   00000090   ........           _BLF     crc32,??crc32??rA
   \   00000094   180085E5           STR      R0,[R5, #+24]
    601                          CRC2(state->check, hold);
   \   00000098   1F10A0E3           MOV      R1,#+31
   \   0000009C   0410CDE5           STRB     R1,[SP, #+4]
   \   000000A0   8B10A0E3           MOV      R1,#+139
   \   000000A4   0510CDE5           STRB     R1,[SP, #+5]
   \   000000A8   180095E5           LDR      R0,[R5, #+24]
   \   000000AC   0220A0E3           MOV      R2,#+2
   \   000000B0   04108DE2           ADD      R1,SP,#+4
   \   000000B4   ........           _BLF     crc32,??crc32??rA
   \   000000B8   180085E5           STR      R0,[R5, #+24]
    602                          INITBITS();
   \   000000BC   0080A0E3           MOV      R8,#+0
   \   000000C0   0890A0E1           MOV      R9,R8
    603                          state->mode = FLAGS;
   \   000000C4   0100A0E3           MOV      R0,#+1
   \                     ??inflate_6:
   \   000000C8   0000C5E5           STRB     R0,[R5, #+0]
    604                          break;
    605                      }
   \                     ??inflate_4:
   \   000000CC   08109DE5           LDR      R1,[SP, #+8]
   \   000000D0   00209DE5           LDR      R2,[SP, #+0]
   \   000000D4   021041E0           SUB      R1,R1,R2
   \   000000D8   1C108DE5           STR      R1,[SP, #+28]
   \   000000DC   D000D5E1           LDRSB    R0,[R5, #+0]
   \   000000E0   1C0050E3           CMP      R0,#+28
   \   000000E4   D3FFFF8A           BHI      ??inflate_1
   \   000000E8   021F8FE2           ADR      R1,??inflate_0
   \   000000EC   8000A0E1           MOV      R0,R0, LSL #+1
   \   000000F0   F01091E1           LDRSH    R1,[R1, R0]
   \   000000F4   01F18FE0           ADD      PC,PC,R1, LSL #+2
   \                     ??inflate_0:
   \   000000F8   0E0061008400       DC16     +14,+97,+132,+162
   \              A200        
   \   00000100   BA00C3001101       DC16     +186,+195,+273,+347
   \              5B01        
   \   00000108   8901B501C301       DC16     +393,+437,+451,+472
   \              D801        
   \   00000110   DB0106022002       DC16     +475,+518,+544,+576
   \              4002        
   \   00000118   7102A1024303       DC16     +625,+673,+835,+943
   \              AF03        
   \   00000120   CF0318043B04       DC16     +975,+1048,+1083,+1127
   \              6704        
   \   00000128   7204A904C104       DC16     +1138,+1193,+1217,+1220
   \              C404        
   \   00000130   C6040000           DC16     +1222,+0
   \                     ??inflate_7:
   \   00000134   080095E5           LDR      R0,[R5, #+8]
   \   00000138   000050E3           CMP      R0,#+0
   \   0000013C   0700001A           BNE      ??inflate_8
   \   00000140   0C00A0E3           MOV      R0,#+12
   \   00000144   DFFFFFEA           B        ??inflate_6
   \                     ??inflate_9:
   \   00000148   000057E3           CMP      R7,#+0
   \   0000014C   2201000A           BEQ      ??inflate_10
   \   00000150   ........           LDRB     R0,[R6], #+1
   \   00000154   017047E2           SUB      R7,R7,#+1
   \   00000158   108988E0           ADD      R8,R8,R0, LSL R9
   \   0000015C   089089E2           ADD      R9,R9,#+8
   \                     ??inflate_8:
   \   00000160   100059E3           CMP      R9,#+16
   \   00000164   F7FFFF3A           BCC      ??inflate_9
   \   00000168   080095E5           LDR      R0,[R5, #+8]
   \   0000016C   020010E3           TST      R0,#0x2
   \   00000170   0300000A           BEQ      ??inflate_11
   \   00000174   1F00A0E3           MOV      R0,#+31
   \   00000178   8B0C80E3           ORR      R0,R0,#0x8B00
   \   0000017C   000058E1           CMP      R8,R0
   \   00000180   BFFFFF0A           BEQ      ??inflate_5
    606                      state->flags = 0;           /* expect zlib header */
   \                     ??inflate_11:
   \   00000184   0000A0E3           MOV      R0,#+0
   \   00000188   100085E5           STR      R0,[R5, #+16]
    607                      if (state->head != Z_NULL)
   \   0000018C   200095E5           LDR      R0,[R5, #+32]
   \   00000190   000050E3           CMP      R0,#+0
    608                          state->head->done = -1;
   \   00000194   0010E013           MVNNE    R1,#+0
   \   00000198   30108015           STRNE    R1,[R0, #+48]
    609                      if (!(state->wrap & 1) ||   /* check if zlib header allowed */
    610          #else
    611                      if (
    612          #endif
    613                          ((BITS(8) << 8) + (hold >> 8)) % 31) {
   \   0000019C   080095E5           LDR      R0,[R5, #+8]
   \   000001A0   010010E3           TST      R0,#0x1
   \   000001A4   0B00000A           BEQ      ??inflate_12
   \   000001A8   FF0008E2           AND      R0,R8,#0xFF
   \   000001AC   2814A0E1           LSR      R1,R8,#+8
   \   000001B0   000481E0           ADD      R0,R1,R0, LSL #+8
   \   000001B4   781F9FE5           LDR      R1,??inflate_13  ;; 0x8421085
   \   000001B8   912083E0           UMULL    R2,R3,R1,R0
   \   000001BC   1F20A0E3           MOV      R2,#+31
   \   000001C0   003093E0           ADDS     R3,R3,R0
   \   000001C4   6330A0E1           RRX      R3,R3
   \   000001C8   2332A0E1           LSR      R3,R3,#+4
   \   000001CC   920303E0           MUL      R3,R2,R3
   \   000001D0   033050E0           SUBS     R3,R0,R3
   \   000001D4   0300000A           BEQ      ??inflate_14
    614                          strm->msg = (char *)"incorrect header check";
   \                     ??inflate_12:
   \   000001D8   580F9FE5           LDR      R0,??inflate_13+0x4  ;; `?<Constant "incorrect header check">`
   \                     ??inflate_15:
   \   000001DC   180084E5           STR      R0,[R4, #+24]
    615                          state->mode = BAD;
   \   000001E0   1B00A0E3           MOV      R0,#+27
   \   000001E4   B7FFFFEA           B        ??inflate_6
    616                          break;
    617                      }
    618                      if (BITS(4) != Z_DEFLATED) {
   \                     ??inflate_14:
   \   000001E8   0F0008E2           AND      R0,R8,#0xF
   \   000001EC   080050E3           CMP      R0,#+8
   \   000001F0   0100000A           BEQ      ??inflate_16
    619                          strm->msg = (char *)"unknown compression method";
   \                     ??inflate_17:
   \   000001F4   400F9FE5           LDR      R0,??inflate_13+0x8  ;; `?<Constant "unknown compression m...">`
   \   000001F8   F7FFFFEA           B        ??inflate_15
    620                          state->mode = BAD;
    621                          break;
    622                      }
    623                      DROPBITS(4);
   \                     ??inflate_16:
   \   000001FC   2882A0E1           LSR      R8,R8,#+4
    624                      len = BITS(4) + 8;
   \   00000200   0F0008E2           AND      R0,R8,#0xF
   \   00000204   08B080E2           ADD      R11,R0,#+8
    625                      if (len > state->wbits) {
   \   00000208   240095E5           LDR      R0,[R5, #+36]
   \   0000020C   049049E2           SUB      R9,R9,#+4
   \   00000210   0B0050E1           CMP      R0,R11
   \   00000214   0300002A           BCS      ??inflate_18
    626                          strm->msg = (char *)"invalid window size";
   \   00000218   200F9FE5           LDR      R0,??inflate_13+0xC  ;; `?<Constant "invalid window size">`
   \                     ??inflate_19:
   \   0000021C   180084E5           STR      R0,[R4, #+24]
    627                          state->mode = BAD;
   \   00000220   1B00A0E3           MOV      R0,#+27
   \   00000224   A7FFFFEA           B        ??inflate_6
    628                          break;
    629                      }
    630                      state->dmax = 1U << len;
   \                     ??inflate_18:
   \   00000228   0100A0E3           MOV      R0,#+1
   \   0000022C   100BA0E1           LSL      R0,R0,R11
   \   00000230   140085E5           STR      R0,[R5, #+20]
    631                      Tracev((stderr, "inflate:   zlib header ok\n"));
    632                      strm->adler = state->check = adler32(0L, Z_NULL, 0);
   \   00000234   0020A0E3           MOV      R2,#+0
   \   00000238   0010A0E3           MOV      R1,#+0
   \   0000023C   0100A0E1           MOV      R0,R1
   \   00000240   ........           _BLF     adler32,??adler32??rA
   \   00000244   180085E5           STR      R0,[R5, #+24]
   \   00000248   300084E5           STR      R0,[R4, #+48]
    633                      state->mode = hold & 0x200 ? DICTID : TYPE;
   \   0000024C   800F18E3           TST      R8,#0x200
   \   00000250   0900A013           MOVNE    R0,#+9
   \   00000254   0B00A003           MOVEQ    R0,#+11
   \   00000258   0000C5E5           STRB     R0,[R5, #+0]
    634                      INITBITS();
   \   0000025C   0080A0E3           MOV      R8,#+0
   \   00000260   0090A0E3           MOV      R9,#+0
   \   00000264   98FFFFEA           B        ??inflate_4
    635                      break;
    636          #ifdef GUNZIP
    637                  case FLAGS:
    638                      NEEDBITS(16);
   \                     ??inflate_20:
   \   00000268   000057E3           CMP      R7,#+0
   \   0000026C   DA00000A           BEQ      ??inflate_10
   \   00000270   ........           LDRB     R0,[R6], #+1
   \   00000274   017047E2           SUB      R7,R7,#+1
   \   00000278   108988E0           ADD      R8,R8,R0, LSL R9
   \   0000027C   089089E2           ADD      R9,R9,#+8
   \                     ??inflate_21:
   \   00000280   100059E3           CMP      R9,#+16
   \   00000284   F7FFFF3A           BCC      ??inflate_20
    639                      state->flags = (int)(hold);
   \   00000288   108085E5           STR      R8,[R5, #+16]
    640                      if ((state->flags & 0xff) != Z_DEFLATED) {
   \   0000028C   FF0008E2           AND      R0,R8,#0xFF
   \   00000290   080050E3           CMP      R0,#+8
   \   00000294   D6FFFF1A           BNE      ??inflate_17
    641                          strm->msg = (char *)"unknown compression method";
    642                          state->mode = BAD;
    643                          break;
    644                      }
    645                      if (state->flags & 0xe000) {
   \   00000298   E00C18E3           TST      R8,#0xE000
   \   0000029C   0100000A           BEQ      ??inflate_22
    646                          strm->msg = (char *)"unknown header flags set";
   \   000002A0   9C0E9FE5           LDR      R0,??inflate_13+0x10  ;; `?<Constant "unknown header flags set">`
   \   000002A4   CCFFFFEA           B        ??inflate_15
    647                          state->mode = BAD;
    648                          break;
    649                      }
    650                      if (state->head != Z_NULL)
   \                     ??inflate_22:
   \   000002A8   201095E5           LDR      R1,[R5, #+32]
   \   000002AC   2804A0E1           LSR      R0,R8,#+8
   \   000002B0   000051E3           CMP      R1,#+0
    651                          state->head->text = (int)((hold >> 8) & 1);
   \   000002B4   01200012           ANDNE    R2,R0,#0x1
   \   000002B8   00208115           STRNE    R2,[R1, #+0]
    652                      if (state->flags & 0x0200) CRC2(state->check, hold);
   \   000002BC   101095E5           LDR      R1,[R5, #+16]
   \   000002C0   800F11E3           TST      R1,#0x200
   \   000002C4   0600000A           BEQ      ??inflate_23
   \   000002C8   0480CDE5           STRB     R8,[SP, #+4]
   \   000002CC   0500CDE5           STRB     R0,[SP, #+5]
   \   000002D0   180095E5           LDR      R0,[R5, #+24]
   \   000002D4   0220A0E3           MOV      R2,#+2
   \   000002D8   04108DE2           ADD      R1,SP,#+4
   \   000002DC   ........           _BLF     crc32,??crc32??rA
   \   000002E0   180085E5           STR      R0,[R5, #+24]
    653                      INITBITS();
   \                     ??inflate_23:
   \   000002E4   0080A0E3           MOV      R8,#+0
   \   000002E8   0090A0E3           MOV      R9,#+0
    654                      state->mode = TIME;
   \   000002EC   0200A0E3           MOV      R0,#+2
   \   000002F0   0000C5E5           STRB     R0,[R5, #+0]
    655                  case TIME:
    656                      NEEDBITS(32);
   \                     ??inflate_24:
   \   000002F4   000057E3           CMP      R7,#+0
   \   000002F8   B700000A           BEQ      ??inflate_10
   \   000002FC   ........           LDRB     R0,[R6], #+1
   \   00000300   017047E2           SUB      R7,R7,#+1
   \   00000304   108988E0           ADD      R8,R8,R0, LSL R9
   \   00000308   089089E2           ADD      R9,R9,#+8
   \                     ??inflate_25:
   \   0000030C   200059E3           CMP      R9,#+32
   \   00000310   F7FFFF3A           BCC      ??inflate_24
    657                      if (state->head != Z_NULL)
   \   00000314   200095E5           LDR      R0,[R5, #+32]
   \   00000318   000050E3           CMP      R0,#+0
    658                          state->head->time = hold;
   \   0000031C   04808015           STRNE    R8,[R0, #+4]
    659                      if (state->flags & 0x0200) CRC4(state->check, hold);
   \   00000320   100095E5           LDR      R0,[R5, #+16]
   \   00000324   800F10E3           TST      R0,#0x200
   \   00000328   0B00000A           BEQ      ??inflate_26
   \   0000032C   0480CDE5           STRB     R8,[SP, #+4]
   \   00000330   2814A0E1           LSR      R1,R8,#+8
   \   00000334   0510CDE5           STRB     R1,[SP, #+5]
   \   00000338   2818A0E1           LSR      R1,R8,#+16
   \   0000033C   0610CDE5           STRB     R1,[SP, #+6]
   \   00000340   281CA0E1           LSR      R1,R8,#+24
   \   00000344   0710CDE5           STRB     R1,[SP, #+7]
   \   00000348   180095E5           LDR      R0,[R5, #+24]
   \   0000034C   0420A0E3           MOV      R2,#+4
   \   00000350   04108DE2           ADD      R1,SP,#+4
   \   00000354   ........           _BLF     crc32,??crc32??rA
   \   00000358   180085E5           STR      R0,[R5, #+24]
    660                      INITBITS();
   \                     ??inflate_26:
   \   0000035C   0080A0E3           MOV      R8,#+0
   \   00000360   0090A0E3           MOV      R9,#+0
    661                      state->mode = OS;
   \   00000364   0300A0E3           MOV      R0,#+3
   \   00000368   0000C5E5           STRB     R0,[R5, #+0]
    662                  case OS:
    663                      NEEDBITS(16);
   \                     ??inflate_27:
   \   0000036C   000057E3           CMP      R7,#+0
   \   00000370   9900000A           BEQ      ??inflate_10
   \   00000374   ........           LDRB     R0,[R6], #+1
   \   00000378   017047E2           SUB      R7,R7,#+1
   \   0000037C   108988E0           ADD      R8,R8,R0, LSL R9
   \   00000380   089089E2           ADD      R9,R9,#+8
   \                     ??inflate_28:
   \   00000384   100059E3           CMP      R9,#+16
   \   00000388   F7FFFF3A           BCC      ??inflate_27
    664                      if (state->head != Z_NULL) {
   \   0000038C   201095E5           LDR      R1,[R5, #+32]
   \   00000390   2804A0E1           LSR      R0,R8,#+8
   \   00000394   000051E3           CMP      R1,#+0
   \   00000398   0300000A           BEQ      ??inflate_29
    665                          state->head->xflags = (int)(hold & 0xff);
   \   0000039C   FF2008E2           AND      R2,R8,#0xFF
   \   000003A0   082081E5           STR      R2,[R1, #+8]
    666                          state->head->os = (int)(hold >> 8);
   \   000003A4   201095E5           LDR      R1,[R5, #+32]
   \   000003A8   0C0081E5           STR      R0,[R1, #+12]
    667                      }
    668                      if (state->flags & 0x0200) CRC2(state->check, hold);
   \                     ??inflate_29:
   \   000003AC   101095E5           LDR      R1,[R5, #+16]
   \   000003B0   800F11E3           TST      R1,#0x200
   \   000003B4   0600000A           BEQ      ??inflate_30
   \   000003B8   0480CDE5           STRB     R8,[SP, #+4]
   \   000003BC   0500CDE5           STRB     R0,[SP, #+5]
   \   000003C0   180095E5           LDR      R0,[R5, #+24]
   \   000003C4   0220A0E3           MOV      R2,#+2
   \   000003C8   04108DE2           ADD      R1,SP,#+4
   \   000003CC   ........           _BLF     crc32,??crc32??rA
   \   000003D0   180085E5           STR      R0,[R5, #+24]
    669                      INITBITS();
   \                     ??inflate_30:
   \   000003D4   0080A0E3           MOV      R8,#+0
   \   000003D8   0090A0E3           MOV      R9,#+0
    670                      state->mode = EXLEN;
   \   000003DC   0400A0E3           MOV      R0,#+4
   \   000003E0   0000C5E5           STRB     R0,[R5, #+0]
    671                  case EXLEN:
    672                      if (state->flags & 0x0400) {
   \                     ??inflate_31:
   \   000003E4   100095E5           LDR      R0,[R5, #+16]
   \   000003E8   400E10E3           TST      R0,#0x400
   \   000003EC   2500001A           BNE      ??inflate_32
    673                          NEEDBITS(16);
    674                          state->length = (unsigned)(hold);
    675                          if (state->head != Z_NULL)
    676                              state->head->extra_len = (unsigned)hold;
    677                          if (state->flags & 0x0200) CRC2(state->check, hold);
    678                          INITBITS();
    679                      }
    680                      else if (state->head != Z_NULL)
   \   000003F0   200095E5           LDR      R0,[R5, #+32]
   \   000003F4   000050E3           CMP      R0,#+0
    681                          state->head->extra = Z_NULL;
   \   000003F8   0010A013           MOVNE    R1,#+0
   \   000003FC   10108015           STRNE    R1,[R0, #+16]
    682                      state->mode = EXTRA;
   \                     ??inflate_33:
   \   00000400   0500A0E3           MOV      R0,#+5
   \   00000404   0000C5E5           STRB     R0,[R5, #+0]
    683                  case EXTRA:
    684                      if (state->flags & 0x0400) {
   \                     ??inflate_34:
   \   00000408   100095E5           LDR      R0,[R5, #+16]
   \   0000040C   400E10E3           TST      R0,#0x400
   \   00000410   4600000A           BEQ      ??inflate_35
    685                          copy = state->length;
   \   00000414   40A095E5           LDR      R10,[R5, #+64]
    686                          if (copy > have) copy = have;
   \   00000418   0A0057E1           CMP      R7,R10
   \   0000041C   07A0A031           MOVCC    R10,R7
    687                          if (copy) {
   \   00000420   00005AE3           CMP      R10,#+0
   \   00000424   3E00000A           BEQ      ??inflate_36
    688                              if (state->head != Z_NULL &&
    689                                  state->head->extra != Z_NULL) {
   \   00000428   200095E5           LDR      R0,[R5, #+32]
   \   0000042C   000050E3           CMP      R0,#+0
   \   00000430   10009015           LDRNE    R0,[R0, #+16]
   \   00000434   00005013           CMPNE    R0,#+0
   \   00000438   2C00000A           BEQ      ??inflate_37
    690                                  len = state->head->extra_len - state->length;
   \   0000043C   200095E5           LDR      R0,[R5, #+32]
   \   00000440   401095E5           LDR      R1,[R5, #+64]
   \   00000444   140090E5           LDR      R0,[R0, #+20]
   \   00000448   01B040E0           SUB      R11,R0,R1
    691                                  zmemcpy(state->head->extra + len, next,
    692                                          len + copy > state->head->extra_max ?
    693                                          state->head->extra_max - len : copy);
   \   0000044C   200095E5           LDR      R0,[R5, #+32]
   \   00000450   0B108AE0           ADD      R1,R10,R11
   \   00000454   180090E5           LDR      R0,[R0, #+24]
   \   00000458   010050E1           CMP      R0,R1
   \   0000045C   1D00002A           BCS      ??inflate_38
   \   00000460   200095E5           LDR      R0,[R5, #+32]
   \   00000464   180090E5           LDR      R0,[R0, #+24]
   \   00000468   0B2040E0           SUB      R2,R0,R11
   \   0000046C   1A0000EA           B        ??inflate_39
   \                     ??inflate_40:
   \   00000470   000057E3           CMP      R7,#+0
   \   00000474   5800000A           BEQ      ??inflate_10
   \   00000478   ........           LDRB     R0,[R6], #+1
   \   0000047C   017047E2           SUB      R7,R7,#+1
   \   00000480   108988E0           ADD      R8,R8,R0, LSL R9
   \   00000484   089089E2           ADD      R9,R9,#+8
   \                     ??inflate_32:
   \   00000488   100059E3           CMP      R9,#+16
   \   0000048C   F7FFFF3A           BCC      ??inflate_40
   \   00000490   408085E5           STR      R8,[R5, #+64]
   \   00000494   200095E5           LDR      R0,[R5, #+32]
   \   00000498   000050E3           CMP      R0,#+0
   \   0000049C   14808015           STRNE    R8,[R0, #+20]
   \   000004A0   100095E5           LDR      R0,[R5, #+16]
   \   000004A4   800F10E3           TST      R0,#0x200
   \   000004A8   0700000A           BEQ      ??inflate_41
   \   000004AC   0480CDE5           STRB     R8,[SP, #+4]
   \   000004B0   2814A0E1           LSR      R1,R8,#+8
   \   000004B4   0510CDE5           STRB     R1,[SP, #+5]
   \   000004B8   180095E5           LDR      R0,[R5, #+24]
   \   000004BC   0220A0E3           MOV      R2,#+2
   \   000004C0   04108DE2           ADD      R1,SP,#+4
   \   000004C4   ........           _BLF     crc32,??crc32??rA
   \   000004C8   180085E5           STR      R0,[R5, #+24]
   \                     ??inflate_41:
   \   000004CC   0080A0E3           MOV      R8,#+0
   \   000004D0   0090A0E3           MOV      R9,#+0
   \   000004D4   C9FFFFEA           B        ??inflate_33
   \                     ??inflate_38:
   \   000004D8   0A20A0E1           MOV      R2,R10
   \                     ??inflate_39:
   \   000004DC   200095E5           LDR      R0,[R5, #+32]
   \   000004E0   0610A0E1           MOV      R1,R6
   \   000004E4   100090E5           LDR      R0,[R0, #+16]
   \   000004E8   00008BE0           ADD      R0,R11,R0
   \   000004EC   1E0100EF           SWI      +286
    694                              }
    695                              if (state->flags & 0x0200)
   \                     ??inflate_37:
   \   000004F0   100095E5           LDR      R0,[R5, #+16]
   \   000004F4   800F10E3           TST      R0,#0x200
   \   000004F8   0400000A           BEQ      ??inflate_42
    696                                  state->check = crc32(state->check, next, copy);
   \   000004FC   180095E5           LDR      R0,[R5, #+24]
   \   00000500   0A20A0E1           MOV      R2,R10
   \   00000504   0610A0E1           MOV      R1,R6
   \   00000508   ........           _BLF     crc32,??crc32??rA
   \   0000050C   180085E5           STR      R0,[R5, #+24]
    697                              have -= copy;
    698                              next += copy;
    699                              state->length -= copy;
   \                     ??inflate_42:
   \   00000510   400095E5           LDR      R0,[R5, #+64]
   \   00000514   0A7047E0           SUB      R7,R7,R10
   \   00000518   06608AE0           ADD      R6,R10,R6
   \   0000051C   0A0040E0           SUB      R0,R0,R10
   \   00000520   400085E5           STR      R0,[R5, #+64]
    700                          }
    701                          if (state->length) goto inf_leave;
   \                     ??inflate_36:
   \   00000524   400095E5           LDR      R0,[R5, #+64]
   \   00000528   000050E3           CMP      R0,#+0
   \   0000052C   2A00001A           BNE      ??inflate_10
    702                      }
    703                      state->length = 0;
   \                     ??inflate_35:
   \   00000530   0000A0E3           MOV      R0,#+0
   \   00000534   400085E5           STR      R0,[R5, #+64]
    704                      state->mode = NAME;
   \   00000538   0600A0E3           MOV      R0,#+6
   \   0000053C   0000C5E5           STRB     R0,[R5, #+0]
    705                  case NAME:
    706                      if (state->flags & 0x0800) {
   \                     ??inflate_43:
   \   00000540   100095E5           LDR      R0,[R5, #+16]
   \   00000544   800E10E3           TST      R0,#0x800
   \   00000548   3D00000A           BEQ      ??inflate_44
    707                          if (have == 0) goto inf_leave;
   \   0000054C   000057E3           CMP      R7,#+0
   \   00000550   2100000A           BEQ      ??inflate_10
    708                          copy = 0;
   \   00000554   00A0A0E3           MOV      R10,#+0
    709                          do {
    710                              len = (unsigned)(next[copy++]);
    711                              if (state->head != Z_NULL &&
    712                                      state->head->name != Z_NULL &&
    713                                      state->length < state->head->name_max)
   \                     ??inflate_45:
   \   00000558   200095E5           LDR      R0,[R5, #+32]
   \   0000055C   06B0DAE7           LDRB     R11,[R10, +R6]
   \   00000560   000050E3           CMP      R0,#+0
   \   00000564   1C009015           LDRNE    R0,[R0, #+28]
   \   00000568   01A08AE2           ADD      R10,R10,#+1
   \   0000056C   00005013           CMPNE    R0,#+0
   \   00000570   0900000A           BEQ      ??inflate_46
   \   00000574   201095E5           LDR      R1,[R5, #+32]
   \   00000578   400095E5           LDR      R0,[R5, #+64]
   \   0000057C   201091E5           LDR      R1,[R1, #+32]
   \   00000580   010050E1           CMP      R0,R1
   \   00000584   0400002A           BCS      ??inflate_46
    714                                  state->head->name[state->length++] = len;
   \   00000588   011080E2           ADD      R1,R0,#+1
   \   0000058C   401085E5           STR      R1,[R5, #+64]
   \   00000590   201095E5           LDR      R1,[R5, #+32]
   \   00000594   1C1091E5           LDR      R1,[R1, #+28]
   \   00000598   01B0C0E7           STRB     R11,[R0, +R1]
    715                          } while (len && copy < have);
   \                     ??inflate_46:
   \   0000059C   00005BE3           CMP      R11,#+0
   \   000005A0   0100000A           BEQ      ??inflate_47
   \   000005A4   07005AE1           CMP      R10,R7
   \   000005A8   EAFFFF3A           BCC      ??inflate_45
    716                          if (state->flags & 0x0200)
   \                     ??inflate_47:
   \   000005AC   100095E5           LDR      R0,[R5, #+16]
   \   000005B0   800F10E3           TST      R0,#0x200
   \   000005B4   0400000A           BEQ      ??inflate_48
    717                              state->check = crc32(state->check, next, copy);
   \   000005B8   180095E5           LDR      R0,[R5, #+24]
   \   000005BC   0A20A0E1           MOV      R2,R10
   \   000005C0   0610A0E1           MOV      R1,R6
   \   000005C4   ........           _BLF     crc32,??crc32??rA
   \   000005C8   180085E5           STR      R0,[R5, #+24]
    718                          have -= copy;
   \                     ??inflate_48:
   \   000005CC   0A7047E0           SUB      R7,R7,R10
    719                          next += copy;
   \   000005D0   06608AE0           ADD      R6,R10,R6
    720                          if (len) goto inf_leave;
   \   000005D4   00005BE3           CMP      R11,#+0
   \   000005D8   1E00000A           BEQ      ??inflate_49
    721                      }
    722                      else if (state->head != Z_NULL)
    723                          state->head->name = Z_NULL;
    724                      state->length = 0;
    725                      state->mode = COMMENT;
    726                  case COMMENT:
    727                      if (state->flags & 0x1000) {
    728                          if (have == 0) goto inf_leave;
    729                          copy = 0;
    730                          do {
    731                              len = (unsigned)(next[copy++]);
    732                              if (state->head != Z_NULL &&
    733                                      state->head->comment != Z_NULL &&
    734                                      state->length < state->head->comm_max)
    735                                  state->head->comment[state->length++] = len;
    736                          } while (len && copy < have);
    737                          if (state->flags & 0x0200)
    738                              state->check = crc32(state->check, next, copy);
    739                          have -= copy;
    740                          next += copy;
    741                          if (len) goto inf_leave;
    742                      }
    743                      else if (state->head != Z_NULL)
    744                          state->head->comment = Z_NULL;
    745                      state->mode = HCRC;
    746                  case HCRC:
    747                      if (state->flags & 0x0200) {
    748                          NEEDBITS(16);
    749                          if (hold != (state->check & 0xffff)) {
    750                              strm->msg = (char *)"header crc mismatch";
    751                              state->mode = BAD;
    752                              break;
    753                          }
    754                          INITBITS();
    755                      }
    756                      if (state->head != Z_NULL) {
    757                          state->head->hcrc = (int)((state->flags >> 9) & 1);
    758                          state->head->done = 1;
    759                      }
    760                      strm->adler = state->check = crc32(0L, Z_NULL, 0);
    761                      state->mode = TYPE;
    762                      break;
    763          #endif
    764                  case DICTID:
    765                      NEEDBITS(32);
    766                      strm->adler = state->check = REVERSE(hold);
    767                      INITBITS();
    768                      state->mode = DICT;
    769                  case DICT:
    770                      if (state->havedict == 0) {
    771                          RESTORE();
    772                          return Z_NEED_DICT;
    773                      }
    774                      strm->adler = state->check = adler32(0L, Z_NULL, 0);
    775                      state->mode = TYPE;
    776                  case TYPE:
    777                      if (flush == Z_BLOCK) goto inf_leave;
    778                  case TYPEDO:
    779                      if (state->last) {
    780                          BYTEBITS();
    781                          state->mode = CHECK;
    782                          break;
    783                      }
    784                      NEEDBITS(3);
    785                      state->last = BITS(1);
    786                      DROPBITS(1);
    787                      switch (BITS(2)) {
    788                      case 0:                             /* stored block */
    789                          Tracev((stderr, "inflate:     stored block%s\n",
    790                                  state->last ? " (last)" : ""));
    791                          state->mode = STORED;
    792                          break;
    793                      case 1:                             /* fixed block */
    794                          fixedtables(state);
    795                          Tracev((stderr, "inflate:     fixed codes block%s\n",
    796                                  state->last ? " (last)" : ""));
    797                          state->mode = LEN;              /* decode codes */
    798                          break;
    799                      case 2:                             /* dynamic block */
    800                          Tracev((stderr, "inflate:     dynamic codes block%s\n",
    801                                  state->last ? " (last)" : ""));
    802                          state->mode = TABLE;
    803                          break;
    804                      case 3:
    805                          strm->msg = (char *)"invalid block type";
    806                          state->mode = BAD;
    807                      }
    808                      DROPBITS(2);
    809                      break;
    810                  case STORED:
    811                      BYTEBITS();                         /* go to byte boundary */
    812                      NEEDBITS(32);
    813                      if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
    814                          strm->msg = (char *)"invalid stored block lengths";
    815                          state->mode = BAD;
    816                          break;
    817                      }
    818                      state->length = (unsigned)hold & 0xffff;
    819                      Tracev((stderr, "inflate:       stored length %u\n",
    820                              state->length));
    821                      INITBITS();
    822                      state->mode = COPY;
    823                  case COPY:
    824                      copy = state->length;
    825                      if (copy) {
    826                          if (copy > have) copy = have;
    827                          if (copy > left) copy = left;
    828                          if (copy == 0) goto inf_leave;
    829                          zmemcpy(put, next, copy);
    830                          have -= copy;
    831                          next += copy;
    832                          left -= copy;
    833                          put += copy;
    834                          state->length -= copy;
    835                          break;
    836                      }
    837                      Tracev((stderr, "inflate:       stored end\n"));
    838                      state->mode = TYPE;
    839                      break;
    840                  case TABLE:
    841                      NEEDBITS(14);
    842                      state->nlen = BITS(5) + 257;
    843                      DROPBITS(5);
    844                      state->ndist = BITS(5) + 1;
    845                      DROPBITS(5);
    846                      state->ncode = BITS(4) + 4;
    847                      DROPBITS(4);
    848          #ifndef PKZIP_BUG_WORKAROUND
    849                      if (state->nlen > 286 || state->ndist > 30) {
    850                          strm->msg = (char *)"too many length or distance symbols";
    851                          state->mode = BAD;
    852                          break;
    853                      }
    854          #endif
    855                      Tracev((stderr, "inflate:       table sizes ok\n"));
    856                      state->have = 0;
    857                      state->mode = LENLENS;
    858                  case LENLENS:
    859                      while (state->have < state->ncode) {
    860                          NEEDBITS(3);
    861                          state->lens[order[state->have++]] = (unsigned short)BITS(3);
    862                          DROPBITS(3);
    863                      }
    864                      while (state->have < 19)
    865                          state->lens[order[state->have++]] = 0;
    866                      state->next = state->codes;
    867                      state->lencode = (code const FAR *)(state->next);
    868                      state->lenbits = 7;
    869                      ret = inflate_table(CODES, state->lens, 19, &(state->next),
    870                                          &(state->lenbits), state->work);
    871                      if (ret) {
    872                          strm->msg = (char *)"invalid code lengths set";
    873                          state->mode = BAD;
    874                          break;
    875                      }
    876                      Tracev((stderr, "inflate:       code lengths ok\n"));
    877                      state->have = 0;
    878                      state->mode = CODELENS;
    879                  case CODELENS:
    880                      while (state->have < state->nlen + state->ndist) {
    881                          for (;;) {
    882                              this = state->lencode[BITS(state->lenbits)];
    883                              if ((unsigned)(this.bits) <= bits) break;
    884                              PULLBYTE();
    885                          }
    886                          if (this.val < 16) {
    887                              NEEDBITS(this.bits);
    888                              DROPBITS(this.bits);
    889                              state->lens[state->have++] = this.val;
    890                          }
    891                          else {
    892                              if (this.val == 16) {
    893                                  NEEDBITS(this.bits + 2);
    894                                  DROPBITS(this.bits);
    895                                  if (state->have == 0) {
    896                                      strm->msg = (char *)"invalid bit length repeat";
    897                                      state->mode = BAD;
    898                                      break;
    899                                  }
    900                                  len = state->lens[state->have - 1];
    901                                  copy = 3 + BITS(2);
    902                                  DROPBITS(2);
    903                              }
    904                              else if (this.val == 17) {
    905                                  NEEDBITS(this.bits + 3);
    906                                  DROPBITS(this.bits);
    907                                  len = 0;
    908                                  copy = 3 + BITS(3);
    909                                  DROPBITS(3);
    910                              }
    911                              else {
    912                                  NEEDBITS(this.bits + 7);
    913                                  DROPBITS(this.bits);
    914                                  len = 0;
    915                                  copy = 11 + BITS(7);
    916                                  DROPBITS(7);
    917                              }
    918                              if (state->have + copy > state->nlen + state->ndist) {
    919                                  strm->msg = (char *)"invalid bit length repeat";
    920                                  state->mode = BAD;
    921                                  break;
    922                              }
    923                              while (copy--)
    924                                  state->lens[state->have++] = (unsigned short)len;
    925                          }
    926                      }
    927          
    928                      /* handle error breaks in while */
    929                      if (state->mode == BAD) break;
    930          
    931                      /* build code tables */
    932                      state->next = state->codes;
    933                      state->lencode = (code const FAR *)(state->next);
    934                      state->lenbits = 9;
    935                      ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
    936                                          &(state->lenbits), state->work);
    937                      if (ret) {
    938                          strm->msg = (char *)"invalid literal/lengths set";
    939                          state->mode = BAD;
    940                          break;
    941                      }
    942                      state->distcode = (code const FAR *)(state->next);
    943                      state->distbits = 6;
    944                      ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
    945                                      &(state->next), &(state->distbits), state->work);
    946                      if (ret) {
    947                          strm->msg = (char *)"invalid distances set";
    948                          state->mode = BAD;
    949                          break;
    950                      }
    951                      Tracev((stderr, "inflate:       codes ok\n"));
    952                      state->mode = LEN;
    953                  case LEN:
    954                      if (have >= 6 && left >= 258) {
    955                          RESTORE();
    956                          inflate_fast(strm, out);
    957                          LOAD();
    958                          break;
    959                      }
    960                      for (;;) {
    961                          this = state->lencode[BITS(state->lenbits)];
    962                          if ((unsigned)(this.bits) <= bits) break;
    963                          PULLBYTE();
    964                      }
    965                      if (this.op && (this.op & 0xf0) == 0) {
    966                          last = this;
    967                          for (;;) {
    968                              this = state->lencode[last.val +
    969                                      (BITS(last.bits + last.op) >> last.bits)];
    970                              if ((unsigned)(last.bits + this.bits) <= bits) break;
    971                              PULLBYTE();
    972                          }
    973                          DROPBITS(last.bits);
    974                      }
    975                      DROPBITS(this.bits);
    976                      state->length = (unsigned)this.val;
    977                      if ((int)(this.op) == 0) {
    978                          Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
    979                                  "inflate:         literal '%c'\n" :
    980                                  "inflate:         literal 0x%02x\n", this.val));
    981                          state->mode = LIT;
    982                          break;
    983                      }
    984                      if (this.op & 32) {
    985                          Tracevv((stderr, "inflate:         end of block\n"));
    986                          state->mode = TYPE;
    987                          break;
    988                      }
    989                      if (this.op & 64) {
    990                          strm->msg = (char *)"invalid literal/length code";
    991                          state->mode = BAD;
    992                          break;
    993                      }
    994                      state->extra = (unsigned)(this.op) & 15;
    995                      state->mode = LENEXT;
    996                  case LENEXT:
    997                      if (state->extra) {
    998                          NEEDBITS(state->extra);
    999                          state->length += BITS(state->extra);
   1000                          DROPBITS(state->extra);
   1001                      }
   1002                      Tracevv((stderr, "inflate:         length %u\n", state->length));
   1003                      state->mode = DIST;
   1004                  case DIST:
   1005                      for (;;) {
   1006                          this = state->distcode[BITS(state->distbits)];
   1007                          if ((unsigned)(this.bits) <= bits) break;
   1008                          PULLBYTE();
   1009                      }
   1010                      if ((this.op & 0xf0) == 0) {
   1011                          last = this;
   1012                          for (;;) {
   1013                              this = state->distcode[last.val +
   1014                                      (BITS(last.bits + last.op) >> last.bits)];
   1015                              if ((unsigned)(last.bits + this.bits) <= bits) break;
   1016                              PULLBYTE();
   1017                          }
   1018                          DROPBITS(last.bits);
   1019                      }
   1020                      DROPBITS(this.bits);
   1021                      if (this.op & 64) {
   1022                          strm->msg = (char *)"invalid distance code";
   1023                          state->mode = BAD;
   1024                          break;
   1025                      }
   1026                      state->offset = (unsigned)this.val;
   1027                      state->extra = (unsigned)(this.op) & 15;
   1028                      state->mode = DISTEXT;
   1029                  case DISTEXT:
   1030                      if (state->extra) {
   1031                          NEEDBITS(state->extra);
   1032                          state->offset += BITS(state->extra);
   1033                          DROPBITS(state->extra);
   1034                      }
   1035          #ifdef INFLATE_STRICT
   1036                      if (state->offset > state->dmax) {
   1037                          strm->msg = (char *)"invalid distance too far back";
   1038                          state->mode = BAD;
   1039                          break;
   1040                      }
   1041          #endif
   1042                      if (state->offset > state->whave + out - left) {
   1043                          strm->msg = (char *)"invalid distance too far back";
   1044                          state->mode = BAD;
   1045                          break;
   1046                      }
   1047                      Tracevv((stderr, "inflate:         distance %u\n", state->offset));
   1048                      state->mode = MATCH;
   1049                  case MATCH:
   1050                      if (left == 0) goto inf_leave;
   1051                      copy = out - left;
   1052                      if (state->offset > copy) {         /* copy from window */
   1053                          copy = state->offset - copy;
   1054                          if (copy > state->write) {
   1055                              copy -= state->write;
   1056                              from = state->window + (state->wsize - copy);
   1057                          }
   1058                          else
   1059                              from = state->window + (state->write - copy);
   1060                          if (copy > state->length) copy = state->length;
   1061                      }
   1062                      else {                              /* copy from output */
   1063                          from = put - state->offset;
   1064                          copy = state->length;
   1065                      }
   1066                      if (copy > left) copy = left;
   1067                      left -= copy;
   1068                      state->length -= copy;
   1069                      do {
   1070                          *put++ = *from++;
   1071                      } while (--copy);
   1072                      if (state->length == 0) state->mode = LEN;
   1073                      break;
   1074                  case LIT:
   1075                      if (left == 0) goto inf_leave;
   1076                      *put++ = (unsigned char)(state->length);
   1077                      left--;
   1078                      state->mode = LEN;
   1079                      break;
   1080                  case CHECK:
   1081                      if (state->wrap) {
   1082                          NEEDBITS(32);
   1083                          out -= left;
   1084                          strm->total_out += out;
   1085                          state->total += out;
   1086                          if (out)
   1087                              strm->adler = state->check =
   1088                                  UPDATE(state->check, put - out, out);
   1089                          out = left;
   1090                          if ((
   1091          #ifdef GUNZIP
   1092                               state->flags ? hold :
   1093          #endif
   1094                               REVERSE(hold)) != state->check) {
   1095                              strm->msg = (char *)"incorrect data check";
   1096                              state->mode = BAD;
   1097                              break;
   1098                          }
   1099                          INITBITS();
   1100                          Tracev((stderr, "inflate:   check matches trailer\n"));
   1101                      }
   1102          #ifdef GUNZIP
   1103                      state->mode = LENGTH;
   1104                  case LENGTH:
   1105                      if (state->wrap && state->flags) {
   1106                          NEEDBITS(32);
   1107                          if (hold != (state->total & 0xffffffffUL)) {
   1108                              strm->msg = (char *)"incorrect length check";
   1109                              state->mode = BAD;
   1110                              break;
   1111                          }
   1112                          INITBITS();
   1113                          Tracev((stderr, "inflate:   length matches trailer\n"));
   1114                      }
   1115          #endif
   1116                      state->mode = DONE;
   1117                  case DONE:
   1118                      ret = Z_STREAM_END;
   1119                      goto inf_leave;
   1120                  case BAD:
   1121                      ret = Z_DATA_ERROR;
   1122                      goto inf_leave;
   1123                  case MEM:
   1124                      return Z_MEM_ERROR;
   1125                  case SYNC:
   1126                  default:
   1127                      return Z_STREAM_ERROR;
   1128                  }
   1129          
   1130              /*
   1131                 Return from inflate(), updating the total counts and the check value.
   1132                 If there was no progress during the inflate() call, return a buffer
   1133                 error.  Call updatewindow() to create and/or update the window state.
   1134                 Note: a memory error from inflate() is non-recoverable.
   1135               */
   1136            inf_leave:
   1137              RESTORE();
   \                     ??inflate_10:
   \   000005DC   0C009DE5           LDR      R0,[SP, #+12]
   \   000005E0   0C0084E5           STR      R0,[R4, #+12]
   \   000005E4   00009DE5           LDR      R0,[SP, #+0]
   \   000005E8   100084E5           STR      R0,[R4, #+16]
   \   000005EC   006084E5           STR      R6,[R4, #+0]
   \   000005F0   047084E5           STR      R7,[R4, #+4]
   \   000005F4   388085E5           STR      R8,[R5, #+56]
   \   000005F8   3C9085E5           STR      R9,[R5, #+60]
   1138              if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
   \   000005FC   280095E5           LDR      R0,[R5, #+40]
   \   00000600   000050E3           CMP      R0,#+0
   \   00000604   0600001A           BNE      ??inflate_50
   \   00000608   D000D5E1           LDRSB    R0,[R5, #+0]
   \   0000060C   180050E3           CMP      R0,#+24
   \   00000610   820300AA           BGE      ??inflate_51
   \   00000614   08009DE5           LDR      R0,[SP, #+8]
   \   00000618   101094E5           LDR      R1,[R4, #+16]
   \   0000061C   010050E1           CMP      R0,R1
   \   00000620   7E03000A           BEQ      ??inflate_51
   1139                  if (updatewindow(strm, out)) {
   \                     ??inflate_50:
   \   00000624   08109DE5           LDR      R1,[SP, #+8]
   \   00000628   0400A0E1           MOV      R0,R4
   \   0000062C   ........           BL       updatewindow
   \   00000630   000050E3           CMP      R0,#+0
   \   00000634   7903000A           BEQ      ??inflate_51
   1140                      state->mode = MEM;
   \   00000638   1C00A0E3           MOV      R0,#+28
   \   0000063C   0000C5E5           STRB     R0,[R5, #+0]
   1141                      return Z_MEM_ERROR;
   \   00000640   730300EA           B        ??inflate_52
   1142                  }
   \                     ??inflate_44:
   \   00000644   200095E5           LDR      R0,[R5, #+32]
   \   00000648   000050E3           CMP      R0,#+0
   \   0000064C   0200000A           BEQ      ??inflate_53
   \   00000650   0010A0E3           MOV      R1,#+0
   \   00000654   1C1080E5           STR      R1,[R0, #+28]
   \                     ??inflate_49:
   \   00000658   0000A0E3           MOV      R0,#+0
   \                     ??inflate_53:
   \   0000065C   400085E5           STR      R0,[R5, #+64]
   \   00000660   0700A0E3           MOV      R0,#+7
   \   00000664   0000C5E5           STRB     R0,[R5, #+0]
   \                     ??inflate_54:
   \   00000668   100095E5           LDR      R0,[R5, #+16]
   \   0000066C   400D10E3           TST      R0,#0x1000
   \   00000670   2400000A           BEQ      ??inflate_55
   \   00000674   000057E3           CMP      R7,#+0
   \   00000678   D7FFFF0A           BEQ      ??inflate_10
   \   0000067C   00A0A0E3           MOV      R10,#+0
   \                     ??inflate_56:
   \   00000680   200095E5           LDR      R0,[R5, #+32]
   \   00000684   06B0DAE7           LDRB     R11,[R10, +R6]
   \   00000688   000050E3           CMP      R0,#+0
   \   0000068C   24009015           LDRNE    R0,[R0, #+36]
   \   00000690   01A08AE2           ADD      R10,R10,#+1
   \   00000694   00005013           CMPNE    R0,#+0
   \   00000698   0900000A           BEQ      ??inflate_57
   \   0000069C   201095E5           LDR      R1,[R5, #+32]
   \   000006A0   400095E5           LDR      R0,[R5, #+64]
   \   000006A4   281091E5           LDR      R1,[R1, #+40]
   \   000006A8   010050E1           CMP      R0,R1
   \   000006AC   0400002A           BCS      ??inflate_57
   \   000006B0   011080E2           ADD      R1,R0,#+1
   \   000006B4   401085E5           STR      R1,[R5, #+64]
   \   000006B8   201095E5           LDR      R1,[R5, #+32]
   \   000006BC   241091E5           LDR      R1,[R1, #+36]
   \   000006C0   01B0C0E7           STRB     R11,[R0, +R1]
   \                     ??inflate_57:
   \   000006C4   00005BE3           CMP      R11,#+0
   \   000006C8   0100000A           BEQ      ??inflate_58
   \   000006CC   07005AE1           CMP      R10,R7
   \   000006D0   EAFFFF3A           BCC      ??inflate_56
   \                     ??inflate_58:
   \   000006D4   100095E5           LDR      R0,[R5, #+16]
   \   000006D8   800F10E3           TST      R0,#0x200
   \   000006DC   0400000A           BEQ      ??inflate_59
   \   000006E0   180095E5           LDR      R0,[R5, #+24]
   \   000006E4   0A20A0E1           MOV      R2,R10
   \   000006E8   0610A0E1           MOV      R1,R6
   \   000006EC   ........           _BLF     crc32,??crc32??rA
   \   000006F0   180085E5           STR      R0,[R5, #+24]
   \                     ??inflate_59:
   \   000006F4   0A7047E0           SUB      R7,R7,R10
   \   000006F8   06608AE0           ADD      R6,R10,R6
   \   000006FC   00005BE3           CMP      R11,#+0
   \   00000700   B5FFFF1A           BNE      ??inflate_10
   \   00000704   030000EA           B        ??inflate_60
   \                     ??inflate_55:
   \   00000708   200095E5           LDR      R0,[R5, #+32]
   \   0000070C   000050E3           CMP      R0,#+0
   \   00000710   0010A013           MOVNE    R1,#+0
   \   00000714   24108015           STRNE    R1,[R0, #+36]
   \                     ??inflate_60:
   \   00000718   0800A0E3           MOV      R0,#+8
   \   0000071C   0000C5E5           STRB     R0,[R5, #+0]
   \                     ??inflate_61:
   \   00000720   100095E5           LDR      R0,[R5, #+16]
   \   00000724   800F10E3           TST      R0,#0x200
   \   00000728   0600001A           BNE      ??inflate_62
   \   0000072C   0F0000EA           B        ??inflate_63
   \                     ??inflate_64:
   \   00000730   000057E3           CMP      R7,#+0
   \   00000734   A8FFFF0A           BEQ      ??inflate_10
   \   00000738   ........           LDRB     R0,[R6], #+1
   \   0000073C   017047E2           SUB      R7,R7,#+1
   \   00000740   108988E0           ADD      R8,R8,R0, LSL R9
   \   00000744   089089E2           ADD      R9,R9,#+8
   \                     ??inflate_62:
   \   00000748   100059E3           CMP      R9,#+16
   \   0000074C   F7FFFF3A           BCC      ??inflate_64
   \   00000750   180095E5           LDR      R0,[R5, #+24]
   \   00000754   0008A0E1           LSL      R0,R0,#+16
   \   00000758   200858E1           CMP      R8,R0, LSR #+16
   \   0000075C   0100000A           BEQ      ??inflate_65
   \   00000760   B00D9FE5           LDR      R0,??inflate_66  ;; `?<Constant "header crc mismatch">`
   \   00000764   ACFEFFEA           B        ??inflate_19
   \                     ??inflate_65:
   \   00000768   0080A0E3           MOV      R8,#+0
   \   0000076C   0090A0E3           MOV      R9,#+0
   \                     ??inflate_63:
   \   00000770   200095E5           LDR      R0,[R5, #+32]
   \   00000774   000050E3           CMP      R0,#+0
   \   00000778   0600000A           BEQ      ??inflate_67
   \   0000077C   101095E5           LDR      R1,[R5, #+16]
   \   00000780   0120A0E3           MOV      R2,#+1
   \   00000784   C11402E0           AND      R1,R2,R1, ASR #+9
   \   00000788   2C1080E5           STR      R1,[R0, #+44]
   \   0000078C   200095E5           LDR      R0,[R5, #+32]
   \   00000790   0110A0E3           MOV      R1,#+1
   \   00000794   301080E5           STR      R1,[R0, #+48]
   \                     ??inflate_67:
   \   00000798   0020A0E3           MOV      R2,#+0
   \   0000079C   0010A0E3           MOV      R1,#+0
   \   000007A0   0100A0E1           MOV      R0,R1
   \   000007A4   ........           _BLF     crc32,??crc32??rA
   \   000007A8   180085E5           STR      R0,[R5, #+24]
   \   000007AC   300084E5           STR      R0,[R4, #+48]
   \                     ??inflate_68:
   \   000007B0   0B00A0E3           MOV      R0,#+11
   \   000007B4   43FEFFEA           B        ??inflate_6
   \                     ??inflate_69:
   \   000007B8   000057E3           CMP      R7,#+0
   \   000007BC   86FFFF0A           BEQ      ??inflate_10
   \   000007C0   ........           LDRB     R0,[R6], #+1
   \   000007C4   017047E2           SUB      R7,R7,#+1
   \   000007C8   108988E0           ADD      R8,R8,R0, LSL R9
   \   000007CC   089089E2           ADD      R9,R9,#+8
   \                     ??inflate_70:
   \   000007D0   200059E3           CMP      R9,#+32
   \   000007D4   F7FFFF3A           BCC      ??inflate_69
   \   000007D8   FF0CA0E3           MOV      R0,#+65280
   \   000007DC   280400E0           AND      R0,R0,R8, LSR #+8
   \   000007E0   280C80E0           ADD      R0,R0,R8, LSR #+24
   \   000007E4   FF1C08E2           AND      R1,R8,#0xFF00
   \   000007E8   010480E0           ADD      R0,R0,R1, LSL #+8
   \   000007EC   080C80E0           ADD      R0,R0,R8, LSL #+24
   \   000007F0   180085E5           STR      R0,[R5, #+24]
   \   000007F4   300084E5           STR      R0,[R4, #+48]
   \   000007F8   0080A0E3           MOV      R8,#+0
   \   000007FC   0090A0E3           MOV      R9,#+0
   \   00000800   0A00A0E3           MOV      R0,#+10
   \   00000804   0000C5E5           STRB     R0,[R5, #+0]
   \                     ??inflate_71:
   \   00000808   0C0095E5           LDR      R0,[R5, #+12]
   \   0000080C   000050E3           CMP      R0,#+0
   \   00000810   0900001A           BNE      ??inflate_72
   \   00000814   0C009DE5           LDR      R0,[SP, #+12]
   \   00000818   0C0084E5           STR      R0,[R4, #+12]
   \   0000081C   00009DE5           LDR      R0,[SP, #+0]
   \   00000820   100084E5           STR      R0,[R4, #+16]
   \   00000824   006084E5           STR      R6,[R4, #+0]
   \   00000828   047084E5           STR      R7,[R4, #+4]
   \   0000082C   388085E5           STR      R8,[R5, #+56]
   \   00000830   3C9085E5           STR      R9,[R5, #+60]
   \   00000834   0200A0E3           MOV      R0,#+2
   \   00000838   F60200EA           B        ??inflate_3
   \                     ??inflate_72:
   \   0000083C   0020A0E3           MOV      R2,#+0
   \   00000840   0010A0E3           MOV      R1,#+0
   \   00000844   0100A0E1           MOV      R0,R1
   \   00000848   ........           _BLF     adler32,??adler32??rA
   \   0000084C   180085E5           STR      R0,[R5, #+24]
   \   00000850   300084E5           STR      R0,[R4, #+48]
   \   00000854   0B00A0E3           MOV      R0,#+11
   \   00000858   0000C5E5           STRB     R0,[R5, #+0]
   \                     ??inflate_73:
   \   0000085C   20009DE5           LDR      R0,[SP, #+32]
   \   00000860   050050E3           CMP      R0,#+5
   \   00000864   5CFFFF0A           BEQ      ??inflate_10
   \                     ??inflate_74:
   \   00000868   040095E5           LDR      R0,[R5, #+4]
   \   0000086C   000050E3           CMP      R0,#+0
   \   00000870   0A00000A           BEQ      ??inflate_75
   \   00000874   070009E2           AND      R0,R9,#0x7
   \   00000878   3880A0E1           LSR      R8,R8,R0
   \   0000087C   009049E0           SUB      R9,R9,R0
   \   00000880   1800A0E3           MOV      R0,#+24
   \   00000884   0FFEFFEA           B        ??inflate_6
   \                     ??inflate_76:
   \   00000888   000057E3           CMP      R7,#+0
   \   0000088C   52FFFF0A           BEQ      ??inflate_10
   \   00000890   ........           LDRB     R0,[R6], #+1
   \   00000894   017047E2           SUB      R7,R7,#+1
   \   00000898   108988E0           ADD      R8,R8,R0, LSL R9
   \   0000089C   089089E2           ADD      R9,R9,#+8
   \                     ??inflate_75:
   \   000008A0   030059E3           CMP      R9,#+3
   \   000008A4   F7FFFF3A           BCC      ??inflate_76
   \   000008A8   010008E2           AND      R0,R8,#0x1
   \   000008AC   040085E5           STR      R0,[R5, #+4]
   \   000008B0   A880A0E1           LSR      R8,R8,#+1
   \   000008B4   030018E2           ANDS     R0,R8,#0x3
   \   000008B8   0600000A           BEQ      ??inflate_77
   \   000008BC   010050E2           SUBS     R0,R0,#+1
   \   000008C0   0600000A           BEQ      ??inflate_78
   \   000008C4   010050E2           SUBS     R0,R0,#+1
   \   000008C8   0800000A           BEQ      ??inflate_79
   \   000008CC   010050E2           SUBS     R0,R0,#+1
   \   000008D0   0800000A           BEQ      ??inflate_80
   \   000008D4   0B0000EA           B        ??inflate_81
   \                     ??inflate_77:
   \   000008D8   0D00A0E3           MOV      R0,#+13
   \   000008DC   080000EA           B        ??inflate_82
   \                     ??inflate_78:
   \   000008E0   0500A0E1           MOV      R0,R5
   \   000008E4   ........           BL       fixedtables
   \   000008E8   1200A0E3           MOV      R0,#+18
   \   000008EC   040000EA           B        ??inflate_82
   \                     ??inflate_79:
   \   000008F0   0F00A0E3           MOV      R0,#+15
   \   000008F4   020000EA           B        ??inflate_82
   \                     ??inflate_80:
   \   000008F8   1C0C9FE5           LDR      R0,??inflate_66+0x4  ;; `?<Constant "invalid block type">`
   \   000008FC   180084E5           STR      R0,[R4, #+24]
   \   00000900   1B00A0E3           MOV      R0,#+27
   \                     ??inflate_82:
   \   00000904   0000C5E5           STRB     R0,[R5, #+0]
   \                     ??inflate_81:
   \   00000908   2881A0E1           LSR      R8,R8,#+2
   \   0000090C   039049E2           SUB      R9,R9,#+3
   \   00000910   EDFDFFEA           B        ??inflate_4
   \                     ??inflate_83:
   \   00000914   070009E2           AND      R0,R9,#0x7
   \   00000918   3880A0E1           LSR      R8,R8,R0
   \   0000091C   009049E0           SUB      R9,R9,R0
   \   00000920   050000EA           B        ??inflate_84
   \                     ??inflate_85:
   \   00000924   000057E3           CMP      R7,#+0
   \   00000928   2BFFFF0A           BEQ      ??inflate_10
   \   0000092C   ........           LDRB     R0,[R6], #+1
   \   00000930   017047E2           SUB      R7,R7,#+1
   \   00000934   108988E0           ADD      R8,R8,R0, LSL R9
   \   00000938   089089E2           ADD      R9,R9,#+8
   \                     ??inflate_84:
   \   0000093C   200059E3           CMP      R9,#+32
   \   00000940   F7FFFF3A           BCC      ??inflate_85
   \   00000944   0808A0E1           LSL      R0,R8,#+16
   \   00000948   FF10A0E3           MOV      R1,#+255
   \   0000094C   FF1C81E3           ORR      R1,R1,#0xFF00
   \   00000950   281821E0           EOR      R1,R1,R8, LSR #+16
   \   00000954   200851E1           CMP      R1,R0, LSR #+16
   \   00000958   0100000A           BEQ      ??inflate_86
   \   0000095C   BC0B9FE5           LDR      R0,??inflate_66+0x8  ;; `?<Constant "invalid stored block ...">`
   \   00000960   1DFEFFEA           B        ??inflate_15
   \                     ??inflate_86:
   \   00000964   2008A0E1           LSR      R0,R0,#+16
   \   00000968   400085E5           STR      R0,[R5, #+64]
   \   0000096C   0080A0E3           MOV      R8,#+0
   \   00000970   0090A0E3           MOV      R9,#+0
   \   00000974   0E00A0E3           MOV      R0,#+14
   \   00000978   0000C5E5           STRB     R0,[R5, #+0]
   \                     ??inflate_87:
   \   0000097C   40A095E5           LDR      R10,[R5, #+64]
   \   00000980   00005AE3           CMP      R10,#+0
   \   00000984   89FFFF0A           BEQ      ??inflate_68
   \   00000988   00009DE5           LDR      R0,[SP, #+0]
   \   0000098C   0A0057E1           CMP      R7,R10
   \   00000990   07A0A031           MOVCC    R10,R7
   \   00000994   0A0050E1           CMP      R0,R10
   \   00000998   00A0A031           MOVCC    R10,R0
   \   0000099C   00005AE3           CMP      R10,#+0
   \   000009A0   0DFFFF0A           BEQ      ??inflate_10
   \   000009A4   0C009DE5           LDR      R0,[SP, #+12]
   \   000009A8   0A20A0E1           MOV      R2,R10
   \   000009AC   0610A0E1           MOV      R1,R6
   \   000009B0   1E0100EF           SWI      +286
   \   000009B4   00109DE5           LDR      R1,[SP, #+0]
   \   000009B8   0A7047E0           SUB      R7,R7,R10
   \   000009BC   0A1041E0           SUB      R1,R1,R10
   \   000009C0   00108DE5           STR      R1,[SP, #+0]
   \   000009C4   0C109DE5           LDR      R1,[SP, #+12]
   \   000009C8   06608AE0           ADD      R6,R10,R6
   \   000009CC   01108AE0           ADD      R1,R10,R1
   \   000009D0   0C108DE5           STR      R1,[SP, #+12]
   \   000009D4   400095E5           LDR      R0,[R5, #+64]
   \   000009D8   0A0040E0           SUB      R0,R0,R10
   \   000009DC   400085E5           STR      R0,[R5, #+64]
   \   000009E0   B9FDFFEA           B        ??inflate_4
   \                     ??inflate_88:
   \   000009E4   000057E3           CMP      R7,#+0
   \   000009E8   FBFEFF0A           BEQ      ??inflate_10
   \   000009EC   ........           LDRB     R0,[R6], #+1
   \   000009F0   017047E2           SUB      R7,R7,#+1
   \   000009F4   108988E0           ADD      R8,R8,R0, LSL R9
   \   000009F8   089089E2           ADD      R9,R9,#+8
   \                     ??inflate_89:
   \   000009FC   0E0059E3           CMP      R9,#+14
   \   00000A00   F7FFFF3A           BCC      ??inflate_88
   \   00000A04   1F0008E2           AND      R0,R8,#0x1F
   \   00000A08   0110A0E3           MOV      R1,#+1
   \   00000A0C   401F81E3           ORR      R1,R1,#0x100
   \   00000A10   000081E0           ADD      R0,R1,R0
   \   00000A14   600085E5           STR      R0,[R5, #+96]
   \   00000A18   A802A0E1           LSR      R0,R8,#+5
   \   00000A1C   1F1000E2           AND      R1,R0,#0x1F
   \   00000A20   011081E2           ADD      R1,R1,#+1
   \   00000A24   641085E5           STR      R1,[R5, #+100]
   \   00000A28   A002A0E1           LSR      R0,R0,#+5
   \   00000A2C   0F1000E2           AND      R1,R0,#0xF
   \   00000A30   041081E2           ADD      R1,R1,#+4
   \   00000A34   5C1085E5           STR      R1,[R5, #+92]
   \   00000A38   2082A0E1           LSR      R8,R0,#+4
   \   00000A3C   600095E5           LDR      R0,[R5, #+96]
   \   00000A40   1F10A0E3           MOV      R1,#+31
   \   00000A44   401F81E3           ORR      R1,R1,#0x100
   \   00000A48   010050E1           CMP      R0,R1
   \   00000A4C   64009535           LDRCC    R0,[R5, #+100]
   \   00000A50   0E9049E2           SUB      R9,R9,#+14
   \   00000A54   1F005033           CMPCC    R0,#+31
   \   00000A58   0100003A           BCC      ??inflate_90
   \   00000A5C   C00A9FE5           LDR      R0,??inflate_66+0xC  ;; `?<Constant "too many length or di...">`
   \   00000A60   DDFDFFEA           B        ??inflate_15
   \                     ??inflate_90:
   \   00000A64   0000A0E3           MOV      R0,#+0
   \   00000A68   680085E5           STR      R0,[R5, #+104]
   \   00000A6C   1000A0E3           MOV      R0,#+16
   \   00000A70   0000C5E5           STRB     R0,[R5, #+0]
   \   00000A74   110000EA           B        ??inflate_91
   \                     ??inflate_92:
   \   00000A78   000057E3           CMP      R7,#+0
   \   00000A7C   D6FEFF0A           BEQ      ??inflate_10
   \   00000A80   ........           LDRB     R1,[R6], #+1
   \   00000A84   017047E2           SUB      R7,R7,#+1
   \   00000A88   118988E0           ADD      R8,R8,R1, LSL R9
   \   00000A8C   089089E2           ADD      R9,R9,#+8
   \                     ??inflate_93:
   \   00000A90   030059E3           CMP      R9,#+3
   \   00000A94   F7FFFF3A           BCC      ??inflate_92
   \   00000A98   681095E5           LDR      R1,[R5, #+104]
   \   00000A9C   012081E2           ADD      R2,R1,#+1
   \   00000AA0   682085E5           STR      R2,[R5, #+104]
   \   00000AA4   810080E0           ADD      R0,R0,R1, LSL #+1
   \   00000AA8   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000AAC   071008E2           AND      R1,R8,#0x7
   \   00000AB0   A881A0E1           LSR      R8,R8,#+3
   \   00000AB4   800085E0           ADD      R0,R5,R0, LSL #+1
   \   00000AB8   B017C0E1           STRH     R1,[R0, #+112]
   \   00000ABC   039049E2           SUB      R9,R9,#+3
   \                     ??inflate_91:
   \   00000AC0   681095E5           LDR      R1,[R5, #+104]
   \   00000AC4   5C2095E5           LDR      R2,[R5, #+92]
   \   00000AC8   580A9FE5           LDR      R0,??inflate_66+0x10  ;; ??order
   \   00000ACC   020051E1           CMP      R1,R2
   \   00000AD0   EEFFFF3A           BCC      ??inflate_93
   \                     ??inflate_94:
   \   00000AD4   681095E5           LDR      R1,[R5, #+104]
   \   00000AD8   130051E3           CMP      R1,#+19
   \   00000ADC   0700002A           BCS      ??inflate_95
   \   00000AE0   012081E2           ADD      R2,R1,#+1
   \   00000AE4   682085E5           STR      R2,[R5, #+104]
   \   00000AE8   811080E0           ADD      R1,R0,R1, LSL #+1
   \   00000AEC   B010D1E1           LDRH     R1,[R1, #+0]
   \   00000AF0   0020A0E3           MOV      R2,#+0
   \   00000AF4   811085E0           ADD      R1,R5,R1, LSL #+1
   \   00000AF8   B027C1E1           STRH     R2,[R1, #+112]
   \   00000AFC   F4FFFFEA           B        ??inflate_94
   \                     ??inflate_95:
   \   00000B00   530E85E2           ADD      R0,R5,#+1328
   \   00000B04   6C0085E5           STR      R0,[R5, #+108]
   \   00000B08   4C0085E5           STR      R0,[R5, #+76]
   \   00000B0C   0700A0E3           MOV      R0,#+7
   \   00000B10   540085E5           STR      R0,[R5, #+84]
   \   00000B14   BC0F85E2           ADD      R0,R5,#+752
   \   00000B18   01002DE9           PUSH     {R0}
   \   00000B1C   6C3085E2           ADD      R3,R5,#+108
   \   00000B20   1320A0E3           MOV      R2,#+19
   \   00000B24   701085E2           ADD      R1,R5,#+112
   \   00000B28   540085E2           ADD      R0,R5,#+84
   \   00000B2C   01002DE9           PUSH     {R0}
   \   00000B30   0000A0E3           MOV      R0,#+0
   \   00000B34   ........           _BLF     inflate_table,??inflate_table??rA
   \   00000B38   18008DE5           STR      R0,[SP, #+24]
   \   00000B3C   000050E3           CMP      R0,#+0
   \   00000B40   08D08DE2           ADD      SP,SP,#+8
   \   00000B44   0100000A           BEQ      ??inflate_96
   \   00000B48   DC099FE5           LDR      R0,??inflate_66+0x14  ;; `?<Constant "invalid code lengths set">`
   \   00000B4C   B2FDFFEA           B        ??inflate_19
   \                     ??inflate_96:
   \   00000B50   0000A0E3           MOV      R0,#+0
   \   00000B54   680085E5           STR      R0,[R5, #+104]
   \   00000B58   1100A0E3           MOV      R0,#+17
   \   00000B5C   0000C5E5           STRB     R0,[R5, #+0]
   \   00000B60   060000EA           B        ??inflate_97
   \                     ??inflate_98:
   \   00000B64   3880A0E1           LSR      R8,R8,R0
   \   00000B68   680095E5           LDR      R0,[R5, #+104]
   \   00000B6C   029049E0           SUB      R9,R9,R2
   \   00000B70   012080E2           ADD      R2,R0,#+1
   \   00000B74   682085E5           STR      R2,[R5, #+104]
   \   00000B78   800085E0           ADD      R0,R5,R0, LSL #+1
   \   00000B7C   B017C0E1           STRH     R1,[R0, #+112]
   \                     ??inflate_97:
   \   00000B80   680095E5           LDR      R0,[R5, #+104]
   \   00000B84   601095E5           LDR      R1,[R5, #+96]
   \   00000B88   642095E5           LDR      R2,[R5, #+100]
   \   00000B8C   011082E0           ADD      R1,R2,R1
   \   00000B90   010050E1           CMP      R0,R1
   \   00000B94   1C00003A           BCC      ??inflate_99
   \                     ??inflate_100:
   \   00000B98   D000D5E1           LDRSB    R0,[R5, #+0]
   \   00000B9C   1B0050E3           CMP      R0,#+27
   \   00000BA0   49FDFF0A           BEQ      ??inflate_4
   \   00000BA4   530E85E2           ADD      R0,R5,#+1328
   \   00000BA8   6C0085E5           STR      R0,[R5, #+108]
   \   00000BAC   4C0085E5           STR      R0,[R5, #+76]
   \   00000BB0   0900A0E3           MOV      R0,#+9
   \   00000BB4   540085E5           STR      R0,[R5, #+84]
   \   00000BB8   BC0F85E2           ADD      R0,R5,#+752
   \   00000BBC   01002DE9           PUSH     {R0}
   \   00000BC0   6C3085E2           ADD      R3,R5,#+108
   \   00000BC4   701085E2           ADD      R1,R5,#+112
   \   00000BC8   540085E2           ADD      R0,R5,#+84
   \   00000BCC   01002DE9           PUSH     {R0}
   \   00000BD0   602095E5           LDR      R2,[R5, #+96]
   \   00000BD4   0100A0E3           MOV      R0,#+1
   \   00000BD8   ........           _BLF     inflate_table,??inflate_table??rA
   \   00000BDC   18008DE5           STR      R0,[SP, #+24]
   \   00000BE0   000050E3           CMP      R0,#+0
   \   00000BE4   08D08DE2           ADD      SP,SP,#+8
   \   00000BE8   6D00000A           BEQ      ??inflate_101
   \   00000BEC   3C099FE5           LDR      R0,??inflate_66+0x18  ;; `?<Constant "invalid literal/lengt...">`
   \   00000BF0   79FDFFEA           B        ??inflate_15
   \                     ??inflate_102:
   \   00000BF4   000057E3           CMP      R7,#+0
   \   00000BF8   77FEFF0A           BEQ      ??inflate_10
   \   00000BFC   ........           LDRB     R0,[R6], #+1
   \   00000C00   017047E2           SUB      R7,R7,#+1
   \   00000C04   108988E0           ADD      R8,R8,R0, LSL R9
   \   00000C08   089089E2           ADD      R9,R9,#+8
   \                     ??inflate_99:
   \   00000C0C   541095E5           LDR      R1,[R5, #+84]
   \   00000C10   542095E5           LDR      R2,[R5, #+84]
   \   00000C14   0100A0E3           MOV      R0,#+1
   \   00000C18   1001A0E1           LSL      R0,R0,R1
   \   00000C1C   4C1095E5           LDR      R1,[R5, #+76]
   \   00000C20   010040E2           SUB      R0,R0,#+1
   \   00000C24   080000E0           AND      R0,R0,R8
   \   00000C28   000181E0           ADD      R0,R1,R0, LSL #+2
   \   00000C2C   0100D0E5           LDRB     R0,[R0, #+1]
   \   00000C30   0110A0E3           MOV      R1,#+1
   \   00000C34   1112A0E1           LSL      R1,R1,R2
   \   00000C38   4C2095E5           LDR      R2,[R5, #+76]
   \   00000C3C   011041E2           SUB      R1,R1,#+1
   \   00000C40   081001E0           AND      R1,R1,R8
   \   00000C44   011182E0           ADD      R1,R2,R1, LSL #+2
   \   00000C48   B210D1E1           LDRH     R1,[R1, #+2]
   \   00000C4C   0020A0E1           MOV      R2,R0
   \   00000C50   020059E1           CMP      R9,R2
   \   00000C54   E6FFFF3A           BCC      ??inflate_102
   \   00000C58   100051E3           CMP      R1,#+16
   \   00000C5C   C0FFFF3A           BCC      ??inflate_98
   \   00000C60   0800000A           BEQ      ??inflate_103
   \   00000C64   110051E3           CMP      R1,#+17
   \   00000C68   3200001A           BNE      ??inflate_104
   \   00000C6C   200000EA           B        ??inflate_105
   \                     ??inflate_106:
   \   00000C70   000057E3           CMP      R7,#+0
   \   00000C74   58FEFF0A           BEQ      ??inflate_10
   \   00000C78   ........           LDRB     R1,[R6], #+1
   \   00000C7C   017047E2           SUB      R7,R7,#+1
   \   00000C80   118988E0           ADD      R8,R8,R1, LSL R9
   \   00000C84   089089E2           ADD      R9,R9,#+8
   \                     ??inflate_103:
   \   00000C88   021080E2           ADD      R1,R0,#+2
   \   00000C8C   010059E1           CMP      R9,R1
   \   00000C90   F6FFFF3A           BCC      ??inflate_106
   \   00000C94   3880A0E1           LSR      R8,R8,R0
   \   00000C98   680095E5           LDR      R0,[R5, #+104]
   \   00000C9C   029049E0           SUB      R9,R9,R2
   \   00000CA0   000050E3           CMP      R0,#+0
   \   00000CA4   0400001A           BNE      ??inflate_107
   \                     ??inflate_108:
   \   00000CA8   84089FE5           LDR      R0,??inflate_66+0x1C  ;; `?<Constant "invalid bit length re...">`
   \   00000CAC   180084E5           STR      R0,[R4, #+24]
   \   00000CB0   1B00A0E3           MOV      R0,#+27
   \   00000CB4   0000C5E5           STRB     R0,[R5, #+0]
   \   00000CB8   B6FFFFEA           B        ??inflate_100
   \                     ??inflate_107:
   \   00000CBC   010040E2           SUB      R0,R0,#+1
   \   00000CC0   800085E0           ADD      R0,R5,R0, LSL #+1
   \   00000CC4   B0B7D0E1           LDRH     R11,[R0, #+112]
   \   00000CC8   030008E2           AND      R0,R8,#0x3
   \   00000CCC   03A080E2           ADD      R10,R0,#+3
   \   00000CD0   2881A0E1           LSR      R8,R8,#+2
   \   00000CD4   029049E2           SUB      R9,R9,#+2
   \   00000CD8   200000EA           B        ??inflate_109
   \                     ??inflate_110:
   \   00000CDC   000057E3           CMP      R7,#+0
   \   00000CE0   3DFEFF0A           BEQ      ??inflate_10
   \   00000CE4   ........           LDRB     R1,[R6], #+1
   \   00000CE8   017047E2           SUB      R7,R7,#+1
   \   00000CEC   118988E0           ADD      R8,R8,R1, LSL R9
   \   00000CF0   089089E2           ADD      R9,R9,#+8
   \                     ??inflate_105:
   \   00000CF4   031080E2           ADD      R1,R0,#+3
   \   00000CF8   010059E1           CMP      R9,R1
   \   00000CFC   F6FFFF3A           BCC      ??inflate_110
   \   00000D00   3800A0E1           LSR      R0,R8,R0
   \   00000D04   021049E0           SUB      R1,R9,R2
   \   00000D08   00B0A0E3           MOV      R11,#+0
   \   00000D0C   072000E2           AND      R2,R0,#0x7
   \   00000D10   03A082E2           ADD      R10,R2,#+3
   \   00000D14   A081A0E1           LSR      R8,R0,#+3
   \   00000D18   039041E2           SUB      R9,R1,#+3
   \   00000D1C   0F0000EA           B        ??inflate_109
   \                     ??inflate_111:
   \   00000D20   000057E3           CMP      R7,#+0
   \   00000D24   2CFEFF0A           BEQ      ??inflate_10
   \   00000D28   ........           LDRB     R1,[R6], #+1
   \   00000D2C   017047E2           SUB      R7,R7,#+1
   \   00000D30   118988E0           ADD      R8,R8,R1, LSL R9
   \   00000D34   089089E2           ADD      R9,R9,#+8
   \                     ??inflate_104:
   \   00000D38   071080E2           ADD      R1,R0,#+7
   \   00000D3C   010059E1           CMP      R9,R1
   \   00000D40   F6FFFF3A           BCC      ??inflate_111
   \   00000D44   3800A0E1           LSR      R0,R8,R0
   \   00000D48   021049E0           SUB      R1,R9,R2
   \   00000D4C   00B0A0E3           MOV      R11,#+0
   \   00000D50   7F2000E2           AND      R2,R0,#0x7F
   \   00000D54   0BA082E2           ADD      R10,R2,#+11
   \   00000D58   A083A0E1           LSR      R8,R0,#+7
   \   00000D5C   079041E2           SUB      R9,R1,#+7
   \                     ??inflate_109:
   \   00000D60   600095E5           LDR      R0,[R5, #+96]
   \   00000D64   641095E5           LDR      R1,[R5, #+100]
   \   00000D68   000081E0           ADD      R0,R1,R0
   \   00000D6C   681095E5           LDR      R1,[R5, #+104]
   \   00000D70   01108AE0           ADD      R1,R10,R1
   \   00000D74   010050E1           CMP      R0,R1
   \   00000D78   CAFFFF3A           BCC      ??inflate_108
   \                     ??inflate_112:
   \   00000D7C   0A00A0E1           MOV      R0,R10
   \   00000D80   01A040E2           SUB      R10,R0,#+1
   \   00000D84   000050E3           CMP      R0,#+0
   \   00000D88   7CFFFF0A           BEQ      ??inflate_97
   \   00000D8C   680095E5           LDR      R0,[R5, #+104]
   \   00000D90   011080E2           ADD      R1,R0,#+1
   \   00000D94   681085E5           STR      R1,[R5, #+104]
   \   00000D98   800085E0           ADD      R0,R5,R0, LSL #+1
   \   00000D9C   B0B7C0E1           STRH     R11,[R0, #+112]
   \   00000DA0   F5FFFFEA           B        ??inflate_112
   \                     ??inflate_101:
   \   00000DA4   6C0095E5           LDR      R0,[R5, #+108]
   \   00000DA8   6C3085E2           ADD      R3,R5,#+108
   \   00000DAC   500085E5           STR      R0,[R5, #+80]
   \   00000DB0   0600A0E3           MOV      R0,#+6
   \   00000DB4   580085E5           STR      R0,[R5, #+88]
   \   00000DB8   BC0F85E2           ADD      R0,R5,#+752
   \   00000DBC   01002DE9           PUSH     {R0}
   \   00000DC0   580085E2           ADD      R0,R5,#+88
   \   00000DC4   01002DE9           PUSH     {R0}
   \   00000DC8   642095E5           LDR      R2,[R5, #+100]
   \   00000DCC   600095E5           LDR      R0,[R5, #+96]
   \   00000DD0   800085E0           ADD      R0,R5,R0, LSL #+1
   \   00000DD4   701080E2           ADD      R1,R0,#+112
   \   00000DD8   0200A0E3           MOV      R0,#+2
   \   00000DDC   ........           _BLF     inflate_table,??inflate_table??rA
   \   00000DE0   18008DE5           STR      R0,[SP, #+24]
   \   00000DE4   000050E3           CMP      R0,#+0
   \   00000DE8   08D08DE2           ADD      SP,SP,#+8
   \   00000DEC   0300000A           BEQ      ??inflate_113
   \   00000DF0   40079FE5           LDR      R0,??inflate_66+0x20  ;; `?<Constant "invalid distances set">`
   \   00000DF4   180084E5           STR      R0,[R4, #+24]
   \   00000DF8   1B00A0E3           MOV      R0,#+27
   \   00000DFC   B1FCFFEA           B        ??inflate_6
   \                     ??inflate_113:
   \   00000E00   1200A0E3           MOV      R0,#+18
   \   00000E04   0000C5E5           STRB     R0,[R5, #+0]
   \                     ??inflate_114:
   \   00000E08   060057E3           CMP      R7,#+6
   \   00000E0C   1E00003A           BCC      ??inflate_115
   \   00000E10   00009DE5           LDR      R0,[SP, #+0]
   \   00000E14   0210A0E3           MOV      R1,#+2
   \   00000E18   401F81E3           ORR      R1,R1,#0x100
   \   00000E1C   010050E1           CMP      R0,R1
   \   00000E20   1900003A           BCC      ??inflate_115
   \   00000E24   0C009DE5           LDR      R0,[SP, #+12]
   \   00000E28   0C0084E5           STR      R0,[R4, #+12]
   \   00000E2C   00009DE5           LDR      R0,[SP, #+0]
   \   00000E30   100084E5           STR      R0,[R4, #+16]
   \   00000E34   006084E5           STR      R6,[R4, #+0]
   \   00000E38   047084E5           STR      R7,[R4, #+4]
   \   00000E3C   388085E5           STR      R8,[R5, #+56]
   \   00000E40   3C9085E5           STR      R9,[R5, #+60]
   \   00000E44   08109DE5           LDR      R1,[SP, #+8]
   \   00000E48   0400A0E1           MOV      R0,R4
   \   00000E4C   ........           _BLF     inflate_fast,??inflate_fast??rA
   \   00000E50   0C1094E5           LDR      R1,[R4, #+12]
   \   00000E54   0C108DE5           STR      R1,[SP, #+12]
   \   00000E58   101094E5           LDR      R1,[R4, #+16]
   \   00000E5C   00108DE5           STR      R1,[SP, #+0]
   \   00000E60   006094E5           LDR      R6,[R4, #+0]
   \   00000E64   047094E5           LDR      R7,[R4, #+4]
   \   00000E68   388095E5           LDR      R8,[R5, #+56]
   \   00000E6C   3C9095E5           LDR      R9,[R5, #+60]
   \   00000E70   95FCFFEA           B        ??inflate_4
   \                     ??inflate_116:
   \   00000E74   000057E3           CMP      R7,#+0
   \   00000E78   D7FDFF0A           BEQ      ??inflate_10
   \   00000E7C   ........           LDRB     R0,[R6], #+1
   \   00000E80   017047E2           SUB      R7,R7,#+1
   \   00000E84   108988E0           ADD      R8,R8,R0, LSL R9
   \   00000E88   089089E2           ADD      R9,R9,#+8
   \                     ??inflate_115:
   \   00000E8C   541095E5           LDR      R1,[R5, #+84]
   \   00000E90   542095E5           LDR      R2,[R5, #+84]
   \   00000E94   0100A0E3           MOV      R0,#+1
   \   00000E98   1001A0E1           LSL      R0,R0,R1
   \   00000E9C   4C1095E5           LDR      R1,[R5, #+76]
   \   00000EA0   010040E2           SUB      R0,R0,#+1
   \   00000EA4   080000E0           AND      R0,R0,R8
   \   00000EA8   00C1D1E7           LDRB     R12,[R1, +R0, LSL #+2]
   \   00000EAC   541095E5           LDR      R1,[R5, #+84]
   \   00000EB0   0100A0E3           MOV      R0,#+1
   \   00000EB4   1001A0E1           LSL      R0,R0,R1
   \   00000EB8   4C1095E5           LDR      R1,[R5, #+76]
   \   00000EBC   010040E2           SUB      R0,R0,#+1
   \   00000EC0   080000E0           AND      R0,R0,R8
   \   00000EC4   000181E0           ADD      R0,R1,R0, LSL #+2
   \   00000EC8   0100D0E5           LDRB     R0,[R0, #+1]
   \   00000ECC   0110A0E3           MOV      R1,#+1
   \   00000ED0   1112A0E1           LSL      R1,R1,R2
   \   00000ED4   4C2095E5           LDR      R2,[R5, #+76]
   \   00000ED8   011041E2           SUB      R1,R1,#+1
   \   00000EDC   081001E0           AND      R1,R1,R8
   \   00000EE0   011182E0           ADD      R1,R2,R1, LSL #+2
   \   00000EE4   B210D1E1           LDRH     R1,[R1, #+2]
   \   00000EE8   00A0A0E1           MOV      R10,R0
   \   00000EEC   0A0059E1           CMP      R9,R10
   \   00000EF0   DFFFFF3A           BCC      ??inflate_116
   \   00000EF4   00005CE3           CMP      R12,#+0
   \   00000EF8   1E00000A           BEQ      ??inflate_117
   \   00000EFC   F0001CE3           TST      R12,#0xF0
   \   00000F00   1C00001A           BNE      ??inflate_117
   \   00000F04   18C0CDE5           STRB     R12,[SP, #+24]
   \   00000F08   0020A0E1           MOV      R2,R0
   \   00000F0C   0130A0E1           MOV      R3,R1
   \   00000F10   050000EA           B        ??inflate_118
   \                     ??inflate_119:
   \   00000F14   000057E3           CMP      R7,#+0
   \   00000F18   AFFDFF0A           BEQ      ??inflate_10
   \   00000F1C   ........           LDRB     R0,[R6], #+1
   \   00000F20   017047E2           SUB      R7,R7,#+1
   \   00000F24   108988E0           ADD      R8,R8,R0, LSL R9
   \   00000F28   089089E2           ADD      R9,R9,#+8
   \                     ??inflate_118:
   \   00000F2C   18B0DDE5           LDRB     R11,[SP, #+24]
   \   00000F30   4C0095E5           LDR      R0,[R5, #+76]
   \   00000F34   0110A0E3           MOV      R1,#+1
   \   00000F38   02B08BE0           ADD      R11,R11,R2
   \   00000F3C   111BA0E1           LSL      R1,R1,R11
   \   00000F40   4CB095E5           LDR      R11,[R5, #+76]
   \   00000F44   011041E2           SUB      R1,R1,#+1
   \   00000F48   081001E0           AND      R1,R1,R8
   \   00000F4C   311283E0           ADD      R1,R3,R1, LSR R2
   \   00000F50   01C1D0E7           LDRB     R12,[R0, +R1, LSL #+2]
   \   00000F54   010180E0           ADD      R0,R0,R1, LSL #+2
   \   00000F58   0100D0E5           LDRB     R0,[R0, #+1]
   \   00000F5C   01118BE0           ADD      R1,R11,R1, LSL #+2
   \   00000F60   B210D1E1           LDRH     R1,[R1, #+2]
   \   00000F64   02B080E0           ADD      R11,R0,R2
   \   00000F68   0B0059E1           CMP      R9,R11
   \   00000F6C   E8FFFF3A           BCC      ??inflate_119
   \   00000F70   3882A0E1           LSR      R8,R8,R2
   \   00000F74   0A9049E0           SUB      R9,R9,R10
   \                     ??inflate_117:
   \   00000F78   3880A0E1           LSR      R8,R8,R0
   \   00000F7C   009049E0           SUB      R9,R9,R0
   \   00000F80   401085E5           STR      R1,[R5, #+64]
   \   00000F84   00005CE3           CMP      R12,#+0
   \   00000F88   1700A003           MOVEQ    R0,#+23
   \   00000F8C   4DFCFF0A           BEQ      ??inflate_6
   \   00000F90   20001CE3           TST      R12,#0x20
   \   00000F94   05FEFF1A           BNE      ??inflate_68
   \   00000F98   40001CE3           TST      R12,#0x40
   \   00000F9C   0100000A           BEQ      ??inflate_120
   \   00000FA0   94059FE5           LDR      R0,??inflate_66+0x24  ;; `?<Constant "invalid literal/lengt...">_1`
   \   00000FA4   8CFCFFEA           B        ??inflate_15
   \                     ??inflate_120:
   \   00000FA8   0F000CE2           AND      R0,R12,#0xF
   \   00000FAC   480085E5           STR      R0,[R5, #+72]
   \   00000FB0   1300A0E3           MOV      R0,#+19
   \   00000FB4   0000C5E5           STRB     R0,[R5, #+0]
   \                     ??inflate_121:
   \   00000FB8   480095E5           LDR      R0,[R5, #+72]
   \   00000FBC   000050E3           CMP      R0,#+0
   \   00000FC0   0600001A           BNE      ??inflate_122
   \   00000FC4   120000EA           B        ??inflate_123
   \                     ??inflate_124:
   \   00000FC8   000057E3           CMP      R7,#+0
   \   00000FCC   82FDFF0A           BEQ      ??inflate_10
   \   00000FD0   ........           LDRB     R0,[R6], #+1
   \   00000FD4   017047E2           SUB      R7,R7,#+1
   \   00000FD8   108988E0           ADD      R8,R8,R0, LSL R9
   \   00000FDC   089089E2           ADD      R9,R9,#+8
   \                     ??inflate_122:
   \   00000FE0   480095E5           LDR      R0,[R5, #+72]
   \   00000FE4   000059E1           CMP      R9,R0
   \   00000FE8   F6FFFF3A           BCC      ??inflate_124
   \   00000FEC   400095E5           LDR      R0,[R5, #+64]
   \   00000FF0   482095E5           LDR      R2,[R5, #+72]
   \   00000FF4   0110A0E3           MOV      R1,#+1
   \   00000FF8   1112A0E1           LSL      R1,R1,R2
   \   00000FFC   011041E2           SUB      R1,R1,#+1
   \   00001000   081001E0           AND      R1,R1,R8
   \   00001004   000081E0           ADD      R0,R1,R0
   \   00001008   400085E5           STR      R0,[R5, #+64]
   \   0000100C   3882A0E1           LSR      R8,R8,R2
   \   00001010   029049E0           SUB      R9,R9,R2
   \                     ??inflate_123:
   \   00001014   1400A0E3           MOV      R0,#+20
   \   00001018   0000C5E5           STRB     R0,[R5, #+0]
   \   0000101C   050000EA           B        ??inflate_125
   \                     ??inflate_126:
   \   00001020   000057E3           CMP      R7,#+0
   \   00001024   6CFDFF0A           BEQ      ??inflate_10
   \   00001028   ........           LDRB     R0,[R6], #+1
   \   0000102C   017047E2           SUB      R7,R7,#+1
   \   00001030   108988E0           ADD      R8,R8,R0, LSL R9
   \   00001034   089089E2           ADD      R9,R9,#+8
   \                     ??inflate_125:
   \   00001038   581095E5           LDR      R1,[R5, #+88]
   \   0000103C   582095E5           LDR      R2,[R5, #+88]
   \   00001040   0100A0E3           MOV      R0,#+1
   \   00001044   1001A0E1           LSL      R0,R0,R1
   \   00001048   501095E5           LDR      R1,[R5, #+80]
   \   0000104C   010040E2           SUB      R0,R0,#+1
   \   00001050   080000E0           AND      R0,R0,R8
   \   00001054   00C1D1E7           LDRB     R12,[R1, +R0, LSL #+2]
   \   00001058   581095E5           LDR      R1,[R5, #+88]
   \   0000105C   0100A0E3           MOV      R0,#+1
   \   00001060   1001A0E1           LSL      R0,R0,R1
   \   00001064   501095E5           LDR      R1,[R5, #+80]
   \   00001068   010040E2           SUB      R0,R0,#+1
   \   0000106C   080000E0           AND      R0,R0,R8
   \   00001070   000181E0           ADD      R0,R1,R0, LSL #+2
   \   00001074   0100D0E5           LDRB     R0,[R0, #+1]
   \   00001078   0110A0E3           MOV      R1,#+1
   \   0000107C   1112A0E1           LSL      R1,R1,R2
   \   00001080   502095E5           LDR      R2,[R5, #+80]
   \   00001084   011041E2           SUB      R1,R1,#+1
   \   00001088   081001E0           AND      R1,R1,R8
   \   0000108C   011182E0           ADD      R1,R2,R1, LSL #+2
   \   00001090   B210D1E1           LDRH     R1,[R1, #+2]
   \   00001094   00A0A0E1           MOV      R10,R0
   \   00001098   0A0059E1           CMP      R9,R10
   \   0000109C   DFFFFF3A           BCC      ??inflate_126
   \   000010A0   F0001CE3           TST      R12,#0xF0
   \   000010A4   1C00001A           BNE      ??inflate_127
   \   000010A8   18C0CDE5           STRB     R12,[SP, #+24]
   \   000010AC   0020A0E1           MOV      R2,R0
   \   000010B0   0130A0E1           MOV      R3,R1
   \   000010B4   050000EA           B        ??inflate_128
   \                     ??inflate_129:
   \   000010B8   000057E3           CMP      R7,#+0
   \   000010BC   46FDFF0A           BEQ      ??inflate_10
   \   000010C0   ........           LDRB     R0,[R6], #+1
   \   000010C4   017047E2           SUB      R7,R7,#+1
   \   000010C8   108988E0           ADD      R8,R8,R0, LSL R9
   \   000010CC   089089E2           ADD      R9,R9,#+8
   \                     ??inflate_128:
   \   000010D0   18B0DDE5           LDRB     R11,[SP, #+24]
   \   000010D4   500095E5           LDR      R0,[R5, #+80]
   \   000010D8   0110A0E3           MOV      R1,#+1
   \   000010DC   02B08BE0           ADD      R11,R11,R2
   \   000010E0   111BA0E1           LSL      R1,R1,R11
   \   000010E4   50B095E5           LDR      R11,[R5, #+80]
   \   000010E8   011041E2           SUB      R1,R1,#+1
   \   000010EC   081001E0           AND      R1,R1,R8
   \   000010F0   311283E0           ADD      R1,R3,R1, LSR R2
   \   000010F4   01C1D0E7           LDRB     R12,[R0, +R1, LSL #+2]
   \   000010F8   010180E0           ADD      R0,R0,R1, LSL #+2
   \   000010FC   0100D0E5           LDRB     R0,[R0, #+1]
   \   00001100   01118BE0           ADD      R1,R11,R1, LSL #+2
   \   00001104   B210D1E1           LDRH     R1,[R1, #+2]
   \   00001108   02B080E0           ADD      R11,R0,R2
   \   0000110C   0B0059E1           CMP      R9,R11
   \   00001110   E8FFFF3A           BCC      ??inflate_129
   \   00001114   3882A0E1           LSR      R8,R8,R2
   \   00001118   0A9049E0           SUB      R9,R9,R10
   \                     ??inflate_127:
   \   0000111C   3880A0E1           LSR      R8,R8,R0
   \   00001120   009049E0           SUB      R9,R9,R0
   \   00001124   40001CE3           TST      R12,#0x40
   \   00001128   0600000A           BEQ      ??inflate_130
   \   0000112C   0C049FE5           LDR      R0,??inflate_66+0x28  ;; `?<Constant "invalid distance code">`
   \   00001130   39FCFFEA           B        ??inflate_19
   \                     ??inflate_13:
   \   00001134   85104208           DC32     0x8421085
   \   00001138   ........           DC32     `?<Constant "incorrect header check">`
   \   0000113C   ........           DC32     `?<Constant "unknown compression m...">`
   \   00001140   ........           DC32     `?<Constant "invalid window size">`
   \   00001144   ........           DC32     `?<Constant "unknown header flags set">`
   \                     ??inflate_130:
   \   00001148   441085E5           STR      R1,[R5, #+68]
   \   0000114C   0F000CE2           AND      R0,R12,#0xF
   \   00001150   480085E5           STR      R0,[R5, #+72]
   \   00001154   1500A0E3           MOV      R0,#+21
   \   00001158   0000C5E5           STRB     R0,[R5, #+0]
   \                     ??inflate_131:
   \   0000115C   480095E5           LDR      R0,[R5, #+72]
   \   00001160   000050E3           CMP      R0,#+0
   \   00001164   0600001A           BNE      ??inflate_132
   \   00001168   120000EA           B        ??inflate_133
   \                     ??inflate_134:
   \   0000116C   000057E3           CMP      R7,#+0
   \   00001170   19FDFF0A           BEQ      ??inflate_10
   \   00001174   ........           LDRB     R0,[R6], #+1
   \   00001178   017047E2           SUB      R7,R7,#+1
   \   0000117C   108988E0           ADD      R8,R8,R0, LSL R9
   \   00001180   089089E2           ADD      R9,R9,#+8
   \                     ??inflate_132:
   \   00001184   480095E5           LDR      R0,[R5, #+72]
   \   00001188   000059E1           CMP      R9,R0
   \   0000118C   F6FFFF3A           BCC      ??inflate_134
   \   00001190   440095E5           LDR      R0,[R5, #+68]
   \   00001194   482095E5           LDR      R2,[R5, #+72]
   \   00001198   0110A0E3           MOV      R1,#+1
   \   0000119C   1112A0E1           LSL      R1,R1,R2
   \   000011A0   011041E2           SUB      R1,R1,#+1
   \   000011A4   081001E0           AND      R1,R1,R8
   \   000011A8   000081E0           ADD      R0,R1,R0
   \   000011AC   440085E5           STR      R0,[R5, #+68]
   \   000011B0   3882A0E1           LSR      R8,R8,R2
   \   000011B4   029049E0           SUB      R9,R9,R2
   \                     ??inflate_133:
   \   000011B8   2C0095E5           LDR      R0,[R5, #+44]
   \   000011BC   08109DE5           LDR      R1,[SP, #+8]
   \   000011C0   000081E0           ADD      R0,R1,R0
   \   000011C4   00109DE5           LDR      R1,[SP, #+0]
   \   000011C8   010040E0           SUB      R0,R0,R1
   \   000011CC   441095E5           LDR      R1,[R5, #+68]
   \   000011D0   010050E1           CMP      R0,R1
   \   000011D4   0100002A           BCS      ??inflate_135
   \   000011D8   64039FE5           LDR      R0,??inflate_66+0x2C  ;; `?<Constant "invalid distance too ...">`
   \   000011DC   FEFBFFEA           B        ??inflate_15
   \                     ??inflate_135:
   \   000011E0   1600A0E3           MOV      R0,#+22
   \   000011E4   0000C5E5           STRB     R0,[R5, #+0]
   \                     ??inflate_136:
   \   000011E8   00009DE5           LDR      R0,[SP, #+0]
   \   000011EC   000050E3           CMP      R0,#+0
   \   000011F0   F9FCFF0A           BEQ      ??inflate_10
   \   000011F4   1C009DE5           LDR      R0,[SP, #+28]
   \   000011F8   441095E5           LDR      R1,[R5, #+68]
   \   000011FC   010050E1           CMP      R0,R1
   \   00001200   0C00002A           BCS      ??inflate_137
   \   00001204   00A041E0           SUB      R10,R1,R0
   \   00001208   300095E5           LDR      R0,[R5, #+48]
   \   0000120C   341095E5           LDR      R1,[R5, #+52]
   \   00001210   0A0050E1           CMP      R0,R10
   \   00001214   00A04A30           SUBCC    R10,R10,R0
   \   00001218   28009535           LDRCC    R0,[R5, #+40]
   \   0000121C   0A0040E0           SUB      R0,R0,R10
   \   00001220   010080E0           ADD      R0,R0,R1
   \   00001224   401095E5           LDR      R1,[R5, #+64]
   \   00001228   0A0051E1           CMP      R1,R10
   \   0000122C   0600002A           BCS      ??inflate_138
   \   00001230   01A0A0E1           MOV      R10,R1
   \   00001234   040000EA           B        ??inflate_138
   \                     ??inflate_137:
   \   00001238   40A095E5           LDR      R10,[R5, #+64]
   \   0000123C   0100A0E1           MOV      R0,R1
   \   00001240   0C109DE5           LDR      R1,[SP, #+12]
   \   00001244   000060E2           RSB      R0,R0,#+0
   \   00001248   010080E0           ADD      R0,R0,R1
   \                     ??inflate_138:
   \   0000124C   00109DE5           LDR      R1,[SP, #+0]
   \   00001250   0A0051E1           CMP      R1,R10
   \   00001254   01A0A031           MOVCC    R10,R1
   \   00001258   0A2041E0           SUB      R2,R1,R10
   \   0000125C   00208DE5           STR      R2,[SP, #+0]
   \   00001260   401095E5           LDR      R1,[R5, #+64]
   \   00001264   0A1041E0           SUB      R1,R1,R10
   \   00001268   401085E5           STR      R1,[R5, #+64]
   \                     ??inflate_139:
   \   0000126C   ........           LDRB     R2,[R0], #+1
   \   00001270   0C309DE5           LDR      R3,[SP, #+12]
   \   00001274   01A05AE2           SUBS     R10,R10,#+1
   \   00001278   ........           STRB     R2,[R3], #+1
   \   0000127C   0C308DE5           STR      R3,[SP, #+12]
   \   00001280   F9FFFF1A           BNE      ??inflate_139
   \   00001284   400095E5           LDR      R0,[R5, #+64]
   \   00001288   000050E3           CMP      R0,#+0
   \   0000128C   8EFBFF1A           BNE      ??inflate_4
   \   00001290   1200A0E3           MOV      R0,#+18
   \   00001294   8BFBFFEA           B        ??inflate_6
   \                     ??inflate_140:
   \   00001298   000052E3           CMP      R2,#+0
   \   0000129C   CEFCFF0A           BEQ      ??inflate_10
   \   000012A0   401095E5           LDR      R1,[R5, #+64]
   \   000012A4   0C209DE5           LDR      R2,[SP, #+12]
   \   000012A8   1200A0E3           MOV      R0,#+18
   \   000012AC   ........           STRB     R1,[R2], #+1
   \   000012B0   0C208DE5           STR      R2,[SP, #+12]
   \   000012B4   00109DE5           LDR      R1,[SP, #+0]
   \   000012B8   011041E2           SUB      R1,R1,#+1
   \   000012BC   00108DE5           STR      R1,[SP, #+0]
   \   000012C0   80FBFFEA           B        ??inflate_6
   \                     ??inflate_141:
   \   000012C4   080095E5           LDR      R0,[R5, #+8]
   \   000012C8   000050E3           CMP      R0,#+0
   \   000012CC   0600001A           BNE      ??inflate_142
   \   000012D0   300000EA           B        ??inflate_143
   \                     ??inflate_144:
   \   000012D4   000057E3           CMP      R7,#+0
   \   000012D8   BFFCFF0A           BEQ      ??inflate_10
   \   000012DC   ........           LDRB     R0,[R6], #+1
   \   000012E0   017047E2           SUB      R7,R7,#+1
   \   000012E4   108988E0           ADD      R8,R8,R0, LSL R9
   \   000012E8   089089E2           ADD      R9,R9,#+8
   \                     ??inflate_142:
   \   000012EC   200059E3           CMP      R9,#+32
   \   000012F0   F7FFFF3A           BCC      ??inflate_144
   \   000012F4   1C209DE5           LDR      R2,[SP, #+28]
   \   000012F8   140094E5           LDR      R0,[R4, #+20]
   \   000012FC   000052E3           CMP      R2,#+0
   \   00001300   000082E0           ADD      R0,R2,R0
   \   00001304   140084E5           STR      R0,[R4, #+20]
   \   00001308   1C0095E5           LDR      R0,[R5, #+28]
   \   0000130C   000082E0           ADD      R0,R2,R0
   \   00001310   1C0085E5           STR      R0,[R5, #+28]
   \   00001314   0C00000A           BEQ      ??inflate_145
   \   00001318   0C109DE5           LDR      R1,[SP, #+12]
   \   0000131C   0200A0E1           MOV      R0,R2
   \   00001320   000060E2           RSB      R0,R0,#+0
   \   00001324   011080E0           ADD      R1,R0,R1
   \   00001328   100095E5           LDR      R0,[R5, #+16]
   \   0000132C   000050E3           CMP      R0,#+0
   \   00001330   180095E5           LDR      R0,[R5, #+24]
   \   00001334   0100000A           BEQ      ??inflate_146
   \   00001338   ........           _BLF     crc32,??crc32??rA
   \   0000133C   000000EA           B        ??inflate_147
   \                     ??inflate_146:
   \   00001340   ........           _BLF     adler32,??adler32??rA
   \                     ??inflate_147:
   \   00001344   180085E5           STR      R0,[R5, #+24]
   \   00001348   300084E5           STR      R0,[R4, #+48]
   \                     ??inflate_145:
   \   0000134C   00109DE5           LDR      R1,[SP, #+0]
   \   00001350   08108DE5           STR      R1,[SP, #+8]
   \   00001354   100095E5           LDR      R0,[R5, #+16]
   \   00001358   000050E3           CMP      R0,#+0
   \   0000135C   0800A011           MOVNE    R0,R8
   \   00001360   0500001A           BNE      ??inflate_148
   \   00001364   FF0CA0E3           MOV      R0,#+65280
   \   00001368   280400E0           AND      R0,R0,R8, LSR #+8
   \   0000136C   280C80E0           ADD      R0,R0,R8, LSR #+24
   \   00001370   FF1C08E2           AND      R1,R8,#0xFF00
   \   00001374   010480E0           ADD      R0,R0,R1, LSL #+8
   \   00001378   080C80E0           ADD      R0,R0,R8, LSL #+24
   \                     ??inflate_148:
   \   0000137C   181095E5           LDR      R1,[R5, #+24]
   \   00001380   010050E1           CMP      R0,R1
   \   00001384   0100000A           BEQ      ??inflate_149
   \   00001388   B8019FE5           LDR      R0,??inflate_66+0x30  ;; `?<Constant "incorrect data check">`
   \   0000138C   92FBFFEA           B        ??inflate_15
   \                     ??inflate_149:
   \   00001390   0080A0E3           MOV      R8,#+0
   \   00001394   0090A0E3           MOV      R9,#+0
   \                     ??inflate_143:
   \   00001398   1900A0E3           MOV      R0,#+25
   \   0000139C   0000C5E5           STRB     R0,[R5, #+0]
   \                     ??inflate_150:
   \   000013A0   080095E5           LDR      R0,[R5, #+8]
   \   000013A4   000050E3           CMP      R0,#+0
   \   000013A8   1200000A           BEQ      ??inflate_151
   \   000013AC   100095E5           LDR      R0,[R5, #+16]
   \   000013B0   000050E3           CMP      R0,#+0
   \   000013B4   0600001A           BNE      ??inflate_152
   \   000013B8   0E0000EA           B        ??inflate_151
   \                     ??inflate_153:
   \   000013BC   000057E3           CMP      R7,#+0
   \   000013C0   85FCFF0A           BEQ      ??inflate_10
   \   000013C4   ........           LDRB     R0,[R6], #+1
   \   000013C8   017047E2           SUB      R7,R7,#+1
   \   000013CC   108988E0           ADD      R8,R8,R0, LSL R9
   \   000013D0   089089E2           ADD      R9,R9,#+8
   \                     ??inflate_152:
   \   000013D4   200059E3           CMP      R9,#+32
   \   000013D8   F7FFFF3A           BCC      ??inflate_153
   \   000013DC   1C0095E5           LDR      R0,[R5, #+28]
   \   000013E0   000058E1           CMP      R8,R0
   \   000013E4   0100000A           BEQ      ??inflate_154
   \   000013E8   5C019FE5           LDR      R0,??inflate_66+0x34  ;; `?<Constant "incorrect length check">`
   \   000013EC   8AFBFFEA           B        ??inflate_19
   \                     ??inflate_154:
   \   000013F0   0080A0E3           MOV      R8,#+0
   \   000013F4   0090A0E3           MOV      R9,#+0
   \                     ??inflate_151:
   \   000013F8   1A00A0E3           MOV      R0,#+26
   \   000013FC   0000C5E5           STRB     R0,[R5, #+0]
   \                     ??inflate_155:
   \   00001400   0110A0E3           MOV      R1,#+1
   \                     ??inflate_156:
   \   00001404   10108DE5           STR      R1,[SP, #+16]
   \   00001408   73FCFFEA           B        ??inflate_10
   \                     ??inflate_157:
   \   0000140C   0210E0E3           MVN      R1,#+2
   \   00001410   FBFFFFEA           B        ??inflate_156
   \                     ??inflate_52:
   \   00001414   0300E0E3           MVN      R0,#+3
   \                     ??inflate_3:
   \   00001418   24D08DE2           ADD      SP,SP,#+36
   \   0000141C   F08FBDE8           POP      {R4-R11,PC}
   1143              in -= strm->avail_in;
   \                     ??inflate_51:
   \   00001420   14109DE5           LDR      R1,[SP, #+20]
   \   00001424   042094E5           LDR      R2,[R4, #+4]
   \   00001428   021041E0           SUB      R1,R1,R2
   \   0000142C   14108DE5           STR      R1,[SP, #+20]
   1144              out -= strm->avail_out;
   \   00001430   08109DE5           LDR      R1,[SP, #+8]
   \   00001434   102094E5           LDR      R2,[R4, #+16]
   \   00001438   021041E0           SUB      R1,R1,R2
   \   0000143C   08108DE5           STR      R1,[SP, #+8]
   1145              strm->total_in += in;
   \   00001440   080094E5           LDR      R0,[R4, #+8]
   \   00001444   14109DE5           LDR      R1,[SP, #+20]
   \   00001448   000081E0           ADD      R0,R1,R0
   \   0000144C   080084E5           STR      R0,[R4, #+8]
   1146              strm->total_out += out;
   \   00001450   140094E5           LDR      R0,[R4, #+20]
   \   00001454   08109DE5           LDR      R1,[SP, #+8]
   \   00001458   000081E0           ADD      R0,R1,R0
   \   0000145C   140084E5           STR      R0,[R4, #+20]
   1147              state->total += out;
   \   00001460   1C0095E5           LDR      R0,[R5, #+28]
   \   00001464   08109DE5           LDR      R1,[SP, #+8]
   \   00001468   000081E0           ADD      R0,R1,R0
   \   0000146C   1C0085E5           STR      R0,[R5, #+28]
   1148              if (state->wrap && out)
   \   00001470   080095E5           LDR      R0,[R5, #+8]
   \   00001474   000050E3           CMP      R0,#+0
   \   00001478   08009D15           LDRNE    R0,[SP, #+8]
   \   0000147C   00005013           CMPNE    R0,#+0
   \   00001480   0C00000A           BEQ      ??inflate_158
   1149                  strm->adler = state->check =
   1150                      UPDATE(state->check, strm->next_out - out, out);
   \   00001484   0C1094E5           LDR      R1,[R4, #+12]
   \   00001488   08209DE5           LDR      R2,[SP, #+8]
   \   0000148C   000060E2           RSB      R0,R0,#+0
   \   00001490   011080E0           ADD      R1,R0,R1
   \   00001494   100095E5           LDR      R0,[R5, #+16]
   \   00001498   000050E3           CMP      R0,#+0
   \   0000149C   180095E5           LDR      R0,[R5, #+24]
   \   000014A0   0100000A           BEQ      ??inflate_159
   \   000014A4   ........           _BLF     crc32,??crc32??rA
   \   000014A8   000000EA           B        ??inflate_160
   \                     ??inflate_159:
   \   000014AC   ........           _BLF     adler32,??adler32??rA
   \                     ??inflate_160:
   \   000014B0   180085E5           STR      R0,[R5, #+24]
   \   000014B4   300084E5           STR      R0,[R4, #+48]
   1151              strm->data_type = state->bits + (state->last ? 64 : 0) +
   1152                                (state->mode == TYPE ? 128 : 0);
   \                     ??inflate_158:
   \   000014B8   D010D5E1           LDRSB    R1,[R5, #+0]
   \   000014BC   040095E5           LDR      R0,[R5, #+4]
   \   000014C0   3C2095E5           LDR      R2,[R5, #+60]
   \   000014C4   000050E3           CMP      R0,#+0
   \   000014C8   4000A013           MOVNE    R0,#+64
   \   000014CC   0B0051E3           CMP      R1,#+11
   \   000014D0   8010A003           MOVEQ    R1,#+128
   \   000014D4   0010A013           MOVNE    R1,#+0
   \   000014D8   020080E0           ADD      R0,R0,R2
   \   000014DC   000081E0           ADD      R0,R1,R0
   \   000014E0   2C0084E5           STR      R0,[R4, #+44]
   1153              if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
   \   000014E4   14009DE5           LDR      R0,[SP, #+20]
   \   000014E8   000050E3           CMP      R0,#+0
   \   000014EC   08009D05           LDREQ    R0,[SP, #+8]
   \   000014F0   00005003           CMPEQ    R0,#+0
   \   000014F4   20009D15           LDRNE    R0,[SP, #+32]
   \   000014F8   04005013           CMPNE    R0,#+4
   \   000014FC   10009D05           LDREQ    R0,[SP, #+16]
   \   00001500   00005003           CMPEQ    R0,#+0
   1154                  ret = Z_BUF_ERROR;
   \   00001504   0410E003           MVNEQ    R1,#+4
   \   00001508   10108D05           STREQ    R1,[SP, #+16]
   1155              return ret;
   \   0000150C   10009DE5           LDR      R0,[SP, #+16]
   \   00001510   24D08DE2           ADD      SP,SP,#+36
   \   00001514   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??inflate_66:
   \   00001518   ........           DC32     `?<Constant "header crc mismatch">`
   \   0000151C   ........           DC32     `?<Constant "invalid block type">`
   \   00001520   ........           DC32     `?<Constant "invalid stored block ...">`
   \   00001524   ........           DC32     `?<Constant "too many length or di...">`
   \   00001528   ........           DC32     ??order
   \   0000152C   ........           DC32     `?<Constant "invalid code lengths set">`
   \   00001530   ........           DC32     `?<Constant "invalid literal/lengt...">`
   \   00001534   ........           DC32     `?<Constant "invalid bit length re...">`
   \   00001538   ........           DC32     `?<Constant "invalid distances set">`
   \   0000153C   ........           DC32     `?<Constant "invalid literal/lengt...">_1`
   \   00001540   ........           DC32     `?<Constant "invalid distance code">`
   \   00001544   ........           DC32     `?<Constant "invalid distance too ...">`
   \   00001548   ........           DC32     `?<Constant "incorrect data check">`
   \   0000154C   ........           DC32     `?<Constant "incorrect length check">`
   1156          }

   \                                 In segment DATA_C, align 4, align-sorted
   \                     ??order:
   \   00000000   100011001200       DC16 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
   \              000008000700
   \              090006000A00
   \              05000B000400
   \              0C0003000D00
   \              02000E000100
   \              0F00        
   \   00000026   0000               DC8 0, 0
   1157          

   \                                 In segment CODE, align 4, keep-with-next
   1158          int ZEXPORT inflateEnd(strm)
   1159          z_streamp strm;
   1160          {
   \                     inflateEnd:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
   1161              struct inflate_state FAR *state;
   1162              if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
   \   00000008   1C009415           LDRNE    R0,[R4, #+28]
   \   0000000C   00005013           CMPNE    R0,#+0
   \   00000010   24209415           LDRNE    R2,[R4, #+36]
   \   00000014   00005213           CMPNE    R2,#+0
   1163                  return Z_STREAM_ERROR;
   \   00000018   0100E003           MVNEQ    R0,#+1
   \   0000001C   1080BD08           POPEQ    {R4,PC}
   1164              state = (struct inflate_state FAR *)strm->state;
   1165              if (state->window != Z_NULL) ZFREE(strm, state->window);
   \   00000020   341090E5           LDR      R1,[R0, #+52]
   \   00000024   000051E3           CMP      R1,#+0
   \   00000028   0100000A           BEQ      ??inflateEnd_0
   \   0000002C   280094E5           LDR      R0,[R4, #+40]
   \   00000030   32FF2FE1           BLX      R2
   1166              ZFREE(strm, strm->state);
   \                     ??inflateEnd_0:
   \   00000034   280094E5           LDR      R0,[R4, #+40]
   \   00000038   1C1094E5           LDR      R1,[R4, #+28]
   \   0000003C   242094E5           LDR      R2,[R4, #+36]
   \   00000040   32FF2FE1           BLX      R2
   1167              strm->state = Z_NULL;
   \   00000044   0000A0E3           MOV      R0,#+0
   \   00000048   1C0084E5           STR      R0,[R4, #+28]
   1168              Tracev((stderr, "inflate: end\n"));
   1169              return Z_OK;
   \   0000004C   1080BDE8           POP      {R4,PC}          ;; return
   1170          }
   1171          

   \                                 In segment CODE, align 4, keep-with-next
   1172          int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)
   1173          z_streamp strm;
   1174          const Bytef *dictionary;
   1175          uInt dictLength;
   1176          {
   \                     inflateSetDictionary:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   \   00000008   0250A0E1           MOV      R5,R2
   \   0000000C   0070A0E1           MOV      R7,R0
   1177              struct inflate_state FAR *state;
   1178              unsigned long id;
   1179          
   1180              /* check state */
   1181              if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
   \   00000010   000057E3           CMP      R7,#+0
   \   00000014   1C609715           LDRNE    R6,[R7, #+28]
   \   00000018   00005613           CMPNE    R6,#+0
   \   0000001C   0100001A           BNE      ??inflateSetDictionary_0
   \                     ??inflateSetDictionary_1:
   \   00000020   0100E0E3           MVN      R0,#+1
   \   00000024   F080BDE8           POP      {R4-R7,PC}
   1182              state = (struct inflate_state FAR *)strm->state;
   1183              if (state->wrap != 0 && state->mode != DICT)
   \                     ??inflateSetDictionary_0:
   \   00000028   080096E5           LDR      R0,[R6, #+8]
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   D000D611           LDRSBNE  R0,[R6, #+0]
   \   00000034   0A005013           CMPNE    R0,#+10
   \   00000038   F8FFFF1A           BNE      ??inflateSetDictionary_1
   1184                  return Z_STREAM_ERROR;
   1185          
   1186              /* check for correct dictionary id */
   1187              if (state->mode == DICT) {
   \   0000003C   D000D6E1           LDRSB    R0,[R6, #+0]
   \   00000040   0A0050E3           CMP      R0,#+10
   \   00000044   0A00001A           BNE      ??inflateSetDictionary_2
   1188                  id = adler32(0L, Z_NULL, 0);
   \   00000048   0020A0E3           MOV      R2,#+0
   \   0000004C   0010A0E3           MOV      R1,#+0
   \   00000050   0100A0E1           MOV      R0,R1
   \   00000054   ........           _BLF     adler32,??adler32??rA
   1189                  id = adler32(id, dictionary, dictLength);
   \   00000058   0520A0E1           MOV      R2,R5
   \   0000005C   0410A0E1           MOV      R1,R4
   \   00000060   ........           _BLF     adler32,??adler32??rA
   1190                  if (id != state->check)
   \   00000064   181096E5           LDR      R1,[R6, #+24]
   \   00000068   010050E1           CMP      R0,R1
   1191                      return Z_DATA_ERROR;
   \   0000006C   0200E013           MVNNE    R0,#+2
   \   00000070   F080BD18           POPNE    {R4-R7,PC}
   1192              }
   1193          
   1194              /* copy dictionary to window */
   1195              if (updatewindow(strm, strm->avail_out)) {
   \                     ??inflateSetDictionary_2:
   \   00000074   101097E5           LDR      R1,[R7, #+16]
   \   00000078   0700A0E1           MOV      R0,R7
   \   0000007C   ........           BL       updatewindow
   \   00000080   000050E3           CMP      R0,#+0
   \   00000084   0300000A           BEQ      ??inflateSetDictionary_3
   1196                  state->mode = MEM;
   \   00000088   1C00A0E3           MOV      R0,#+28
   \   0000008C   0000C6E5           STRB     R0,[R6, #+0]
   1197                  return Z_MEM_ERROR;
   \   00000090   0300E0E3           MVN      R0,#+3
   \   00000094   F080BDE8           POP      {R4-R7,PC}
   1198              }
   1199              if (dictLength > state->wsize) {
   \                     ??inflateSetDictionary_3:
   \   00000098   283096E5           LDR      R3,[R6, #+40]
   \   0000009C   340096E5           LDR      R0,[R6, #+52]
   \   000000A0   050053E1           CMP      R3,R5
   \   000000A4   0600002A           BCS      ??inflateSetDictionary_4
   1200                  zmemcpy(state->window, dictionary + dictLength - state->wsize,
   1201                          state->wsize);
   \   000000A8   0320A0E1           MOV      R2,R3
   \   000000AC   001063E2           RSB      R1,R3,#+0
   \   000000B0   043085E0           ADD      R3,R5,R4
   \   000000B4   031081E0           ADD      R1,R1,R3
   \   000000B8   1E0100EF           SWI      +286
   1202                  state->whave = state->wsize;
   \   000000BC   285096E5           LDR      R5,[R6, #+40]
   \   000000C0   060000EA           B        ??inflateSetDictionary_5
   1203              }
   1204              else {
   1205                  zmemcpy(state->window + state->wsize - dictLength, dictionary,
   1206                          dictLength);
   \                     ??inflateSetDictionary_4:
   \   000000C4   0520A0E1           MOV      R2,R5
   \   000000C8   0410A0E1           MOV      R1,R4
   \   000000CC   0540A0E1           MOV      R4,R5
   \   000000D0   004064E2           RSB      R4,R4,#+0
   \   000000D4   000083E0           ADD      R0,R3,R0
   \   000000D8   000084E0           ADD      R0,R4,R0
   \   000000DC   1E0100EF           SWI      +286
   1207                  state->whave = dictLength;
   \                     ??inflateSetDictionary_5:
   \   000000E0   2C5086E5           STR      R5,[R6, #+44]
   1208              }
   1209              state->havedict = 1;
   \   000000E4   0100A0E3           MOV      R0,#+1
   \   000000E8   0C0086E5           STR      R0,[R6, #+12]
   1210              Tracev((stderr, "inflate:   dictionary set\n"));
   1211              return Z_OK;
   \   000000EC   0000A0E3           MOV      R0,#+0
   \   000000F0   F080BDE8           POP      {R4-R7,PC}       ;; return
   1212          }
   1213          

   \                                 In segment CODE, align 4, keep-with-next
   1214          int ZEXPORT inflateGetHeader(strm, head)
   1215          z_streamp strm;
   1216          gz_headerp head;
   1217          {
   1218              struct inflate_state FAR *state;
   1219          
   1220              /* check state */
   1221              if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
   \                     inflateGetHeader:
   \   00000000   000050E3           CMP      R0,#+0
   \   00000004   1C009015           LDRNE    R0,[R0, #+28]
   \   00000008   00005013           CMPNE    R0,#+0
   1222              state = (struct inflate_state FAR *)strm->state;
   1223              if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;
   \   0000000C   08209015           LDRNE    R2,[R0, #+8]
   \   00000010   02001213           TSTNE    R2,#0x2
   \   00000014   0100E003           MVNEQ    R0,#+1
   \   00000018   1EFF2F01           BXEQ     LR
   1224          
   1225              /* save header structure */
   1226              state->head = head;
   \   0000001C   201080E5           STR      R1,[R0, #+32]
   1227              head->done = 0;
   \   00000020   0000A0E3           MOV      R0,#+0
   \   00000024   300081E5           STR      R0,[R1, #+48]
   1228              return Z_OK;
   \   00000028   1EFF2FE1           BX       LR               ;; return
   1229          }
   1230          
   1231          /*
   1232             Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found
   1233             or when out of input.  When called, *have is the number of pattern bytes
   1234             found in order so far, in 0..3.  On return *have is updated to the new
   1235             state.  If on return *have equals four, then the pattern was found and the
   1236             return value is how many bytes were read including the last byte of the
   1237             pattern.  If *have is less than four, then the pattern has not been found
   1238             yet and the return value is len.  In the latter case, syncsearch() can be
   1239             called again with more data and the *have state.  *have is initialized to
   1240             zero for the first call.
   1241           */

   \                                 In segment CODE, align 4, keep-with-next
   1242          local unsigned syncsearch(have, buf, len)
   1243          unsigned FAR *have;
   1244          unsigned char FAR *buf;
   1245          unsigned len;
   1246          {
   \                     syncsearch:
   \   00000000   E0002DE9           PUSH     {R5-R7}
   1247              unsigned got;
   1248              unsigned next;
   1249          
   1250              got = *have;
   \   00000004   00C090E5           LDR      R12,[R0, #+0]
   1251              next = 0;
   \   00000008   0030A0E3           MOV      R3,#+0
   \   0000000C   000000EA           B        ??syncsearch_0
   1252              while (next < len && got < 4) {
   1253                  if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))
   1254                      got++;
   1255                  else if (buf[next])
   1256                      got = 0;
   1257                  else
   1258                      got = 4 - got;
   1259                  next++;
   \                     ??syncsearch_1:
   \   00000010   013083E2           ADD      R3,R3,#+1
   \                     ??syncsearch_0:
   \   00000014   020053E1           CMP      R3,R2
   \   00000018   04005C33           CMPCC    R12,#+4
   \   0000001C   0B00002A           BCS      ??syncsearch_2
   \   00000020   016083E0           ADD      R6,R3,R1
   \   00000024   0070D6E5           LDRB     R7,[R6, #+0]
   \   00000028   02005CE3           CMP      R12,#+2
   \   0000002C   0050A033           MOVCC    R5,#+0
   \   00000030   FF50A023           MOVCS    R5,#+255
   \   00000034   050057E1           CMP      R7,R5
   \   00000038   01C08C02           ADDEQ    R12,R12,#+1
   \   0000003C   F3FFFF0A           BEQ      ??syncsearch_1
   \   00000040   000057E3           CMP      R7,#+0
   \   00000044   04C06C02           RSBEQ    R12,R12,#+4
   \   00000048   00C0A013           MOVNE    R12,#+0
   \   0000004C   EFFFFFEA           B        ??syncsearch_1
   1260              }
   1261              *have = got;
   \                     ??syncsearch_2:
   \   00000050   00C080E5           STR      R12,[R0, #+0]
   1262              return next;
   \   00000054   E000BDE8           POP      {R5-R7}
   \   00000058   0300A0E1           MOV      R0,R3
   \   0000005C   1EFF2FE1           BX       LR               ;; return
   1263          }
   1264          

   \                                 In segment CODE, align 4, keep-with-next
   1265          int ZEXPORT inflateSync(strm)
   1266          z_streamp strm;
   1267          {
   \                     inflateSync:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040B0E1           MOVS     R4,R0
   1268              unsigned len;               /* number of bytes to look at or looked at */
   1269              unsigned long in, out;      /* temporary to save total_in and total_out */
   1270              unsigned char buf[4];       /* to restore bit buffer to byte string */
   1271              struct inflate_state FAR *state;
   1272          
   1273              /* check parameters */
   1274              if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
   \   0000000C   1C509415           LDRNE    R5,[R4, #+28]
   \   00000010   00005513           CMPNE    R5,#+0
   \   00000014   0100E003           MVNEQ    R0,#+1
   \   00000018   F280BD08           POPEQ    {R1,R4-R7,PC}
   1275              state = (struct inflate_state FAR *)strm->state;
   1276              if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;
   \   0000001C   040094E5           LDR      R0,[R4, #+4]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0300001A           BNE      ??inflateSync_0
   \   00000028   3C0095E5           LDR      R0,[R5, #+60]
   \   0000002C   080050E3           CMP      R0,#+8
   \   00000030   0400E033           MVNCC    R0,#+4
   \   00000034   F280BD38           POPCC    {R1,R4-R7,PC}
   1277          
   1278              /* if first time, start search in bit buffer */
   1279              if (state->mode != SYNC) {
   \                     ??inflateSync_0:
   \   00000038   D000D5E1           LDRSB    R0,[R5, #+0]
   \   0000003C   1D0050E3           CMP      R0,#+29
   \   00000040   1D00000A           BEQ      ??inflateSync_1
   1280                  state->mode = SYNC;
   \   00000044   1D00A0E3           MOV      R0,#+29
   \   00000048   0000C5E5           STRB     R0,[R5, #+0]
   1281                  state->hold <<= state->bits & 7;
   \   0000004C   3C0095E5           LDR      R0,[R5, #+60]
   \   00000050   381095E5           LDR      R1,[R5, #+56]
   \   00000054   072000E2           AND      R2,R0,#0x7
   \   00000058   1112A0E1           LSL      R1,R1,R2
   \   0000005C   381085E5           STR      R1,[R5, #+56]
   1282                  state->bits -= state->bits & 7;
   \   00000060   071000E2           AND      R1,R0,#0x7
   \   00000064   010040E0           SUB      R0,R0,R1
   \   00000068   3C0085E5           STR      R0,[R5, #+60]
   1283                  len = 0;
   \   0000006C   0010A0E3           MOV      R1,#+0
   \   00000070   0020A0E3           MOV      R2,#+0
   \   00000074   080050E3           CMP      R0,#+8
   \   00000078   0B00003A           BCC      ??inflateSync_2
   1284                  while (state->bits >= 8) {
   1285                      buf[len++] = (unsigned char)(state->hold);
   \                     ??inflateSync_3:
   \   0000007C   383095E5           LDR      R3,[R5, #+56]
   \   00000080   0D00A0E1           MOV      R0,SP
   \   00000084   0030C2E7           STRB     R3,[R2, +R0]
   1286                      state->hold >>= 8;
   \   00000088   380095E5           LDR      R0,[R5, #+56]
   \   0000008C   012082E2           ADD      R2,R2,#+1
   \   00000090   2004A0E1           LSR      R0,R0,#+8
   \   00000094   380085E5           STR      R0,[R5, #+56]
   1287                      state->bits -= 8;
   \   00000098   3C0095E5           LDR      R0,[R5, #+60]
   \   0000009C   080040E2           SUB      R0,R0,#+8
   \   000000A0   3C0085E5           STR      R0,[R5, #+60]
   1288                  }
   \   000000A4   080050E3           CMP      R0,#+8
   \   000000A8   F3FFFF2A           BCS      ??inflateSync_3
   1289                  state->have = 0;
   \                     ??inflateSync_2:
   \   000000AC   681085E5           STR      R1,[R5, #+104]
   1290                  syncsearch(&(state->have), buf, len);
   \   000000B0   0D10A0E1           MOV      R1,SP
   \   000000B4   680085E2           ADD      R0,R5,#+104
   \   000000B8   ........           BL       syncsearch
   1291              }
   1292          
   1293              /* search available input */
   1294              len = syncsearch(&(state->have), strm->next_in, strm->avail_in);
   \                     ??inflateSync_1:
   \   000000BC   042094E5           LDR      R2,[R4, #+4]
   \   000000C0   001094E5           LDR      R1,[R4, #+0]
   \   000000C4   680085E2           ADD      R0,R5,#+104
   \   000000C8   ........           BL       syncsearch
   1295              strm->avail_in -= len;
   \   000000CC   041094E5           LDR      R1,[R4, #+4]
   \   000000D0   001041E0           SUB      R1,R1,R0
   \   000000D4   041084E5           STR      R1,[R4, #+4]
   1296              strm->next_in += len;
   \   000000D8   001094E5           LDR      R1,[R4, #+0]
   \   000000DC   011080E0           ADD      R1,R0,R1
   \   000000E0   001084E5           STR      R1,[R4, #+0]
   1297              strm->total_in += len;
   \   000000E4   081094E5           LDR      R1,[R4, #+8]
   \   000000E8   016080E0           ADD      R6,R0,R1
   \   000000EC   086084E5           STR      R6,[R4, #+8]
   1298          
   1299              /* return no joy or set up to restart inflate() on a new block */
   1300              if (state->have != 4) return Z_DATA_ERROR;
   \   000000F0   680095E5           LDR      R0,[R5, #+104]
   \   000000F4   040050E3           CMP      R0,#+4
   \   000000F8   0200E013           MVNNE    R0,#+2
   \   000000FC   F280BD18           POPNE    {R1,R4-R7,PC}
   1301              in = strm->total_in;  out = strm->total_out;
   \   00000100   147094E5           LDR      R7,[R4, #+20]
   1302              inflateReset(strm);
   \   00000104   0400A0E1           MOV      R0,R4
   \   00000108   ........           BL       inflateReset
   1303              strm->total_in = in;  strm->total_out = out;
   \   0000010C   086084E5           STR      R6,[R4, #+8]
   \   00000110   147084E5           STR      R7,[R4, #+20]
   1304              state->mode = TYPE;
   \   00000114   0B00A0E3           MOV      R0,#+11
   \   00000118   0000C5E5           STRB     R0,[R5, #+0]
   1305              return Z_OK;
   \   0000011C   0000A0E3           MOV      R0,#+0
   \   00000120   F280BDE8           POP      {R1,R4-R7,PC}    ;; return
   1306          }
   1307          
   1308          /*
   1309             Returns true if inflate is currently at the end of a block generated by
   1310             Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
   1311             implementation to provide an additional safety check. PPP uses
   1312             Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored
   1313             block. When decompressing, PPP checks that at the end of input packet,
   1314             inflate is waiting for these length bytes.
   1315           */

   \                                 In segment CODE, align 4, keep-with-next
   1316          int ZEXPORT inflateSyncPoint(strm)
   1317          z_streamp strm;
   1318          {
   1319              struct inflate_state FAR *state;
   1320          
   1321              if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
   \                     inflateSyncPoint:
   \   00000000   000050E3           CMP      R0,#+0
   \   00000004   1C009015           LDRNE    R0,[R0, #+28]
   \   00000008   00005013           CMPNE    R0,#+0
   \   0000000C   0100E003           MVNEQ    R0,#+1
   \   00000010   1EFF2F01           BXEQ     LR
   1322              state = (struct inflate_state FAR *)strm->state;
   1323              return state->mode == STORED && state->bits == 0;
   \   00000014   D010D0E1           LDRSB    R1,[R0, #+0]
   \   00000018   0D0051E3           CMP      R1,#+13
   \   0000001C   3C009005           LDREQ    R0,[R0, #+60]
   \   00000020   00005003           CMPEQ    R0,#+0
   \   00000024   0100A003           MOVEQ    R0,#+1
   \   00000028   1EFF2F01           BXEQ     LR
   \   0000002C   0000A0E3           MOV      R0,#+0
   \   00000030   1EFF2FE1           BX       LR               ;; return
   1324          }
   1325          

   \                                 In segment CODE, align 4, keep-with-next
   1326          int ZEXPORT inflateCopy(dest, source)
   1327          z_streamp dest;
   1328          z_streamp source;
   1329          {
   \                     inflateCopy:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0050A0E1           MOV      R5,R0
   \   0000000C   0160A0E1           MOV      R6,R1
   1330              struct inflate_state FAR *state;
   1331              struct inflate_state FAR *copy;
   1332              unsigned char FAR *window;
   1333              unsigned wsize;
   1334          
   1335              /* check input */
   1336              if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
   1337                  source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)
   \   00000010   000055E3           CMP      R5,#+0
   \   00000014   00005613           CMPNE    R6,#+0
   \   00000018   1C409615           LDRNE    R4,[R6, #+28]
   \   0000001C   00005413           CMPNE    R4,#+0
   \   00000020   20309615           LDRNE    R3,[R6, #+32]
   \   00000024   00005313           CMPNE    R3,#+0
   \   00000028   24009615           LDRNE    R0,[R6, #+36]
   \   0000002C   00005013           CMPNE    R0,#+0
   1338                  return Z_STREAM_ERROR;
   \   00000030   0100E003           MVNEQ    R0,#+1
   \   00000034   F287BD08           POPEQ    {R1,R4-R10,PC}
   1339              state = (struct inflate_state FAR *)source->state;
   1340          
   1341              /* allocate space */
   1342              copy = (struct inflate_state FAR *)
   1343                     ZALLOC(source, 1, sizeof(struct inflate_state));
   \   00000038   280096E5           LDR      R0,[R6, #+40]
   \   0000003C   30A0A0E3           MOV      R10,#+48
   \   00000040   94AD8AE3           ORR      R10,R10,#0x2500
   \   00000044   0A20A0E1           MOV      R2,R10
   \   00000048   0110A0E3           MOV      R1,#+1
   \   0000004C   33FF2FE1           BLX      R3
   \   00000050   0070B0E1           MOVS     R7,R0
   1344              if (copy == Z_NULL) return Z_MEM_ERROR;
   \   00000054   1000000A           BEQ      ??inflateCopy_0
   1345              window = Z_NULL;
   1346              if (state->window != Z_NULL) {
   \   00000058   340094E5           LDR      R0,[R4, #+52]
   \   0000005C   0080A0E3           MOV      R8,#+0
   \   00000060   0190A0E3           MOV      R9,#+1
   \   00000064   000050E3           CMP      R0,#+0
   \   00000068   0D00000A           BEQ      ??inflateCopy_1
   1347                  window = (unsigned char FAR *)
   1348                           ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
   \   0000006C   240094E5           LDR      R0,[R4, #+36]
   \   00000070   203096E5           LDR      R3,[R6, #+32]
   \   00000074   1910A0E1           LSL      R1,R9,R0
   \   00000078   280096E5           LDR      R0,[R6, #+40]
   \   0000007C   0120A0E3           MOV      R2,#+1
   \   00000080   33FF2FE1           BLX      R3
   \   00000084   0080B0E1           MOVS     R8,R0
   1349                  if (window == Z_NULL) {
   \   00000088   0500001A           BNE      ??inflateCopy_1
   1350                      ZFREE(source, copy);
   \   0000008C   280096E5           LDR      R0,[R6, #+40]
   \   00000090   242096E5           LDR      R2,[R6, #+36]
   \   00000094   0710A0E1           MOV      R1,R7
   \   00000098   32FF2FE1           BLX      R2
   1351                      return Z_MEM_ERROR;
   \                     ??inflateCopy_0:
   \   0000009C   0300E0E3           MVN      R0,#+3
   \   000000A0   F287BDE8           POP      {R1,R4-R10,PC}
   1352                  }
   1353              }
   1354          
   1355              /* copy state */
   1356              zmemcpy(dest, source, sizeof(z_stream));
   \                     ??inflateCopy_1:
   \   000000A4   3820A0E3           MOV      R2,#+56
   \   000000A8   0610A0E1           MOV      R1,R6
   \   000000AC   0500A0E1           MOV      R0,R5
   \   000000B0   1E0100EF           SWI      +286
   1357              zmemcpy(copy, state, sizeof(struct inflate_state));
   \   000000B4   0A20A0E1           MOV      R2,R10
   \   000000B8   0410A0E1           MOV      R1,R4
   \   000000BC   0700A0E1           MOV      R0,R7
   \   000000C0   1E0100EF           SWI      +286
   1358              if (state->lencode >= state->codes &&
   1359                  state->lencode <= state->codes + ENOUGH - 1) {
   \   000000C4   4C1094E5           LDR      R1,[R4, #+76]
   \   000000C8   530EA0E3           MOV      R0,#+1328
   \   000000CC   042080E0           ADD      R2,R0,R4
   \   000000D0   020051E1           CMP      R1,R2
   \   000000D4   0D00003A           BCC      ??inflateCopy_2
   \   000000D8   04304AE2           SUB      R3,R10,#+4
   \   000000DC   043083E0           ADD      R3,R3,R4
   \   000000E0   010053E1           CMP      R3,R1
   \   000000E4   0900003A           BCC      ??inflateCopy_2
   1360                  copy->lencode = copy->codes + (state->lencode - state->codes);
   \   000000E8   2221A0E1           LSR      R2,R2,#+2
   \   000000EC   211162E0           RSB      R1,R2,R1, LSR #+2
   \   000000F0   011187E0           ADD      R1,R7,R1, LSL #+2
   \   000000F4   531E81E2           ADD      R1,R1,#+1328
   \   000000F8   4C1087E5           STR      R1,[R7, #+76]
   1361                  copy->distcode = copy->codes + (state->distcode - state->codes);
   \   000000FC   501094E5           LDR      R1,[R4, #+80]
   \   00000100   211162E0           RSB      R1,R2,R1, LSR #+2
   \   00000104   011187E0           ADD      R1,R7,R1, LSL #+2
   \   00000108   531E81E2           ADD      R1,R1,#+1328
   \   0000010C   501087E5           STR      R1,[R7, #+80]
   1362              }
   1363              copy->next = copy->codes + (state->next - state->codes);
   \                     ??inflateCopy_2:
   \   00000110   6C1094E5           LDR      R1,[R4, #+108]
   \   00000114   040080E0           ADD      R0,R0,R4
   \   00000118   2111A0E1           LSR      R1,R1,#+2
   \   0000011C   200141E0           SUB      R0,R1,R0, LSR #+2
   \   00000120   000187E0           ADD      R0,R7,R0, LSL #+2
   \   00000124   530E80E2           ADD      R0,R0,#+1328
   \   00000128   6C0087E5           STR      R0,[R7, #+108]
   1364              if (window != Z_NULL) {
   \   0000012C   000058E3           CMP      R8,#+0
   \   00000130   0400000A           BEQ      ??inflateCopy_3
   1365                  wsize = 1U << state->wbits;
   1366                  zmemcpy(window, state->window, wsize);
   \   00000134   240094E5           LDR      R0,[R4, #+36]
   \   00000138   341094E5           LDR      R1,[R4, #+52]
   \   0000013C   1920A0E1           LSL      R2,R9,R0
   \   00000140   0800A0E1           MOV      R0,R8
   \   00000144   1E0100EF           SWI      +286
   1367              }
   1368              copy->window = window;
   \                     ??inflateCopy_3:
   \   00000148   348087E5           STR      R8,[R7, #+52]
   1369              dest->state = (struct internal_state FAR *)copy;
   \   0000014C   1C7085E5           STR      R7,[R5, #+28]
   1370              return Z_OK;
   \   00000150   0000A0E3           MOV      R0,#+0
   \   00000154   F287BDE8           POP      {R1,R4-R10,PC}   ;; return
   1371          }

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "incorrect header check">`:
   \   00000000   696E636F7272       DC8 "incorrect header check"
   \              656374206865
   \              616465722063
   \              6865636B00  
   \   00000017   00                 DC8 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "unknown compression m...">`:
   \   00000000   756E6B6E6F77       DC8 "unknown compression method"
   \              6E20636F6D70
   \              72657373696F
   \              6E206D657468
   \              6F6400      
   \   0000001B   00                 DC8 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "invalid window size">`:
   \   00000000   696E76616C69       DC8 "invalid window size"
   \              642077696E64
   \              6F772073697A
   \              6500        

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "unknown header flags set">`:
   \   00000000   756E6B6E6F77       DC8 "unknown header flags set"
   \              6E2068656164
   \              657220666C61
   \              677320736574
   \              00          
   \   00000019   000000             DC8 0, 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "header crc mismatch">`:
   \   00000000   686561646572       DC8 "header crc mismatch"
   \              20637263206D
   \              69736D617463
   \              6800        

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "invalid block type">`:
   \   00000000   696E76616C69       DC8 "invalid block type"
   \              6420626C6F63
   \              6B2074797065
   \              00          
   \   00000013   00                 DC8 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "invalid stored block ...">`:
   \   00000000   696E76616C69       DC8 "invalid stored block lengths"
   \              642073746F72
   \              656420626C6F
   \              636B206C656E
   \              6774687300  
   \   0000001D   000000             DC8 0, 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "too many length or di...">`:
   \   00000000   746F6F206D61       DC8 "too many length or distance symbols"
   \              6E79206C656E
   \              677468206F72
   \              206469737461
   \              6E6365207379
   \              6D626F6C7300

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "invalid code lengths set">`:
   \   00000000   696E76616C69       DC8 "invalid code lengths set"
   \              6420636F6465
   \              206C656E6774
   \              687320736574
   \              00          
   \   00000019   000000             DC8 0, 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "invalid bit length re...">`:
   \   00000000   696E76616C69       DC8 "invalid bit length repeat"
   \              642062697420
   \              6C656E677468
   \              207265706561
   \              7400        
   \   0000001A   0000               DC8 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "invalid literal/lengt...">`:
   \   00000000   696E76616C69       DC8 "invalid literal/lengths set"
   \              64206C697465
   \              72616C2F6C65
   \              6E6774687320
   \              73657400    

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "invalid distances set">`:
   \   00000000   696E76616C69       DC8 "invalid distances set"
   \              642064697374
   \              616E63657320
   \              73657400    
   \   00000016   0000               DC8 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "invalid literal/lengt...">_1`:
   \   00000000   696E76616C69       DC8 "invalid literal/length code"
   \              64206C697465
   \              72616C2F6C65
   \              6E6774682063
   \              6F646500    

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "invalid distance code">`:
   \   00000000   696E76616C69       DC8 "invalid distance code"
   \              642064697374
   \              616E63652063
   \              6F646500    
   \   00000016   0000               DC8 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "invalid distance too ...">`:
   \   00000000   696E76616C69       DC8 "invalid distance too far back"
   \              642064697374
   \              616E63652074
   \              6F6F20666172
   \              206261636B00
   \   0000001E   0000               DC8 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "incorrect data check">`:
   \   00000000   696E636F7272       DC8 "incorrect data check"
   \              656374206461
   \              746120636865
   \              636B00      
   \   00000015   000000             DC8 0, 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "incorrect length check">`:
   \   00000000   696E636F7272       DC8 "incorrect length check"
   \              656374206C65
   \              6E6774682063
   \              6865636B00  
   \   00000017   00                 DC8 0

   Maximum stack usage in bytes:

     Function             CSTACK
     --------             ------
     fixedtables              0
     inflate                 80
     inflateCopy             36
     inflateEnd               8
     inflateGetHeader         0
     inflateInit2_           16
     inflateInit_             4
     inflatePrime             8
     inflateReset             0
     inflateSetDictionary    20
     inflateSync             24
     inflateSyncPoint         0
     syncsearch              16
     updatewindow            24


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     inflateReset                    116
     inflatePrime                    100
     inflateInit2_                   244
     inflateInit_                     16
     fixedtables                      44
     lenfix                         2048
     distfix                         128
     updatewindow                    300
     inflate                        5456
     order                            40
     inflateEnd                       80
     inflateSetDictionary            244
     inflateGetHeader                 44
     syncsearch                       96
     inflateSync                     292
     inflateSyncPoint                 52
     inflateCopy                     344
     ?<Constant "incorrect header check">
                                      24
     ?<Constant "unknown compression m...">
                                      28
     ?<Constant "invalid window size">
                                      20
     ?<Constant "unknown header flags set">
                                      28
     ?<Constant "header crc mismatch">
                                      20
     ?<Constant "invalid block type">
                                      20
     ?<Constant "invalid stored block ...">
                                      32
     ?<Constant "too many length or di...">
                                      36
     ?<Constant "invalid code lengths set">
                                      28
     ?<Constant "invalid bit length re...">
                                      28
     ?<Constant "invalid literal/lengt...">
                                      28
     ?<Constant "invalid distances set">
                                      24
     ?<Constant "invalid literal/lengt...">_1
                                      28
     ?<Constant "invalid distance code">
                                      24
     ?<Constant "invalid distance too ...">
                                      32
     ?<Constant "incorrect data check">
                                      24
     ?<Constant "incorrect length check">
                                      24
      Others                         104

 
 7 532 bytes in segment CODE
 2 664 bytes in segment DATA_C
 
 7 428 bytes of CODE  memory (+ 104 bytes shared)
 2 664 bytes of CONST memory

Errors: none
Warnings: none
