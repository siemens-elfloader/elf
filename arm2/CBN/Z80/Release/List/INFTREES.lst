##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    31/Mar/2011  22:54:03 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\CBN\Arc\Zlib\INFTREES.C                       #
#    Command line    =  C:\arm\CBN\Arc\Zlib\INFTREES.C -D NEWSGOLD -D        #
#                       UNPACK -lC C:\arm\CBN\Z80\Release\List\ -o           #
#                       C:\arm\CBN\Z80\Release\Obj\ -s9 --no_unroll          #
#                       --no_clustering --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --char_is_signed --fpu None -I "C:\arm2\Embedded     #
#                       Workbench 4.0 Evaluation\ARM\INC\"                   #
#                       --inline_threshold=2                                 #
#    List file       =  C:\arm\CBN\Z80\Release\List\INFTREES.lst             #
#    Object file     =  C:\arm\CBN\Z80\Release\Obj\INFTREES.r79              #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\CBN\Arc\Zlib\INFTREES.C
      1          /* inftrees.c -- generate Huffman trees for efficient decoding
      2           * Copyright (C) 1995-2005 Mark Adler
      3           * For conditions of distribution and use, see copyright notice in zlib.h
      4           */
      5          
      6          #include "zutil.h"
      7          #include "inftrees.h"
      8          
      9          #define MAXBITS 15
     10          

   \                                 In segment DATA_C, align 4, align-sorted
     11          const char inflate_copyright[] =
   \                     inflate_copyright:
   \   00000000   20696E666C61       DC8 " inflate 1.2.3 Copyright 1995-2005 Mark Adler "
   \              746520312E32
   \              2E3320436F70
   \              797269676874
   \              20313939352D
   \              32303035204D
   \              61726B204164
   \              6C65722000  
   \   0000002F   00                 DC8 0
     12             " inflate 1.2.3 Copyright 1995-2005 Mark Adler ";
     13          /*
     14            If you use the zlib library in a product, an acknowledgment is welcome
     15            in the documentation of your product. If for some reason you cannot
     16            include such an acknowledgment, I would appreciate that you keep this
     17            copyright string in the executable of your product.
     18           */
     19          
     20          /*
     21             Build a set of tables to decode the provided canonical Huffman code.
     22             The code lengths are lens[0..codes-1].  The result starts at *table,
     23             whose indices are 0..2^bits-1.  work is a writable array of at least
     24             lens shorts, which is used as a work area.  type is the type of code
     25             to be generated, CODES, LENS, or DISTS.  On return, zero is success,
     26             -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
     27             on return points to the next available entry's address.  bits is the
     28             requested root table index bits, and on return it is the actual root
     29             table index bits.  It will differ if the request is greater than the
     30             longest code or if it is less than the shortest code.
     31           */

   \                                 In segment CODE, align 4, keep-with-next
     32          int inflate_table (codetype type, unsigned short  *lens,
     33                                       unsigned codes, code  * *table,
     34                                       unsigned *bits, unsigned short *work)
     35          
     36          //int inflate_table(type, lens, codes, table, bits, work)
     37          //codetype type;
     38          //unsigned short *lens;
     39          //unsigned codes;
     40          //code  **table;
     41          //unsigned  *bits;
     42          //unsigned short  *work;
     43          {
   \                     inflate_table:
   \   00000000   FB4F2DE9           PUSH     {R0,R1,R3-R11,LR}
   \   00000004   64D04DE2           SUB      SP,SP,#+100
     44              unsigned len;               /* a code's length in bits */
     45              unsigned sym;               /* index of code symbols */
     46              unsigned min, max;          /* minimum and maximum code lengths */
     47              unsigned root;              /* number of index bits for root table */
     48              unsigned curr;              /* number of index bits for current table */
     49              unsigned drop;              /* code bits to drop for sub-table */
     50              int left;                   /* number of prefix codes available */
     51              unsigned used;              /* code entries in table used */
     52              unsigned huff;              /* Huffman code */
     53              unsigned incr;              /* for incrementing code, index */
     54              unsigned fill;              /* index for replicating entries */
     55              unsigned low;               /* low bits for current root entry */
     56              unsigned mask;              /* mask for low root bits */
     57              code this;                  /* table entry for duplication */
     58              code FAR *next;             /* next available space in table */
     59              const unsigned short FAR *base;     /* base value table to use */
     60              const unsigned short FAR *extra;    /* extra bits table to use */
     61              int end;                    /* use base and extra for symbol > end */
     62              unsigned short count[MAXBITS+1];    /* number of codes of each length */
     63              unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
     64              static const unsigned short lbase[31] = { /* Length codes 257..285 base */
     65                  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
     66                  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
     67              static const unsigned short lext[31] = { /* Length codes 257..285 extra */
     68                  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
     69                  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 201, 196};
     70              static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
     71                  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
     72                  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
     73                  8193, 12289, 16385, 24577, 0, 0};
     74              static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
     75                  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
     76                  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
     77                  28, 28, 29, 29, 64, 64};
     78          
     79              /*
     80                 Process a set of code lengths to create a canonical Huffman code.  The
     81                 code lengths are lens[0..codes-1].  Each length corresponds to the
     82                 symbols 0..codes-1.  The Huffman code is generated by first sorting the
     83                 symbols by length from short to long, and retaining the symbol order
     84                 for codes with equal lengths.  Then the code starts with all zero bits
     85                 for the first code of the shortest length, and the codes are integer
     86                 increments for the same length, and zeros are appended as the length
     87                 increases.  For the deflate format, these bits are stored backwards
     88                 from their more natural integer increment ordering, and so when the
     89                 decoding tables are built in the large loop below, the integer codes
     90                 are incremented backwards.
     91          
     92                 This routine assumes, but does not check, that all of the entries in
     93                 lens[] are in the range 0..MAXBITS.  The caller must assure this.
     94                 1..MAXBITS is interpreted as that code length.  zero means that that
     95                 symbol does not occur in this code.
     96          
     97                 The codes are sorted by computing a count of codes for each length,
     98                 creating from that a table of starting indices for each length in the
     99                 sorted table, and then entering the symbols in order in the sorted
    100                 table.  The sorted table is work[], with that space being provided by
    101                 the caller.
    102          
    103                 The length counts are used for other purposes as well, i.e. finding
    104                 the minimum and maximum length codes, determining if there are any
    105                 codes at all, checking for a valid set of lengths, and looking ahead
    106                 at length counts to determine sub-table sizes when building the
    107                 decoding tables.
    108               */
    109          
    110              /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    111              for (len = 0; len <= MAXBITS; len++)
   \   00000008   0010A0E3           MOV      R1,#+0
   \   0000000C   0050A0E3           MOV      R5,#+0
    112                  count[len] = 0;
   \                     ??inflate_table_0:
   \   00000010   24008DE2           ADD      R0,SP,#+36
   \   00000014   850080E0           ADD      R0,R0,R5, LSL #+1
   \   00000018   B010C0E1           STRH     R1,[R0, #+0]
   \   0000001C   015085E2           ADD      R5,R5,#+1
   \   00000020   100055E3           CMP      R5,#+16
   \   00000024   F9FFFF3A           BCC      ??inflate_table_0
    113              for (sym = 0; sym < codes; sym++)
   \   00000028   0060A0E3           MOV      R6,#+0
   \   0000002C   000052E3           CMP      R2,#+0
   \   00000030   24408DE2           ADD      R4,SP,#+36
   \   00000034   0A00001A           BNE      ??inflate_table_1
   \   00000038   0B0000EA           B        ??inflate_table_2
    114                  count[lens[sym]]++;
   \                     ??inflate_table_3:
   \   0000003C   68009DE5           LDR      R0,[SP, #+104]
   \   00000040   860080E0           ADD      R0,R0,R6, LSL #+1
   \   00000044   B030D0E1           LDRH     R3,[R0, #+0]
   \   00000048   B000D0E1           LDRH     R0,[R0, #+0]
   \   0000004C   016086E2           ADD      R6,R6,#+1
   \   00000050   833084E0           ADD      R3,R4,R3, LSL #+1
   \   00000054   800084E0           ADD      R0,R4,R0, LSL #+1
   \   00000058   B000D0E1           LDRH     R0,[R0, #+0]
   \   0000005C   010080E2           ADD      R0,R0,#+1
   \   00000060   B000C3E1           STRH     R0,[R3, #+0]
   \                     ??inflate_table_1:
   \   00000064   020056E1           CMP      R6,R2
   \   00000068   F3FFFF3A           BCC      ??inflate_table_3
    115          
    116              /* bound code lengths, force root to be within code lengths */
    117              root = *bits;
   \                     ??inflate_table_2:
   \   0000006C   94309DE5           LDR      R3,[SP, #+148]
   \   00000070   003093E5           LDR      R3,[R3, #+0]
   \   00000074   04308DE5           STR      R3,[SP, #+4]
    118              for (max = MAXBITS; max >= 1; max--)
   \   00000078   0F30A0E3           MOV      R3,#+15
    119                  if (count[max] != 0) break;
   \                     ??inflate_table_4:
   \   0000007C   24008DE2           ADD      R0,SP,#+36
   \   00000080   830080E0           ADD      R0,R0,R3, LSL #+1
   \   00000084   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000088   000050E3           CMP      R0,#+0
   \   0000008C   0100001A           BNE      ??inflate_table_5
   \   00000090   013053E2           SUBS     R3,R3,#+1
   \   00000094   F8FFFF1A           BNE      ??inflate_table_4
    120              if (root > max) root = max;
   \                     ??inflate_table_5:
   \   00000098   04009DE5           LDR      R0,[SP, #+4]
    121              if (max == 0) {                     /* no symbols to code at all */
   \   0000009C   01C0A0E3           MOV      R12,#+1
   \   000000A0   000053E1           CMP      R3,R0
   \   000000A4   6C009DE5           LDR      R0,[SP, #+108]
   \   000000A8   04308D35           STRCC    R3,[SP, #+4]
   \   000000AC   000090E5           LDR      R0,[R0, #+0]
   \   000000B0   000053E3           CMP      R3,#+0
   \   000000B4   1300001A           BNE      ??inflate_table_6
    122                  this.op = (unsigned char)64;    /* invalid code marker */
    123                  this.bits = (unsigned char)1;
    124                  this.val = (unsigned short)0;
    125                  *(*table)++ = this;             /* make a table to force an error */
   \   000000B8   6C209DE5           LDR      R2,[SP, #+108]
   \   000000BC   043080E2           ADD      R3,R0,#+4
   \   000000C0   003082E5           STR      R3,[R2, #+0]
   \   000000C4   4020A0E3           MOV      R2,#+64
   \   000000C8   0020C0E5           STRB     R2,[R0, #+0]
   \   000000CC   01C0C0E5           STRB     R12,[R0, #+1]
   \   000000D0   B210C0E1           STRH     R1,[R0, #+2]
    126                  *(*table)++ = this;
   \   000000D4   6C009DE5           LDR      R0,[SP, #+108]
   \   000000D8   6C209DE5           LDR      R2,[SP, #+108]
   \   000000DC   000090E5           LDR      R0,[R0, #+0]
   \   000000E0   043080E2           ADD      R3,R0,#+4
   \   000000E4   003082E5           STR      R3,[R2, #+0]
   \   000000E8   4020A0E3           MOV      R2,#+64
   \   000000EC   0020C0E5           STRB     R2,[R0, #+0]
   \   000000F0   01C0C0E5           STRB     R12,[R0, #+1]
   \   000000F4   B210C0E1           STRH     R1,[R0, #+2]
    127                  *bits = 1;
   \   000000F8   94009DE5           LDR      R0,[SP, #+148]
   \   000000FC   00C080E5           STR      R12,[R0, #+0]
    128                  return 0;     /* no symbols, but wait for decoding to report error */
   \   00000100   0000A0E3           MOV      R0,#+0
   \   00000104   130000EA           B        ??inflate_table_7
    129              }
    130              for (min = 1; min <= MAXBITS; min++)
   \                     ??inflate_table_6:
   \   00000108   0140A0E3           MOV      R4,#+1
    131                  if (count[min] != 0) break;
   \                     ??inflate_table_8:
   \   0000010C   24508DE2           ADD      R5,SP,#+36
   \   00000110   845085E0           ADD      R5,R5,R4, LSL #+1
   \   00000114   B050D5E1           LDRH     R5,[R5, #+0]
   \   00000118   000055E3           CMP      R5,#+0
   \   0000011C   0200001A           BNE      ??inflate_table_9
   \   00000120   014084E2           ADD      R4,R4,#+1
   \   00000124   100054E3           CMP      R4,#+16
   \   00000128   F7FFFF3A           BCC      ??inflate_table_8
    132              if (root < min) root = min;
   \                     ??inflate_table_9:
   \   0000012C   04509DE5           LDR      R5,[SP, #+4]
    133          
    134              /* check for an over-subscribed or incomplete set of lengths */
    135              left = 1;
   \   00000130   0190A0E3           MOV      R9,#+1
   \   00000134   040055E1           CMP      R5,R4
   \   00000138   04408D35           STRCC    R4,[SP, #+4]
    136              for (len = 1; len <= MAXBITS; len++) {
   \   0000013C   0950A0E1           MOV      R5,R9
    137                  left <<= 1;
    138                  left -= count[len];
   \                     ??inflate_table_10:
   \   00000140   24608DE2           ADD      R6,SP,#+36
   \   00000144   856086E0           ADD      R6,R6,R5, LSL #+1
   \   00000148   B060D6E1           LDRH     R6,[R6, #+0]
   \   0000014C   899076E0           RSBS     R9,R6,R9, LSL #+1
    139                  if (left < 0) return -1;        /* over-subscribed */
   \   00000150   0200005A           BPL      ??inflate_table_11
   \                     ??inflate_table_12:
   \   00000154   0100E0E1           MVN      R0,R1
   \                     ??inflate_table_7:
   \   00000158   70D08DE2           ADD      SP,SP,#+112
   \   0000015C   F08FBDE8           POP      {R4-R11,PC}
    140              }
   \                     ??inflate_table_11:
   \   00000160   015085E2           ADD      R5,R5,#+1
   \   00000164   100055E3           CMP      R5,#+16
   \   00000168   F4FFFF3A           BCC      ??inflate_table_10
    141              if (left > 0 && (type == CODES || max != 1))
   \   0000016C   010059E3           CMP      R9,#+1
   \   00000170   040000BA           BLT      ??inflate_table_13
   \   00000174   D456DDE1           LDRSB    R5,[SP, #+100]
   \   00000178   000055E3           CMP      R5,#+0
   \   0000017C   F4FFFF0A           BEQ      ??inflate_table_12
   \   00000180   010053E3           CMP      R3,#+1
   \   00000184   F2FFFF1A           BNE      ??inflate_table_12
    142                  return -1;                      /* incomplete set */
    143          
    144              /* generate offsets into symbol table for each length for sorting */
    145              offs[1] = 0;
   \                     ??inflate_table_13:
   \   00000188   B614CDE1           STRH     R1,[SP, #+70]
    146              for (len = 1; len < MAXBITS; len++)
   \   0000018C   0150A0E3           MOV      R5,#+1
    147                  offs[len + 1] = offs[len] + count[len];
   \                     ??inflate_table_14:
   \   00000190   44608DE2           ADD      R6,SP,#+68
   \   00000194   856086E0           ADD      R6,R6,R5, LSL #+1
   \   00000198   B070D6E1           LDRH     R7,[R6, #+0]
   \   0000019C   24808DE2           ADD      R8,SP,#+36
   \   000001A0   858088E0           ADD      R8,R8,R5, LSL #+1
   \   000001A4   B080D8E1           LDRH     R8,[R8, #+0]
   \   000001A8   015085E2           ADD      R5,R5,#+1
   \   000001AC   0F0055E3           CMP      R5,#+15
   \   000001B0   077088E0           ADD      R7,R8,R7
   \   000001B4   B270C6E1           STRH     R7,[R6, #+2]
   \   000001B8   F4FFFF3A           BCC      ??inflate_table_14
    148          
    149              /* sort symbols by length, by symbol order within each length */
    150              for (sym = 0; sym < codes; sym++)
   \   000001BC   0050A0E3           MOV      R5,#+0
   \   000001C0   000052E3           CMP      R2,#+0
   \   000001C4   1400001A           BNE      ??inflate_table_15
   \   000001C8   150000EA           B        ??inflate_table_16
    151                  if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
   \                     ??inflate_table_17:
   \   000001CC   68609DE5           LDR      R6,[SP, #+104]
   \   000001D0   856086E0           ADD      R6,R6,R5, LSL #+1
   \   000001D4   B070D6E1           LDRH     R7,[R6, #+0]
   \   000001D8   000057E3           CMP      R7,#+0
   \   000001DC   0D00000A           BEQ      ??inflate_table_18
   \   000001E0   44808DE2           ADD      R8,SP,#+68
   \   000001E4   877088E0           ADD      R7,R8,R7, LSL #+1
   \   000001E8   B070D7E1           LDRH     R7,[R7, #+0]
   \   000001EC   98809DE5           LDR      R8,[SP, #+152]
   \   000001F0   877088E0           ADD      R7,R8,R7, LSL #+1
   \   000001F4   B050C7E1           STRH     R5,[R7, #+0]
   \   000001F8   B070D6E1           LDRH     R7,[R6, #+0]
   \   000001FC   B060D6E1           LDRH     R6,[R6, #+0]
   \   00000200   44808DE2           ADD      R8,SP,#+68
   \   00000204   877088E0           ADD      R7,R8,R7, LSL #+1
   \   00000208   866088E0           ADD      R6,R8,R6, LSL #+1
   \   0000020C   B060D6E1           LDRH     R6,[R6, #+0]
   \   00000210   016086E2           ADD      R6,R6,#+1
   \   00000214   B060C7E1           STRH     R6,[R7, #+0]
   \                     ??inflate_table_18:
   \   00000218   015085E2           ADD      R5,R5,#+1
   \                     ??inflate_table_15:
   \   0000021C   020055E1           CMP      R5,R2
   \   00000220   E9FFFF3A           BCC      ??inflate_table_17
    152          
    153              /*
    154                 Create and fill in decoding tables.  In this loop, the table being
    155                 filled is at next and has curr index bits.  The code being used is huff
    156                 with length len.  That code is converted to an index by dropping drop
    157                 bits off of the bottom.  For codes where len is less than drop + curr,
    158                 those top drop + curr - len bits are incremented through all values to
    159                 fill the table with replicated entries.
    160          
    161                 root is the number of index bits for the root table.  When len exceeds
    162                 root, sub-tables are created pointed to by the root entry with an index
    163                 of the low root bits of huff.  This is saved in low to check for when a
    164                 new sub-table should be started.  drop is zero when the root table is
    165                 being filled, and drop is root when sub-tables are being filled.
    166          
    167                 When a new sub-table is needed, it is necessary to look ahead in the
    168                 code lengths to determine what size sub-table is needed.  The length
    169                 counts are used for this, and so count[] is decremented as codes are
    170                 entered in the tables.
    171          
    172                 used keeps track of how many table entries have been allocated from the
    173                 provided *table space.  It is checked when a LENS table is being made
    174                 against the space in *table, ENOUGH, minus the maximum space needed by
    175                 the worst case distance code, MAXD.  This should never happen, but the
    176                 sufficiency of ENOUGH has not been proven exhaustively, hence the check.
    177                 This assumes that when type == LENS, bits == 9.
    178          
    179                 sym increments through all symbols, and the loop terminates when
    180                 all codes of length max, i.e. all codes, have been processed.  This
    181                 routine permits incomplete codes, so another loop after this one fills
    182                 in the rest of the decoding tables with invalid code markers.
    183               */
    184          
    185              /* set up for code type */
    186              switch (type) {
   \                     ??inflate_table_16:
   \   00000224   D426DDE1           LDRSB    R2,[SP, #+100]
   \   00000228   000052E3           CMP      R2,#+0
   \   0000022C   0200000A           BEQ      ??inflate_table_19
   \   00000230   012052E2           SUBS     R2,R2,#+1
   \   00000234   0500000A           BEQ      ??inflate_table_20
   \   00000238   0E0000EA           B        ??inflate_table_21
    187              case CODES:
    188                  base = extra = work;    /* dummy value--not used */
   \                     ??inflate_table_19:
   \   0000023C   98509DE5           LDR      R5,[SP, #+152]
   \   00000240   10508DE5           STR      R5,[SP, #+16]
   \   00000244   18508DE5           STR      R5,[SP, #+24]
    189                  end = 19;
   \   00000248   1350A0E3           MOV      R5,#+19
   \   0000024C   0E0000EA           B        ??inflate_table_22
    190                  break;
    191              case LENS:
    192                  base = lbase;
    193                  base -= 257;
   \                     ??inflate_table_20:
   \   00000250   38639FE5           LDR      R6,??inflate_table_23  ;; ??lbase
   \   00000254   0120E0E3           MVN      R2,#+1
   \   00000258   802FC2E3           BIC      R2,R2,#0x200
   \   0000025C   066082E0           ADD      R6,R2,R6
   \   00000260   18608DE5           STR      R6,[SP, #+24]
    194                  extra = lext;
    195                  extra -= 257;
   \   00000264   28639FE5           LDR      R6,??inflate_table_23+0x4  ;; ??lext
    196                  end = 256;
   \   00000268   405FA0E3           MOV      R5,#+256
   \   0000026C   062082E0           ADD      R2,R2,R6
   \   00000270   10208DE5           STR      R2,[SP, #+16]
   \   00000274   040000EA           B        ??inflate_table_22
    197                  break;
    198              default:            /* DISTS */
    199                  base = dbase;
   \                     ??inflate_table_21:
   \   00000278   18539FE5           LDR      R5,??inflate_table_23+0x8  ;; ??dbase
   \   0000027C   18508DE5           STR      R5,[SP, #+24]
    200                  extra = dext;
   \   00000280   14539FE5           LDR      R5,??inflate_table_23+0xC  ;; ??dext
   \   00000284   10508DE5           STR      R5,[SP, #+16]
    201                  end = -1;
   \   00000288   0150E0E1           MVN      R5,R1
    202              }
    203          
    204              /* initialize state for loop */
    205              huff = 0;                   /* starting code */
    206              sym = 0;                    /* starting code symbol */
    207              len = min;                  /* starting code length */
    208              next = *table;              /* current table to fill in */
    209              curr = root;                /* current table index bits */
   \                     ??inflate_table_22:
   \   0000028C   04809DE5           LDR      R8,[SP, #+4]
   \   00000290   14508DE5           STR      R5,[SP, #+20]
   \   00000294   0450A0E1           MOV      R5,R4
    210              drop = 0;                   /* current bits to drop from code for index */
    211              low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    212              used = 1U << root;          /* use root table entries */
    213              mask = used - 1;            /* mask for comparing low */
    214          
    215              /* check available table space */
    216              if (type == LENS && used >= ENOUGH - MAXD)
   \   00000298   D446DDE1           LDRSB    R4,[SP, #+100]
   \   0000029C   0020A0E3           MOV      R2,#+0
   \   000002A0   0160A0E1           MOV      R6,R1
   \   000002A4   0170A0E1           MOV      R7,R1
   \   000002A8   0190E0E1           MVN      R9,R1
   \   000002AC   08908DE5           STR      R9,[SP, #+8]
   \   000002B0   0890A0E1           MOV      R9,R8
   \   000002B4   1C99A0E1           LSL      R9,R12,R9
   \   000002B8   0C908DE5           STR      R9,[SP, #+12]
   \   000002BC   019049E2           SUB      R9,R9,#+1
   \   000002C0   1C908DE5           STR      R9,[SP, #+28]
   \   000002C4   010054E3           CMP      R4,#+1
   \   000002C8   2900001A           BNE      ??inflate_table_24
   \   000002CC   0C409DE5           LDR      R4,[SP, #+12]
   \   000002D0   5B0E54E3           CMP      R4,#+1456
   \   000002D4   2600003A           BCC      ??inflate_table_24
    217                  return 1;
   \                     ??inflate_table_25:
   \   000002D8   0100A0E3           MOV      R0,#+1
   \   000002DC   9DFFFFEA           B        ??inflate_table_7
    218          
    219              /* process all codes and make table entries */
    220              for (;;) {
    221                  /* create table entry */
    222                  this.bits = (unsigned char)(len - drop);
    223                  if ((int)(work[sym]) < end) {
    224                      this.op = (unsigned char)0;
    225                      this.val = work[sym];
    226                  }
    227                  else if ((int)(work[sym]) > end) {
    228                      this.op = (unsigned char)(extra[work[sym]]);
    229                      this.val = base[work[sym]];
    230                  }
    231                  else {
    232                      this.op = (unsigned char)(32 + 64);         /* end of block */
    233                      this.val = 0;
    234                  }
    235          
    236                  /* replicate for those indices with low len bits equal to huff */
    237                  incr = 1U << (len - drop);
    238                  fill = 1U << curr;
    239                  min = fill;                 /* save offset to next table */
    240                  do {
    241                      fill -= incr;
    242                      next[(huff >> drop) + fill] = this;
    243                  } while (fill != 0);
    244          
    245                  /* backwards increment the len-bit code huff */
    246                  incr = 1U << (len - 1);
    247                  while (huff & incr)
    248                      incr >>= 1;
    249                  if (incr != 0) {
    250                      huff &= incr - 1;
    251                      huff += incr;
    252                  }
    253                  else
    254                      huff = 0;
    255          
    256                  /* go to next symbol, update count, len */
    257                  sym++;
    258                  if (--(count[len]) == 0) {
    259                      if (len == max) break;
    260                      len = lens[work[sym]];
    261                  }
    262          
    263                  /* create new sub-table if needed */
    264                  if (len > root && (huff & mask) != low) {
    265                      /* if first time, transition to sub-tables */
    266                      if (drop == 0)
    267                          drop = root;
    268          
    269                      /* increment past last table */
    270                      next += min;            /* here min is 1 << curr */
    271          
    272                      /* determine length of next table */
    273                      curr = len - drop;
    274                      left = (int)(1 << curr);
    275                      while (curr + drop < max) {
    276                          left -= count[curr + drop];
    277                          if (left <= 0) break;
    278                          curr++;
   \                     ??inflate_table_26:
   \   000002E0   018088E2           ADD      R8,R8,#+1
    279                          left <<= 1;
   \   000002E4   8990A0E1           LSL      R9,R9,#+1
   \                     ??inflate_table_27:
   \   000002E8   084087E0           ADD      R4,R7,R8
   \   000002EC   030054E1           CMP      R4,R3
   \   000002F0   0500002A           BCS      ??inflate_table_28
   \   000002F4   24B08DE2           ADD      R11,SP,#+36
   \   000002F8   84408BE0           ADD      R4,R11,R4, LSL #+1
   \   000002FC   B040D4E1           LDRH     R4,[R4, #+0]
   \   00000300   049049E0           SUB      R9,R9,R4
   \   00000304   010059E3           CMP      R9,#+1
   \   00000308   F4FFFFAA           BGE      ??inflate_table_26
    280                      }
    281          
    282                      /* check for enough space */
    283                      used += 1U << curr;
    284                      if (type == LENS && used >= ENOUGH - MAXD)
   \                     ??inflate_table_28:
   \   0000030C   D446DDE1           LDRSB    R4,[SP, #+100]
   \   00000310   0C909DE5           LDR      R9,[SP, #+12]
   \   00000314   1C9889E0           ADD      R9,R9,R12, LSL R8
   \   00000318   0C908DE5           STR      R9,[SP, #+12]
   \   0000031C   010054E3           CMP      R4,#+1
   \   00000320   0100001A           BNE      ??inflate_table_29
   \   00000324   5B0E59E3           CMP      R9,#+1456
   \   00000328   EAFFFF2A           BCS      ??inflate_table_25
    285                          return 1;
    286          
    287                      /* point entry in root table to sub-table */
    288                      low = huff & mask;
    289                      (*table)[low].op = (unsigned char)curr;
   \                     ??inflate_table_29:
   \   0000032C   6C909DE5           LDR      R9,[SP, #+108]
   \   00000330   08A08DE5           STR      R10,[SP, #+8]
   \   00000334   08409DE5           LDR      R4,[SP, #+8]
   \   00000338   009099E5           LDR      R9,[R9, #+0]
    290                      (*table)[low].bits = (unsigned char)root;
    291                      (*table)[low].val = (unsigned short)(next - *table);
   \   0000033C   20A1A0E1           LSR      R10,R0,#+2
   \   00000340   0481C9E7           STRB     R8,[R9, +R4, LSL #+2]
   \   00000344   6C909DE5           LDR      R9,[SP, #+108]
   \   00000348   08409DE5           LDR      R4,[SP, #+8]
   \   0000034C   009099E5           LDR      R9,[R9, #+0]
   \   00000350   044189E0           ADD      R4,R9,R4, LSL #+2
   \   00000354   04909DE5           LDR      R9,[SP, #+4]
   \   00000358   0190C4E5           STRB     R9,[R4, #+1]
   \   0000035C   6C409DE5           LDR      R4,[SP, #+108]
   \   00000360   08909DE5           LDR      R9,[SP, #+8]
   \   00000364   004094E5           LDR      R4,[R4, #+0]
   \   00000368   099184E0           ADD      R9,R4,R9, LSL #+2
   \   0000036C   24414AE0           SUB      R4,R10,R4, LSR #+2
   \   00000370   B240C9E1           STRH     R4,[R9, #+2]
   \                     ??inflate_table_24:
   \   00000374   98909DE5           LDR      R9,[SP, #+152]
   \   00000378   14B09DE5           LDR      R11,[SP, #+20]
   \   0000037C   074045E0           SUB      R4,R5,R7
   \   00000380   0140CDE5           STRB     R4,[SP, #+1]
   \   00000384   869089E0           ADD      R9,R9,R6, LSL #+1
   \   00000388   B0A0D9E1           LDRH     R10,[R9, #+0]
   \   0000038C   0B005AE1           CMP      R10,R11
   \   00000390   030000AA           BGE      ??inflate_table_30
   \   00000394   0010CDE5           STRB     R1,[SP, #+0]
   \                     ??inflate_table_31:
   \   00000398   B090D9E1           LDRH     R9,[R9, #+0]
   \   0000039C   B290CDE1           STRH     R9,[SP, #+2]
   \   000003A0   0E0000EA           B        ??inflate_table_32
   \                     ??inflate_table_30:
   \   000003A4   0BA0A0E1           MOV      R10,R11
   \   000003A8   B0B0D9E1           LDRH     R11,[R9, #+0]
   \   000003AC   0B005AE1           CMP      R10,R11
   \   000003B0   070000AA           BGE      ??inflate_table_33
   \   000003B4   10E09DE5           LDR      LR,[SP, #+16]
   \   000003B8   8BB08EE0           ADD      R11,LR,R11, LSL #+1
   \   000003BC   B0B0DBE1           LDRH     R11,[R11, #+0]
   \   000003C0   00B0CDE5           STRB     R11,[SP, #+0]
   \   000003C4   B090D9E1           LDRH     R9,[R9, #+0]
   \   000003C8   18B09DE5           LDR      R11,[SP, #+24]
   \   000003CC   89908BE0           ADD      R9,R11,R9, LSL #+1
   \   000003D0   F0FFFFEA           B        ??inflate_table_31
   \                     ??inflate_table_33:
   \   000003D4   60A0A0E3           MOV      R10,#+96
   \   000003D8   00A0CDE5           STRB     R10,[SP, #+0]
   \   000003DC   B210CDE1           STRH     R1,[SP, #+2]
   \                     ??inflate_table_32:
   \   000003E0   1C44A0E1           LSL      R4,R12,R4
   \   000003E4   20408DE5           STR      R4,[SP, #+32]
   \   000003E8   1C98A0E1           LSL      R9,R12,R8
   \   000003EC   0940A0E1           MOV      R4,R9
   \                     ??inflate_table_34:
   \   000003F0   00B0DDE5           LDRB     R11,[SP, #+0]
   \   000003F4   20A09DE5           LDR      R10,[SP, #+32]
   \   000003F8   0A9049E0           SUB      R9,R9,R10
   \   000003FC   32A789E0           ADD      R10,R9,R2, LSR R7
   \   00000400   0AB1C0E7           STRB     R11,[R0, +R10, LSL #+2]
   \   00000404   01E0DDE5           LDRB     LR,[SP, #+1]
   \   00000408   01B080E2           ADD      R11,R0,#+1
   \   0000040C   000059E3           CMP      R9,#+0
   \   00000410   0AE1CBE7           STRB     LR,[R11, +R10, LSL #+2]
   \   00000414   02B080E2           ADD      R11,R0,#+2
   \   00000418   0AA18BE0           ADD      R10,R11,R10, LSL #+2
   \   0000041C   B2B0DDE1           LDRH     R11,[SP, #+2]
   \   00000420   B0B0CAE1           STRH     R11,[R10, #+0]
   \   00000424   F1FFFF1A           BNE      ??inflate_table_34
   \   00000428   019045E2           SUB      R9,R5,#+1
   \   0000042C   1C99A0E1           LSL      R9,R12,R9
   \   00000430   020019E1           TST      R9,R2
   \   00000434   0200000A           BEQ      ??inflate_table_35
   \                     ??inflate_table_36:
   \   00000438   A990A0E1           LSR      R9,R9,#+1
   \   0000043C   020019E1           TST      R9,R2
   \   00000440   FCFFFF1A           BNE      ??inflate_table_36
   \                     ??inflate_table_35:
   \   00000444   000059E3           CMP      R9,#+0
   \   00000448   0300000A           BEQ      ??inflate_table_37
   \   0000044C   01A049E2           SUB      R10,R9,#+1
   \   00000450   02200AE0           AND      R2,R10,R2
   \   00000454   022089E0           ADD      R2,R9,R2
   \   00000458   000000EA           B        ??inflate_table_38
   \                     ??inflate_table_37:
   \   0000045C   0020A0E3           MOV      R2,#+0
   \                     ??inflate_table_38:
   \   00000460   24908DE2           ADD      R9,SP,#+36
   \   00000464   859089E0           ADD      R9,R9,R5, LSL #+1
   \   00000468   B0A0D9E1           LDRH     R10,[R9, #+0]
   \   0000046C   016086E2           ADD      R6,R6,#+1
   \   00000470   FFB0A0E3           MOV      R11,#+255
   \   00000474   FFBC8BE3           ORR      R11,R11,#0xFF00
   \   00000478   0AA08BE0           ADD      R10,R11,R10
   \   0000047C   B0A0C9E1           STRH     R10,[R9, #+0]
   \   00000480   0AA8B0E1           LSLS     R10,R10,#+16
   \   00000484   0700001A           BNE      ??inflate_table_39
   \   00000488   030055E1           CMP      R5,R3
   \   0000048C   1600000A           BEQ      ??inflate_table_40
   \   00000490   98509DE5           LDR      R5,[SP, #+152]
   \   00000494   68909DE5           LDR      R9,[SP, #+104]
   \   00000498   865085E0           ADD      R5,R5,R6, LSL #+1
   \   0000049C   B050D5E1           LDRH     R5,[R5, #+0]
   \   000004A0   855089E0           ADD      R5,R9,R5, LSL #+1
   \   000004A4   B050D5E1           LDRH     R5,[R5, #+0]
   \                     ??inflate_table_39:
   \   000004A8   04909DE5           LDR      R9,[SP, #+4]
   \   000004AC   050059E1           CMP      R9,R5
   \   000004B0   AFFFFF2A           BCS      ??inflate_table_24
   \   000004B4   1C909DE5           LDR      R9,[SP, #+28]
   \   000004B8   02A009E0           AND      R10,R9,R2
   \   000004BC   08909DE5           LDR      R9,[SP, #+8]
   \   000004C0   09005AE1           CMP      R10,R9
   \   000004C4   AAFFFF0A           BEQ      ??inflate_table_24
   \   000004C8   000057E3           CMP      R7,#+0
   \   000004CC   04709D05           LDREQ    R7,[SP, #+4]
   \   000004D0   040180E0           ADD      R0,R0,R4, LSL #+2
   \   000004D4   078045E0           SUB      R8,R5,R7
   \   000004D8   1C98A0E1           LSL      R9,R12,R8
   \   000004DC   81FFFFEA           B        ??inflate_table_27
    292                  }
    293              }
    294          
    295              /*
    296                 Fill in rest of table for incomplete codes.  This loop is similar to the
    297                 loop above in incrementing huff for table indices.  It is assumed that
    298                 len is equal to curr + drop, so there is no loop needed to increment
    299                 through high index bits.  When the current sub-table is filled, the loop
    300                 drops back to the root table to fill in any remaining entries there.
    301               */
    302              this.op = (unsigned char)64;                /* invalid code marker */
    303              this.bits = (unsigned char)(len - drop);
    304              this.val = (unsigned short)0;
    305              while (huff != 0) {
    306                  /* when done with sub-table, drop back to root table */
    307                  if (drop != 0 && (huff & mask) != low) {
    308                      drop = 0;
    309                      len = root;
    310                      next = *table;
    311                      this.bits = (unsigned char)len;
    312                  }
    313          
    314                  /* put invalid code marker in table */
    315                  next[huff >> drop] = this;
    316          
    317                  /* backwards increment the len-bit code huff */
    318                  incr = 1U << (len - 1);
    319                  while (huff & incr)
    320                      incr >>= 1;
    321                  if (incr != 0) {
    322                      huff &= incr - 1;
    323                      huff += incr;
   \                     ??inflate_table_41:
   \   000004E0   013049E2           SUB      R3,R9,#+1
   \   000004E4   022003E0           AND      R2,R3,R2
   \   000004E8   022089E0           ADD      R2,R9,R2
    324                  }
   \                     ??inflate_table_40:
   \   000004EC   000052E3           CMP      R2,#+0
   \   000004F0   1B00000A           BEQ      ??inflate_table_42
   \   000004F4   000057E3           CMP      R7,#+0
   \   000004F8   0900000A           BEQ      ??inflate_table_43
   \   000004FC   1C309DE5           LDR      R3,[SP, #+28]
   \   00000500   08409DE5           LDR      R4,[SP, #+8]
   \   00000504   023003E0           AND      R3,R3,R2
   \   00000508   040053E1           CMP      R3,R4
   \   0000050C   0400000A           BEQ      ??inflate_table_43
   \   00000510   04509DE5           LDR      R5,[SP, #+4]
   \   00000514   6C009DE5           LDR      R0,[SP, #+108]
   \   00000518   0070A0E3           MOV      R7,#+0
   \   0000051C   000090E5           LDR      R0,[R0, #+0]
   \   00000520   0150CDE5           STRB     R5,[SP, #+1]
   \                     ??inflate_table_43:
   \   00000524   3237A0E1           LSR      R3,R2,R7
   \   00000528   033180E0           ADD      R3,R0,R3, LSL #+2
   \   0000052C   4040A0E3           MOV      R4,#+64
   \   00000530   0040C3E5           STRB     R4,[R3, #+0]
   \   00000534   0140DDE5           LDRB     R4,[SP, #+1]
   \   00000538   0140C3E5           STRB     R4,[R3, #+1]
   \   0000053C   B210C3E1           STRH     R1,[R3, #+2]
   \   00000540   013045E2           SUB      R3,R5,#+1
   \   00000544   1C93A0E1           LSL      R9,R12,R3
   \   00000548   020019E1           TST      R9,R2
   \   0000054C   0200000A           BEQ      ??inflate_table_44
   \                     ??inflate_table_45:
   \   00000550   A990A0E1           LSR      R9,R9,#+1
   \   00000554   020019E1           TST      R9,R2
   \   00000558   FCFFFF1A           BNE      ??inflate_table_45
   \                     ??inflate_table_44:
   \   0000055C   000059E3           CMP      R9,#+0
   \   00000560   DEFFFF1A           BNE      ??inflate_table_41
    325                  else
    326                      huff = 0;
    327              }
    328          
    329              /* set return parameters */
    330              *table += used;
   \                     ??inflate_table_42:
   \   00000564   6C009DE5           LDR      R0,[SP, #+108]
   \   00000568   0C109DE5           LDR      R1,[SP, #+12]
   \   0000056C   002090E5           LDR      R2,[R0, #+0]
   \   00000570   011182E0           ADD      R1,R2,R1, LSL #+2
   \   00000574   001080E5           STR      R1,[R0, #+0]
    331              *bits = root;
   \   00000578   94009DE5           LDR      R0,[SP, #+148]
   \   0000057C   04109DE5           LDR      R1,[SP, #+4]
   \   00000580   001080E5           STR      R1,[R0, #+0]
    332              return 0;
   \   00000584   0000A0E3           MOV      R0,#+0
   \   00000588   70D08DE2           ADD      SP,SP,#+112
   \   0000058C   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??inflate_table_23:
   \   00000590   ........           DC32     ??lbase
   \   00000594   ........           DC32     ??lext
   \   00000598   ........           DC32     ??dbase
   \   0000059C   ........           DC32     ??dext
    333          }

   \                                 In segment DATA_C, align 4, align-sorted
   \                     ??lbase:
   \   00000000   030004000500       DC16 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43
   \              060007000800
   \              09000A000B00
   \              0D000F001100
   \              130017001B00
   \              1F0023002B00
   \   00000024   33003B004300       DC16 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
   \              530063007300
   \              8300A300C300
   \              E30002010000
   \              0000        
   \   0000003E   0000               DC8 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     ??lext:
   \   00000000   100010001000       DC16 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19
   \              100010001000
   \              100010001100
   \              110011001100
   \              120012001200
   \              12001300    
   \   00000022   130013001300       DC16 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 201, 196
   \              140014001400
   \              140015001500
   \              150015001000
   \              C900C400    
   \   0000003E   0000               DC8 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     ??dbase:
   \   00000000   010002000300       DC16 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257
   \              040005000700
   \              09000D001100
   \              190021003100
   \              410061008100
   \              C1000101    
   \   00000022   810101020103       DC16 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289
   \              010401060108
   \              010C01100118
   \              01200130    
   \   00000038   014001600000       DC16 16385, 24577, 0, 0
   \              0000        

   \                                 In segment DATA_C, align 4, align-sorted
   \                     ??dext:
   \   00000000   100010001000       DC16 16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23
   \              100011001100
   \              120012001300
   \              130014001400
   \              150015001600
   \              16001700    
   \   00000022   170018001800       DC16 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64
   \              190019001A00
   \              1A001B001B00
   \              1C001C001D00
   \              1D0040004000

   Maximum stack usage in bytes:

     Function      CSTACK
     --------      ------
     inflate_table   148


   Segment part sizes:

     Function/Label    Bytes
     --------------    -----
     inflate_copyright   48
     inflate_table     1440
     lbase               64
     lext                64
     dbase               64
     dext                64
      Others              4

 
 1 444 bytes in segment CODE
   304 bytes in segment DATA_C
 
 1 440 bytes of CODE  memory (+ 4 bytes shared)
   304 bytes of CONST memory

Errors: none
Warnings: none
