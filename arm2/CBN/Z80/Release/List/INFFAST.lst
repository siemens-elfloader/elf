##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    31/Mar/2011  22:53:46 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\CBN\Arc\Zlib\INFFAST.C                        #
#    Command line    =  C:\arm\CBN\Arc\Zlib\INFFAST.C -D NEWSGOLD -D UNPACK  #
#                       -lC C:\arm\CBN\Z80\Release\List\ -o                  #
#                       C:\arm\CBN\Z80\Release\Obj\ -s9 --no_unroll          #
#                       --no_clustering --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --char_is_signed --fpu None -I "C:\arm2\Embedded     #
#                       Workbench 4.0 Evaluation\ARM\INC\"                   #
#                       --inline_threshold=2                                 #
#    List file       =  C:\arm\CBN\Z80\Release\List\INFFAST.lst              #
#    Object file     =  C:\arm\CBN\Z80\Release\Obj\INFFAST.r79               #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\CBN\Arc\Zlib\INFFAST.C
      1          /* inffast.c -- fast decoding
      2           * Copyright (C) 1995-2004 Mark Adler
      3           * For conditions of distribution and use, see copyright notice in zlib.h
      4           */
      5          
      6          #include "zutil.h"
      7          #include "inftrees.h"
      8          #include "inflate.h"
      9          #include "inffast.h"
     10          
     11          #ifndef ASMINF
     12          
     13          /* Allow machine dependent optimization for post-increment or pre-increment.
     14             Based on testing to date,
     15             Pre-increment preferred for:
     16             - PowerPC G3 (Adler)
     17             - MIPS R5000 (Randers-Pehrson)
     18             Post-increment preferred for:
     19             - none
     20             No measurable difference:
     21             - Pentium III (Anderson)
     22             - M68060 (Nikl)
     23           */
     24          #ifdef POSTINC
     25          #  define OFF 0
     26          #  define PUP(a) *(a)++
     27          #else
     28          #  define OFF 1
     29          #  define PUP(a) *++(a)
     30          #endif
     31          
     32          /*
     33             Decode literal, length, and distance codes and write out the resulting
     34             literal and match bytes until either not enough input or output is
     35             available, an end-of-block is encountered, or a data error is encountered.
     36             When large enough input and output buffers are supplied to inflate(), for
     37             example, a 16K input buffer and a 64K output buffer, more than 95% of the
     38             inflate execution time is spent in this routine.
     39          
     40             Entry assumptions:
     41          
     42                  state->mode == LEN
     43                  strm->avail_in >= 6
     44                  strm->avail_out >= 258
     45                  start >= strm->avail_out
     46                  state->bits < 8
     47          
     48             On return, state->mode is one of:
     49          
     50                  LEN -- ran out of enough output space or enough available input
     51                  TYPE -- reached end of block code, inflate() to interpret next block
     52                  BAD -- error in block data
     53          
     54             Notes:
     55          
     56              - The maximum input bits used by a length/distance pair is 15 bits for the
     57                length code, 5 bits for the length extra, 15 bits for the distance code,
     58                and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
     59                Therefore if strm->avail_in >= 6, then there is enough input to avoid
     60                checking for available input while decoding.
     61          
     62              - The maximum bytes that a single length/distance pair can output is 258
     63                bytes, which is the maximum length that can be coded.  inflate_fast()
     64                requires strm->avail_out >= 258 for each loop to avoid checking for
     65                output space.
     66           */

   \                                 In segment CODE, align 4, keep-with-next
     67          void inflate_fast(strm, start)
     68          z_streamp strm;
     69          unsigned start;         /* inflate()'s starting value for strm->avail_out */
     70          {
   \                     inflate_fast:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   2CD04DE2           SUB      SP,SP,#+44
   \   00000008   0020A0E1           MOV      R2,R0
     71              struct inflate_state FAR *state;
     72              unsigned char FAR *in;      /* local strm->next_in */
     73              unsigned char FAR *last;    /* while in < last, enough input available */
     74              unsigned char FAR *out;     /* local strm->next_out */
     75              unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
     76              unsigned char FAR *end;     /* while out < end, enough space available */
     77          #ifdef INFLATE_STRICT
     78              unsigned dmax;              /* maximum distance from zlib header */
     79          #endif
     80              unsigned wsize;             /* window size or zero if not using window */
     81              unsigned whave;             /* valid bytes in the window */
     82              unsigned write;             /* window write index */
     83              unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
     84              unsigned long hold;         /* local strm->hold */
     85              unsigned bits;              /* local strm->bits */
     86              code const FAR *lcode;      /* local strm->lencode */
     87              code const FAR *dcode;      /* local strm->distcode */
     88              unsigned lmask;             /* mask for first level of length codes */
     89              unsigned dmask;             /* mask for first level of distance codes */
     90              code this;                  /* retrieved table entry */
     91              unsigned op;                /* code bits, operation, extra bits, or */
     92                                          /*  window position, window bytes to copy */
     93              unsigned len;               /* match length, unused bytes */
     94              unsigned dist;              /* match distance */
     95              unsigned char FAR *from;    /* where to copy match from */
     96          
     97              /* copy state to local variables */
     98              state = (struct inflate_state FAR *)strm->state;
     99              in = strm->next_in - OFF;
   \   0000000C   000092E5           LDR      R0,[R2, #+0]
    100              last = in + (strm->avail_in - 5);
   \   00000010   043092E5           LDR      R3,[R2, #+4]
   \   00000014   1CC092E5           LDR      R12,[R2, #+28]
   \   00000018   014040E2           SUB      R4,R0,#+1
   \   0000001C   043083E0           ADD      R3,R3,R4
   \   00000020   053043E2           SUB      R3,R3,#+5
   \   00000024   14308DE5           STR      R3,[SP, #+20]
    101              out = strm->next_out - OFF;
   \   00000028   0C0092E5           LDR      R0,[R2, #+12]
    102              beg = out - (start - strm->avail_out);
    103              end = out + (strm->avail_out - 257);
   \   0000002C   405FE0E3           MVN      R5,#+256
   \   00000030   013040E2           SUB      R3,R0,#+1
   \   00000034   100092E5           LDR      R0,[R2, #+16]
   \   00000038   001041E0           SUB      R1,R1,R0
   \   0000003C   001061E2           RSB      R1,R1,#+0
   \   00000040   031081E0           ADD      R1,R1,R3
   \   00000044   1C108DE5           STR      R1,[SP, #+28]
   \   00000048   030080E0           ADD      R0,R0,R3
   \   0000004C   000085E0           ADD      R0,R5,R0
   \   00000050   18008DE5           STR      R0,[SP, #+24]
    104          #ifdef INFLATE_STRICT
    105              dmax = state->dmax;
    106          #endif
    107              wsize = state->wsize;
   \   00000054   28109CE5           LDR      R1,[R12, #+40]
   \   00000058   04108DE5           STR      R1,[SP, #+4]
    108              whave = state->whave;
   \   0000005C   2C109CE5           LDR      R1,[R12, #+44]
   \   00000060   20108DE5           STR      R1,[SP, #+32]
    109              write = state->write;
    110              window = state->window;
   \   00000064   34109CE5           LDR      R1,[R12, #+52]
   \   00000068   30609CE5           LDR      R6,[R12, #+48]
   \   0000006C   08108DE5           STR      R1,[SP, #+8]
    111              hold = state->hold;
    112              bits = state->bits;
    113              lcode = state->lencode;
   \   00000070   4C109CE5           LDR      R1,[R12, #+76]
   \   00000074   38509CE5           LDR      R5,[R12, #+56]
   \   00000078   3C709CE5           LDR      R7,[R12, #+60]
   \   0000007C   0C108DE5           STR      R1,[SP, #+12]
    114              dcode = state->distcode;
   \   00000080   50109CE5           LDR      R1,[R12, #+80]
   \   00000084   10108DE5           STR      R1,[SP, #+16]
    115              lmask = (1U << state->lenbits) - 1;
   \   00000088   54809CE5           LDR      R8,[R12, #+84]
   \   0000008C   0110A0E3           MOV      R1,#+1
   \   00000090   1188A0E1           LSL      R8,R1,R8
   \   00000094   018048E2           SUB      R8,R8,#+1
   \   00000098   24808DE5           STR      R8,[SP, #+36]
    116              dmask = (1U << state->distbits) - 1;
   \   0000009C   58809CE5           LDR      R8,[R12, #+88]
   \   000000A0   1188A0E1           LSL      R8,R1,R8
   \   000000A4   018048E2           SUB      R8,R8,#+1
   \   000000A8   28808DE5           STR      R8,[SP, #+40]
    117          
    118              /* decode literals and length/distances until end-of-block or not enough
    119                 input data or output space */
    120              do {
    121                  if (bits < 15) {
   \                     ??inflate_fast_0:
   \   000000AC   0F0057E3           CMP      R7,#+15
   \   000000B0   0600002A           BCS      ??inflate_fast_1
    122                      hold += (unsigned long)(PUP(in)) << bits;
   \   000000B4   014084E2           ADD      R4,R4,#+1
   \   000000B8   ........           LDRB     R0,[R4], #+1
   \   000000BC   100785E0           ADD      R0,R5,R0, LSL R7
    123                      bits += 8;
    124                      hold += (unsigned long)(PUP(in)) << bits;
   \   000000C0   0050D4E5           LDRB     R5,[R4, #+0]
   \   000000C4   087087E2           ADD      R7,R7,#+8
   \   000000C8   155780E0           ADD      R5,R0,R5, LSL R7
    125                      bits += 8;
   \   000000CC   087087E2           ADD      R7,R7,#+8
    126                  }
    127                  this = lcode[hold & lmask];
   \                     ??inflate_fast_1:
   \   000000D0   24809DE5           LDR      R8,[SP, #+36]
   \   000000D4   0C909DE5           LDR      R9,[SP, #+12]
   \   000000D8   058008E0           AND      R8,R8,R5
   \   000000DC   088189E0           ADD      R8,R9,R8, LSL #+2
   \   000000E0   B090D8E1           LDRH     R9,[R8, #0]
   \   000000E4   0D00A0E1           MOV      R0,SP
   \   000000E8   B090C0E1           STRH     R9,[R0, #+0]
   \   000000EC   B290D8E1           LDRH     R9,[R8, #+2]
   \   000000F0   B290C0E1           STRH     R9,[R0, #+2]
   \   000000F4   0D90A0E1           MOV      R9,SP
   \   000000F8   090000EA           B        ??inflate_fast_2
    128                dolen:
    129                  op = (unsigned)(this.bits);
    130                  hold >>= op;
    131                  bits -= op;
    132                  op = (unsigned)(this.op);
    133                  if (op == 0) {                          /* literal */
    134                      Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
    135                              "inflate:         literal '%c'\n" :
    136                              "inflate:         literal 0x%02x\n", this.val));
    137                      PUP(out) = (unsigned char)(this.val);
    138                  }
    139                  else if (op & 16) {                     /* length base */
    140                      len = (unsigned)(this.val);
    141                      op &= 15;                           /* number of extra bits */
    142                      if (op) {
    143                          if (bits < op) {
    144                              hold += (unsigned long)(PUP(in)) << bits;
    145                              bits += 8;
    146                          }
    147                          len += (unsigned)hold & ((1U << op) - 1);
    148                          hold >>= op;
    149                          bits -= op;
    150                      }
    151                      Tracevv((stderr, "inflate:         length %u\n", len));
    152                      if (bits < 15) {
    153                          hold += (unsigned long)(PUP(in)) << bits;
    154                          bits += 8;
    155                          hold += (unsigned long)(PUP(in)) << bits;
    156                          bits += 8;
    157                      }
    158                      this = dcode[hold & dmask];
    159                    dodist:
    160                      op = (unsigned)(this.bits);
    161                      hold >>= op;
    162                      bits -= op;
    163                      op = (unsigned)(this.op);
    164                      if (op & 16) {                      /* distance base */
    165                          dist = (unsigned)(this.val);
    166                          op &= 15;                       /* number of extra bits */
    167                          if (bits < op) {
    168                              hold += (unsigned long)(PUP(in)) << bits;
    169                              bits += 8;
    170                              if (bits < op) {
    171                                  hold += (unsigned long)(PUP(in)) << bits;
    172                                  bits += 8;
    173                              }
    174                          }
    175                          dist += (unsigned)hold & ((1U << op) - 1);
    176          #ifdef INFLATE_STRICT
    177                          if (dist > dmax) {
    178                              strm->msg = (char *)"invalid distance too far back";
    179                              state->mode = BAD;
    180                              break;
    181                          }
    182          #endif
    183                          hold >>= op;
    184                          bits -= op;
    185                          Tracevv((stderr, "inflate:         distance %u\n", dist));
    186                          op = (unsigned)(out - beg);     /* max distance in output */
    187                          if (dist > op) {                /* see if copy from window */
    188                              op = dist - op;             /* distance back in window */
    189                              if (op > whave) {
    190                                  strm->msg = (char *)"invalid distance too far back";
    191                                  state->mode = BAD;
    192                                  break;
    193                              }
    194                              from = window - OFF;
    195                              if (write == 0) {           /* very common case */
    196                                  from += wsize - op;
    197                                  if (op < len) {         /* some from window */
    198                                      len -= op;
    199                                      do {
    200                                          PUP(out) = PUP(from);
    201                                      } while (--op);
    202                                      from = out - dist;  /* rest from output */
    203                                  }
    204                              }
    205                              else if (write < op) {      /* wrap around window */
    206                                  from += wsize + write - op;
    207                                  op -= write;
    208                                  if (op < len) {         /* some from end of window */
    209                                      len -= op;
    210                                      do {
    211                                          PUP(out) = PUP(from);
    212                                      } while (--op);
    213                                      from = window - OFF;
    214                                      if (write < len) {  /* some from start of window */
    215                                          op = write;
    216                                          len -= op;
    217                                          do {
    218                                              PUP(out) = PUP(from);
    219                                          } while (--op);
    220                                          from = out - dist;      /* rest from output */
    221                                      }
    222                                  }
    223                              }
    224                              else {                      /* contiguous in window */
    225                                  from += write - op;
    226                                  if (op < len) {         /* some from window */
    227                                      len -= op;
    228                                      do {
    229                                          PUP(out) = PUP(from);
    230                                      } while (--op);
    231                                      from = out - dist;  /* rest from output */
    232                                  }
    233                              }
    234                              while (len > 2) {
    235                                  PUP(out) = PUP(from);
    236                                  PUP(out) = PUP(from);
    237                                  PUP(out) = PUP(from);
    238                                  len -= 3;
    239                              }
    240                              if (len) {
    241                                  PUP(out) = PUP(from);
    242                                  if (len > 1)
    243                                      PUP(out) = PUP(from);
    244                              }
    245                          }
    246                          else {
    247                              from = out - dist;          /* copy direct from output */
    248                              do {                        /* minimum length is three */
    249                                  PUP(out) = PUP(from);
    250                                  PUP(out) = PUP(from);
    251                                  PUP(out) = PUP(from);
    252                                  len -= 3;
    253                              } while (len > 2);
    254                              if (len) {
    255                                  PUP(out) = PUP(from);
    256                                  if (len > 1)
    257                                      PUP(out) = PUP(from);
    258                              }
    259                          }
    260                      }
    261                      else if ((op & 64) == 0) {          /* 2nd level distance code */
    262                          this = dcode[this.val + (hold & ((1U << op) - 1))];
    263                          goto dodist;
    264                      }
    265                      else {
    266                          strm->msg = (char *)"invalid distance code";
    267                          state->mode = BAD;
    268                          break;
    269                      }
    270                  }
    271                  else if ((op & 64) == 0) {              /* 2nd level length code */
    272                      this = lcode[this.val + (hold & ((1U << op) - 1))];
   \                     ??inflate_fast_3:
   \   000000FC   1188A0E1           LSL      R8,R1,R8
   \   00000100   018048E2           SUB      R8,R8,#+1
   \   00000104   058008E0           AND      R8,R8,R5
   \   00000108   000088E0           ADD      R0,R8,R0
   \   0000010C   0C809DE5           LDR      R8,[SP, #+12]
   \   00000110   000188E0           ADD      R0,R8,R0, LSL #+2
   \   00000114   B080D0E1           LDRH     R8,[R0, #0]
   \   00000118   B080C9E1           STRH     R8,[R9, #+0]
   \   0000011C   B280D0E1           LDRH     R8,[R0, #+2]
   \   00000120   B280C9E1           STRH     R8,[R9, #+2]
    273                      goto dolen;
    274                  }
   \                     ??inflate_fast_2:
   \   00000124   0100DDE5           LDRB     R0,[SP, #+1]
   \   00000128   0080DDE5           LDRB     R8,[SP, #+0]
   \   0000012C   3550A0E1           LSR      R5,R5,R0
   \   00000130   007047E0           SUB      R7,R7,R0
   \   00000134   B200DDE1           LDRH     R0,[SP, #+2]
   \   00000138   000058E3           CMP      R8,#+0
   \   0000013C   1500001A           BNE      ??inflate_fast_4
   \                     ??inflate_fast_5:
   \   00000140   0100E3E5           STRB     R0,[R3, #+1]!
    275                  else if (op & 32) {                     /* end-of-block */
    276                      Tracevv((stderr, "inflate:         end of block\n"));
    277                      state->mode = TYPE;
    278                      break;
    279                  }
    280                  else {
    281                      strm->msg = (char *)"invalid literal/length code";
    282                      state->mode = BAD;
    283                      break;
    284                  }
    285              } while (in < last && out < end);
   \                     ??inflate_fast_6:
   \   00000144   14009DE5           LDR      R0,[SP, #+20]
   \   00000148   000054E1           CMP      R4,R0
   \   0000014C   18009D35           LDRCC    R0,[SP, #+24]
   \   00000150   00005331           CMPCC    R3,R0
   \   00000154   D4FFFF3A           BCC      ??inflate_fast_0
    286          
    287              /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
    288              len = bits >> 3;
   \                     ??inflate_fast_7:
   \   00000158   A701A0E1           LSR      R0,R7,#+3
    289              in -= len;
   \   0000015C   0060A0E1           MOV      R6,R0
   \   00000160   006066E2           RSB      R6,R6,#+0
   \   00000164   044086E0           ADD      R4,R6,R4
    290              bits -= len << 3;
    291              hold &= (1U << bits) - 1;
    292          
    293              /* update state and return */
    294              strm->next_in = in + OFF;
   \   00000168   016084E2           ADD      R6,R4,#+1
   \   0000016C   006082E5           STR      R6,[R2, #+0]
    295              strm->next_out = out + OFF;
   \   00000170   016083E2           ADD      R6,R3,#+1
   \   00000174   0C6082E5           STR      R6,[R2, #+12]
    296              strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
   \   00000178   14609DE5           LDR      R6,[SP, #+20]
   \   0000017C   800147E0           SUB      R0,R7,R0, LSL #+3
   \   00000180   060054E1           CMP      R4,R6
   \   00000184   05406422           RSBCS    R4,R4,#+5
   \   00000188   04408620           ADDCS    R4,R6,R4
   \   0000018C   04404630           SUBCC    R4,R6,R4
   \   00000190   05408432           ADDCC    R4,R4,#+5
   \   00000194   B10000EA           B        ??inflate_fast_8
   \                     ??inflate_fast_4:
   \   00000198   100018E3           TST      R8,#0x10
   \   0000019C   A700000A           BEQ      ??inflate_fast_9
   \   000001A0   0F8018E2           ANDS     R8,R8,#0xF
   \   000001A4   0900000A           BEQ      ??inflate_fast_10
   \   000001A8   080057E1           CMP      R7,R8
   \   000001AC   0190F435           LDRBCC   R9,[R4, #+1]!
   \   000001B0   19578530           ADDCC    R5,R5,R9, LSL R7
   \   000001B4   08708732           ADDCC    R7,R7,#+8
   \   000001B8   1198A0E1           LSL      R9,R1,R8
   \   000001BC   019049E2           SUB      R9,R9,#+1
   \   000001C0   059009E0           AND      R9,R9,R5
   \   000001C4   000089E0           ADD      R0,R9,R0
   \   000001C8   3558A0E1           LSR      R5,R5,R8
   \   000001CC   087047E0           SUB      R7,R7,R8
   \                     ??inflate_fast_10:
   \   000001D0   0F0057E3           CMP      R7,#+15
   \   000001D4   0600002A           BCS      ??inflate_fast_11
   \   000001D8   014084E2           ADD      R4,R4,#+1
   \   000001DC   ........           LDRB     R8,[R4], #+1
   \   000001E0   185785E0           ADD      R5,R5,R8, LSL R7
   \   000001E4   0080D4E5           LDRB     R8,[R4, #+0]
   \   000001E8   087087E2           ADD      R7,R7,#+8
   \   000001EC   185785E0           ADD      R5,R5,R8, LSL R7
   \   000001F0   087087E2           ADD      R7,R7,#+8
   \                     ??inflate_fast_11:
   \   000001F4   28909DE5           LDR      R9,[SP, #+40]
   \   000001F8   10A09DE5           LDR      R10,[SP, #+16]
   \   000001FC   059009E0           AND      R9,R9,R5
   \   00000200   09918AE0           ADD      R9,R10,R9, LSL #+2
   \   00000204   B0A0D9E1           LDRH     R10,[R9, #0]
   \   00000208   0D80A0E1           MOV      R8,SP
   \   0000020C   B0A0C8E1           STRH     R10,[R8, #+0]
   \   00000210   B2A0D9E1           LDRH     R10,[R9, #+2]
   \   00000214   B2A0C8E1           STRH     R10,[R8, #+2]
   \   00000218   0DA0A0E1           MOV      R10,SP
   \   0000021C   090000EA           B        ??inflate_fast_12
   \                     ??inflate_fast_13:
   \   00000220   1188A0E1           LSL      R8,R1,R8
   \   00000224   018048E2           SUB      R8,R8,#+1
   \   00000228   058008E0           AND      R8,R8,R5
   \   0000022C   098088E0           ADD      R8,R8,R9
   \   00000230   10909DE5           LDR      R9,[SP, #+16]
   \   00000234   088189E0           ADD      R8,R9,R8, LSL #+2
   \   00000238   B090D8E1           LDRH     R9,[R8, #0]
   \   0000023C   B090CAE1           STRH     R9,[R10, #+0]
   \   00000240   B290D8E1           LDRH     R9,[R8, #+2]
   \   00000244   B290CAE1           STRH     R9,[R10, #+2]
   \                     ??inflate_fast_12:
   \   00000248   0180DDE5           LDRB     R8,[SP, #+1]
   \   0000024C   3558A0E1           LSR      R5,R5,R8
   \   00000250   B290DDE1           LDRH     R9,[SP, #+2]
   \   00000254   087047E0           SUB      R7,R7,R8
   \   00000258   0080DDE5           LDRB     R8,[SP, #+0]
   \   0000025C   100018E3           TST      R8,#0x10
   \   00000260   7200000A           BEQ      ??inflate_fast_14
   \   00000264   0F8008E2           AND      R8,R8,#0xF
   \   00000268   080057E1           CMP      R7,R8
   \   0000026C   0600002A           BCS      ??inflate_fast_15
   \   00000270   01A0F4E5           LDRB     R10,[R4, #+1]!
   \   00000274   1A5785E0           ADD      R5,R5,R10, LSL R7
   \   00000278   087087E2           ADD      R7,R7,#+8
   \   0000027C   080057E1           CMP      R7,R8
   \   00000280   01A0F435           LDRBCC   R10,[R4, #+1]!
   \   00000284   1A578530           ADDCC    R5,R5,R10, LSL R7
   \   00000288   08708732           ADDCC    R7,R7,#+8
   \                     ??inflate_fast_15:
   \   0000028C   11A8A0E1           LSL      R10,R1,R8
   \   00000290   01A04AE2           SUB      R10,R10,#+1
   \   00000294   05A00AE0           AND      R10,R10,R5
   \   00000298   3558A0E1           LSR      R5,R5,R8
   \   0000029C   087047E0           SUB      R7,R7,R8
   \   000002A0   1C809DE5           LDR      R8,[SP, #+28]
   \   000002A4   09908AE0           ADD      R9,R10,R9
   \   000002A8   088043E0           SUB      R8,R3,R8
   \   000002AC   090058E1           CMP      R8,R9
   \   000002B0   5000002A           BCS      ??inflate_fast_16
   \   000002B4   20A09DE5           LDR      R10,[SP, #+32]
   \   000002B8   088049E0           SUB      R8,R9,R8
   \   000002BC   08005AE1           CMP      R10,R8
   \   000002C0   0400002A           BCS      ??inflate_fast_17
   \   000002C4   D4019FE5           LDR      R0,??inflate_fast_18  ;; `?<Constant "invalid distance too ...">`
   \                     ??inflate_fast_19:
   \   000002C8   180082E5           STR      R0,[R2, #+24]
   \   000002CC   1B00A0E3           MOV      R0,#+27
   \   000002D0   0000CCE5           STRB     R0,[R12, #+0]
   \   000002D4   9FFFFFEA           B        ??inflate_fast_7
   \                     ??inflate_fast_17:
   \   000002D8   08A09DE5           LDR      R10,[SP, #+8]
   \   000002DC   000056E3           CMP      R6,#+0
   \   000002E0   01B04AE2           SUB      R11,R10,#+1
   \   000002E4   08A040E0           SUB      R10,R0,R8
   \   000002E8   0C00001A           BNE      ??inflate_fast_20
   \   000002EC   04E09DE5           LDR      LR,[SP, #+4]
   \   000002F0   000058E1           CMP      R8,R0
   \   000002F4   08E04EE0           SUB      LR,LR,R8
   \   000002F8   0BB08EE0           ADD      R11,LR,R11
   \   000002FC   3300002A           BCS      ??inflate_fast_21
   \   00000300   0A00A0E1           MOV      R0,R10
   \                     ??inflate_fast_22:
   \   00000304   01A0FBE5           LDRB     R10,[R11, #+1]!
   \   00000308   018058E2           SUBS     R8,R8,#+1
   \   0000030C   01A0E3E5           STRB     R10,[R3, #+1]!
   \   00000310   FBFFFF1A           BNE      ??inflate_fast_22
   \                     ??inflate_fast_23:
   \   00000314   008069E2           RSB      R8,R9,#+0
   \   00000318   03B088E0           ADD      R11,R8,R3
   \   0000031C   2B0000EA           B        ??inflate_fast_21
   \                     ??inflate_fast_20:
   \   00000320   080056E1           CMP      R6,R8
   \   00000324   1600002A           BCS      ??inflate_fast_24
   \   00000328   04A09DE5           LDR      R10,[SP, #+4]
   \   0000032C   0AA086E0           ADD      R10,R6,R10
   \   00000330   08A04AE0           SUB      R10,R10,R8
   \   00000334   0BB08AE0           ADD      R11,R10,R11
   \   00000338   068048E0           SUB      R8,R8,R6
   \   0000033C   000058E1           CMP      R8,R0
   \   00000340   2200002A           BCS      ??inflate_fast_21
   \   00000344   080040E0           SUB      R0,R0,R8
   \                     ??inflate_fast_25:
   \   00000348   01A0FBE5           LDRB     R10,[R11, #+1]!
   \   0000034C   018058E2           SUBS     R8,R8,#+1
   \   00000350   01A0E3E5           STRB     R10,[R3, #+1]!
   \   00000354   FBFFFF1A           BNE      ??inflate_fast_25
   \   00000358   08809DE5           LDR      R8,[SP, #+8]
   \   0000035C   000056E1           CMP      R6,R0
   \   00000360   01B048E2           SUB      R11,R8,#+1
   \   00000364   1900002A           BCS      ??inflate_fast_21
   \   00000368   0680A0E1           MOV      R8,R6
   \   0000036C   080040E0           SUB      R0,R0,R8
   \                     ??inflate_fast_26:
   \   00000370   01A0FBE5           LDRB     R10,[R11, #+1]!
   \   00000374   018058E2           SUBS     R8,R8,#+1
   \   00000378   01A0E3E5           STRB     R10,[R3, #+1]!
   \   0000037C   FBFFFF1A           BNE      ??inflate_fast_26
   \   00000380   E3FFFFEA           B        ??inflate_fast_23
   \                     ??inflate_fast_24:
   \   00000384   08E046E0           SUB      LR,R6,R8
   \   00000388   0BB08EE0           ADD      R11,LR,R11
   \   0000038C   000058E1           CMP      R8,R0
   \   00000390   0E00002A           BCS      ??inflate_fast_21
   \   00000394   0A00A0E1           MOV      R0,R10
   \                     ??inflate_fast_27:
   \   00000398   01A0FBE5           LDRB     R10,[R11, #+1]!
   \   0000039C   018058E2           SUBS     R8,R8,#+1
   \   000003A0   01A0E3E5           STRB     R10,[R3, #+1]!
   \   000003A4   FBFFFF1A           BNE      ??inflate_fast_27
   \   000003A8   D9FFFFEA           B        ??inflate_fast_23
   \                     ??inflate_fast_28:
   \   000003AC   01B08BE2           ADD      R11,R11,#+1
   \   000003B0   ........           LDRB     R8,[R11], #+1
   \   000003B4   013083E2           ADD      R3,R3,#+1
   \   000003B8   030040E2           SUB      R0,R0,#+3
   \   000003BC   ........           STRB     R8,[R3], #+1
   \   000003C0   ........           LDRB     R8,[R11], #+1
   \   000003C4   ........           STRB     R8,[R3], #+1
   \   000003C8   0080DBE5           LDRB     R8,[R11, #+0]
   \   000003CC   0080C3E5           STRB     R8,[R3, #+0]
   \                     ??inflate_fast_21:
   \   000003D0   030050E3           CMP      R0,#+3
   \   000003D4   F4FFFF2A           BCS      ??inflate_fast_28
   \                     ??inflate_fast_29:
   \   000003D8   000050E3           CMP      R0,#+0
   \   000003DC   58FFFF0A           BEQ      ??inflate_fast_6
   \   000003E0   0180FBE5           LDRB     R8,[R11, #+1]!
   \   000003E4   020050E3           CMP      R0,#+2
   \   000003E8   0180E3E5           STRB     R8,[R3, #+1]!
   \   000003EC   54FFFF3A           BCC      ??inflate_fast_6
   \   000003F0   0100DBE5           LDRB     R0,[R11, #+1]
   \   000003F4   51FFFFEA           B        ??inflate_fast_5
   \                     ??inflate_fast_16:
   \   000003F8   008069E2           RSB      R8,R9,#+0
   \   000003FC   03B088E0           ADD      R11,R8,R3
   \                     ??inflate_fast_30:
   \   00000400   01B08BE2           ADD      R11,R11,#+1
   \   00000404   ........           LDRB     R8,[R11], #+1
   \   00000408   013083E2           ADD      R3,R3,#+1
   \   0000040C   030040E2           SUB      R0,R0,#+3
   \   00000410   ........           STRB     R8,[R3], #+1
   \   00000414   ........           LDRB     R8,[R11], #+1
   \   00000418   030050E3           CMP      R0,#+3
   \   0000041C   ........           STRB     R8,[R3], #+1
   \   00000420   0080DBE5           LDRB     R8,[R11, #+0]
   \   00000424   0080C3E5           STRB     R8,[R3, #+0]
   \   00000428   F4FFFF2A           BCS      ??inflate_fast_30
   \   0000042C   E9FFFFEA           B        ??inflate_fast_29
   \                     ??inflate_fast_14:
   \   00000430   400018E3           TST      R8,#0x40
   \   00000434   79FFFF0A           BEQ      ??inflate_fast_13
   \   00000438   64009FE5           LDR      R0,??inflate_fast_18+0x4  ;; `?<Constant "invalid distance code">`
   \   0000043C   A1FFFFEA           B        ??inflate_fast_19
   \                     ??inflate_fast_9:
   \   00000440   400018E3           TST      R8,#0x40
   \   00000444   2CFFFF0A           BEQ      ??inflate_fast_3
   \   00000448   200018E3           TST      R8,#0x20
   \   0000044C   0B00A013           MOVNE    R0,#+11
   \   00000450   0000CC15           STRBNE   R0,[R12, #+0]
   \   00000454   3FFFFF1A           BNE      ??inflate_fast_7
   \   00000458   48009FE5           LDR      R0,??inflate_fast_18+0x8  ;; `?<Constant "invalid literal/lengt...">`
   \   0000045C   99FFFFEA           B        ??inflate_fast_19
   \                     ??inflate_fast_8:
   \   00000460   044082E5           STR      R4,[R2, #+4]
    297              strm->avail_out = (unsigned)(out < end ?
    298                                           257 + (end - out) : 257 - (out - end));
   \   00000464   18409DE5           LDR      R4,[SP, #+24]
   \   00000468   406F81E3           ORR      R6,R1,#0x100
   \   0000046C   040053E1           CMP      R3,R4
   \   00000470   03304430           SUBCC    R3,R4,R3
   \   00000474   03308630           ADDCC    R3,R6,R3
   \   00000478   03304620           SUBCS    R3,R6,R3
   \   0000047C   03308420           ADDCS    R3,R4,R3
   \   00000480   103082E5           STR      R3,[R2, #+16]
    299              state->hold = hold;
   \   00000484   1110A0E1           LSL      R1,R1,R0
   \   00000488   011041E2           SUB      R1,R1,#+1
   \   0000048C   051001E0           AND      R1,R1,R5
   \   00000490   38108CE5           STR      R1,[R12, #+56]
    300              state->bits = bits;
   \   00000494   3C008CE5           STR      R0,[R12, #+60]
    301              return;
   \   00000498   2CD08DE2           ADD      SP,SP,#+44
   \   0000049C   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??inflate_fast_18:
   \   000004A0   ........           DC32     `?<Constant "invalid distance too ...">`
   \   000004A4   ........           DC32     `?<Constant "invalid distance code">`
   \   000004A8   ........           DC32     `?<Constant "invalid literal/lengt...">`
    302          }

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "invalid distance too ...">`:
   \   00000000   696E76616C69       DC8 "invalid distance too far back"
   \              642064697374
   \              616E63652074
   \              6F6F20666172
   \              206261636B00
   \   0000001E   0000               DC8 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "invalid distance code">`:
   \   00000000   696E76616C69       DC8 "invalid distance code"
   \              642064697374
   \              616E63652063
   \              6F646500    
   \   00000016   0000               DC8 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "invalid literal/lengt...">`:
   \   00000000   696E76616C69       DC8 "invalid literal/length code"
   \              64206C697465
   \              72616C2F6C65
   \              6E6774682063
   \              6F646500    
    303          
    304          /*
    305             inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):
    306             - Using bit fields for code structure
    307             - Different op definition to avoid & for extra bits (do & for table bits)
    308             - Three separate decoding do-loops for direct, window, and write == 0
    309             - Special case for distance > 1 copies to do overlapped load and store copy
    310             - Explicit branch predictions (based on measured branch probabilities)
    311             - Deferring match copy and interspersed it with decoding subsequent codes
    312             - Swapping literal/length else
    313             - Swapping window/direct else
    314             - Larger unrolled copy loops (three is about right)
    315             - Moving len -= 3 statement into middle of loop
    316           */
    317          
    318          #endif /* !ASMINF */

   Maximum stack usage in bytes:

     Function     CSTACK
     --------     ------
     inflate_fast    80


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     inflate_fast                   1196
     ?<Constant "invalid distance too ...">
                                      32
     ?<Constant "invalid distance code">
                                      24
     ?<Constant "invalid literal/lengt...">
                                      28
      Others                           4

 
 1 200 bytes in segment CODE
    84 bytes in segment DATA_C
 
 1 196 bytes of CODE  memory (+ 4 bytes shared)
    84 bytes of CONST memory

Errors: none
Warnings: none
