##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    31/Mar/2011  22:53:57 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\CBN\Arc\Zlib\DEFLATE.C                        #
#    Command line    =  C:\arm\CBN\Arc\Zlib\DEFLATE.C -D NEWSGOLD -D UNPACK  #
#                       -lC C:\arm\CBN\Z80\Release\List\ -o                  #
#                       C:\arm\CBN\Z80\Release\Obj\ -s9 --no_unroll          #
#                       --no_clustering --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --char_is_signed --fpu None -I "C:\arm2\Embedded     #
#                       Workbench 4.0 Evaluation\ARM\INC\"                   #
#                       --inline_threshold=2                                 #
#    List file       =  C:\arm\CBN\Z80\Release\List\DEFLATE.lst              #
#    Object file     =  C:\arm\CBN\Z80\Release\Obj\DEFLATE.r79               #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\CBN\Arc\Zlib\DEFLATE.C
      1          /* deflate.c -- compress data using the deflation algorithm
      2           * Copyright (C) 1995-2005 Jean-loup Gailly.
      3           * For conditions of distribution and use, see copyright notice in zlib.h
      4           */
      5          
      6          /*
      7           *  ALGORITHM
      8           *
      9           *      The "deflation" process depends on being able to identify portions
     10           *      of the input text which are identical to earlier input (within a
     11           *      sliding window trailing behind the input currently being processed).
     12           *
     13           *      The most straightforward technique turns out to be the fastest for
     14           *      most input files: try all possible matches and select the longest.
     15           *      The key feature of this algorithm is that insertions into the string
     16           *      dictionary are very simple and thus fast, and deletions are avoided
     17           *      completely. Insertions are performed at each input character, whereas
     18           *      string matches are performed only when the previous match ends. So it
     19           *      is preferable to spend more time in matches to allow very fast string
     20           *      insertions and avoid deletions. The matching algorithm for small
     21           *      strings is inspired from that of Rabin & Karp. A brute force approach
     22           *      is used to find longer strings when a small match has been found.
     23           *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
     24           *      (by Leonid Broukhis).
     25           *         A previous version of this file used a more sophisticated algorithm
     26           *      (by Fiala and Greene) which is guaranteed to run in linear amortized
     27           *      time, but has a larger average cost, uses more memory and is patented.
     28           *      However the F&G algorithm may be faster for some highly redundant
     29           *      files if the parameter max_chain_length (described below) is too large.
     30           *
     31           *  ACKNOWLEDGEMENTS
     32           *
     33           *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
     34           *      I found it in 'freeze' written by Leonid Broukhis.
     35           *      Thanks to many people for bug reports and testing.
     36           *
     37           *  REFERENCES
     38           *
     39           *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
     40           *      Available in http://www.ietf.org/rfc/rfc1951.txt
     41           *
     42           *      A description of the Rabin and Karp algorithm is given in the book
     43           *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
     44           *
     45           *      Fiala,E.R., and Greene,D.H.
     46           *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
     47           *
     48           */
     49          
     50          /* @(#) $Id$ */
     51          
     52          #include "deflate.h"
     53          
     54          
     55          //extern void *memset(void *mem, int val, int size){
     56          //  while(--size>=0) ((char*)mem)[size]=(char)val;
     57          //  return mem; 
     58          //}
     59          

   \                                 In segment DATA_C, align 4, align-sorted
     60          const char deflate_copyright[] =
   \                     deflate_copyright:
   \   00000000   206465666C61       DC8 20H, 64H, 65H, 66H, 6CH, 61H, 74H, 65H
   \              7465        
   \   00000008   20312E322E33       DC8 20H, 31H, 2EH, 32H, 2EH, 33H, 20H, 43H
   \              2043        
   \   00000010   6F7079726967       DC8 6FH, 70H, 79H, 72H, 69H, 67H, 68H, 74H
   \              6874        
   \   00000018   20313939352D       DC8 20H, 31H, 39H, 39H, 35H, 2DH, 32H, 30H
   \              3230        
   \   00000020   3035204A6561       DC8 30H, 35H, 20H, 4AH, 65H, 61H, 6EH, 2DH
   \              6E2D        
   \   00000028   6C6F75702047       DC8 6CH, 6FH, 75H, 70H, 20H, 47H, 61H, 69H
   \              6169        
   \   00000030   6C6C792000         DC8 6CH, 6CH, 79H, 20H, 0
   \   00000035   000000             DC8 0, 0, 0
     61             " deflate 1.2.3 Copyright 1995-2005 Jean-loup Gailly ";
     62          /*
     63            If you use the zlib library in a product, an acknowledgment is welcome
     64            in the documentation of your product. If for some reason you cannot
     65            include such an acknowledgment, I would appreciate that you keep this
     66            copyright string in the executable of your product.
     67           */
     68          
     69          /* ===========================================================================
     70           *  Function prototypes.
     71           */
     72          typedef enum {
     73              need_more,      /* block not completed, need more input or more output */
     74              block_done,     /* block flush performed */
     75              finish_started, /* finish started, need only more output at next deflate */
     76              finish_done     /* finish done, accept no more input or output */
     77          } block_state;
     78          
     79          typedef block_state (*compress_func) OF((deflate_state *s, int flush));
     80          /* Compression function. Returns the block state after the call. */
     81          
     82          local void fill_window    OF((deflate_state *s));
     83          local block_state deflate_stored OF((deflate_state *s, int flush));
     84          local block_state deflate_fast   OF((deflate_state *s, int flush));
     85          #ifndef FASTEST
     86          local block_state deflate_slow   OF((deflate_state *s, int flush));
     87          #endif
     88          local void lm_init        OF((deflate_state *s));
     89          local void putShortMSB    OF((deflate_state *s, uInt b));
     90          local void flush_pending  OF((z_streamp strm));
     91          local int read_buf        OF((z_streamp strm, Bytef *buf, unsigned size));
     92          #ifndef FASTEST
     93          #ifdef ASMV
     94                void match_init OF((void)); /* asm code initialization */
     95                uInt longest_match  OF((deflate_state *s, IPos cur_match));
     96          #else
     97          local uInt longest_match  OF((deflate_state *s, IPos cur_match));
     98          #endif
     99          #endif
    100          local uInt longest_match_fast OF((deflate_state *s, IPos cur_match));
    101          
    102          #ifdef DEBUG
    103          local  void check_match OF((deflate_state *s, IPos start, IPos match,
    104                                      int length));
    105          #endif
    106          
    107          /* ===========================================================================
    108           * Local data
    109           */
    110          
    111          #define NIL 0
    112          /* Tail of hash chains */
    113          
    114          #ifndef TOO_FAR
    115          #  define TOO_FAR 4096
    116          #endif
    117          /* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
    118          
    119          #define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
    120          /* Minimum amount of lookahead, except at the end of the input file.
    121           * See deflate.c for comments about the MIN_MATCH+1.
    122           */
    123          
    124          /* Values for max_lazy_match, good_match and max_chain_length, depending on
    125           * the desired pack level (0..9). The values given below have been tuned to
    126           * exclude worst case performance for pathological files. Better values may be
    127           * found for specific files.
    128           */
    129          typedef struct config_s {
    130             ush good_length; /* reduce lazy search above this match length */
    131             ush max_lazy;    /* do not perform lazy search above this match length */
    132             ush nice_length; /* quit search above this match length */
    133             ush max_chain;
    134             compress_func func;
    135          } config;
    136          
    137          #ifdef FASTEST
    138          local const config configuration_table[2] = {
    139          /*      good lazy nice chain */
    140          /* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
    141          /* 1 */ {4,    4,  8,    4, deflate_fast}}; /* max speed, no lazy matches */
    142          #else

   \                                 In segment DATA_C, align 4, align-sorted
    143          local const config configuration_table[10] = {
   \                     configuration_table:
   \   00000000   000000000000       DC16 0, 0, 0, 0
   \              0000        
   \   00000008   ........           DC32 deflate_stored
   \   0000000C   040004000800       DC16 4, 4, 8, 4
   \              0400        
   \   00000014   ........           DC32 deflate_fast
   \   00000018   040005001000       DC16 4, 5, 16, 8
   \              0800        
   \   00000020   ........           DC32 deflate_fast
   \   00000024   040006002000       DC16 4, 6, 32, 32
   \              2000        
   \   0000002C   ........           DC32 deflate_fast
   \   00000030   040004001000       DC16 4, 4, 16, 16
   \              1000        
   \   00000038   ........           DC32 deflate_slow
   \   0000003C   080010002000       DC16 8, 16, 32, 32
   \              2000        
   \   00000044   ........           DC32 deflate_slow
   \   00000048   080010008000       DC16 8, 16, 128, 128
   \              8000        
   \   00000050   ........           DC32 deflate_slow
   \   00000054   080020008000       DC16 8, 32, 128, 256
   \              0001        
   \   0000005C   ........           DC32 deflate_slow
   \   00000060   200080000201       DC16 32, 128, 258, 1024
   \              0004        
   \   00000068   ........           DC32 deflate_slow
   \   0000006C   200002010201       DC16 32, 258, 258, 4096
   \              0010        
   \   00000074   ........           DC32 deflate_slow
    144          /*      good lazy nice chain */
    145          /* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
    146          /* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */
    147          /* 2 */ {4,    5, 16,    8, deflate_fast},
    148          /* 3 */ {4,    6, 32,   32, deflate_fast},
    149          
    150          /* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
    151          /* 5 */ {8,   16, 32,   32, deflate_slow},
    152          /* 6 */ {8,   16, 128, 128, deflate_slow},
    153          /* 7 */ {8,   32, 128, 256, deflate_slow},
    154          /* 8 */ {32, 128, 258, 1024, deflate_slow},
    155          /* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */
    156          #endif
    157          
    158          /* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
    159           * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
    160           * meaning.
    161           */
    162          
    163          #define EQUAL 0
    164          /* result of memcmp for equal strings */
    165          
    166          #ifndef NO_DUMMY_DECL
    167          struct static_tree_desc_s {int dummy;}; /* for buggy compilers */
    168          #endif
    169          
    170          /* ===========================================================================
    171           * Update a hash value with the given input byte
    172           * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
    173           *    input characters, so that a running hash key can be computed from the
    174           *    previous key instead of complete recalculation each time.
    175           */
    176          #define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)
    177          
    178          
    179          /* ===========================================================================
    180           * Insert string str in the dictionary and set match_head to the previous head
    181           * of the hash chain (the most recent string with same hash key). Return
    182           * the previous length of the hash chain.
    183           * If this file is compiled with -DFASTEST, the compression level is forced
    184           * to 1, and no hash chains are maintained.
    185           * IN  assertion: all calls to to INSERT_STRING are made with consecutive
    186           *    input characters and the first MIN_MATCH bytes of str are valid
    187           *    (except for the last MIN_MATCH-1 bytes of the input file).
    188           */
    189          #ifdef FASTEST
    190          #define INSERT_STRING(s, str, match_head) \
    191             (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
    192              match_head = s->head[s->ins_h], \
    193              s->head[s->ins_h] = (Pos)(str))
    194          #else
    195          #define INSERT_STRING(s, str, match_head) \
    196             (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
    197              match_head = s->prev[(str) & s->w_mask] = s->head[s->ins_h], \
    198              s->head[s->ins_h] = (Pos)(str))
    199          #endif
    200          
    201          /* ===========================================================================
    202           * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
    203           * prev[] will be initialized on the fly.
    204           */
    205          #define CLEAR_HASH(s) \
    206              s->head[s->hash_size-1] = NIL; \
    207              zmemzero((Bytef *)s->head, (unsigned)(s->hash_size-1)*sizeof(*s->head));
    208          
    209          /* ========================================================================= */

   \                                 In segment CODE, align 4, keep-with-next
    210          int ZEXPORT deflateInit_(strm, level, version, stream_size)
    211              z_streamp strm;
    212              int level;
    213              const char *version;
    214              int stream_size;
    215          {
   \                     deflateInit_:
   \   00000000   00402DE9           PUSH     {LR}
    216              return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
    217                                   Z_DEFAULT_STRATEGY, version, stream_size);
   \   00000004   08002DE9           PUSH     {R3}
   \   00000008   04002DE9           PUSH     {R2}
   \   0000000C   0020A0E3           MOV      R2,#+0
   \   00000010   04002DE9           PUSH     {R2}
   \   00000014   0F30A0E3           MOV      R3,#+15
   \   00000018   0820A0E3           MOV      R2,#+8
   \   0000001C   04002DE9           PUSH     {R2}
   \   00000020   ........           BL       deflateInit2_
   \   00000024   10D08DE2           ADD      SP,SP,#+16
   \   00000028   0080BDE8           POP      {PC}             ;; return
    218              /* To do: ignore strm->next_in if we use it as window */
    219          }
    220          
    221          /* ========================================================================= */

   \                                 In segment CODE, align 4, keep-with-next
    222          int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
    223                            version, stream_size)
    224              z_streamp strm;
    225              int  level;
    226              int  method;
    227              int  windowBits;
    228              int  memLevel;
    229              int  strategy;
    230              const char *version;
    231              int stream_size;
    232          {
   \                     deflateInit2_:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   24609DE5           LDR      R6,[SP, #+36]
   \   00000008   28709DE5           LDR      R7,[SP, #+40]
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   2C009DE5           LDR      R0,[SP, #+44]
   \   00000014   0150A0E1           MOV      R5,R1
   \   00000018   30109DE5           LDR      R1,[SP, #+48]
   \   0000001C   0390A0E1           MOV      R9,R3
    233              deflate_state *s;
    234              int wrap = 1;
   \   00000020   01A0A0E3           MOV      R10,#+1
    235              static const char my_version[] = ZLIB_VERSION;
    236          
    237              ushf *overlay;
    238              /* We overlay pending_buf and d_buf+l_buf. This works since the average
    239               * output size for (length,distance) codes is <= 24 bits.
    240               */
    241          
    242              if (version == Z_NULL || version[0] != my_version[0] ||
    243                  stream_size != sizeof(z_stream)) {
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   0300000A           BEQ      ??deflateInit2__0
   \   0000002C   D000D0E1           LDRSB    R0,[R0, #+0]
   \   00000030   310050E3           CMP      R0,#+49
   \   00000034   38005103           CMPEQ    R1,#+56
   \   00000038   0100000A           BEQ      ??deflateInit2__1
    244                  return Z_VERSION_ERROR;
   \                     ??deflateInit2__0:
   \   0000003C   0500E0E3           MVN      R0,#+5
   \   00000040   F08FBDE8           POP      {R4-R11,PC}
    245              }
    246              if (strm == Z_NULL) return Z_STREAM_ERROR;
   \                     ??deflateInit2__1:
   \   00000044   000054E3           CMP      R4,#+0
   \   00000048   0100001A           BNE      ??deflateInit2__2
   \                     ??deflateInit2__3:
   \   0000004C   0100E0E3           MVN      R0,#+1
   \   00000050   F08FBDE8           POP      {R4-R11,PC}
    247          
    248              strm->msg = Z_NULL;
   \                     ??deflateInit2__2:
   \   00000054   00B0A0E3           MOV      R11,#+0
   \   00000058   18B084E5           STR      R11,[R4, #+24]
    249              if (strm->zalloc == (alloc_func)0) {
   \   0000005C   200094E5           LDR      R0,[R4, #+32]
   \   00000060   000050E3           CMP      R0,#+0
    250                  strm->zalloc = zcalloc;
   \   00000064   04029F05           LDREQ    R0,??deflateInit2__4  ;; zcalloc
   \   00000068   20008405           STREQ    R0,[R4, #+32]
    251                  strm->opaque = (voidpf)0;
   \   0000006C   28B08405           STREQ    R11,[R4, #+40]
    252              }
    253              if (strm->zfree == (free_func)0) strm->zfree = zcfree;
   \   00000070   240094E5           LDR      R0,[R4, #+36]
   \   00000074   000050E3           CMP      R0,#+0
   \   00000078   F4019F05           LDREQ    R0,??deflateInit2__4+0x4  ;; zcfree
   \   0000007C   24008405           STREQ    R0,[R4, #+36]
    254          
    255          #ifdef FASTEST
    256              if (level != 0) level = 1;
    257          #else
    258              if (level == Z_DEFAULT_COMPRESSION) level = 6;
   \   00000080   010075E3           CMN      R5,#+1
   \   00000084   0650A003           MOVEQ    R5,#+6
    259          #endif
    260          
    261              if (windowBits < 0) { /* suppress zlib wrapper */
   \   00000088   000059E3           CMP      R9,#+0
    262                  wrap = 0;
   \   0000008C   00A0A043           MOVMI    R10,#+0
    263                  windowBits = -windowBits;
   \   00000090   00906942           RSBMI    R9,R9,#+0
   \   00000094   0200004A           BMI      ??deflateInit2__5
    264              }
    265          #ifdef GZIP
    266              else if (windowBits > 15) {
   \   00000098   100059E3           CMP      R9,#+16
    267                  wrap = 2;       /* write gzip wrapper instead */
   \   0000009C   02A0A0A3           MOVGE    R10,#+2
    268                  windowBits -= 16;
   \   000000A0   109049A2           SUBGE    R9,R9,#+16
    269              }
    270          #endif
    271              if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
    272                  windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    273                  strategy < 0 || strategy > Z_FIXED) {
   \                     ??deflateInit2__5:
   \   000000A4   010056E3           CMP      R6,#+1
   \   000000A8   E7FFFFBA           BLT      ??deflateInit2__3
   \   000000AC   0A0056E3           CMP      R6,#+10
   \   000000B0   E5FFFFAA           BGE      ??deflateInit2__3
   \   000000B4   080052E3           CMP      R2,#+8
   \   000000B8   E3FFFF1A           BNE      ??deflateInit2__3
   \   000000BC   080059E3           CMP      R9,#+8
   \   000000C0   E1FFFFBA           BLT      ??deflateInit2__3
   \   000000C4   100059E3           CMP      R9,#+16
   \   000000C8   DFFFFFAA           BGE      ??deflateInit2__3
   \   000000CC   000055E3           CMP      R5,#+0
   \   000000D0   DDFFFF4A           BMI      ??deflateInit2__3
   \   000000D4   0A0055E3           CMP      R5,#+10
   \   000000D8   DBFFFFAA           BGE      ??deflateInit2__3
   \   000000DC   000057E3           CMP      R7,#+0
   \   000000E0   D9FFFF4A           BMI      ??deflateInit2__3
   \   000000E4   050057E3           CMP      R7,#+5
   \   000000E8   D7FFFFAA           BGE      ??deflateInit2__3
    274                  return Z_STREAM_ERROR;
    275              }
    276              if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */
    277              s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
   \   000000EC   280094E5           LDR      R0,[R4, #+40]
   \   000000F0   203094E5           LDR      R3,[R4, #+32]
   \   000000F4   080059E3           CMP      R9,#+8
   \   000000F8   0990A003           MOVEQ    R9,#+9
   \   000000FC   5B2DA0E3           MOV      R2,#+5824
   \   00000100   0110A0E3           MOV      R1,#+1
   \   00000104   33FF2FE1           BLX      R3
   \   00000108   0080B0E1           MOVS     R8,R0
    278              if (s == Z_NULL) return Z_MEM_ERROR;
   \   0000010C   4800000A           BEQ      ??deflateInit2__6
    279              strm->state = (struct internal_state FAR *)s;
    280              s->strm = strm;
    281          
    282              s->wrap = wrap;
    283              s->gzhead = Z_NULL;
    284              s->w_bits = windowBits;
    285              s->w_size = 1 << s->w_bits;
    286              s->w_mask = s->w_size - 1;
    287          
    288              s->hash_bits = memLevel + 7;
    289              s->hash_size = 1 << s->hash_bits;
    290              s->hash_mask = s->hash_size - 1;
    291              s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);
   \   00000110   60119FE5           LDR      R1,??deflateInit2__4+0x8  ;; 0xffffffffaaaaaaab
   \   00000114   1C8084E5           STR      R8,[R4, #+28]
   \   00000118   004088E5           STR      R4,[R8, #+0]
   \   0000011C   18A088E5           STR      R10,[R8, #+24]
   \   00000120   1CB088E5           STR      R11,[R8, #+28]
   \   00000124   309088E5           STR      R9,[R8, #+48]
   \   00000128   01A0A0E3           MOV      R10,#+1
   \   0000012C   0900A0E1           MOV      R0,R9
   \   00000130   1A00A0E1           LSL      R0,R10,R0
   \   00000134   2C0088E5           STR      R0,[R8, #+44]
   \   00000138   010040E2           SUB      R0,R0,#+1
   \   0000013C   340088E5           STR      R0,[R8, #+52]
   \   00000140   070086E2           ADD      R0,R6,#+7
   \   00000144   500088E5           STR      R0,[R8, #+80]
   \   00000148   1A00A0E1           LSL      R0,R10,R0
   \   0000014C   4C0088E5           STR      R0,[R8, #+76]
   \   00000150   010040E2           SUB      R0,R0,#+1
   \   00000154   540088E5           STR      R0,[R8, #+84]
   \   00000158   500098E5           LDR      R0,[R8, #+80]
   \   0000015C   020080E2           ADD      R0,R0,#+2
   \   00000160   912083E0           UMULL    R2,R3,R1,R0
    292          
    293              s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
   \   00000164   0220A0E3           MOV      R2,#+2
   \   00000168   A330A0E1           LSR      R3,R3,#+1
   \   0000016C   583088E5           STR      R3,[R8, #+88]
   \   00000170   280094E5           LDR      R0,[R4, #+40]
   \   00000174   2C1098E5           LDR      R1,[R8, #+44]
   \   00000178   203094E5           LDR      R3,[R4, #+32]
   \   0000017C   33FF2FE1           BLX      R3
   \   00000180   380088E5           STR      R0,[R8, #+56]
    294              s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
   \   00000184   280094E5           LDR      R0,[R4, #+40]
   \   00000188   2C1098E5           LDR      R1,[R8, #+44]
   \   0000018C   203094E5           LDR      R3,[R4, #+32]
   \   00000190   0220A0E3           MOV      R2,#+2
   \   00000194   33FF2FE1           BLX      R3
   \   00000198   400088E5           STR      R0,[R8, #+64]
    295              s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));
   \   0000019C   280094E5           LDR      R0,[R4, #+40]
   \   000001A0   4C1098E5           LDR      R1,[R8, #+76]
   \   000001A4   203094E5           LDR      R3,[R4, #+32]
   \   000001A8   0220A0E3           MOV      R2,#+2
   \   000001AC   33FF2FE1           BLX      R3
   \   000001B0   440088E5           STR      R0,[R8, #+68]
   \   000001B4   9800A0E3           MOV      R0,#+152
   \   000001B8   580D80E3           ORR      R0,R0,#0x1600
   \   000001BC   089080E0           ADD      R9,R0,R8
   \   000001C0   060086E2           ADD      R0,R6,#+6
   \   000001C4   1A00A0E1           LSL      R0,R10,R0
   \   000001C8   040089E5           STR      R0,[R9, #+4]
    296          
    297              s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
    298          
    299              overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
   \   000001CC   203094E5           LDR      R3,[R4, #+32]
   \   000001D0   0010A0E1           MOV      R1,R0
   \   000001D4   280094E5           LDR      R0,[R4, #+40]
   \   000001D8   0420A0E3           MOV      R2,#+4
   \   000001DC   33FF2FE1           BLX      R3
    300              s->pending_buf = (uchf *) overlay;
   \   000001E0   080088E5           STR      R0,[R8, #+8]
    301              s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);
   \   000001E4   041099E5           LDR      R1,[R9, #+4]
   \   000001E8   0121A0E1           LSL      R2,R1,#+2
   \   000001EC   0C2088E5           STR      R2,[R8, #+12]
    302          
    303              if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
    304                  s->pending_buf == Z_NULL) {
   \   000001F0   382098E5           LDR      R2,[R8, #+56]
   \   000001F4   000052E3           CMP      R2,#+0
   \   000001F8   40209815           LDRNE    R2,[R8, #+64]
   \   000001FC   00005213           CMPNE    R2,#+0
   \   00000200   44209815           LDRNE    R2,[R8, #+68]
   \   00000204   00005213           CMPNE    R2,#+0
   \   00000208   0020A011           MOVNE    R2,R0
   \   0000020C   00005213           CMPNE    R2,#+0
   \   00000210   0900001A           BNE      ??deflateInit2__7
    305                  s->status = FINISH_STATE;
   \   00000214   9A00A0E3           MOV      R0,#+154
   \   00000218   800F80E3           ORR      R0,R0,#0x200
   \   0000021C   040088E5           STR      R0,[R8, #+4]
    306                  strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);
   \   00000220   54009FE5           LDR      R0,??deflateInit2__4+0xC  ;; z_errmsg + 24
   \   00000224   000090E5           LDR      R0,[R0, #+0]
   \   00000228   180084E5           STR      R0,[R4, #+24]
    307                  deflateEnd (strm);
   \   0000022C   0400A0E1           MOV      R0,R4
   \   00000230   ........           BL       deflateEnd
    308                  return Z_MEM_ERROR;
   \                     ??deflateInit2__6:
   \   00000234   0300E0E3           MVN      R0,#+3
   \   00000238   F08FBDE8           POP      {R4-R11,PC}
    309              }
    310              s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
   \                     ??deflateInit2__7:
   \   0000023C   A130A0E1           LSR      R3,R1,#+1
   \   00000240   830080E0           ADD      R0,R0,R3, LSL #+1
   \   00000244   0C0089E5           STR      R0,[R9, #+12]
    311              s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
   \   00000248   810081E0           ADD      R0,R1,R1, LSL #+1
   \   0000024C   020080E0           ADD      R0,R0,R2
   \   00000250   000089E5           STR      R0,[R9, #+0]
    312          
    313              s->level = level;
   \   00000254   845088E5           STR      R5,[R8, #+132]
    314              s->strategy = strategy;
   \   00000258   887088E5           STR      R7,[R8, #+136]
    315              s->method = (Byte)method;
   \   0000025C   0800A0E3           MOV      R0,#+8
   \   00000260   2400C8E5           STRB     R0,[R8, #+36]
    316          
    317              return deflateReset(strm);
   \   00000264   0400A0E1           MOV      R0,R4
   \   00000268   ........           BL       deflateReset
   \   0000026C   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??deflateInit2__4:
   \   00000270   ........           DC32     zcalloc
   \   00000274   ........           DC32     zcfree
   \   00000278   ABAAAAAA           DC32     0xffffffffaaaaaaab
   \   0000027C   ........           DC32     z_errmsg + 24
    318          }
    319          
    320          /* ========================================================================= */

   \                                 In segment CODE, align 4, keep-with-next
    321          int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
    322              z_streamp strm;
    323              const Bytef *dictionary;
    324              uInt  dictLength;
    325          {
   \                     deflateSetDictionary:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0160A0E1           MOV      R6,R1
   \   00000008   0270A0E1           MOV      R7,R2
   \   0000000C   0080A0E1           MOV      R8,R0
    326              deflate_state *s;
    327              uInt length = dictLength;
    328              uInt n;
    329              IPos hash_head = 0;
    330          
    331              if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||
    332                  strm->state->wrap == 2 ||
    333                  (strm->state->wrap == 1 && strm->state->status != INIT_STATE))
   \   00000010   000058E3           CMP      R8,#+0
   \   00000014   1C409815           LDRNE    R4,[R8, #+28]
   \   00000018   0750A0E1           MOV      R5,R7
   \   0000001C   00005413           CMPNE    R4,#+0
   \   00000020   00005613           CMPNE    R6,#+0
   \   00000024   18009415           LDRNE    R0,[R4, #+24]
   \   00000028   02005013           CMPNE    R0,#+2
   \   0000002C   0400000A           BEQ      ??deflateSetDictionary_0
   \   00000030   010050E3           CMP      R0,#+1
   \   00000034   0400001A           BNE      ??deflateSetDictionary_1
   \   00000038   040094E5           LDR      R0,[R4, #+4]
   \   0000003C   2A0050E3           CMP      R0,#+42
   \   00000040   0100000A           BEQ      ??deflateSetDictionary_1
    334                  return Z_STREAM_ERROR;
   \                     ??deflateSetDictionary_0:
   \   00000044   0100E0E3           MVN      R0,#+1
   \   00000048   F081BDE8           POP      {R4-R8,PC}       ;; return
    335          
    336              s = strm->state;
    337              if (s->wrap)
   \                     ??deflateSetDictionary_1:
   \   0000004C   180094E5           LDR      R0,[R4, #+24]
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   0200000A           BEQ      ??deflateSetDictionary_2
    338                  strm->adler = adler32(strm->adler, dictionary, dictLength);
   \   00000058   300098E5           LDR      R0,[R8, #+48]
   \   0000005C   ........           _BLF     adler32,??adler32??rA
   \   00000060   300088E5           STR      R0,[R8, #+48]
    339          
    340              if (length < MIN_MATCH) return Z_OK;
   \                     ??deflateSetDictionary_2:
   \   00000064   030055E3           CMP      R5,#+3
   \   00000068   0100002A           BCS      ??deflateSetDictionary_3
   \                     ??deflateSetDictionary_4:
   \   0000006C   0000A0E3           MOV      R0,#+0
   \   00000070   F081BDE8           POP      {R4-R8,PC}
    341              if (length > MAX_DIST(s)) {
   \                     ??deflateSetDictionary_3:
   \   00000074   2C0094E5           LDR      R0,[R4, #+44]
   \   00000078   0510E0E3           MVN      R1,#+5
   \   0000007C   401FC1E3           BIC      R1,R1,#0x100
   \   00000080   000081E0           ADD      R0,R1,R0
   \   00000084   050050E1           CMP      R0,R5
    342                  length = MAX_DIST(s);
   \   00000088   0050A031           MOVCC    R5,R0
    343                  dictionary += dictLength - length; /* use the tail of the dictionary */
   \   0000008C   05004730           SUBCC    R0,R7,R5
   \   00000090   06608030           ADDCC    R6,R0,R6
    344              }
    345              zmemcpy(s->window, dictionary, length);
   \   00000094   380094E5           LDR      R0,[R4, #+56]
   \   00000098   0520A0E1           MOV      R2,R5
   \   0000009C   0610A0E1           MOV      R1,R6
   \   000000A0   ........           _BLF     memcpy,??memcpy??rA
    346              s->strstart = length;
   \   000000A4   6C5084E5           STR      R5,[R4, #+108]
    347              s->block_start = (long)length;
   \   000000A8   5C5084E5           STR      R5,[R4, #+92]
    348          
    349              /* Insert all strings in the hash table (except for the last two bytes).
    350               * s->lookahead stays null, so s->ins_h will be recomputed at the next
    351               * call of fill_window.
    352               */
    353              s->ins_h = s->window[0];
   \   000000AC   380094E5           LDR      R0,[R4, #+56]
    354              UPDATE_HASH(s, s->ins_h, s->window[1]);
    355              for (n = 0; n <= length - MIN_MATCH; n++) {
   \   000000B0   035045E2           SUB      R5,R5,#+3
   \   000000B4   0030D0E5           LDRB     R3,[R0, #+0]
   \   000000B8   483084E5           STR      R3,[R4, #+72]
   \   000000BC   0160D0E5           LDRB     R6,[R0, #+1]
   \   000000C0   541094E5           LDR      R1,[R4, #+84]
   \   000000C4   582094E5           LDR      R2,[R4, #+88]
   \   000000C8   133226E0           EOR      R3,R6,R3, LSL R2
   \   000000CC   033001E0           AND      R3,R1,R3
   \   000000D0   483084E5           STR      R3,[R4, #+72]
   \   000000D4   0030A0E3           MOV      R3,#+0
   \                     ??deflateSetDictionary_5:
   \   000000D8   030055E1           CMP      R5,R3
   \   000000DC   E2FFFF3A           BCC      ??deflateSetDictionary_4
    356                  INSERT_STRING(s, n, hash_head);
   \   000000E0   486094E5           LDR      R6,[R4, #+72]
   \   000000E4   007083E0           ADD      R7,R3,R0
   \   000000E8   0270D7E5           LDRB     R7,[R7, #+2]
   \   000000EC   166227E0           EOR      R6,R7,R6, LSL R2
   \   000000F0   066001E0           AND      R6,R1,R6
   \   000000F4   486084E5           STR      R6,[R4, #+72]
   \   000000F8   447094E5           LDR      R7,[R4, #+68]
   \   000000FC   408094E5           LDR      R8,[R4, #+64]
   \   00000100   866087E0           ADD      R6,R7,R6, LSL #+1
   \   00000104   347094E5           LDR      R7,[R4, #+52]
   \   00000108   037007E0           AND      R7,R7,R3
   \   0000010C   877088E0           ADD      R7,R8,R7, LSL #+1
   \   00000110   B080D6E1           LDRH     R8,[R6, #+0]
   \   00000114   B080C7E1           STRH     R8,[R7, #+0]
   \   00000118   B030C6E1           STRH     R3,[R6, #+0]
    357              }
   \   0000011C   013083E2           ADD      R3,R3,#+1
   \   00000120   ECFFFFEA           B        ??deflateSetDictionary_5
    358              if (hash_head) hash_head = 0;  /* to make compiler happy */
    359              return Z_OK;
    360          }
    361          
    362          /* ========================================================================= */

   \                                 In segment CODE, align 4, keep-with-next
    363          int ZEXPORT deflateReset (strm)
    364              z_streamp strm;
    365          {
   \                     deflateReset:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    366              deflate_state *s;
    367          
    368              if (strm == Z_NULL || strm->state == Z_NULL ||
    369                  strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0) {
   \   00000008   1C509415           LDRNE    R5,[R4, #+28]
   \   0000000C   00005513           CMPNE    R5,#+0
   \   00000010   20009415           LDRNE    R0,[R4, #+32]
   \   00000014   00005013           CMPNE    R0,#+0
   \   00000018   24009415           LDRNE    R0,[R4, #+36]
   \   0000001C   00005013           CMPNE    R0,#+0
    370                  return Z_STREAM_ERROR;
   \   00000020   0100E003           MVNEQ    R0,#+1
   \   00000024   7080BD08           POPEQ    {R4-R6,PC}
    371              }
    372          
    373              strm->total_in = strm->total_out = 0;
   \   00000028   0060A0E3           MOV      R6,#+0
   \   0000002C   146084E5           STR      R6,[R4, #+20]
   \   00000030   086084E5           STR      R6,[R4, #+8]
    374              strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
   \   00000034   186084E5           STR      R6,[R4, #+24]
    375              strm->data_type = Z_UNKNOWN;
   \   00000038   0200A0E3           MOV      R0,#+2
   \   0000003C   2C0084E5           STR      R0,[R4, #+44]
    376          
    377              s = (deflate_state *)strm->state;
    378              s->pending = 0;
   \   00000040   146085E5           STR      R6,[R5, #+20]
    379              s->pending_out = s->pending_buf;
   \   00000044   080095E5           LDR      R0,[R5, #+8]
    380          
    381              if (s->wrap < 0) {
    382                  s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */
    383              }
    384              s->status = s->wrap ? INIT_STATE : BUSY_STATE;
    385              strm->adler =
    386          #ifdef GZIP
    387                  s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
    388          #endif
    389                  adler32(0L, Z_NULL, 0);
   \   00000048   0020A0E3           MOV      R2,#+0
   \   0000004C   100085E5           STR      R0,[R5, #+16]
   \   00000050   180095E5           LDR      R0,[R5, #+24]
   \   00000054   0210A0E1           MOV      R1,R2
   \   00000058   000050E3           CMP      R0,#+0
   \   0000005C   00006042           RSBMI    R0,R0,#+0
   \   00000060   18008545           STRMI    R0,[R5, #+24]
   \   00000064   180095E5           LDR      R0,[R5, #+24]
   \   00000068   000050E3           CMP      R0,#+0
   \   0000006C   2A00A013           MOVNE    R0,#+42
   \   00000070   7100A003           MOVEQ    R0,#+113
   \   00000074   040085E5           STR      R0,[R5, #+4]
   \   00000078   180095E5           LDR      R0,[R5, #+24]
   \   0000007C   020050E3           CMP      R0,#+2
   \   00000080   0100A0E1           MOV      R0,R1
   \   00000084   0100001A           BNE      ??deflateReset_0
   \   00000088   ........           _BLF     crc32,??crc32??rA
   \   0000008C   000000EA           B        ??deflateReset_1
   \                     ??deflateReset_0:
   \   00000090   ........           _BLF     adler32,??adler32??rA
   \                     ??deflateReset_1:
   \   00000094   300084E5           STR      R0,[R4, #+48]
    390              s->last_flush = Z_NO_FLUSH;
   \   00000098   286085E5           STR      R6,[R5, #+40]
    391          
    392              _tr_init(s);
   \   0000009C   0500A0E1           MOV      R0,R5
   \   000000A0   ........           _BLF     _tr_init,??_tr_init??rA
    393              lm_init(s);
   \   000000A4   0500A0E1           MOV      R0,R5
   \   000000A8   ........           BL       lm_init
    394          
    395              return Z_OK;
   \   000000AC   0000A0E3           MOV      R0,#+0
   \   000000B0   7080BDE8           POP      {R4-R6,PC}       ;; return
    396          }
    397          
    398          /* ========================================================================= */

   \                                 In segment CODE, align 4, keep-with-next
    399          int ZEXPORT deflateSetHeader (strm, head)
    400              z_streamp strm;
    401              gz_headerp head;
    402          {
    403              if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
   \                     deflateSetHeader:
   \   00000000   000050E3           CMP      R0,#+0
   \   00000004   1C009015           LDRNE    R0,[R0, #+28]
   \   00000008   00005013           CMPNE    R0,#+0
   \   0000000C   0200000A           BEQ      ??deflateSetHeader_0
    404              if (strm->state->wrap != 2) return Z_STREAM_ERROR;
   \   00000010   182090E5           LDR      R2,[R0, #+24]
   \   00000014   020052E3           CMP      R2,#+2
   \   00000018   0100000A           BEQ      ??deflateSetHeader_1
   \                     ??deflateSetHeader_0:
   \   0000001C   0100E0E3           MVN      R0,#+1
   \   00000020   1EFF2FE1           BX       LR
    405              strm->state->gzhead = head;
   \                     ??deflateSetHeader_1:
   \   00000024   1C1080E5           STR      R1,[R0, #+28]
    406              return Z_OK;
   \   00000028   0000A0E3           MOV      R0,#+0
   \   0000002C   1EFF2FE1           BX       LR               ;; return
    407          }
    408          
    409          /* ========================================================================= */

   \                                 In segment CODE, align 4, keep-with-next
    410          int ZEXPORT deflatePrime (strm, bits, value)
    411              z_streamp strm;
    412              int bits;
    413              int value;
    414          {
    415              if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
   \                     deflatePrime:
   \   00000000   000050E3           CMP      R0,#+0
   \   00000004   1C009015           LDRNE    R0,[R0, #+28]
   \   00000008   00005013           CMPNE    R0,#+0
   \   0000000C   0100E003           MVNEQ    R0,#+1
   \   00000010   1EFF2F01           BXEQ     LR
    416              strm->state->bi_valid = bits;
   \   00000014   B830A0E3           MOV      R3,#+184
   \   00000018   583D83E3           ORR      R3,R3,#0x1600
   \   0000001C   000083E0           ADD      R0,R3,R0
   \   00000020   041080E5           STR      R1,[R0, #+4]
    417              strm->state->bi_buf = (ush)(value & ((1 << bits) - 1));
   \   00000024   0130A0E3           MOV      R3,#+1
   \   00000028   1311A0E1           LSL      R1,R3,R1
   \   0000002C   FF30A0E3           MOV      R3,#+255
   \   00000030   FF3C83E3           ORR      R3,R3,#0xFF00
   \   00000034   011083E0           ADD      R1,R3,R1
   \   00000038   021001E0           AND      R1,R1,R2
   \   0000003C   B010C0E1           STRH     R1,[R0, #+0]
    418              return Z_OK;
   \   00000040   0000A0E3           MOV      R0,#+0
   \   00000044   1EFF2FE1           BX       LR               ;; return
    419          }
    420          
    421          /* ========================================================================= */

   \                                 In segment CODE, align 4, keep-with-next
    422          int ZEXPORT deflateParams(strm, level, strategy)
    423              z_streamp strm;
    424              int level;
    425              int strategy;
    426          {
   \                     deflateParams:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
    427              deflate_state *s;
    428              compress_func func;
    429              int err = Z_OK;
    430          
    431              if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   1C709015           LDRNE    R7,[R0, #+28]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0240A0E1           MOV      R4,R2
   \   00000014   0010A0E3           MOV      R1,#+0
   \   00000018   00005713           CMPNE    R7,#+0
   \   0000001C   0100001A           BNE      ??deflateParams_0
   \                     ??deflateParams_1:
   \   00000020   0100E0E3           MVN      R0,#+1
   \   00000024   F080BDE8           POP      {R4-R7,PC}
    432              s = strm->state;
    433          
    434          #ifdef FASTEST
    435              if (level != 0) level = 1;
    436          #else
    437              if (level == Z_DEFAULT_COMPRESSION) level = 6;
   \                     ??deflateParams_0:
   \   00000028   010075E3           CMN      R5,#+1
   \   0000002C   0650A003           MOVEQ    R5,#+6
   \   00000030   0300000A           BEQ      ??deflateParams_2
    438          #endif
    439              if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
   \   00000034   000055E3           CMP      R5,#+0
   \   00000038   F8FFFF4A           BMI      ??deflateParams_1
   \   0000003C   0A0055E3           CMP      R5,#+10
   \   00000040   F6FFFFAA           BGE      ??deflateParams_1
   \                     ??deflateParams_2:
   \   00000044   000054E3           CMP      R4,#+0
   \   00000048   F4FFFF4A           BMI      ??deflateParams_1
   \   0000004C   050054E3           CMP      R4,#+5
   \   00000050   F2FFFFAA           BGE      ??deflateParams_1
    440                  return Z_STREAM_ERROR;
    441              }
    442              func = configuration_table[s->level].func;
    443          
    444              if (func != configuration_table[level].func && strm->total_in != 0) {
   \   00000054   ........           LDR      R2,??DataTable1  ;; configuration_table
   \   00000058   0C30A0E3           MOV      R3,#+12
   \   0000005C   932526E0           MLA      R6,R3,R5,R2
   \   00000060   843097E5           LDR      R3,[R7, #+132]
   \   00000064   0CC0A0E3           MOV      R12,#+12
   \   00000068   9C2322E0           MLA      R2,R12,R3,R2
   \   0000006C   083096E5           LDR      R3,[R6, #+8]
   \   00000070   082092E5           LDR      R2,[R2, #+8]
   \   00000074   030052E1           CMP      R2,R3
   \   00000078   08209015           LDRNE    R2,[R0, #+8]
   \   0000007C   00005213           CMPNE    R2,#+0
   \   00000080   0200000A           BEQ      ??deflateParams_3
    445                  /* Flush the last buffer: */
    446                  err = deflate(strm, Z_PARTIAL_FLUSH);
   \   00000084   0110A0E3           MOV      R1,#+1
   \   00000088   ........           BL       deflate
   \   0000008C   0010A0E1           MOV      R1,R0
    447              }
    448              if (s->level != level) {
   \                     ??deflateParams_3:
   \   00000090   840097E5           LDR      R0,[R7, #+132]
   \   00000094   050050E1           CMP      R0,R5
   \   00000098   0800000A           BEQ      ??deflateParams_4
    449                  s->level = level;
   \   0000009C   845087E5           STR      R5,[R7, #+132]
    450                  s->max_lazy_match   = configuration_table[level].max_lazy;
   \   000000A0   B200D6E1           LDRH     R0,[R6, #+2]
   \   000000A4   800087E5           STR      R0,[R7, #+128]
    451                  s->good_match       = configuration_table[level].good_length;
   \   000000A8   B000D6E1           LDRH     R0,[R6, #+0]
   \   000000AC   8C0087E5           STR      R0,[R7, #+140]
    452                  s->nice_match       = configuration_table[level].nice_length;
   \   000000B0   B400D6E1           LDRH     R0,[R6, #+4]
   \   000000B4   900087E5           STR      R0,[R7, #+144]
    453                  s->max_chain_length = configuration_table[level].max_chain;
   \   000000B8   B600D6E1           LDRH     R0,[R6, #+6]
   \   000000BC   7C0087E5           STR      R0,[R7, #+124]
    454              }
    455              s->strategy = strategy;
   \                     ??deflateParams_4:
   \   000000C0   884087E5           STR      R4,[R7, #+136]
    456              return err;
   \   000000C4   0100A0E1           MOV      R0,R1
   \   000000C8   F080BDE8           POP      {R4-R7,PC}       ;; return
    457          }
    458          
    459          /* ========================================================================= */

   \                                 In segment CODE, align 4, keep-with-next
    460          int ZEXPORT deflateTune(strm, good_length, max_lazy, nice_length, max_chain)
    461              z_streamp strm;
    462              int good_length;
    463              int max_lazy;
    464              int nice_length;
    465              int max_chain;
    466          {
   \                     deflateTune:
   \   00000000   00C09DE5           LDR      R12,[SP, #+0]
    467              deflate_state *s;
    468          
    469              if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   1C009015           LDRNE    R0,[R0, #+28]
   \   0000000C   00005013           CMPNE    R0,#+0
   \   00000010   0100E003           MVNEQ    R0,#+1
   \   00000014   1EFF2F01           BXEQ     LR
    470              s = strm->state;
    471              s->good_match = good_length;
   \   00000018   8C1080E5           STR      R1,[R0, #+140]
    472              s->max_lazy_match = max_lazy;
   \   0000001C   802080E5           STR      R2,[R0, #+128]
    473              s->nice_match = nice_length;
   \   00000020   903080E5           STR      R3,[R0, #+144]
    474              s->max_chain_length = max_chain;
   \   00000024   7CC080E5           STR      R12,[R0, #+124]
    475              return Z_OK;
   \   00000028   0000A0E3           MOV      R0,#+0
   \   0000002C   1EFF2FE1           BX       LR               ;; return
    476          }
    477          
    478          /* =========================================================================
    479           * For the default windowBits of 15 and memLevel of 8, this function returns
    480           * a close to exact, as well as small, upper bound on the compressed size.
    481           * They are coded as constants here for a reason--if the #define's are
    482           * changed, then this function needs to be changed as well.  The return
    483           * value for 15 and 8 only works for those exact settings.
    484           *
    485           * For any setting other than those defaults for windowBits and memLevel,
    486           * the value returned is a conservative worst case for the maximum expansion
    487           * resulting from using fixed blocks instead of stored blocks, which deflate
    488           * can emit on compressed data for some combinations of the parameters.
    489           *
    490           * This function could be more sophisticated to provide closer upper bounds
    491           * for every combination of windowBits and memLevel, as well as wrap.
    492           * But even the conservative upper bound of about 14% expansion does not
    493           * seem onerous for output buffer allocation.
    494           */

   \                                 In segment CODE, align 4, keep-with-next
    495          uLong ZEXPORT deflateBound(strm, sourceLen)
    496              z_streamp strm;
    497              uLong sourceLen;
    498          {
    499              deflate_state *s;
    500              uLong destLen;
    501          
    502              /* conservative upper bound */
    503              destLen = sourceLen +
    504                        ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 11;
    505          
    506              /* if can't get parameters, return conservative bound */
    507              if (strm == Z_NULL || strm->state == Z_NULL)
   \                     deflateBound:
   \   00000000   000050E3           CMP      R0,#+0
   \   00000004   1C009015           LDRNE    R0,[R0, #+28]
   \   00000008   072081E2           ADD      R2,R1,#+7
   \   0000000C   A22181E0           ADD      R2,R1,R2, LSR #+3
   \   00000010   3F3081E2           ADD      R3,R1,#+63
   \   00000014   232382E0           ADD      R2,R2,R3, LSR #+6
   \   00000018   0B2082E2           ADD      R2,R2,#+11
   \   0000001C   00005013           CMPNE    R0,#+0
   \   00000020   0100001A           BNE      ??deflateBound_0
    508                  return destLen;
   \                     ??deflateBound_1:
   \   00000024   0200A0E1           MOV      R0,R2
   \   00000028   1EFF2FE1           BX       LR
    509          
    510              /* if not default parameters, return conservative bound */
    511              s = strm->state;
    512              if (s->w_bits != 15 || s->hash_bits != 8 + 7)
   \                     ??deflateBound_0:
   \   0000002C   303090E5           LDR      R3,[R0, #+48]
   \   00000030   0F0053E3           CMP      R3,#+15
   \   00000034   50009005           LDREQ    R0,[R0, #+80]
   \   00000038   0F005003           CMPEQ    R0,#+15
   \   0000003C   F8FFFF1A           BNE      ??deflateBound_1
    513                  return destLen;
    514          
    515              /* default settings: return tight bound for that case */
    516              return compressBound(sourceLen);
   \   00000040   0100A0E1           MOV      R0,R1
   \   00000044   ........           _BF      compressBound,??compressBound??rA  ;; tailcall
    517          }
    518          
    519          /* =========================================================================
    520           * Put a short in the pending buffer. The 16-bit value is put in MSB order.
    521           * IN assertion: the stream state is correct and there is enough room in
    522           * pending_buf.
    523           */

   \                                 In segment CODE, align 4, keep-with-next
    524          local void putShortMSB (s, b)
    525              deflate_state *s;
    526              uInt b;
    527          {
    528              put_byte(s, (Byte)(b >> 8));
   \                     putShortMSB:
   \   00000000   142090E5           LDR      R2,[R0, #+20]
   \   00000004   21C4A0E1           LSR      R12,R1,#+8
   \   00000008   013082E2           ADD      R3,R2,#+1
   \   0000000C   143080E5           STR      R3,[R0, #+20]
   \   00000010   083090E5           LDR      R3,[R0, #+8]
   \   00000014   03C0C2E7           STRB     R12,[R2, +R3]
    529              put_byte(s, (Byte)(b & 0xff));
   \   00000018   142090E5           LDR      R2,[R0, #+20]
   \   0000001C   013082E2           ADD      R3,R2,#+1
   \   00000020   143080E5           STR      R3,[R0, #+20]
   \   00000024   080090E5           LDR      R0,[R0, #+8]
   \   00000028   0010C2E7           STRB     R1,[R2, +R0]
    530          }
   \   0000002C   1EFF2FE1           BX       LR               ;; return
    531          
    532          /* =========================================================================
    533           * Flush as much pending output as possible. All deflate() output goes
    534           * through this function so some applications may wish to modify it
    535           * to avoid allocating a large strm->next_out buffer and copying into it.
    536           * (See also read_buf()).
    537           */

   \                                 In segment CODE, align 4, keep-with-next
    538          local void flush_pending(strm)
    539              z_streamp strm;
    540          {
   \                     flush_pending:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    541              unsigned len = strm->state->pending;
   \   00000008   1C0094E5           LDR      R0,[R4, #+28]
    542          
    543              if (len > strm->avail_out) len = strm->avail_out;
   \   0000000C   101094E5           LDR      R1,[R4, #+16]
   \   00000010   145090E5           LDR      R5,[R0, #+20]
   \   00000014   050051E1           CMP      R1,R5
   \   00000018   0150A031           MOVCC    R5,R1
    544              if (len == 0) return;
   \   0000001C   000055E3           CMP      R5,#+0
   \   00000020   3080BD08           POPEQ    {R4,R5,PC}
    545          
    546              zmemcpy(strm->next_out, strm->state->pending_out, len);
   \   00000024   101090E5           LDR      R1,[R0, #+16]
   \   00000028   0C0094E5           LDR      R0,[R4, #+12]
   \   0000002C   0520A0E1           MOV      R2,R5
   \   00000030   ........           _BLF     memcpy,??memcpy??rA
    547              strm->next_out  += len;
   \   00000034   0C0094E5           LDR      R0,[R4, #+12]
   \   00000038   000085E0           ADD      R0,R5,R0
   \   0000003C   0C0084E5           STR      R0,[R4, #+12]
    548              strm->state->pending_out  += len;
   \   00000040   1C0094E5           LDR      R0,[R4, #+28]
   \   00000044   101090E5           LDR      R1,[R0, #+16]
   \   00000048   011085E0           ADD      R1,R5,R1
   \   0000004C   101080E5           STR      R1,[R0, #+16]
    549              strm->total_out += len;
   \   00000050   141094E5           LDR      R1,[R4, #+20]
   \   00000054   011085E0           ADD      R1,R5,R1
   \   00000058   141084E5           STR      R1,[R4, #+20]
    550              strm->avail_out  -= len;
   \   0000005C   101094E5           LDR      R1,[R4, #+16]
   \   00000060   051041E0           SUB      R1,R1,R5
   \   00000064   101084E5           STR      R1,[R4, #+16]
    551              strm->state->pending -= len;
   \   00000068   141090E5           LDR      R1,[R0, #+20]
   \   0000006C   051041E0           SUB      R1,R1,R5
   \   00000070   141080E5           STR      R1,[R0, #+20]
    552              if (strm->state->pending == 0) {
   \   00000074   000051E3           CMP      R1,#+0
    553                  strm->state->pending_out = strm->state->pending_buf;
   \   00000078   08109005           LDREQ    R1,[R0, #+8]
   \   0000007C   10108005           STREQ    R1,[R0, #+16]
   \   00000080   3080BDE8           POP      {R4,R5,PC}       ;; return
    554              }
    555          }
    556          
    557          /* ========================================================================= */

   \                                 In segment CODE, align 4, keep-with-next
    558          int ZEXPORT deflate (strm, flush)
    559              z_streamp strm;
    560              int flush;
    561          {
   \                     deflate:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0050A0E1           MOV      R5,R0
    562              int old_flush; /* value of flush param for previous deflate call */
    563              deflate_state *s;
    564          
    565              if (strm == Z_NULL || strm->state == Z_NULL ||
    566                  flush > Z_FINISH || flush < 0) {
   \   0000000C   000055E3           CMP      R5,#+0
   \   00000010   1C709515           LDRNE    R7,[R5, #+28]
   \   00000014   0160A0E1           MOV      R6,R1
   \   00000018   00005713           CMPNE    R7,#+0
   \   0000001C   1600000A           BEQ      ??deflate_0
   \   00000020   050056E3           CMP      R6,#+5
   \   00000024   140000AA           BGE      ??deflate_0
   \   00000028   000056E3           CMP      R6,#+0
   \   0000002C   1200004A           BMI      ??deflate_0
    567                  return Z_STREAM_ERROR;
    568              }
    569              s = strm->state;
   \   00000030   0C0095E5           LDR      R0,[R5, #+12]
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   0C00000A           BEQ      ??deflate_1
   \   0000003C   000095E5           LDR      R0,[R5, #+0]
   \   00000040   000050E3           CMP      R0,#+0
   \   00000044   0200001A           BNE      ??deflate_2
   \   00000048   040095E5           LDR      R0,[R5, #+4]
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   0600001A           BNE      ??deflate_1
   \                     ??deflate_2:
   \   00000054   040097E5           LDR      R0,[R7, #+4]
   \   00000058   9A10A0E3           MOV      R1,#+154
   \   0000005C   801F81E3           ORR      R1,R1,#0x200
   \   00000060   010050E1           CMP      R0,R1
   \   00000064   0600001A           BNE      ??deflate_3
   \   00000068   040056E3           CMP      R6,#+4
   \   0000006C   0400000A           BEQ      ??deflate_3
    570          
    571              if (strm->next_out == Z_NULL ||
    572                  (strm->next_in == Z_NULL && strm->avail_in != 0) ||
    573                  (s->status == FINISH_STATE && flush != Z_FINISH)) {
    574                  ERR_RETURN(strm, Z_STREAM_ERROR);
   \                     ??deflate_1:
   \   00000070   280A9FE5           LDR      R0,??deflate_4   ;; z_errmsg + 16
   \   00000074   000090E5           LDR      R0,[R0, #+0]
   \   00000078   180085E5           STR      R0,[R5, #+24]
   \                     ??deflate_0:
   \   0000007C   0100E0E3           MVN      R0,#+1
   \   00000080   F28FBDE8           POP      {R1,R4-R11,PC}
    575              }
    576              if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);
   \                     ??deflate_3:
   \   00000084   101095E5           LDR      R1,[R5, #+16]
   \   00000088   000051E3           CMP      R1,#+0
   \   0000008C   0400001A           BNE      ??deflate_5
   \                     ??deflate_6:
   \   00000090   0C0A9FE5           LDR      R0,??deflate_4+0x4  ;; z_errmsg + 28
   \   00000094   000090E5           LDR      R0,[R0, #+0]
   \   00000098   180085E5           STR      R0,[R5, #+24]
   \   0000009C   0400E0E3           MVN      R0,#+4
   \   000000A0   F28FBDE8           POP      {R1,R4-R11,PC}
    577          
    578              s->strm = strm; /* just in case */
   \                     ??deflate_5:
   \   000000A4   005087E5           STR      R5,[R7, #+0]
    579              old_flush = s->last_flush;
   \   000000A8   282097E5           LDR      R2,[R7, #+40]
    580              s->last_flush = flush;
   \   000000AC   7180A0E3           MOV      R8,#+113
   \   000000B0   00208DE5           STR      R2,[SP, #+0]
   \   000000B4   286087E5           STR      R6,[R7, #+40]
   \   000000B8   0090A0E3           MOV      R9,#+0
   \   000000BC   2A0050E3           CMP      R0,#+42
   \   000000C0   EA00001A           BNE      ??deflate_7
   \   000000C4   180097E5           LDR      R0,[R7, #+24]
   \   000000C8   0240A0E3           MOV      R4,#+2
   \   000000CC   020050E3           CMP      R0,#+2
   \   000000D0   B400001A           BNE      ??deflate_8
    581          
    582              /* Write the header */
    583              if (s->status == INIT_STATE) {
    584          #ifdef GZIP
    585                  if (s->wrap == 2) {
    586                      strm->adler = crc32(0L, Z_NULL, 0);
   \   000000D4   0020A0E3           MOV      R2,#+0
   \   000000D8   0210A0E1           MOV      R1,R2
   \   000000DC   0100A0E1           MOV      R0,R1
   \   000000E0   ........           _BLF     crc32,??crc32??rA
   \   000000E4   300085E5           STR      R0,[R5, #+48]
    587                      put_byte(s, 31);
   \   000000E8   140097E5           LDR      R0,[R7, #+20]
   \   000000EC   1F20A0E3           MOV      R2,#+31
   \   000000F0   011080E2           ADD      R1,R0,#+1
   \   000000F4   141087E5           STR      R1,[R7, #+20]
   \   000000F8   081097E5           LDR      R1,[R7, #+8]
   \   000000FC   0120C0E7           STRB     R2,[R0, +R1]
    588                      put_byte(s, 139);
   \   00000100   140097E5           LDR      R0,[R7, #+20]
   \   00000104   8B20A0E3           MOV      R2,#+139
   \   00000108   011080E2           ADD      R1,R0,#+1
   \   0000010C   141087E5           STR      R1,[R7, #+20]
   \   00000110   081097E5           LDR      R1,[R7, #+8]
   \   00000114   0120C0E7           STRB     R2,[R0, +R1]
    589                      put_byte(s, 8);
   \   00000118   140097E5           LDR      R0,[R7, #+20]
   \   0000011C   0820A0E3           MOV      R2,#+8
   \   00000120   011080E2           ADD      R1,R0,#+1
   \   00000124   141087E5           STR      R1,[R7, #+20]
   \   00000128   081097E5           LDR      R1,[R7, #+8]
   \   0000012C   0120C0E7           STRB     R2,[R0, +R1]
    590                      if (s->gzhead == NULL) {
   \   00000130   1CA097E5           LDR      R10,[R7, #+28]
   \   00000134   141097E5           LDR      R1,[R7, #+20]
   \   00000138   0400A0E3           MOV      R0,#+4
   \   0000013C   00005AE3           CMP      R10,#+0
   \   00000140   012081E2           ADD      R2,R1,#+1
   \   00000144   142087E5           STR      R2,[R7, #+20]
   \   00000148   2A00001A           BNE      ??deflate_9
    591                          put_byte(s, 0);
   \   0000014C   082097E5           LDR      R2,[R7, #+8]
   \   00000150   0290C1E7           STRB     R9,[R1, +R2]
    592                          put_byte(s, 0);
   \   00000154   141097E5           LDR      R1,[R7, #+20]
   \   00000158   012081E2           ADD      R2,R1,#+1
   \   0000015C   142087E5           STR      R2,[R7, #+20]
   \   00000160   082097E5           LDR      R2,[R7, #+8]
   \   00000164   0290C1E7           STRB     R9,[R1, +R2]
    593                          put_byte(s, 0);
   \   00000168   141097E5           LDR      R1,[R7, #+20]
   \   0000016C   012081E2           ADD      R2,R1,#+1
   \   00000170   142087E5           STR      R2,[R7, #+20]
   \   00000174   082097E5           LDR      R2,[R7, #+8]
   \   00000178   0290C1E7           STRB     R9,[R1, +R2]
    594                          put_byte(s, 0);
   \   0000017C   141097E5           LDR      R1,[R7, #+20]
   \   00000180   012081E2           ADD      R2,R1,#+1
   \   00000184   142087E5           STR      R2,[R7, #+20]
   \   00000188   082097E5           LDR      R2,[R7, #+8]
   \   0000018C   0290C1E7           STRB     R9,[R1, +R2]
    595                          put_byte(s, 0);
   \   00000190   141097E5           LDR      R1,[R7, #+20]
   \   00000194   012081E2           ADD      R2,R1,#+1
   \   00000198   142087E5           STR      R2,[R7, #+20]
   \   0000019C   082097E5           LDR      R2,[R7, #+8]
   \   000001A0   0290C1E7           STRB     R9,[R1, +R2]
    596                          put_byte(s, s->level == 9 ? 2 :
    597                                      (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
    598                                       4 : 0));
   \   000001A4   141097E5           LDR      R1,[R7, #+20]
   \   000001A8   012081E2           ADD      R2,R1,#+1
   \   000001AC   142087E5           STR      R2,[R7, #+20]
   \   000001B0   842097E5           LDR      R2,[R7, #+132]
   \   000001B4   090052E3           CMP      R2,#+9
   \   000001B8   0200A003           MOVEQ    R0,#+2
   \   000001BC   0400000A           BEQ      ??deflate_10
   \   000001C0   883097E5           LDR      R3,[R7, #+136]
   \   000001C4   020053E3           CMP      R3,#+2
   \   000001C8   010000AA           BGE      ??deflate_10
   \   000001CC   020052E3           CMP      R2,#+2
   \   000001D0   0000A0A3           MOVGE    R0,#+0
   \                     ??deflate_10:
   \   000001D4   082097E5           LDR      R2,[R7, #+8]
   \   000001D8   0200C1E7           STRB     R0,[R1, +R2]
    599                          put_byte(s, OS_CODE);
   \   000001DC   140097E5           LDR      R0,[R7, #+20]
   \   000001E0   0320A0E3           MOV      R2,#+3
   \   000001E4   011080E2           ADD      R1,R0,#+1
   \   000001E8   141087E5           STR      R1,[R7, #+20]
   \   000001EC   081097E5           LDR      R1,[R7, #+8]
   \   000001F0   0120C0E7           STRB     R2,[R0, +R1]
    600                          s->status = BUSY_STATE;
   \   000001F4   840100EA           B        ??deflate_11
    601                      }
    602                      else {
    603                          put_byte(s, (s->gzhead->text ? 1 : 0) +
    604                                      (s->gzhead->hcrc ? 2 : 0) +
    605                                      (s->gzhead->extra == Z_NULL ? 0 : 4) +
    606                                      (s->gzhead->name == Z_NULL ? 0 : 8) +
    607                                      (s->gzhead->comment == Z_NULL ? 0 : 16)
    608                                  );
   \                     ??deflate_9:
   \   000001F8   00209AE5           LDR      R2,[R10, #+0]
   \   000001FC   2C309AE5           LDR      R3,[R10, #+44]
   \   00000200   10B09AE5           LDR      R11,[R10, #+16]
   \   00000204   000052E3           CMP      R2,#+0
   \   00000208   0120A013           MOVNE    R2,#+1
   \   0000020C   000053E3           CMP      R3,#+0
   \   00000210   0230A013           MOVNE    R3,#+2
   \   00000214   00005BE3           CMP      R11,#+0
   \   00000218   1CB09AE5           LDR      R11,[R10, #+28]
   \   0000021C   24A09AE5           LDR      R10,[R10, #+36]
   \   00000220   00C0A003           MOVEQ    R12,#+0
   \   00000224   04C0A013           MOVNE    R12,#+4
   \   00000228   00005BE3           CMP      R11,#+0
   \   0000022C   08B097E5           LDR      R11,[R7, #+8]
   \   00000230   00E0A003           MOVEQ    LR,#+0
   \   00000234   08E0A013           MOVNE    LR,#+8
   \   00000238   00005AE3           CMP      R10,#+0
   \   0000023C   10A0A013           MOVNE    R10,#+16
   \   00000240   022083E0           ADD      R2,R3,R2
   \   00000244   02208CE0           ADD      R2,R12,R2
   \   00000248   02208EE0           ADD      R2,LR,R2
   \   0000024C   02208AE0           ADD      R2,R10,R2
   \   00000250   0B20C1E7           STRB     R2,[R1, +R11]
    609                          put_byte(s, (Byte)(s->gzhead->time & 0xff));
   \   00000254   141097E5           LDR      R1,[R7, #+20]
   \   00000258   012081E2           ADD      R2,R1,#+1
   \   0000025C   142087E5           STR      R2,[R7, #+20]
   \   00000260   1C3097E5           LDR      R3,[R7, #+28]
   \   00000264   082097E5           LDR      R2,[R7, #+8]
   \   00000268   043093E5           LDR      R3,[R3, #+4]
   \   0000026C   0230C1E7           STRB     R3,[R1, +R2]
    610                          put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));
   \   00000270   141097E5           LDR      R1,[R7, #+20]
   \   00000274   012081E2           ADD      R2,R1,#+1
   \   00000278   142087E5           STR      R2,[R7, #+20]
   \   0000027C   1C3097E5           LDR      R3,[R7, #+28]
   \   00000280   082097E5           LDR      R2,[R7, #+8]
   \   00000284   043093E5           LDR      R3,[R3, #+4]
   \   00000288   2334A0E1           LSR      R3,R3,#+8
   \   0000028C   0230C1E7           STRB     R3,[R1, +R2]
    611                          put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));
   \   00000290   141097E5           LDR      R1,[R7, #+20]
   \   00000294   012081E2           ADD      R2,R1,#+1
   \   00000298   142087E5           STR      R2,[R7, #+20]
   \   0000029C   1C3097E5           LDR      R3,[R7, #+28]
   \   000002A0   082097E5           LDR      R2,[R7, #+8]
   \   000002A4   043093E5           LDR      R3,[R3, #+4]
   \   000002A8   2338A0E1           LSR      R3,R3,#+16
   \   000002AC   0230C1E7           STRB     R3,[R1, +R2]
    612                          put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));
   \   000002B0   141097E5           LDR      R1,[R7, #+20]
   \   000002B4   012081E2           ADD      R2,R1,#+1
   \   000002B8   142087E5           STR      R2,[R7, #+20]
   \   000002BC   1C3097E5           LDR      R3,[R7, #+28]
   \   000002C0   082097E5           LDR      R2,[R7, #+8]
   \   000002C4   043093E5           LDR      R3,[R3, #+4]
   \   000002C8   233CA0E1           LSR      R3,R3,#+24
   \   000002CC   0230C1E7           STRB     R3,[R1, +R2]
    613                          put_byte(s, s->level == 9 ? 2 :
    614                                      (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
    615                                       4 : 0));
   \   000002D0   141097E5           LDR      R1,[R7, #+20]
   \   000002D4   012081E2           ADD      R2,R1,#+1
   \   000002D8   142087E5           STR      R2,[R7, #+20]
   \   000002DC   842097E5           LDR      R2,[R7, #+132]
   \   000002E0   090052E3           CMP      R2,#+9
   \   000002E4   0700000A           BEQ      ??deflate_12
   \   000002E8   883097E5           LDR      R3,[R7, #+136]
   \   000002EC   020053E3           CMP      R3,#+2
   \   000002F0   010000AA           BGE      ??deflate_13
   \   000002F4   020052E3           CMP      R2,#+2
   \   000002F8   010000AA           BGE      ??deflate_14
   \                     ??deflate_13:
   \   000002FC   0440A0E3           MOV      R4,#+4
   \   00000300   000000EA           B        ??deflate_12
   \                     ??deflate_14:
   \   00000304   0040A0E3           MOV      R4,#+0
   \                     ??deflate_12:
   \   00000308   080097E5           LDR      R0,[R7, #+8]
   \   0000030C   0040C1E7           STRB     R4,[R1, +R0]
    616                          put_byte(s, s->gzhead->os & 0xff);
   \   00000310   140097E5           LDR      R0,[R7, #+20]
   \   00000314   011080E2           ADD      R1,R0,#+1
   \   00000318   141087E5           STR      R1,[R7, #+20]
   \   0000031C   1C2097E5           LDR      R2,[R7, #+28]
   \   00000320   081097E5           LDR      R1,[R7, #+8]
   \   00000324   0C2092E5           LDR      R2,[R2, #+12]
   \   00000328   0120C0E7           STRB     R2,[R0, +R1]
    617                          if (s->gzhead->extra != NULL) {
   \   0000032C   1C0097E5           LDR      R0,[R7, #+28]
   \   00000330   101090E5           LDR      R1,[R0, #+16]
   \   00000334   000051E3           CMP      R1,#+0
   \   00000338   0D00000A           BEQ      ??deflate_15
    618                              put_byte(s, s->gzhead->extra_len & 0xff);
   \   0000033C   141097E5           LDR      R1,[R7, #+20]
   \   00000340   012081E2           ADD      R2,R1,#+1
   \   00000344   142087E5           STR      R2,[R7, #+20]
   \   00000348   082097E5           LDR      R2,[R7, #+8]
   \   0000034C   140090E5           LDR      R0,[R0, #+20]
   \   00000350   0200C1E7           STRB     R0,[R1, +R2]
    619                              put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);
   \   00000354   140097E5           LDR      R0,[R7, #+20]
   \   00000358   011080E2           ADD      R1,R0,#+1
   \   0000035C   141087E5           STR      R1,[R7, #+20]
   \   00000360   1C2097E5           LDR      R2,[R7, #+28]
   \   00000364   081097E5           LDR      R1,[R7, #+8]
   \   00000368   142092E5           LDR      R2,[R2, #+20]
   \   0000036C   2224A0E1           LSR      R2,R2,#+8
   \   00000370   0120C0E7           STRB     R2,[R0, +R1]
    620                          }
    621                          if (s->gzhead->hcrc)
   \                     ??deflate_15:
   \   00000374   1C0097E5           LDR      R0,[R7, #+28]
   \   00000378   2C0090E5           LDR      R0,[R0, #+44]
   \   0000037C   000050E3           CMP      R0,#+0
   \   00000380   0400000A           BEQ      ??deflate_16
    622                              strm->adler = crc32(strm->adler, s->pending_buf,
    623                                                  s->pending);
   \   00000384   300095E5           LDR      R0,[R5, #+48]
   \   00000388   142097E5           LDR      R2,[R7, #+20]
   \   0000038C   081097E5           LDR      R1,[R7, #+8]
   \   00000390   ........           _BLF     crc32,??crc32??rA
   \   00000394   300085E5           STR      R0,[R5, #+48]
    624                          s->gzindex = 0;
   \                     ??deflate_16:
   \   00000398   209087E5           STR      R9,[R7, #+32]
    625                          s->status = EXTRA_STATE;
   \   0000039C   4500A0E3           MOV      R0,#+69
   \   000003A0   040087E5           STR      R0,[R7, #+4]
   \   000003A4   340000EA           B        ??deflate_17
    626                      }
    627                  }
    628                  else
    629          #endif
    630                  {
    631                      uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
    632                      uInt level_flags;
    633          
    634                      if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)
   \                     ??deflate_8:
   \   000003A8   880097E5           LDR      R0,[R7, #+136]
   \   000003AC   020050E3           CMP      R0,#+2
   \   000003B0   020000AA           BGE      ??deflate_18
   \   000003B4   840097E5           LDR      R0,[R7, #+132]
   \   000003B8   020050E3           CMP      R0,#+2
   \   000003BC   010000AA           BGE      ??deflate_19
    635                          level_flags = 0;
   \                     ??deflate_18:
   \   000003C0   0040A0E3           MOV      R4,#+0
   \   000003C4   030000EA           B        ??deflate_20
    636                      else if (s->level < 6)
   \                     ??deflate_19:
   \   000003C8   060050E3           CMP      R0,#+6
    637                          level_flags = 1;
   \   000003CC   0140A0B3           MOVLT    R4,#+1
   \   000003D0   000000BA           BLT      ??deflate_20
    638                      else if (s->level == 6)
    639                          level_flags = 2;
    640                      else
    641                          level_flags = 3;
   \   000003D4   0340A013           MOVNE    R4,#+3
    642                      header |= (level_flags << 6);
   \                     ??deflate_20:
   \   000003D8   300097E5           LDR      R0,[R7, #+48]
    643                      if (s->strstart != 0) header |= PRESET_DICT;
    644                      header += 31 - (header % 31);
    645          
    646                      s->status = BUSY_STATE;
    647                      putShortMSB(s, header);
   \   000003DC   C4269FE5           LDR      R2,??deflate_4+0x8  ;; 0x8421085
   \   000003E0   0002A0E1           LSL      R0,R0,#+4
   \   000003E4   780040E2           SUB      R0,R0,#+120
   \   000003E8   0413A0E1           LSL      R1,R4,#+6
   \   000003EC   000481E1           ORR      R0,R1,R0, LSL #+8
   \   000003F0   6C1097E5           LDR      R1,[R7, #+108]
   \   000003F4   048087E5           STR      R8,[R7, #+4]
   \   000003F8   000051E3           CMP      R1,#+0
   \   000003FC   20008013           ORRNE    R0,R0,#0x20
   \   00000400   923084E0           UMULL    R3,R4,R2,R0
   \   00000404   1F30A0E3           MOV      R3,#+31
   \   00000408   004094E0           ADDS     R4,R4,R0
   \   0000040C   6440A0E1           RRX      R4,R4
   \   00000410   2442A0E1           LSR      R4,R4,#+4
   \   00000414   930404E0           MUL      R4,R3,R4
   \   00000418   1F1080E2           ADD      R1,R0,#+31
   \   0000041C   044040E0           SUB      R4,R0,R4
   \   00000420   041041E0           SUB      R1,R1,R4
   \   00000424   0700A0E1           MOV      R0,R7
   \   00000428   ........           BL       putShortMSB
    648          
    649                      /* Save the adler32 of the preset dictionary: */
    650                      if (s->strstart != 0) {
   \   0000042C   6C0097E5           LDR      R0,[R7, #+108]
   \   00000430   000050E3           CMP      R0,#+0
   \   00000434   0800000A           BEQ      ??deflate_21
    651                          putShortMSB(s, (uInt)(strm->adler >> 16));
   \   00000438   300095E5           LDR      R0,[R5, #+48]
   \   0000043C   2018A0E1           LSR      R1,R0,#+16
   \   00000440   0700A0E1           MOV      R0,R7
   \   00000444   ........           BL       putShortMSB
    652                          putShortMSB(s, (uInt)(strm->adler & 0xffff));
   \   00000448   300095E5           LDR      R0,[R5, #+48]
   \   0000044C   0008A0E1           LSL      R0,R0,#+16
   \   00000450   2018A0E1           LSR      R1,R0,#+16
   \   00000454   0700A0E1           MOV      R0,R7
   \   00000458   ........           BL       putShortMSB
    653                      }
    654                      strm->adler = adler32(0L, Z_NULL, 0);
   \                     ??deflate_21:
   \   0000045C   0020A0E3           MOV      R2,#+0
   \   00000460   0210A0E1           MOV      R1,R2
   \   00000464   0100A0E1           MOV      R0,R1
   \   00000468   ........           _BLF     adler32,??adler32??rA
   \   0000046C   300085E5           STR      R0,[R5, #+48]
    655                  }
    656              }
    657          #ifdef GZIP
    658              if (s->status == EXTRA_STATE) {
   \                     ??deflate_7:
   \   00000470   040097E5           LDR      R0,[R7, #+4]
   \   00000474   450050E3           CMP      R0,#+69
   \   00000478   4200001A           BNE      ??deflate_22
    659                  if (s->gzhead->extra != NULL) {
   \                     ??deflate_17:
   \   0000047C   1C0097E5           LDR      R0,[R7, #+28]
   \   00000480   4940A0E3           MOV      R4,#+73
   \   00000484   100090E5           LDR      R0,[R0, #+16]
   \   00000488   000050E3           CMP      R0,#+0
   \   0000048C   3B00000A           BEQ      ??deflate_23
    660                      uInt beg = s->pending;  /* start of bytes to update crc */
   \   00000490   140097E5           LDR      R0,[R7, #+20]
   \   00000494   0B0000EA           B        ??deflate_24
    661          
    662                      while (s->gzindex < (s->gzhead->extra_len & 0xffff)) {
    663                          if (s->pending == s->pending_buf_size) {
    664                              if (s->gzhead->hcrc && s->pending > beg)
    665                                  strm->adler = crc32(strm->adler, s->pending_buf + beg,
    666                                                      s->pending - beg);
    667                              flush_pending(strm);
    668                              beg = s->pending;
    669                              if (s->pending == s->pending_buf_size)
    670                                  break;
    671                          }
    672                          put_byte(s, s->gzhead->extra[s->gzindex]);
   \                     ??deflate_25:
   \   00000498   141097E5           LDR      R1,[R7, #+20]
   \   0000049C   012081E2           ADD      R2,R1,#+1
   \   000004A0   142087E5           STR      R2,[R7, #+20]
   \   000004A4   1CA097E5           LDR      R10,[R7, #+28]
   \   000004A8   203097E5           LDR      R3,[R7, #+32]
   \   000004AC   10A09AE5           LDR      R10,[R10, #+16]
   \   000004B0   082097E5           LDR      R2,[R7, #+8]
   \   000004B4   0A30D3E7           LDRB     R3,[R3, +R10]
   \   000004B8   0230C1E7           STRB     R3,[R1, +R2]
    673                          s->gzindex++;
   \   000004BC   201097E5           LDR      R1,[R7, #+32]
   \   000004C0   011081E2           ADD      R1,R1,#+1
   \   000004C4   201087E5           STR      R1,[R7, #+32]
   \                     ??deflate_24:
   \   000004C8   1C1097E5           LDR      R1,[R7, #+28]
   \   000004CC   202097E5           LDR      R2,[R7, #+32]
   \   000004D0   143091E5           LDR      R3,[R1, #+20]
   \   000004D4   0338A0E1           LSL      R3,R3,#+16
   \   000004D8   230852E1           CMP      R2,R3, LSR #+16
   \   000004DC   1400002A           BCS      ??deflate_26
   \   000004E0   142097E5           LDR      R2,[R7, #+20]
   \   000004E4   0C3097E5           LDR      R3,[R7, #+12]
   \   000004E8   030052E1           CMP      R2,R3
   \   000004EC   E9FFFF1A           BNE      ??deflate_25
   \   000004F0   2C1091E5           LDR      R1,[R1, #+44]
   \   000004F4   000051E3           CMP      R1,#+0
   \   000004F8   0700000A           BEQ      ??deflate_27
   \   000004FC   020050E1           CMP      R0,R2
   \   00000500   0500002A           BCS      ??deflate_27
   \   00000504   081097E5           LDR      R1,[R7, #+8]
   \   00000508   002042E0           SUB      R2,R2,R0
   \   0000050C   011080E0           ADD      R1,R0,R1
   \   00000510   300095E5           LDR      R0,[R5, #+48]
   \   00000514   ........           _BLF     crc32,??crc32??rA
   \   00000518   300085E5           STR      R0,[R5, #+48]
   \                     ??deflate_27:
   \   0000051C   0500A0E1           MOV      R0,R5
   \   00000520   ........           BL       flush_pending
   \   00000524   140097E5           LDR      R0,[R7, #+20]
   \   00000528   0C1097E5           LDR      R1,[R7, #+12]
   \   0000052C   010050E1           CMP      R0,R1
   \   00000530   D8FFFF1A           BNE      ??deflate_25
    674                      }
    675                      if (s->gzhead->hcrc && s->pending > beg)
   \                     ??deflate_26:
   \   00000534   1C1097E5           LDR      R1,[R7, #+28]
   \   00000538   2C1091E5           LDR      R1,[R1, #+44]
   \   0000053C   000051E3           CMP      R1,#+0
   \   00000540   0800000A           BEQ      ??deflate_28
   \   00000544   141097E5           LDR      R1,[R7, #+20]
   \   00000548   010050E1           CMP      R0,R1
   \   0000054C   0500002A           BCS      ??deflate_28
    676                          strm->adler = crc32(strm->adler, s->pending_buf + beg,
    677                                              s->pending - beg);
   \   00000550   002041E0           SUB      R2,R1,R0
   \   00000554   081097E5           LDR      R1,[R7, #+8]
   \   00000558   011080E0           ADD      R1,R0,R1
   \   0000055C   300095E5           LDR      R0,[R5, #+48]
   \   00000560   ........           _BLF     crc32,??crc32??rA
   \   00000564   300085E5           STR      R0,[R5, #+48]
    678                      if (s->gzindex == s->gzhead->extra_len) {
   \                     ??deflate_28:
   \   00000568   1C1097E5           LDR      R1,[R7, #+28]
   \   0000056C   200097E5           LDR      R0,[R7, #+32]
   \   00000570   141091E5           LDR      R1,[R1, #+20]
   \   00000574   010050E1           CMP      R0,R1
   \   00000578   0200001A           BNE      ??deflate_22
    679                          s->gzindex = 0;
   \   0000057C   209087E5           STR      R9,[R7, #+32]
    680                          s->status = NAME_STATE;
   \                     ??deflate_23:
   \   00000580   044087E5           STR      R4,[R7, #+4]
   \   00000584   020000EA           B        ??deflate_29
    681                      }
    682                  }
    683                  else
    684                      s->status = NAME_STATE;
    685              }
    686              if (s->status == NAME_STATE) {
   \                     ??deflate_22:
   \   00000588   040097E5           LDR      R0,[R7, #+4]
   \   0000058C   490050E3           CMP      R0,#+73
   \   00000590   3B00001A           BNE      ??deflate_30
    687                  if (s->gzhead->name != NULL) {
   \                     ??deflate_29:
   \   00000594   1C0097E5           LDR      R0,[R7, #+28]
   \   00000598   5B40A0E3           MOV      R4,#+91
   \   0000059C   1C0090E5           LDR      R0,[R0, #+28]
   \   000005A0   000050E3           CMP      R0,#+0
   \   000005A4   3400000A           BEQ      ??deflate_31
    688                      uInt beg = s->pending;  /* start of bytes to update crc */
   \   000005A8   140097E5           LDR      R0,[R7, #+20]
    689                      int val;
    690          
    691                      do {
    692                          if (s->pending == s->pending_buf_size) {
   \                     ??deflate_32:
   \   000005AC   141097E5           LDR      R1,[R7, #+20]
   \   000005B0   0C2097E5           LDR      R2,[R7, #+12]
   \   000005B4   020051E1           CMP      R1,R2
   \   000005B8   1200001A           BNE      ??deflate_33
    693                              if (s->gzhead->hcrc && s->pending > beg)
   \   000005BC   1C2097E5           LDR      R2,[R7, #+28]
   \   000005C0   2C2092E5           LDR      R2,[R2, #+44]
   \   000005C4   000052E3           CMP      R2,#+0
   \   000005C8   0700000A           BEQ      ??deflate_34
   \   000005CC   010050E1           CMP      R0,R1
   \   000005D0   0500002A           BCS      ??deflate_34
    694                                  strm->adler = crc32(strm->adler, s->pending_buf + beg,
    695                                                      s->pending - beg);
   \   000005D4   002041E0           SUB      R2,R1,R0
   \   000005D8   081097E5           LDR      R1,[R7, #+8]
   \   000005DC   011080E0           ADD      R1,R0,R1
   \   000005E0   300095E5           LDR      R0,[R5, #+48]
   \   000005E4   ........           _BLF     crc32,??crc32??rA
   \   000005E8   300085E5           STR      R0,[R5, #+48]
    696                              flush_pending(strm);
   \                     ??deflate_34:
   \   000005EC   0500A0E1           MOV      R0,R5
   \   000005F0   ........           BL       flush_pending
    697                              beg = s->pending;
   \   000005F4   140097E5           LDR      R0,[R7, #+20]
    698                              if (s->pending == s->pending_buf_size) {
   \   000005F8   0C1097E5           LDR      R1,[R7, #+12]
   \   000005FC   010050E1           CMP      R0,R1
    699                                  val = 1;
   \   00000600   01A0A003           MOVEQ    R10,#+1
    700                                  break;
   \   00000604   0C00000A           BEQ      ??deflate_35
    701                              }
    702                          }
    703                          val = s->gzhead->name[s->gzindex++];
   \                     ??deflate_33:
   \   00000608   201097E5           LDR      R1,[R7, #+32]
   \   0000060C   012081E2           ADD      R2,R1,#+1
   \   00000610   202087E5           STR      R2,[R7, #+32]
   \   00000614   1C2097E5           LDR      R2,[R7, #+28]
   \   00000618   1C2092E5           LDR      R2,[R2, #+28]
   \   0000061C   02A0D1E7           LDRB     R10,[R1, +R2]
    704                          put_byte(s, val);
   \   00000620   141097E5           LDR      R1,[R7, #+20]
   \   00000624   012081E2           ADD      R2,R1,#+1
   \   00000628   142087E5           STR      R2,[R7, #+20]
   \   0000062C   082097E5           LDR      R2,[R7, #+8]
    705                      } while (val != 0);
   \   00000630   00005AE3           CMP      R10,#+0
   \   00000634   02A0C1E7           STRB     R10,[R1, +R2]
   \   00000638   DBFFFF1A           BNE      ??deflate_32
    706                      if (s->gzhead->hcrc && s->pending > beg)
   \                     ??deflate_35:
   \   0000063C   1C1097E5           LDR      R1,[R7, #+28]
   \   00000640   2C1091E5           LDR      R1,[R1, #+44]
   \   00000644   000051E3           CMP      R1,#+0
   \   00000648   0800000A           BEQ      ??deflate_36
   \   0000064C   141097E5           LDR      R1,[R7, #+20]
   \   00000650   010050E1           CMP      R0,R1
   \   00000654   0500002A           BCS      ??deflate_36
    707                          strm->adler = crc32(strm->adler, s->pending_buf + beg,
    708                                              s->pending - beg);
   \   00000658   002041E0           SUB      R2,R1,R0
   \   0000065C   081097E5           LDR      R1,[R7, #+8]
   \   00000660   011080E0           ADD      R1,R0,R1
   \   00000664   300095E5           LDR      R0,[R5, #+48]
   \   00000668   ........           _BLF     crc32,??crc32??rA
   \   0000066C   300085E5           STR      R0,[R5, #+48]
    709                      if (val == 0) {
   \                     ??deflate_36:
   \   00000670   00005AE3           CMP      R10,#+0
   \   00000674   0200001A           BNE      ??deflate_30
    710                          s->gzindex = 0;
   \   00000678   209087E5           STR      R9,[R7, #+32]
    711                          s->status = COMMENT_STATE;
   \                     ??deflate_31:
   \   0000067C   044087E5           STR      R4,[R7, #+4]
   \   00000680   020000EA           B        ??deflate_37
    712                      }
    713                  }
    714                  else
    715                      s->status = COMMENT_STATE;
    716              }
    717              if (s->status == COMMENT_STATE) {
   \                     ??deflate_30:
   \   00000684   040097E5           LDR      R0,[R7, #+4]
   \   00000688   5B0050E3           CMP      R0,#+91
   \   0000068C   3A00001A           BNE      ??deflate_38
    718                  if (s->gzhead->comment != NULL) {
   \                     ??deflate_37:
   \   00000690   1C0097E5           LDR      R0,[R7, #+28]
   \   00000694   6740A0E3           MOV      R4,#+103
   \   00000698   240090E5           LDR      R0,[R0, #+36]
   \   0000069C   000050E3           CMP      R0,#+0
   \   000006A0   3300000A           BEQ      ??deflate_39
    719                      uInt beg = s->pending;  /* start of bytes to update crc */
   \   000006A4   140097E5           LDR      R0,[R7, #+20]
    720                      int val;
    721          
    722                      do {
    723                          if (s->pending == s->pending_buf_size) {
   \                     ??deflate_40:
   \   000006A8   141097E5           LDR      R1,[R7, #+20]
   \   000006AC   0C2097E5           LDR      R2,[R7, #+12]
   \   000006B0   020051E1           CMP      R1,R2
   \   000006B4   1200001A           BNE      ??deflate_41
    724                              if (s->gzhead->hcrc && s->pending > beg)
   \   000006B8   1C2097E5           LDR      R2,[R7, #+28]
   \   000006BC   2C2092E5           LDR      R2,[R2, #+44]
   \   000006C0   000052E3           CMP      R2,#+0
   \   000006C4   0700000A           BEQ      ??deflate_42
   \   000006C8   010050E1           CMP      R0,R1
   \   000006CC   0500002A           BCS      ??deflate_42
    725                                  strm->adler = crc32(strm->adler, s->pending_buf + beg,
    726                                                      s->pending - beg);
   \   000006D0   002041E0           SUB      R2,R1,R0
   \   000006D4   081097E5           LDR      R1,[R7, #+8]
   \   000006D8   011080E0           ADD      R1,R0,R1
   \   000006DC   300095E5           LDR      R0,[R5, #+48]
   \   000006E0   ........           _BLF     crc32,??crc32??rA
   \   000006E4   300085E5           STR      R0,[R5, #+48]
    727                              flush_pending(strm);
   \                     ??deflate_42:
   \   000006E8   0500A0E1           MOV      R0,R5
   \   000006EC   ........           BL       flush_pending
    728                              beg = s->pending;
   \   000006F0   140097E5           LDR      R0,[R7, #+20]
    729                              if (s->pending == s->pending_buf_size) {
   \   000006F4   0C1097E5           LDR      R1,[R7, #+12]
   \   000006F8   010050E1           CMP      R0,R1
    730                                  val = 1;
   \   000006FC   01A0A003           MOVEQ    R10,#+1
    731                                  break;
   \   00000700   0C00000A           BEQ      ??deflate_43
    732                              }
    733                          }
    734                          val = s->gzhead->comment[s->gzindex++];
   \                     ??deflate_41:
   \   00000704   201097E5           LDR      R1,[R7, #+32]
   \   00000708   012081E2           ADD      R2,R1,#+1
   \   0000070C   202087E5           STR      R2,[R7, #+32]
   \   00000710   1C2097E5           LDR      R2,[R7, #+28]
   \   00000714   242092E5           LDR      R2,[R2, #+36]
   \   00000718   02A0D1E7           LDRB     R10,[R1, +R2]
    735                          put_byte(s, val);
   \   0000071C   141097E5           LDR      R1,[R7, #+20]
   \   00000720   012081E2           ADD      R2,R1,#+1
   \   00000724   142087E5           STR      R2,[R7, #+20]
   \   00000728   082097E5           LDR      R2,[R7, #+8]
    736                      } while (val != 0);
   \   0000072C   00005AE3           CMP      R10,#+0
   \   00000730   02A0C1E7           STRB     R10,[R1, +R2]
   \   00000734   DBFFFF1A           BNE      ??deflate_40
    737                      if (s->gzhead->hcrc && s->pending > beg)
   \                     ??deflate_43:
   \   00000738   1C1097E5           LDR      R1,[R7, #+28]
   \   0000073C   2C1091E5           LDR      R1,[R1, #+44]
   \   00000740   000051E3           CMP      R1,#+0
   \   00000744   0800000A           BEQ      ??deflate_44
   \   00000748   141097E5           LDR      R1,[R7, #+20]
   \   0000074C   010050E1           CMP      R0,R1
   \   00000750   0500002A           BCS      ??deflate_44
    738                          strm->adler = crc32(strm->adler, s->pending_buf + beg,
    739                                              s->pending - beg);
   \   00000754   002041E0           SUB      R2,R1,R0
   \   00000758   081097E5           LDR      R1,[R7, #+8]
   \   0000075C   011080E0           ADD      R1,R0,R1
   \   00000760   300095E5           LDR      R0,[R5, #+48]
   \   00000764   ........           _BLF     crc32,??crc32??rA
   \   00000768   300085E5           STR      R0,[R5, #+48]
    740                      if (val == 0)
   \                     ??deflate_44:
   \   0000076C   00005AE3           CMP      R10,#+0
   \   00000770   0100001A           BNE      ??deflate_38
    741                          s->status = HCRC_STATE;
   \                     ??deflate_39:
   \   00000774   044087E5           STR      R4,[R7, #+4]
   \   00000778   020000EA           B        ??deflate_45
    742                  }
    743                  else
    744                      s->status = HCRC_STATE;
    745              }
    746              if (s->status == HCRC_STATE) {
   \                     ??deflate_38:
   \   0000077C   040097E5           LDR      R0,[R7, #+4]
   \   00000780   670050E3           CMP      R0,#+103
   \   00000784   2100001A           BNE      ??deflate_46
    747                  if (s->gzhead->hcrc) {
   \                     ??deflate_45:
   \   00000788   1C0097E5           LDR      R0,[R7, #+28]
   \   0000078C   2C0090E5           LDR      R0,[R0, #+44]
   \   00000790   000050E3           CMP      R0,#+0
   \   00000794   1C00000A           BEQ      ??deflate_11
    748                      if (s->pending + 2 > s->pending_buf_size)
   \   00000798   0C0097E5           LDR      R0,[R7, #+12]
   \   0000079C   141097E5           LDR      R1,[R7, #+20]
   \   000007A0   021081E2           ADD      R1,R1,#+2
   \   000007A4   010050E1           CMP      R0,R1
   \   000007A8   0100002A           BCS      ??deflate_47
    749                          flush_pending(strm);
   \   000007AC   0500A0E1           MOV      R0,R5
   \   000007B0   ........           BL       flush_pending
    750                      if (s->pending + 2 <= s->pending_buf_size) {
   \                     ??deflate_47:
   \   000007B4   140097E5           LDR      R0,[R7, #+20]
   \   000007B8   0C1097E5           LDR      R1,[R7, #+12]
   \   000007BC   022080E2           ADD      R2,R0,#+2
   \   000007C0   020051E1           CMP      R1,R2
   \   000007C4   1100003A           BCC      ??deflate_46
    751                          put_byte(s, (Byte)(strm->adler & 0xff));
   \   000007C8   011080E2           ADD      R1,R0,#+1
   \   000007CC   141087E5           STR      R1,[R7, #+20]
   \   000007D0   081097E5           LDR      R1,[R7, #+8]
   \   000007D4   302095E5           LDR      R2,[R5, #+48]
   \   000007D8   0120C0E7           STRB     R2,[R0, +R1]
    752                          put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
   \   000007DC   140097E5           LDR      R0,[R7, #+20]
   \   000007E0   011080E2           ADD      R1,R0,#+1
   \   000007E4   141087E5           STR      R1,[R7, #+20]
   \   000007E8   081097E5           LDR      R1,[R7, #+8]
   \   000007EC   302095E5           LDR      R2,[R5, #+48]
   \   000007F0   2224A0E1           LSR      R2,R2,#+8
   \   000007F4   0120C0E7           STRB     R2,[R0, +R1]
    753                          strm->adler = crc32(0L, Z_NULL, 0);
   \   000007F8   0020A0E3           MOV      R2,#+0
   \   000007FC   0210A0E1           MOV      R1,R2
   \   00000800   0100A0E1           MOV      R0,R1
   \   00000804   ........           _BLF     crc32,??crc32??rA
   \   00000808   300085E5           STR      R0,[R5, #+48]
    754                          s->status = BUSY_STATE;
    755                      }
    756                  }
    757                  else
    758                      s->status = BUSY_STATE;
   \                     ??deflate_11:
   \   0000080C   048087E5           STR      R8,[R7, #+4]
    759              }
    760          #endif
    761          
    762              /* Flush as much pending output as possible */
    763              if (s->pending != 0) {
   \                     ??deflate_46:
   \   00000810   140097E5           LDR      R0,[R7, #+20]
   \   00000814   0940E0E1           MVN      R4,R9
   \   00000818   000050E3           CMP      R0,#+0
   \   0000081C   0700000A           BEQ      ??deflate_48
    764                  flush_pending(strm);
   \   00000820   0500A0E1           MOV      R0,R5
   \   00000824   ........           BL       flush_pending
    765                  if (strm->avail_out == 0) {
   \   00000828   100095E5           LDR      R0,[R5, #+16]
   \   0000082C   000050E3           CMP      R0,#+0
   \   00000830   0A00001A           BNE      ??deflate_49
    766                      /* Since avail_out is 0, deflate will be called again with
    767                       * more output space, but possibly with both pending and
    768                       * avail_in equal to zero. There won't be anything to do,
    769                       * but this is not an error situation so make sure we
    770                       * return OK instead of BUF_ERROR at next call of deflate:
    771                       */
    772                      s->last_flush = -1;
   \                     ??deflate_50:
   \   00000834   284087E5           STR      R4,[R7, #+40]
    773                      return Z_OK;
   \   00000838   0000A0E3           MOV      R0,#+0
   \   0000083C   F28FBDE8           POP      {R1,R4-R11,PC}
    774                  }
    775          
    776              /* Make sure there is something to do and avoid duplicate consecutive
    777               * flushes. For repeated and useless calls with Z_FINISH, we keep
    778               * returning Z_STREAM_END instead of Z_BUF_ERROR.
    779               */
    780              } else if (strm->avail_in == 0 && flush <= old_flush &&
    781                         flush != Z_FINISH) {
   \                     ??deflate_48:
   \   00000840   040095E5           LDR      R0,[R5, #+4]
   \   00000844   000050E3           CMP      R0,#+0
   \   00000848   0400001A           BNE      ??deflate_49
   \   0000084C   00009DE5           LDR      R0,[SP, #+0]
   \   00000850   060050E1           CMP      R0,R6
   \   00000854   010000BA           BLT      ??deflate_49
   \   00000858   040056E3           CMP      R6,#+4
   \   0000085C   0BFEFF1A           BNE      ??deflate_6
    782                  ERR_RETURN(strm, Z_BUF_ERROR);
    783              }
    784          
    785              /* User must not provide more input after the first FINISH: */
    786              if (s->status == FINISH_STATE && strm->avail_in != 0) {
   \                     ??deflate_49:
   \   00000860   040097E5           LDR      R0,[R7, #+4]
   \   00000864   041095E5           LDR      R1,[R5, #+4]
   \   00000868   9A20A0E3           MOV      R2,#+154
   \   0000086C   802F82E3           ORR      R2,R2,#0x200
   \   00000870   020050E1           CMP      R0,R2
   \   00000874   0100001A           BNE      ??deflate_51
   \   00000878   000051E3           CMP      R1,#+0
   \   0000087C   03FEFF1A           BNE      ??deflate_6
    787                  ERR_RETURN(strm, Z_BUF_ERROR);
    788              }
    789          
    790              /* Start a new block or continue the current one.
    791               */
    792              if (strm->avail_in != 0 || s->lookahead != 0 ||
    793                  (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
   \                     ??deflate_51:
   \   00000880   000051E3           CMP      R1,#+0
   \   00000884   74109705           LDREQ    R1,[R7, #+116]
   \   00000888   00005103           CMPEQ    R1,#+0
   \   0000088C   0200001A           BNE      ??deflate_52
   \   00000890   000056E3           CMP      R6,#+0
   \   00000894   02005011           CMPNE    R0,R2
   \   00000898   2F00000A           BEQ      ??deflate_53
    794                  block_state bstate;
    795          
    796                  bstate = (*(configuration_table[s->level].func))(s, flush);
   \                     ??deflate_52:
   \   0000089C   842097E5           LDR      R2,[R7, #+132]
   \   000008A0   ........           LDR      R8,??DataTable1  ;; configuration_table
   \   000008A4   0C30A0E3           MOV      R3,#+12
   \   000008A8   938222E0           MLA      R2,R3,R2,R8
   \   000008AC   0610A0E1           MOV      R1,R6
   \   000008B0   082092E5           LDR      R2,[R2, #+8]
   \   000008B4   0700A0E1           MOV      R0,R7
   \   000008B8   32FF2FE1           BLX      R2
    797          
    798                  if (bstate == finish_started || bstate == finish_done) {
   \   000008BC   020050E3           CMP      R0,#+2
   \   000008C0   03005013           CMPNE    R0,#+3
    799                      s->status = FINISH_STATE;
   \   000008C4   9A10A003           MOVEQ    R1,#+154
   \   000008C8   801F8103           ORREQ    R1,R1,#0x200
   \   000008CC   04108705           STREQ    R1,[R7, #+4]
    800                  }
    801                  if (bstate == need_more || bstate == finish_started) {
   \   000008D0   000050E3           CMP      R0,#+0
   \   000008D4   02005013           CMPNE    R0,#+2
   \   000008D8   0400001A           BNE      ??deflate_54
    802                      if (strm->avail_out == 0) {
   \   000008DC   100095E5           LDR      R0,[R5, #+16]
   \   000008E0   000050E3           CMP      R0,#+0
    803                          s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
   \   000008E4   28408705           STREQ    R4,[R7, #+40]
    804                      }
    805                      return Z_OK;
   \                     ??deflate_55:
   \   000008E8   0000A0E3           MOV      R0,#+0
   \   000008EC   F28FBDE8           POP      {R1,R4-R11,PC}
    806                      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
    807                       * of deflate should use the same flush parameter to make sure
    808                       * that the flush is complete. So we don't have to output an
    809                       * empty block here, this will be done at next call. This also
    810                       * ensures that for a very small output buffer, we emit at most
    811                       * one empty block.
    812                       */
    813                  }
    814                  if (bstate == block_done) {
   \                     ??deflate_54:
   \   000008F0   010050E3           CMP      R0,#+1
   \   000008F4   1800001A           BNE      ??deflate_53
    815                      if (flush == Z_PARTIAL_FLUSH) {
   \   000008F8   010056E3           CMP      R6,#+1
   \   000008FC   0200001A           BNE      ??deflate_56
    816                          _tr_align(s);
   \   00000900   0700A0E1           MOV      R0,R7
   \   00000904   ........           _BLF     _tr_align,??_tr_align??rA
   \   00000908   0E0000EA           B        ??deflate_57
    817                      } else { /* FULL_FLUSH or SYNC_FLUSH */
    818                          _tr_stored_block(s, (char*)0, 0L, 0);
   \                     ??deflate_56:
   \   0000090C   0030A0E3           MOV      R3,#+0
   \   00000910   0320A0E1           MOV      R2,R3
   \   00000914   0210A0E1           MOV      R1,R2
   \   00000918   0700A0E1           MOV      R0,R7
   \   0000091C   ........           _BLF     _tr_stored_block,??_tr_stored_block??rA
    819                          /* For a full flush, this empty block will be recognized
    820                           * as a special marker by inflate_sync().
    821                           */
    822                          if (flush == Z_FULL_FLUSH) {
   \   00000920   030056E3           CMP      R6,#+3
   \   00000924   0700001A           BNE      ??deflate_57
    823                              CLEAR_HASH(s);             /* forget history */
   \   00000928   4C1097E5           LDR      R1,[R7, #+76]
   \   0000092C   440097E5           LDR      R0,[R7, #+68]
   \   00000930   812080E0           ADD      R2,R0,R1, LSL #+1
   \   00000934   B29042E1           STRH     R9,[R2, #-2]
   \   00000938   011041E2           SUB      R1,R1,#+1
   \   0000093C   8120A0E1           LSL      R2,R1,#+1
   \   00000940   0010A0E3           MOV      R1,#+0
   \   00000944   ........           _BLF     memset,??memset??rA
    824                          }
    825                      }
    826                      flush_pending(strm);
   \                     ??deflate_57:
   \   00000948   0500A0E1           MOV      R0,R5
   \   0000094C   ........           BL       flush_pending
    827                      if (strm->avail_out == 0) {
   \   00000950   100095E5           LDR      R0,[R5, #+16]
   \   00000954   000050E3           CMP      R0,#+0
   \   00000958   B5FFFF0A           BEQ      ??deflate_50
    828                        s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
    829                        return Z_OK;
    830                      }
    831                  }
    832              }
    833              Assert(strm->avail_out > 0, "bug2");
    834          
    835              if (flush != Z_FINISH) return Z_OK;
   \                     ??deflate_53:
   \   0000095C   040056E3           CMP      R6,#+4
   \   00000960   E0FFFF1A           BNE      ??deflate_55
    836              if (s->wrap <= 0) return Z_STREAM_END;
   \   00000964   180097E5           LDR      R0,[R7, #+24]
   \   00000968   010050E3           CMP      R0,#+1
   \   0000096C   490000BA           BLT      ??deflate_58
    837          
    838              /* Write the trailer */
    839          #ifdef GZIP
    840              if (s->wrap == 2) {
   \   00000970   301095E5           LDR      R1,[R5, #+48]
   \   00000974   020050E3           CMP      R0,#+2
   \   00000978   3500001A           BNE      ??deflate_59
    841                  put_byte(s, (Byte)(strm->adler & 0xff));
   \   0000097C   140097E5           LDR      R0,[R7, #+20]
   \   00000980   012080E2           ADD      R2,R0,#+1
   \   00000984   142087E5           STR      R2,[R7, #+20]
   \   00000988   082097E5           LDR      R2,[R7, #+8]
   \   0000098C   0210C0E7           STRB     R1,[R0, +R2]
    842                  put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
   \   00000990   140097E5           LDR      R0,[R7, #+20]
   \   00000994   011080E2           ADD      R1,R0,#+1
   \   00000998   141087E5           STR      R1,[R7, #+20]
   \   0000099C   081097E5           LDR      R1,[R7, #+8]
   \   000009A0   302095E5           LDR      R2,[R5, #+48]
   \   000009A4   2224A0E1           LSR      R2,R2,#+8
   \   000009A8   0120C0E7           STRB     R2,[R0, +R1]
    843                  put_byte(s, (Byte)((strm->adler >> 16) & 0xff));
   \   000009AC   140097E5           LDR      R0,[R7, #+20]
   \   000009B0   011080E2           ADD      R1,R0,#+1
   \   000009B4   141087E5           STR      R1,[R7, #+20]
   \   000009B8   081097E5           LDR      R1,[R7, #+8]
   \   000009BC   302095E5           LDR      R2,[R5, #+48]
   \   000009C0   2228A0E1           LSR      R2,R2,#+16
   \   000009C4   0120C0E7           STRB     R2,[R0, +R1]
    844                  put_byte(s, (Byte)((strm->adler >> 24) & 0xff));
   \   000009C8   140097E5           LDR      R0,[R7, #+20]
   \   000009CC   011080E2           ADD      R1,R0,#+1
   \   000009D0   141087E5           STR      R1,[R7, #+20]
   \   000009D4   081097E5           LDR      R1,[R7, #+8]
   \   000009D8   302095E5           LDR      R2,[R5, #+48]
   \   000009DC   222CA0E1           LSR      R2,R2,#+24
   \   000009E0   0120C0E7           STRB     R2,[R0, +R1]
    845                  put_byte(s, (Byte)(strm->total_in & 0xff));
   \   000009E4   140097E5           LDR      R0,[R7, #+20]
   \   000009E8   011080E2           ADD      R1,R0,#+1
   \   000009EC   141087E5           STR      R1,[R7, #+20]
   \   000009F0   081097E5           LDR      R1,[R7, #+8]
   \   000009F4   082095E5           LDR      R2,[R5, #+8]
   \   000009F8   0120C0E7           STRB     R2,[R0, +R1]
    846                  put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));
   \   000009FC   140097E5           LDR      R0,[R7, #+20]
   \   00000A00   011080E2           ADD      R1,R0,#+1
   \   00000A04   141087E5           STR      R1,[R7, #+20]
   \   00000A08   081097E5           LDR      R1,[R7, #+8]
   \   00000A0C   082095E5           LDR      R2,[R5, #+8]
   \   00000A10   2224A0E1           LSR      R2,R2,#+8
   \   00000A14   0120C0E7           STRB     R2,[R0, +R1]
    847                  put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));
   \   00000A18   140097E5           LDR      R0,[R7, #+20]
   \   00000A1C   011080E2           ADD      R1,R0,#+1
   \   00000A20   141087E5           STR      R1,[R7, #+20]
   \   00000A24   081097E5           LDR      R1,[R7, #+8]
   \   00000A28   082095E5           LDR      R2,[R5, #+8]
   \   00000A2C   2228A0E1           LSR      R2,R2,#+16
   \   00000A30   0120C0E7           STRB     R2,[R0, +R1]
    848                  put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));
   \   00000A34   140097E5           LDR      R0,[R7, #+20]
   \   00000A38   011080E2           ADD      R1,R0,#+1
   \   00000A3C   141087E5           STR      R1,[R7, #+20]
   \   00000A40   081097E5           LDR      R1,[R7, #+8]
   \   00000A44   082095E5           LDR      R2,[R5, #+8]
   \   00000A48   222CA0E1           LSR      R2,R2,#+24
   \   00000A4C   0120C0E7           STRB     R2,[R0, +R1]
   \   00000A50   070000EA           B        ??deflate_60
    849              }
    850              else
    851          #endif
    852              {
    853                  putShortMSB(s, (uInt)(strm->adler >> 16));
   \                     ??deflate_59:
   \   00000A54   2118A0E1           LSR      R1,R1,#+16
   \   00000A58   0700A0E1           MOV      R0,R7
   \   00000A5C   ........           BL       putShortMSB
    854                  putShortMSB(s, (uInt)(strm->adler & 0xffff));
   \   00000A60   300095E5           LDR      R0,[R5, #+48]
   \   00000A64   0008A0E1           LSL      R0,R0,#+16
   \   00000A68   2018A0E1           LSR      R1,R0,#+16
   \   00000A6C   0700A0E1           MOV      R0,R7
   \   00000A70   ........           BL       putShortMSB
    855              }
    856              flush_pending(strm);
   \                     ??deflate_60:
   \   00000A74   0500A0E1           MOV      R0,R5
   \   00000A78   ........           BL       flush_pending
    857              /* If avail_out is zero, the application will call deflate again
    858               * to flush the rest.
    859               */
    860              if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */
   \   00000A7C   180097E5           LDR      R0,[R7, #+24]
   \   00000A80   010050E3           CMP      R0,#+1
   \   00000A84   000060A2           RSBGE    R0,R0,#+0
   \   00000A88   180087A5           STRGE    R0,[R7, #+24]
    861              return s->pending != 0 ? Z_OK : Z_STREAM_END;
   \   00000A8C   140097E5           LDR      R0,[R7, #+20]
   \   00000A90   000050E3           CMP      R0,#+0
   \   00000A94   93FFFF1A           BNE      ??deflate_55
   \                     ??deflate_58:
   \   00000A98   0100A0E3           MOV      R0,#+1
   \   00000A9C   F28FBDE8           POP      {R1,R4-R11,PC}   ;; return
   \                     ??deflate_4:
   \   00000AA0   ........           DC32     z_errmsg + 16
   \   00000AA4   ........           DC32     z_errmsg + 28
   \   00000AA8   85104208           DC32     0x8421085
    862          }
    863          
    864          /* ========================================================================= */

   \                                 In segment CODE, align 4, keep-with-next
    865          int ZEXPORT deflateEnd (strm)
    866              z_streamp strm;
    867          {
   \                     deflateEnd:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    868              int status;
    869          
    870              if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
   \   00000008   1C009415           LDRNE    R0,[R4, #+28]
   \   0000000C   00005013           CMPNE    R0,#+0
   \   00000010   0100001A           BNE      ??deflateEnd_0
   \                     ??deflateEnd_1:
   \   00000014   0100E0E3           MVN      R0,#+1
   \   00000018   3080BDE8           POP      {R4,R5,PC}
    871          
    872              status = strm->state->status;
   \                     ??deflateEnd_0:
   \   0000001C   045090E5           LDR      R5,[R0, #+4]
    873              if (status != INIT_STATE &&
    874                  status != EXTRA_STATE &&
    875                  status != NAME_STATE &&
    876                  status != COMMENT_STATE &&
    877                  status != HCRC_STATE &&
    878                  status != BUSY_STATE &&
    879                  status != FINISH_STATE) {
   \   00000020   2A0055E3           CMP      R5,#+42
   \   00000024   45005513           CMPNE    R5,#+69
   \   00000028   49005513           CMPNE    R5,#+73
   \   0000002C   5B005513           CMPNE    R5,#+91
   \   00000030   67005513           CMPNE    R5,#+103
   \   00000034   71005513           CMPNE    R5,#+113
   \   00000038   0300000A           BEQ      ??deflateEnd_2
   \   0000003C   9A10A0E3           MOV      R1,#+154
   \   00000040   801F81E3           ORR      R1,R1,#0x200
   \   00000044   010055E1           CMP      R5,R1
   \   00000048   F1FFFF1A           BNE      ??deflateEnd_1
    880                return Z_STREAM_ERROR;
    881              }
    882          
    883              /* Deallocate in reverse order of allocations: */
    884              TRY_FREE(strm, strm->state->pending_buf);
   \                     ??deflateEnd_2:
   \   0000004C   081090E5           LDR      R1,[R0, #+8]
   \   00000050   000051E3           CMP      R1,#+0
   \   00000054   0200000A           BEQ      ??deflateEnd_3
   \   00000058   280094E5           LDR      R0,[R4, #+40]
   \   0000005C   242094E5           LDR      R2,[R4, #+36]
   \   00000060   32FF2FE1           BLX      R2
    885              TRY_FREE(strm, strm->state->head);
   \                     ??deflateEnd_3:
   \   00000064   1C0094E5           LDR      R0,[R4, #+28]
   \   00000068   441090E5           LDR      R1,[R0, #+68]
   \   0000006C   000051E3           CMP      R1,#+0
   \   00000070   0200000A           BEQ      ??deflateEnd_4
   \   00000074   280094E5           LDR      R0,[R4, #+40]
   \   00000078   242094E5           LDR      R2,[R4, #+36]
   \   0000007C   32FF2FE1           BLX      R2
    886              TRY_FREE(strm, strm->state->prev);
   \                     ??deflateEnd_4:
   \   00000080   1C0094E5           LDR      R0,[R4, #+28]
   \   00000084   401090E5           LDR      R1,[R0, #+64]
   \   00000088   000051E3           CMP      R1,#+0
   \   0000008C   0200000A           BEQ      ??deflateEnd_5
   \   00000090   280094E5           LDR      R0,[R4, #+40]
   \   00000094   242094E5           LDR      R2,[R4, #+36]
   \   00000098   32FF2FE1           BLX      R2
    887              TRY_FREE(strm, strm->state->window);
   \                     ??deflateEnd_5:
   \   0000009C   1C0094E5           LDR      R0,[R4, #+28]
   \   000000A0   381090E5           LDR      R1,[R0, #+56]
   \   000000A4   000051E3           CMP      R1,#+0
   \   000000A8   0200000A           BEQ      ??deflateEnd_6
   \   000000AC   280094E5           LDR      R0,[R4, #+40]
   \   000000B0   242094E5           LDR      R2,[R4, #+36]
   \   000000B4   32FF2FE1           BLX      R2
    888          
    889              ZFREE(strm, strm->state);
   \                     ??deflateEnd_6:
   \   000000B8   280094E5           LDR      R0,[R4, #+40]
   \   000000BC   1C1094E5           LDR      R1,[R4, #+28]
   \   000000C0   242094E5           LDR      R2,[R4, #+36]
   \   000000C4   32FF2FE1           BLX      R2
    890              strm->state = Z_NULL;
   \   000000C8   0000A0E3           MOV      R0,#+0
   \   000000CC   1C0084E5           STR      R0,[R4, #+28]
    891          
    892              return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
   \   000000D0   710055E3           CMP      R5,#+113
   \   000000D4   0200E003           MVNEQ    R0,#+2
   \   000000D8   3080BDE8           POP      {R4,R5,PC}       ;; return
    893          }
    894          
    895          /* =========================================================================
    896           * Copy the source state to the destination state.
    897           * To simplify the source, this is not supported for 16-bit MSDOS (which
    898           * doesn't have enough memory anyway to duplicate compression states).
    899           */

   \                                 In segment CODE, align 4, keep-with-next
    900          int ZEXPORT deflateCopy (dest, source)
    901              z_streamp dest;
    902              z_streamp source;
    903          {
   \                     deflateCopy:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    904          #ifdef MAXSEG_64K
    905              return Z_STREAM_ERROR;
    906          #else
    907              deflate_state *ds;
    908              deflate_state *ss;
    909              ushf *overlay;
    910          
    911          
    912              if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {
   \   00000008   000051E3           CMP      R1,#+0
   \   0000000C   00005413           CMPNE    R4,#+0
   \   00000010   1C609115           LDRNE    R6,[R1, #+28]
   \   00000014   00005613           CMPNE    R6,#+0
    913                  return Z_STREAM_ERROR;
   \   00000018   0100E003           MVNEQ    R0,#+1
   \   0000001C   F081BD08           POPEQ    {R4-R8,PC}
    914              }
    915          
    916              ss = source->state;
    917          
    918              zmemcpy(dest, source, sizeof(z_stream));
   \   00000020   3820A0E3           MOV      R2,#+56
   \   00000024   ........           _BLF     memcpy,??memcpy??rA
    919          
    920              ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
   \   00000028   280094E5           LDR      R0,[R4, #+40]
   \   0000002C   203094E5           LDR      R3,[R4, #+32]
   \   00000030   5B2DA0E3           MOV      R2,#+5824
   \   00000034   0110A0E3           MOV      R1,#+1
   \   00000038   33FF2FE1           BLX      R3
   \   0000003C   0050B0E1           MOVS     R5,R0
    921              if (ds == Z_NULL) return Z_MEM_ERROR;
   \   00000040   2A00000A           BEQ      ??deflateCopy_0
    922              dest->state = (struct internal_state FAR *) ds;
   \   00000044   1C5084E5           STR      R5,[R4, #+28]
    923              zmemcpy(ds, ss, sizeof(deflate_state));
   \   00000048   5B2DA0E3           MOV      R2,#+5824
   \   0000004C   0610A0E1           MOV      R1,R6
   \   00000050   ........           _BLF     memcpy,??memcpy??rA
    924              ds->strm = dest;
   \   00000054   004085E5           STR      R4,[R5, #+0]
    925          
    926              ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
   \   00000058   280094E5           LDR      R0,[R4, #+40]
   \   0000005C   2C1095E5           LDR      R1,[R5, #+44]
   \   00000060   203094E5           LDR      R3,[R4, #+32]
   \   00000064   0220A0E3           MOV      R2,#+2
   \   00000068   33FF2FE1           BLX      R3
   \   0000006C   380085E5           STR      R0,[R5, #+56]
    927              ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
   \   00000070   280094E5           LDR      R0,[R4, #+40]
   \   00000074   2C1095E5           LDR      R1,[R5, #+44]
   \   00000078   203094E5           LDR      R3,[R4, #+32]
   \   0000007C   0220A0E3           MOV      R2,#+2
   \   00000080   33FF2FE1           BLX      R3
   \   00000084   400085E5           STR      R0,[R5, #+64]
    928              ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
   \   00000088   280094E5           LDR      R0,[R4, #+40]
   \   0000008C   4C1095E5           LDR      R1,[R5, #+76]
   \   00000090   203094E5           LDR      R3,[R4, #+32]
   \   00000094   0220A0E3           MOV      R2,#+2
   \   00000098   33FF2FE1           BLX      R3
   \   0000009C   440085E5           STR      R0,[R5, #+68]
   \   000000A0   203094E5           LDR      R3,[R4, #+32]
   \   000000A4   9800A0E3           MOV      R0,#+152
   \   000000A8   580D80E3           ORR      R0,R0,#0x1600
   \   000000AC   057080E0           ADD      R7,R0,R5
   \   000000B0   280094E5           LDR      R0,[R4, #+40]
   \   000000B4   041097E5           LDR      R1,[R7, #+4]
   \   000000B8   0420A0E3           MOV      R2,#+4
    929              overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);
   \   000000BC   33FF2FE1           BLX      R3
   \   000000C0   0080A0E1           MOV      R8,R0
    930              ds->pending_buf = (uchf *) overlay;
   \   000000C4   088085E5           STR      R8,[R5, #+8]
    931          
    932              if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
    933                  ds->pending_buf == Z_NULL) {
   \   000000C8   380095E5           LDR      R0,[R5, #+56]
   \   000000CC   000050E3           CMP      R0,#+0
   \   000000D0   40109515           LDRNE    R1,[R5, #+64]
   \   000000D4   00005113           CMPNE    R1,#+0
   \   000000D8   44109515           LDRNE    R1,[R5, #+68]
   \   000000DC   00005113           CMPNE    R1,#+0
   \   000000E0   00005813           CMPNE    R8,#+0
   \   000000E4   0300001A           BNE      ??deflateCopy_1
    934                  deflateEnd (dest);
   \   000000E8   0400A0E1           MOV      R0,R4
   \   000000EC   ........           BL       deflateEnd
    935                  return Z_MEM_ERROR;
   \                     ??deflateCopy_0:
   \   000000F0   0300E0E3           MVN      R0,#+3
   \   000000F4   F081BDE8           POP      {R4-R8,PC}
    936              }
    937              /* following zmemcpy do not work for 16-bit MSDOS */
    938              zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
   \                     ??deflateCopy_1:
   \   000000F8   2C1095E5           LDR      R1,[R5, #+44]
   \   000000FC   8120A0E1           LSL      R2,R1,#+1
   \   00000100   381096E5           LDR      R1,[R6, #+56]
   \   00000104   ........           _BLF     memcpy,??memcpy??rA
    939              zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));
   \   00000108   2C0095E5           LDR      R0,[R5, #+44]
   \   0000010C   401096E5           LDR      R1,[R6, #+64]
   \   00000110   8020A0E1           LSL      R2,R0,#+1
   \   00000114   400095E5           LDR      R0,[R5, #+64]
   \   00000118   ........           _BLF     memcpy,??memcpy??rA
    940              zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));
   \   0000011C   4C0095E5           LDR      R0,[R5, #+76]
   \   00000120   441096E5           LDR      R1,[R6, #+68]
   \   00000124   8020A0E1           LSL      R2,R0,#+1
   \   00000128   440095E5           LDR      R0,[R5, #+68]
   \   0000012C   ........           _BLF     memcpy,??memcpy??rA
    941              zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);
   \   00000130   0C2095E5           LDR      R2,[R5, #+12]
   \   00000134   081096E5           LDR      R1,[R6, #+8]
   \   00000138   080095E5           LDR      R0,[R5, #+8]
   \   0000013C   ........           _BLF     memcpy,??memcpy??rA
    942          
    943              ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
   \   00000140   100096E5           LDR      R0,[R6, #+16]
   \   00000144   081096E5           LDR      R1,[R6, #+8]
   \   00000148   010040E0           SUB      R0,R0,R1
   \   0000014C   081095E5           LDR      R1,[R5, #+8]
   \   00000150   010080E0           ADD      R0,R0,R1
   \   00000154   100085E5           STR      R0,[R5, #+16]
    944              ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);
   \   00000158   040097E5           LDR      R0,[R7, #+4]
   \   0000015C   A010A0E1           LSR      R1,R0,#+1
   \   00000160   811088E0           ADD      R1,R8,R1, LSL #+1
   \   00000164   0C1087E5           STR      R1,[R7, #+12]
    945              ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;
   \   00000168   081095E5           LDR      R1,[R5, #+8]
   \   0000016C   800080E0           ADD      R0,R0,R0, LSL #+1
   \   00000170   010080E0           ADD      R0,R0,R1
   \   00000174   000087E5           STR      R0,[R7, #+0]
    946          
    947              ds->l_desc.dyn_tree = ds->dyn_ltree;
   \   00000178   940085E2           ADD      R0,R5,#+148
   \   0000017C   180B85E5           STR      R0,[R5, #+2840]
    948              ds->d_desc.dyn_tree = ds->dyn_dtree;
   \   00000180   8800A0E3           MOV      R0,#+136
   \   00000184   900E80E3           ORR      R0,R0,#0x900
   \   00000188   050080E0           ADD      R0,R0,R5
   \   0000018C   240B85E5           STR      R0,[R5, #+2852]
    949              ds->bl_desc.dyn_tree = ds->bl_tree;
   \   00000190   7C00A0E3           MOV      R0,#+124
   \   00000194   A00E80E3           ORR      R0,R0,#0xA00
   \   00000198   050080E0           ADD      R0,R0,R5
   \   0000019C   300B85E5           STR      R0,[R5, #+2864]
    950          
    951              return Z_OK;
   \   000001A0   0000A0E3           MOV      R0,#+0
   \   000001A4   F081BDE8           POP      {R4-R8,PC}       ;; return
    952          #endif /* MAXSEG_64K */
    953          }
    954          
    955          /* ===========================================================================
    956           * Read a new buffer from the current input stream, update the adler32
    957           * and total number of bytes read.  All deflate() input goes through
    958           * this function so some applications may wish to modify it to avoid
    959           * allocating a large strm->next_in buffer and copying from it.
    960           * (See also flush_pending()).
    961           */

   \                                 In segment CODE, align 4, keep-with-next
    962          local int read_buf(strm, buf, size)
    963              z_streamp strm;
    964              Bytef *buf;
    965              unsigned size;
    966          {
   \                     read_buf:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    967              unsigned len = strm->avail_in;
   \   00000008   040094E5           LDR      R0,[R4, #+4]
   \   0000000C   0160A0E1           MOV      R6,R1
   \   00000010   0050A0E1           MOV      R5,R0
    968          
    969              if (len > size) len = size;
   \   00000014   050052E1           CMP      R2,R5
   \   00000018   0250A031           MOVCC    R5,R2
    970              if (len == 0) return 0;
   \   0000001C   000055E3           CMP      R5,#+0
   \   00000020   0000A003           MOVEQ    R0,#+0
   \   00000024   7080BD08           POPEQ    {R4-R6,PC}
    971          
    972              strm->avail_in  -= len;
   \   00000028   050040E0           SUB      R0,R0,R5
   \   0000002C   040084E5           STR      R0,[R4, #+4]
    973          
    974              if (strm->state->wrap == 1) {
   \   00000030   1C0094E5           LDR      R0,[R4, #+28]
   \   00000034   181090E5           LDR      R1,[R0, #+24]
   \   00000038   010051E3           CMP      R1,#+1
   \   0000003C   0400001A           BNE      ??read_buf_0
    975                  strm->adler = adler32(strm->adler, strm->next_in, len);
   \   00000040   001094E5           LDR      R1,[R4, #+0]
   \   00000044   300094E5           LDR      R0,[R4, #+48]
   \   00000048   0520A0E1           MOV      R2,R5
   \   0000004C   ........           _BLF     adler32,??adler32??rA
   \   00000050   050000EA           B        ??read_buf_1
    976              }
    977          #ifdef GZIP
    978              else if (strm->state->wrap == 2) {
   \                     ??read_buf_0:
   \   00000054   020051E3           CMP      R1,#+2
   \   00000058   0400001A           BNE      ??read_buf_2
    979                  strm->adler = crc32(strm->adler, strm->next_in, len);
   \   0000005C   001094E5           LDR      R1,[R4, #+0]
   \   00000060   300094E5           LDR      R0,[R4, #+48]
   \   00000064   0520A0E1           MOV      R2,R5
   \   00000068   ........           _BLF     crc32,??crc32??rA
   \                     ??read_buf_1:
   \   0000006C   300084E5           STR      R0,[R4, #+48]
    980              }
    981          #endif
    982              zmemcpy(buf, strm->next_in, len);
   \                     ??read_buf_2:
   \   00000070   001094E5           LDR      R1,[R4, #+0]
   \   00000074   0520A0E1           MOV      R2,R5
   \   00000078   0600A0E1           MOV      R0,R6
   \   0000007C   ........           _BLF     memcpy,??memcpy??rA
    983              strm->next_in  += len;
   \   00000080   000094E5           LDR      R0,[R4, #+0]
   \   00000084   000085E0           ADD      R0,R5,R0
   \   00000088   000084E5           STR      R0,[R4, #+0]
    984              strm->total_in += len;
   \   0000008C   080094E5           LDR      R0,[R4, #+8]
   \   00000090   000085E0           ADD      R0,R5,R0
   \   00000094   080084E5           STR      R0,[R4, #+8]
    985          
    986              return (int)len;
   \   00000098   0500A0E1           MOV      R0,R5
   \   0000009C   7080BDE8           POP      {R4-R6,PC}       ;; return
    987          }
    988          
    989          /* ===========================================================================
    990           * Initialize the "longest match" routines for a new zlib stream
    991           */

   \                                 In segment CODE, align 4, keep-with-next
    992          local void lm_init (s)
    993              deflate_state *s;
    994          {
   \                     lm_init:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    995              s->window_size = (ulg)2L*s->w_size;
   \   00000008   2C0094E5           LDR      R0,[R4, #+44]
    996          
    997              CLEAR_HASH(s);
   \   0000000C   0050A0E3           MOV      R5,#+0
   \   00000010   8000A0E1           LSL      R0,R0,#+1
   \   00000014   3C0084E5           STR      R0,[R4, #+60]
   \   00000018   4C1094E5           LDR      R1,[R4, #+76]
   \   0000001C   440094E5           LDR      R0,[R4, #+68]
   \   00000020   812080E0           ADD      R2,R0,R1, LSL #+1
   \   00000024   B25042E1           STRH     R5,[R2, #-2]
   \   00000028   011041E2           SUB      R1,R1,#+1
   \   0000002C   8120A0E1           LSL      R2,R1,#+1
   \   00000030   0010A0E3           MOV      R1,#+0
   \   00000034   ........           _BLF     memset,??memset??rA
    998          
    999              /* Set the default configuration parameters:
   1000               */
   1001              s->max_lazy_match   = configuration_table[s->level].max_lazy;
   \   00000038   841094E5           LDR      R1,[R4, #+132]
   \   0000003C   ........           LDR      R0,??DataTable2  ;; configuration_table
   \   00000040   0C20A0E3           MOV      R2,#+12
   \   00000044   920121E0           MLA      R1,R2,R1,R0
   \   00000048   B210D1E1           LDRH     R1,[R1, #+2]
   \   0000004C   801084E5           STR      R1,[R4, #+128]
   1002              s->good_match       = configuration_table[s->level].good_length;
   \   00000050   841094E5           LDR      R1,[R4, #+132]
   \   00000054   920121E0           MLA      R1,R2,R1,R0
   \   00000058   B010D1E1           LDRH     R1,[R1, #+0]
   \   0000005C   8C1084E5           STR      R1,[R4, #+140]
   1003              s->nice_match       = configuration_table[s->level].nice_length;
   \   00000060   841094E5           LDR      R1,[R4, #+132]
   \   00000064   920121E0           MLA      R1,R2,R1,R0
   \   00000068   B410D1E1           LDRH     R1,[R1, #+4]
   \   0000006C   901084E5           STR      R1,[R4, #+144]
   1004              s->max_chain_length = configuration_table[s->level].max_chain;
   \   00000070   841094E5           LDR      R1,[R4, #+132]
   \   00000074   920120E0           MLA      R0,R2,R1,R0
   \   00000078   B600D0E1           LDRH     R0,[R0, #+6]
   \   0000007C   7C0084E5           STR      R0,[R4, #+124]
   1005          
   1006              s->strstart = 0;
   \   00000080   6C5084E5           STR      R5,[R4, #+108]
   1007              s->block_start = 0L;
   \   00000084   5C5084E5           STR      R5,[R4, #+92]
   1008              s->lookahead = 0;
   \   00000088   745084E5           STR      R5,[R4, #+116]
   1009              s->match_length = s->prev_length = MIN_MATCH-1;
   \   0000008C   0200A0E3           MOV      R0,#+2
   \   00000090   780084E5           STR      R0,[R4, #+120]
   \   00000094   600084E5           STR      R0,[R4, #+96]
   1010              s->match_available = 0;
   \   00000098   685084E5           STR      R5,[R4, #+104]
   1011              s->ins_h = 0;
   \   0000009C   485084E5           STR      R5,[R4, #+72]
   1012          #ifndef FASTEST
   1013          #ifdef ASMV
   1014              match_init(); /* initialize the asm code */
   1015          #endif
   1016          #endif
   1017          }
   \   000000A0   3080BDE8           POP      {R4,R5,PC}       ;; return
   1018          
   1019          #ifndef FASTEST
   1020          /* ===========================================================================
   1021           * Set match_start to the longest match starting at the given string and
   1022           * return its length. Matches shorter or equal to prev_length are discarded,
   1023           * in which case the result is equal to prev_length and match_start is
   1024           * garbage.
   1025           * IN assertions: cur_match is the head of the hash chain for the current
   1026           *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
   1027           * OUT assertion: the match length is not greater than s->lookahead.
   1028           */
   1029          #ifndef ASMV
   1030          /* For 80x86 and 680x0, an optimized version will be provided in match.asm or
   1031           * match.S. The code will be functionally equivalent.
   1032           */

   \                                 In segment CODE, align 4, keep-with-next
   1033          local uInt longest_match(s, cur_match)
   1034              deflate_state *s;
   1035              IPos cur_match;                             /* current match */
   1036          {
   \                     longest_match:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
   1037              unsigned chain_length = s->max_chain_length;/* max hash chain length */
   1038              register Bytef *scan = s->window + s->strstart; /* current string */
   1039              register Bytef *match;                       /* matched string */
   1040              register int len;                           /* length of current match */
   1041              int best_len = s->prev_length;              /* best match length so far */
   1042              int nice_match = s->nice_match;             /* stop if match long enough */
   \   00000008   909090E5           LDR      R9,[R0, #+144]
   \   0000000C   7C4090E5           LDR      R4,[R0, #+124]
   \   00000010   6C7090E5           LDR      R7,[R0, #+108]
   \   00000014   382090E5           LDR      R2,[R0, #+56]
   \   00000018   783090E5           LDR      R3,[R0, #+120]
   \   0000001C   00908DE5           STR      R9,[SP, #+0]
   1043              IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
   1044                  s->strstart - (IPos)MAX_DIST(s) : NIL;
   \   00000020   2C8090E5           LDR      R8,[R0, #+44]
   \   00000024   026087E0           ADD      R6,R7,R2
   \   00000028   0650A0E1           MOV      R5,R6
   \   0000002C   0320A0E1           MOV      R2,R3
   \   00000030   0590E0E3           MVN      R9,#+5
   \   00000034   409FC9E3           BIC      R9,R9,#0x100
   \   00000038   089089E0           ADD      R9,R9,R8
   \   0000003C   070059E1           CMP      R9,R7
   \   00000040   0400002A           BCS      ??longest_match_0
   \   00000044   087047E0           SUB      R7,R7,R8
   \   00000048   0680A0E3           MOV      R8,#+6
   \   0000004C   408F88E3           ORR      R8,R8,#0x100
   \   00000050   07C088E0           ADD      R12,R8,R7
   \   00000054   000000EA           B        ??longest_match_1
   \                     ??longest_match_0:
   \   00000058   00C0A0E3           MOV      R12,#+0
   1045              /* Stop when cur_match becomes <= limit. To simplify the code,
   1046               * we prevent matches with the string of window index 0.
   1047               */
   1048              Posf *prev = s->prev;
   \                     ??longest_match_1:
   \   0000005C   408090E5           LDR      R8,[R0, #+64]
   1049              uInt wmask = s->w_mask;
   1050          
   1051          #ifdef UNALIGNED_OK
   1052              /* Compare two bytes at a time. Note: this is not always beneficial.
   1053               * Try with and without -DUNALIGNED_OK to check.
   1054               */
   1055              register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
   1056              register ush scan_start = *(ushf*)scan;
   1057              register ush scan_end   = *(ushf*)(scan+best_len-1);
   1058          #else
   1059              register Bytef *strend = s->window + s->strstart + MAX_MATCH;
   \   00000060   0270A0E3           MOV      R7,#+2
   \   00000064   04808DE5           STR      R8,[SP, #+4]
   \   00000068   348090E5           LDR      R8,[R0, #+52]
   \   0000006C   407F87E3           ORR      R7,R7,#0x100
   \   00000070   08808DE5           STR      R8,[SP, #+8]
   1060              register Byte scan_end1  = scan[best_len-1];
   1061              register Byte scan_end   = scan[best_len];
   1062          #endif
   1063          
   1064              /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   1065               * It is easy to get rid of this optimization if necessary.
   1066               */
   1067              Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
   1068          
   1069              /* Do not waste too much time if we already have a good match: */
   1070              if (s->prev_length >= s->good_match) {
   \   00000074   8C9090E5           LDR      R9,[R0, #+140]
   \   00000078   0580D2E7           LDRB     R8,[R2, +R5]
   \   0000007C   090053E1           CMP      R3,R9
   1071                  chain_length >>= 2;
   1072              }
   1073              /* Do not look for matches beyond the end of the input. This is necessary
   1074               * to make deflate deterministic.
   1075               */
   1076              if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
   \   00000080   743090E5           LDR      R3,[R0, #+116]
   \   00000084   00909DE5           LDR      R9,[SP, #+0]
   \   00000088   066087E0           ADD      R6,R7,R6
   \   0000008C   057082E0           ADD      R7,R2,R5
   \   00000090   017057E5           LDRB     R7,[R7, #-1]
   \   00000094   2441A021           LSRCS    R4,R4,#+2
   \   00000098   090053E1           CMP      R3,R9
   \   0000009C   00308D35           STRCC    R3,[SP, #+0]
   1077          
   1078              Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
   1079          
   1080              do {
   1081                  Assert(cur_match < s->strstart, "no future");
   1082                  match = s->window + cur_match;
   \                     ??longest_match_2:
   \   000000A0   389090E5           LDR      R9,[R0, #+56]
   \   000000A4   099081E0           ADD      R9,R1,R9
   1083          
   1084                  /* Skip to next match if the match length cannot increase
   1085                   * or if the match length is less than 2.  Note that the checks below
   1086                   * for insufficient lookahead only occur occasionally for performance
   1087                   * reasons.  Therefore uninitialized memory will be accessed, and
   1088                   * conditional jumps will be made that depend on those values.
   1089                   * However the length of the match is limited to the lookahead, so
   1090                   * the output of deflate is not affected by the uninitialized values.
   1091                   */
   1092          #if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
   1093                  /* This code assumes sizeof(unsigned short) == 2. Do not use
   1094                   * UNALIGNED_OK if your compiler uses a different size.
   1095                   */
   1096                  if (*(ushf*)(match+best_len-1) != scan_end ||
   1097                      *(ushf*)match != scan_start) continue;
   1098          
   1099                  /* It is not necessary to compare scan[2] and match[2] since they are
   1100                   * always equal when the other bytes match, given that the hash keys
   1101                   * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
   1102                   * strstart+3, +5, ... up to strstart+257. We check for insufficient
   1103                   * lookahead only every 4th comparison; the 128th check will be made
   1104                   * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
   1105                   * necessary to put more guard bytes at the end of the window, or
   1106                   * to check more often for insufficient lookahead.
   1107                   */
   1108                  Assert(scan[2] == match[2], "scan[2]?");
   1109                  scan++, match++;
   1110                  do {
   1111                  } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
   1112                           *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
   1113                           *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
   1114                           *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
   1115                           scan < strend);
   1116                  /* The funny "do {}" generates better code on most compilers */
   1117          
   1118                  /* Here, scan <= window+strstart+257 */
   1119                  Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
   1120                  if (*scan == *match) scan++;
   1121          
   1122                  len = (MAX_MATCH - 1) - (int)(strend-scan);
   1123                  scan = strend - (MAX_MATCH-1);
   1124          
   1125          #else /* UNALIGNED_OK */
   1126          
   1127                  if (match[best_len]   != scan_end  ||
   1128                      match[best_len-1] != scan_end1 ||
   1129                      *match            != *scan     ||
   1130                      *++match          != scan[1])      continue;
   \   000000A8   09A0D2E7           LDRB     R10,[R2, +R9]
   \   000000AC   08005AE1           CMP      R10,R8
   \   000000B0   4000001A           BNE      ??longest_match_3
   \   000000B4   09A082E0           ADD      R10,R2,R9
   \   000000B8   01A05AE5           LDRB     R10,[R10, #-1]
   \   000000BC   07005AE1           CMP      R10,R7
   \   000000C0   3C00001A           BNE      ??longest_match_3
   \   000000C4   ........           LDRB     R10,[R9], #+1
   \   000000C8   00B0D5E5           LDRB     R11,[R5, #+0]
   \   000000CC   0B005AE1           CMP      R10,R11
   \   000000D0   3800001A           BNE      ??longest_match_3
   \   000000D4   ........           LDRB     R10,[R9], #+1
   \   000000D8   01B0D5E5           LDRB     R11,[R5, #+1]
   \   000000DC   0B005AE1           CMP      R10,R11
   \   000000E0   3400001A           BNE      ??longest_match_3
   1131          
   1132                  /* The check at best_len-1 can be removed because it will be made
   1133                   * again later. (This heuristic is not always a win.)
   1134                   * It is not necessary to compare scan[2] and match[2] since they
   1135                   * are always equal when the other bytes match, given that
   1136                   * the hash keys are equal and that HASH_BITS >= 8.
   1137                   */
   1138                  scan += 2, match++;
   \   000000E4   025085E2           ADD      R5,R5,#+2
   1139                  Assert(*scan == *match, "match[2]?");
   1140          
   1141                  /* We check for insufficient lookahead only every 8th comparison;
   1142                   * the 256th check will be made at strstart+258.
   1143                   */
   1144                  do {
   1145                  } while (*++scan == *++match && *++scan == *++match &&
   1146                           *++scan == *++match && *++scan == *++match &&
   1147                           *++scan == *++match && *++scan == *++match &&
   1148                           *++scan == *++match && *++scan == *++match &&
   1149                           scan < strend);
   \                     ??longest_match_4:
   \   000000E8   01B0F5E5           LDRB     R11,[R5, #+1]!
   \   000000EC   019089E2           ADD      R9,R9,#+1
   \   000000F0   ........           LDRB     LR,[R9], #+1
   \   000000F4   0E005BE1           CMP      R11,LR
   \   000000F8   1D00001A           BNE      ??longest_match_5
   \   000000FC   01B0F5E5           LDRB     R11,[R5, #+1]!
   \   00000100   ........           LDRB     LR,[R9], #+1
   \   00000104   0E005BE1           CMP      R11,LR
   \   00000108   1900001A           BNE      ??longest_match_5
   \   0000010C   01B0F5E5           LDRB     R11,[R5, #+1]!
   \   00000110   ........           LDRB     LR,[R9], #+1
   \   00000114   0E005BE1           CMP      R11,LR
   \   00000118   1500001A           BNE      ??longest_match_5
   \   0000011C   01B0F5E5           LDRB     R11,[R5, #+1]!
   \   00000120   ........           LDRB     LR,[R9], #+1
   \   00000124   0E005BE1           CMP      R11,LR
   \   00000128   1100001A           BNE      ??longest_match_5
   \   0000012C   01B0F5E5           LDRB     R11,[R5, #+1]!
   \   00000130   ........           LDRB     LR,[R9], #+1
   \   00000134   0E005BE1           CMP      R11,LR
   \   00000138   0D00001A           BNE      ??longest_match_5
   \   0000013C   01B0F5E5           LDRB     R11,[R5, #+1]!
   \   00000140   ........           LDRB     LR,[R9], #+1
   \   00000144   0E005BE1           CMP      R11,LR
   \   00000148   0900001A           BNE      ??longest_match_5
   \   0000014C   01B0F5E5           LDRB     R11,[R5, #+1]!
   \   00000150   ........           LDRB     LR,[R9], #+1
   \   00000154   0E005BE1           CMP      R11,LR
   \   00000158   0500001A           BNE      ??longest_match_5
   \   0000015C   01B0F5E5           LDRB     R11,[R5, #+1]!
   \   00000160   00E0D9E5           LDRB     LR,[R9, #+0]
   \   00000164   0E005BE1           CMP      R11,LR
   \   00000168   0100001A           BNE      ??longest_match_5
   \   0000016C   060055E1           CMP      R5,R6
   \   00000170   DCFFFF3A           BCC      ??longest_match_4
   1150          
   1151                  Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
   1152          
   1153                  len = MAX_MATCH - (int)(strend - scan);
   \                     ??longest_match_5:
   \   00000174   0290A0E3           MOV      R9,#+2
   \   00000178   409F89E3           ORR      R9,R9,#0x100
   \   0000017C   055046E0           SUB      R5,R6,R5
   \   00000180   059049E0           SUB      R9,R9,R5
   1154                  scan = strend - MAX_MATCH;
   \   00000184   0150E0E3           MVN      R5,#+1
   \   00000188   405FC5E3           BIC      R5,R5,#0x100
   \   0000018C   065085E0           ADD      R5,R5,R6
   1155          
   1156          #endif /* UNALIGNED_OK */
   1157          
   1158                  if (len > best_len) {
   \   00000190   090052E1           CMP      R2,R9
   \   00000194   070000AA           BGE      ??longest_match_3
   1159                      s->match_start = cur_match;
   \   00000198   701080E5           STR      R1,[R0, #+112]
   1160                      best_len = len;
   1161                      if (len >= nice_match) break;
   \   0000019C   00709DE5           LDR      R7,[SP, #+0]
   \   000001A0   0920A0E1           MOV      R2,R9
   \   000001A4   070059E1           CMP      R9,R7
   \   000001A8   0B0000AA           BGE      ??longest_match_6
   1162          #ifdef UNALIGNED_OK
   1163                      scan_end = *(ushf*)(scan+best_len-1);
   1164          #else
   1165                      scan_end1  = scan[best_len-1];
   1166                      scan_end   = scan[best_len];
   \   000001AC   0580D2E7           LDRB     R8,[R2, +R5]
   \   000001B0   057082E0           ADD      R7,R2,R5
   \   000001B4   017057E5           LDRB     R7,[R7, #-1]
   1167          #endif
   1168                  }
   1169              } while ((cur_match = prev[cur_match & wmask]) > limit
   1170                       && --chain_length != 0);
   \                     ??longest_match_3:
   \   000001B8   08909DE5           LDR      R9,[SP, #+8]
   \   000001BC   011009E0           AND      R1,R9,R1
   \   000001C0   04909DE5           LDR      R9,[SP, #+4]
   \   000001C4   811089E0           ADD      R1,R9,R1, LSL #+1
   \   000001C8   B010D1E1           LDRH     R1,[R1, #+0]
   \   000001CC   01005CE1           CMP      R12,R1
   \   000001D0   0100002A           BCS      ??longest_match_6
   \   000001D4   014054E2           SUBS     R4,R4,#+1
   \   000001D8   B0FFFF1A           BNE      ??longest_match_2
   1171          
   1172              if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
   \                     ??longest_match_6:
   \   000001DC   020053E1           CMP      R3,R2
   \   000001E0   0200A021           MOVCS    R0,R2
   \   000001E4   FE8FBD28           POPCS    {R1-R11,PC}
   1173              return s->lookahead;
   \   000001E8   0300A0E1           MOV      R0,R3
   \   000001EC   FE8FBDE8           POP      {R1-R11,PC}      ;; return
   1174          }
   1175          #endif /* ASMV */
   1176          #endif /* FASTEST */
   1177          
   1178          /* ---------------------------------------------------------------------------
   1179           * Optimized version for level == 1 or strategy == Z_RLE only
   1180           */

   \                                 In segment CODE, align 4, keep-with-next
   1181          local uInt longest_match_fast(s, cur_match)
   1182              deflate_state *s;
   1183              IPos cur_match;                             /* current match */
   1184          {
   \                     longest_match_fast:
   \   00000000   70002DE9           PUSH     {R4-R6}
   \   00000004   6C2090E5           LDR      R2,[R0, #+108]
   \   00000008   384090E5           LDR      R4,[R0, #+56]
   1185              register Bytef *scan = s->window + s->strstart; /* current string */
   1186              register Bytef *match;                       /* matched string */
   1187              register int len;                           /* length of current match */
   1188              register Bytef *strend = s->window + s->strstart + MAX_MATCH;
   \   0000000C   0230A0E3           MOV      R3,#+2
   \   00000010   042082E0           ADD      R2,R2,R4
   \   00000014   403F83E3           ORR      R3,R3,#0x100
   \   00000018   023083E0           ADD      R3,R3,R2
   1189          
   1190              /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   1191               * It is easy to get rid of this optimization if necessary.
   1192               */
   1193              Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
   1194          
   1195              Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
   1196          
   1197              Assert(cur_match < s->strstart, "no future");
   1198          
   1199              match = s->window + cur_match;
   1200          
   1201              /* Return failure if the match length is less than 2:
   1202               */
   1203              if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;
   \   0000001C   ........           LDRB     R5,[R2], #+1
   \   00000020   04C081E0           ADD      R12,R1,R4
   \   00000024   ........           LDRB     R4,[R12], #+1
   \   00000028   050054E1           CMP      R4,R5
   \   0000002C   0300001A           BNE      ??longest_match_fast_0
   \   00000030   ........           LDRB     R4,[R12], #+1
   \   00000034   ........           LDRB     R5,[R2], #+1
   \   00000038   050054E1           CMP      R4,R5
   \   0000003C   0200000A           BEQ      ??longest_match_fast_1
   \                     ??longest_match_fast_0:
   \   00000040   7000BDE8           POP      {R4-R6}
   \   00000044   0200A0E3           MOV      R0,#+2
   \   00000048   1EFF2FE1           BX       LR
   1204          
   1205              /* The check at best_len-1 can be removed because it will be made
   1206               * again later. (This heuristic is not always a win.)
   1207               * It is not necessary to compare scan[2] and match[2] since they
   1208               * are always equal when the other bytes match, given that
   1209               * the hash keys are equal and that HASH_BITS >= 8.
   1210               */
   1211              scan += 2, match += 2;
   1212              Assert(*scan == *match, "match[2]?");
   1213          
   1214              /* We check for insufficient lookahead only every 8th comparison;
   1215               * the 256th check will be made at strstart+258.
   1216               */
   1217              do {
   1218              } while (*++scan == *++match && *++scan == *++match &&
   1219                       *++scan == *++match && *++scan == *++match &&
   1220                       *++scan == *++match && *++scan == *++match &&
   1221                       *++scan == *++match && *++scan == *++match &&
   1222                       scan < strend);
   \                     ??longest_match_fast_1:
   \   0000004C   0150F2E5           LDRB     R5,[R2, #+1]!
   \   00000050   01C08CE2           ADD      R12,R12,#+1
   \   00000054   ........           LDRB     R6,[R12], #+1
   \   00000058   0340A0E1           MOV      R4,R3
   \   0000005C   060055E1           CMP      R5,R6
   \   00000060   1D00001A           BNE      ??longest_match_fast_2
   \   00000064   0150F2E5           LDRB     R5,[R2, #+1]!
   \   00000068   ........           LDRB     R6,[R12], #+1
   \   0000006C   060055E1           CMP      R5,R6
   \   00000070   1900001A           BNE      ??longest_match_fast_2
   \   00000074   0150F2E5           LDRB     R5,[R2, #+1]!
   \   00000078   ........           LDRB     R6,[R12], #+1
   \   0000007C   060055E1           CMP      R5,R6
   \   00000080   1500001A           BNE      ??longest_match_fast_2
   \   00000084   0150F2E5           LDRB     R5,[R2, #+1]!
   \   00000088   ........           LDRB     R6,[R12], #+1
   \   0000008C   060055E1           CMP      R5,R6
   \   00000090   1100001A           BNE      ??longest_match_fast_2
   \   00000094   0150F2E5           LDRB     R5,[R2, #+1]!
   \   00000098   ........           LDRB     R6,[R12], #+1
   \   0000009C   060055E1           CMP      R5,R6
   \   000000A0   0D00001A           BNE      ??longest_match_fast_2
   \   000000A4   0150F2E5           LDRB     R5,[R2, #+1]!
   \   000000A8   ........           LDRB     R6,[R12], #+1
   \   000000AC   060055E1           CMP      R5,R6
   \   000000B0   0900001A           BNE      ??longest_match_fast_2
   \   000000B4   0150F2E5           LDRB     R5,[R2, #+1]!
   \   000000B8   ........           LDRB     R6,[R12], #+1
   \   000000BC   060055E1           CMP      R5,R6
   \   000000C0   0500001A           BNE      ??longest_match_fast_2
   \   000000C4   0150F2E5           LDRB     R5,[R2, #+1]!
   \   000000C8   0060DCE5           LDRB     R6,[R12, #+0]
   \   000000CC   060055E1           CMP      R5,R6
   \   000000D0   0100001A           BNE      ??longest_match_fast_2
   \   000000D4   040052E1           CMP      R2,R4
   \   000000D8   DBFFFF3A           BCC      ??longest_match_fast_1
   1223          
   1224              Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
   1225          
   1226              len = MAX_MATCH - (int)(strend - scan);
   \                     ??longest_match_fast_2:
   \   000000DC   0230A0E3           MOV      R3,#+2
   \   000000E0   403F83E3           ORR      R3,R3,#0x100
   \   000000E4   022044E0           SUB      R2,R4,R2
   \   000000E8   022043E0           SUB      R2,R3,R2
   1227          
   1228              if (len < MIN_MATCH) return MIN_MATCH - 1;
   \   000000EC   030052E3           CMP      R2,#+3
   \   000000F0   D2FFFFBA           BLT      ??longest_match_fast_0
   1229          
   1230              s->match_start = cur_match;
   \   000000F4   701080E5           STR      R1,[R0, #+112]
   1231              return (uInt)len <= s->lookahead ? (uInt)len : s->lookahead;
   \   000000F8   740090E5           LDR      R0,[R0, #+116]
   \   000000FC   7000BDE8           POP      {R4-R6}
   \   00000100   020050E1           CMP      R0,R2
   \   00000104   0020A031           MOVCC    R2,R0
   \   00000108   0200A0E1           MOV      R0,R2
   \   0000010C   1EFF2FE1           BX       LR               ;; return
   1232          }
   1233          
   1234          #ifdef DEBUG
   1235          /* ===========================================================================
   1236           * Check that the match at match_start is indeed a match.
   1237           */
   1238          local void check_match(s, start, match, length)
   1239              deflate_state *s;
   1240              IPos start, match;
   1241              int length;
   1242          {
   1243              /* check that the match is indeed a match */
   1244              if (zmemcmp(s->window + match,
   1245                          s->window + start, length) != EQUAL) {
   1246                  fprintf(stderr, " start %u, match %u, length %d\n",
   1247                          start, match, length);
   1248                  do {
   1249                      fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
   1250                  } while (--length != 0);
   1251                  z_error("invalid match");
   1252              }
   1253              if (z_verbose > 1) {
   1254                  fprintf(stderr,"\\[%d,%d]", start-match, length);
   1255                  do { putc(s->window[start++], stderr); } while (--length != 0);
   1256              }
   1257          }
   1258          #else
   1259          #  define check_match(s, start, match, length)
   1260          #endif /* DEBUG */
   1261          
   1262          /* ===========================================================================
   1263           * Fill the window when the lookahead becomes insufficient.
   1264           * Updates strstart and lookahead.
   1265           *
   1266           * IN assertion: lookahead < MIN_LOOKAHEAD
   1267           * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
   1268           *    At least one byte has been read, or avail_in == 0; reads are
   1269           *    performed for at least two bytes (required for the zip translate_eol
   1270           *    option -- not supported here).
   1271           */

   \                                 In segment CODE, align 4, keep-with-next
   1272          local void fill_window(s)
   1273              deflate_state *s;
   1274          {
   \                     fill_window:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1275              register unsigned n, m;
   1276              register Posf *p;
   1277              unsigned more;    /* Amount of free space at the end of the window. */
   1278              uInt wsize = s->w_size;
   \   00000008   2C5094E5           LDR      R5,[R4, #+44]
   \   0000000C   0560E0E3           MVN      R6,#+5
   \   00000010   406FC6E3           BIC      R6,R6,#0x100
   1279          
   1280              do {
   1281                  more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);
   \                     ??fill_window_0:
   \   00000014   6C0094E5           LDR      R0,[R4, #+108]
   \   00000018   3C1094E5           LDR      R1,[R4, #+60]
   \   0000001C   742094E5           LDR      R2,[R4, #+116]
   \   00000020   021041E0           SUB      R1,R1,R2
   \   00000024   007041E0           SUB      R7,R1,R0
   1282          
   1283                  /* Deal with !@#$% 64K limit: */
   1284                  if (sizeof(int) <= 2) {
   1285                      if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
   1286                          more = wsize;
   1287          
   1288                      } else if (more == (unsigned)(-1)) {
   1289                          /* Very unlikely, but possible on 16 bit machine if
   1290                           * strstart == 0 && lookahead == 1 (input done a byte at time)
   1291                           */
   1292                          more--;
   1293                      }
   1294                  }
   1295          
   1296                  /* If the window is almost full and there is insufficient lookahead,
   1297                   * move the upper half to the lower one to make room in the upper half.
   1298                   */
   1299                  if (s->strstart >= wsize+MAX_DIST(s)) {
   \   00000028   2C1094E5           LDR      R1,[R4, #+44]
   \   0000002C   051081E0           ADD      R1,R1,R5
   \   00000030   011086E0           ADD      R1,R6,R1
   \   00000034   010050E1           CMP      R0,R1
   \   00000038   2100003A           BCC      ??fill_window_1
   1300          
   1301                      zmemcpy(s->window, s->window+wsize, (unsigned)wsize);
   \   0000003C   380094E5           LDR      R0,[R4, #+56]
   \   00000040   0520A0E1           MOV      R2,R5
   \   00000044   001085E0           ADD      R1,R5,R0
   \   00000048   ........           _BLF     memcpy,??memcpy??rA
   1302                      s->match_start -= wsize;
   \   0000004C   700094E5           LDR      R0,[R4, #+112]
   \   00000050   050040E0           SUB      R0,R0,R5
   \   00000054   700084E5           STR      R0,[R4, #+112]
   1303                      s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
   \   00000058   6C0094E5           LDR      R0,[R4, #+108]
   \   0000005C   050040E0           SUB      R0,R0,R5
   \   00000060   6C0084E5           STR      R0,[R4, #+108]
   1304                      s->block_start -= (long) wsize;
   \   00000064   5C0094E5           LDR      R0,[R4, #+92]
   \   00000068   050040E0           SUB      R0,R0,R5
   \   0000006C   5C0084E5           STR      R0,[R4, #+92]
   1305          
   1306                      /* Slide the hash table (could be avoided with 32 bit values
   1307                         at the expense of memory usage). We slide even when level == 0
   1308                         to keep the hash table consistent if we switch back to level > 0
   1309                         later. (Using level 0 permanently is not an optimal usage of
   1310                         zlib, so we don't care about this pathological case.)
   1311                       */
   1312                      /* %%% avoid this when Z_RLE */
   1313                      n = s->hash_size;
   \   00000070   4C0094E5           LDR      R0,[R4, #+76]
   1314                      p = &s->head[n];
   \   00000074   441094E5           LDR      R1,[R4, #+68]
   \   00000078   802081E0           ADD      R2,R1,R0, LSL #+1
   1315                      do {
   1316                          m = *--p;
   \                     ??fill_window_2:
   \   0000007C   B23072E1           LDRH     R3,[R2, #-2]!
   1317                          *p = (Pos)(m >= wsize ? m-wsize : NIL);
   \   00000080   050053E1           CMP      R3,R5
   \   00000084   05304320           SUBCS    R3,R3,R5
   \   00000088   0030A033           MOVCC    R3,#+0
   \   0000008C   B030C2E1           STRH     R3,[R2, #+0]
   1318                      } while (--n);
   \   00000090   010050E2           SUBS     R0,R0,#+1
   \   00000094   F8FFFF1A           BNE      ??fill_window_2
   1319          
   1320                      n = wsize;
   1321          #ifndef FASTEST
   1322                      p = &s->prev[n];
   \   00000098   402094E5           LDR      R2,[R4, #+64]
   \   0000009C   0500A0E1           MOV      R0,R5
   \   000000A0   802082E0           ADD      R2,R2,R0, LSL #+1
   1323                      do {
   1324                          m = *--p;
   \                     ??fill_window_3:
   \   000000A4   B23072E1           LDRH     R3,[R2, #-2]!
   1325                          *p = (Pos)(m >= wsize ? m-wsize : NIL);
   \   000000A8   050053E1           CMP      R3,R5
   \   000000AC   05304320           SUBCS    R3,R3,R5
   \   000000B0   0030A033           MOVCC    R3,#+0
   \   000000B4   B030C2E1           STRH     R3,[R2, #+0]
   1326                          /* If n is not on any hash chain, prev[n] is garbage but
   1327                           * its value will never be used.
   1328                           */
   1329                      } while (--n);
   \   000000B8   010050E2           SUBS     R0,R0,#+1
   \   000000BC   F8FFFF1A           BNE      ??fill_window_3
   1330          #endif
   1331                      more += wsize;
   \   000000C0   077085E0           ADD      R7,R5,R7
   1332                  }
   1333                  if (s->strm->avail_in == 0) return;
   \                     ??fill_window_1:
   \   000000C4   000094E5           LDR      R0,[R4, #+0]
   \   000000C8   041090E5           LDR      R1,[R0, #+4]
   \   000000CC   000051E3           CMP      R1,#+0
   \   000000D0   F080BD08           POPEQ    {R4-R7,PC}
   1334          
   1335                  /* If there was no sliding:
   1336                   *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
   1337                   *    more == window_size - lookahead - strstart
   1338                   * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
   1339                   * => more >= window_size - 2*WSIZE + 2
   1340                   * In the BIG_MEM or MMAP case (not yet supported),
   1341                   *   window_size == input_size + MIN_LOOKAHEAD  &&
   1342                   *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
   1343                   * Otherwise, window_size == 2*WSIZE so more >= 2.
   1344                   * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
   1345                   */
   1346                  Assert(more >= 2, "more < 2");
   1347          
   1348                  n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
   \   000000D4   741094E5           LDR      R1,[R4, #+116]
   \   000000D8   6C3094E5           LDR      R3,[R4, #+108]
   \   000000DC   0720A0E1           MOV      R2,R7
   \   000000E0   387094E5           LDR      R7,[R4, #+56]
   \   000000E4   073083E0           ADD      R3,R3,R7
   \   000000E8   031081E0           ADD      R1,R1,R3
   \   000000EC   ........           BL       read_buf
   1349                  s->lookahead += n;
   \   000000F0   741094E5           LDR      R1,[R4, #+116]
   \   000000F4   010080E0           ADD      R0,R0,R1
   \   000000F8   740084E5           STR      R0,[R4, #+116]
   1350          
   1351                  /* Initialize the hash value now that we have some input: */
   1352                  if (s->lookahead >= MIN_MATCH) {
   \   000000FC   030050E3           CMP      R0,#+3
   \   00000100   0A00003A           BCC      ??fill_window_4
   \   00000104   6C1094E5           LDR      R1,[R4, #+108]
   \   00000108   382094E5           LDR      R2,[R4, #+56]
   \   0000010C   021081E0           ADD      R1,R1,R2
   \   00000110   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000114   482084E5           STR      R2,[R4, #+72]
   1353                      s->ins_h = s->window[s->strstart];
   1354                      UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
   \   00000118   0110D1E5           LDRB     R1,[R1, #+1]
   \   0000011C   583094E5           LDR      R3,[R4, #+88]
   \   00000120   121321E0           EOR      R1,R1,R2, LSL R3
   \   00000124   542094E5           LDR      R2,[R4, #+84]
   \   00000128   011002E0           AND      R1,R2,R1
   \   0000012C   481084E5           STR      R1,[R4, #+72]
   1355          #if MIN_MATCH != 3
   1356                      Call UPDATE_HASH() MIN_MATCH-3 more times
   1357          #endif
   1358                  }
   1359                  /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
   1360                   * but this is not important since only literal bytes will be emitted.
   1361                   */
   1362          
   1363              } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
   \                     ??fill_window_4:
   \   00000130   001066E2           RSB      R1,R6,#+0
   \   00000134   010050E1           CMP      R0,R1
   \   00000138   F080BD28           POPCS    {R4-R7,PC}
   \   0000013C   000094E5           LDR      R0,[R4, #+0]
   \   00000140   040090E5           LDR      R0,[R0, #+4]
   \   00000144   000050E3           CMP      R0,#+0
   \   00000148   B1FFFF1A           BNE      ??fill_window_0
   \   0000014C   F080BDE8           POP      {R4-R7,PC}       ;; return
   1364          }
   1365          
   1366          /* ===========================================================================
   1367           * Flush the current block, with given end-of-file flag.
   1368           * IN assertion: strstart is set to the end of the current match.
   1369           */
   1370          #define FLUSH_BLOCK_ONLY(s, eof) { \
   1371             _tr_flush_block(s, (s->block_start >= 0L ? \
   1372                             (charf *)&s->window[(unsigned)s->block_start] : \
   1373                             (charf *)Z_NULL), \
   1374                          (ulg)((long)s->strstart - s->block_start), \
   1375                          (eof)); \
   1376             s->block_start = s->strstart; \
   1377             flush_pending(s->strm); \
   1378             Tracev((stderr,"[FLUSH]")); \
   1379          }
   1380          
   1381          /* Same but force premature exit if necessary. */
   1382          #define FLUSH_BLOCK(s, eof) { \
   1383             FLUSH_BLOCK_ONLY(s, eof); \
   1384             if (s->strm->avail_out == 0) return (eof) ? finish_started : need_more; \
   1385          }
   1386          
   1387          /* ===========================================================================
   1388           * Copy without compression as much as possible from the input stream, return
   1389           * the current block state.
   1390           * This function does not insert new strings in the dictionary since
   1391           * uncompressible data is probably not useful. This function is used
   1392           * only for the level=0 compression option.
   1393           * NOTE: this function should be optimized to avoid extra copying from
   1394           * window to pending_buf.
   1395           */

   \                                 In segment CODE, align 4, keep-with-next
   1396          local block_state deflate_stored(s, flush)
   1397              deflate_state *s;
   1398              int flush;
   1399          {
   \                     deflate_stored:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1400              /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   1401               * to pending_buf_size, and each stored block has a 5 byte header:
   1402               */
   1403              ulg max_block_size = 0xffff;
   \   00000008   0C0094E5           LDR      R0,[R4, #+12]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   FF60A0E3           MOV      R6,#+255
   \   00000014   FF6C86E3           ORR      R6,R6,#0xFF00
   \   00000018   050040E2           SUB      R0,R0,#+5
   \   0000001C   060050E1           CMP      R0,R6
   \   00000020   0D00002A           BCS      ??deflate_stored_0
   1404              ulg max_start;
   1405          
   1406              if (max_block_size > s->pending_buf_size - 5) {
   1407                  max_block_size = s->pending_buf_size - 5;
   \   00000024   0060A0E1           MOV      R6,R0
   \   00000028   0B0000EA           B        ??deflate_stored_0
   1408              }
   1409          
   1410              /* Copy as much as possible from input to output: */
   1411              for (;;) {
   1412                  /* Fill the window as much as possible: */
   1413                  if (s->lookahead <= 1) {
   1414          
   1415                      Assert(s->strstart < s->w_size+MAX_DIST(s) ||
   1416                             s->block_start >= (long)s->w_size, "slide too late");
   1417          
   1418                      fill_window(s);
   1419                      if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;
   1420          
   1421                      if (s->lookahead == 0) break; /* flush the current block */
   1422                  }
   1423                  Assert(s->block_start >= 0L, "block gone");
   1424          
   1425                  s->strstart += s->lookahead;
   1426                  s->lookahead = 0;
   1427          
   1428                  /* Emit a stored block if pending_buf will be full: */
   1429                  max_start = s->block_start + max_block_size;
   1430                  if (s->strstart == 0 || (ulg)s->strstart >= max_start) {
   1431                      /* strstart == 0 is possible when wraparound on 16-bit machine */
   1432                      s->lookahead = (uInt)(s->strstart - max_start);
   1433                      s->strstart = (uInt)max_start;
   1434                      FLUSH_BLOCK(s, 0);
   1435                  }
   1436                  /* Flush if we may have to slide, otherwise block_start may become
   1437                   * negative and the data will be gone:
   1438                   */
   1439                  if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {
   1440                      FLUSH_BLOCK(s, 0);
   \                     ??deflate_stored_1:
   \   0000002C   0030A0E3           MOV      R3,#+0
   \   00000030   0710A0E1           MOV      R1,R7
   \   00000034   0400A0E1           MOV      R0,R4
   \   00000038   ........           _BLF     _tr_flush_block,??_tr_flush_block??rA
   \   0000003C   6C0094E5           LDR      R0,[R4, #+108]
   \   00000040   5C0084E5           STR      R0,[R4, #+92]
   \   00000044   000094E5           LDR      R0,[R4, #+0]
   \   00000048   ........           BL       flush_pending
   \   0000004C   000094E5           LDR      R0,[R4, #+0]
   \   00000050   100090E5           LDR      R0,[R0, #+16]
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   F080BD08           POPEQ    {R4-R7,PC}
   \                     ??deflate_stored_0:
   \   0000005C   740094E5           LDR      R0,[R4, #+116]
   \   00000060   0070A0E3           MOV      R7,#+0
   \   00000064   020050E3           CMP      R0,#+2
   \   00000068   0A00002A           BCS      ??deflate_stored_2
   \   0000006C   0400A0E1           MOV      R0,R4
   \   00000070   ........           BL       fill_window
   \   00000074   740094E5           LDR      R0,[R4, #+116]
   \   00000078   000050E3           CMP      R0,#+0
   \   0000007C   0500001A           BNE      ??deflate_stored_2
   \   00000080   000055E3           CMP      R5,#+0
   \   00000084   F080BD08           POPEQ    {R4-R7,PC}
   1441                  }
   1442              }
   1443              FLUSH_BLOCK(s, flush == Z_FINISH);
   \   00000088   040055E3           CMP      R5,#+4
   \   0000008C   0030A013           MOVNE    R3,#+0
   \   00000090   0130A003           MOVEQ    R3,#+1
   \   00000094   2C0000EA           B        ??deflate_stored_3
   \                     ??deflate_stored_2:
   \   00000098   6C0094E5           LDR      R0,[R4, #+108]
   \   0000009C   741094E5           LDR      R1,[R4, #+116]
   \   000000A0   000081E0           ADD      R0,R1,R0
   \   000000A4   6C0084E5           STR      R0,[R4, #+108]
   \   000000A8   747084E5           STR      R7,[R4, #+116]
   \   000000AC   5C2094E5           LDR      R2,[R4, #+92]
   \   000000B0   000050E3           CMP      R0,#+0
   \   000000B4   02C086E0           ADD      R12,R6,R2
   \   000000B8   0C10A0E1           MOV      R1,R12
   \   000000BC   0100000A           BEQ      ??deflate_stored_4
   \   000000C0   010050E1           CMP      R0,R1
   \   000000C4   1200003A           BCC      ??deflate_stored_5
   \                     ??deflate_stored_4:
   \   000000C8   010040E0           SUB      R0,R0,R1
   \   000000CC   740084E5           STR      R0,[R4, #+116]
   \   000000D0   6C1084E5           STR      R1,[R4, #+108]
   \   000000D4   000052E3           CMP      R2,#+0
   \   000000D8   38009455           LDRPL    R0,[R4, #+56]
   \   000000DC   0010A043           MOVMI    R1,#+0
   \   000000E0   00108250           ADDPL    R1,R2,R0
   \   000000E4   0030A0E3           MOV      R3,#+0
   \   000000E8   02204CE0           SUB      R2,R12,R2
   \   000000EC   0400A0E1           MOV      R0,R4
   \   000000F0   ........           _BLF     _tr_flush_block,??_tr_flush_block??rA
   \   000000F4   6C0094E5           LDR      R0,[R4, #+108]
   \   000000F8   5C0084E5           STR      R0,[R4, #+92]
   \   000000FC   000094E5           LDR      R0,[R4, #+0]
   \   00000100   ........           BL       flush_pending
   \   00000104   000094E5           LDR      R0,[R4, #+0]
   \   00000108   100090E5           LDR      R0,[R0, #+16]
   \   0000010C   000050E3           CMP      R0,#+0
   \   00000110   F080BD08           POPEQ    {R4-R7,PC}
   \                     ??deflate_stored_5:
   \   00000114   5C0094E5           LDR      R0,[R4, #+92]
   \   00000118   6C1094E5           LDR      R1,[R4, #+108]
   \   0000011C   0530E0E3           MVN      R3,#+5
   \   00000120   002041E0           SUB      R2,R1,R0
   \   00000124   2C1094E5           LDR      R1,[R4, #+44]
   \   00000128   403FC3E3           BIC      R3,R3,#0x100
   \   0000012C   011083E0           ADD      R1,R3,R1
   \   00000130   010052E1           CMP      R2,R1
   \   00000134   C8FFFF3A           BCC      ??deflate_stored_0
   \   00000138   000050E3           CMP      R0,#+0
   \   0000013C   BAFFFF4A           BMI      ??deflate_stored_1
   \   00000140   381094E5           LDR      R1,[R4, #+56]
   \   00000144   017080E0           ADD      R7,R0,R1
   \   00000148   B7FFFFEA           B        ??deflate_stored_1
   \                     ??deflate_stored_3:
   \   0000014C   5C0094E5           LDR      R0,[R4, #+92]
   \   00000150   6C2094E5           LDR      R2,[R4, #+108]
   \   00000154   000050E3           CMP      R0,#+0
   \   00000158   38109455           LDRPL    R1,[R4, #+56]
   \   0000015C   002042E0           SUB      R2,R2,R0
   \   00000160   01108050           ADDPL    R1,R0,R1
   \   00000164   0010A043           MOVMI    R1,#+0
   \   00000168   0400A0E1           MOV      R0,R4
   \   0000016C   ........           _BLF     _tr_flush_block,??_tr_flush_block??rA
   \   00000170   6C0094E5           LDR      R0,[R4, #+108]
   \   00000174   5C0084E5           STR      R0,[R4, #+92]
   \   00000178   000094E5           LDR      R0,[R4, #+0]
   \   0000017C   ........           BL       flush_pending
   \   00000180   000094E5           LDR      R0,[R4, #+0]
   \   00000184   100090E5           LDR      R0,[R0, #+16]
   \   00000188   000050E3           CMP      R0,#+0
   \   0000018C   0300001A           BNE      ??deflate_stored_6
   \   00000190   040055E3           CMP      R5,#+4
   \   00000194   0270A003           MOVEQ    R7,#+2
   \   00000198   0700A0E1           MOV      R0,R7
   \   0000019C   F080BDE8           POP      {R4-R7,PC}
   1444              return flush == Z_FINISH ? finish_done : block_done;
   \                     ??deflate_stored_6:
   \   000001A0   040055E3           CMP      R5,#+4
   \   000001A4   0300A003           MOVEQ    R0,#+3
   \   000001A8   F080BD08           POPEQ    {R4-R7,PC}
   \   000001AC   0100A0E3           MOV      R0,#+1
   \   000001B0   F080BDE8           POP      {R4-R7,PC}       ;; return
   1445          }
   1446          
   1447          /* ===========================================================================
   1448           * Compress as much as possible from the input stream, return the current
   1449           * block state.
   1450           * This function does not perform lazy evaluation of matches and inserts
   1451           * new strings in the dictionary only for unmatched strings or for short
   1452           * matches. It is used only for the fast compression options.
   1453           */

   \                                 In segment CODE, align 4, keep-with-next
   1454          local block_state deflate_fast(s, flush)
   1455              deflate_state *s;
   1456              int flush;
   1457          {
   \                     deflate_fast:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0050A0E1           MOV      R5,R0
   \   00000008   0160A0E1           MOV      R6,R1
   1458              IPos hash_head = NIL; /* head of the hash chain */
   \   0000000C   0040A0E3           MOV      R4,#+0
   \   00000010   0080A0E3           MOV      R8,#+0
   \   00000014   0670A0E3           MOV      R7,#+6
   \   00000018   407F87E3           ORR      R7,R7,#0x100
   \   0000001C   0D0000EA           B        ??deflate_fast_0
   1459              int bflush;           /* set if current block must be flushed */
   1460          
   1461              for (;;) {
   1462                  /* Make sure that we always have enough lookahead, except
   1463                   * at the end of the input file. We need MAX_MATCH bytes
   1464                   * for the next match, plus MIN_MATCH bytes to insert the
   1465                   * string following the next match.
   1466                   */
   1467                  if (s->lookahead < MIN_LOOKAHEAD) {
   1468                      fill_window(s);
   1469                      if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
   1470                          return need_more;
   1471                      }
   1472                      if (s->lookahead == 0) break; /* flush the current block */
   1473                  }
   1474          
   1475                  /* Insert the string window[strstart .. strstart+2] in the
   1476                   * dictionary, and set hash_head to the head of the hash chain:
   1477                   */
   1478                  if (s->lookahead >= MIN_MATCH) {
   1479                      INSERT_STRING(s, s->strstart, hash_head);
   1480                  }
   1481          
   1482                  /* Find the longest match, discarding those <= prev_length.
   1483                   * At this point we have always match_length < MIN_MATCH
   1484                   */
   1485                  if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
   1486                      /* To simplify the code, we prevent matches with the string
   1487                       * of window index 0 (in particular we have to avoid a match
   1488                       * of the string with itself at the start of the input file).
   1489                       */
   1490          #ifdef FASTEST
   1491                      if ((s->strategy != Z_HUFFMAN_ONLY && s->strategy != Z_RLE) ||
   1492                          (s->strategy == Z_RLE && s->strstart - hash_head == 1)) {
   1493                          s->match_length = longest_match_fast (s, hash_head);
   1494                      }
   1495          #else
   1496                      if (s->strategy != Z_HUFFMAN_ONLY && s->strategy != Z_RLE) {
   1497                          s->match_length = longest_match (s, hash_head);
   1498                      } else if (s->strategy == Z_RLE && s->strstart - hash_head == 1) {
   1499                          s->match_length = longest_match_fast (s, hash_head);
   1500                      }
   1501          #endif
   1502                      /* longest_match() or longest_match_fast() sets match_start */
   1503                  }
   1504                  if (s->match_length >= MIN_MATCH) {
   1505                      check_match(s, s->strstart, s->match_start, s->match_length);
   1506          
   1507                      _tr_tally_dist(s, s->strstart - s->match_start,
   1508                                     s->match_length - MIN_MATCH, bflush);
   1509          
   1510                      s->lookahead -= s->match_length;
   1511          
   1512                      /* Insert new strings in the hash table only if the match length
   1513                       * is not too large. This saves time but degrades compression.
   1514                       */
   1515          #ifndef FASTEST
   1516                      if (s->match_length <= s->max_insert_length &&
   1517                          s->lookahead >= MIN_MATCH) {
   1518                          s->match_length--; /* string at strstart already in table */
   1519                          do {
   1520                              s->strstart++;
   1521                              INSERT_STRING(s, s->strstart, hash_head);
   1522                              /* strstart never exceeds WSIZE-MAX_MATCH, so there are
   1523                               * always MIN_MATCH bytes ahead.
   1524                               */
   1525                          } while (--s->match_length != 0);
   1526                          s->strstart++;
   1527                      } else
   1528          #endif
   1529                      {
   1530                          s->strstart += s->match_length;
   1531                          s->match_length = 0;
   1532                          s->ins_h = s->window[s->strstart];
   1533                          UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
   1534          #if MIN_MATCH != 3
   1535                          Call UPDATE_HASH() MIN_MATCH-3 more times
   1536          #endif
   1537                          /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
   1538                           * matter since it will be recomputed at next deflate call.
   1539                           */
   1540                      }
   1541                  } else {
   1542                      /* No match, output a literal byte */
   1543                      Tracevv((stderr,"%c", s->window[s->strstart]));
   1544                      _tr_tally_lit (s, s->window[s->strstart], bflush);
   1545                      s->lookahead--;
   1546                      s->strstart++;
   1547                  }
   1548                  if (bflush) FLUSH_BLOCK(s, 0);
   \                     ??deflate_fast_1:
   \   00000020   6C0095E5           LDR      R0,[R5, #+108]
   \   00000024   5C2095E5           LDR      R2,[R5, #+92]
   \   00000028   0030A0E3           MOV      R3,#+0
   \   0000002C   022040E0           SUB      R2,R0,R2
   \   00000030   0500A0E1           MOV      R0,R5
   \   00000034   ........           _BLF     _tr_flush_block,??_tr_flush_block??rA
   \   00000038   6C0095E5           LDR      R0,[R5, #+108]
   \   0000003C   5C0085E5           STR      R0,[R5, #+92]
   \   00000040   000095E5           LDR      R0,[R5, #+0]
   \   00000044   ........           BL       flush_pending
   \   00000048   000095E5           LDR      R0,[R5, #+0]
   \   0000004C   100090E5           LDR      R0,[R0, #+16]
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   F081BD08           POPEQ    {R4-R8,PC}
   \                     ??deflate_fast_0:
   \   00000058   740095E5           LDR      R0,[R5, #+116]
   \   0000005C   070050E1           CMP      R0,R7
   \   00000060   0E00002A           BCS      ??deflate_fast_2
   \   00000064   0500A0E1           MOV      R0,R5
   \   00000068   ........           BL       fill_window
   \   0000006C   740095E5           LDR      R0,[R5, #+116]
   \   00000070   070050E1           CMP      R0,R7
   \   00000074   0200002A           BCS      ??deflate_fast_3
   \   00000078   000056E3           CMP      R6,#+0
   \   0000007C   0000A003           MOVEQ    R0,#+0
   \   00000080   F081BD08           POPEQ    {R4-R8,PC}
   \                     ??deflate_fast_3:
   \   00000084   000050E3           CMP      R0,#+0
   \   00000088   0400001A           BNE      ??deflate_fast_2
   1549              }
   1550              FLUSH_BLOCK(s, flush == Z_FINISH);
   \   0000008C   0170A0E3           MOV      R7,#+1
   \   00000090   040056E3           CMP      R6,#+4
   \   00000094   0030A013           MOVNE    R3,#+0
   \   00000098   0130A003           MOVEQ    R3,#+1
   \   0000009C   D80000EA           B        ??deflate_fast_4
   \                     ??deflate_fast_2:
   \   000000A0   740095E5           LDR      R0,[R5, #+116]
   \   000000A4   030050E3           CMP      R0,#+3
   \   000000A8   1E00003A           BCC      ??deflate_fast_5
   \   000000AC   6C2095E5           LDR      R2,[R5, #+108]
   \   000000B0   383095E5           LDR      R3,[R5, #+56]
   \   000000B4   480095E5           LDR      R0,[R5, #+72]
   \   000000B8   581095E5           LDR      R1,[R5, #+88]
   \   000000BC   032082E0           ADD      R2,R2,R3
   \   000000C0   0220D2E5           LDRB     R2,[R2, #+2]
   \   000000C4   100122E0           EOR      R0,R2,R0, LSL R1
   \   000000C8   541095E5           LDR      R1,[R5, #+84]
   \   000000CC   000001E0           AND      R0,R1,R0
   \   000000D0   480085E5           STR      R0,[R5, #+72]
   \   000000D4   6C0095E5           LDR      R0,[R5, #+108]
   \   000000D8   341095E5           LDR      R1,[R5, #+52]
   \   000000DC   442095E5           LDR      R2,[R5, #+68]
   \   000000E0   000001E0           AND      R0,R1,R0
   \   000000E4   401095E5           LDR      R1,[R5, #+64]
   \   000000E8   800081E0           ADD      R0,R1,R0, LSL #+1
   \   000000EC   481095E5           LDR      R1,[R5, #+72]
   \   000000F0   811082E0           ADD      R1,R2,R1, LSL #+1
   \   000000F4   B010D1E1           LDRH     R1,[R1, #+0]
   \   000000F8   B010C0E1           STRH     R1,[R0, #+0]
   \   000000FC   6C0095E5           LDR      R0,[R5, #+108]
   \   00000100   341095E5           LDR      R1,[R5, #+52]
   \   00000104   000001E0           AND      R0,R1,R0
   \   00000108   401095E5           LDR      R1,[R5, #+64]
   \   0000010C   800081E0           ADD      R0,R1,R0, LSL #+1
   \   00000110   B080D0E1           LDRH     R8,[R0, #+0]
   \   00000114   480095E5           LDR      R0,[R5, #+72]
   \   00000118   441095E5           LDR      R1,[R5, #+68]
   \   0000011C   800081E0           ADD      R0,R1,R0, LSL #+1
   \   00000120   6C1095E5           LDR      R1,[R5, #+108]
   \   00000124   B010C0E1           STRH     R1,[R0, #+0]
   \                     ??deflate_fast_5:
   \   00000128   000058E3           CMP      R8,#+0
   \   0000012C   1800000A           BEQ      ??deflate_fast_6
   \   00000130   2C0095E5           LDR      R0,[R5, #+44]
   \   00000134   001067E2           RSB      R1,R7,#+0
   \   00000138   000081E0           ADD      R0,R1,R0
   \   0000013C   6C1095E5           LDR      R1,[R5, #+108]
   \   00000140   081041E0           SUB      R1,R1,R8
   \   00000144   010050E1           CMP      R0,R1
   \   00000148   1100003A           BCC      ??deflate_fast_6
   \   0000014C   880095E5           LDR      R0,[R5, #+136]
   \   00000150   020050E3           CMP      R0,#+2
   \   00000154   03005013           CMPNE    R0,#+3
   \   00000158   0300000A           BEQ      ??deflate_fast_7
   \   0000015C   0810A0E1           MOV      R1,R8
   \   00000160   0500A0E1           MOV      R0,R5
   \   00000164   ........           BL       longest_match
   \   00000168   080000EA           B        ??deflate_fast_8
   \                     ??deflate_fast_7:
   \   0000016C   030050E3           CMP      R0,#+3
   \   00000170   0700001A           BNE      ??deflate_fast_6
   \   00000174   6C0095E5           LDR      R0,[R5, #+108]
   \   00000178   080040E0           SUB      R0,R0,R8
   \   0000017C   010050E3           CMP      R0,#+1
   \   00000180   0300001A           BNE      ??deflate_fast_6
   \   00000184   0810A0E1           MOV      R1,R8
   \   00000188   0500A0E1           MOV      R0,R5
   \   0000018C   ........           BL       longest_match_fast
   \                     ??deflate_fast_8:
   \   00000190   600085E5           STR      R0,[R5, #+96]
   \                     ??deflate_fast_6:
   \   00000194   601095E5           LDR      R1,[R5, #+96]
   \   00000198   9800A0E3           MOV      R0,#+152
   \   0000019C   580D80E3           ORR      R0,R0,#0x1600
   \   000001A0   050080E0           ADD      R0,R0,R5
   \   000001A4   030051E3           CMP      R1,#+3
   \   000001A8   7100003A           BCC      ??deflate_fast_9
   \   000001AC   6C2095E5           LDR      R2,[R5, #+108]
   \   000001B0   703095E5           LDR      R3,[R5, #+112]
   \   000001B4   0CC090E5           LDR      R12,[R0, #+12]
   \   000001B8   032042E0           SUB      R2,R2,R3
   \   000001BC   083090E5           LDR      R3,[R0, #+8]
   \   000001C0   0228A0E1           MOV      R2,R2, LSL #+16
   \   000001C4   2228A0E1           MOV      R2,R2, LSR #+16
   \   000001C8   83308CE0           ADD      R3,R12,R3, LSL #+1
   \   000001CC   B020C3E1           STRH     R2,[R3, #+0]
   \   000001D0   083090E5           LDR      R3,[R0, #+8]
   \   000001D4   FD1081E2           ADD      R1,R1,#+253
   \   000001D8   01C083E2           ADD      R12,R3,#+1
   \   000001DC   08C080E5           STR      R12,[R0, #+8]
   \   000001E0   00C090E5           LDR      R12,[R0, #+0]
   \   000001E4   FF1001E2           AND      R1,R1,#0xFF
   \   000001E8   0C10C3E7           STRB     R1,[R3, +R12]
   \   000001EC   FF30A0E3           MOV      R3,#+255
   \   000001F0   FF3C83E3           ORR      R3,R3,#0xFF00
   \   000001F4   022083E0           ADD      R2,R3,R2
   \   000001F8   ........           LDR      R3,??DataTable5  ;; _length_code
   \   000001FC   0228A0E1           MOV      R2,R2, LSL #+16
   \   00000200   0310D1E7           LDRB     R1,[R1, +R3]
   \   00000204   053047E2           SUB      R3,R7,#+5
   \   00000208   2228A0E1           MOV      R2,R2, LSR #+16
   \   0000020C   011083E0           ADD      R1,R3,R1
   \   00000210   011185E0           ADD      R1,R5,R1, LSL #+2
   \   00000214   B439D1E1           LDRH     R3,[R1, #+148]
   \   00000218   400F52E3           CMP      R2,#+256
   \   0000021C   013083E2           ADD      R3,R3,#+1
   \   00000220   B439C1E1           STRH     R3,[R1, #+148]
   \   00000224   ........           LDR      R1,??DataTable6  ;; _dist_code
   \   00000228   0110D237           LDRBCC   R1,[R2, +R1]
   \   0000022C   C2138120           ADDCS    R1,R1,R2, ASR #+7
   \   00000230   0011D125           LDRBCS   R1,[R1, #+256]
   \   00000234   8820A0E3           MOV      R2,#+136
   \   00000238   902E82E3           ORR      R2,R2,#0x900
   \   0000023C   011185E0           ADD      R1,R5,R1, LSL #+2
   \   00000240   B13092E1           LDRH     R3,[R2, +R1]
   \   00000244   013083E2           ADD      R3,R3,#+1
   \   00000248   B13082E1           STRH     R3,[R2, +R1]
   \   0000024C   081090E5           LDR      R1,[R0, #+8]
   \   00000250   040090E5           LDR      R0,[R0, #+4]
   \   00000254   602095E5           LDR      R2,[R5, #+96]
   \   00000258   010040E2           SUB      R0,R0,#+1
   \   0000025C   000051E1           CMP      R1,R0
   \   00000260   741095E5           LDR      R1,[R5, #+116]
   \   00000264   0100A003           MOVEQ    R0,#+1
   \   00000268   021041E0           SUB      R1,R1,R2
   \   0000026C   741085E5           STR      R1,[R5, #+116]
   \   00000270   801095E5           LDR      R1,[R5, #+128]
   \   00000274   0000A013           MOVNE    R0,#+0
   \   00000278   020051E1           CMP      R1,R2
   \   0000027C   74109525           LDRCS    R1,[R5, #+116]
   \   00000280   03005123           CMPCS    R1,#+3
   \   00000284   2900003A           BCC      ??deflate_fast_10
   \   00000288   011042E2           SUB      R1,R2,#+1
   \   0000028C   601085E5           STR      R1,[R5, #+96]
   \                     ??deflate_fast_11:
   \   00000290   6C1095E5           LDR      R1,[R5, #+108]
   \   00000294   011081E2           ADD      R1,R1,#+1
   \   00000298   6C1085E5           STR      R1,[R5, #+108]
   \   0000029C   6C3095E5           LDR      R3,[R5, #+108]
   \   000002A0   388095E5           LDR      R8,[R5, #+56]
   \   000002A4   481095E5           LDR      R1,[R5, #+72]
   \   000002A8   582095E5           LDR      R2,[R5, #+88]
   \   000002AC   083083E0           ADD      R3,R3,R8
   \   000002B0   0230D3E5           LDRB     R3,[R3, #+2]
   \   000002B4   111223E0           EOR      R1,R3,R1, LSL R2
   \   000002B8   542095E5           LDR      R2,[R5, #+84]
   \   000002BC   011002E0           AND      R1,R2,R1
   \   000002C0   481085E5           STR      R1,[R5, #+72]
   \   000002C4   6C1095E5           LDR      R1,[R5, #+108]
   \   000002C8   342095E5           LDR      R2,[R5, #+52]
   \   000002CC   443095E5           LDR      R3,[R5, #+68]
   \   000002D0   011002E0           AND      R1,R2,R1
   \   000002D4   402095E5           LDR      R2,[R5, #+64]
   \   000002D8   811082E0           ADD      R1,R2,R1, LSL #+1
   \   000002DC   482095E5           LDR      R2,[R5, #+72]
   \   000002E0   822083E0           ADD      R2,R3,R2, LSL #+1
   \   000002E4   B020D2E1           LDRH     R2,[R2, #+0]
   \   000002E8   B020C1E1           STRH     R2,[R1, #+0]
   \   000002EC   6C1095E5           LDR      R1,[R5, #+108]
   \   000002F0   342095E5           LDR      R2,[R5, #+52]
   \   000002F4   011002E0           AND      R1,R2,R1
   \   000002F8   402095E5           LDR      R2,[R5, #+64]
   \   000002FC   811082E0           ADD      R1,R2,R1, LSL #+1
   \   00000300   B080D1E1           LDRH     R8,[R1, #+0]
   \   00000304   481095E5           LDR      R1,[R5, #+72]
   \   00000308   442095E5           LDR      R2,[R5, #+68]
   \   0000030C   811082E0           ADD      R1,R2,R1, LSL #+1
   \   00000310   6C2095E5           LDR      R2,[R5, #+108]
   \   00000314   B020C1E1           STRH     R2,[R1, #+0]
   \   00000318   601095E5           LDR      R1,[R5, #+96]
   \   0000031C   011041E2           SUB      R1,R1,#+1
   \   00000320   601085E5           STR      R1,[R5, #+96]
   \   00000324   000051E3           CMP      R1,#+0
   \   00000328   D8FFFF1A           BNE      ??deflate_fast_11
   \   0000032C   290000EA           B        ??deflate_fast_12
   \                     ??deflate_fast_10:
   \   00000330   6C1095E5           LDR      R1,[R5, #+108]
   \   00000334   011082E0           ADD      R1,R2,R1
   \   00000338   6C1085E5           STR      R1,[R5, #+108]
   \   0000033C   604085E5           STR      R4,[R5, #+96]
   \   00000340   382095E5           LDR      R2,[R5, #+56]
   \   00000344   0210D1E7           LDRB     R1,[R1, +R2]
   \   00000348   481085E5           STR      R1,[R5, #+72]
   \   0000034C   6C3095E5           LDR      R3,[R5, #+108]
   \   00000350   38C095E5           LDR      R12,[R5, #+56]
   \   00000354   582095E5           LDR      R2,[R5, #+88]
   \   00000358   0C3083E0           ADD      R3,R3,R12
   \   0000035C   0130D3E5           LDRB     R3,[R3, #+1]
   \   00000360   111223E0           EOR      R1,R3,R1, LSL R2
   \   00000364   542095E5           LDR      R2,[R5, #+84]
   \   00000368   011002E0           AND      R1,R2,R1
   \   0000036C   481085E5           STR      R1,[R5, #+72]
   \   00000370   1B0000EA           B        ??deflate_fast_13
   \                     ??deflate_fast_9:
   \   00000374   6C1095E5           LDR      R1,[R5, #+108]
   \   00000378   382095E5           LDR      R2,[R5, #+56]
   \   0000037C   0C3090E5           LDR      R3,[R0, #+12]
   \   00000380   0210D1E7           LDRB     R1,[R1, +R2]
   \   00000384   082090E5           LDR      R2,[R0, #+8]
   \   00000388   822083E0           ADD      R2,R3,R2, LSL #+1
   \   0000038C   B040C2E1           STRH     R4,[R2, #+0]
   \   00000390   082090E5           LDR      R2,[R0, #+8]
   \   00000394   013082E2           ADD      R3,R2,#+1
   \   00000398   083080E5           STR      R3,[R0, #+8]
   \   0000039C   003090E5           LDR      R3,[R0, #+0]
   \   000003A0   0310C2E7           STRB     R1,[R2, +R3]
   \   000003A4   011185E0           ADD      R1,R5,R1, LSL #+2
   \   000003A8   B429D1E1           LDRH     R2,[R1, #+148]
   \   000003AC   012082E2           ADD      R2,R2,#+1
   \   000003B0   B429C1E1           STRH     R2,[R1, #+148]
   \   000003B4   081090E5           LDR      R1,[R0, #+8]
   \   000003B8   040090E5           LDR      R0,[R0, #+4]
   \   000003BC   010040E2           SUB      R0,R0,#+1
   \   000003C0   000051E1           CMP      R1,R0
   \   000003C4   741095E5           LDR      R1,[R5, #+116]
   \   000003C8   0100A003           MOVEQ    R0,#+1
   \   000003CC   0000A013           MOVNE    R0,#+0
   \   000003D0   011041E2           SUB      R1,R1,#+1
   \   000003D4   741085E5           STR      R1,[R5, #+116]
   \                     ??deflate_fast_12:
   \   000003D8   6C1095E5           LDR      R1,[R5, #+108]
   \   000003DC   011081E2           ADD      R1,R1,#+1
   \   000003E0   6C1085E5           STR      R1,[R5, #+108]
   \                     ??deflate_fast_13:
   \   000003E4   000050E3           CMP      R0,#+0
   \   000003E8   1AFFFF0A           BEQ      ??deflate_fast_0
   \   000003EC   5C0095E5           LDR      R0,[R5, #+92]
   \   000003F0   000050E3           CMP      R0,#+0
   \   000003F4   38109555           LDRPL    R1,[R5, #+56]
   \   000003F8   0010A043           MOVMI    R1,#+0
   \   000003FC   01108050           ADDPL    R1,R0,R1
   \   00000400   06FFFFEA           B        ??deflate_fast_1
   \                     ??deflate_fast_4:
   \   00000404   5C0095E5           LDR      R0,[R5, #+92]
   \   00000408   5C2095E5           LDR      R2,[R5, #+92]
   \   0000040C   000050E3           CMP      R0,#+0
   \   00000410   38109555           LDRPL    R1,[R5, #+56]
   \   00000414   01108050           ADDPL    R1,R0,R1
   \   00000418   6C0095E5           LDR      R0,[R5, #+108]
   \   0000041C   0010A043           MOVMI    R1,#+0
   \   00000420   022040E0           SUB      R2,R0,R2
   \   00000424   0500A0E1           MOV      R0,R5
   \   00000428   ........           _BLF     _tr_flush_block,??_tr_flush_block??rA
   \   0000042C   6C0095E5           LDR      R0,[R5, #+108]
   \   00000430   5C0085E5           STR      R0,[R5, #+92]
   \   00000434   000095E5           LDR      R0,[R5, #+0]
   \   00000438   ........           BL       flush_pending
   \   0000043C   000095E5           LDR      R0,[R5, #+0]
   \   00000440   100090E5           LDR      R0,[R0, #+16]
   \   00000444   000050E3           CMP      R0,#+0
   \   00000448   0200001A           BNE      ??deflate_fast_14
   \   0000044C   040056E3           CMP      R6,#+4
   \   00000450   0200A003           MOVEQ    R0,#+2
   \   00000454   F081BDE8           POP      {R4-R8,PC}
   1551              return flush == Z_FINISH ? finish_done : block_done;
   \                     ??deflate_fast_14:
   \   00000458   040056E3           CMP      R6,#+4
   \   0000045C   0370A003           MOVEQ    R7,#+3
   \   00000460   0700A0E1           MOV      R0,R7
   \   00000464   F081BDE8           POP      {R4-R8,PC}       ;; return
   1552          }
   1553          
   1554          #ifndef FASTEST
   1555          /* ===========================================================================
   1556           * Same as above, but achieves better compression. We use a lazy
   1557           * evaluation for matches: a match is finally adopted only if there is
   1558           * no better match at the next window position.
   1559           */

   \                                 In segment CODE, align 4, keep-with-next
   1560          local block_state deflate_slow(s, flush)
   1561              deflate_state *s;
   1562              int flush;
   1563          {
   \                     deflate_slow:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0070A0E1           MOV      R7,R0
   \   00000008   0180A0E1           MOV      R8,R1
   1564              IPos hash_head = NIL;    /* head of hash chain */
   \   0000000C   0040A0E3           MOV      R4,#+0
   \   00000010   0090A0E3           MOV      R9,#+0
   \   00000014   06A0A0E3           MOV      R10,#+6
   \   00000018   40AF8AE3           ORR      R10,R10,#0x100
   \   0000001C   0260A0E3           MOV      R6,#+2
   \   00000020   0D0000EA           B        ??deflate_slow_0
   1565              int bflush;              /* set if current block must be flushed */
   1566          
   1567              /* Process the input block. */
   1568              for (;;) {
   1569                  /* Make sure that we always have enough lookahead, except
   1570                   * at the end of the input file. We need MAX_MATCH bytes
   1571                   * for the next match, plus MIN_MATCH bytes to insert the
   1572                   * string following the next match.
   1573                   */
   1574                  if (s->lookahead < MIN_LOOKAHEAD) {
   1575                      fill_window(s);
   1576                      if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
   1577                          return need_more;
   1578                      }
   1579                      if (s->lookahead == 0) break; /* flush the current block */
   1580                  }
   1581          
   1582                  /* Insert the string window[strstart .. strstart+2] in the
   1583                   * dictionary, and set hash_head to the head of the hash chain:
   1584                   */
   1585                  if (s->lookahead >= MIN_MATCH) {
   1586                      INSERT_STRING(s, s->strstart, hash_head);
   1587                  }
   1588          
   1589                  /* Find the longest match, discarding those <= prev_length.
   1590                   */
   1591                  s->prev_length = s->match_length, s->prev_match = s->match_start;
   1592                  s->match_length = MIN_MATCH-1;
   1593          
   1594                  if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
   1595                      s->strstart - hash_head <= MAX_DIST(s)) {
   1596                      /* To simplify the code, we prevent matches with the string
   1597                       * of window index 0 (in particular we have to avoid a match
   1598                       * of the string with itself at the start of the input file).
   1599                       */
   1600                      if (s->strategy != Z_HUFFMAN_ONLY && s->strategy != Z_RLE) {
   1601                          s->match_length = longest_match (s, hash_head);
   1602                      } else if (s->strategy == Z_RLE && s->strstart - hash_head == 1) {
   1603                          s->match_length = longest_match_fast (s, hash_head);
   1604                      }
   1605                      /* longest_match() or longest_match_fast() sets match_start */
   1606          
   1607                      if (s->match_length <= 5 && (s->strategy == Z_FILTERED
   1608          #if TOO_FAR <= 32767
   1609                          || (s->match_length == MIN_MATCH &&
   1610                              s->strstart - s->match_start > TOO_FAR)
   1611          #endif
   1612                          )) {
   1613          
   1614                          /* If prev_match is also MIN_MATCH, match_start is garbage
   1615                           * but we will ignore the current match anyway.
   1616                           */
   1617                          s->match_length = MIN_MATCH-1;
   1618                      }
   1619                  }
   1620                  /* If there was a match at the previous step and the current
   1621                   * match is not better, output the previous match:
   1622                   */
   1623                  if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
   1624                      uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
   1625                      /* Do not insert strings in hash table beyond this. */
   1626          
   1627                      check_match(s, s->strstart-1, s->prev_match, s->prev_length);
   1628          
   1629                      _tr_tally_dist(s, s->strstart -1 - s->prev_match,
   1630                                     s->prev_length - MIN_MATCH, bflush);
   1631          
   1632                      /* Insert in hash table all strings up to the end of the match.
   1633                       * strstart-1 and strstart are already inserted. If there is not
   1634                       * enough lookahead, the last two strings are not inserted in
   1635                       * the hash table.
   1636                       */
   1637                      s->lookahead -= s->prev_length-1;
   1638                      s->prev_length -= 2;
   1639                      do {
   1640                          if (++s->strstart <= max_insert) {
   1641                              INSERT_STRING(s, s->strstart, hash_head);
   1642                          }
   1643                      } while (--s->prev_length != 0);
   1644                      s->match_available = 0;
   1645                      s->match_length = MIN_MATCH-1;
   1646                      s->strstart++;
   1647          
   1648                      if (bflush) FLUSH_BLOCK(s, 0);
   \                     ??deflate_slow_1:
   \   00000024   6C0097E5           LDR      R0,[R7, #+108]
   \   00000028   5C2097E5           LDR      R2,[R7, #+92]
   \   0000002C   0030A0E3           MOV      R3,#+0
   \   00000030   022040E0           SUB      R2,R0,R2
   \   00000034   0700A0E1           MOV      R0,R7
   \   00000038   ........           _BLF     _tr_flush_block,??_tr_flush_block??rA
   \   0000003C   6C0097E5           LDR      R0,[R7, #+108]
   \   00000040   5C0087E5           STR      R0,[R7, #+92]
   \   00000044   000097E5           LDR      R0,[R7, #+0]
   \   00000048   ........           BL       flush_pending
   \   0000004C   000097E5           LDR      R0,[R7, #+0]
   \   00000050   100090E5           LDR      R0,[R0, #+16]
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   F08FBD08           POPEQ    {R4-R11,PC}
   \                     ??deflate_slow_0:
   \   0000005C   9800A0E3           MOV      R0,#+152
   \   00000060   580D80E3           ORR      R0,R0,#0x1600
   \   00000064   07B080E0           ADD      R11,R0,R7
   \   00000068   740097E5           LDR      R0,[R7, #+116]
   \   0000006C   0150A0E3           MOV      R5,#+1
   \   00000070   0A0050E1           CMP      R0,R10
   \   00000074   2300002A           BCS      ??deflate_slow_2
   \   00000078   0700A0E1           MOV      R0,R7
   \   0000007C   ........           BL       fill_window
   \   00000080   740097E5           LDR      R0,[R7, #+116]
   \   00000084   0A0050E1           CMP      R0,R10
   \   00000088   0300002A           BCS      ??deflate_slow_3
   \   0000008C   000058E3           CMP      R8,#+0
   \   00000090   0100001A           BNE      ??deflate_slow_3
   \   00000094   0000A0E3           MOV      R0,#+0
   \   00000098   F08FBDE8           POP      {R4-R11,PC}
   \                     ??deflate_slow_3:
   \   0000009C   000050E3           CMP      R0,#+0
   \   000000A0   1800001A           BNE      ??deflate_slow_2
   1649          
   1650                  } else if (s->match_available) {
   1651                      /* If there was no match at the previous position, output a
   1652                       * single literal. If there was a match but the current match
   1653                       * is longer, truncate the previous match to a single literal.
   1654                       */
   1655                      Tracevv((stderr,"%c", s->window[s->strstart-1]));
   1656                      _tr_tally_lit(s, s->window[s->strstart-1], bflush);
   1657                      if (bflush) {
   1658                          FLUSH_BLOCK_ONLY(s, 0);
   1659                      }
   1660                      s->strstart++;
   1661                      s->lookahead--;
   1662                      if (s->strm->avail_out == 0) return need_more;
   1663                  } else {
   1664                      /* There is no previous match to compare with, wait for
   1665                       * the next step to decide.
   1666                       */
   1667                      s->match_available = 1;
   1668                      s->strstart++;
   1669                      s->lookahead--;
   1670                  }
   1671              }
   1672              Assert (flush != Z_NO_FLUSH, "no flush?");
   1673              if (s->match_available) {
   \   000000A4   680097E5           LDR      R0,[R7, #+104]
   \   000000A8   000050E3           CMP      R0,#+0
   \   000000AC   1100000A           BEQ      ??deflate_slow_4
   1674                  Tracevv((stderr,"%c", s->window[s->strstart-1]));
   1675                  _tr_tally_lit(s, s->window[s->strstart-1], bflush);
   \   000000B0   6C0097E5           LDR      R0,[R7, #+108]
   \   000000B4   381097E5           LDR      R1,[R7, #+56]
   \   000000B8   0C209BE5           LDR      R2,[R11, #+12]
   \   000000BC   010080E0           ADD      R0,R0,R1
   \   000000C0   08109BE5           LDR      R1,[R11, #+8]
   \   000000C4   010050E5           LDRB     R0,[R0, #-1]
   \   000000C8   811082E0           ADD      R1,R2,R1, LSL #+1
   \   000000CC   B040C1E1           STRH     R4,[R1, #+0]
   \   000000D0   08109BE5           LDR      R1,[R11, #+8]
   \   000000D4   012081E2           ADD      R2,R1,#+1
   \   000000D8   08208BE5           STR      R2,[R11, #+8]
   \   000000DC   00209BE5           LDR      R2,[R11, #+0]
   \   000000E0   0200C1E7           STRB     R0,[R1, +R2]
   \   000000E4   000187E0           ADD      R0,R7,R0, LSL #+2
   \   000000E8   B419D0E1           LDRH     R1,[R0, #+148]
   \   000000EC   011081E2           ADD      R1,R1,#+1
   \   000000F0   B419C0E1           STRH     R1,[R0, #+148]
   1676                  s->match_available = 0;
   \   000000F4   684087E5           STR      R4,[R7, #+104]
   1677              }
   1678              FLUSH_BLOCK(s, flush == Z_FINISH);
   \                     ??deflate_slow_4:
   \   000000F8   040058E3           CMP      R8,#+4
   \   000000FC   0030A013           MOVNE    R3,#+0
   \   00000100   0130A003           MOVEQ    R3,#+1
   \   00000104   070100EA           B        ??deflate_slow_5
   \                     ??deflate_slow_2:
   \   00000108   740097E5           LDR      R0,[R7, #+116]
   \   0000010C   030050E3           CMP      R0,#+3
   \   00000110   1E00003A           BCC      ??deflate_slow_6
   \   00000114   6C2097E5           LDR      R2,[R7, #+108]
   \   00000118   383097E5           LDR      R3,[R7, #+56]
   \   0000011C   480097E5           LDR      R0,[R7, #+72]
   \   00000120   581097E5           LDR      R1,[R7, #+88]
   \   00000124   032082E0           ADD      R2,R2,R3
   \   00000128   0220D2E5           LDRB     R2,[R2, #+2]
   \   0000012C   100122E0           EOR      R0,R2,R0, LSL R1
   \   00000130   541097E5           LDR      R1,[R7, #+84]
   \   00000134   000001E0           AND      R0,R1,R0
   \   00000138   480087E5           STR      R0,[R7, #+72]
   \   0000013C   6C0097E5           LDR      R0,[R7, #+108]
   \   00000140   341097E5           LDR      R1,[R7, #+52]
   \   00000144   442097E5           LDR      R2,[R7, #+68]
   \   00000148   000001E0           AND      R0,R1,R0
   \   0000014C   401097E5           LDR      R1,[R7, #+64]
   \   00000150   800081E0           ADD      R0,R1,R0, LSL #+1
   \   00000154   481097E5           LDR      R1,[R7, #+72]
   \   00000158   811082E0           ADD      R1,R2,R1, LSL #+1
   \   0000015C   B010D1E1           LDRH     R1,[R1, #+0]
   \   00000160   B010C0E1           STRH     R1,[R0, #+0]
   \   00000164   6C0097E5           LDR      R0,[R7, #+108]
   \   00000168   341097E5           LDR      R1,[R7, #+52]
   \   0000016C   000001E0           AND      R0,R1,R0
   \   00000170   401097E5           LDR      R1,[R7, #+64]
   \   00000174   800081E0           ADD      R0,R1,R0, LSL #+1
   \   00000178   B090D0E1           LDRH     R9,[R0, #+0]
   \   0000017C   480097E5           LDR      R0,[R7, #+72]
   \   00000180   441097E5           LDR      R1,[R7, #+68]
   \   00000184   800081E0           ADD      R0,R1,R0, LSL #+1
   \   00000188   6C1097E5           LDR      R1,[R7, #+108]
   \   0000018C   B010C0E1           STRH     R1,[R0, #+0]
   \                     ??deflate_slow_6:
   \   00000190   600097E5           LDR      R0,[R7, #+96]
   \   00000194   000059E3           CMP      R9,#+0
   \   00000198   780087E5           STR      R0,[R7, #+120]
   \   0000019C   700097E5           LDR      R0,[R7, #+112]
   \   000001A0   640087E5           STR      R0,[R7, #+100]
   \   000001A4   606087E5           STR      R6,[R7, #+96]
   \   000001A8   2C00000A           BEQ      ??deflate_slow_7
   \   000001AC   780097E5           LDR      R0,[R7, #+120]
   \   000001B0   801097E5           LDR      R1,[R7, #+128]
   \   000001B4   010050E1           CMP      R0,R1
   \   000001B8   2800002A           BCS      ??deflate_slow_7
   \   000001BC   2C0097E5           LDR      R0,[R7, #+44]
   \   000001C0   00106AE2           RSB      R1,R10,#+0
   \   000001C4   000081E0           ADD      R0,R1,R0
   \   000001C8   6C1097E5           LDR      R1,[R7, #+108]
   \   000001CC   091041E0           SUB      R1,R1,R9
   \   000001D0   010050E1           CMP      R0,R1
   \   000001D4   2100003A           BCC      ??deflate_slow_7
   \   000001D8   880097E5           LDR      R0,[R7, #+136]
   \   000001DC   020050E3           CMP      R0,#+2
   \   000001E0   03005013           CMPNE    R0,#+3
   \   000001E4   0300000A           BEQ      ??deflate_slow_8
   \   000001E8   0910A0E1           MOV      R1,R9
   \   000001EC   0700A0E1           MOV      R0,R7
   \   000001F0   ........           BL       longest_match
   \   000001F4   080000EA           B        ??deflate_slow_9
   \                     ??deflate_slow_8:
   \   000001F8   030050E3           CMP      R0,#+3
   \   000001FC   0700001A           BNE      ??deflate_slow_10
   \   00000200   6C0097E5           LDR      R0,[R7, #+108]
   \   00000204   090040E0           SUB      R0,R0,R9
   \   00000208   010050E3           CMP      R0,#+1
   \   0000020C   0300001A           BNE      ??deflate_slow_10
   \   00000210   0910A0E1           MOV      R1,R9
   \   00000214   0700A0E1           MOV      R0,R7
   \   00000218   ........           BL       longest_match_fast
   \                     ??deflate_slow_9:
   \   0000021C   600087E5           STR      R0,[R7, #+96]
   \                     ??deflate_slow_10:
   \   00000220   600097E5           LDR      R0,[R7, #+96]
   \   00000224   060050E3           CMP      R0,#+6
   \   00000228   0C00002A           BCS      ??deflate_slow_7
   \   0000022C   880097E5           LDR      R0,[R7, #+136]
   \   00000230   010050E3           CMP      R0,#+1
   \   00000234   0800000A           BEQ      ??deflate_slow_11
   \   00000238   600097E5           LDR      R0,[R7, #+96]
   \   0000023C   030050E3           CMP      R0,#+3
   \   00000240   0600001A           BNE      ??deflate_slow_7
   \   00000244   6C0097E5           LDR      R0,[R7, #+108]
   \   00000248   701097E5           LDR      R1,[R7, #+112]
   \   0000024C   010040E0           SUB      R0,R0,R1
   \   00000250   401D85E3           ORR      R1,R5,#0x1000
   \   00000254   010050E1           CMP      R0,R1
   \   00000258   0000003A           BCC      ??deflate_slow_7
   \                     ??deflate_slow_11:
   \   0000025C   606087E5           STR      R6,[R7, #+96]
   \                     ??deflate_slow_7:
   \   00000260   780097E5           LDR      R0,[R7, #+120]
   \   00000264   030050E3           CMP      R0,#+3
   \   00000268   60109725           LDRCS    R1,[R7, #+96]
   \   0000026C   01005021           CMPCS    R0,R1
   \   00000270   7000003A           BCC      ??deflate_slow_12
   \   00000274   6C3097E5           LDR      R3,[R7, #+108]
   \   00000278   645097E5           LDR      R5,[R7, #+100]
   \   0000027C   740097E5           LDR      R0,[R7, #+116]
   \   00000280   6C1097E5           LDR      R1,[R7, #+108]
   \   00000284   0CC09BE5           LDR      R12,[R11, #+12]
   \   00000288   FF20A0E3           MOV      R2,#+255
   \   0000028C   FF2C82E3           ORR      R2,R2,#0xFF00
   \   00000290   033082E0           ADD      R3,R2,R3
   \   00000294   053043E0           SUB      R3,R3,R5
   \   00000298   08509BE5           LDR      R5,[R11, #+8]
   \   0000029C   000081E0           ADD      R0,R1,R0
   \   000002A0   781097E5           LDR      R1,[R7, #+120]
   \   000002A4   0338A0E1           MOV      R3,R3, LSL #+16
   \   000002A8   2338A0E1           MOV      R3,R3, LSR #+16
   \   000002AC   85508CE0           ADD      R5,R12,R5, LSL #+1
   \   000002B0   B030C5E1           STRH     R3,[R5, #+0]
   \   000002B4   08509BE5           LDR      R5,[R11, #+8]
   \   000002B8   032082E0           ADD      R2,R2,R3
   \   000002BC   ........           LDR      R3,??DataTable5  ;; _length_code
   \   000002C0   01C085E2           ADD      R12,R5,#+1
   \   000002C4   08C08BE5           STR      R12,[R11, #+8]
   \   000002C8   00C09BE5           LDR      R12,[R11, #+0]
   \   000002CC   FD1081E2           ADD      R1,R1,#+253
   \   000002D0   FF1001E2           AND      R1,R1,#0xFF
   \   000002D4   0C10C5E7           STRB     R1,[R5, +R12]
   \   000002D8   0310D1E7           LDRB     R1,[R1, +R3]
   \   000002DC   FF3086E2           ADD      R3,R6,#+255
   \   000002E0   0228A0E1           MOV      R2,R2, LSL #+16
   \   000002E4   011083E0           ADD      R1,R3,R1
   \   000002E8   011187E0           ADD      R1,R7,R1, LSL #+2
   \   000002EC   B439D1E1           LDRH     R3,[R1, #+148]
   \   000002F0   2228A0E1           MOV      R2,R2, LSR #+16
   \   000002F4   400F52E3           CMP      R2,#+256
   \   000002F8   013083E2           ADD      R3,R3,#+1
   \   000002FC   B439C1E1           STRH     R3,[R1, #+148]
   \   00000300   ........           LDR      R1,??DataTable6  ;; _dist_code
   \   00000304   0110D237           LDRBCC   R1,[R2, +R1]
   \   00000308   030040E2           SUB      R0,R0,#+3
   \   0000030C   C2138120           ADDCS    R1,R1,R2, ASR #+7
   \   00000310   0011D125           LDRBCS   R1,[R1, #+256]
   \   00000314   8820A0E3           MOV      R2,#+136
   \   00000318   902E82E3           ORR      R2,R2,#0x900
   \   0000031C   011187E0           ADD      R1,R7,R1, LSL #+2
   \   00000320   B13092E1           LDRH     R3,[R2, +R1]
   \   00000324   013083E2           ADD      R3,R3,#+1
   \   00000328   B13082E1           STRH     R3,[R2, +R1]
   \   0000032C   08109BE5           LDR      R1,[R11, #+8]
   \   00000330   04209BE5           LDR      R2,[R11, #+4]
   \   00000334   783097E5           LDR      R3,[R7, #+120]
   \   00000338   012042E2           SUB      R2,R2,#+1
   \   0000033C   020051E1           CMP      R1,R2
   \   00000340   742097E5           LDR      R2,[R7, #+116]
   \   00000344   0110A003           MOVEQ    R1,#+1
   \   00000348   0010A013           MOVNE    R1,#+0
   \   0000034C   032042E0           SUB      R2,R2,R3
   \   00000350   012082E2           ADD      R2,R2,#+1
   \   00000354   742087E5           STR      R2,[R7, #+116]
   \   00000358   022043E2           SUB      R2,R3,#+2
   \   0000035C   782087E5           STR      R2,[R7, #+120]
   \                     ??deflate_slow_13:
   \   00000360   6C2097E5           LDR      R2,[R7, #+108]
   \   00000364   012082E2           ADD      R2,R2,#+1
   \   00000368   6C2087E5           STR      R2,[R7, #+108]
   \   0000036C   020050E1           CMP      R0,R2
   \   00000370   1E00003A           BCC      ??deflate_slow_14
   \   00000374   6C5097E5           LDR      R5,[R7, #+108]
   \   00000378   389097E5           LDR      R9,[R7, #+56]
   \   0000037C   482097E5           LDR      R2,[R7, #+72]
   \   00000380   583097E5           LDR      R3,[R7, #+88]
   \   00000384   095085E0           ADD      R5,R5,R9
   \   00000388   0250D5E5           LDRB     R5,[R5, #+2]
   \   0000038C   122325E0           EOR      R2,R5,R2, LSL R3
   \   00000390   543097E5           LDR      R3,[R7, #+84]
   \   00000394   022003E0           AND      R2,R3,R2
   \   00000398   482087E5           STR      R2,[R7, #+72]
   \   0000039C   6C2097E5           LDR      R2,[R7, #+108]
   \   000003A0   343097E5           LDR      R3,[R7, #+52]
   \   000003A4   445097E5           LDR      R5,[R7, #+68]
   \   000003A8   022003E0           AND      R2,R3,R2
   \   000003AC   403097E5           LDR      R3,[R7, #+64]
   \   000003B0   822083E0           ADD      R2,R3,R2, LSL #+1
   \   000003B4   483097E5           LDR      R3,[R7, #+72]
   \   000003B8   833085E0           ADD      R3,R5,R3, LSL #+1
   \   000003BC   B030D3E1           LDRH     R3,[R3, #+0]
   \   000003C0   B030C2E1           STRH     R3,[R2, #+0]
   \   000003C4   6C2097E5           LDR      R2,[R7, #+108]
   \   000003C8   343097E5           LDR      R3,[R7, #+52]
   \   000003CC   022003E0           AND      R2,R3,R2
   \   000003D0   403097E5           LDR      R3,[R7, #+64]
   \   000003D4   822083E0           ADD      R2,R3,R2, LSL #+1
   \   000003D8   B090D2E1           LDRH     R9,[R2, #+0]
   \   000003DC   482097E5           LDR      R2,[R7, #+72]
   \   000003E0   443097E5           LDR      R3,[R7, #+68]
   \   000003E4   822083E0           ADD      R2,R3,R2, LSL #+1
   \   000003E8   6C3097E5           LDR      R3,[R7, #+108]
   \   000003EC   B030C2E1           STRH     R3,[R2, #+0]
   \                     ??deflate_slow_14:
   \   000003F0   782097E5           LDR      R2,[R7, #+120]
   \   000003F4   012042E2           SUB      R2,R2,#+1
   \   000003F8   782087E5           STR      R2,[R7, #+120]
   \   000003FC   000052E3           CMP      R2,#+0
   \   00000400   D6FFFF1A           BNE      ??deflate_slow_13
   \   00000404   684087E5           STR      R4,[R7, #+104]
   \   00000408   606087E5           STR      R6,[R7, #+96]
   \   0000040C   6C0097E5           LDR      R0,[R7, #+108]
   \   00000410   000051E3           CMP      R1,#+0
   \   00000414   010080E2           ADD      R0,R0,#+1
   \   00000418   6C0087E5           STR      R0,[R7, #+108]
   \   0000041C   0EFFFF0A           BEQ      ??deflate_slow_0
   \   00000420   5C0097E5           LDR      R0,[R7, #+92]
   \   00000424   000050E3           CMP      R0,#+0
   \   00000428   38109755           LDRPL    R1,[R7, #+56]
   \   0000042C   0010A043           MOVMI    R1,#+0
   \   00000430   01108050           ADDPL    R1,R0,R1
   \   00000434   FAFEFFEA           B        ??deflate_slow_1
   \                     ??deflate_slow_12:
   \   00000438   680097E5           LDR      R0,[R7, #+104]
   \   0000043C   000050E3           CMP      R0,#+0
   \   00000440   3000000A           BEQ      ??deflate_slow_15
   \   00000444   6C0097E5           LDR      R0,[R7, #+108]
   \   00000448   381097E5           LDR      R1,[R7, #+56]
   \   0000044C   0C209BE5           LDR      R2,[R11, #+12]
   \   00000450   010080E0           ADD      R0,R0,R1
   \   00000454   08109BE5           LDR      R1,[R11, #+8]
   \   00000458   010050E5           LDRB     R0,[R0, #-1]
   \   0000045C   811082E0           ADD      R1,R2,R1, LSL #+1
   \   00000460   B040C1E1           STRH     R4,[R1, #+0]
   \   00000464   08109BE5           LDR      R1,[R11, #+8]
   \   00000468   012081E2           ADD      R2,R1,#+1
   \   0000046C   08208BE5           STR      R2,[R11, #+8]
   \   00000470   00209BE5           LDR      R2,[R11, #+0]
   \   00000474   0200C1E7           STRB     R0,[R1, +R2]
   \   00000478   000187E0           ADD      R0,R7,R0, LSL #+2
   \   0000047C   B419D0E1           LDRH     R1,[R0, #+148]
   \   00000480   011081E2           ADD      R1,R1,#+1
   \   00000484   B419C0E1           STRH     R1,[R0, #+148]
   \   00000488   08009BE5           LDR      R0,[R11, #+8]
   \   0000048C   04109BE5           LDR      R1,[R11, #+4]
   \   00000490   011041E2           SUB      R1,R1,#+1
   \   00000494   010050E1           CMP      R0,R1
   \   00000498   0E00001A           BNE      ??deflate_slow_16
   \   0000049C   5C0097E5           LDR      R0,[R7, #+92]
   \   000004A0   5C2097E5           LDR      R2,[R7, #+92]
   \   000004A4   000050E3           CMP      R0,#+0
   \   000004A8   38109755           LDRPL    R1,[R7, #+56]
   \   000004AC   0030A0E3           MOV      R3,#+0
   \   000004B0   01108050           ADDPL    R1,R0,R1
   \   000004B4   6C0097E5           LDR      R0,[R7, #+108]
   \   000004B8   0010A043           MOVMI    R1,#+0
   \   000004BC   022040E0           SUB      R2,R0,R2
   \   000004C0   0700A0E1           MOV      R0,R7
   \   000004C4   ........           _BLF     _tr_flush_block,??_tr_flush_block??rA
   \   000004C8   6C0097E5           LDR      R0,[R7, #+108]
   \   000004CC   5C0087E5           STR      R0,[R7, #+92]
   \   000004D0   000097E5           LDR      R0,[R7, #+0]
   \   000004D4   ........           BL       flush_pending
   \                     ??deflate_slow_16:
   \   000004D8   6C0097E5           LDR      R0,[R7, #+108]
   \   000004DC   010080E2           ADD      R0,R0,#+1
   \   000004E0   6C0087E5           STR      R0,[R7, #+108]
   \   000004E4   740097E5           LDR      R0,[R7, #+116]
   \   000004E8   010040E2           SUB      R0,R0,#+1
   \   000004EC   740087E5           STR      R0,[R7, #+116]
   \   000004F0   000097E5           LDR      R0,[R7, #+0]
   \   000004F4   100090E5           LDR      R0,[R0, #+16]
   \   000004F8   000050E3           CMP      R0,#+0
   \   000004FC   D6FEFF1A           BNE      ??deflate_slow_0
   \   00000500   0000A0E3           MOV      R0,#+0
   \   00000504   F08FBDE8           POP      {R4-R11,PC}
   \                     ??deflate_slow_15:
   \   00000508   685087E5           STR      R5,[R7, #+104]
   \   0000050C   6C0097E5           LDR      R0,[R7, #+108]
   \   00000510   010080E2           ADD      R0,R0,#+1
   \   00000514   6C0087E5           STR      R0,[R7, #+108]
   \   00000518   740097E5           LDR      R0,[R7, #+116]
   \   0000051C   010040E2           SUB      R0,R0,#+1
   \   00000520   740087E5           STR      R0,[R7, #+116]
   \   00000524   CCFEFFEA           B        ??deflate_slow_0
   \                     ??deflate_slow_5:
   \   00000528   5C0097E5           LDR      R0,[R7, #+92]
   \   0000052C   5C2097E5           LDR      R2,[R7, #+92]
   \   00000530   000050E3           CMP      R0,#+0
   \   00000534   38109755           LDRPL    R1,[R7, #+56]
   \   00000538   01108050           ADDPL    R1,R0,R1
   \   0000053C   6C0097E5           LDR      R0,[R7, #+108]
   \   00000540   0010A043           MOVMI    R1,#+0
   \   00000544   022040E0           SUB      R2,R0,R2
   \   00000548   0700A0E1           MOV      R0,R7
   \   0000054C   ........           _BLF     _tr_flush_block,??_tr_flush_block??rA
   \   00000550   6C0097E5           LDR      R0,[R7, #+108]
   \   00000554   5C0087E5           STR      R0,[R7, #+92]
   \   00000558   000097E5           LDR      R0,[R7, #+0]
   \   0000055C   ........           BL       flush_pending
   \   00000560   000097E5           LDR      R0,[R7, #+0]
   \   00000564   100090E5           LDR      R0,[R0, #+16]
   \   00000568   000050E3           CMP      R0,#+0
   \   0000056C   0200001A           BNE      ??deflate_slow_17
   \   00000570   040058E3           CMP      R8,#+4
   \   00000574   0200A003           MOVEQ    R0,#+2
   \   00000578   F08FBDE8           POP      {R4-R11,PC}
   1679              return flush == Z_FINISH ? finish_done : block_done;
   \                     ??deflate_slow_17:
   \   0000057C   040058E3           CMP      R8,#+4
   \   00000580   0300A003           MOVEQ    R0,#+3
   \   00000584   F08FBD08           POPEQ    {R4-R11,PC}
   \   00000588   0100A0E3           MOV      R0,#+1
   \   0000058C   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1680          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   ........           DC32     configuration_table

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     configuration_table

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     _length_code

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   ........           DC32     _dist_code
   1681          #endif /* FASTEST */
   1682          
   1683          #if 0
   1684          /* ===========================================================================
   1685           * For Z_RLE, simply look for runs of bytes, generate matches only of distance
   1686           * one.  Do not maintain a hash table.  (It will be regenerated if this run of
   1687           * deflate switches away from Z_RLE.)
   1688           */
   1689          local block_state deflate_rle(s, flush)
   1690              deflate_state *s;
   1691              int flush;
   1692          {
   1693              int bflush;         /* set if current block must be flushed */
   1694              uInt run;           /* length of run */
   1695              uInt max;           /* maximum length of run */
   1696              uInt prev;          /* byte at distance one to match */
   1697              Bytef *scan;        /* scan for end of run */
   1698          
   1699              for (;;) {
   1700                  /* Make sure that we always have enough lookahead, except
   1701                   * at the end of the input file. We need MAX_MATCH bytes
   1702                   * for the longest encodable run.
   1703                   */
   1704                  if (s->lookahead < MAX_MATCH) {
   1705                      fill_window(s);
   1706                      if (s->lookahead < MAX_MATCH && flush == Z_NO_FLUSH) {
   1707                          return need_more;
   1708                      }
   1709                      if (s->lookahead == 0) break; /* flush the current block */
   1710                  }
   1711          
   1712                  /* See how many times the previous byte repeats */
   1713                  run = 0;
   1714                  if (s->strstart > 0) {      /* if there is a previous byte, that is */
   1715                      max = s->lookahead < MAX_MATCH ? s->lookahead : MAX_MATCH;
   1716                      scan = s->window + s->strstart - 1;
   1717                      prev = *scan++;
   1718                      do {
   1719                          if (*scan++ != prev)
   1720                              break;
   1721                      } while (++run < max);
   1722                  }
   1723          
   1724                  /* Emit match if have run of MIN_MATCH or longer, else emit literal */
   1725                  if (run >= MIN_MATCH) {
   1726                      check_match(s, s->strstart, s->strstart - 1, run);
   1727                      _tr_tally_dist(s, 1, run - MIN_MATCH, bflush);
   1728                      s->lookahead -= run;
   1729                      s->strstart += run;
   1730                  } else {
   1731                      /* No match, output a literal byte */
   1732                      Tracevv((stderr,"%c", s->window[s->strstart]));
   1733                      _tr_tally_lit (s, s->window[s->strstart], bflush);
   1734                      s->lookahead--;
   1735                      s->strstart++;
   1736                  }
   1737                  if (bflush) FLUSH_BLOCK(s, 0);
   1738              }
   1739              FLUSH_BLOCK(s, flush == Z_FINISH);
   1740              return flush == Z_FINISH ? finish_done : block_done;
   1741          }
   1742          #endif

   Maximum stack usage in bytes:

     Function             CSTACK
     --------             ------
     deflate                 40
     deflateBound             4
     deflateCopy             24
     deflateEnd              12
     deflateInit2_           36
     deflateInit_            20
     deflateParams           20
     deflatePrime             0
     deflateReset            16
     deflateSetDictionary    24
     deflateSetHeader         0
     deflateTune              0
     deflate_fast            24
     deflate_slow            36
     deflate_stored          20
     fill_window             20
     flush_pending           12
     lm_init                 12
     longest_match           48
     longest_match_fast      12
     putShortMSB              0
     read_buf                16


   Segment part sizes:

     Function/Label       Bytes
     --------------       -----
     deflate_copyright      56
     configuration_table   120
     deflateInit_           44
     deflateInit2_         640
     deflateSetDictionary  292
     deflateReset          180
     deflateSetHeader       48
     deflatePrime           72
     deflateParams         204
     deflateTune            48
     deflateBound           72
     putShortMSB            48
     flush_pending         132
     deflate              2732
     deflateEnd            220
     deflateCopy           424
     read_buf              160
     lm_init               164
     longest_match         496
     longest_match_fast    272
     fill_window           336
     deflate_stored        436
     deflate_fast         1128
     deflate_slow         1424
     ??DataTable1            4
     ??DataTable2            4
     ??DataTable5            4
     ??DataTable6            4
      Others               196

 
 9 784 bytes in segment CODE
   176 bytes in segment DATA_C
 
 9 588 bytes of CODE  memory (+ 196 bytes shared)
   176 bytes of CONST memory

Errors: none
Warnings: none
