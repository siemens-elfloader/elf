##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    05/Aug/2009  15:39:59 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\CBN\SWILIB.C                                  #
#    Command line    =  C:\arm\CBN\SWILIB.C -D NEWSGOLD -D HIGHCOLOR -D      #
#                       GRAPH -D UNPACK -D NOZIP -D NORAR -lC                #
#                       C:\arm\CBN\UltraVix\Release\List\ -o                 #
#                       C:\arm\CBN\UltraVix\Release\Obj\ -s9 --no_unroll     #
#                       --no_clustering --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --char_is_signed --fpu None -I "C:\arm2\Embedded     #
#                       Workbench 4.0 Evaluation\ARM\INC\"                   #
#                       --inline_threshold=2                                 #
#    List file       =  C:\arm\CBN\UltraVix\Release\List\SWILIB.lst          #
#    Object file     =  C:\arm\CBN\UltraVix\Release\Obj\SWILIB.r79           #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\CBN\SWILIB.C
      1          
      2          // swilib.c
      3          #include "swilib.h"
      4          
      5          //#define HIGHCOLOR // 16-битный режим
      6          //#define GRAPH  // Графика
      7          //#define UNPACK // Распаковка архивов
      8          //#define NO7Z   // Кроме 7z
      9          //#define NOZIP  // Кроме zip
     10          //#define NORAR  // Кроме rar
     11          //#define NOLOAD // in loadgraph data loaded allready
     12          
     13          //#ifdef ELKA
     14          //  #define width 240
     15          //  #define height 304
     16          //#else
     17          //  #define width 132
     18          //  #define height 176
     19          //#endif
     20          extern int width, height;
     21          

   \                                 In segment DATA_Z, align 4, align-sorted
     22          unsigned int err=0;
   \                     err:
   \   00000000                      DS8 4

   \                                 In segment DATA_Z, align 4, align-sorted
     23          int loadfilesize=0;
   \                     loadfilesize:
   \   00000000                      DS8 4
     24          
     25          //#define ELKA // Для EL-71
     26          #ifndef NEWSGOLD
     27          #define NEWSGOLD // Для S75
     28          #endif
     29          #ifndef NEWSGOLD
     30          
     31          int fread32(int fh, void *buf, int len, unsigned int *err){
     32            int clen, rlen, total=0;
     33            while(len){
     34            if (len>16384) clen=16384; else clen=len;
     35            total+=(rlen=fread(fh, buf, clen, err));
     36            if (rlen!=clen) break;
     37            buf=(char*)buf+rlen;
     38            len-=clen;
     39            }return(total);
     40          }
     41          
     42          int fwrite32(int fh, void *buf, int len, unsigned int *err){
     43            int clen, rlen, total=0;
     44            while(len){
     45            if (len>16384) clen=16384; else clen=len;
     46            total+=(rlen=fwrite(fh, buf, clen, err));
     47            if (rlen!=clen) break;
     48            buf=(char*)buf+rlen;
     49            len-=clen;
     50            }return(total);
     51          }
     52          #endif
     53          
     54          //void *memset(void *mem, int val, int size){
     55          //  char *s=(char*)mem;
     56          //  while(--size>=0) *s++=(char)val;
     57          //  return mem;
     58          //}
     59          
     60          //void *memsetw(void *mem, int val, int size){
     61          //  short *s=(short*)mem;
     62          //  while(--size>=0) *s++=val;
     63          //  return mem;
     64          //}
     65          

   \                                 In segment CODE, align 4, keep-with-next
     66          int min(int a, int b){ return (a<b)?a:b;}
   \                     min:
   \   00000000   010050E1           CMP      R0,R1
   \   00000004   0100A0A1           MOVGE    R0,R1
   \   00000008   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
     67          int max(int a, int b){ return (a>b)?a:b;}
   \                     max:
   \   00000000   000051E1           CMP      R1,R0
   \   00000004   0100A0A1           MOVGE    R0,R1
   \   00000008   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
     68          int abs(int a){ return (a<0)?-a:a;}
   \                     abs:
   \   00000000   000050E3           CMP      R0,#+0
   \   00000004   00006042           RSBMI    R0,R0,#+0
   \   00000008   1EFF2FE1           BX       LR               ;; return
     69          

   \                                 In segment CODE, align 4, keep-with-next
     70          int fgets(char *buf,int size,int fh){ return 0;} //fake!!!
   \                     fgets:
   \   00000000   0000A0E3           MOV      R0,#+0
   \   00000004   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
     71          void printf(char *s,...){}  //fake!!!
   \                     printf:
   \   00000000   0E002DE9           PUSH     {R1-R3}
   \   00000004   0CD08DE2           ADD      SP,SP,#+12
   \   00000008   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
     72          char *strdup(char *s){ return s;}
   \                     strdup:
   \   00000000   1EFF2FE1           BX       LR               ;; return
     73          
     74          //void *memcpyrev(void *to, void *from, int size){
     75          //  char *s=(char*)to+size, *ss=(char*)from+size;
     76          //  while(--size>=0)
     77          //    *--s=*--ss;
     78          //  return to;
     79          //}
     80          

   \                                 In segment CODE, align 4, keep-with-next
     81          int savefile(char *fname, char *buf, int size){
   \                     savefile:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
     82            int f,i;
     83            if((f=fopen(fname,A_WriteOnly+A_BIN+A_Create+A_Truncate,P_WRITE,&err))==-1) return 0;
   \   00000004   50609FE5           LDR      R6,??savefile_0  ;; err
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   0250A0E1           MOV      R5,R2
   \   00000010   0630A0E1           MOV      R3,R6
   \   00000014   402FA0E3           MOV      R2,#+256
   \   00000018   0110A0E3           MOV      R1,#+1
   \   0000001C   831C81E3           ORR      R1,R1,#0x8300
   \   00000020   0A0000EF           SWI      +10
   \   00000024   0070A0E1           MOV      R7,R0
   \   00000028   010077E3           CMN      R7,#+1
   \   0000002C   0000A003           MOVEQ    R0,#+0
   \   00000030   F080BD08           POPEQ    {R4-R7,PC}
     84            i=fwrite32(f,buf,size,&err); 
   \   00000034   0630A0E1           MOV      R3,R6
   \   00000038   0520A0E1           MOV      R2,R5
   \   0000003C   0410A0E1           MOV      R1,R4
   \   00000040   0C0000EF           SWI      +12
   \   00000044   0040A0E1           MOV      R4,R0
     85            fclose(f,&err); 
   \   00000048   0610A0E1           MOV      R1,R6
   \   0000004C   0700A0E1           MOV      R0,R7
   \   00000050   0D0000EF           SWI      +13
     86            return i;
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??savefile_0:
   \   0000005C   ........           DC32     err
     87          }
     88          

   \                                 In segment CODE, align 4, keep-with-next
     89          char *loadfile(char *filename){ // Загрузить файл, распак-ть
   \                     loadfile:
   \   00000000   E0402DE9           PUSH     {R5-R7,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
     90            int f; unsigned int err;  char *buf=0;
   \   00000008   0060A0E3           MOV      R6,#+0
     91            if((f=fopen(filename,A_ReadOnly+A_BIN,P_READ,&err))!=-1){
   \   0000000C   0D30A0E1           MOV      R3,SP
   \   00000010   8020A0E3           MOV      R2,#+128
   \   00000014   801CA0E3           MOV      R1,#+32768
   \   00000018   0A0000EF           SWI      +10
   \   0000001C   0070A0E1           MOV      R7,R0
   \   00000020   010077E3           CMN      R7,#+1
   \   00000024   3000000A           BEQ      ??loadfile_0
     92              if(loadfilesize=lseek(f,0,2,&err,&err)){
   \   00000028   C4509FE5           LDR      R5,??loadfile_1  ;; loadfilesize
   \   0000002C   0D00A0E1           MOV      R0,SP
   \   00000030   01002DE9           PUSH     {R0}
   \   00000034   04308DE2           ADD      R3,SP,#+4
   \   00000038   0220A0E3           MOV      R2,#+2
   \   0000003C   0010A0E3           MOV      R1,#+0
   \   00000040   0700A0E1           MOV      R0,R7
   \   00000044   0F0000EF           SWI      +15
   \   00000048   000085E5           STR      R0,[R5, #+0]
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   04D08DE2           ADD      SP,SP,#+4
   \   00000054   1400000A           BEQ      ??loadfile_2
     93                buf=(char*)malloc(loadfilesize);
   \   00000058   140000EF           SWI      +20
   \   0000005C   0060A0E1           MOV      R6,R0
     94                lseek(f,0,0,&err,&err);
   \   00000060   0D00A0E1           MOV      R0,SP
   \   00000064   01002DE9           PUSH     {R0}
   \   00000068   04308DE2           ADD      R3,SP,#+4
   \   0000006C   0020A0E3           MOV      R2,#+0
   \   00000070   0010A0E3           MOV      R1,#+0
   \   00000074   0700A0E1           MOV      R0,R7
   \   00000078   0F0000EF           SWI      +15
     95                if(fread32(f,buf,loadfilesize,&err)!=loadfilesize){ mfree(buf); buf=0;}
   \   0000007C   002095E5           LDR      R2,[R5, #+0]
   \   00000080   04308DE2           ADD      R3,SP,#+4
   \   00000084   0610A0E1           MOV      R1,R6
   \   00000088   0700A0E1           MOV      R0,R7
   \   0000008C   0B0000EF           SWI      +11
   \   00000090   001095E5           LDR      R1,[R5, #+0]
   \   00000094   04D08DE2           ADD      SP,SP,#+4
   \   00000098   010050E1           CMP      R0,R1
   \   0000009C   0200000A           BEQ      ??loadfile_2
   \   000000A0   0600A0E1           MOV      R0,R6
   \   000000A4   150000EF           SWI      +21
   \   000000A8   0060A0E3           MOV      R6,#+0
     96              } fclose(f,&err);
   \                     ??loadfile_2:
   \   000000AC   0D10A0E1           MOV      R1,SP
   \   000000B0   0700A0E1           MOV      R0,R7
   \   000000B4   0D0000EF           SWI      +13
     97          #ifdef UNPACK
     98              extern char *un7z(char *buf);
     99              extern char *unrar(char *buf);
    100              extern char *unzip(char *buf);
    101              if(buf && loadfilesize>4){
   \   000000B8   000056E3           CMP      R6,#+0
   \   000000BC   0A00000A           BEQ      ??loadfile_0
   \   000000C0   000095E5           LDR      R0,[R5, #+0]
   \   000000C4   050050E3           CMP      R0,#+5
   \   000000C8   070000BA           BLT      ??loadfile_0
    102          #ifndef NORAR
    103                if(*(int *)buf=='!raR') buf=unrar(buf); //unrar
    104                else
    105          #endif      
    106          #ifndef NOZIP
    107                if(*(int*)buf==0x4034b50) buf=unzip(buf); //unzip
    108                else
    109          #endif
    110          #ifndef NO7Z      
    111                if(*(short*)buf=='z7') buf=un7z(buf); //un7z
   \   000000CC   F000D6E1           LDRSH    R0,[R6, #+0]
   \   000000D0   3710A0E3           MOV      R1,#+55
   \   000000D4   7A1C81E3           ORR      R1,R1,#0x7A00
   \   000000D8   010050E1           CMP      R0,R1
   \   000000DC   0200001A           BNE      ??loadfile_0
   \   000000E0   0600A0E1           MOV      R0,R6
   \   000000E4   ........           _BLF     un7z,??un7z??rA
   \   000000E8   0060A0E1           MOV      R6,R0
    112          #endif
    113               ;      
    114              }
    115          //#ifdef SAVETEST
    116          //  int out=fopen("0:\\ZBin\\123",A_WriteOnly+A_BIN+A_Create,P_WRITE,&err);
    117          //  fwrite32(out,buf,loadfilesize,&err);
    118          //  fclose(out,&err);
    119          //#endif    
    120              
    121          #endif      
    122            } return buf;
   \                     ??loadfile_0:
   \   000000EC   0600A0E1           MOV      R0,R6
   \   000000F0   E280BDE8           POP      {R1,R5-R7,PC}
   \                     ??loadfile_1:
   \   000000F4   ........           DC32     loadfilesize
    123          }
    124          
    125          //void *memset(void *buf, int val, int size){
    126          //  char *b=(char*)buf;
    127          //  while(--size>=0) *b++=val; 
    128          //  return buf;
    129          //}
    130          

   \                                 In segment CODE, align 4, keep-with-next
    131          char *toup(char *str){			// К верхнему регистру
    132            char *val=str;
   \                     toup:
   \   00000000   0010A0E1           MOV      R1,R0
   \   00000004   D020D1E1           LDRSB    R2,[R1, #+0]
   \   00000008   1FC0E0E3           MVN      R12,#+31
   \   0000000C   000052E3           CMP      R2,#+0
   \   00000010   1EFF2F01           BXEQ     LR
    133            while(*val!=NULL){
    134                   if(*val>='a' && *val<='z')  *val-=' ';  
   \                     ??toup_0:
   \   00000014   D020D1E1           LDRSB    R2,[R1, #+0]
   \   00000018   0230A0E1           MOV      R3,R2
   \   0000001C   610052E3           CMP      R2,#+97
   \   00000020   030000BA           BLT      ??toup_1
   \   00000024   7B0053E3           CMP      R3,#+123
   \   00000028   0A0000AA           BGE      ??toup_2
   \                     ??toup_3:
   \   0000002C   203043E2           SUB      R3,R3,#+32
   \   00000030   080000EA           B        ??toup_2
    135              else if(*val>='а' && *val<='п')  *val-=' ';  
   \                     ??toup_1:
   \   00000034   10208CE3           ORR      R2,R12,#0x10
   \   00000038   0C0053E1           CMP      R3,R12
   \   0000003C   010000BA           BLT      ??toup_4
   \   00000040   020053E1           CMP      R3,R2
   \   00000044   F8FFFFBA           BLT      ??toup_3
    136              else if(*val>='р' && *val<='я')  *val-= 80;  
   \                     ??toup_4:
   \   00000048   020053E1           CMP      R3,R2
   \   0000004C   010000BA           BLT      ??toup_2
   \   00000050   000053E3           CMP      R3,#+0
   \   00000054   50304342           SUBMI    R3,R3,#+80
   \                     ??toup_2:
   \   00000058   ........           STRB     R3,[R1], #+1
    137              ++val;
    138            }
   \   0000005C   D020D1E1           LDRSB    R2,[R1, #+0]
   \   00000060   000052E3           CMP      R2,#+0
   \   00000064   EAFFFF1A           BNE      ??toup_0
    139            return str;
   \   00000068   1EFF2FE1           BX       LR               ;; return
    140          }  
    141          

   \                                 In segment CODE, align 4, keep-with-next
    142          char *todown(char *str){		// К нижнему регистру
    143            char *val=str;
   \                     todown:
   \   00000000   0010A0E1           MOV      R1,R0
   \   00000004   D020D1E1           LDRSB    R2,[R1, #+0]
   \   00000008   3FC0E0E3           MVN      R12,#+63
   \   0000000C   000052E3           CMP      R2,#+0
   \   00000010   1EFF2F01           BXEQ     LR
    144            while(*val!=NULL){
    145                   if(*val>='A' && *val<='Z')  *val+=' '; 
   \                     ??todown_0:
   \   00000014   D020D1E1           LDRSB    R2,[R1, #+0]
   \   00000018   0230A0E1           MOV      R3,R2
   \   0000001C   410052E3           CMP      R2,#+65
   \   00000020   030000BA           BLT      ??todown_1
   \   00000024   5B0053E3           CMP      R3,#+91
   \   00000028   0B0000AA           BGE      ??todown_2
   \                     ??todown_3:
   \   0000002C   203083E2           ADD      R3,R3,#+32
   \   00000030   090000EA           B        ??todown_2
    146              else if(*val>='А' && *val<='П')  *val+=' ';
   \                     ??todown_1:
   \   00000034   10208CE3           ORR      R2,R12,#0x10
   \   00000038   0C0053E1           CMP      R3,R12
   \   0000003C   010000BA           BLT      ??todown_4
   \   00000040   020053E1           CMP      R3,R2
   \   00000044   F8FFFFBA           BLT      ??todown_3
    147              else if(*val>='Р' && *val<='Я')  *val+= 80; 
   \                     ??todown_4:
   \   00000048   020053E1           CMP      R3,R2
   \   0000004C   020000BA           BLT      ??todown_2
   \   00000050   102082E2           ADD      R2,R2,#+16
   \   00000054   020053E1           CMP      R3,R2
   \   00000058   503083B2           ADDLT    R3,R3,#+80
   \                     ??todown_2:
   \   0000005C   ........           STRB     R3,[R1], #+1
    148              ++val;
    149            }
   \   00000060   D020D1E1           LDRSB    R2,[R1, #+0]
   \   00000064   000052E3           CMP      R2,#+0
   \   00000068   E9FFFF1A           BNE      ??todown_0
    150            return str;
   \   0000006C   1EFF2FE1           BX       LR               ;; return
    151          }  
    152          

   \                                 In segment CODE, align 4, keep-with-next
    153          int  isalth (unsigned char sym){	// Алфавитный символ ?
    154            return ((sym>='A' && sym<='Z') || (sym>=(unsigned char)'А' && sym<=(unsigned char)'П')
    155              || (sym>=(unsigned char)'Р' && sym<=(unsigned char)'Я'));}
   \                     isalth:
   \   00000000   410050E3           CMP      R0,#+65
   \   00000004   0100003A           BCC      ??isalth_0
   \   00000008   5B0050E3           CMP      R0,#+91
   \   0000000C   0700003A           BCC      ??isalth_1
   \                     ??isalth_0:
   \   00000010   C00050E3           CMP      R0,#+192
   \   00000014   0100003A           BCC      ??isalth_2
   \   00000018   D00050E3           CMP      R0,#+208
   \   0000001C   0300003A           BCC      ??isalth_1
   \                     ??isalth_2:
   \   00000020   D00050E3           CMP      R0,#+208
   \   00000024   0300003A           BCC      ??isalth_3
   \   00000028   E00050E3           CMP      R0,#+224
   \   0000002C   0100002A           BCS      ??isalth_3
   \                     ??isalth_1:
   \   00000030   0100A0E3           MOV      R0,#+1
   \   00000034   1EFF2FE1           BX       LR
   \                     ??isalth_3:
   \   00000038   0000A0E3           MOV      R0,#+0
   \   0000003C   1EFF2FE1           BX       LR               ;; return
    156          

   \                                 In segment CODE, align 4, keep-with-next
    157          int  isval (char sym){		// Символ является числом ?
    158            return (sym>='0' && sym<='9');}
   \                     isval:
   \   00000000   300050E3           CMP      R0,#+48
   \   00000004   020000BA           BLT      ??isval_0
   \   00000008   3A0050E3           CMP      R0,#+58
   \   0000000C   0100A0B3           MOVLT    R0,#+1
   \   00000010   1EFF2FB1           BXLT     LR
   \                     ??isval_0:
   \   00000014   0000A0E3           MOV      R0,#+0
   \   00000018   1EFF2FE1           BX       LR               ;; return
    159          

   \                                 In segment CODE, align 4, keep-with-next
    160          int strchrpos(const char *s, int c){	// Позиция символа в строке (1-N, 0=нет)
   \                     strchrpos:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    161            char *sptr=strchr(s,c);
   \   00000008   ........           _BLF     strchr,??strchr??rA
    162            return (sptr)?sptr-s+1:NULL;
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   04004010           SUBNE    R0,R0,R4
   \   00000014   01008012           ADDNE    R0,R0,#+1
   \   00000018   1080BDE8           POP      {R4,PC}          ;; return
    163          }
    164            

   \                                 In segment CODE, align 4, keep-with-next
    165          int emptystr(char *str){		// Пустая ли строка
   \                     emptystr:
   \   00000000   000000EA           B        ??emptystr_0
    166            while(*str && (*str==' ' || *str==9)) ++str;
   \                     ??emptystr_1:
   \   00000004   010080E2           ADD      R0,R0,#+1
   \                     ??emptystr_0:
   \   00000008   D010D0E1           LDRSB    R1,[R0, #+0]
   \   0000000C   000051E3           CMP      R1,#+0
   \   00000010   0200000A           BEQ      ??emptystr_2
   \   00000014   200051E3           CMP      R1,#+32
   \   00000018   09005113           CMPNE    R1,#+9
   \   0000001C   F8FFFF0A           BEQ      ??emptystr_1
    167            return ((*str)?0:1);
   \                     ??emptystr_2:
   \   00000020   000051E3           CMP      R1,#+0
   \   00000024   0000A013           MOVNE    R0,#+0
   \   00000028   1EFF2F11           BXNE     LR
   \   0000002C   0100A0E3           MOV      R0,#+1
   \   00000030   1EFF2FE1           BX       LR               ;; return
    168          }
    169          

   \                                 In segment CODE, align 4, keep-with-next
    170          char  *alltrim (char *str){		// Удалить пробелы по бокам строки
    171            char *s;
    172            if(!*str) return str;
   \                     alltrim:
   \   00000000   D010D0E1           LDRSB    R1,[R0, #+0]
   \   00000004   000051E3           CMP      R1,#+0
   \   00000008   0100001A           BNE      ??alltrim_0
   \   0000000C   1EFF2FE1           BX       LR
    173            while(*str==' ' || *str==9) ++str;
   \                     ??alltrim_1:
   \   00000010   010080E2           ADD      R0,R0,#+1
   \                     ??alltrim_0:
   \   00000014   D010D0E1           LDRSB    R1,[R0, #+0]
   \   00000018   200051E3           CMP      R1,#+32
   \   0000001C   09005113           CMPNE    R1,#+9
   \   00000020   FAFFFF0A           BEQ      ??alltrim_1
    174            s=str;
   \   00000024   0010A0E1           MOV      R1,R0
   \   00000028   D020D1E1           LDRSB    R2,[R1, #+0]
   \   0000002C   000052E3           CMP      R2,#+0
   \   00000030   0200000A           BEQ      ??alltrim_2
    175            while(*s) ++s;
   \                     ??alltrim_3:
   \   00000034   D120F1E1           LDRSB    R2,[R1, #+1]!
   \   00000038   000052E3           CMP      R2,#+0
   \   0000003C   FCFFFF1A           BNE      ??alltrim_3
    176            while(s>str && (*(s-1)==' ' || *(s-1)==9)) --s;
   \                     ??alltrim_2:
   \   00000040   010050E1           CMP      R0,R1
   \   00000044   0400002A           BCS      ??alltrim_4
   \   00000048   D12051E1           LDRSB    R2,[R1, #-1]
   \   0000004C   200052E3           CMP      R2,#+32
   \   00000050   09005213           CMPNE    R2,#+9
   \   00000054   01104102           SUBEQ    R1,R1,#+1
   \   00000058   F8FFFF0A           BEQ      ??alltrim_2
    177            *s=NULL;
   \                     ??alltrim_4:
   \   0000005C   0020A0E3           MOV      R2,#+0
   \   00000060   0020C1E5           STRB     R2,[R1, #+0]
    178            return str;
   \   00000064   1EFF2FE1           BX       LR               ;; return
    179          }
    180          

   \                                 In segment CODE, align 4, keep-with-next
    181          int   strcmpsize (const char *s1,const char *s2,int size){ // Сравнить строки длины size
   \                     strcmpsize:
   \   00000000   10002DE9           PUSH     {R4}
    182            int i;
    183            for(i=0;i<size && s1[i]==s2[i];i++);
   \   00000004   0030A0E3           MOV      R3,#+0
   \   00000008   040000EA           B        ??strcmpsize_0
   \                     ??strcmpsize_1:
   \   0000000C   D0C093E1           LDRSB    R12,[R3, +R0]
   \   00000010   D14093E1           LDRSB    R4,[R3, +R1]
   \   00000014   04005CE1           CMP      R12,R4
   \   00000018   0400001A           BNE      ??strcmpsize_2
   \   0000001C   013083E2           ADD      R3,R3,#+1
   \                     ??strcmpsize_0:
   \   00000020   020053E1           CMP      R3,R2
   \   00000024   F8FFFFBA           BLT      ??strcmpsize_1
    184              return (i==size)?NULL:s1[i]-s2[i];
   \   00000028   0000A003           MOVEQ    R0,#+0
   \   0000002C   0200000A           BEQ      ??strcmpsize_3
   \                     ??strcmpsize_2:
   \   00000030   D00093E1           LDRSB    R0,[R3, +R0]
   \   00000034   D11093E1           LDRSB    R1,[R3, +R1]
   \   00000038   010040E0           SUB      R0,R0,R1
   \                     ??strcmpsize_3:
   \   0000003C   1000BDE8           POP      {R4}
   \   00000040   1EFF2FE1           BX       LR               ;; return
    185          }
    186          

   \                                 In segment CODE, align 4, keep-with-next
    187          int getint(void *ptr){ // Получить int
    188            if((int)ptr & 3) return *(unsigned char*)ptr | *((unsigned char*)ptr+1)<<8\
   \                     getint:
   \   00000000   030010E3           TST      R0,#0x3
   \   00000004   0700000A           BEQ      ??getint_0
    189              | *((unsigned char*)ptr+2)<<16 | *((unsigned char*)ptr+3)<<24;
   \   00000008   0010D0E5           LDRB     R1,[R0, #+0]
   \   0000000C   0120D0E5           LDRB     R2,[R0, #+1]
   \   00000010   021481E1           ORR      R1,R1,R2, LSL #+8
   \   00000014   0220D0E5           LDRB     R2,[R0, #+2]
   \   00000018   0300D0E5           LDRB     R0,[R0, #+3]
   \   0000001C   021881E1           ORR      R1,R1,R2, LSL #+16
   \   00000020   000C81E1           ORR      R0,R1,R0, LSL #+24
   \   00000024   1EFF2FE1           BX       LR
    190            else return *(int*)ptr;
   \                     ??getint_0:
   \   00000028   000090E5           LDR      R0,[R0, #+0]
   \   0000002C   1EFF2FE1           BX       LR               ;; return
    191          }
    192          

   \                                 In segment CODE, align 4, keep-with-next
    193          int get3int(void *ptr){ // Получить 3int
    194            return *(unsigned char*)ptr | *((unsigned char*)ptr+1)<<8 | *((unsigned char*)ptr+2)<<16; 
   \                     get3int:
   \   00000000   0010D0E5           LDRB     R1,[R0, #+0]
   \   00000004   0120D0E5           LDRB     R2,[R0, #+1]
   \   00000008   0200D0E5           LDRB     R0,[R0, #+2]
   \   0000000C   021481E1           ORR      R1,R1,R2, LSL #+8
   \   00000010   000881E1           ORR      R0,R1,R0, LSL #+16
   \   00000014   1EFF2FE1           BX       LR               ;; return
    195          }
    196          

   \                                 In segment CODE, align 4, keep-with-next
    197          short getshort(void *ptr){ // Получить short
    198            if((int)ptr & 1) return *(unsigned char*)ptr | *((unsigned char*)ptr+1)<<8;
   \                     getshort:
   \   00000000   010010E3           TST      R0,#0x1
   \   00000004   0500000A           BEQ      ??getshort_0
   \   00000008   0010D0E5           LDRB     R1,[R0, #+0]
   \   0000000C   0100D0E5           LDRB     R0,[R0, #+1]
   \   00000010   000481E1           ORR      R0,R1,R0, LSL #+8
   \   00000014   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000018   4008A0E1           MOV      R0,R0, ASR #+16
   \   0000001C   1EFF2FE1           BX       LR
    199            else return *(short*)ptr;
   \                     ??getshort_0:
   \   00000020   F000D0E1           LDRSH    R0,[R0, #+0]
   \   00000024   1EFF2FE1           BX       LR               ;; return
    200          }
    201          

   \                                 In segment CODE, align 4, keep-with-next
    202          void putint(void *ptr, int data){ // Записать int
    203            if((int)ptr & 3){ *(char*)ptr=data; *((char*)ptr+1)=data>>8;
   \                     putint:
   \   00000000   030010E3           TST      R0,#0x3
   \   00000004   0700000A           BEQ      ??putint_0
   \   00000008   0010C0E5           STRB     R1,[R0, #+0]
   \   0000000C   4124A0E1           ASR      R2,R1,#+8
   \   00000010   0120C0E5           STRB     R2,[R0, #+1]
    204              *((char*)ptr+2)=data>>16; *((char*)ptr+3)=data>>24;
   \   00000014   4128A0E1           ASR      R2,R1,#+16
   \   00000018   0220C0E5           STRB     R2,[R0, #+2]
   \   0000001C   411CA0E1           ASR      R1,R1,#+24
   \   00000020   0310C0E5           STRB     R1,[R0, #+3]
   \   00000024   1EFF2FE1           BX       LR
    205            }else *(int*)ptr=data;
   \                     ??putint_0:
   \   00000028   001080E5           STR      R1,[R0, #+0]
    206            
    207          }
   \   0000002C   1EFF2FE1           BX       LR               ;; return
    208           

   \                                 In segment CODE, align 4, keep-with-next
    209          void putshort(void *ptr, short data){ // Записать short
    210            if((int)ptr & 1){ *(char*)ptr=data; *((char*)ptr+1)=data>>8;
   \                     putshort:
   \   00000000   010010E3           TST      R0,#0x1
   \   00000004   0300000A           BEQ      ??putshort_0
   \   00000008   0010C0E5           STRB     R1,[R0, #+0]
   \   0000000C   4114A0E1           ASR      R1,R1,#+8
   \   00000010   0110C0E5           STRB     R1,[R0, #+1]
   \   00000014   1EFF2FE1           BX       LR
    211            }else *(short*)ptr=data;
   \                     ??putshort_0:
   \   00000018   B010C0E1           STRH     R1,[R0, #+0]
    212          }
   \   0000001C   1EFF2FE1           BX       LR               ;; return
    213          
    214          #ifdef GRAPH
    215          /*-----------------------------
    216          смещ.	размер	имя
    217          00	2	'BM'
    218          02	4	Размер файла в байтах;
    219          06	2	0
    220          08	2	0
    221          10	4	Смещение начала изображения в файле;
    222          14	4	Размер этого заголовка, 40;
    223          18	4	Ширина изображения в пикселях;
    224          22	4	Высота изображения в пикселях;
    225          26	2	Число плоскостей изображения, 1;
    226          28	2	Бит на пиксел: 1,4,8 или 24;
    227          30	4	Тип сжатия;
    228          34	4	Размер сжатого изображения в байтах или 0;
    229          38	4	Горизонтальное разрешение, в пикселях / на метр;
    230          42	4	Вертикальное разрешение, в пикселях / на метр;
    231          46	4	Количество используемых цветов;
    232          50	4	Число "важных" цветов;
    233          54	4*N	Карты цветов BGRР;
    234          
    235          BMP	заголовок 54 б + палитра 4*256;*/
    236          
    237          inline unsigned char rgb888tobyte(int color){
    238            return ((color>>6)&3)|((color>>11)&0x1C)|((color>>16)&0xE0); }
    239          
    240          inline short rgb888toshort(int color){
    241            return ((color>>3)&0x1f)|((color>>5)&0x7e0)|((color>>8)&0xf800); }
    242          
    243          inline unsigned char rgb565tobyte(short color){
    244            return ((color>>3)&3)|((color>>6)&0x1C)|((color>>8)&0xE0); }
    245          
    246          inline short rgb565toshort(short color){
    247            return color; }
    248          
    249          

   \                                 In segment DATA_Z, align 4, align-sorted
    250          int loadgraphsize=0;
   \                     loadgraphsize:
   \   00000000                      DS8 4
    251          #ifndef HIGHCOLOR
    252            const int graphpoints=1;
    253          #else  

   \                                 In segment DATA_C, align 4, align-sorted
    254            const int graphpoints=2;
   \                     graphpoints:
   \   00000000   02000000           DC32 2
    255          #endif
    256          // Формат файла 2б х 2б у  далее точки (повернуты как надо, без выравнивания)

   \                                 In segment CODE, align 4, keep-with-next
    257          char *loadgraph(char *filename){ // Загрузить графику (распаковываем и перекодируем) #define HIGHCOLOR учесть
   \                     loadgraph:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
    258            unsigned char *bmp=0, *buf=0, *pbuf, *pbmp, *ptr;
   \   00000008   0020A0E3           MOV      R2,#+0
   \   0000000C   04208DE5           STR      R2,[SP, #+4]
    259            int *pal;
    260            int sizex, sizey, bytepixel, pitch;
    261            int i,j;
    262            do{
    263              if(!(bmp=(unsigned char*)
    264          #ifndef NOLOAD
    265              loadfile(filename)
    266          #else
    267              filename
    268          #endif
    269              )) break;
   \   00000010   ........           BL       loadfile
   \   00000014   0050B0E1           MOVS     R5,R0
   \   00000018   CB00000A           BEQ      ??loadgraph_0
    270              if(getshort(bmp)!='MB') break;
   \   0000001C   ........           BL       getshort
   \   00000020   4210A0E3           MOV      R1,#+66
   \   00000024   4D1C81E3           ORR      R1,R1,#0x4D00
   \   00000028   010050E1           CMP      R0,R1
   \   0000002C   C000001A           BNE      ??loadgraph_1
    271              sizex=getint(bmp+18);
   \   00000030   120085E2           ADD      R0,R5,#+18
   \   00000034   ........           BL       getint
   \   00000038   0060A0E1           MOV      R6,R0
    272              sizey=getint(bmp+22);
   \   0000003C   160085E2           ADD      R0,R5,#+22
   \   00000040   ........           BL       getint
   \   00000044   0070A0E1           MOV      R7,R0
    273              bytepixel=getshort(bmp+28)>>3;
   \   00000048   1C0085E2           ADD      R0,R5,#+28
   \   0000004C   ........           BL       getshort
   \   00000050   C041A0E1           ASR      R4,R0,#+3
    274              if(!sizex || !sizey || bytepixel<1 || bytepixel>4) break;
   \   00000054   000056E3           CMP      R6,#+0
   \   00000058   00005713           CMPNE    R7,#+0
   \   0000005C   B400000A           BEQ      ??loadgraph_1
   \   00000060   010054E3           CMP      R4,#+1
   \   00000064   B20000BA           BLT      ??loadgraph_1
   \   00000068   050054E3           CMP      R4,#+5
   \   0000006C   B00000AA           BGE      ??loadgraph_1
    275              pitch=sizex*bytepixel;
   \   00000070   940601E0           MUL      R1,R4,R6
   \   00000074   00108DE5           STR      R1,[SP, #+0]
    276              if(pitch&3) pitch+=4-(pitch&3);
   \   00000078   0100A0E1           MOV      R0,R1
   \   0000007C   030010E3           TST      R0,#0x3
   \   00000080   0300000A           BEQ      ??loadgraph_2
   \   00000084   041081E2           ADD      R1,R1,#+4
   \   00000088   032000E2           AND      R2,R0,#0x3
   \   0000008C   021041E0           SUB      R1,R1,R2
   \   00000090   00108DE5           STR      R1,[SP, #+0]
    277              if(!(buf=(unsigned char*)malloc(loadgraphsize=sizex*sizey*graphpoints+4))) break;
   \                     ??loadgraph_2:
   \   00000094   970600E0           MUL      R0,R7,R6
   \   00000098   0410A0E3           MOV      R1,#+4
   \   0000009C   800081E0           ADD      R0,R1,R0, LSL #+1
   \   000000A0   AC129FE5           LDR      R1,??loadgraph_3  ;; loadgraphsize
   \   000000A4   000081E5           STR      R0,[R1, #+0]
   \   000000A8   140000EF           SWI      +20
   \   000000AC   04008DE5           STR      R0,[SP, #+4]
   \   000000B0   000050E3           CMP      R0,#+0
   \   000000B4   9E00000A           BEQ      ??loadgraph_1
    278              *(short*)buf=sizex; *(short*)(buf+2)=sizey; 
   \   000000B8   B060C0E1           STRH     R6,[R0, #+0]
   \   000000BC   04009DE5           LDR      R0,[SP, #+4]
   \   000000C0   B270C0E1           STRH     R7,[R0, #+2]
    279              pbuf=buf+4;
   \   000000C4   04009DE5           LDR      R0,[SP, #+4]
   \   000000C8   048080E2           ADD      R8,R0,#+4
    280              ptr=bmp+getint(bmp+10)+sizey*pitch;
   \   000000CC   00009DE5           LDR      R0,[SP, #+0]
   \   000000D0   90070AE0           MUL      R10,R0,R7
   \   000000D4   0A0085E2           ADD      R0,R5,#+10
   \   000000D8   ........           BL       getint
   \   000000DC   050080E0           ADD      R0,R0,R5
   \   000000E0   00908AE0           ADD      R9,R10,R0
   \   000000E4   014054E2           SUBS     R4,R4,#+1
   \   000000E8   0600000A           BEQ      ??loadgraph_4
   \   000000EC   014054E2           SUBS     R4,R4,#+1
   \   000000F0   3000000A           BEQ      ??loadgraph_5
   \   000000F4   014054E2           SUBS     R4,R4,#+1
   \   000000F8   4200000A           BEQ      ??loadgraph_6
   \   000000FC   014054E2           SUBS     R4,R4,#+1
   \   00000100   6000000A           BEQ      ??loadgraph_7
   \   00000104   0B0000EA           B        ??loadgraph_8
    281          #ifndef HIGHCOLOR //1 byte
    282              switch(bytepixel){
    283              case 1: //8 -> 8
    284                memcpy(pal=(int*)(bmp+52),bmp+54,*(short*)(bmp+50)?(*(short*)(bmp+50)<<2):1024);
    285              for(j=0;j<sizey;j++){
    286                pbmp=(ptr-=pitch);
    287                for(i=0;i<sizex;i++){
    288                  *pbuf++=rgb888tobyte(pal[*pbmp++]);
    289              }  } break;
    290              case 2: //16 bit
    291              for(j=0;j<sizey;j++){
    292                pbmp=(ptr-=pitch);
    293                for(i=0;i<sizex;i++){
    294                  *pbuf++=rgb565tobyte(*(short*)pbmp);
    295                  pbmp+=2;
    296              }  } break;
    297              case 3: //24 bit
    298              for(j=0;j<sizey;j++){
    299                pbmp=(ptr-=pitch);
    300                for(i=0;i<sizex;i++){
    301                  *pbuf++=rgb888tobyte(get3int(pbmp));
    302                  pbmp+=3;
    303              }  } break;
    304              case 4: //32 bit
    305              if((i=getint(bmp+10))&3){ //Выровнять данные на границу 4
    306                j=i-(i&3);
    307                memcpy(bmp+j, bmp+i, sizey*pitch);
    308                ptr=bmp+j+sizey*pitch;
    309              }
    310              for(j=0;j<sizey;j++){
    311                pbmp=(ptr-=pitch);
    312                for(i=0;i<sizex;i++){
    313                  *pbuf++=rgb888tobyte(*(int*)pbmp);
    314                  pbmp+=4;
    315              }  } break;
    316           #else    // 2 byte
    317              switch(bytepixel){
    318              case 1: //8 -> 16
    319              memcpy(pal=(int*)(bmp+52),bmp+54,*(short*)(bmp+50)?(*(short*)(bmp+50)<<2):1024);
   \                     ??loadgraph_4:
   \   00000108   F203D5E1           LDRSH    R0,[R5, #+50]
   \   0000010C   341085E2           ADD      R1,R5,#+52
   \   00000110   08108DE5           STR      R1,[SP, #+8]
   \   00000114   000050E3           CMP      R0,#+0
   \   00000118   0021A011           LSLNE    R2,R0,#+2
   \   0000011C   08009DE5           LDR      R0,[SP, #+8]
   \   00000120   402EA003           MOVEQ    R2,#+1024
   \   00000124   361085E2           ADD      R1,R5,#+54
   \   00000128   ........           _BLF     memcpy,??memcpy??rA
    320              for(j=0;j<sizey;j++){
   \   0000012C   00A0A0E3           MOV      R10,#+0
   \   00000130   010057E3           CMP      R7,#+1
   \   00000134   150000AA           BGE      ??loadgraph_9
    321                pbmp=(ptr-=pitch);
    322                for(i=0;i<sizex;i++){
    323                  *(short*)pbuf=rgb888toshort(pal[*pbmp++]);
    324                  pbuf+=2;
    325              }  } break;
    326              case 2: //16 bit
    327              for(j=0;j<sizey;j++){
    328                pbmp=(ptr-=pitch);
    329                for(i=0;i<sizex;i++){
    330                  *(short*)pbuf=rgb565toshort(*(short*)pbmp);
    331                  pbmp+=2;
    332                  pbuf+=2;
    333              }  } break;
    334              case 3: //24 bit
    335              for(j=0;j<sizey;j++){
    336                pbmp=(ptr-=pitch);
    337                for(i=0;i<sizex;i++){
    338                  *(short*)pbuf=rgb888toshort(get3int(pbmp));
    339                  pbmp+=3;
    340                  pbuf+=2;
    341              }  } break;
    342              case 4: //32 bit
    343              if((i=getint(bmp+10))&3){ //Выровнять данные на границу 4
    344                j=i-(i&3);
    345                memcpy(bmp+j, bmp+i, sizey*pitch);
    346                ptr=bmp+j+sizey*pitch;
    347              }
    348              for(j=0;j<sizey;j++){
    349                pbmp=(ptr-=pitch);
    350                for(i=0;i<sizex;i++){
    351                  *(short*)pbuf=rgb888toshort(*(int*)pbmp);
    352                  pbmp+=4;
    353                  pbuf+=2;
    354              }  } break;
    355          #endif    
    356              }
    357              mfree(bmp);
   \                     ??loadgraph_8:
   \   00000138   0500A0E1           MOV      R0,R5
   \   0000013C   150000EF           SWI      +21
    358              return (char*)buf;
   \   00000140   04009DE5           LDR      R0,[SP, #+4]
   \   00000144   FE8FBDE8           POP      {R1-R11,PC}
   \                     ??loadgraph_10:
   \   00000148   ........           LDRB     R0,[R11], #+1
   \   0000014C   08109DE5           LDR      R1,[SP, #+8]
   \   00000150   014084E2           ADD      R4,R4,#+1
   \   00000154   000191E7           LDR      R0,[R1, +R0, LSL #+2]
   \   00000158   C011A0E1           ASR      R1,R0,#+3
   \   0000015C   1F1001E2           AND      R1,R1,#0x1F
   \   00000160   C022A0E1           ASR      R2,R0,#+5
   \   00000164   7E2E02E2           AND      R2,R2,#0x7E0
   \   00000168   011082E1           ORR      R1,R2,R1
   \   0000016C   4004A0E1           ASR      R0,R0,#+8
   \   00000170   FF20E0E3           MVN      R2,#+255
   \   00000174   702EC2E3           BIC      R2,R2,#0x700
   \   00000178   000002E0           AND      R0,R2,R0
   \   0000017C   010080E1           ORR      R0,R0,R1
   \   00000180   ........           STRH     R0,[R8], #+2
   \                     ??loadgraph_11:
   \   00000184   060054E1           CMP      R4,R6
   \   00000188   EEFFFFBA           BLT      ??loadgraph_10
   \                     ??loadgraph_12:
   \   0000018C   01A08AE2           ADD      R10,R10,#+1
   \                     ??loadgraph_9:
   \   00000190   07005AE1           CMP      R10,R7
   \   00000194   E7FFFFAA           BGE      ??loadgraph_8
   \   00000198   00009DE5           LDR      R0,[SP, #+0]
   \   0000019C   0040A0E3           MOV      R4,#+0
   \   000001A0   000060E2           RSB      R0,R0,#+0
   \   000001A4   099080E0           ADD      R9,R0,R9
   \   000001A8   09B0A0E1           MOV      R11,R9
   \   000001AC   010056E3           CMP      R6,#+1
   \   000001B0   F3FFFFAA           BGE      ??loadgraph_11
   \   000001B4   F4FFFFEA           B        ??loadgraph_12
   \                     ??loadgraph_5:
   \   000001B8   00A0A0E3           MOV      R10,#+0
   \   000001BC   010057E3           CMP      R7,#+1
   \   000001C0   060000AA           BGE      ??loadgraph_13
   \   000001C4   DBFFFFEA           B        ??loadgraph_8
   \                     ??loadgraph_14:
   \   000001C8   ........           LDRSH    R0,[R11], #+2
   \   000001CC   014084E2           ADD      R4,R4,#+1
   \   000001D0   ........           STRH     R0,[R8], #+2
   \                     ??loadgraph_15:
   \   000001D4   060054E1           CMP      R4,R6
   \   000001D8   FAFFFFBA           BLT      ??loadgraph_14
   \                     ??loadgraph_16:
   \   000001DC   01A08AE2           ADD      R10,R10,#+1
   \                     ??loadgraph_13:
   \   000001E0   07005AE1           CMP      R10,R7
   \   000001E4   D3FFFFAA           BGE      ??loadgraph_8
   \   000001E8   00009DE5           LDR      R0,[SP, #+0]
   \   000001EC   0040A0E3           MOV      R4,#+0
   \   000001F0   000060E2           RSB      R0,R0,#+0
   \   000001F4   099080E0           ADD      R9,R0,R9
   \   000001F8   09B0A0E1           MOV      R11,R9
   \   000001FC   010056E3           CMP      R6,#+1
   \   00000200   F3FFFFAA           BGE      ??loadgraph_15
   \   00000204   F4FFFFEA           B        ??loadgraph_16
   \                     ??loadgraph_6:
   \   00000208   00A0A0E3           MOV      R10,#+0
   \   0000020C   010057E3           CMP      R7,#+1
   \   00000210   120000AA           BGE      ??loadgraph_17
   \   00000214   C7FFFFEA           B        ??loadgraph_8
   \                     ??loadgraph_18:
   \   00000218   0B00A0E1           MOV      R0,R11
   \   0000021C   ........           BL       get3int
   \   00000220   C011A0E1           ASR      R1,R0,#+3
   \   00000224   1F1001E2           AND      R1,R1,#0x1F
   \   00000228   C022A0E1           ASR      R2,R0,#+5
   \   0000022C   7E2E02E2           AND      R2,R2,#0x7E0
   \   00000230   011082E1           ORR      R1,R2,R1
   \   00000234   4004A0E1           ASR      R0,R0,#+8
   \   00000238   FF20E0E3           MVN      R2,#+255
   \   0000023C   702EC2E3           BIC      R2,R2,#0x700
   \   00000240   000002E0           AND      R0,R2,R0
   \   00000244   010080E1           ORR      R0,R0,R1
   \   00000248   ........           STRH     R0,[R8], #+2
   \   0000024C   03B08BE2           ADD      R11,R11,#+3
   \   00000250   014084E2           ADD      R4,R4,#+1
   \                     ??loadgraph_19:
   \   00000254   060054E1           CMP      R4,R6
   \   00000258   EEFFFFBA           BLT      ??loadgraph_18
   \                     ??loadgraph_20:
   \   0000025C   01A08AE2           ADD      R10,R10,#+1
   \                     ??loadgraph_17:
   \   00000260   07005AE1           CMP      R10,R7
   \   00000264   B3FFFFAA           BGE      ??loadgraph_8
   \   00000268   00009DE5           LDR      R0,[SP, #+0]
   \   0000026C   0040A0E3           MOV      R4,#+0
   \   00000270   000060E2           RSB      R0,R0,#+0
   \   00000274   099080E0           ADD      R9,R0,R9
   \   00000278   09B0A0E1           MOV      R11,R9
   \   0000027C   010056E3           CMP      R6,#+1
   \   00000280   F3FFFFAA           BGE      ??loadgraph_19
   \   00000284   F4FFFFEA           B        ??loadgraph_20
   \                     ??loadgraph_7:
   \   00000288   0A0085E2           ADD      R0,R5,#+10
   \   0000028C   ........           BL       getint
   \   00000290   0040A0E1           MOV      R4,R0
   \   00000294   030010E3           TST      R0,#0x3
   \   00000298   0700000A           BEQ      ??loadgraph_21
   \   0000029C   030004E2           AND      R0,R4,#0x3
   \   000002A0   009044E0           SUB      R9,R4,R0
   \   000002A4   0A20A0E1           MOV      R2,R10
   \   000002A8   051084E0           ADD      R1,R4,R5
   \   000002AC   050089E0           ADD      R0,R9,R5
   \   000002B0   ........           _BLF     memcpy,??memcpy??rA
   \   000002B4   050089E0           ADD      R0,R9,R5
   \   000002B8   00908AE0           ADD      R9,R10,R0
   \                     ??loadgraph_21:
   \   000002BC   00A0A0E3           MOV      R10,#+0
   \   000002C0   010057E3           CMP      R7,#+1
   \   000002C4   100000AA           BGE      ??loadgraph_22
   \   000002C8   9AFFFFEA           B        ??loadgraph_8
   \                     ??loadgraph_23:
   \   000002CC   ........           LDR      R0,[R11], #+4
   \   000002D0   014084E2           ADD      R4,R4,#+1
   \   000002D4   C011A0E1           ASR      R1,R0,#+3
   \   000002D8   1F1001E2           AND      R1,R1,#0x1F
   \   000002DC   C022A0E1           ASR      R2,R0,#+5
   \   000002E0   7E2E02E2           AND      R2,R2,#0x7E0
   \   000002E4   011082E1           ORR      R1,R2,R1
   \   000002E8   4004A0E1           ASR      R0,R0,#+8
   \   000002EC   FF20E0E3           MVN      R2,#+255
   \   000002F0   702EC2E3           BIC      R2,R2,#0x700
   \   000002F4   000002E0           AND      R0,R2,R0
   \   000002F8   010080E1           ORR      R0,R0,R1
   \   000002FC   ........           STRH     R0,[R8], #+2
   \                     ??loadgraph_24:
   \   00000300   060054E1           CMP      R4,R6
   \   00000304   F0FFFFBA           BLT      ??loadgraph_23
   \                     ??loadgraph_25:
   \   00000308   01A08AE2           ADD      R10,R10,#+1
   \                     ??loadgraph_22:
   \   0000030C   07005AE1           CMP      R10,R7
   \   00000310   88FFFFAA           BGE      ??loadgraph_8
   \   00000314   00009DE5           LDR      R0,[SP, #+0]
   \   00000318   0040A0E3           MOV      R4,#+0
   \   0000031C   000060E2           RSB      R0,R0,#+0
   \   00000320   099080E0           ADD      R9,R0,R9
   \   00000324   09B0A0E1           MOV      R11,R9
   \   00000328   010056E3           CMP      R6,#+1
   \   0000032C   F3FFFFAA           BGE      ??loadgraph_24
   \   00000330   F4FFFFEA           B        ??loadgraph_25
    359            }while(0);
    360            if(bmp) mfree(bmp);
   \                     ??loadgraph_1:
   \   00000334   0500A0E1           MOV      R0,R5
   \   00000338   150000EF           SWI      +21
    361            if(buf) mfree(buf);
   \   0000033C   04009DE5           LDR      R0,[SP, #+4]
   \   00000340   000050E3           CMP      R0,#+0
   \   00000344   FE8FBD08           POPEQ    {R1-R11,PC}
   \   00000348   150000EF           SWI      +21
    362            return 0;
   \                     ??loadgraph_0:
   \   0000034C   0000A0E3           MOV      R0,#+0
   \   00000350   FE8FBDE8           POP      {R1-R11,PC}      ;; return
   \                     ??loadgraph_3:
   \   00000354   ........           DC32     loadgraphsize
    363          }
    364          #endif
    365          
    366          // Вывести на экран в поз х,у картинку размером sizex,sizey с поз. в bmp х0,у0 и 
    367          // прозрачным цветом (если<>0)  Флаги: 0x40 = всегда

   \                                 In segment CODE, align 4, keep-with-next
    368          void bitblt(void *screen, void *bmp, int x, int y, int sizex, int sizey, int x0, int y0,  int colormask, int flags){
   \                     bitblt:
   \   00000000   F14F2DE9           PUSH     {R0,R4-R11,LR}
    369            int i,j, sizexx, bmpx, bmpy;
    370            // Проверка на дурака
    371            if(!screen || !bmp || x>=width || y>=height) return;
   \   00000004   00409DE5           LDR      R4,[SP, #+0]
   \   00000008   28009DE5           LDR      R0,[SP, #+40]
   \   0000000C   2C609DE5           LDR      R6,[SP, #+44]
   \   00000010   30909DE5           LDR      R9,[SP, #+48]
   \   00000014   34A09DE5           LDR      R10,[SP, #+52]
   \   00000018   38C09DE5           LDR      R12,[SP, #+56]
   \   0000001C   000054E3           CMP      R4,#+0
   \   00000020   00005113           CMPNE    R1,#+0
   \   00000024   F18FBD08           POPEQ    {R0,R4-R11,PC}
   \   00000028   78419FE5           LDR      R4,??bitblt_0    ;; width
   \   0000002C   008094E5           LDR      R8,[R4, #+0]
   \   00000030   080052E1           CMP      R2,R8
   \   00000034   F18FBDA8           POPGE    {R0,R4-R11,PC}
   \   00000038   6C519FE5           LDR      R5,??bitblt_0+0x4  ;; height
   \   0000003C   007095E5           LDR      R7,[R5, #+0]
   \   00000040   070053E1           CMP      R3,R7
   \   00000044   F18FBDA8           POPGE    {R0,R4-R11,PC}
    372            bmpx=*(short*)bmp; 
   \   00000048   F050D1E1           LDRSH    R5,[R1, #+0]
    373            bmpy=*(short*)((char*)bmp+2);
   \   0000004C   F2E0D1E1           LDRSH    LR,[R1, #+2]
    374            if(!sizex) sizex=bmpx;
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   0500A001           MOVEQ    R0,R5
    375            if(!sizey) sizey=bmpy;
   \   00000058   000056E3           CMP      R6,#+0
   \   0000005C   0E60A001           MOVEQ    R6,LR
    376            
    377            if(x<0){ sizex+=x; x0-=x; x=0;}
   \   00000060   000052E3           CMP      R2,#+0
   \   00000064   00008240           ADDMI    R0,R2,R0
   \   00000068   02904940           SUBMI    R9,R9,R2
   \   0000006C   0020A043           MOVMI    R2,#+0
    378            if(y<0){ sizey+=y0; y0-=y; y=0;}
   \   00000070   000053E3           CMP      R3,#+0
   \   00000074   06608A40           ADDMI    R6,R10,R6
   \   00000078   03A04A40           SUBMI    R10,R10,R3
   \   0000007C   0030A043           MOVMI    R3,#+0
    379            if(x0<0 || x0>=bmpx || y0<0 || y0>=bmpy || sizex<=0 || sizey<=0) return;
   \   00000080   000059E3           CMP      R9,#+0
   \   00000084   F18FBD48           POPMI    {R0,R4-R11,PC}
   \   00000088   050059E1           CMP      R9,R5
   \   0000008C   F18FBDA8           POPGE    {R0,R4-R11,PC}
   \   00000090   00005AE3           CMP      R10,#+0
   \   00000094   F18FBD48           POPMI    {R0,R4-R11,PC}
   \   00000098   0E005AE1           CMP      R10,LR
   \   0000009C   F18FBDA8           POPGE    {R0,R4-R11,PC}
   \   000000A0   010050E3           CMP      R0,#+1
   \   000000A4   010056A3           CMPGE    R6,#+1
   \   000000A8   F18FBDB8           POPLT    {R0,R4-R11,PC}
    380            
    381            if(x+sizex>=width) sizex=width-x;
   \   000000AC   02B080E0           ADD      R11,R0,R2
   \   000000B0   08005BE1           CMP      R11,R8
   \   000000B4   020048A0           SUBGE    R0,R8,R2
    382            if(x0+sizex>=bmpx) sizex=bmpx-x0;
   \   000000B8   09B080E0           ADD      R11,R0,R9
   \   000000BC   05005BE1           CMP      R11,R5
   \   000000C0   090045A0           SUBGE    R0,R5,R9
    383            if(y+sizey>=height) sizey=height-y;
   \   000000C4   03B086E0           ADD      R11,R6,R3
   \   000000C8   07005BE1           CMP      R11,R7
   \   000000CC   036047A0           SUBGE    R6,R7,R3
    384            if(y0+sizey>=bmpy) sizey=bmpy-y0;
    385            
    386          #ifndef HIGHCOLOR
    387            char *scr=(char*)screen, *pic=(char*)bmp+4;
    388            sizexx=sizex;
    389          #else
    390            short *scr=(short*)screen, *pic=(short*)((char*)bmp+4);
    391            sizexx=sizex<<1;
    392          #endif
    393            scr+=width*y+x;
   \   000000D0   932822E0           MLA      R2,R3,R8,R2
   \   000000D4   00309DE5           LDR      R3,[SP, #+0]
   \   000000D8   0A7086E0           ADD      R7,R6,R10
   \   000000DC   828083E0           ADD      R8,R3,R2, LSL #+1
    394            pic+=bmpx*y0 + x0;
   \   000000E0   9A9522E0           MLA      R2,R10,R5,R9
   \   000000E4   0E0057E1           CMP      R7,LR
   \   000000E8   0A604EA0           SUBGE    R6,LR,R10
   \   000000EC   041081E2           ADD      R1,R1,#+4
   \   000000F0   829081E0           ADD      R9,R1,R2, LSL #+1
    395            if(colormask || (flags&0x40)){
   \   000000F4   00005CE3           CMP      R12,#+0
   \   000000F8   3C109D05           LDREQ    R1,[SP, #+60]
   \   000000FC   8070A0E1           LSL      R7,R0,#+1
   \   00000100   40001103           TSTEQ    R1,#0x40
   \   00000104   1800000A           BEQ      ??bitblt_1
    396              for(j=0; j<sizey; j++, scr+=width-sizex, pic+=bmpx-sizex)
   \   00000108   00A0A0E3           MOV      R10,#+0
   \   0000010C   010056E3           CMP      R6,#+1
   \   00000110   0F0000AA           BGE      ??bitblt_2
   \   00000114   F18FBDE8           POP      {R0,R4-R11,PC}
    397                for(i=0; i<sizex; i++, scr++, pic++)
    398                  if(*pic!=
    399          #ifndef HIGHCOLOR
    400            (char)
    401          #else
    402           (short)             
    403          #endif
    404             colormask) *scr=*pic;
   \                     ??bitblt_3:
   \   00000118   F010D9E1           LDRSH    R1,[R9, #+0]
   \   0000011C   0C38A0E1           MOV      R3,R12, LSL #+16
   \   00000120   012082E2           ADD      R2,R2,#+1
   \   00000124   430851E1           CMP      R1,R3, ASR #+16
   \   00000128   B010C811           STRHNE   R1,[R8, #+0]
   \   0000012C   028088E2           ADD      R8,R8,#+2
   \   00000130   029089E2           ADD      R9,R9,#+2
   \                     ??bitblt_4:
   \   00000134   000052E1           CMP      R2,R0
   \   00000138   F6FFFFBA           BLT      ??bitblt_3
   \                     ??bitblt_5:
   \   0000013C   001094E5           LDR      R1,[R4, #+0]
   \   00000140   01A08AE2           ADD      R10,R10,#+1
   \   00000144   001041E0           SUB      R1,R1,R0
   \   00000148   818088E0           ADD      R8,R8,R1, LSL #+1
   \   0000014C   001045E0           SUB      R1,R5,R0
   \   00000150   819089E0           ADD      R9,R9,R1, LSL #+1
   \                     ??bitblt_2:
   \   00000154   06005AE1           CMP      R10,R6
   \   00000158   F18FBDA8           POPGE    {R0,R4-R11,PC}
   \   0000015C   0020A0E3           MOV      R2,#+0
   \   00000160   010050E3           CMP      R0,#+1
   \   00000164   F2FFFFAA           BGE      ??bitblt_4
   \   00000168   F3FFFFEA           B        ??bitblt_5
    405            }else{
    406              for(j=0; j<sizey; j++, scr+=width, pic+=bmpx)
   \                     ??bitblt_1:
   \   0000016C   00A0A0E3           MOV      R10,#+0
   \   00000170   010056E3           CMP      R6,#+1
   \   00000174   080000AA           BGE      ??bitblt_6
   \   00000178   F18FBDE8           POP      {R0,R4-R11,PC}
    407                memcpy(scr,pic,sizexx);
   \                     ??bitblt_7:
   \   0000017C   0720A0E1           MOV      R2,R7
   \   00000180   0910A0E1           MOV      R1,R9
   \   00000184   0800A0E1           MOV      R0,R8
   \   00000188   ........           _BLF     memcpy,??memcpy??rA
   \   0000018C   000094E5           LDR      R0,[R4, #+0]
   \   00000190   01A08AE2           ADD      R10,R10,#+1
   \   00000194   808088E0           ADD      R8,R8,R0, LSL #+1
   \   00000198   859089E0           ADD      R9,R9,R5, LSL #+1
   \                     ??bitblt_6:
   \   0000019C   06005AE1           CMP      R10,R6
   \   000001A0   F5FFFFBA           BLT      ??bitblt_7
   \   000001A4   F18FBDE8           POP      {R0,R4-R11,PC}   ;; return
   \                     ??bitblt_0:
   \   000001A8   ........           DC32     width
   \   000001AC   ........           DC32     height
    408            }
    409          }
    410          
    411          
    412          //void debsave();
    413          //char debarea[10000], *deb=debarea;
    414          ////unsigned int err;
    415          //
    416          //void debsave(){
    417          //  int f;
    418          //  if(deb==debarea) return;
    419          //  f=fopen("0:\\ZBin\\nes\\log",A_ReadWrite+A_BIN+A_Create+A_Append,P_READ+P_WRITE,&err);
    420          //  if (f==-1) return;
    421          //  fwrite32(f,(unsigned char*)debarea,deb-debarea,&err);
    422          //  fclose(f,&err);
    423          //  deb=debarea;
    424          //}
    425          //
    426          //void debug(int num, int val){
    427          //  if(deb-debarea<9800){
    428          //  sprintf(deb,"\n%d = %d",num,val);
    429          //  deb+=strlen(deb);
    430          //  }
    431          //}
    432          
    433          //    void memcpy3(signed char *to, signed char *from, int size){
    434          //      to+=size;
    435          //      from+=size;
    436          //      while(--size>=0){
    437          //        *--to=*--from;
    438          //      }
    439          //    }
    440          //
    441          //    void memcpy4(signed char *to, signed char *from, int size){
    442          //      while(--size>=0){
    443          //        *to++=*from++;
    444          //      }
    445          //    }
    446              
    447          //    void memmove(signed char *to, signed char *from, int size){
    448          //      if(from<to)
    449          //        if(from+size>=to) memcpy3(to,from,size);
    450          //        else memcpy4(to,from,size);
    451          //      else memcpy4(to,from,size);
    452          //    }
    453          
    454          #ifndef DOS

   \                                 In segment CODE, align 4, keep-with-next
    455              void *memmove(void *to, void *from, int size){
    456                if((char*)from<(char*)to && (char*)from+size>=(char*)to) return memmov(to,from,size); //memcpyrev
   \                     memmove:
   \   00000000   000051E1           CMP      R1,R0
   \   00000004   0300002A           BCS      ??memmove_0
   \   00000008   01C082E0           ADD      R12,R2,R1
   \   0000000C   00005CE1           CMP      R12,R0
   \   00000010   0000003A           BCC      ??memmove_0
   \   00000014   ........           _BF      memmov,??memmov??rA  ;; tailcall
    457                return memcpy(to,from,size);
   \                     ??memmove_0:
   \   00000018   ........           _BF      memcpy,??memcpy??rA  ;; tailcall
    458              }
    459          #endif
    460          
    461          //char *strcpy2(char *to, char *from){
    462          //  char *res=to--;
    463          //  do{ *++to=*from++;
    464          //  }while(*to);
    465          //  return res;
    466          //}
    467          //
    468          //char *strcat2(char *to, char *from){
    469          //  char *res=to--;
    470          //  while(*++to); --to;
    471          //  do{ *++to=*from++;
    472          //  }while(*to);
    473          //  return res;
    474          //}

   Maximum stack usage in bytes:

     Function   CSTACK
     --------   ------
     abs            0
     alltrim        0
     bitblt        40
     emptystr       0
     fgets          0
     get3int        0
     getint         0
     getshort       0
     isalth         0
     isval          0
     loadfile      28
     loadgraph     48
     max            0
     memmove        4
     min            0
     printf         0
     putint         0
     putshort       0
     savefile      20
     strchrpos      8
     strcmpsize     4
     strdup         0
     todown         0
     toup           0


   Segment part sizes:

     Function/Label Bytes
     -------------- -----
     err               4
     loadfilesize      4
     min              12
     max              12
     abs              12
     fgets             8
     printf           12
     strdup            4
     savefile         96
     loadfile        248
     toup            108
     todown          112
     isalth           64
     isval            28
     strchrpos        28
     emptystr         52
     alltrim         104
     strcmpsize       68
     getint           48
     get3int          24
     getshort         40
     putint           48
     putshort         32
     loadgraphsize     4
     graphpoints       4
     loadgraph       856
     bitblt          432
     memmove          28
      Others         156

 
 2 620 bytes in segment CODE
     4 bytes in segment DATA_C
    12 bytes in segment DATA_Z
    12 bytes in segment INITTAB
 
 2 476 bytes of CODE  memory (+ 156 bytes shared)
     4 bytes of CONST memory
    12 bytes of DATA  memory

Errors: none
Warnings: none
