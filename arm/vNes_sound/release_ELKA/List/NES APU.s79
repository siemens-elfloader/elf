//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION   09/Dec/2010  18:20:56 /
// Copyright 1999-2005 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Cpu mode        =  interwork                                           /
//    Endian          =  little                                              /
//    Stack alignment =  4                                                   /
//    Source file     =  C:\arm\vNes_sound\snd\NES APU.C                     /
//    Command line    =  "C:\arm\vNes_sound\snd\NES APU.C" -D NDEBUG -D      /
//                       NEWSGOLD -D ELKA -lCN C:\arm\vNes_sound\release_ELK /
//                       A\List\ -lA C:\arm\vNes_sound\release_ELKA\List\    /
//                       -o C:\arm\vNes_sound\release_ELKA\Obj\ -s9          /
//                       --cpu_mode arm --endian little --cpu ARM926EJ-S     /
//                       --stack_align 4 --interwork -e --fpu None           /
//                       --dlib_config "C:\arm2\Embedded Workbench 4.0       /
//                       Evaluation\ARM\LIB\dl5tpainl8f.h" -I                /
//                       "C:\arm2\Embedded Workbench 4.0                     /
//                       Evaluation\ARM\INC\" --inline_threshold=2           /
//    List file       =  C:\arm\vNes_sound\release_ELKA\List\NES APU.s79     /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME `NES APU`

        RTMODEL "StackAlign4", "USED"
        RTMODEL "__cpu_mode", "__pcs__interwork"
        RTMODEL "__data_model", "absolute"
        RTMODEL "__endian", "little"
        RTMODEL "__rt_version", "6"

        RSEG CSTACK:DATA:NOROOT(2)

        PUBWEAK `?*?DATA_ID`
        MULTWEAK ??APUWrite??rT
??DataTable0 EQU 0
??DataTable1 EQU 0
??DataTable2 EQU 0
??DataTable3 EQU 0
??DataTable4 EQU 0
??DataTable6 EQU 0
        MULTWEAK ??EnvLinC??rT
        MULTWEAK ??GetSound??rT
        MULTWEAK ??LenSweepC??rT
        MULTWEAK ??NSF_Init??rT
        MULTWEAK ??randint??rT
        PUBWEAK ?init?tab?DATA_I
        PUBWEAK ?init?tab?DATA_Z
        PUBLIC APUWrite
        FUNCTION APUWrite,0203H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC EnvLinC
        FUNCTION EnvLinC,0201H
        PUBLIC GetSound
        FUNCTION GetSound,0201H
        LOCFRAME CSTACK, 44, STACK
        PUBLIC LenSweepC
        FUNCTION LenSweepC,0201H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC MainClock
        PUBLIC NSF_HDR
        PUBLIC NSF_Init
        FUNCTION NSF_Init,0201H
        PUBLIC addrmask
        PUBLIC daccounter
        PUBLIC dmcbuffer
        PUBLIC dmcbuffercount
        PUBLIC dmcdatalen
        PUBLIC dmcdevider
        PUBLIC dmcdmaadr
        PUBLIC dmcperiod
        PUBLIC dmcsilence
        PUBLIC frameseqcount
        PUBLIC framesequence
        PUBLIC lastvalue
        PUBLIC lengthtable
        PUBLIC noisedevider
        PUBLIC noiseenvdiv
        PUBLIC noiseenvelope
        PUBLIC noiselencounter
        PUBLIC noiseoutput
        PUBLIC noiseperiod
        PUBLIC noisevolume
        PUBLIC randint
        FUNCTION randint,0203H
        PUBLIC randseed
        PUBLIC sq1sweepperiod
        PUBLIC sq2sweepperiod
        PUBLIC square1devider
        PUBLIC square1envdiv
        PUBLIC square1envelope
        PUBLIC square1lencounter
        PUBLIC square1period
        PUBLIC square1seqpos
        PUBLIC square1sweep
        PUBLIC square1volume
        PUBLIC square2devider
        PUBLIC square2envdiv
        PUBLIC square2envelope
        PUBLIC square2lencounter
        PUBLIC square2period
        PUBLIC square2seqpos
        PUBLIC square2sweep
        PUBLIC square2volume
        PUBLIC squarewave
        PUBLIC sw1d
        PUBLIC sw2d
        PUBLIC sweep1negative
        PUBLIC sweep1shift
        PUBLIC sweep2negative
        PUBLIC sweep2shift
        PUBLIC triabglelinearcounter
        PUBLIC triangledevider
        PUBLIC trianglelencounter
        PUBLIC triangleperiod
        PUBLIC triangleseqpos
        PUBLIC trianglevolume
        PUBLIC trianglewave
        PUBLIC twhaltflag
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 HUGEDATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, CPSR:32, R13:32
        CFI Resource R14:32, SPSR:32
        CFI VirtualResource ?RET:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon0
        
        
        CFI Common cfiCommon1 Using cfiNames0
        CFI CodeAlign 4
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon1
        
APUWrite            SYMBOL "APUWrite"
??APUWrite??rT      SYMBOL "??rT", APUWrite
EnvLinC             SYMBOL "EnvLinC"
??EnvLinC??rT       SYMBOL "??rT", EnvLinC
GetSound            SYMBOL "GetSound"
??GetSound??rT      SYMBOL "??rT", GetSound
LenSweepC           SYMBOL "LenSweepC"
??LenSweepC??rT     SYMBOL "??rT", LenSweepC
NSF_Init            SYMBOL "NSF_Init"
??NSF_Init??rT      SYMBOL "??rT", NSF_Init
randint             SYMBOL "randint"
??randint??rT       SYMBOL "??rT", randint

        EXTERN PSG
        EXTERN samplerate

// C:\arm\vNes_sound\snd\NES APU.C
//    1 
//    2 typedef struct
//    3 {
//    4   signed char NESM[6];
//    5   unsigned char tsongs, csong;
//    6   unsigned short load, init, play;
//    7   signed char SongName[32];
//    8   signed char Artist[32];
//    9   signed char Copyright[32];
//   10   unsigned short speednoisedevidersc;
//   11   unsigned char BankSwitch[8];
//   12   unsigned short speedpal;
//   13   unsigned char PNBits, extra, al1, al2, al3, al4;
//   14 }
//   15 NSFHDR;
//   16 
//   17 //unsigned short speed;
//   18 
//   19 //#define byte unsigned char
//   20 extern unsigned char PSG[25];
//   21 
//   22 extern int samplerate;

        RSEG DATA_I:DATA:SORT:NOROOT(1)
//   23 unsigned short addrmask = 0xFFFF;
addrmask:
        DS8 2
        REQUIRE `?<Initializer for addrmask>`

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   24 NSFHDR NSF_HDR;
NSF_HDR:
        DS8 128
//   25 typedef  unsigned short WORD;
//   26 typedef unsigned char BYTE;
//   27 
//   28 
//   29 signed long square1devider, square2devider, triangledevider, noisedevider;
//   30 unsigned char square1seqpos, square2seqpos, triangleseqpos;
//   31 unsigned long square1volume, square2volume, trianglevolume, noisevolume;
//   32 signed long square1period, square2period, triangleperiod, square1lencounter, square2lencounter,
//   33      trianglelencounter, noiselencounter;
//   34 unsigned char sw1d, sw2d;
//   35 unsigned long noiseoutput;

        RSEG DATA_Z:DATA:SORT:NOROOT(1)
//   36 signed short dmcdevider;
dmcdevider:
        DS8 2
//   37 unsigned char daccounter;

        RSEG DATA_Z:DATA:SORT:NOROOT(0)
//   38 unsigned char dmcbuffer, dmcbuffercount, dmcsilence;
dmcbuffer:
        DS8 1

        RSEG DATA_Z:DATA:SORT:NOROOT(0)
dmcbuffercount:
        DS8 1

        RSEG DATA_Z:DATA:SORT:NOROOT(0)
dmcsilence:
        DS8 1
//   39 signed long dmcdmaadr, dmcdatalen;
//   40 signed char noiseenvelope, noiseenvdiv;
//   41 signed char square1envelope, square1envdiv;
//   42 signed char square2envelope, square2envdiv;
//   43 unsigned char triabglelinearcounter, twhaltflag;

        RSEG DATA_Z:DATA:SORT:NOROOT(1)
//   44 unsigned short MainClock;
MainClock:
        DS8 2

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   45 unsigned long randseed;
randseed:
        DS8 4
//   46 short frameseqcount, framesequence;

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   47 int lastvalue;
lastvalue:
        DS8 4
//   48 signed char square1sweep, sweep1shift, sweep1negative, sq1sweepperiod;
//   49 signed char square2sweep, sweep2shift, sweep2negative, sq2sweepperiod;
//   50 unsigned char trianglewave[32] =
//   51 {
//   52   0xF, 0xE, 0xD, 0xC, 0xB, 0xA, 0x9, 0x8, 0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1, 0x0, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8,
//   53        0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF
//   54 };
//   55 

        RSEG DATA_C:CONST:SORT:NOROOT(2)
//   56 const signed char squarewave[4] [8] =
squarewave:
        DATA
        DC8 -1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, -1, -1, -1, -1, -1, -1, 1
        DC8 1, 1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1
//   57 {
//   58   -1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1
//   59 };
//   60 

        RSEG DATA_C:CONST:SORT:NOROOT(2)
//   61 const short dmcperiod[16] =
dmcperiod:
        DATA
        DC16 428, 380, 340, 320, 286, 254, 226, 214, 190, 160, 142, 128, 106
        DC16 84, 72, 54

        RSEG DATA_I:DATA:SORT:NOROOT(2)
frameseqcount:
        DS8 2
        REQUIRE `?<Initializer for frameseqcount>`
framesequence:
        DS8 2
        REQUIRE `?<Initializer for framesequence>`
//   62 {
//   63   0x1AC, 0x17C, 0x154, 0x140, 0x11E, 0x0FE, 0x0E2, 0x0D6, 0x0BE, 0x0A0, 0x08E, 0x080, 0x06A, 0x054, 0x048, 0x036
//   64 };
//   65 
//   66 unsigned short noiseperiod[16] =
noiseperiod:
        DS8 32
        REQUIRE `?<Initializer for noiseperiod>`
square1devider:
        DS8 4
        REQUIRE `?<Initializer for square1devider>`
square2devider:
        DS8 4
        REQUIRE `?<Initializer for square2devider>`
triangledevider:
        DS8 4
        REQUIRE `?<Initializer for triangledevider>`
noisedevider:
        DS8 4
        REQUIRE `?<Initializer for noisedevider>`
square1volume:
        DS8 4
        REQUIRE `?<Initializer for square1volume>`
square2volume:
        DS8 4
        REQUIRE `?<Initializer for square2volume>`
trianglevolume:
        DS8 4
        REQUIRE `?<Initializer for trianglevolume>`
noisevolume:
        DS8 4
        REQUIRE `?<Initializer for noisevolume>`
square1period:
        DS8 4
        REQUIRE `?<Initializer for square1period>`
square2period:
        DS8 4
        REQUIRE `?<Initializer for square2period>`
triangleperiod:
        DS8 4
        REQUIRE `?<Initializer for triangleperiod>`
square1lencounter:
        DS8 4
        REQUIRE `?<Initializer for square1lencounter>`
square2lencounter:
        DS8 4
        REQUIRE `?<Initializer for square2lencounter>`
trianglelencounter:
        DS8 4
        REQUIRE `?<Initializer for trianglelencounter>`
noiselencounter:
        DS8 4
        REQUIRE `?<Initializer for noiselencounter>`
noiseoutput:
        DS8 4
        REQUIRE `?<Initializer for noiseoutput>`
dmcdmaadr:
        DS8 4
        REQUIRE `?<Initializer for dmcdmaadr>`
dmcdatalen:
        DS8 4
        REQUIRE `?<Initializer for dmcdatalen>`
square1seqpos:
        DS8 1
        REQUIRE `?<Initializer for square1seqpos>`
square2seqpos:
        DS8 1
        REQUIRE `?<Initializer for square2seqpos>`
triangleseqpos:
        DS8 1
        REQUIRE `?<Initializer for triangleseqpos>`
sw1d:
        DS8 1
        REQUIRE `?<Initializer for sw1d>`
sw2d:
        DS8 1
        REQUIRE `?<Initializer for sw2d>`
daccounter:
        DS8 1
        REQUIRE `?<Initializer for daccounter>`
noiseenvelope:
        DS8 1
        REQUIRE `?<Initializer for noiseenvelope>`
noiseenvdiv:
        DS8 1
        REQUIRE `?<Initializer for noiseenvdiv>`
square1envelope:
        DS8 1
        REQUIRE `?<Initializer for square1envelope>`
square1envdiv:
        DS8 1
        REQUIRE `?<Initializer for square1envdiv>`
square2envelope:
        DS8 1
        REQUIRE `?<Initializer for square2envelope>`
square2envdiv:
        DS8 1
        REQUIRE `?<Initializer for square2envdiv>`
triabglelinearcounter:
        DS8 1
        REQUIRE `?<Initializer for triabglelinearcounter>`
twhaltflag:
        DS8 1
        REQUIRE `?<Initializer for twhaltflag>`
square1sweep:
        DS8 1
        REQUIRE `?<Initializer for square1sweep>`
sweep1shift:
        DS8 1
        REQUIRE `?<Initializer for sweep1shift>`
sweep1negative:
        DS8 1
        REQUIRE `?<Initializer for sweep1negative>`
sq1sweepperiod:
        DS8 1
        REQUIRE `?<Initializer for sq1sweepperiod>`
square2sweep:
        DS8 1
        REQUIRE `?<Initializer for square2sweep>`
sweep2shift:
        DS8 1
        REQUIRE `?<Initializer for sweep2shift>`
sweep2negative:
        DS8 1
        REQUIRE `?<Initializer for sweep2negative>`
sq2sweepperiod:
        DS8 1
        REQUIRE `?<Initializer for sq2sweepperiod>`
        DS8 2
trianglewave:
        DS8 32
        REQUIRE `?<Initializer for trianglewave>`
//   67 {
//   68   4, 8, 16, 32, 64, 96, 128, 160, 202, 254, 380, 508, 762, 1016, 2034, 4068
//   69 };
//   70 
//   71 
//   72 unsigned char lengthtable[32] =
lengthtable:
        DS8 32
        REQUIRE `?<Initializer for lengthtable>`

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI NoFunction
        THUMB
??randint??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock0
        REQUIRE randint
//   73 {
//   74   5, 127, 10, 1, 19, 2, 40, 3, 80, 4, 30, 5, 7, 6, 13, 7, 6, 8, 12, 9, 24, 10, 48, 11, 96, 12, 36, 13, 8, 14, 16, 15
//   75 };
//   76 
//   77 
//   78 
//   79 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock1 Using cfiCommon1
        CFI Function randint
        ARM
//   80 unsigned short randint( long max )
//   81 {
//   82   randseed = randseed * 0x08088405;
//   83   randseed++;
randint:
        LDR      R1,??randint_0   ;; randseed
        LDR      R3,??randint_0+0x4  ;; 0x8088405
        LDR      R2,[R1, #+0]
        MUL      R2,R3,R2
        ADD      R2,R2,#+1
        STR      R2,[R1, #+0]
//   84   return ( ( randseed >> 16 ) * max ) >> 16;
        LSR      R1,R2,#+16
        MUL      R1,R0,R1
        LSR      R0,R1,#+16
        BX       LR               ;; return
        DATA
??randint_0:
        DC32     randseed
        DC32     0x8088405
        CFI EndBlock cfiBlock1
//   85 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock2 Using cfiCommon0
        CFI NoFunction
        THUMB
??NSF_Init??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock2
        REQUIRE NSF_Init
//   86 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock3 Using cfiCommon1
        CFI Function NSF_Init
        ARM
//   87 void NSF_Init()
//   88 {
//   89   daccounter = 64;
NSF_Init:
        LDR      R0,??DataTable5  ;; frameseqcount
        MOV      R1,#+64
        STRB     R1,[R0, #+113]
//   90   trianglevolume = 16;
        MOV      R1,#+16
        STR      R1,[R0, #+60]
//   91  }
        BX       LR               ;; return
        CFI EndBlock cfiBlock3

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock4 Using cfiCommon0
        CFI NoFunction
        THUMB
??APUWrite??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock4
        REQUIRE APUWrite
//   92 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock5 Using cfiCommon1
        CFI Function APUWrite
        ARM
//   93  void APUWrite( unsigned short address, unsigned char data )
//   94 {
//   95   PSG[address-0x4000]=data;
APUWrite:
        LDR      R2,??DataTable8  ;; PSG
        PUSH     {R4,R5}
        CFI R5 Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
        ADD      R3,R0,R2
        SUB      R3,R3,#+16384
        STRB     R1,[R3, #+0]
//   96   //*((unsigned short*)0xA8400000)=address;
//   97   switch ( address )
        LDR      R1,??DataTable7  ;; frameseqcount
        MOV      R3,#+0
        MOV      R12,#+15
        SUB      R0,R0,#+16384
        CMP      R0,#+23
        BHI      ??APUWrite_1
        ADR      R4,??APUWrite_0
        LDRB     R4,[R4, R0]
        ADD      PC,PC,R4, LSL #+2
        DATA
??APUWrite_0:
        DC8      +5,+11,+22,+28
        DC8      +43,+49,+59,+65
        DC8      +80,+20,+89,+95
        DC8      +103,+20,+107,+109
        DC8      +20,+119,+123,+128
        DC8      +20,+20,+20,+133
        ARM
//   98   {
//   99     //Square1
//  100     //ddle nnnn   duty, loop enoisevolume/disable length, enoisevolume disable, vol/enoisevolume
//  101     case 0x4000:
//  102       sw1d = PSG[0x00] >> 6;
??APUWrite_2:
        LDRB     R0,[R2, #+0]
        LSR      R2,R0,#+6
        STRB     R2,[R1, #+111]
//  103       square1volume = PSG[0x00] & 0x0F;
        AND      R0,R0,#0xF
        STR      R0,[R1, #+52]
        B        ??APUWrite_1
//  104       //if(PSG[0x00]&32)PSG[0x15]=PSG[0x15]&254;else
//  105       //     PSG[0x15]=PSG[0x15]|1;
//  106     break;
//  107       //eppp nsss   enable sweep, period, negative, shift
//  108     case 0x4001:
//  109       square1sweep = ( PSG[0x01] >> 4 ) & 7;
??APUWrite_3:
        LDRB     R0,[R2, #+1]
        MOV      R2,#+7
        AND      R2,R2,R0, LSR #+4
        STRB     R2,[R1, #+122]
//  110       sweep1shift = PSG[0x01] & 7;
        AND      R3,R0,#0x7
        STRB     R3,[R1, #+123]
//  111       sweep1negative = PSG[0x01] & 8;
        AND      R0,R0,#0x8
        STRB     R0,[R1, #+124]
//  112       sq1sweepperiod = ( PSG[0x01] >> 4 ) & 7;
        STRB     R2,[R1, #+125]
??APUWrite_1:
        POP      {R4,R5}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI CFA R13+0
        BX       LR
        CFI R4 Frame(CFA, -8)
        CFI R5 Frame(CFA, -4)
        CFI CFA R13+8
//  113     break;
//  114       //pppp pppp   period low
//  115     case 0x4002:
//  116       square1period = ( PSG[0x02] + ( ( PSG[0x03] & 7 ) << 8 ) );
??APUWrite_4:
        LDRB     R0,[R2, #+2]
        LDRB     R2,[R2, #+3]
        AND      R2,R2,#0x7
        ADD      R0,R0,R2, LSL #+8
        STR      R0,[R1, #+68]
        B        ??APUWrite_1
??APUWrite_5:
        LDRB     R0,[R2, #+3]
        LDRB     R4,[R2, #+2]
        AND      R5,R0,#0x7
        ADD      R4,R4,R5, LSL #+8
        STR      R4,[R1, #+68]
//  117     break;
//  118       //llll lppp length index, period high
//  119     case 0x4003:
//  120       square1period = ( PSG[0x02] + ( ( PSG[0x03] & 7 ) << 8 ) );
//  121       square1lencounter = lengthtable[PSG[0x03] >> 3];
        ADD      R0,R1,R0, ASR #+3
        LDRB     R0,[R0, #+164]
//  122       square1devider = 0;
        STR      R3,[R1, #+36]
//  123       square1envelope = 15;
        STRB     R12,[R1, #+116]
        STR      R0,[R1, #+80]
//  124       square1envdiv = ( PSG[0x00] & 15 ) + 1;
        LDRSB    R0,[R2, #+0]
        AND      R0,R0,#0xF
        ADD      R0,R0,#+1
        STRB     R0,[R1, #+117]
        B        ??APUWrite_1
//  125     break;
//  126       //Square2
//  127       //ddle nnnn   duty, loop enoisevolume/disable length, enoisevolume disable, vol/enoisevolume
//  128     case 0x4004:
//  129       sw2d = PSG[0x04] >> 6;
??APUWrite_6:
        LDRB     R0,[R2, #+4]
        LSR      R2,R0,#+6
        STRB     R2,[R1, #+112]
//  130       square2volume = PSG[0x04] & 0x0F;
        AND      R0,R0,#0xF
        STR      R0,[R1, #+56]
        B        ??APUWrite_1
//  131       // if(PSG[0x04]&32)PSG[0x15]=PSG[0x15]&253;else
//  132       //      PSG[0x15]=PSG[0x15]|2;
//  133     break;
//  134       //eppp nsss   enable sweep, period, negative, shift
//  135     case 0x4005:
//  136       square2sweep = ( PSG[0x05] >> 4 ) & 7;
??APUWrite_7:
        LDRB     R0,[R2, #+5]
        MOV      R2,#+7
        AND      R2,R2,R0, LSR #+4
        STRB     R2,[R1, #+126]
//  137       sweep2shift = PSG[0x05] & 7;
        AND      R3,R0,#0x7
        STRB     R3,[R1, #+127]
//  138       sweep2negative = PSG[0x05] & 8;
        AND      R0,R0,#0x8
        STRB     R0,[R1, #+128]
//  139       sq2sweepperiod = ( PSG[0x05] >> 4 ) & 7;
        STRB     R2,[R1, #+129]
        B        ??APUWrite_1
//  140     break;
//  141       //pppp pppp   period low
//  142     case 0x4006:
//  143       square2period = ( PSG[0x06] + ( ( PSG[0x07] & 7 ) << 8 ) );
??APUWrite_8:
        LDRB     R0,[R2, #+6]
        LDRB     R2,[R2, #+7]
        AND      R2,R2,#0x7
        ADD      R0,R0,R2, LSL #+8
        STR      R0,[R1, #+72]
        B        ??APUWrite_1
??APUWrite_9:
        LDRB     R0,[R2, #+7]
        LDRB     R4,[R2, #+6]
        AND      R5,R0,#0x7
        ADD      R4,R4,R5, LSL #+8
        STR      R4,[R1, #+72]
//  144     break;
//  145       //llll lppp length index, period high
//  146     case 0x4007:
//  147       square2period = ( PSG[0x06] + ( ( PSG[0x07] & 7 ) << 8 ) );
//  148       square2lencounter = lengthtable[PSG[0x07] >> 3];
        ADD      R0,R1,R0, ASR #+3
        LDRB     R0,[R0, #+164]
//  149       square2devider = 0;
        STR      R3,[R1, #+40]
//  150       square2envelope = 15;
        STRB     R12,[R1, #+118]
        STR      R0,[R1, #+84]
//  151       square2envdiv = ( PSG[0x04] & 15 ) + 1;
        LDRSB    R0,[R2, #+4]
        AND      R0,R0,#0xF
        ADD      R0,R0,#+1
        STRB     R0,[R1, #+119]
        B        ??APUWrite_1
//  152 
//  153     break;
//  154       //Triangle
//  155       //clll llll   conoisedeviderrol, linear counoisedeviderer load
//  156     case 0x4008:
//  157       if ( ( PSG[0x08] & 128 ) > 0 ) trianglelencounter = lengthtable[PSG[0x0B] >> 3];
??APUWrite_10:
        LDRB     R0,[R2, #+8]
        AND      R0,R0,#0x80
        CMP      R0,#+1
        BLT      ??APUWrite_1
        LDRB     R0,[R2, #+11]
        ADD      R0,R1,R0, ASR #+3
        LDRB     R0,[R0, #+164]
        STR      R0,[R1, #+88]
        B        ??APUWrite_1
//  158 
//  159     break;
//  160       //pppp pppp   period low
//  161     case 0x400A:
//  162       triangleperiod = ( PSG[0x0A] + ( ( PSG[0x0B] & 7 ) << 8 ) );
??APUWrite_11:
        LDRB     R0,[R2, #+10]
        LDRB     R2,[R2, #+11]
        AND      R2,R2,#0x7
        ADD      R0,R0,R2, LSL #+8
        STR      R0,[R1, #+76]
        B        ??APUWrite_1
//  163     break;
//  164       //llll lppp   length index, period high
//  165     case 0x400B:
//  166       triangleperiod = ( PSG[0x0A] + ( ( PSG[0x0B] & 7 ) << 8 ) );
??APUWrite_12:
        LDRB     R0,[R2, #+10]
        LDRB     R2,[R2, #+11]
        AND      R2,R2,#0x7
        ADD      R0,R0,R2, LSL #+8
        STR      R0,[R1, #+76]
//  167       twhaltflag = 128;
        MOV      R0,#+128
        STRB     R0,[R1, #+121]
        B        ??APUWrite_1
//  168     break;
//  169       //Noise
//  170       //--le nnnn   loop enoisevolume/disable length, enoisevolume disable, vol/enoisevolume period
//  171     case 0x400C:
//  172 
//  173       noisevolume = PSG[0x0C] & 15;
??APUWrite_13:
        LDRB     R0,[R2, #+12]
        AND      R0,R0,#0xF
        STR      R0,[R1, #+64]
        B        ??APUWrite_1
//  174       //if(PSG[0x0C]&32)PSG[0x15]=PSG[0x15]&247;else
//  175       //      PSG[0x15]=PSG[0x15]|8;
//  176     break;
//  177       //s--- pppp   short mode, period index
//  178     case 0x400E:
//  179       noisedevider = 0;
??APUWrite_14:
        STR      R3,[R1, #+48]
        B        ??APUWrite_1
//  180     break;
//  181       //llll l---   length index
//  182     case 0x400F:
//  183       noiselencounter = lengthtable[PSG[0x0F] >> 3];
??APUWrite_15:
        LDRB     R0,[R2, #+15]
        ADD      R0,R1,R0, ASR #+3
        LDRB     R0,[R0, #+164]
//  184       noiseenvelope = 15;
        STRB     R12,[R1, #+114]
        STR      R0,[R1, #+92]
//  185       noiseenvdiv = ( PSG[0x0C] & 15 ) + 1;
        LDRSB    R0,[R2, #+12]
        AND      R0,R0,#0xF
        ADD      R0,R0,#+1
        STRB     R0,[R1, #+115]
        B        ??APUWrite_1
//  186     break;
//  187       //DMC
//  188       //il-- ffff   IRQ enable, loop, frequency index
//  189     case 0x4010:
//  190 
//  191 
//  192     break;
//  193       //-ddd dddd   DAC
//  194     case 0x4011:
//  195       daccounter = ( PSG[0x11] & 127 );
??APUWrite_16:
        LDRB     R0,[R2, #+17]
        AND      R0,R0,#0x7F
        STRB     R0,[R1, #+113]
        B        ??APUWrite_1
//  196     break;
//  197       //aaaa aaaa   sample address
//  198     case 0x4012:
//  199       dmcdmaadr = PSG[0x12] * 0x40 + 0xC000;
??APUWrite_17:
        LDRB     R0,[R2, #+18]
        MOV      R2,#+49152
        ADD      R0,R2,R0, LSL #+6
        STR      R0,[R1, #+100]
        B        ??APUWrite_1
//  200     break;
//  201       //llll llll   sample length
//  202     case 0x4013:
//  203       dmcdatalen = PSG[0x13] * 0x10 + 1;
??APUWrite_18:
        LDRB     R0,[R2, #+19]
        MOV      R2,#+1
        ADD      R0,R2,R0, LSL #+4
        STR      R0,[R1, #+104]
        B        ??APUWrite_1
//  204 
//  205     break;
//  206       //Common
//  207       //---d noisedevider21   length ctr enable: DMC, noise, triangle, pulse 2, 1
//  208     case 0x4015:
//  209 
//  210     break;
//  211       //fd-- ----   5-frame cycle, disable frame inoisedevidererrupt
//  212     case 0x4017:
//  213       framesequence = 0;
??APUWrite_19:
        STRH     R3,[R1, #+2]
//  214       frameseqcount = 0;
        STRH     R3,[R1, #+0]
//  215     break;
//  216 
//  217   }
//  218 }
??APUWrite_20:
        B        ??APUWrite_1
        CFI EndBlock cfiBlock5

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock6 Using cfiCommon0
        CFI NoFunction
        THUMB
??LenSweepC??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock6
        REQUIRE LenSweepC
//  219 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock7 Using cfiCommon1
        CFI Function LenSweepC
        ARM
//  220 void LenSweepC()
//  221 {
//  222 
//  223   if ( ( ( PSG[0x00] & 32 ) == 0 ) && ( square1lencounter > 0 ) )
LenSweepC:
        LDR      R1,??DataTable8  ;; PSG
        LDR      R0,??DataTable5  ;; frameseqcount
        PUSH     {R4,R5}
        CFI R5 Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
        LDRB     R2,[R1, #+0]
        TST      R2,#0x20
        BNE      ??LenSweepC_0
        LDR      R2,[R0, #+80]
        CMP      R2,#+1
//  224   {
//  225     square1lencounter--;
        SUBGE    R2,R2,#+1
        STRGE    R2,[R0, #+80]
//  226   }
//  227   if ( ( ( PSG[0x04] & 32 ) == 0 ) && ( square2lencounter > 0 ) )
??LenSweepC_0:
        LDRB     R2,[R1, #+4]
        TST      R2,#0x20
        BNE      ??LenSweepC_1
        LDR      R2,[R0, #+84]
        CMP      R2,#+1
//  228   {
//  229     square2lencounter--;
        SUBGE    R2,R2,#+1
        STRGE    R2,[R0, #+84]
//  230   }
//  231   if ( ( ( PSG[0x08] & 128 ) == 0 ) && ( trianglelencounter > 0 ) )
??LenSweepC_1:
        LDRB     R2,[R1, #+8]
        TST      R2,#0x80
        BNE      ??LenSweepC_2
        LDR      R2,[R0, #+88]
        CMP      R2,#+1
//  232   {
//  233     trianglelencounter--;
        SUBGE    R2,R2,#+1
        STRGE    R2,[R0, #+88]
//  234   }
//  235   if ( ( ( PSG[0x0C] & 32 ) == 0 ) && ( noiselencounter > 0 ) )
??LenSweepC_2:
        LDRB     R2,[R1, #+12]
        TST      R2,#0x20
        BNE      ??LenSweepC_3
        LDR      R2,[R0, #+92]
        CMP      R2,#+1
//  236   {
//  237     noiselencounter--;
        SUBGE    R2,R2,#+1
        STRGE    R2,[R0, #+92]
//  238   }
//  239   //Sweep
//  240   //Square1
//  241   if ( PSG[0x01] & 128 ) square1sweep -= 1;
??LenSweepC_3:
        LDRSB    R2,[R0, #+122]
        LDRB     R3,[R1, #+1]
//  242   if ( square1sweep < 0 )
        LDRB     R4,[R0, #+123]
        TST      R3,#0x80
        LDR      R3,[R0, #+68]
        SUBNE    R2,R2,#+1
        ADD      R12,R4,#+1
        LDRSB    R4,[R0, #+124]
        MOV      R2,R2, LSL #+24
        MOVS     R2,R2, ASR #+24
        BPL      ??LenSweepC_4
//  243   {
//  244     square1sweep = sq1sweepperiod;
        LDRSB    R2,[R0, #+125]
//  245     if ( sweep1negative )
        ASR      R5,R3,R12
        CMP      R4,#+0
//  246       square1period = square1period - ( square1period >> ( sweep1shift + 1 ) );
        SUBNE    R3,R3,R5
//  247     else
//  248       square1period = square1period + ( square1period >> ( sweep1shift + 1 ) );
        ADDEQ    R3,R5,R3
//  249     if ( square1period < 0 ) square1period += 2048;
        CMP      R3,#+0
        ADDMI    R3,R3,#+2048
//  250     if ( square1period > 2047 ) square1period -= 2048;
        CMP      R3,#+2048
        MVNGE    R5,#+255
        BICGE    R5,R5,#0x700
        ADDGE    R3,R5,R3
//  251   }
//  252   //
//  253   //Square2
//  254   if ( PSG[0x05] & 128 ) square2sweep -= 1;
??LenSweepC_4:
        LDRB     R1,[R1, #+5]
        STRB     R2,[R0, #+122]
        LDRSB    R2,[R0, #+126]
        STR      R3,[R0, #+68]
        TST      R1,#0x80
//  255   if ( square2sweep < 0 )
        LDR      R1,[R0, #+72]
        SUBNE    R2,R2,#+1
        MOV      R2,R2, LSL #+24
        MOVS     R2,R2, ASR #+24
        BPL      ??LenSweepC_5
//  256   {
//  257     square2sweep = sq2sweepperiod;
        LDRSB    R2,[R0, #+129]
//  258     if ( sweep1negative )
        ASR      R3,R1,R12
        CMP      R4,#+0
//  259       square2period = square2period - ( square2period >> ( sweep1shift + 1 ) );
        SUBNE    R1,R1,R3
//  260     else
//  261       square2period = square2period + ( square2period >> ( sweep1shift + 1 ) );
        ADDEQ    R1,R3,R1
//  262     if ( square2period < 0 ) square2period += 2048;
        CMP      R1,#+0
        ADDMI    R1,R1,#+2048
//  263     if ( square2period > 2047 ) square2period -= 2048;
        CMP      R1,#+2048
        MVNGE    R3,#+255
        BICGE    R3,R3,#0x700
        ADDGE    R1,R3,R1
??LenSweepC_5:
        STR      R1,[R0, #+72]
        STRB     R2,[R0, #+126]
//  264   }
//  265 
//  266 }
        POP      {R4,R5}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock7

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock8 Using cfiCommon0
        CFI NoFunction
        THUMB
??EnvLinC??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock8
        REQUIRE EnvLinC
//  267 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock9 Using cfiCommon1
        CFI Function EnvLinC
        ARM
//  268 void EnvLinC()
//  269 {
//  270   //Linear counter
//  271   if ( twhaltflag != 0 )
EnvLinC:
        LDR      R0,??DataTable5  ;; frameseqcount
        LDR      R1,??DataTable8  ;; PSG
        LDRB     R2,[R0, #+120]
        LDRB     R3,[R1, #+8]
        LDRB     R12,[R0, #+121]
        CMP      R12,#+0
//  272   {
//  273     triabglelinearcounter = PSG[0x08] & 127;
        ANDNE    R2,R3,#0x7F
        BNE      ??EnvLinC_0
//  274   }
//  275   else
//  276   {
//  277     if ( triabglelinearcounter > 0 )
        CMP      R2,#+0
//  278     {
//  279       triabglelinearcounter--;
        SUBNE    R2,R2,#+1
??EnvLinC_0:
        STRB     R2,[R0, #+120]
//  280     }
//  281   }
//  282   if ( ( PSG[0x08] & 128 ) == 0 )
        TST      R3,#0x80
//  283   {
//  284     twhaltflag = 0;
//  285   }
//  286 
//  287   //Envelope
//  288   //Noise
//  289   noiseenvdiv--;
//  290   if ( noiseenvdiv <= 0 )
        LDRSB    R3,[R0, #+114]
        MOVEQ    R2,#+0
        STRBEQ   R2,[R0, #+121]
        LDRSB    R2,[R0, #+115]
        SUB      R2,R2,#+1
        MOV      R2,R2, LSL #+24
        MOV      R2,R2, ASR #+24
        CMP      R2,#+1
        BGE      ??EnvLinC_1
//  291   {
//  292     noiseenvdiv = ( PSG[0x0C] & 15 ) + 1;
        LDRB     R12,[R1, #+12]
//  293     if ( noiseenvelope > 0 ) noiseenvelope--;
        CMP      R3,#+1
        SUBGE    R3,R3,#+1
        AND      R2,R12,#0xF
        ADD      R2,R2,#+1
//  294     if ( ( noiseenvelope <= 0 ) && ( ( PSG[0x0C] & 32 ) != 0 ) ) noiseenvelope = 15;
        MOV      R3,R3, LSL #+24
        MOV      R3,R3, ASR #+24
        CMP      R3,#+1
        BGE      ??EnvLinC_1
        TST      R12,#0x20
        MOVNE    R3,#+15
??EnvLinC_1:
        STRB     R2,[R0, #+115]
//  295   }
//  296   //Square1
//  297   square1envdiv--;
        LDRSB    R2,[R0, #+117]
        STRB     R3,[R0, #+114]
//  298   if ( square1envdiv <= 0 )
        LDRSB    R3,[R0, #+116]
        SUB      R2,R2,#+1
        MOV      R2,R2, LSL #+24
        MOV      R2,R2, ASR #+24
        CMP      R2,#+1
        BGE      ??EnvLinC_2
//  299   {
//  300     square1envdiv = ( PSG[0x00] & 15 ) + 1;
        LDRB     R12,[R1, #+0]
//  301 
//  302     if ( square1envelope > 0 ) square1envelope--;
        CMP      R3,#+1
        SUBGE    R3,R3,#+1
        AND      R2,R12,#0xF
        ADD      R2,R2,#+1
//  303     if ( ( square1envelope <= 0 ) && ( ( PSG[0x00] & 32 ) != 0 ) )
        MOV      R3,R3, LSL #+24
        MOV      R3,R3, ASR #+24
        CMP      R3,#+1
        BGE      ??EnvLinC_2
        TST      R12,#0x20
//  304       square1envelope = 15;
        MOVNE    R3,#+15
??EnvLinC_2:
        STRB     R2,[R0, #+117]
//  305   }
//  306   //Square2
//  307   square2envdiv--;
        LDRSB    R2,[R0, #+119]
        STRB     R3,[R0, #+116]
//  308   if ( square2envdiv <= 0 )
        LDRSB    R3,[R0, #+118]
        SUB      R2,R2,#+1
        MOV      R2,R2, LSL #+24
        MOV      R2,R2, ASR #+24
        CMP      R2,#+1
        BGE      ??EnvLinC_3
//  309   {
//  310     square2envdiv = ( PSG[0x04] & 15 ) + 1;
        LDRB     R1,[R1, #+4]
//  311 
//  312     if ( square2envelope > 0 ) square2envelope--;
        CMP      R3,#+1
        SUBGE    R3,R3,#+1
        AND      R2,R1,#0xF
        ADD      R2,R2,#+1
//  313     if ( ( square2envelope <= 0 ) && ( ( PSG[0x04] & 32 ) != 0 ) )
        MOV      R3,R3, LSL #+24
        MOV      R3,R3, ASR #+24
        CMP      R3,#+1
        BGE      ??EnvLinC_3
        TST      R1,#0x20
//  314       square2envelope = 15;
        MOVNE    R3,#+15
??EnvLinC_3:
        STRB     R3,[R0, #+118]
        STRB     R2,[R0, #+119]
//  315   }
//  316 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock9

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable5:
        DC32     frameseqcount

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock10 Using cfiCommon0
        CFI NoFunction
        THUMB
??GetSound??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock10
        REQUIRE GetSound
//  317 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock11 Using cfiCommon1
        CFI Function GetSound
        ARM
//  318 signed short GetSound()
//  319 {
GetSound:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
//  320   int add, tri, squ1, squ2, noise;
//  321   add = tri = squ1 = squ2 = noise = 0;
//  322 
//  323 //  if((NsfSongLen-NsfTime)<0){
//  324  //   AudioActive=0;
//  325  //   return(0);}
//  326     /*
//  327   if ( PSG[0x15] & 16 )
//  328   {
//  329     dmcdevider -= 1792000/16000;
//  330     while ( dmcdevider <= 0 )
//  331     {
//  332       dmcdevider += dmcperiod[PSG[0x10] & 15];
//  333       //
//  334       if ( dmcdatalen > 0 )
//  335       {
//  336         if ( dmcbuffer & 1 )
//  337         {
//  338           if ( daccounter < 126 ) daccounter += 2;
//  339         }
//  340         else
//  341         {
//  342           if ( daccounter > 1 ) daccounter -= 2;
//  343         }
//  344       }
//  345 
//  346       dmcbuffer = dmcbuffer >> 1;
//  347       dmcbuffercount++;
//  348       if ( dmcbuffercount >= 8 )
//  349       {
//  350         dmcbuffercount = 0;
//  351         if ( dmcdatalen > 0 ) dmcbuffer = vra[dmcdmaadr];
//  352         //if(dmcbuffer==0)dmcsilence=1;else dmcsilence=0;
//  353         dmcdmaadr++;
//  354         if ( dmcdmaadr > 0xFFFF ) dmcdmaadr = 0x8000;
//  355         if ( dmcdatalen > 0 ) dmcdatalen--;
//  356         if ( dmcdatalen <= 0 )
//  357         {
//  358           if ( PSG[0x10] & 64 )
//  359           {
//  360             dmcdmaadr = PSG[0x12] * 0x40 + 0xC000;
//  361             dmcdatalen = PSG[0x13] * 0x10 + 1;
//  362           }
//  363         }
//  364       }
//  365     }
//  366   }
//  367 */
//  368   if ( triangleperiod >= 8 ) triangledevider -= 1792000/16000;
        LDR      R6,??DataTable7  ;; frameseqcount
        SUB      SP,SP,#+8
        CFI CFA R13+44
        LDR      R0,[R6, #+76]
        MOV      R1,#+0
        STR      R1,[SP, #+0]
        MOV      R4,#+0
        MOV      R5,R1
        STR      R1,[SP, #+4]
        CMP      R0,#+8
        BLT      ??GetSound_0
        LDR      R1,[R6, #+44]
        SUB      R1,R1,#+112
        STR      R1,[R6, #+44]
        B        ??GetSound_0
//  369   while ( triangledevider <= 0 )
//  370   {
//  371     triangledevider += triangleperiod + 1;
??GetSound_1:
        ADD      R2,R0,#+1
        ADD      R1,R2,R1
//  372     if ( ( PSG[0x0A] + ( ( PSG[0x0B] & 7 ) << 8 ) ) > 4 ) triangleseqpos++;
        LDRB     R2,[R7, #+11]
        STR      R1,[R6, #+44]
        LDRB     R1,[R7, #+10]
        AND      R2,R2,#0x7
        ADD      R1,R1,R2, LSL #+8
        MOV      R1,R1, LSL #+16
        MOV      R1,R1, LSR #+16
        CMP      R1,#+5
        ADDCS    R1,R8,#+1
        STRBCS   R1,[R6, #+110]
//  373     if ( triangleseqpos >= 32 ) triangleseqpos = 0;
        LDRB     R1,[R6, #+110]
        CMP      R1,#+32
        STRBCS   R9,[R6, #+110]
//  374   }
??GetSound_0:
        LDR      R1,[R6, #+44]
        LDRB     R8,[R6, #+110]
        LDR      R7,??DataTable8  ;; PSG
        MOV      R9,#+0
        CMP      R1,#+1
        BLT      ??GetSound_1
//  375 
//  376   if ( square1period >= 8 ) square1devider -= 1792000/16000/2;
        LDR      R0,[R6, #+68]
        CMP      R0,#+8
        BLT      ??GetSound_2
        LDR      R1,[R6, #+36]
        SUB      R1,R1,#+56
        STR      R1,[R6, #+36]
        B        ??GetSound_2
//  377   while ( square1devider <= 0 )
//  378   {
//  379     square1devider += ( square1period + 1 );
??GetSound_3:
        ADD      R2,R0,#+1
        ADD      R1,R2,R1
        STR      R1,[R6, #+36]
//  380     square1seqpos++;
        ADD      R1,R10,#+1
        STRB     R1,[R6, #+108]
//  381     if ( square1seqpos >= 8 ) square1seqpos = 0;
        AND      R1,R1,#0xFF
        CMP      R1,#+8
        STRBCS   R9,[R6, #+108]
//  382   }
??GetSound_2:
        LDR      R1,[R6, #+36]
        LDRB     R10,[R6, #+108]
        CMP      R1,#+1
        BLT      ??GetSound_3
//  383   //
//  384   if ( square2period >= 8 ) square2devider -= 1792000/16000/2;
        LDR      R0,[R6, #+72]
        CMP      R0,#+8
        BLT      ??GetSound_4
        LDR      R1,[R6, #+40]
        SUB      R1,R1,#+56
        STR      R1,[R6, #+40]
        B        ??GetSound_4
//  385   while ( square2devider <= 0 )
//  386   {
//  387     square2devider += square2period + 1;
??GetSound_5:
        ADD      R2,R0,#+1
        ADD      R1,R2,R1
        STR      R1,[R6, #+40]
//  388     square2seqpos++;
        ADD      R1,R11,#+1
        STRB     R1,[R6, #+109]
//  389     if ( square2seqpos >= 8 ) square2seqpos = 0;
        AND      R1,R1,#0xFF
        CMP      R1,#+8
        STRBCS   R9,[R6, #+109]
//  390   }
??GetSound_4:
        LDR      R1,[R6, #+40]
        LDRB     R11,[R6, #+109]
        CMP      R1,#+1
        BLT      ??GetSound_5
//  391 
//  392   noisedevider -= 1792000/16000;
        LDR      R0,[R6, #+48]
        SUB      R0,R0,#+112
        STR      R0,[R6, #+48]
//  393   if ( noisedevider <= 0 )
        CMP      R0,#+1
        BGE      ??GetSound_6
//  394   {
//  395     noisedevider += noiseperiod[PSG[0x0E] & 15];
        LDRB     R1,[R7, #+14]
        AND      R1,R1,#0xF
        ADD      R1,R6,R1, LSL #+1
        LDRH     R1,[R1, #+4]
        ADD      R0,R1,R0
        STR      R0,[R6, #+48]
//  396     if ( ( PSG[0x0C] & 16 ) == 0 ) noiseoutput = ( randint( 2 ) - 1 ) * noiseenvelope;
        LDRB     R0,[R7, #+12]
        TST      R0,#0x10
        MOV      R0,#+2
        BNE      ??GetSound_7
        BL       randint
        LDRSB    R1,[R6, #+114]
        B        ??GetSound_8
//  397     else
//  398       noiseoutput = ( randint( 2 ) - 1 ) * noisevolume;
??GetSound_7:
        BL       randint
        LDR      R1,[R6, #+64]
??GetSound_8:
        SUB      R0,R0,#+1
        MUL      R0,R1,R0
        STR      R0,[R6, #+96]
//  399   }
//  400   //
//  401   if ( ( ( PSG[0x15] & 1 ) == 0 ) || ( square1lencounter != 0 ) )
??GetSound_6:
        LDRB     R0,[R7, #+21]
        LDR      R1,??GetSound_9  ;; squarewave
        TST      R0,#0x1
        BEQ      ??GetSound_10
        LDR      R2,[R6, #+80]
        CMP      R2,#+0
        BEQ      ??GetSound_11
??GetSound_10:
        LDRB     R2,[R6, #+111]
        LDRB     R3,[R7, #+0]
        ADD      R2,R1,R2, LSL #+3
        LDRSB    R2,[R10, +R2]
        TST      R3,#0x10
//  402   {
//  403     if ( ( PSG[0x00] & 16 ) != 0 ) squ1 = squarewave[sw1d] [square1seqpos] * square1volume;
//  404     else
//  405       squ1 = squarewave[sw1d] [square1seqpos] * square1envelope;
        LDRSBEQ  R3,[R6, #+116]
        LDRNE    R3,[R6, #+52]
        MUL      R5,R3,R2
//  406   }
//  407   if ( ( ( PSG[0x15] & 2 ) == 0 ) || ( square2lencounter != 0 ) )
??GetSound_11:
        TST      R0,#0x2
        BEQ      ??GetSound_12
        LDR      R2,[R6, #+84]
        CMP      R2,#+0
        BEQ      ??GetSound_13
??GetSound_12:
        LDRB     R2,[R6, #+112]
        ADD      R1,R1,R2, LSL #+3
        LDRB     R2,[R7, #+4]
        LDRSB    R1,[R11, +R1]
        TST      R2,#0x10
//  408   {
//  409     if ( ( PSG[0x04] & 16 ) != 0 ) squ2 = squarewave[sw2d] [square2seqpos] * square2volume;
//  410     else
//  411       squ2 = squarewave[sw2d] [square2seqpos] * square2envelope;
        LDRSBEQ  R2,[R6, #+118]
        LDRNE    R2,[R6, #+56]
        MUL      R4,R2,R1
//  412   }
//  413   if ( ( ( ( PSG[0x15] & 4 ) == 0 ) && ( trianglelencounter != 0 ) ) || ( ( triabglelinearcounter != 0 ) ) )
??GetSound_13:
        TST      R0,#0x4
        BNE      ??GetSound_14
        LDR      R1,[R6, #+88]
        CMP      R1,#+0
        BNE      ??GetSound_15
??GetSound_14:
        LDRB     R1,[R6, #+120]
        CMP      R1,#+0
        BEQ      ??GetSound_16
//  414     tri = ( trianglewave[triangleseqpos] - 7 ) * trianglevolume;
??GetSound_15:
        LDR      R3,[R6, #+60]
        ADD      R2,R8,R6
        LDRB     R2,[R2, #+132]
        SUB      R2,R2,#+7
        MUL      R2,R3,R2
        STR      R2,[SP, #+4]
//  415 
//  416   if ( ( ( PSG[0x15] & 8 ) == 0 ) || ( noiselencounter != 0 ) )
??GetSound_16:
        TST      R0,#0x8
        BEQ      ??GetSound_17
        LDR      R0,[R6, #+92]
        CMP      R0,#+0
        BEQ      ??GetSound_18
//  417   {
//  418     noise = noiseoutput;
??GetSound_17:
        LDR      R1,[R6, #+96]
        STR      R1,[SP, #+0]
//  419   }
//  420 
//  421 
//  422   frameseqcount++;
??GetSound_18:
        LDRSH    R0,[R6, #+0]
//  423   if ( frameseqcount >= ( samplerate/50 / 4 ) )
        LDR      R1,??GetSound_9+0x4  ;; 0x51eb851f
        ADD      R8,R0,#+1
        LDR      R0,??GetSound_9+0x8  ;; samplerate
        LDR      R0,[R0, #+0]
        SMULL    R2,R3,R1,R0
        MOV      R1,R8, LSL #+16
        ASR      R3,R3,#+4
        ADD      R0,R3,R0, LSR #+31
        MOV      R1,R1, ASR #+16
        ASR      R2,R0,#+1
        ADD      R0,R0,R2, LSR #+30
        CMP      R1,R0, ASR #+2
        BLT      ??GetSound_19
//  424   {
//  425     frameseqcount = 0;
//  426     if ( ( PSG[0x17] & 128 ) == 0 )
        LDRB     R0,[R7, #+23]
        LDRSH    R10,[R6, #+2]
        MOV      R8,#+0
        TST      R0,#0x80
        BNE      ??GetSound_20
//  427     //4 steps
//  428     {
//  429       if ( ( framesequence == 1 ) || ( framesequence == 3 ) )
        CMP      R10,#+1
        CMPNE    R10,#+3
        BNE      ??GetSound_21
//  430       {
//  431         LenSweepC();
        BL       LenSweepC
//  432       } //clock length counoisedeviderers and sweep units
//  433       EnvLinC();
??GetSound_21:
        BL       EnvLinC
//  434       if ( framesequence >= 3 ) framesequence = 0;
        CMP      R10,#+3
        BLT      ??GetSound_22
        B        ??GetSound_23
//  435     }
//  436     else
//  437     //5 steps
//  438     {
//  439       if ( ( framesequence == 0 ) || ( framesequence == 2 ) )
??GetSound_20:
        CMP      R10,#+0
        CMPNE    R10,#+2
        BNE      ??GetSound_24
//  440       {
//  441         LenSweepC();
        BL       LenSweepC
//  442       } //clock length counoisedeviderers and sweep units
//  443       if ( framesequence < 4 ) EnvLinC();
??GetSound_24:
        CMP      R10,#+4
        BGE      ??GetSound_23
        BL       EnvLinC
        B        ??GetSound_22
//  444       if ( framesequence >= 4 ) framesequence = 0;
??GetSound_23:
        STRH     R9,[R6, #+2]
//  445     }
//  446     framesequence++;
??GetSound_22:
        LDRSH    R0,[R6, #+2]
        ADD      R0,R0,#+1
        STRH     R0,[R6, #+2]
//  447     LenSweepC();
        BL       LenSweepC
??GetSound_19:
        STRH     R8,[R6, #+0]
//  448   }
//  449 
//  450   //
//  451   /*
//  452   MainClock++;
//  453   if ( MainClock >= speed )
//  454   {
//  455     NsfTime+=1;
//  456     MainClock = 0;
//  457     PC = NSF_HDR.play;
//  458     PSG[0x100 + S--] = 0xFF;
//  459     PSG[0x100 + S--] = 0xFF;
//  460     while ( PC > 4 )
//  461     {
//  462       opcode = PSG[PC++];
//  463       instruction[opcode] ();
//  464     }
//  465     //PSG[0x15]=PSG[0x15]&(255-192);
//  466   }  
//  467   */
//  468   add = ( ( squ1 + squ2 ) * 8 + noise * 6 + tri ) * 32;
//  469 
//  470 
//  471 // if((NsfSongLen-NsfTime)<256)add=add*(NsfSongLen-NsfTime)/256;
//  472   return add;
        LDR      R1,[SP, #+0]
        MOV      R2,#+6
        SMULBB   R1,R1,R2
        ADD      R0,R4,R5
        ADD      R0,R1,R0, LSL #+3
        LDR      R1,[SP, #+4]
        ADD      R0,R1,R0
        LSL      R0,R0,#+21
        ASR      R0,R0,#+16
        POP      {R1,R2,R4-R11,PC}  ;; return
        DATA
??GetSound_9:
        DC32     squarewave
        DC32     0x51eb851f
        DC32     samplerate
        CFI EndBlock cfiBlock11
//  473 
//  474 }

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable7:
        DC32     frameseqcount

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable8:
        DC32     PSG

        RSEG DATA_ID:CONST:SORT:NOROOT(1)
`?<Initializer for addrmask>`:
        DATA
        DC16 65535

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for frameseqcount>`:
        DATA
        DC8 0, 0
`?<Initializer for framesequence>`:
        DC8 0, 0
`?<Initializer for noiseperiod>`:
        DC16 4, 8, 16, 32, 64, 96, 128, 160, 202, 254, 380, 508, 762, 1016
        DC16 2034, 4068
`?<Initializer for square1devider>`:
        DC8 0, 0, 0, 0
`?<Initializer for square2devider>`:
        DC8 0, 0, 0, 0
`?<Initializer for triangledevider>`:
        DC8 0, 0, 0, 0
`?<Initializer for noisedevider>`:
        DC8 0, 0, 0, 0
`?<Initializer for square1volume>`:
        DC8 0, 0, 0, 0
`?<Initializer for square2volume>`:
        DC8 0, 0, 0, 0
`?<Initializer for trianglevolume>`:
        DC8 0, 0, 0, 0
`?<Initializer for noisevolume>`:
        DC8 0, 0, 0, 0
`?<Initializer for square1period>`:
        DC8 0, 0, 0, 0
`?<Initializer for square2period>`:
        DC8 0, 0, 0, 0
`?<Initializer for triangleperiod>`:
        DC8 0, 0, 0, 0
`?<Initializer for square1lencounter>`:
        DC8 0, 0, 0, 0
`?<Initializer for square2lencounter>`:
        DC8 0, 0, 0, 0
`?<Initializer for trianglelencounter>`:
        DC8 0, 0, 0, 0
`?<Initializer for noiselencounter>`:
        DC8 0, 0, 0, 0
`?<Initializer for noiseoutput>`:
        DC8 0, 0, 0, 0
`?<Initializer for dmcdmaadr>`:
        DC8 0, 0, 0, 0
`?<Initializer for dmcdatalen>`:
        DC8 0, 0, 0, 0
`?<Initializer for square1seqpos>`:
        DC8 0
`?<Initializer for square2seqpos>`:
        DC8 0
`?<Initializer for triangleseqpos>`:
        DC8 0
`?<Initializer for sw1d>`:
        DC8 0
`?<Initializer for sw2d>`:
        DC8 0
`?<Initializer for daccounter>`:
        DC8 0
`?<Initializer for noiseenvelope>`:
        DC8 0
`?<Initializer for noiseenvdiv>`:
        DC8 0
`?<Initializer for square1envelope>`:
        DC8 0
`?<Initializer for square1envdiv>`:
        DC8 0
`?<Initializer for square2envelope>`:
        DC8 0
`?<Initializer for square2envdiv>`:
        DC8 0
`?<Initializer for triabglelinearcounter>`:
        DC8 0
`?<Initializer for twhaltflag>`:
        DC8 0
`?<Initializer for square1sweep>`:
        DC8 0
`?<Initializer for sweep1shift>`:
        DC8 0
`?<Initializer for sweep1negative>`:
        DC8 0
`?<Initializer for sq1sweepperiod>`:
        DC8 0
`?<Initializer for square2sweep>`:
        DC8 0
`?<Initializer for sweep2shift>`:
        DC8 0
`?<Initializer for sweep2negative>`:
        DC8 0
`?<Initializer for sq2sweepperiod>`:
        DC8 0
        DC8 0, 0
`?<Initializer for trianglewave>`:
        DC8 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 1, 2, 3, 4
        DC8 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
`?<Initializer for lengthtable>`:
        DC8 5, 127, 10, 1, 19, 2, 40, 3, 80, 4, 30, 5, 7, 6, 13, 7, 6, 8, 12, 9
        DC8 24, 10, 48, 11, 96, 12, 36, 13, 8, 14, 16, 15

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_Z:
        DCD      sfe(DATA_Z) - sfb(DATA_Z), sfb(DATA_Z), sfb(DATA_Z)

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?*?DATA_ID`:

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_I:
        DCD      sfe(DATA_I) - sfb(DATA_I), sfb(DATA_I), sfb(DATA_ID)

        END
// 
// 2 124 bytes in segment CODE
//    64 bytes in segment DATA_C
//   198 bytes in segment DATA_I
//   198 bytes in segment DATA_ID
//   143 bytes in segment DATA_Z
//    24 bytes in segment INITTAB
// 
// 2 100 bytes of CODE  memory (+ 48 bytes shared)
//   262 bytes of CONST memory
//   341 bytes of DATA  memory
//
//Errors: none
//Warnings: none
