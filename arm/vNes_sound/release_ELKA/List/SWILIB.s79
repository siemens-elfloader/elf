//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION   09/Dec/2010  18:20:30 /
// Copyright 1999-2005 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Cpu mode        =  interwork                                           /
//    Endian          =  little                                              /
//    Stack alignment =  4                                                   /
//    Source file     =  C:\arm\vNes_sound\SWILIB.C                          /
//    Command line    =  C:\arm\vNes_sound\SWILIB.C -D NDEBUG -D NEWSGOLD    /
//                       -D ELKA -lCN C:\arm\vNes_sound\release_ELKA\List\   /
//                       -lA C:\arm\vNes_sound\release_ELKA\List\ -o         /
//                       C:\arm\vNes_sound\release_ELKA\Obj\ -s9 --cpu_mode  /
//                       arm --endian little --cpu ARM926EJ-S --stack_align  /
//                       4 --interwork -e --fpu None --dlib_config           /
//                       "C:\arm2\Embedded Workbench 4.0                     /
//                       Evaluation\ARM\LIB\dl5tpainl8f.h" -I                /
//                       "C:\arm2\Embedded Workbench 4.0                     /
//                       Evaluation\ARM\INC\" --inline_threshold=2           /
//    List file       =  C:\arm\vNes_sound\release_ELKA\List\SWILIB.s79      /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME SWILIB

        RTMODEL "StackAlign4", "USED"
        RTMODEL "__cpu_mode", "__pcs__interwork"
        RTMODEL "__data_model", "absolute"
        RTMODEL "__endian", "little"
        RTMODEL "__rt_version", "6"

        RSEG CSTACK:DATA:NOROOT(2)

        MULTWEAK ??abs??rT
        MULTWEAK ??alltrim??rT
        MULTWEAK ??bitblt??rT
        MULTWEAK ??emptystr??rT
        MULTWEAK ??fgets??rT
        MULTWEAK ??fread32??rT
        MULTWEAK ??fwrite32??rT
        MULTWEAK ??get3int??rT
        MULTWEAK ??getint??rT
        MULTWEAK ??getshort??rT
        MULTWEAK ??isalth??rT
        MULTWEAK ??isval??rT
        MULTWEAK ??loadfile??rT
        MULTWEAK ??max??rT
        MULTWEAK ??min??rT
        MULTWEAK ??printf??rT
        MULTWEAK ??putint??rT
        MULTWEAK ??putshort??rT
        MULTWEAK ??savefile??rT
        MULTWEAK ??strchrpos??rT
        MULTWEAK ??strcmpsize??rT
        MULTWEAK ??strdup??rT
        MULTWEAK ??todown??rT
        MULTWEAK ??toup??rT
        PUBWEAK ?init?tab?DATA_Z
        PUBLIC abs
        FUNCTION abs,0203H
        PUBLIC alltrim
        FUNCTION alltrim,0203H
        PUBLIC bitblt
        FUNCTION bitblt,0203H
        LOCFRAME CSTACK, 40, STACK
        PUBLIC emptystr
        FUNCTION emptystr,0203H
        PUBLIC err
        PUBLIC fgets
        FUNCTION fgets,0203H
        PUBLIC fread32
        FUNCTION fread32,0203H
        LOCFRAME CSTACK, 28, STACK
        PUBLIC fwrite32
        FUNCTION fwrite32,0203H
        LOCFRAME CSTACK, 28, STACK
        PUBLIC get3int
        FUNCTION get3int,0203H
        PUBLIC getint
        FUNCTION getint,0203H
        PUBLIC getshort
        FUNCTION getshort,0203H
        PUBLIC isalth
        FUNCTION isalth,0203H
        PUBLIC isval
        FUNCTION isval,0203H
        PUBLIC loadfile
        FUNCTION loadfile,0203H
        LOCFRAME CSTACK, 28, STACK
        PUBLIC loadfilesize
        PUBLIC max
        FUNCTION max,0203H
        PUBLIC min
        FUNCTION min,0203H
        PUBLIC printf
        FUNCTION printf,0203H
        PUBLIC putint
        FUNCTION putint,0203H
        PUBLIC putshort
        FUNCTION putshort,0203H
        PUBLIC savefile
        FUNCTION savefile,0203H
        LOCFRAME CSTACK, 20, STACK
        PUBLIC strchrpos
        FUNCTION strchrpos,0203H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC strcmpsize
        FUNCTION strcmpsize,0203H
        LOCFRAME CSTACK, 4, STACK
        PUBLIC strdup
        FUNCTION strdup,0203H
        PUBLIC todown
        FUNCTION todown,0203H
        PUBLIC toup
        FUNCTION toup,0203H
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 HUGEDATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, CPSR:32, R13:32
        CFI Resource R14:32, SPSR:32
        CFI VirtualResource ?RET:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon0
        
        
        CFI Common cfiCommon1 Using cfiNames0
        CFI CodeAlign 4
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon1
        
abs                 SYMBOL "abs"
??abs??rT           SYMBOL "??rT", abs
alltrim             SYMBOL "alltrim"
??alltrim??rT       SYMBOL "??rT", alltrim
bitblt              SYMBOL "bitblt"
??bitblt??rT        SYMBOL "??rT", bitblt
emptystr            SYMBOL "emptystr"
??emptystr??rT      SYMBOL "??rT", emptystr
fgets               SYMBOL "fgets"
??fgets??rT         SYMBOL "??rT", fgets
fread32             SYMBOL "fread32"
??fread32??rT       SYMBOL "??rT", fread32
fwrite32            SYMBOL "fwrite32"
??fwrite32??rT      SYMBOL "??rT", fwrite32
get3int             SYMBOL "get3int"
??get3int??rT       SYMBOL "??rT", get3int
getint              SYMBOL "getint"
??getint??rT        SYMBOL "??rT", getint
getshort            SYMBOL "getshort"
??getshort??rT      SYMBOL "??rT", getshort
isalth              SYMBOL "isalth"
??isalth??rT        SYMBOL "??rT", isalth
isval               SYMBOL "isval"
??isval??rT         SYMBOL "??rT", isval
loadfile            SYMBOL "loadfile"
??loadfile??rT      SYMBOL "??rT", loadfile
max                 SYMBOL "max"
??max??rT           SYMBOL "??rT", max
min                 SYMBOL "min"
??min??rT           SYMBOL "??rT", min
printf              SYMBOL "printf"
??printf??rT        SYMBOL "??rT", printf
putint              SYMBOL "putint"
??putint??rT        SYMBOL "??rT", putint
putshort            SYMBOL "putshort"
??putshort??rT      SYMBOL "??rT", putshort
savefile            SYMBOL "savefile"
??savefile??rT      SYMBOL "??rT", savefile
strchrpos           SYMBOL "strchrpos"
??strchrpos??rT     SYMBOL "??rT", strchrpos
strcmpsize          SYMBOL "strcmpsize"
??strcmpsize??rT    SYMBOL "??rT", strcmpsize
strdup              SYMBOL "strdup"
??strdup??rT        SYMBOL "??rT", strdup
todown              SYMBOL "todown"
??todown??rT        SYMBOL "??rT", todown
toup                SYMBOL "toup"
??toup??rT          SYMBOL "??rT", toup

        EXTERN height
        EXTERN width

// C:\arm\vNes_sound\SWILIB.C
//    1 
//    2 // swilib.c
//    3 #include "swilib.h"
//    4 
//    5 //#define HIGHCOLOR // 16-битный режим
//    6 //#define GRAPH  // Графика
//    7 //#define UNPACK // Распаковка архивов
//    8 #define NO7Z   // Кроме 7z
//    9 //#define NOZIP  // Кроме zip
//   10 #define NORAR  // Кроме rar
//   11 //#define NOLOAD // in loadgraph data loaded allready
//   12 
//   13 //#ifdef ELKA
//   14 //  #define width 240
//   15 //  #define height 304
//   16 //#else
//   17 //  #define width 132
//   18 //  #define height 176
//   19 //#endif
//   20 extern int width, height;
//   21 

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   22 unsigned int err=0;
err:
        DS8 4

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   23 int loadfilesize=0;
loadfilesize:
        DS8 4

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI NoFunction
        THUMB
??fread32??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock0
        REQUIRE fread32
//   24 
//   25 //#define ELKA // Для EL-71
//   26 //#ifndef NEWSGOLD
//   27 //#define NEWSGOLD // Для S75
//   28 //#endif
//   29 //#ifndef NEWSGOLD
//   30 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock1 Using cfiCommon1
        CFI Function fread32
        ARM
//   31 int fread32(int fh, void *buf, int len, unsigned int *err){
fread32:
        PUSH     {R4-R9,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R9 Frame(CFA, -8)
        CFI R8 Frame(CFA, -12)
        CFI R7 Frame(CFA, -16)
        CFI R6 Frame(CFA, -20)
        CFI R5 Frame(CFA, -24)
        CFI R4 Frame(CFA, -28)
        CFI CFA R13+28
        MOV      R4,R0
        MOV      R5,R1
        MOV      R6,R2
        MOV      R7,R3
//   32   int clen, rlen, total=0;
        MOV      R8,#+0
        B        ??fread32_0
//   33   while(len){
//   34   if (len>16384) clen=16384; else clen=len;
//   35   total+=(rlen=fread(fh, buf, clen, err));
//   36   if (rlen!=clen) break;
//   37   buf=(char*)buf+rlen;
??fread32_1:
        ADD      R5,R0,R5
//   38   len-=clen;
        SUB      R6,R6,R9
??fread32_0:
        CMP      R6,#+0
        BEQ      ??fread32_2
        MOV      R0,#+1
        ORR      R0,R0,#0x4000
        CMP      R6,R0
        MOVGE    R9,#+16384
        MOVLT    R9,R6
        MOV      R3,R7
        MOV      R2,R9
        MOV      R1,R5
        MOV      R0,R4
        SWI      +11
        ADD      R8,R0,R8
        CMP      R0,R9
        BEQ      ??fread32_1
//   39   }return(total);
??fread32_2:
        MOV      R0,R8
        POP      {R4-R9,PC}       ;; return
        CFI EndBlock cfiBlock1
//   40 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock2 Using cfiCommon0
        CFI NoFunction
        THUMB
??fwrite32??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock2
        REQUIRE fwrite32
//   41 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock3 Using cfiCommon1
        CFI Function fwrite32
        ARM
//   42 int fwrite32(int fh, void *buf, int len, unsigned int *err){
fwrite32:
        PUSH     {R4-R9,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R9 Frame(CFA, -8)
        CFI R8 Frame(CFA, -12)
        CFI R7 Frame(CFA, -16)
        CFI R6 Frame(CFA, -20)
        CFI R5 Frame(CFA, -24)
        CFI R4 Frame(CFA, -28)
        CFI CFA R13+28
        MOV      R4,R0
        MOV      R5,R1
        MOV      R6,R2
        MOV      R7,R3
//   43   int clen, rlen, total=0;
        MOV      R8,#+0
        B        ??fwrite32_0
//   44   while(len){
//   45   if (len>16384) clen=16384; else clen=len;
//   46   total+=(rlen=fwrite(fh, buf, clen, err));
//   47   if (rlen!=clen) break;
//   48   buf=(char*)buf+rlen;
??fwrite32_1:
        ADD      R5,R0,R5
//   49   len-=clen;
        SUB      R6,R6,R9
??fwrite32_0:
        CMP      R6,#+0
        BEQ      ??fwrite32_2
        MOV      R0,#+1
        ORR      R0,R0,#0x4000
        CMP      R6,R0
        MOVGE    R9,#+16384
        MOVLT    R9,R6
        MOV      R3,R7
        MOV      R2,R9
        MOV      R1,R5
        MOV      R0,R4
        SWI      +12
        ADD      R8,R0,R8
        CMP      R0,R9
        BEQ      ??fwrite32_1
//   50   }return(total);
??fwrite32_2:
        MOV      R0,R8
        POP      {R4-R9,PC}       ;; return
        CFI EndBlock cfiBlock3
//   51 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock4 Using cfiCommon0
        CFI NoFunction
        THUMB
??min??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock4
        REQUIRE min
//   52 //#endif
//   53 
//   54 //void *memset(void *mem, int val, int size){
//   55 //  char *s=(char*)mem;
//   56 //  while(--size>=0) *s++=(char)val;
//   57 //  return mem;
//   58 //}
//   59 
//   60 //void *memsetw(void *mem, int val, int size){
//   61 //  short *s=(short*)mem;
//   62 //  while(--size>=0) *s++=val;
//   63 //  return mem;
//   64 //}
//   65 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock5 Using cfiCommon1
        CFI Function min
        ARM
//   66 int min(int a, int b){ return (a<b)?a:b;}
min:
        CMP      R0,R1
        MOVGE    R0,R1
        BX       LR               ;; return
        CFI EndBlock cfiBlock5

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock6 Using cfiCommon0
        CFI NoFunction
        THUMB
??max??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock6
        REQUIRE max

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock7 Using cfiCommon1
        CFI Function max
        ARM
//   67 int max(int a, int b){ return (a>b)?a:b;}
max:
        CMP      R1,R0
        MOVGE    R0,R1
        BX       LR               ;; return
        CFI EndBlock cfiBlock7

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock8 Using cfiCommon0
        CFI NoFunction
        THUMB
??abs??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock8
        REQUIRE abs

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock9 Using cfiCommon1
        CFI Function abs
        ARM
//   68 int abs(int a){ return (a<0)?-a:a;}
abs:
        CMP      R0,#+0
        RSBMI    R0,R0,#+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock9

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock10 Using cfiCommon0
        CFI NoFunction
        THUMB
??fgets??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock10
        REQUIRE fgets
//   69 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock11 Using cfiCommon1
        CFI Function fgets
        ARM
//   70 int fgets(char *buf,int size,int fh){ return 0;} //fake!!!
fgets:
        MOV      R0,#+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock11

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock12 Using cfiCommon0
        CFI NoFunction
        THUMB
??printf??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock12
        REQUIRE printf

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock13 Using cfiCommon1
        CFI Function printf
        ARM
//   71 void printf(char *s,...){}  //fake!!!
printf:
        PUSH     {R1-R3}
        CFI CFA R13+12
        ADD      SP,SP,#+12
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock13

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock14 Using cfiCommon0
        CFI NoFunction
        THUMB
??strdup??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock14
        REQUIRE strdup

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock15 Using cfiCommon1
        CFI Function strdup
        ARM
//   72 char *strdup(char *s){ return s;}
strdup:
        BX       LR               ;; return
        CFI EndBlock cfiBlock15

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock16 Using cfiCommon0
        CFI NoFunction
        THUMB
??savefile??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock16
        REQUIRE savefile
//   73 
//   74 //void *memcpyrev(void *to, void *from, int size){
//   75 //  char *s=(char*)to+size, *ss=(char*)from+size;
//   76 //  while(--size>=0)
//   77 //    *--s=*--ss;
//   78 //  return to;
//   79 //}
//   80 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock17 Using cfiCommon1
        CFI Function savefile
        ARM
//   81 int savefile(char *fname, char *buf, int size){
savefile:
        PUSH     {R4-R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
//   82   int f,i;
//   83   if((f=fopen(fname,A_WriteOnly+A_BIN+A_Create+A_Truncate,P_WRITE,&err))==-1) return 0;
        LDR      R6,??savefile_0  ;; err
        MOV      R4,R1
        MOV      R5,R2
        MOV      R3,R6
        MOV      R2,#+256
        MOV      R1,#+1
        ORR      R1,R1,#0x8300
        SWI      +10
        MOV      R7,R0
        CMN      R7,#+1
        MOVEQ    R0,#+0
        POPEQ    {R4-R7,PC}
//   84   i=fwrite32(f,buf,size,&err); 
        MOV      R3,R6
        MOV      R2,R5
        MOV      R1,R4
        BL       fwrite32
        MOV      R4,R0
//   85   fclose(f,&err); 
        MOV      R1,R6
        MOV      R0,R7
        SWI      +13
//   86   return i;
        MOV      R0,R4
        POP      {R4-R7,PC}       ;; return
        DATA
??savefile_0:
        DC32     err
        CFI EndBlock cfiBlock17
//   87 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock18 Using cfiCommon0
        CFI NoFunction
        THUMB
??loadfile??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock18
        REQUIRE loadfile
//   88 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock19 Using cfiCommon1
        CFI Function loadfile
        ARM
//   89 char *loadfile(char *filename){ // Загрузить файл, распак-ть
loadfile:
        PUSH     {R5-R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI CFA R13+16
        SUB      SP,SP,#+4
        CFI CFA R13+20
//   90   int f; unsigned int err;  char *buf=0;
        MOV      R5,#+0
//   91   if((f=fopen(filename,A_ReadOnly+A_BIN,P_READ,&err))!=-1){
        MOV      R3,SP
        MOV      R2,#+128
        MOV      R1,#+32768
        SWI      +10
        MOV      R6,R0
        CMN      R6,#+1
        BEQ      ??loadfile_0
//   92     if(loadfilesize=lseek(f,0,2,&err,&err)){
        LDR      R7,??loadfile_1  ;; loadfilesize
        MOV      R0,SP
        PUSH     {R0}
        CFI CFA R13+24
        ADD      R3,SP,#+4
        MOV      R2,#+2
        MOV      R1,#+0
        MOV      R0,R6
        SWI      +15
        STR      R0,[R7, #+0]
        CMP      R0,#+0
        ADD      SP,SP,#+4
        CFI CFA R13+20
        BEQ      ??loadfile_2
//   93       buf=(char*)malloc(loadfilesize);
        SWI      +20
        MOV      R5,R0
//   94       lseek(f,0,0,&err,&err);
        MOV      R0,SP
        PUSH     {R0}
        CFI CFA R13+24
        ADD      R3,SP,#+4
        MOV      R2,#+0
        MOV      R1,#+0
        MOV      R0,R6
        SWI      +15
//   95       if(fread32(f,buf,loadfilesize,&err)!=loadfilesize){ mfree(buf); buf=0;}
        LDR      R2,[R7, #+0]
        ADD      R3,SP,#+4
        MOV      R1,R5
        MOV      R0,R6
        BL       fread32
        LDR      R1,[R7, #+0]
        ADD      SP,SP,#+4
        CFI CFA R13+20
        CMP      R0,R1
        BEQ      ??loadfile_2
        MOV      R0,R5
        SWI      +21
        MOV      R5,#+0
//   96     } fclose(f,&err);
??loadfile_2:
        MOV      R1,SP
        MOV      R0,R6
        SWI      +13
//   97 #ifdef UNPACK
//   98     extern char *un7z(char *buf);
//   99     extern char *unrar(char *buf);
//  100     extern char *unzip(char *buf);
//  101     if(buf && loadfilesize>4){
//  102 #ifndef NORAR
//  103       if(*(int *)buf=='!raR') buf=unrar(buf); //unrar
//  104       else
//  105 #endif      
//  106 #ifndef NOZIP
//  107       if(*(int*)buf==0x4034b50) buf=unzip(buf); //unzip
//  108       else
//  109 #endif
//  110 #ifndef NO7Z      
//  111       if(*(short*)buf=='z7') buf=un7z(buf); //un7z
//  112 #endif
//  113      ;      
//  114     }
//  115 //#ifdef SAVETEST
//  116 //  int out=fopen("0:\\ZBin\\123",A_WriteOnly+A_BIN+A_Create,P_WRITE,&err);
//  117 //  fwrite32(out,buf,loadfilesize,&err);
//  118 //  fclose(out,&err);
//  119 //#endif    
//  120     
//  121 #endif      
//  122   } return buf;
??loadfile_0:
        MOV      R0,R5
        POP      {R1,R5-R7,PC}
        DATA
??loadfile_1:
        DC32     loadfilesize
        CFI EndBlock cfiBlock19
//  123 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock20 Using cfiCommon0
        CFI NoFunction
        THUMB
??toup??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock20
        REQUIRE toup
//  124 
//  125 //void *memset(void *buf, int val, int size){
//  126 //  char *b=(char*)buf;
//  127 //  while(--size>=0) *b++=val; 
//  128 //  return buf;
//  129 //}
//  130 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock21 Using cfiCommon1
        CFI Function toup
        ARM
//  131 char *toup(char *str){			// К верхнему регистру
//  132   char *val=str;
toup:
        MOV      R1,R0
        LDRB     R2,[R1, #+0]
        CMP      R2,#+0
        BXEQ     LR
//  133   while(*val!=NULL){
//  134          if(*val>='a' && *val<='z')  *val-=' ';  
??toup_0:
        LDRB     R2,[R1, #+0]
        MOV      R3,R2
        CMP      R2,#+97
        BCC      ??toup_1
        CMP      R3,#+123
        BCS      ??toup_1
??toup_2:
        ADD      R3,R3,#+224
        B        ??toup_3
//  135     else if(*val>='а' && *val<='п')  *val-=' ';  
??toup_1:
        CMP      R3,#+224
        BCC      ??toup_4
        CMP      R3,#+240
        BCC      ??toup_2
//  136     else if(*val>='р' && *val<='я')  *val-= 80;  
??toup_4:
        CMP      R3,#+240
        ADDCS    R3,R3,#+176
??toup_3:
        STRB     R3,[R1], #+1
//  137     ++val;
//  138   }
        LDRB     R2,[R1, #+0]
        CMP      R2,#+0
        BNE      ??toup_0
//  139   return str;
        BX       LR               ;; return
        CFI EndBlock cfiBlock21
//  140 }  

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock22 Using cfiCommon0
        CFI NoFunction
        THUMB
??todown??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock22
        REQUIRE todown
//  141 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock23 Using cfiCommon1
        CFI Function todown
        ARM
//  142 char *todown(char *str){		// К нижнему регистру
//  143   char *val=str;
todown:
        MOV      R1,R0
        LDRB     R2,[R1, #+0]
        CMP      R2,#+0
        BXEQ     LR
//  144   while(*val!=NULL){
//  145          if(*val>='A' && *val<='Z')  *val+=' '; 
??todown_0:
        LDRB     R2,[R1, #+0]
        MOV      R3,R2
        CMP      R2,#+65
        BCC      ??todown_1
        CMP      R3,#+91
        BCS      ??todown_1
??todown_2:
        ADD      R3,R3,#+32
        B        ??todown_3
//  146     else if(*val>='А' && *val<='П')  *val+=' ';
??todown_1:
        CMP      R3,#+192
        BCC      ??todown_4
        CMP      R3,#+208
        BCC      ??todown_2
//  147     else if(*val>='Р' && *val<='Я')  *val+= 80; 
??todown_4:
        CMP      R3,#+208
        BCC      ??todown_3
        CMP      R3,#+224
        ADDCC    R3,R3,#+80
??todown_3:
        STRB     R3,[R1], #+1
//  148     ++val;
//  149   }
        LDRB     R2,[R1, #+0]
        CMP      R2,#+0
        BNE      ??todown_0
//  150   return str;
        BX       LR               ;; return
        CFI EndBlock cfiBlock23
//  151 }  

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock24 Using cfiCommon0
        CFI NoFunction
        THUMB
??isalth??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock24
        REQUIRE isalth
//  152 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock25 Using cfiCommon1
        CFI Function isalth
        ARM
//  153 int  isalth (unsigned char sym){	// Алфавитный символ ?
//  154   return ((sym>='A' && sym<='Z') || (sym>=(unsigned char)'А' && sym<=(unsigned char)'П')
//  155     || (sym>=(unsigned char)'Р' && sym<=(unsigned char)'Я'));}
isalth:
        CMP      R0,#+65
        BCC      ??isalth_0
        CMP      R0,#+91
        BCC      ??isalth_1
??isalth_0:
        CMP      R0,#+192
        BCC      ??isalth_2
        CMP      R0,#+208
        BCC      ??isalth_1
??isalth_2:
        CMP      R0,#+208
        BCC      ??isalth_3
        CMP      R0,#+224
        BCS      ??isalth_3
??isalth_1:
        MOV      R0,#+1
        BX       LR
??isalth_3:
        MOV      R0,#+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock25

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock26 Using cfiCommon0
        CFI NoFunction
        THUMB
??isval??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock26
        REQUIRE isval
//  156 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock27 Using cfiCommon1
        CFI Function isval
        ARM
//  157 int  isval (char sym){		// Символ является числом ?
//  158   return (sym>='0' && sym<='9');}
isval:
        CMP      R0,#+48
        BCC      ??isval_0
        CMP      R0,#+58
        MOVCC    R0,#+1
        BXCC     LR
??isval_0:
        MOV      R0,#+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock27

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock28 Using cfiCommon0
        CFI NoFunction
        THUMB
??strchrpos??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock28
        REQUIRE strchrpos
//  159 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock29 Using cfiCommon1
        CFI Function strchrpos
        ARM
//  160 int strchrpos(const char *s, int c){	// Позиция символа в строке (1-N, 0=нет)
strchrpos:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
        MOV      R4,R0
//  161   char *sptr=strchr(s,c);
        SWI      +24
//  162   return (sptr)?sptr-s+1:NULL;
        CMP      R0,#+0
        SUBNE    R0,R0,R4
        ADDNE    R0,R0,#+1
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock29
//  163 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock30 Using cfiCommon0
        CFI NoFunction
        THUMB
??emptystr??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock30
        REQUIRE emptystr
//  164   

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock31 Using cfiCommon1
        CFI Function emptystr
        ARM
//  165 int emptystr(char *str){		// Пустая ли строка
emptystr:
        B        ??emptystr_0
//  166   while(*str && (*str==' ' || *str==9)) ++str;
??emptystr_1:
        ADD      R0,R0,#+1
??emptystr_0:
        LDRB     R1,[R0, #+0]
        CMP      R1,#+0
        BEQ      ??emptystr_2
        CMP      R1,#+32
        CMPNE    R1,#+9
        BEQ      ??emptystr_1
//  167   return ((*str)?0:1);
??emptystr_2:
        CMP      R1,#+0
        MOVNE    R0,#+0
        BXNE     LR
        MOV      R0,#+1
        BX       LR               ;; return
        CFI EndBlock cfiBlock31
//  168 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock32 Using cfiCommon0
        CFI NoFunction
        THUMB
??alltrim??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock32
        REQUIRE alltrim
//  169 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock33 Using cfiCommon1
        CFI Function alltrim
        ARM
//  170 char  *alltrim (char *str){		// Удалить пробелы по бокам строки
//  171   char *s;
//  172   if(!*str) return str;
alltrim:
        LDRB     R1,[R0, #+0]
        CMP      R1,#+0
        BNE      ??alltrim_0
        BX       LR
//  173   while(*str==' ' || *str==9) ++str;
??alltrim_1:
        ADD      R0,R0,#+1
??alltrim_0:
        LDRB     R1,[R0, #+0]
        CMP      R1,#+32
        CMPNE    R1,#+9
        BEQ      ??alltrim_1
//  174   s=str;
        MOV      R1,R0
        LDRB     R2,[R1, #+0]
        CMP      R2,#+0
        BEQ      ??alltrim_2
//  175   while(*s) ++s;
??alltrim_3:
        LDRB     R2,[R1, #+1]!
        CMP      R2,#+0
        BNE      ??alltrim_3
//  176   while(s>str && (*(s-1)==' ' || *(s-1)==9)) --s;
??alltrim_2:
        CMP      R0,R1
        BCS      ??alltrim_4
        LDRB     R2,[R1, #-1]
        CMP      R2,#+32
        CMPNE    R2,#+9
        SUBEQ    R1,R1,#+1
        BEQ      ??alltrim_2
//  177   *s=NULL;
??alltrim_4:
        MOV      R2,#+0
        STRB     R2,[R1, #+0]
//  178   return str;
        BX       LR               ;; return
        CFI EndBlock cfiBlock33
//  179 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock34 Using cfiCommon0
        CFI NoFunction
        THUMB
??strcmpsize??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock34
        REQUIRE strcmpsize
//  180 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock35 Using cfiCommon1
        CFI Function strcmpsize
        ARM
//  181 int   strcmpsize (const char *s1,const char *s2,int size){ // Сравнить строки длины size
strcmpsize:
        PUSH     {R4}
        CFI R4 Frame(CFA, -4)
        CFI CFA R13+4
//  182   int i;
//  183   for(i=0;i<size && s1[i]==s2[i];i++);
        MOV      R3,#+0
        B        ??strcmpsize_0
??strcmpsize_1:
        LDRB     R12,[R3, +R0]
        LDRB     R4,[R3, +R1]
        CMP      R12,R4
        BNE      ??strcmpsize_2
        ADD      R3,R3,#+1
??strcmpsize_0:
        CMP      R3,R2
        BLT      ??strcmpsize_1
//  184     return (i==size)?NULL:s1[i]-s2[i];
        MOVEQ    R0,#+0
        BEQ      ??strcmpsize_3
??strcmpsize_2:
        LDRB     R0,[R3, +R0]
        LDRB     R1,[R3, +R1]
        SUB      R0,R0,R1
??strcmpsize_3:
        POP      {R4}
        CFI R4 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock35
//  185 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock36 Using cfiCommon0
        CFI NoFunction
        THUMB
??getint??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock36
        REQUIRE getint
//  186 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock37 Using cfiCommon1
        CFI Function getint
        ARM
//  187 int getint(void *ptr){ // Получить int
//  188   if((int)ptr & 3) return *(unsigned char*)ptr | *((unsigned char*)ptr+1)<<8\ 
getint:
        TST      R0,#0x3
        BEQ      ??getint_0
//  189     | *((unsigned char*)ptr+2)<<16 | *((unsigned char*)ptr+3)<<24;
        LDRB     R1,[R0, #+0]
        LDRB     R2,[R0, #+1]
        ORR      R1,R1,R2, LSL #+8
        LDRB     R2,[R0, #+2]
        LDRB     R0,[R0, #+3]
        ORR      R1,R1,R2, LSL #+16
        ORR      R0,R1,R0, LSL #+24
        BX       LR
//  190   else return *(int*)ptr;
??getint_0:
        LDR      R0,[R0, #+0]
        BX       LR               ;; return
        CFI EndBlock cfiBlock37
//  191 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock38 Using cfiCommon0
        CFI NoFunction
        THUMB
??get3int??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock38
        REQUIRE get3int
//  192 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock39 Using cfiCommon1
        CFI Function get3int
        ARM
//  193 int get3int(void *ptr){ // Получить 3int
//  194   return *(unsigned char*)ptr | *((unsigned char*)ptr+1)<<8 | *((unsigned char*)ptr+2)<<16; 
get3int:
        LDRB     R1,[R0, #+0]
        LDRB     R2,[R0, #+1]
        LDRB     R0,[R0, #+2]
        ORR      R1,R1,R2, LSL #+8
        ORR      R0,R1,R0, LSL #+16
        BX       LR               ;; return
        CFI EndBlock cfiBlock39
//  195 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock40 Using cfiCommon0
        CFI NoFunction
        THUMB
??getshort??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock40
        REQUIRE getshort
//  196 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock41 Using cfiCommon1
        CFI Function getshort
        ARM
//  197 short getshort(void *ptr){ // Получить short
//  198   if((int)ptr & 1) return *(unsigned char*)ptr | *((unsigned char*)ptr+1)<<8;
getshort:
        TST      R0,#0x1
        BEQ      ??getshort_0
        LDRB     R1,[R0, #+0]
        LDRB     R0,[R0, #+1]
        ORR      R0,R1,R0, LSL #+8
        MOV      R0,R0, LSL #+16
        MOV      R0,R0, ASR #+16
        BX       LR
//  199   else return *(short*)ptr;
??getshort_0:
        LDRSH    R0,[R0, #+0]
        BX       LR               ;; return
        CFI EndBlock cfiBlock41
//  200 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock42 Using cfiCommon0
        CFI NoFunction
        THUMB
??putint??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock42
        REQUIRE putint
//  201 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock43 Using cfiCommon1
        CFI Function putint
        ARM
//  202 void putint(void *ptr, int data){ // Записать int
//  203   if((int)ptr & 3){ *(char*)ptr=data; *((char*)ptr+1)=data>>8;
putint:
        TST      R0,#0x3
        BEQ      ??putint_0
        STRB     R1,[R0, #+0]
        ASR      R2,R1,#+8
        STRB     R2,[R0, #+1]
//  204     *((char*)ptr+2)=data>>16; *((char*)ptr+3)=data>>24;
        ASR      R2,R1,#+16
        STRB     R2,[R0, #+2]
        ASR      R1,R1,#+24
        STRB     R1,[R0, #+3]
        BX       LR
//  205   }else *(int*)ptr=data;
??putint_0:
        STR      R1,[R0, #+0]
//  206   
//  207 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock43

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock44 Using cfiCommon0
        CFI NoFunction
        THUMB
??putshort??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock44
        REQUIRE putshort
//  208  

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock45 Using cfiCommon1
        CFI Function putshort
        ARM
//  209 void putshort(void *ptr, short data){ // Записать short
//  210   if((int)ptr & 1){ *(char*)ptr=data; *((char*)ptr+1)=data>>8;
putshort:
        TST      R0,#0x1
        BEQ      ??putshort_0
        STRB     R1,[R0, #+0]
        ASR      R1,R1,#+8
        STRB     R1,[R0, #+1]
        BX       LR
//  211   }else *(short*)ptr=data;
??putshort_0:
        STRH     R1,[R0, #+0]
//  212 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock45

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock46 Using cfiCommon0
        CFI NoFunction
        THUMB
??bitblt??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock46
        REQUIRE bitblt
//  213 
//  214 #ifdef GRAPH
//  215 /*-----------------------------
//  216 смещ.	размер	имя
//  217 00	2	'BM'
//  218 02	4	Размер файла в байтах;
//  219 06	2	0
//  220 08	2	0
//  221 10	4	Смещение начала изображения в файле;
//  222 14	4	Размер этого заголовка, 40;
//  223 18	4	Ширина изображения в пикселях;
//  224 22	4	Высота изображения в пикселях;
//  225 26	2	Число плоскостей изображения, 1;
//  226 28	2	Бит на пиксел: 1,4,8 или 24;
//  227 30	4	Тип сжатия;
//  228 34	4	Размер сжатого изображения в байтах или 0;
//  229 38	4	Горизонтальное разрешение, в пикселях / на метр;
//  230 42	4	Вертикальное разрешение, в пикселях / на метр;
//  231 46	4	Количество используемых цветов;
//  232 50	4	Число "важных" цветов;
//  233 54	4*N	Карты цветов BGRР;
//  234 
//  235 BMP	заголовок 54 б + палитра 4*256;*/
//  236 
//  237 inline unsigned char rgb888tobyte(int color){
//  238   return ((color>>6)&3)|((color>>11)&0x1C)|((color>>16)&0xE0); }
//  239 
//  240 inline short rgb888toshort(int color){
//  241   return ((color>>3)&0x1f)|((color>>5)&0x7e0)|((color>>8)&0xf800); }
//  242 
//  243 inline unsigned char rgb565tobyte(short color){
//  244   return ((color>>3)&3)|((color>>6)&0x1C)|((color>>8)&0xE0); }
//  245 
//  246 inline short rgb565toshort(short color){
//  247   return color; }
//  248 
//  249 
//  250 int loadgraphsize=0;
//  251 #ifndef HIGHCOLOR
//  252   const int graphpoints=1;
//  253 #else  
//  254   const int graphpoints=2;
//  255 #endif
//  256 // Формат файла 2б х 2б у  далее точки (повернуты как надо, без выравнивания)
//  257 char *loadgraph(char *filename){ // Загрузить графику (распаковываем и перекодируем) #define HIGHCOLOR учесть
//  258   unsigned char *bmp=0, *buf=0, *pbuf, *pbmp, *ptr;
//  259   int *pal;
//  260   int sizex, sizey, bytepixel, pitch;
//  261   int i,j;
//  262   do{
//  263     if(!(bmp=(unsigned char*)
//  264 #ifndef NOLOAD
//  265     loadfile(filename)
//  266 #else
//  267     filename
//  268 #endif
//  269     )) break;
//  270     if(getshort(bmp)!='MB') break;
//  271     sizex=getint(bmp+18);
//  272     sizey=getint(bmp+22);
//  273     bytepixel=getshort(bmp+28)>>3;
//  274     if(!sizex || !sizey || bytepixel<1 || bytepixel>4) break;
//  275     pitch=sizex*bytepixel;
//  276     if(pitch&3) pitch+=4-(pitch&3);
//  277     if(!(buf=(unsigned char*)malloc(loadgraphsize=sizex*sizey*graphpoints+4))) break;
//  278     *(short*)buf=sizex; *(short*)(buf+2)=sizey; 
//  279     pbuf=buf+4;
//  280     ptr=bmp+getint(bmp+10)+sizey*pitch;
//  281 #ifndef HIGHCOLOR //1 byte
//  282     switch(bytepixel){
//  283     case 1: //8 -> 8
//  284       memcpy(pal=(int*)(bmp+52),bmp+54,*(short*)(bmp+50)?(*(short*)(bmp+50)<<2):1024);
//  285     for(j=0;j<sizey;j++){
//  286       pbmp=(ptr-=pitch);
//  287       for(i=0;i<sizex;i++){
//  288         *pbuf++=rgb888tobyte(pal[*pbmp++]);
//  289     }  } break;
//  290     case 2: //16 bit
//  291     for(j=0;j<sizey;j++){
//  292       pbmp=(ptr-=pitch);
//  293       for(i=0;i<sizex;i++){
//  294         *pbuf++=rgb565tobyte(*(short*)pbmp);
//  295         pbmp+=2;
//  296     }  } break;
//  297     case 3: //24 bit
//  298     for(j=0;j<sizey;j++){
//  299       pbmp=(ptr-=pitch);
//  300       for(i=0;i<sizex;i++){
//  301         *pbuf++=rgb888tobyte(get3int(pbmp));
//  302         pbmp+=3;
//  303     }  } break;
//  304     case 4: //32 bit
//  305     if((i=getint(bmp+10))&3){ //Выровнять данные на границу 4
//  306       j=i-(i&3);
//  307       memcpy(bmp+j, bmp+i, sizey*pitch);
//  308       ptr=bmp+j+sizey*pitch;
//  309     }
//  310     for(j=0;j<sizey;j++){
//  311       pbmp=(ptr-=pitch);
//  312       for(i=0;i<sizex;i++){
//  313         *pbuf++=rgb888tobyte(*(int*)pbmp);
//  314         pbmp+=4;
//  315     }  } break;
//  316  #else    // 2 byte
//  317     switch(bytepixel){
//  318     case 1: //8 -> 16
//  319     memcpy(pal=(int*)(bmp+52),bmp+54,*(short*)(bmp+50)?(*(short*)(bmp+50)<<2):1024);
//  320     for(j=0;j<sizey;j++){
//  321       pbmp=(ptr-=pitch);
//  322       for(i=0;i<sizex;i++){
//  323         *(short*)pbuf=rgb888toshort(pal[*pbmp++]);
//  324         pbuf+=2;
//  325     }  } break;
//  326     case 2: //16 bit
//  327     for(j=0;j<sizey;j++){
//  328       pbmp=(ptr-=pitch);
//  329       for(i=0;i<sizex;i++){
//  330         *(short*)pbuf=rgb565toshort(*(short*)pbmp);
//  331         pbmp+=2;
//  332         pbuf+=2;
//  333     }  } break;
//  334     case 3: //24 bit
//  335     for(j=0;j<sizey;j++){
//  336       pbmp=(ptr-=pitch);
//  337       for(i=0;i<sizex;i++){
//  338         *(short*)pbuf=rgb888toshort(get3int(pbmp));
//  339         pbmp+=3;
//  340         pbuf+=2;
//  341     }  } break;
//  342     case 4: //32 bit
//  343     if((i=getint(bmp+10))&3){ //Выровнять данные на границу 4
//  344       j=i-(i&3);
//  345       memcpy(bmp+j, bmp+i, sizey*pitch);
//  346       ptr=bmp+j+sizey*pitch;
//  347     }
//  348     for(j=0;j<sizey;j++){
//  349       pbmp=(ptr-=pitch);
//  350       for(i=0;i<sizex;i++){
//  351         *(short*)pbuf=rgb888toshort(*(int*)pbmp);
//  352         pbmp+=4;
//  353         pbuf+=2;
//  354     }  } break;
//  355 #endif    
//  356     }
//  357     mfree(bmp);
//  358     return (char*)buf;
//  359   }while(0);
//  360   if(bmp) mfree(bmp);
//  361   if(buf) mfree(buf);
//  362   return 0;
//  363 }
//  364 #endif
//  365 
//  366 // Вывести на экран в поз х,у картинку размером sizex,sizey с поз. в bmp х0,у0 и 
//  367 // прозрачным цветом (если<>0)  Флаги: 0x40 = всегда

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock47 Using cfiCommon1
        CFI Function bitblt
        ARM
//  368 void bitblt(void *screen, void *bmp, int x, int y, int sizex, int sizey, int x0, int y0,  int colormask, int flags){
bitblt:
        PUSH     {R0,R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+40
//  369   int i,j, sizexx, bmpx, bmpy;
//  370   // Проверка на дурака
//  371   if(!screen || !bmp || x>=width || y>=height) return;
        LDR      R6,[SP, #+0]
        LDR      R4,[SP, #+40]
        LDR      R5,[SP, #+44]
        LDR      R12,[SP, #+48]
        LDR      LR,[SP, #+52]
        LDR      R0,[SP, #+56]
        CMP      R6,#+0
        CMPNE    R1,#+0
        POPEQ    {R0,R4-R11,PC}
        LDR      R6,??bitblt_0    ;; width
        LDR      R8,[R6, #+0]
        CMP      R2,R8
        POPGE    {R0,R4-R11,PC}
        LDR      R7,??bitblt_0+0x4  ;; height
        LDR      R9,[R7, #+0]
        CMP      R3,R9
        POPGE    {R0,R4-R11,PC}
//  372   bmpx=*(short*)bmp; 
        LDRSH    R7,[R1, #+0]
//  373   bmpy=*(short*)((char*)bmp+2);
        LDRSH    R10,[R1, #+2]
//  374   if(!sizex) sizex=bmpx;
        CMP      R4,#+0
        MOVEQ    R4,R7
//  375   if(!sizey) sizey=bmpy;
        CMP      R5,#+0
        MOVEQ    R5,R10
//  376   
//  377   if(x<0){ sizex+=x; x0-=x; x=0;}
        CMP      R2,#+0
        ADDMI    R4,R2,R4
        SUBMI    R12,R12,R2
        MOVMI    R2,#+0
//  378   if(y<0){ sizey+=y0; y0-=y; y=0;}
        CMP      R3,#+0
        ADDMI    R5,LR,R5
        SUBMI    LR,LR,R3
        MOVMI    R3,#+0
//  379   if(x0<0 || x0>=bmpx || y0<0 || y0>=bmpy || sizex<=0 || sizey<=0) return;
        CMP      R12,#+0
        POPMI    {R0,R4-R11,PC}
        CMP      R12,R7
        POPGE    {R0,R4-R11,PC}
        CMP      LR,#+0
        POPMI    {R0,R4-R11,PC}
        CMP      LR,R10
        POPGE    {R0,R4-R11,PC}
        CMP      R4,#+1
        CMPGE    R5,#+1
        POPLT    {R0,R4-R11,PC}
//  380   
//  381   if(x+sizex>=width) sizex=width-x;
        ADD      R11,R4,R2
        CMP      R11,R8
        SUBGE    R4,R8,R2
//  382   if(x0+sizex>=bmpx) sizex=bmpx-x0;
        ADD      R11,R4,R12
        CMP      R11,R7
        SUBGE    R4,R7,R12
//  383   if(y+sizey>=height) sizey=height-y;
        ADD      R11,R5,R3
        CMP      R11,R9
        SUBGE    R5,R9,R3
//  384   if(y0+sizey>=bmpy) sizey=bmpy-y0;
//  385   
//  386 #ifndef HIGHCOLOR
//  387   char *scr=(char*)screen, *pic=(char*)bmp+4;
//  388   sizexx=sizex;
//  389 #else
//  390   short *scr=(short*)screen, *pic=(short*)((char*)bmp+4);
//  391   sizexx=sizex<<1;
//  392 #endif
//  393   scr+=width*y+x;
        MLA      R2,R3,R8,R2
        LDR      R3,[SP, #+0]
        ADD      R9,R5,LR
        ADD      R8,R2,R3
//  394   pic+=bmpx*y0 + x0;
        MLA      R2,LR,R7,R12
        CMP      R9,R10
        SUBGE    R5,R10,LR
        ADD      R1,R1,#+4
        ADD      R9,R2,R1
//  395   if(colormask || (flags&0x40)){
        CMP      R0,#+0
        LDREQ    R1,[SP, #+60]
        TSTEQ    R1,#0x40
        BEQ      ??bitblt_1
//  396     for(j=0; j<sizey; j++, scr+=width-sizex, pic+=bmpx-sizex)
        MOV      R10,#+0
        CMP      R5,#+1
        BGE      ??bitblt_2
        POP      {R0,R4-R11,PC}
//  397       for(i=0; i<sizex; i++, scr++, pic++)
//  398         if(*pic!=
//  399 #ifndef HIGHCOLOR
//  400   (char)
//  401 #else
//  402  (short)             
//  403 #endif
//  404    colormask) *scr=*pic;
??bitblt_3:
        LDRB     R1,[R9, #+0]
        MOV      R3,R0, LSL #+24
        ADD      R2,R2,#+1
        CMP      R1,R3, LSR #+24
        STRBNE   R1,[R8, #+0]
        ADD      R8,R8,#+1
        ADD      R9,R9,#+1
??bitblt_4:
        CMP      R2,R4
        BLT      ??bitblt_3
??bitblt_5:
        LDR      R1,[R6, #+0]
        ADD      R10,R10,#+1
        SUB      R1,R1,R4
        ADD      R8,R1,R8
        SUB      R1,R7,R4
        ADD      R9,R1,R9
??bitblt_2:
        CMP      R10,R5
        POPGE    {R0,R4-R11,PC}
        MOV      R2,#+0
        CMP      R4,#+1
        BGE      ??bitblt_4
        B        ??bitblt_5
//  405   }else{
//  406     for(j=0; j<sizey; j++, scr+=width, pic+=bmpx)
??bitblt_1:
        MOV      R10,#+0
        CMP      R5,#+1
        BGE      ??bitblt_6
        POP      {R0,R4-R11,PC}
//  407       memcpy(scr,pic,sizexx);
??bitblt_7:
        MOV      R2,R4
        MOV      R1,R9
        MOV      R0,R8
        SWI      +286
        LDR      R0,[R6, #+0]
        ADD      R10,R10,#+1
        ADD      R8,R0,R8
        ADD      R9,R7,R9
??bitblt_6:
        CMP      R10,R5
        BLT      ??bitblt_7
        POP      {R0,R4-R11,PC}   ;; return
        DATA
??bitblt_0:
        DC32     width
        DC32     height
        CFI EndBlock cfiBlock47
//  408   }
//  409 }

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_Z:
        DCD      sfe(DATA_Z) - sfb(DATA_Z), sfb(DATA_Z), sfb(DATA_Z)

        END
//  410 
//  411 
//  412 //void debsave();
//  413 //char debarea[10000], *deb=debarea;
//  414 ////unsigned int err;
//  415 //
//  416 //void debsave(){
//  417 //  int f;
//  418 //  if(deb==debarea) return;
//  419 //  f=fopen("0:\\ZBin\\nes\\log",A_ReadWrite+A_BIN+A_Create+A_Append,P_READ+P_WRITE,&err);
//  420 //  if (f==-1) return;
//  421 //  fwrite32(f,(unsigned char*)debarea,deb-debarea,&err);
//  422 //  fclose(f,&err);
//  423 //  deb=debarea;
//  424 //}
//  425 //
//  426 //void debug(int num, int val){
//  427 //  if(deb-debarea<9800){
//  428 //  sprintf(deb,"\n%d = %d",num,val);
//  429 //  deb+=strlen(deb);
//  430 //  }
//  431 //}
//  432 
//  433 //    void memcpy3(signed char *to, signed char *from, int size){
//  434 //      to+=size;
//  435 //      from+=size;
//  436 //      while(--size>=0){
//  437 //        *--to=*--from;
//  438 //      }
//  439 //    }
//  440 //
//  441 //    void memcpy4(signed char *to, signed char *from, int size){
//  442 //      while(--size>=0){
//  443 //        *to++=*from++;
//  444 //      }
//  445 //    }
//  446     
//  447 //    void memmove(signed char *to, signed char *from, int size){
//  448 //      if(from<to)
//  449 //        if(from+size>=to) memcpy3(to,from,size);
//  450 //        else memcpy4(to,from,size);
//  451 //      else memcpy4(to,from,size);
//  452 //    }
//  453 
//  454 #ifndef DOS
//  455 /*
//  456     void *memmove(void *to, void *from, int size){
//  457       if((char*)from<(char*)to && (char*)from+size>=(char*)to) return memmov(to,from,size); //memcpyrev
//  458       return memcpy(to,from,size);
//  459     }
//  460 */
//  461 #endif
//  462 
//  463 //char *strcpy2(char *to, char *from){
//  464 //  char *res=to--;
//  465 //  do{ *++to=*from++;
//  466 //  }while(*to);
//  467 //  return res;
//  468 //}
//  469 //
//  470 //char *strcat2(char *to, char *from){
//  471 //  char *res=to--;
//  472 //  while(*++to); --to;
//  473 //  do{ *++to=*from++;
//  474 //  }while(*to);
//  475 //  return res;
//  476 //}
// 
// 1 812 bytes in segment CODE
//     8 bytes in segment DATA_Z
//    12 bytes in segment INITTAB
// 
// 1 716 bytes of CODE memory (+ 108 bytes shared)
//     8 bytes of DATA memory
//
//Errors: none
//Warnings: none
