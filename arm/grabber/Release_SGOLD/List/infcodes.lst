##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    19/Jan/2011  13:20:27 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\grabber\zlib\infcodes.c                       #
#    Command line    =  C:\arm\grabber\zlib\infcodes.c -lC                   #
#                       C:\arm\grabber\Release_SGOLD\List\ -o                #
#                       C:\arm\grabber\Release_SGOLD\Obj\ -s9 --no_unroll    #
#                       --no_clustering --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --fpu None --dlib_config "C:\arm2\Embedded           #
#                       Workbench 4.0 Evaluation\ARM\LIB\dl5tpainl8n.h" -I   #
#                       "C:\arm2\Embedded Workbench 4.0                      #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  C:\arm\grabber\Release_SGOLD\List\infcodes.lst       #
#    Object file     =  C:\arm\grabber\Release_SGOLD\Obj\infcodes.r79        #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\grabber\zlib\infcodes.c
      1          /* infcodes.c -- process literals and length/distance pairs
      2           * Copyright (C) 1995-2002 Mark Adler
      3           * For conditions of distribution and use, see copyright notice in zlib.h 
      4           */
      5          
      6          #include "zutil.h"
      7          #include "inftrees.h"
      8          #include "infblock.h"
      9          #include "infcodes.h"
     10          #include "infutil.h"
     11          #include "inffast.h"
     12          
     13          /* simplify the use of the inflate_huft type with some defines */
     14          #define exop word.what.Exop
     15          #define bits word.what.Bits
     16          
     17          typedef enum {        /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
     18                START,    /* x: set up for LEN */
     19                LEN,      /* i: get length/literal/eob next */
     20                LENEXT,   /* i: getting length extra (have base) */
     21                DIST,     /* i: get distance next */
     22                DISTEXT,  /* i: getting distance extra */
     23                COPY,     /* o: copying bytes in window, waiting for space */
     24                LIT,      /* o: got literal, waiting for output space */
     25                WASH,     /* o: got eob, possibly still output waiting */
     26                END,      /* x: got eob and all data flushed */
     27                BADCODE}  /* x: got error */
     28          inflate_codes_mode;
     29          
     30          /* inflate codes private state */
     31          struct inflate_codes_state {
     32          
     33            /* mode */
     34            inflate_codes_mode mode;      /* current inflate_codes mode */
     35          
     36            /* mode dependent information */
     37            uInt len;
     38            union {
     39              struct {
     40                inflate_huft *tree;       /* pointer into tree */
     41                uInt need;                /* bits needed */
     42              } code;             /* if LEN or DIST, where in tree */
     43              uInt lit;           /* if LIT, literal */
     44              struct {
     45                uInt get;                 /* bits to get for extra */
     46                uInt dist;                /* distance back to copy from */
     47              } copy;             /* if EXT or COPY, where and how much */
     48            } sub;                /* submode */
     49          
     50            /* mode independent information */
     51            Byte lbits;           /* ltree bits decoded per branch */
     52            Byte dbits;           /* dtree bits decoder per branch */
     53            inflate_huft *ltree;          /* literal/length/eob tree */
     54            inflate_huft *dtree;          /* distance tree */
     55          
     56          };
     57          
     58          

   \                                 In segment CODE, align 4, keep-with-next
     59          inflate_codes_statef *inflate_codes_new(bl, bd, tl, td, z)
     60          uInt bl, bd;
     61          inflate_huft *tl;
     62          inflate_huft *td; /* need separate declaration for Borland C++ */
     63          z_streamp z;
     64          {
   \                     inflate_codes_new:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0370A0E1           MOV      R7,R3
   \   00000010   14309DE5           LDR      R3,[SP, #+20]
   \   00000014   0260A0E1           MOV      R6,R2
     65            inflate_codes_statef *c;
     66          
     67            if ((c = (inflate_codes_statef *)
     68                 ZALLOC(z,1,sizeof(struct inflate_codes_state))) != Z_NULL)
   \   00000018   280093E5           LDR      R0,[R3, #+40]
   \   0000001C   203093E5           LDR      R3,[R3, #+32]
   \   00000020   1C20A0E3           MOV      R2,#+28
   \   00000024   0110A0E3           MOV      R1,#+1
   \   00000028   33FF2FE1           BLX      R3
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   F080BD08           POPEQ    {R4-R7,PC}
     69            {
     70              c->mode = START;
   \   00000034   0010A0E3           MOV      R1,#+0
   \   00000038   0010C0E5           STRB     R1,[R0, #+0]
     71              c->lbits = (Byte)bl;
   \   0000003C   1040C0E5           STRB     R4,[R0, #+16]
     72              c->dbits = (Byte)bd;
   \   00000040   1150C0E5           STRB     R5,[R0, #+17]
     73              c->ltree = tl;
   \   00000044   146080E5           STR      R6,[R0, #+20]
     74              c->dtree = td;
   \   00000048   187080E5           STR      R7,[R0, #+24]
     75              Tracev((stderr, "inflate:       codes new\n"));
     76            }
     77            return c;
   \   0000004C   F080BDE8           POP      {R4-R7,PC}       ;; return
     78          }
     79          
     80          

   \                                 In segment CODE, align 4, keep-with-next
     81          int inflate_codes(s, z, r)
     82          inflate_blocks_statef *s;
     83          z_streamp z;
     84          int r;
     85          {
   \                     inflate_codes:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   1CD04DE2           SUB      SP,SP,#+28
   \   00000008   0040A0E1           MOV      R4,R0
     86            uInt j;               /* temporary storage */
     87            inflate_huft *t;      /* temporary pointer */
     88            uInt e;               /* extra bits or operation */
     89            uLong b;              /* bit buffer */
     90            uInt k;               /* bits in bit buffer */
     91            Bytef *p;             /* input data pointer */
     92            uInt n;               /* bytes available there */
     93            Bytef *q;             /* output window write pointer */
     94            uInt m;               /* bytes to end of window or read pointer */
     95            Bytef *f;             /* pointer to copy strings from */
     96            inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */
     97          
     98            /* copy input/output information to locals (UPDATE macro restores) */
     99            LOAD
   \   0000000C   300094E5           LDR      R0,[R4, #+48]
   \   00000010   046094E5           LDR      R6,[R4, #+4]
   \   00000014   209094E5           LDR      R9,[R4, #+32]
   \   00000018   1CA094E5           LDR      R10,[R4, #+28]
   \   0000001C   0150A0E1           MOV      R5,R1
   \   00000020   341094E5           LDR      R1,[R4, #+52]
   \   00000024   007095E5           LDR      R7,[R5, #+0]
   \   00000028   048095E5           LDR      R8,[R5, #+4]
   \   0000002C   000051E1           CMP      R1,R0
   \   00000030   2C009425           LDRCS    R0,[R4, #+44]
   \   00000034   01004020           SUBCS    R0,R0,R1
   \   00000038   01004030           SUBCC    R0,R0,R1
   \   0000003C   01004032           SUBCC    R0,R0,#+1
   \   00000040   000000EA           B        ??inflate_codes_1
    100          
    101            /* process input and output based on current state */
    102            while (1) switch (c->mode)
    103            {             /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
    104              case START:         /* x: set up for LEN */
    105          #ifndef SLOW
    106                if (m >= 258 && n >= 10)
    107                {
    108                  UPDATE
    109                  r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);
    110                  LOAD
    111                  if (r != Z_OK)
    112                  {
    113                    c->mode = r == Z_STREAM_END ? WASH : BADCODE;
   \                     ??inflate_codes_2:
   \   00000044   0030C6E5           STRB     R3,[R6, #+0]
    114                    break;
   \                     ??inflate_codes_1:
   \   00000048   0030D6E5           LDRB     R3,[R6, #+0]
   \   0000004C   090053E3           CMP      R3,#+9
   \   00000050   8101008A           BHI      ??inflate_codes_3
   \   00000054   02BF8FE2           ADR      R11,??inflate_codes_0
   \   00000058   8330A0E1           MOV      R3,R3, LSL #+1
   \   0000005C   B3B09BE1           LDRH     R11,[R11, R3]
   \   00000060   0BF18FE0           ADD      PC,PC,R11, LSL #+2
   \                     ??inflate_codes_0:
   \   00000064   040035007100       DC16     +4,+53,+113,+187
   \              BB00        
   \   0000006C   E30003015B00       DC16     +227,+259,+91,+126
   \              7E00        
   \   00000074   71019300           DC16     +369,+147
   \                     ??inflate_codes_4:
   \   00000078   0230A0E3           MOV      R3,#+2
   \   0000007C   403F83E3           ORR      R3,R3,#0x100
   \   00000080   030050E1           CMP      R0,R3
   \   00000084   0A005823           CMPCS    R8,#+10
   \   00000088   2500003A           BCC      ??inflate_codes_5
   \   0000008C   209084E5           STR      R9,[R4, #+32]
   \   00000090   1CA084E5           STR      R10,[R4, #+28]
   \   00000094   048085E5           STR      R8,[R5, #+4]
   \   00000098   080095E5           LDR      R0,[R5, #+8]
   \   0000009C   002095E5           LDR      R2,[R5, #+0]
   \   000000A0   000087E0           ADD      R0,R7,R0
   \   000000A4   020040E0           SUB      R0,R0,R2
   \   000000A8   080085E5           STR      R0,[R5, #+8]
   \   000000AC   007085E5           STR      R7,[R5, #+0]
   \   000000B0   341084E5           STR      R1,[R4, #+52]
   \   000000B4   0500A0E1           MOV      R0,R5
   \   000000B8   01002DE9           PUSH     {R0}
   \   000000BC   0400A0E1           MOV      R0,R4
   \   000000C0   01002DE9           PUSH     {R0}
   \   000000C4   1110D6E5           LDRB     R1,[R6, #+17]
   \   000000C8   183096E5           LDR      R3,[R6, #+24]
   \   000000CC   142096E5           LDR      R2,[R6, #+20]
   \   000000D0   1000D6E5           LDRB     R0,[R6, #+16]
   \   000000D4   ........           _BLF     inflate_fast,??inflate_fast??rA
   \   000000D8   341094E5           LDR      R1,[R4, #+52]
   \   000000DC   007095E5           LDR      R7,[R5, #+0]
   \   000000E0   048095E5           LDR      R8,[R5, #+4]
   \   000000E4   209094E5           LDR      R9,[R4, #+32]
   \   000000E8   1CA094E5           LDR      R10,[R4, #+28]
   \   000000EC   0020A0E1           MOV      R2,R0
   \   000000F0   300094E5           LDR      R0,[R4, #+48]
   \   000000F4   08D08DE2           ADD      SP,SP,#+8
   \   000000F8   000051E1           CMP      R1,R0
   \   000000FC   2C009425           LDRCS    R0,[R4, #+44]
   \   00000100   01004030           SUBCC    R0,R0,R1
   \   00000104   01004032           SUBCC    R0,R0,#+1
   \   00000108   01004020           SUBCS    R0,R0,R1
   \   0000010C   000052E3           CMP      R2,#+0
   \   00000110   0300000A           BEQ      ??inflate_codes_5
   \   00000114   010052E3           CMP      R2,#+1
   \   00000118   0930A013           MOVNE    R3,#+9
   \   0000011C   0730A003           MOVEQ    R3,#+7
   \   00000120   C7FFFFEA           B        ??inflate_codes_2
    115                  }
    116                }
    117          #endif /* !SLOW */
    118                c->sub.code.need = c->lbits;
   \                     ??inflate_codes_5:
   \   00000124   1030D6E5           LDRB     R3,[R6, #+16]
   \   00000128   0C3086E5           STR      R3,[R6, #+12]
    119                c->sub.code.tree = c->ltree;
   \   0000012C   143096E5           LDR      R3,[R6, #+20]
   \   00000130   083086E5           STR      R3,[R6, #+8]
    120                c->mode = LEN;
   \   00000134   0130A0E3           MOV      R3,#+1
   \   00000138   0030C6E5           STRB     R3,[R6, #+0]
    121              case LEN:           /* i: get length/literal/eob next */
    122                j = c->sub.code.need;
   \                     ??inflate_codes_6:
   \   0000013C   0C3096E5           LDR      R3,[R6, #+12]
   \   00000140   040000EA           B        ??inflate_codes_7
    123                NEEDBITS(j)
   \                     ??inflate_codes_8:
   \   00000144   ........           LDRB     R11,[R7], #+1
   \   00000148   0020A0E3           MOV      R2,#+0
   \   0000014C   018048E2           SUB      R8,R8,#+1
   \   00000150   1B9A89E1           ORR      R9,R9,R11, LSL R10
   \   00000154   08A08AE2           ADD      R10,R10,#+8
   \                     ??inflate_codes_7:
   \   00000158   03005AE1           CMP      R10,R3
   \   0000015C   0D00002A           BCS      ??inflate_codes_9
   \   00000160   000058E3           CMP      R8,#+0
   \   00000164   F6FFFF1A           BNE      ??inflate_codes_8
   \   00000168   209084E5           STR      R9,[R4, #+32]
   \   0000016C   1CA084E5           STR      R10,[R4, #+28]
   \   00000170   0000A0E3           MOV      R0,#+0
   \   00000174   040085E5           STR      R0,[R5, #+4]
   \                     ??inflate_codes_10:
   \   00000178   080095E5           LDR      R0,[R5, #+8]
   \   0000017C   003095E5           LDR      R3,[R5, #+0]
   \   00000180   000087E0           ADD      R0,R7,R0
   \   00000184   030040E0           SUB      R0,R0,R3
   \   00000188   080085E5           STR      R0,[R5, #+8]
   \   0000018C   007085E5           STR      R7,[R5, #+0]
   \   00000190   341084E5           STR      R1,[R4, #+52]
   \   00000194   3B0100EA           B        ??inflate_codes_11
    124                t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
   \                     ??inflate_codes_9:
   \   00000198   FCB49FE5           LDR      R11,??inflate_codes_12  ;; inflate_mask
   \   0000019C   03319BE7           LDR      R3,[R11, +R3, LSL #+2]
   \   000001A0   08B096E5           LDR      R11,[R6, #+8]
   \   000001A4   093003E0           AND      R3,R3,R9
   \   000001A8   83318BE0           ADD      R3,R11,R3, LSL #+3
    125                DUMPBITS(t->bits)
   \   000001AC   01B0D3E5           LDRB     R11,[R3, #+1]
   \   000001B0   399BA0E1           LSR      R9,R9,R11
   \   000001B4   0BA04AE0           SUB      R10,R10,R11
    126                e = (uInt)(t->exop);
   \   000001B8   00B0D3E5           LDRB     R11,[R3, #+0]
    127                if (e == 0)               /* literal */
   \   000001BC   00005BE3           CMP      R11,#+0
   \   000001C0   1100001A           BNE      ??inflate_codes_13
    128                {
    129                  c->sub.lit = t->base;
   \   000001C4   043093E5           LDR      R3,[R3, #+4]
   \   000001C8   083086E5           STR      R3,[R6, #+8]
    130                  Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
    131                           "inflate:         literal '%c'\n" :
    132                           "inflate:         literal 0x%02x\n", t->base));
    133                  c->mode = LIT;
   \   000001CC   0630A0E3           MOV      R3,#+6
   \   000001D0   0030C6E5           STRB     R3,[R6, #+0]
    134                  break;
    135                }
    136                if (e & 16)               /* length */
    137                {
    138                  c->sub.copy.get = e & 15;
    139                  c->len = t->base;
    140                  c->mode = LENEXT;
    141                  break;
    142                }
    143                if ((e & 64) == 0)        /* next table */
    144                {
    145                  c->sub.code.need = e;
    146                  c->sub.code.tree = t + t->base;
    147                  break;
    148                }
    149                if (e & 32)               /* end of block */
    150                {
    151                  Tracevv((stderr, "inflate:         end of block\n"));
    152                  c->mode = WASH;
    153                  break;
    154                }
    155                c->mode = BADCODE;        /* invalid code */
    156                z->msg = (char*)"invalid literal/length code";
    157                r = Z_DATA_ERROR;
    158                LEAVE
    159              case LENEXT:        /* i: getting length extra (have base) */
    160                j = c->sub.copy.get;
    161                NEEDBITS(j)
    162                c->len += (uInt)b & inflate_mask[j];
    163                DUMPBITS(j)
    164                c->sub.code.need = c->dbits;
    165                c->sub.code.tree = c->dtree;
    166                Tracevv((stderr, "inflate:         length %u\n", c->len));
    167                c->mode = DIST;
    168              case DIST:          /* i: get distance next */
    169                j = c->sub.code.need;
    170                NEEDBITS(j)
    171                t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
    172                DUMPBITS(t->bits)
    173                e = (uInt)(t->exop);
    174                if (e & 16)               /* distance */
    175                {
    176                  c->sub.copy.get = e & 15;
    177                  c->sub.copy.dist = t->base;
    178                  c->mode = DISTEXT;
    179                  break;
    180                }
    181                if ((e & 64) == 0)        /* next table */
    182                {
    183                  c->sub.code.need = e;
    184                  c->sub.code.tree = t + t->base;
    185                  break;
    186                }
    187                c->mode = BADCODE;        /* invalid code */
    188                z->msg = (char*)"invalid distance code";
    189                r = Z_DATA_ERROR;
    190                LEAVE
    191              case DISTEXT:       /* i: getting distance extra */
    192                j = c->sub.copy.get;
    193                NEEDBITS(j)
    194                c->sub.copy.dist += (uInt)b & inflate_mask[j];
    195                DUMPBITS(j)
    196                Tracevv((stderr, "inflate:         distance %u\n", c->sub.copy.dist));
    197                c->mode = COPY;
    198              case COPY:          /* o: copying bytes in window, waiting for space */
    199                f = q - c->sub.copy.dist;
    200                while (f < s->window)             /* modulo window size-"while" instead */
    201                  f += s->end - s->window;        /* of "if" handles invalid distances */
    202                while (c->len)
    203                {
    204                  NEEDOUT
    205                  OUTBYTE(*f++)
    206                  if (f == s->end)
    207                    f = s->window;
    208                  c->len--;
    209                }
    210                c->mode = START;
    211                break;
    212              case LIT:           /* o: got literal, waiting for output space */
    213                NEEDOUT
   \                     ??inflate_codes_14:
   \   000001D4   000050E3           CMP      R0,#+0
   \   000001D8   0B01001A           BNE      ??inflate_codes_15
   \   000001DC   2C0094E5           LDR      R0,[R4, #+44]
   \   000001E0   000051E1           CMP      R1,R0
   \   000001E4   EB00001A           BNE      ??inflate_codes_16
   \   000001E8   283094E5           LDR      R3,[R4, #+40]
   \   000001EC   30B094E5           LDR      R11,[R4, #+48]
   \   000001F0   0B0053E1           CMP      R3,R11
   \   000001F4   E700000A           BEQ      ??inflate_codes_16
   \   000001F8   0310A0E1           MOV      R1,R3
   \   000001FC   03004020           SUBCS    R0,R0,R3
   \   00000200   03004B30           SUBCC    R0,R11,R3
   \   00000204   01004032           SUBCC    R0,R0,#+1
   \   00000208   E00000EA           B        ??inflate_codes_17
   \                     ??inflate_codes_13:
   \   0000020C   10001BE3           TST      R11,#0x10
   \   00000210   0700000A           BEQ      ??inflate_codes_18
   \   00000214   0FB00BE2           AND      R11,R11,#0xF
   \   00000218   08B086E5           STR      R11,[R6, #+8]
   \   0000021C   043093E5           LDR      R3,[R3, #+4]
   \   00000220   043086E5           STR      R3,[R6, #+4]
   \   00000224   0230A0E3           MOV      R3,#+2
   \   00000228   0030C6E5           STRB     R3,[R6, #+0]
   \                     ??inflate_codes_19:
   \   0000022C   083096E5           LDR      R3,[R6, #+8]
   \   00000230   300000EA           B        ??inflate_codes_20
   \                     ??inflate_codes_18:
   \   00000234   40001BE3           TST      R11,#0x40
   \   00000238   0400001A           BNE      ??inflate_codes_21
   \                     ??inflate_codes_22:
   \   0000023C   0CB086E5           STR      R11,[R6, #+12]
   \   00000240   04B093E5           LDR      R11,[R3, #+4]
   \   00000244   8B3183E0           ADD      R3,R3,R11, LSL #+3
   \   00000248   083086E5           STR      R3,[R6, #+8]
   \   0000024C   7DFFFFEA           B        ??inflate_codes_1
   \                     ??inflate_codes_21:
   \   00000250   20001BE3           TST      R11,#0x20
   \   00000254   1200000A           BEQ      ??inflate_codes_23
   \   00000258   0700A0E3           MOV      R0,#+7
   \   0000025C   0000C6E5           STRB     R0,[R6, #+0]
    214                OUTBYTE(c->sub.lit)
    215                c->mode = START;
    216                break;
    217              case WASH:          /* o: got eob, possibly more output */
    218                if (k > 7)        /* return unused byte, if any */
   \                     ??inflate_codes_24:
   \   00000260   08005AE3           CMP      R10,#+8
    219                {
    220                  Assert(k < 16, "inflate_codes grabbed too many bytes")
    221                  k -= 8;
   \   00000264   08A04A22           SUBCS    R10,R10,#+8
    222                  n++;
   \   00000268   01808822           ADDCS    R8,R8,#+1
    223                  p--;            /* can always return one */
   \   0000026C   01704722           SUBCS    R7,R7,#+1
    224                }
    225                FLUSH
   \   00000270   341084E5           STR      R1,[R4, #+52]
   \   00000274   0510A0E1           MOV      R1,R5
   \   00000278   0400A0E1           MOV      R0,R4
   \   0000027C   ........           _BLF     inflate_flush,??inflate_flush??rA
   \   00000280   341094E5           LDR      R1,[R4, #+52]
   \   00000284   0020A0E1           MOV      R2,R0
    226                if (s->read != s->write)
   \   00000288   300094E5           LDR      R0,[R4, #+48]
   \   0000028C   010050E1           CMP      R0,R1
   \   00000290   E300000A           BEQ      ??inflate_codes_25
    227                  LEAVE
   \   00000294   209084E5           STR      R9,[R4, #+32]
   \   00000298   1CA084E5           STR      R10,[R4, #+28]
   \   0000029C   048085E5           STR      R8,[R5, #+4]
   \   000002A0   B4FFFFEA           B        ??inflate_codes_10
   \                     ??inflate_codes_23:
   \   000002A4   0900A0E3           MOV      R0,#+9
   \   000002A8   0000C6E5           STRB     R0,[R6, #+0]
   \   000002AC   EC039FE5           LDR      R0,??inflate_codes_12+0x4  ;; `?<Constant "invalid literal/lengt...">`
   \                     ??inflate_codes_26:
   \   000002B0   180085E5           STR      R0,[R5, #+24]
   \                     ??inflate_codes_27:
   \   000002B4   209084E5           STR      R9,[R4, #+32]
   \   000002B8   1CA084E5           STR      R10,[R4, #+28]
   \   000002BC   048085E5           STR      R8,[R5, #+4]
   \   000002C0   080095E5           LDR      R0,[R5, #+8]
   \   000002C4   002095E5           LDR      R2,[R5, #+0]
   \   000002C8   000087E0           ADD      R0,R7,R0
   \   000002CC   020040E0           SUB      R0,R0,R2
   \   000002D0   080085E5           STR      R0,[R5, #+8]
   \   000002D4   007085E5           STR      R7,[R5, #+0]
   \   000002D8   341084E5           STR      R1,[R4, #+52]
   \   000002DC   0220E0E3           MVN      R2,#+2
   \   000002E0   E80000EA           B        ??inflate_codes_11
   \                     ??inflate_codes_28:
   \   000002E4   ........           LDRB     R11,[R7], #+1
   \   000002E8   0020A0E3           MOV      R2,#+0
   \   000002EC   018048E2           SUB      R8,R8,#+1
   \   000002F0   1B9A89E1           ORR      R9,R9,R11, LSL R10
   \   000002F4   08A08AE2           ADD      R10,R10,#+8
   \                     ??inflate_codes_20:
   \   000002F8   03005AE1           CMP      R10,R3
   \   000002FC   0600002A           BCS      ??inflate_codes_29
   \   00000300   000058E3           CMP      R8,#+0
   \   00000304   F6FFFF1A           BNE      ??inflate_codes_28
   \   00000308   209084E5           STR      R9,[R4, #+32]
   \   0000030C   1CA084E5           STR      R10,[R4, #+28]
   \   00000310   0000A0E3           MOV      R0,#+0
   \   00000314   040085E5           STR      R0,[R5, #+4]
   \   00000318   96FFFFEA           B        ??inflate_codes_10
   \                     ??inflate_codes_29:
   \   0000031C   78C39FE5           LDR      R12,??inflate_codes_12  ;; inflate_mask
   \   00000320   04B096E5           LDR      R11,[R6, #+4]
   \   00000324   03C19CE7           LDR      R12,[R12, +R3, LSL #+2]
   \   00000328   03A04AE0           SUB      R10,R10,R3
   \   0000032C   09C00CE0           AND      R12,R12,R9
   \   00000330   0BB08CE0           ADD      R11,R12,R11
   \   00000334   04B086E5           STR      R11,[R6, #+4]
   \   00000338   3993A0E1           LSR      R9,R9,R3
   \   0000033C   1130D6E5           LDRB     R3,[R6, #+17]
   \   00000340   0C3086E5           STR      R3,[R6, #+12]
   \   00000344   183096E5           LDR      R3,[R6, #+24]
   \   00000348   083086E5           STR      R3,[R6, #+8]
   \   0000034C   0330A0E3           MOV      R3,#+3
   \   00000350   0030C6E5           STRB     R3,[R6, #+0]
   \                     ??inflate_codes_30:
   \   00000354   0C3096E5           LDR      R3,[R6, #+12]
   \   00000358   040000EA           B        ??inflate_codes_31
   \                     ??inflate_codes_32:
   \   0000035C   ........           LDRB     R11,[R7], #+1
   \   00000360   0020A0E3           MOV      R2,#+0
   \   00000364   018048E2           SUB      R8,R8,#+1
   \   00000368   1B9A89E1           ORR      R9,R9,R11, LSL R10
   \   0000036C   08A08AE2           ADD      R10,R10,#+8
   \                     ??inflate_codes_31:
   \   00000370   03005AE1           CMP      R10,R3
   \   00000374   0D00002A           BCS      ??inflate_codes_33
   \   00000378   000058E3           CMP      R8,#+0
   \   0000037C   F6FFFF1A           BNE      ??inflate_codes_32
   \   00000380   209084E5           STR      R9,[R4, #+32]
   \   00000384   1CA084E5           STR      R10,[R4, #+28]
   \   00000388   0000A0E3           MOV      R0,#+0
   \   0000038C   040085E5           STR      R0,[R5, #+4]
   \                     ??inflate_codes_34:
   \   00000390   080095E5           LDR      R0,[R5, #+8]
   \   00000394   003095E5           LDR      R3,[R5, #+0]
   \   00000398   000087E0           ADD      R0,R7,R0
   \   0000039C   030040E0           SUB      R0,R0,R3
   \   000003A0   080085E5           STR      R0,[R5, #+8]
   \   000003A4   007085E5           STR      R7,[R5, #+0]
   \   000003A8   341084E5           STR      R1,[R4, #+52]
   \   000003AC   B50000EA           B        ??inflate_codes_11
   \                     ??inflate_codes_33:
   \   000003B0   E4B29FE5           LDR      R11,??inflate_codes_12  ;; inflate_mask
   \   000003B4   03319BE7           LDR      R3,[R11, +R3, LSL #+2]
   \   000003B8   08B096E5           LDR      R11,[R6, #+8]
   \   000003BC   093003E0           AND      R3,R3,R9
   \   000003C0   83318BE0           ADD      R3,R11,R3, LSL #+3
   \   000003C4   01B0D3E5           LDRB     R11,[R3, #+1]
   \   000003C8   399BA0E1           LSR      R9,R9,R11
   \   000003CC   0BA04AE0           SUB      R10,R10,R11
   \   000003D0   00B0D3E5           LDRB     R11,[R3, #+0]
   \   000003D4   10001BE3           TST      R11,#0x10
   \   000003D8   0700000A           BEQ      ??inflate_codes_35
   \   000003DC   0FB00BE2           AND      R11,R11,#0xF
   \   000003E0   08B086E5           STR      R11,[R6, #+8]
   \   000003E4   043093E5           LDR      R3,[R3, #+4]
   \   000003E8   0C3086E5           STR      R3,[R6, #+12]
   \   000003EC   0430A0E3           MOV      R3,#+4
   \   000003F0   0030C6E5           STRB     R3,[R6, #+0]
   \                     ??inflate_codes_36:
   \   000003F4   083096E5           LDR      R3,[R6, #+8]
   \   000003F8   0A0000EA           B        ??inflate_codes_37
   \                     ??inflate_codes_35:
   \   000003FC   40001BE3           TST      R11,#0x40
   \   00000400   8DFFFF0A           BEQ      ??inflate_codes_22
   \   00000404   0900A0E3           MOV      R0,#+9
   \   00000408   0000C6E5           STRB     R0,[R6, #+0]
   \   0000040C   90029FE5           LDR      R0,??inflate_codes_12+0x8  ;; `?<Constant "invalid distance code">`
   \   00000410   A6FFFFEA           B        ??inflate_codes_26
   \                     ??inflate_codes_38:
   \   00000414   ........           LDRB     R11,[R7], #+1
   \   00000418   0020A0E3           MOV      R2,#+0
   \   0000041C   018048E2           SUB      R8,R8,#+1
   \   00000420   1B9A89E1           ORR      R9,R9,R11, LSL R10
   \   00000424   08A08AE2           ADD      R10,R10,#+8
   \                     ??inflate_codes_37:
   \   00000428   03005AE1           CMP      R10,R3
   \   0000042C   0600002A           BCS      ??inflate_codes_39
   \   00000430   000058E3           CMP      R8,#+0
   \   00000434   F6FFFF1A           BNE      ??inflate_codes_38
   \   00000438   209084E5           STR      R9,[R4, #+32]
   \   0000043C   1CA084E5           STR      R10,[R4, #+28]
   \   00000440   0000A0E3           MOV      R0,#+0
   \   00000444   040085E5           STR      R0,[R5, #+4]
   \   00000448   4AFFFFEA           B        ??inflate_codes_10
   \                     ??inflate_codes_39:
   \   0000044C   48C29FE5           LDR      R12,??inflate_codes_12  ;; inflate_mask
   \   00000450   0CB096E5           LDR      R11,[R6, #+12]
   \   00000454   03C19CE7           LDR      R12,[R12, +R3, LSL #+2]
   \   00000458   03A04AE0           SUB      R10,R10,R3
   \   0000045C   09C00CE0           AND      R12,R12,R9
   \   00000460   0BB08CE0           ADD      R11,R12,R11
   \   00000464   0CB086E5           STR      R11,[R6, #+12]
   \   00000468   3993A0E1           LSR      R9,R9,R3
   \   0000046C   0530A0E3           MOV      R3,#+5
   \   00000470   0030C6E5           STRB     R3,[R6, #+0]
   \                     ??inflate_codes_40:
   \   00000474   0C3096E5           LDR      R3,[R6, #+12]
   \   00000478   003063E2           RSB      R3,R3,#+0
   \   0000047C   01B083E0           ADD      R11,R3,R1
   \   00000480   283094E5           LDR      R3,[R4, #+40]
   \   00000484   03005BE1           CMP      R11,R3
   \   00000488   0400002A           BCS      ??inflate_codes_41
   \   0000048C   2CC094E5           LDR      R12,[R4, #+44]
   \   00000490   03C04CE0           SUB      R12,R12,R3
   \                     ??inflate_codes_42:
   \   00000494   0BB08CE0           ADD      R11,R12,R11
   \   00000498   03005BE1           CMP      R11,R3
   \   0000049C   FCFFFF3A           BCC      ??inflate_codes_42
   \                     ??inflate_codes_41:
   \   000004A0   043096E5           LDR      R3,[R6, #+4]
   \   000004A4   000053E3           CMP      R3,#+0
   \   000004A8   3600000A           BEQ      ??inflate_codes_43
   \   000004AC   000050E3           CMP      R0,#+0
   \   000004B0   2900001A           BNE      ??inflate_codes_44
   \   000004B4   2C0094E5           LDR      R0,[R4, #+44]
   \   000004B8   000051E1           CMP      R1,R0
   \   000004BC   0900001A           BNE      ??inflate_codes_45
   \   000004C0   283094E5           LDR      R3,[R4, #+40]
   \   000004C4   30C094E5           LDR      R12,[R4, #+48]
   \   000004C8   0C0053E1           CMP      R3,R12
   \   000004CC   0500000A           BEQ      ??inflate_codes_45
   \   000004D0   0310A0E1           MOV      R1,R3
   \   000004D4   03004C30           SUBCC    R0,R12,R3
   \   000004D8   01004032           SUBCC    R0,R0,#+1
   \   000004DC   03004020           SUBCS    R0,R0,R3
   \   000004E0   000050E3           CMP      R0,#+0
   \   000004E4   1C00001A           BNE      ??inflate_codes_44
   \                     ??inflate_codes_45:
   \   000004E8   341084E5           STR      R1,[R4, #+52]
   \   000004EC   0510A0E1           MOV      R1,R5
   \   000004F0   0400A0E1           MOV      R0,R4
   \   000004F4   ........           _BLF     inflate_flush,??inflate_flush??rA
   \   000004F8   341094E5           LDR      R1,[R4, #+52]
   \   000004FC   303094E5           LDR      R3,[R4, #+48]
   \   00000500   0020A0E1           MOV      R2,R0
   \   00000504   030051E1           CMP      R1,R3
   \   00000508   2CC09425           LDRCS    R12,[R4, #+44]
   \   0000050C   01004330           SUBCC    R0,R3,R1
   \   00000510   01004C20           SUBCS    R0,R12,R1
   \   00000514   2CC094E5           LDR      R12,[R4, #+44]
   \   00000518   01004032           SUBCC    R0,R0,#+1
   \   0000051C   0C0051E1           CMP      R1,R12
   \   00000520   0700001A           BNE      ??inflate_codes_46
   \   00000524   28E094E5           LDR      LR,[R4, #+40]
   \   00000528   0E0053E1           CMP      R3,LR
   \   0000052C   0400000A           BEQ      ??inflate_codes_46
   \   00000530   0E10A0E1           MOV      R1,LR
   \   00000534   030051E1           CMP      R1,R3
   \   00000538   01004330           SUBCC    R0,R3,R1
   \   0000053C   01004032           SUBCC    R0,R0,#+1
   \   00000540   01004C20           SUBCS    R0,R12,R1
   \                     ??inflate_codes_46:
   \   00000544   000050E3           CMP      R0,#+0
   \   00000548   0300001A           BNE      ??inflate_codes_44
   \   0000054C   209084E5           STR      R9,[R4, #+32]
   \   00000550   1CA084E5           STR      R10,[R4, #+28]
   \   00000554   048085E5           STR      R8,[R5, #+4]
   \   00000558   8CFFFFEA           B        ??inflate_codes_34
   \                     ??inflate_codes_44:
   \   0000055C   ........           LDRB     R3,[R11], #+1
   \   00000560   0020A0E3           MOV      R2,#+0
   \   00000564   010040E2           SUB      R0,R0,#+1
   \   00000568   ........           STRB     R3,[R1], #+1
   \   0000056C   2C3094E5           LDR      R3,[R4, #+44]
   \   00000570   03005BE1           CMP      R11,R3
   \   00000574   043096E5           LDR      R3,[R6, #+4]
   \   00000578   28B09405           LDREQ    R11,[R4, #+40]
   \   0000057C   013043E2           SUB      R3,R3,#+1
   \   00000580   043086E5           STR      R3,[R6, #+4]
   \   00000584   C5FFFFEA           B        ??inflate_codes_41
   \                     ??inflate_codes_43:
   \   00000588   0030C6E5           STRB     R3,[R6, #+0]
   \   0000058C   B9FEFFEA           B        ??inflate_codes_4
   \                     ??inflate_codes_17:
   \   00000590   000050E3           CMP      R0,#+0
   \   00000594   1C00001A           BNE      ??inflate_codes_15
   \                     ??inflate_codes_16:
   \   00000598   341084E5           STR      R1,[R4, #+52]
   \   0000059C   0510A0E1           MOV      R1,R5
   \   000005A0   0400A0E1           MOV      R0,R4
   \   000005A4   ........           _BLF     inflate_flush,??inflate_flush??rA
   \   000005A8   341094E5           LDR      R1,[R4, #+52]
   \   000005AC   303094E5           LDR      R3,[R4, #+48]
   \   000005B0   0020A0E1           MOV      R2,R0
   \   000005B4   030051E1           CMP      R1,R3
   \   000005B8   2CB09425           LDRCS    R11,[R4, #+44]
   \   000005BC   01004330           SUBCC    R0,R3,R1
   \   000005C0   01004B20           SUBCS    R0,R11,R1
   \   000005C4   2CB094E5           LDR      R11,[R4, #+44]
   \   000005C8   01004032           SUBCC    R0,R0,#+1
   \   000005CC   0B0051E1           CMP      R1,R11
   \   000005D0   0700001A           BNE      ??inflate_codes_47
   \   000005D4   28C094E5           LDR      R12,[R4, #+40]
   \   000005D8   0C0053E1           CMP      R3,R12
   \   000005DC   0400000A           BEQ      ??inflate_codes_47
   \   000005E0   0C10A0E1           MOV      R1,R12
   \   000005E4   030051E1           CMP      R1,R3
   \   000005E8   01004330           SUBCC    R0,R3,R1
   \   000005EC   01004032           SUBCC    R0,R0,#+1
   \   000005F0   01004B20           SUBCS    R0,R11,R1
   \                     ??inflate_codes_47:
   \   000005F4   000050E3           CMP      R0,#+0
   \   000005F8   0300001A           BNE      ??inflate_codes_15
   \   000005FC   209084E5           STR      R9,[R4, #+32]
   \   00000600   1CA084E5           STR      R10,[R4, #+28]
   \   00000604   048085E5           STR      R8,[R5, #+4]
   \   00000608   DAFEFFEA           B        ??inflate_codes_10
   \                     ??inflate_codes_15:
   \   0000060C   083096E5           LDR      R3,[R6, #+8]
   \   00000610   0020A0E3           MOV      R2,#+0
   \   00000614   ........           STRB     R3,[R1], #+1
   \   00000618   010040E2           SUB      R0,R0,#+1
   \   0000061C   0030A0E3           MOV      R3,#+0
   \   00000620   D8FFFFEA           B        ??inflate_codes_43
    228                c->mode = END;
   \                     ??inflate_codes_25:
   \   00000624   0800A0E3           MOV      R0,#+8
   \   00000628   0000C6E5           STRB     R0,[R6, #+0]
    229              case END:
    230                r = Z_STREAM_END;
    231                LEAVE
   \                     ??inflate_codes_48:
   \   0000062C   209084E5           STR      R9,[R4, #+32]
   \   00000630   1CA084E5           STR      R10,[R4, #+28]
   \   00000634   048085E5           STR      R8,[R5, #+4]
   \   00000638   080095E5           LDR      R0,[R5, #+8]
   \   0000063C   002095E5           LDR      R2,[R5, #+0]
   \   00000640   000087E0           ADD      R0,R7,R0
   \   00000644   020040E0           SUB      R0,R0,R2
   \   00000648   080085E5           STR      R0,[R5, #+8]
   \   0000064C   007085E5           STR      R7,[R5, #+0]
   \   00000650   341084E5           STR      R1,[R4, #+52]
   \   00000654   0120A0E3           MOV      R2,#+1
   \   00000658   0A0000EA           B        ??inflate_codes_11
    232              case BADCODE:       /* x: got error */
    233                r = Z_DATA_ERROR;
    234                LEAVE
    235              default:
    236                r = Z_STREAM_ERROR;
    237                LEAVE
   \                     ??inflate_codes_3:
   \   0000065C   209084E5           STR      R9,[R4, #+32]
   \   00000660   1CA084E5           STR      R10,[R4, #+28]
   \   00000664   048085E5           STR      R8,[R5, #+4]
   \   00000668   080095E5           LDR      R0,[R5, #+8]
   \   0000066C   002095E5           LDR      R2,[R5, #+0]
   \   00000670   000087E0           ADD      R0,R7,R0
   \   00000674   020040E0           SUB      R0,R0,R2
   \   00000678   080085E5           STR      R0,[R5, #+8]
   \   0000067C   007085E5           STR      R7,[R5, #+0]
   \   00000680   341084E5           STR      R1,[R4, #+52]
   \   00000684   0120E0E3           MVN      R2,#+1
   \                     ??inflate_codes_11:
   \   00000688   0510A0E1           MOV      R1,R5
   \   0000068C   0400A0E1           MOV      R0,R4
   \   00000690   ........           _BLF     inflate_flush,??inflate_flush??rA
   \   00000694   1CD08DE2           ADD      SP,SP,#+28
   \   00000698   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??inflate_codes_12:
   \   0000069C   ........           DC32     inflate_mask
   \   000006A0   ........           DC32     `?<Constant "invalid literal/lengt...">`
   \   000006A4   ........           DC32     `?<Constant "invalid distance code">`
    238            }
    239          #ifdef NEED_DUMMY_RETURN
    240            return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
    241          #endif
    242          }
    243          
    244          

   \                                 In segment CODE, align 4, keep-with-next
    245          void inflate_codes_free(c, z)
    246          inflate_codes_statef *c;
    247          z_streamp z;
    248          {
   \                     inflate_codes_free:
   \   00000000   0120A0E1           MOV      R2,R1
    249            ZFREE(z, c);
   \   00000004   0010A0E1           MOV      R1,R0
   \   00000008   280092E5           LDR      R0,[R2, #+40]
   \   0000000C   242092E5           LDR      R2,[R2, #+36]
   \   00000010   02F0A0E1           MOV      PC,R2            ;; tailcall
    250            Tracev((stderr, "inflate:       codes free\n"));
    251          }

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "invalid literal/lengt...">`:
   \   00000000   696E76616C69       DC8 "invalid literal/length code"
   \              64206C697465
   \              72616C2F6C65
   \              6E6774682063
   \              6F646500    

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "invalid distance code">`:
   \   00000000   696E76616C69       DC8 "invalid distance code"
   \              642064697374
   \              616E63652063
   \              6F646500    
   \   00000016   0000               DC8 0, 0

   Maximum stack usage in bytes:

     Function           CSTACK
     --------           ------
     inflate_codes         72
     inflate_codes_free     4
     inflate_codes_new     20


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     inflate_codes_new                80
     inflate_codes                  1704
     inflate_codes_free               20
     ?<Constant "invalid literal/lengt...">
                                      28
     ?<Constant "invalid distance code">
                                      24
      Others                          36

 
 1 840 bytes in segment CODE
    52 bytes in segment DATA_C
 
 1 804 bytes of CODE  memory (+ 36 bytes shared)
    52 bytes of CONST memory

Errors: none
Warnings: none
