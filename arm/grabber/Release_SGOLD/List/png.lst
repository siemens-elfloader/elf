##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    19/Jan/2011  13:20:36 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\grabber\pnglib\png.c                          #
#    Command line    =  C:\arm\grabber\pnglib\png.c -lC                      #
#                       C:\arm\grabber\Release_SGOLD\List\ -o                #
#                       C:\arm\grabber\Release_SGOLD\Obj\ -s9 --no_unroll    #
#                       --no_clustering --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --fpu None --dlib_config "C:\arm2\Embedded           #
#                       Workbench 4.0 Evaluation\ARM\LIB\dl5tpainl8n.h" -I   #
#                       "C:\arm2\Embedded Workbench 4.0                      #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  C:\arm\grabber\Release_SGOLD\List\png.lst            #
#    Object file     =  C:\arm\grabber\Release_SGOLD\Obj\png.r79             #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\grabber\pnglib\png.c
      1          
      2          /* png.c - location for general purpose libpng functions
      3           *
      4           * libpng version 1.2.1 - December 12, 2001
      5           * Copyright (c) 1998-2001 Glenn Randers-Pehrson
      6           * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
      7           * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
      8           *
      9           */
     10          
     11          #define PNG_INTERNAL
     12          #define PNG_NO_EXTERN
     13          #include "../pnglib/png.h"

  int CRYPTO_set_mem_functions(void *(*m)(size_t),void *(*r)(void *,size_t), void (*f)(void *));
                                          ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\crypto.h",298  Error[Pe092]: 
          identifier-list parameters may only be used in a function definition

  int CRYPTO_set_mem_functions(void *(*m)(size_t),void *(*r)(void *,size_t), void (*f)(void *));
                                                                    ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\crypto.h",298  Error[Pe020]: 
          identifier "size_t" is undefined

  int CRYPTO_set_locked_mem_functions(void *(*m)(size_t), void (*free_func)(void *));
                                                 ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\crypto.h",299  Error[Pe092]: 
          identifier-list parameters may only be used in a function definition

  void CRYPTO_get_mem_functions(void *(**m)(size_t),void *(**r)(void *, size_t), void (**f)(void *));
                                            ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\crypto.h",301  Error[Pe092]: 
          identifier-list parameters may only be used in a function definition

  void CRYPTO_get_mem_functions(void *(**m)(size_t),void *(**r)(void *, size_t), void (**f)(void *));
                                                                        ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\crypto.h",301  Error[Pe020]: 
          identifier "size_t" is undefined

  void CRYPTO_get_locked_mem_functions(void *(**m)(size_t), void (**f)(void *));
                                                   ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\crypto.h",302  Error[Pe092]: 
          identifier-list parameters may only be used in a function definition

  __swi __arm void *calloc(size_t nelem, size_t elsize);
                           ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",1623  Error[Pe020]: 
          identifier "size_t" is undefined

  __swi __arm void *calloc(size_t nelem, size_t elsize);
                                         ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",1623  Error[Pe020]: 
          identifier "size_t" is undefined

  __swi __arm png_structp png_create_read_struct(png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warn_fn);
              ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2236  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm png_structp png_create_read_struct(png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warn_fn);
                                                 ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2236  Error[Pe020]: 
          identifier "png_const_charp" is undefined

  __swi __arm png_structp png_create_read_struct(png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warn_fn);
                                                                               ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2236  Error[Pe020]: 
          identifier "png_voidp" is undefined

  __swi __arm png_structp png_create_read_struct(png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warn_fn);
                                                                                                    ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2236  Error[Pe020]: 
          identifier "png_error_ptr" is undefined

  __swi __arm png_structp png_create_read_struct(png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warn_fn);
                                                                                                                            ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2236  Error[Pe020]: 
          identifier "png_error_ptr" is undefined

  __swi __arm png_infop png_create_info_struct(png_structp png_ptr);
              ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2241  Error[Pe020]: 
          identifier "png_infop" is undefined

  __swi __arm png_infop png_create_info_struct(png_structp png_ptr);
                                               ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2241  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_destroy_read_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr, png_infopp end_info_ptr_ptr);
                                           ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2246  Error[Pe020]: 
          identifier "png_structpp" is undefined

  __swi __arm void png_destroy_read_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr, png_infopp end_info_ptr_ptr);
                                                                     ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2246  Error[Pe020]: 
          identifier "png_infopp" is undefined

  __swi __arm void png_destroy_read_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr, png_infopp end_info_ptr_ptr);
                                                                                              ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2246  Error[Pe020]: 
          identifier "png_infopp" is undefined

  __swi __arm void png_set_sig_bytes(png_structp png_ptr,int num_bytes);
                                     ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2251  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_read_info(png_structp png_ptr, png_infop info_ptr);
                                 ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2256  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_read_info(png_structp png_ptr, png_infop info_ptr);
                                                      ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2256  Error[Pe020]: 
          identifier "png_infop" is undefined

  __swi __arm png_uint_32 png_get_IHDR(png_structp png_ptr,png_infop info_ptr, png_uint_32 *width, png_uint_32 *height, int *bit_depth, int *color_type, int *interlace_method, int *compression_method, int *filter_method);
              ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2261  Error[Pe020]: 
          identifier "png_uint_32" is undefined

  __swi __arm png_uint_32 png_get_IHDR(png_structp png_ptr,png_infop info_ptr, png_uint_32 *width, png_uint_32 *height, int *bit_depth, int *color_type, int *interlace_method, int *compression_method, int *filter_method);
                                       ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2261  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm png_uint_32 png_get_IHDR(png_structp png_ptr,png_infop info_ptr, png_uint_32 *width, png_uint_32 *height, int *bit_depth, int *color_type, int *interlace_method, int *compression_method, int *filter_method);
                                                           ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2261  Error[Pe020]: 
          identifier "png_infop" is undefined

  __swi __arm png_uint_32 png_get_IHDR(png_structp png_ptr,png_infop info_ptr, png_uint_32 *width, png_uint_32 *height, int *bit_depth, int *color_type, int *interlace_method, int *compression_method, int *filter_method);
                                                                               ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2261  Error[Pe020]: 
          identifier "png_uint_32" is undefined

  __swi __arm png_uint_32 png_get_IHDR(png_structp png_ptr,png_infop info_ptr, png_uint_32 *width, png_uint_32 *height, int *bit_depth, int *color_type, int *interlace_method, int *compression_method, int *filter_method);
                                                                                                   ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2261  Error[Pe020]: 
          identifier "png_uint_32" is undefined

  __swi __arm png_voidp png_malloc(png_structp png_ptr, png_uint_32 size);
              ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2266  Error[Pe020]: 
          identifier "png_voidp" is undefined

  __swi __arm png_voidp png_malloc(png_structp png_ptr, png_uint_32 size);
                                   ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2266  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm png_voidp png_malloc(png_structp png_ptr, png_uint_32 size);
                                                        ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2266  Error[Pe020]: 
          identifier "png_uint_32" is undefined

  __swi __arm void png_read_image(png_structp png_ptr, png_bytepp image);
                                  ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2271  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_read_image(png_structp png_ptr, png_bytepp image);
                                                       ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2271  Error[Pe020]: 
          identifier "png_bytepp" is undefined

  __swi __arm void png_read_end(png_structp png_ptr, png_infop info_ptr);
                                ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2276  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_read_end(png_structp png_ptr, png_infop info_ptr);
                                                     ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2276  Error[Pe020]: 
          identifier "png_infop" is undefined

  __swi __arm png_voidp png_get_io_ptr(png_structp png_ptr);
              ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2281  Error[Pe020]: 
          identifier "png_voidp" is undefined

  __swi __arm png_voidp png_get_io_ptr(png_structp png_ptr);
                                       ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2281  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm png_uint_32 png_get_rowbytes(png_structp png_ptr,png_infop info_ptr);
              ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2286  Error[Pe020]: 
          identifier "png_uint_32" is undefined

  __swi __arm png_uint_32 png_get_rowbytes(png_structp png_ptr,png_infop info_ptr);
                                           ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2286  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm png_uint_32 png_get_rowbytes(png_structp png_ptr,png_infop info_ptr);
                                                               ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2286  Error[Pe020]: 
          identifier "png_infop" is undefined

  __swi __arm void png_read_row(png_structp png_ptr,png_bytep row,png_bytep dsp_row);
                                ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2291  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_read_row(png_structp png_ptr,png_bytep row,png_bytep dsp_row);
                                                    ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2291  Error[Pe020]: 
          identifier "png_bytep" is undefined

  __swi __arm void png_read_row(png_structp png_ptr,png_bytep row,png_bytep dsp_row);
                                                                  ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2291  Error[Pe020]: 
          identifier "png_bytep" is undefined

  __swi __arm void png_init_io(png_structp png_ptr, int fp);
                               ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2296  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm png_structp png_create_read_struct_2(png_const_charp user_png_ver, png_voidp error_ptr,
              ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2640  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm png_structp png_create_read_struct_2(png_const_charp user_png_ver, png_voidp error_ptr,
                                                   ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2640  Error[Pe020]: 
          identifier "png_const_charp" is undefined

  __swi __arm png_structp png_create_read_struct_2(png_const_charp user_png_ver, png_voidp error_ptr,
                                                                                 ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2640  Error[Pe020]: 
          identifier "png_voidp" is undefined

                                                   png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,
                                                   ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2641  Error[Pe020]: 
          identifier "png_error_ptr" is undefined

                                                   png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,
                                                                           ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2641  Error[Pe020]: 
          identifier "png_error_ptr" is undefined

                                                   png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,
                                                                                                  ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2641  Error[Pe020]: 
          identifier "png_voidp" is undefined

                                                   png_malloc_ptr malloc_fn, png_free_ptr free_fn);
                                                   ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2642  Error[Pe020]: 
          identifier "png_malloc_ptr" is undefined

                                                   png_malloc_ptr malloc_fn, png_free_ptr free_fn);
                                                                             ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2642  Error[Pe020]: 
          identifier "png_free_ptr" is undefined

  __swi __arm void png_set_read_fn(png_structp png_ptr, png_voidp io_ptr, png_rw_ptr read_data_fn);
                                   ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2647  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_set_read_fn(png_structp png_ptr, png_voidp io_ptr, png_rw_ptr read_data_fn);
                                                        ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2647  Error[Pe020]: 
          identifier "png_voidp" is undefined

  __swi __arm void png_set_read_fn(png_structp png_ptr, png_voidp io_ptr, png_rw_ptr read_data_fn);
                                                                          ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2647  Error[Pe020]: 
          identifier "png_rw_ptr" is undefined

  __swi __arm void png_read_update_info(png_structp png_ptr,void *info_ptr);
                                        ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2652  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_set_palette_to_rgb(png_structp png_ptr);
                                          ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2657  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm png_uint_32 png_get_valid(png_structp png_ptr,png_infop info_ptr, png_uint_32 flag);
              ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2662  Error[Pe020]: 
          identifier "png_uint_32" is undefined

  __swi __arm png_uint_32 png_get_valid(png_structp png_ptr,png_infop info_ptr, png_uint_32 flag);
                                        ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2662  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm png_uint_32 png_get_valid(png_structp png_ptr,png_infop info_ptr, png_uint_32 flag);
                                                            ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2662  Error[Pe020]: 
          identifier "png_infop" is undefined

  __swi __arm png_uint_32 png_get_valid(png_structp png_ptr,png_infop info_ptr, png_uint_32 flag);
                                                                                ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2662  Error[Pe020]: 
          identifier "png_uint_32" is undefined

  __swi __arm void png_set_tRNS_to_alpha(png_structp png_ptr);
                                         ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2667  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_set_filler(png_structp png_ptr,png_uint_32 filler, int flags);
                                  ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2672  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_set_filler(png_structp png_ptr,png_uint_32 filler, int flags);
                                                      ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2672  Error[Pe020]: 
          identifier "png_uint_32" is undefined

  __swi __arm void png_set_strip_16(png_structp png_ptr);
                                    ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2677  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_set_packing(png_structp png_ptr);
                                   ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2682  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_set_gray_to_rgb(png_structp png_ptr);
                                       ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2687  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm int png_check_sig(png_bytep sig, int num);
                                ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2692  Error[Pe020]: 
          identifier "png_bytep" is undefined

  __swi __arm void png_set_gray_1_2_4_to_8(png_structp png_ptr);
                                           ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2888  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_set_invert_mono(png_structp png_ptr);
                                       ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2893  Error[Pe020]: 
          identifier "png_structp" is undefined

  extern PNG_EXPORT(void,png_read_update_info) PNGARG((png_structp png_ptr,
         ^
"C:\arm\grabber\pnglib\png.h",1525  Error[Pe147]: declaration is incompatible
          with "void png_read_update_info(<error-type>, void *)" (declared at
          line 2652 of "C:\arm2\Embedded Workbench 4.0
          Evaluation\ARM\INC\swilib.h")
     14          
     15          /* Generate a compiler error if there is an old png.h in the search path. */
     16          typedef version_1_2_1 Your_png_h_is_not_version_1_2_1;
     17          
     18          /* Version information for C files.  This had better match the version
     19           * string defined in png.h.  */
     20          
     21          #ifdef PNG_USE_GLOBAL_ARRAYS
     22          /* png_libpng_ver was changed to a function in version 1.0.5c */
     23          const char png_libpng_ver[18] = "1.2.1";
     24          
     25          /* png_sig was changed to a function in version 1.0.5c */
     26          /* Place to hold the signature string for a PNG file. */
     27          const png_byte FARDATA png_sig[8] = {137, 80, 78, 71, 13, 10, 26, 10};
     28          
     29          /* Invoke global declarations for constant strings for known chunk types */
     30          PNG_IHDR;
     31          PNG_IDAT;
     32          PNG_IEND;
     33          PNG_PLTE;
     34          PNG_bKGD;
     35          PNG_cHRM;
     36          PNG_gAMA;
     37          PNG_hIST;
     38          PNG_iCCP;
     39          PNG_iTXt;
     40          PNG_oFFs;
     41          PNG_pCAL;
     42          PNG_sCAL;
     43          PNG_pHYs;
     44          PNG_sBIT;
     45          PNG_sPLT;
     46          PNG_sRGB;
     47          PNG_tEXt;
     48          PNG_tIME;
     49          PNG_tRNS;
     50          PNG_zTXt;
     51          
     52          /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
     53          
     54          /* start of interlace block */
     55          const int FARDATA png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};
     56          
     57          /* offset to next interlace block */
     58          const int FARDATA png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};
     59          
     60          /* start of interlace block in the y direction */
     61          const int FARDATA png_pass_ystart[] = {0, 0, 4, 0, 2, 0, 1};
     62          
     63          /* offset to next interlace block in the y direction */
     64          const int FARDATA png_pass_yinc[] = {8, 8, 8, 4, 4, 2, 2};
     65          
     66          /* width of interlace block (used in assembler routines only) */
     67          #ifdef PNG_HAVE_ASSEMBLER_COMBINE_ROW
     68          const int FARDATA png_pass_width[] = {8, 4, 4, 2, 2, 1, 1};
     69          #endif
     70          
     71          /* Height of interlace block.  This is not currently used - if you need
     72           * it, uncomment it here and in png.h
     73          const int FARDATA png_pass_height[] = {8, 8, 4, 4, 2, 2, 1};
     74          */
     75          
     76          /* Mask to determine which pixels are valid in a pass */
     77          const int FARDATA png_pass_mask[] = {0x80, 0x08, 0x88, 0x22, 0xaa, 0x55, 0xff};
     78          
     79          /* Mask to determine which pixels to overwrite while displaying */
     80          const int FARDATA png_pass_dsp_mask[]
     81             = {0xff, 0x0f, 0xff, 0x33, 0xff, 0x55, 0xff};
     82          
     83          #endif
     84          
     85          /* Tells libpng that we have already handled the first "num_bytes" bytes
     86           * of the PNG file signature.  If the PNG data is embedded into another
     87           * stream we can set num_bytes = 8 so that libpng will not attempt to read
     88           * or write any of the magic bytes before it starts on the IHDR.
     89           */
     90          
     91          void PNGAPI
     92          png_set_sig_bytes(png_structp png_ptr, int num_bytes)
     93          {
     94             png_debug(1, "in png_set_sig_bytes\n");
     95             if (num_bytes > 8)
     96                png_error(png_ptr, "Too many bytes for PNG signature.");
     97          
     98             png_ptr->sig_bytes = (png_byte)(num_bytes < 0 ? 0 : num_bytes);
     99          }
    100          
    101          /* Checks whether the supplied bytes match the PNG signature.  We allow
    102           * checking less than the full 8-byte signature so that those apps that
    103           * already read the first few bytes of a file to determine the file type
    104           * can simply check the remaining bytes for extra assurance.  Returns
    105           * an integer less than, equal to, or greater than zero if sig is found,
    106           * respectively, to be less than, to match, or be greater than the correct
    107           * PNG signature (this is the same behaviour as strcmp, memcmp, etc).
    108           */
    109          int PNGAPI
    110          png_sig_cmp(png_bytep sig, png_size_t start, png_size_t num_to_check)
    111          {
    112             png_byte png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};
    113             if (num_to_check > 8)
    114                num_to_check = 8;
    115             else if (num_to_check < 1)
    116                return (0);
    117          
    118             if (start > 7)
    119                return (0);
    120          
    121             if (start + num_to_check > 8)
    122                num_to_check = 8 - start;
    123          
    124             return ((int)(png_memcmp(&sig[start], &png_signature[start], num_to_check)));
    125          }
    126          
    127          /* (Obsolete) function to check signature bytes.  It does not allow one
    128           * to check a partial signature.  This function might be removed in the
    129           * future - use png_sig_cmp().  Returns true (nonzero) if the file is a PNG.
    130           */
    131          int PNGAPI
    132          png_check_sig(png_bytep sig, int num)
    133          {
    134            return ((int)!png_sig_cmp(sig, (png_size_t)0, (png_size_t)num));
    135          }
    136          
    137          /* Function to allocate memory for zlib and clear it to 0. */
    138          voidpf /* PRIVATE */
    139          png_zalloc(voidpf png_ptr, uInt items, uInt size)
    140          {
    141             png_uint_32 num_bytes = (png_uint_32)items * size;
    142             png_voidp ptr = (png_voidp)png_malloc((png_structp)png_ptr, num_bytes);
    143          
    144          #ifndef PNG_NO_ZALLOC_ZERO
    145             if (num_bytes > (png_uint_32)0x8000L)
    146             {
    147                png_memset(ptr, 0, (png_size_t)0x8000L);
    148                png_memset((png_bytep)ptr + (png_size_t)0x8000L, 0,
    149                   (png_size_t)(num_bytes - (png_uint_32)0x8000L));
    150             }
    151             else
    152             {
    153                png_memset(ptr, 0, (png_size_t)num_bytes);
    154             }
    155          #endif
    156             return ((voidpf)ptr);
    157          }
    158          
    159          /* function to free memory for zlib */
    160          void /* PRIVATE */
    161          png_zfree(voidpf png_ptr, voidpf ptr)
    162          {
    163             png_free((png_structp)png_ptr, (png_voidp)ptr);
    164          }
    165          
    166          /* Reset the CRC variable to 32 bits of 1's.  Care must be taken
    167           * in case CRC is > 32 bits to leave the top bits 0.
    168           */
    169          void /* PRIVATE */
    170          png_reset_crc(png_structp png_ptr)
    171          {
    172             png_ptr->crc = crc32(0, Z_NULL, 0);
    173          }
    174          
    175          /* Calculate the CRC over a section of data.  We can only pass as
    176           * much data to this routine as the largest single buffer size.  We
    177           * also check that this data will actually be used before going to the
    178           * trouble of calculating it.
    179           */
    180          void /* PRIVATE */
    181          png_calculate_crc(png_structp png_ptr, png_bytep ptr, png_size_t length)
    182          {
    183             int need_crc = 1;
    184          
    185             if (png_ptr->chunk_name[0] & 0x20)                     /* ancillary */
    186             {
    187                if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==
    188                    (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))
    189                   need_crc = 0;
    190             }
    191             else                                                    /* critical */
    192             {
    193                if (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE)
    194                   need_crc = 0;
    195             }
    196          
    197             if (need_crc)
    198                png_ptr->crc = crc32(png_ptr->crc, ptr, (uInt)length);
    199          }
    200          
    201          /* Allocate the memory for an info_struct for the application.  We don't
    202           * really need the png_ptr, but it could potentially be useful in the
    203           * future.  This should be used in favour of malloc(sizeof(png_info))
    204           * and png_info_init() so that applications that want to use a shared
    205           * libpng don't have to be recompiled if png_info changes size.
    206           */
    207          png_infop PNGAPI
    208          png_create_info_struct(png_structp png_ptr)
    209          {
    210             png_infop info_ptr;
    211          
    212             png_debug(1, "in png_create_info_struct\n");
    213             if(png_ptr == NULL) return (NULL);
    214          #ifdef PNG_USER_MEM_SUPPORTED
    215             info_ptr = (png_infop)png_create_struct_2(PNG_STRUCT_INFO,
    216                png_ptr->malloc_fn, png_ptr->mem_ptr);
    217          #else
    218             info_ptr = (png_infop)png_create_struct(PNG_STRUCT_INFO);
    219          #endif
    220             if (info_ptr != NULL)
    221                png_info_init_3(&info_ptr, sizeof(png_info));
    222          
    223             return (info_ptr);
    224          }
    225          
    226          /* This function frees the memory associated with a single info struct.
    227           * Normally, one would use either png_destroy_read_struct() or
    228           * png_destroy_write_struct() to free an info struct, but this may be
    229           * useful for some applications.
    230           */
    231          void PNGAPI
    232          png_destroy_info_struct(png_structp png_ptr, png_infopp info_ptr_ptr)
    233          {
    234             png_infop info_ptr = NULL;
    235          
    236             png_debug(1, "in png_destroy_info_struct\n");
    237             if (info_ptr_ptr != NULL)
    238                info_ptr = *info_ptr_ptr;
    239          
    240             if (info_ptr != NULL)
    241             {
    242                png_info_destroy(png_ptr, info_ptr);
    243          
    244          #ifdef PNG_USER_MEM_SUPPORTED
    245                png_destroy_struct_2((png_voidp)info_ptr, png_ptr->free_fn,
    246                    png_ptr->mem_ptr);
    247          #else
    248                png_destroy_struct((png_voidp)info_ptr);
    249          #endif
    250                *info_ptr_ptr = NULL;
    251             }
    252          }
    253          
    254          /* Initialize the info structure.  This is now an internal function (0.89)
    255           * and applications using it are urged to use png_create_info_struct()
    256           * instead.
    257           */
    258          #undef png_info_init
    259          void PNGAPI
    260          png_info_init(png_infop info_ptr)
    261          {
    262             /* We only come here via pre-1.0.12-compiled applications */
    263             png_info_init_3(&info_ptr, 0);
    264          }
    265          
    266          void PNGAPI
    267          png_info_init_3(png_infopp ptr_ptr, png_size_t png_info_struct_size)
    268          {
    269             png_infop info_ptr = *ptr_ptr;
    270          
    271             png_debug(1, "in png_info_init_3\n");
    272          
    273             if(sizeof(png_info) > png_info_struct_size)
    274               {
    275                 png_destroy_struct(info_ptr);
    276                 info_ptr = (png_infop)png_create_struct(PNG_STRUCT_INFO);
    277                 *ptr_ptr = info_ptr;
    278               }
    279          
    280             /* set everything to 0 */
    281             png_memset(info_ptr, 0, sizeof (png_info));
    282          }
    283          
    284          #ifdef PNG_FREE_ME_SUPPORTED
    285          void PNGAPI
    286          png_data_freer(png_structp png_ptr, png_infop info_ptr,
    287             int freer, png_uint_32 mask)
    288          {
    289             png_debug(1, "in png_data_freer\n");
    290             if (png_ptr == NULL || info_ptr == NULL)
    291                return;
    292             if(freer == PNG_DESTROY_WILL_FREE_DATA)
    293                info_ptr->free_me |= mask;
    294             else if(freer == PNG_USER_WILL_FREE_DATA)
    295                info_ptr->free_me &= ~mask;
    296             else
    297                png_warning(png_ptr,
    298                   "Unknown freer parameter in png_data_freer.");
    299          }
    300          #endif
    301          
    302          void PNGAPI
    303          png_free_data(png_structp png_ptr, png_infop info_ptr, png_uint_32 mask,
    304             int num)
    305          {
    306             png_debug(1, "in png_free_data\n");
    307             if (png_ptr == NULL || info_ptr == NULL)
    308                return;
    309          
    310          #if defined(PNG_TEXT_SUPPORTED)
    311          /* free text item num or (if num == -1) all text items */
    312          #ifdef PNG_FREE_ME_SUPPORTED
    313          if ((mask & PNG_FREE_TEXT) & info_ptr->free_me)
    314          #else
    315          if (mask & PNG_FREE_TEXT)
    316          #endif
    317          {
    318             if (num != -1)
    319             {
    320               if (info_ptr->text && info_ptr->text[num].key)
    321               {
    322                   png_free(png_ptr, info_ptr->text[num].key);
    323                   info_ptr->text[num].key = NULL;
    324               }
    325             }
    326             else
    327             {
    328                 int i;
    329                 for (i = 0; i < info_ptr->num_text; i++)
    330                     png_free_data(png_ptr, info_ptr, PNG_FREE_TEXT, i);
    331                 png_free(png_ptr, info_ptr->text);
    332                 info_ptr->text = NULL;
    333                 info_ptr->num_text=0;
    334             }
    335          }
    336          #endif
    337          
    338          #if defined(PNG_tRNS_SUPPORTED)
    339          /* free any tRNS entry */
    340          #ifdef PNG_FREE_ME_SUPPORTED
    341          if ((mask & PNG_FREE_TRNS) & info_ptr->free_me)
    342          #else
    343          if ((mask & PNG_FREE_TRNS) && (png_ptr->flags & PNG_FLAG_FREE_TRNS))
    344          #endif
    345          {
    346              png_free(png_ptr, info_ptr->trans);
    347              info_ptr->valid &= ~PNG_INFO_tRNS;
    348              info_ptr->trans = NULL;
    349          }
    350          #endif
    351          
    352          #if defined(PNG_sCAL_SUPPORTED)
    353          /* free any sCAL entry */
    354          #ifdef PNG_FREE_ME_SUPPORTED
    355          if ((mask & PNG_FREE_SCAL) & info_ptr->free_me)
    356          #else
    357          if (mask & PNG_FREE_SCAL)
    358          #endif
    359          {
    360          #if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
    361              png_free(png_ptr, info_ptr->scal_s_width);
    362              png_free(png_ptr, info_ptr->scal_s_height);
    363              info_ptr->scal_s_width = NULL;
    364              info_ptr->scal_s_height = NULL;
    365          #endif
    366              info_ptr->valid &= ~PNG_INFO_sCAL;
    367          }
    368          #endif
    369          
    370          #if defined(PNG_pCAL_SUPPORTED)
    371          /* free any pCAL entry */
    372          #ifdef PNG_FREE_ME_SUPPORTED
    373          if ((mask & PNG_FREE_PCAL) & info_ptr->free_me)
    374          #else
    375          if (mask & PNG_FREE_PCAL)
    376          #endif
    377          {
    378              png_free(png_ptr, info_ptr->pcal_purpose);
    379              png_free(png_ptr, info_ptr->pcal_units);
    380              info_ptr->pcal_purpose = NULL;
    381              info_ptr->pcal_units = NULL;
    382              if (info_ptr->pcal_params != NULL)
    383              {
    384                  int i;
    385                  for (i = 0; i < (int)info_ptr->pcal_nparams; i++)
    386                  {
    387                    png_free(png_ptr, info_ptr->pcal_params[i]);
    388                    info_ptr->pcal_params[i]=NULL;
    389                  }
    390                  png_free(png_ptr, info_ptr->pcal_params);
    391                  info_ptr->pcal_params = NULL;
    392              }
    393              info_ptr->valid &= ~PNG_INFO_pCAL;
    394          }
    395          #endif
    396          
    397          #if defined(PNG_iCCP_SUPPORTED)
    398          /* free any iCCP entry */
    399          #ifdef PNG_FREE_ME_SUPPORTED
    400          if ((mask & PNG_FREE_ICCP) & info_ptr->free_me)
    401          #else
    402          if (mask & PNG_FREE_ICCP)
    403          #endif
    404          {
    405              png_free(png_ptr, info_ptr->iccp_name);
    406              png_free(png_ptr, info_ptr->iccp_profile);
    407              info_ptr->iccp_name = NULL;
    408              info_ptr->iccp_profile = NULL;
    409              info_ptr->valid &= ~PNG_INFO_iCCP;
    410          }
    411          #endif
    412          
    413          #if defined(PNG_sPLT_SUPPORTED)
    414          /* free a given sPLT entry, or (if num == -1) all sPLT entries */
    415          #ifdef PNG_FREE_ME_SUPPORTED
    416          if ((mask & PNG_FREE_SPLT) & info_ptr->free_me)
    417          #else
    418          if (mask & PNG_FREE_SPLT)
    419          #endif
    420          {
    421             if (num != -1)
    422             {
    423                if(info_ptr->splt_palettes)
    424                {
    425                    png_free(png_ptr, info_ptr->splt_palettes[num].name);
    426                    png_free(png_ptr, info_ptr->splt_palettes[num].entries);
    427                    info_ptr->splt_palettes[num].name = NULL;
    428                    info_ptr->splt_palettes[num].entries = NULL;
    429                }
    430             }
    431             else
    432             {
    433                 if(info_ptr->splt_palettes_num)
    434                 {
    435                   int i;
    436                   for (i = 0; i < (int)info_ptr->splt_palettes_num; i++)
    437                      png_free_data(png_ptr, info_ptr, PNG_FREE_SPLT, i);
    438          
    439                   png_free(png_ptr, info_ptr->splt_palettes);
    440                   info_ptr->splt_palettes = NULL;
    441                   info_ptr->splt_palettes_num = 0;
    442                 }
    443                 info_ptr->valid &= ~PNG_INFO_sPLT;
    444             }
    445          }
    446          #endif
    447          
    448          #if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
    449          #ifdef PNG_FREE_ME_SUPPORTED
    450          if ((mask & PNG_FREE_UNKN) & info_ptr->free_me)
    451          #else
    452          if (mask & PNG_FREE_UNKN)
    453          #endif
    454          {
    455             if (num != -1)
    456             {
    457                 if(info_ptr->unknown_chunks)
    458                 {
    459                    png_free(png_ptr, info_ptr->unknown_chunks[num].data);
    460                    info_ptr->unknown_chunks[num].data = NULL;
    461                 }
    462             }
    463             else
    464             {
    465                 int i;
    466          
    467                 if(info_ptr->unknown_chunks_num)
    468                 {
    469                   for (i = 0; i < (int)info_ptr->unknown_chunks_num; i++)
    470                      png_free_data(png_ptr, info_ptr, PNG_FREE_UNKN, i);
    471          
    472                   png_free(png_ptr, info_ptr->unknown_chunks);
    473                   info_ptr->unknown_chunks = NULL;
    474                   info_ptr->unknown_chunks_num = 0;
    475                 }
    476             }
    477          }
    478          #endif
    479          
    480          #if defined(PNG_hIST_SUPPORTED)
    481          /* free any hIST entry */
    482          #ifdef PNG_FREE_ME_SUPPORTED
    483          if ((mask & PNG_FREE_HIST)  & info_ptr->free_me)
    484          #else
    485          if ((mask & PNG_FREE_HIST) && (png_ptr->flags & PNG_FLAG_FREE_HIST))
    486          #endif
    487          {
    488              png_free(png_ptr, info_ptr->hist);
    489              info_ptr->hist = NULL;
    490              info_ptr->valid &= ~PNG_INFO_hIST;
    491          }
    492          #endif
    493          
    494          /* free any PLTE entry that was internally allocated */
    495          #ifdef PNG_FREE_ME_SUPPORTED
    496          if ((mask & PNG_FREE_PLTE) & info_ptr->free_me)
    497          #else
    498          if ((mask & PNG_FREE_PLTE) && (png_ptr->flags & PNG_FLAG_FREE_PLTE))
    499          #endif
    500          {
    501              png_zfree(png_ptr, info_ptr->palette);
    502              info_ptr->palette = NULL;
    503              info_ptr->valid &= ~PNG_INFO_PLTE;
    504              info_ptr->num_palette = 0;
    505          }
    506          
    507          #if defined(PNG_INFO_IMAGE_SUPPORTED)
    508          /* free any image bits attached to the info structure */
    509          #ifdef PNG_FREE_ME_SUPPORTED
    510          if ((mask & PNG_FREE_ROWS) & info_ptr->free_me)
    511          #else
    512          if (mask & PNG_FREE_ROWS)
    513          #endif
    514          {
    515              if(info_ptr->row_pointers)
    516              {
    517                 int row;
    518                 for (row = 0; row < (int)info_ptr->height; row++)
    519                 {
    520                    png_free(png_ptr, info_ptr->row_pointers[row]);
    521                    info_ptr->row_pointers[row]=NULL;
    522                 }
    523                 png_free(png_ptr, info_ptr->row_pointers);
    524                 info_ptr->row_pointers=NULL;
    525              }
    526              info_ptr->valid &= ~PNG_INFO_IDAT;
    527          }
    528          #endif
    529          
    530          #ifdef PNG_FREE_ME_SUPPORTED
    531             if(num == -1)
    532               info_ptr->free_me &= ~mask;
    533             else
    534               info_ptr->free_me &= ~(mask & ~PNG_FREE_MUL);
    535          #endif
    536          }
    537          
    538          /* This is an internal routine to free any memory that the info struct is
    539           * pointing to before re-using it or freeing the struct itself.  Recall
    540           * that png_free() checks for NULL pointers for us.
    541           */
    542          void /* PRIVATE */
    543          png_info_destroy(png_structp png_ptr, png_infop info_ptr)
    544          {
    545             png_debug(1, "in png_info_destroy\n");
    546          
    547             png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);
    548          
    549          #if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
    550             if (png_ptr->num_chunk_list)
    551             {
    552                 png_free(png_ptr, png_ptr->chunk_list);
    553                 png_ptr->chunk_list=NULL;
    554                 png_ptr->num_chunk_list=0;
    555             }
    556          #endif
    557          
    558             png_info_init_3(&info_ptr, sizeof(png_info));
    559          }
    560          
    561          /* This function returns a pointer to the io_ptr associated with the user
    562           * functions.  The application should free any memory associated with this
    563           * pointer before png_write_destroy() or png_read_destroy() are called.
    564           */
    565          png_voidp PNGAPI
    566          png_get_io_ptr(png_structp png_ptr)
    567          {
    568             return (png_ptr->io_ptr);
    569          }
    570          
    571          #if !defined(PNG_NO_STDIO)
    572          /* Initialize the default input/output functions for the PNG file.  If you
    573           * use your own read or write routines, you can call either png_set_read_fn()
    574           * or png_set_write_fn() instead of png_init_io().  If you have defined
    575           * PNG_NO_STDIO, you must use a function of your own because "FILE *" isn't
    576           * necessarily available.
    577           */
    578          void PNGAPI
    579          png_init_io(png_structp png_ptr, png_FILE_p fp)
    580          {
    581             png_debug(1, "in png_init_io\n");
    582             png_ptr->io_ptr = (png_voidp)fp;
    583          }
    584          #endif
    585          
    586          #if defined(PNG_TIME_RFC1123_SUPPORTED)
    587          /* Convert the supplied time into an RFC 1123 string suitable for use in
    588           * a "Creation Time" or other text-based time string.
    589           */
    590          png_charp PNGAPI
    591          png_convert_to_rfc1123(png_structp png_ptr, png_timep ptime)
    592          {
    593             static PNG_CONST char short_months[12][4] =
    594                  {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
    595                   "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
    596          
    597             if (png_ptr->time_buffer == NULL)
    598             {
    599                png_ptr->time_buffer = (png_charp)png_malloc(png_ptr, (png_uint_32)(29*
    600                   sizeof(char)));
    601             }
    602          
    603          #if defined(_WIN32_WCE)
    604             {
    605                wchar_t time_buf[29];
    606                wsprintf(time_buf, TEXT("%d %S %d %02d:%02d:%02d +0000"),
    607                    ptime->day % 32, short_months[(ptime->month - 1) % 12],
    608                  ptime->year, ptime->hour % 24, ptime->minute % 60,
    609                    ptime->second % 61);
    610                WideCharToMultiByte(CP_ACP, 0, time_buf, -1, png_ptr->time_buffer, 29,
    611                    NULL, NULL);
    612             }
    613          #else
    614          #ifdef USE_FAR_KEYWORD
    615             {
    616                char near_time_buf[29];
    617                sprintf(near_time_buf, "%d %s %d %02d:%02d:%02d +0000",
    618                    ptime->day % 32, short_months[(ptime->month - 1) % 12],
    619                    ptime->year, ptime->hour % 24, ptime->minute % 60,
    620                    ptime->second % 61);
    621                png_memcpy(png_ptr->time_buffer, near_time_buf,
    622                    29*sizeof(char));
    623             }
    624          #else
    625             sprintf(png_ptr->time_buffer, "%d %s %d %02d:%02d:%02d +0000",
    626                 ptime->day % 32, short_months[(ptime->month - 1) % 12],
    627                 ptime->year, ptime->hour % 24, ptime->minute % 60,
    628                 ptime->second % 61);
    629          #endif
    630          #endif /* _WIN32_WCE */
    631             return ((png_charp)png_ptr->time_buffer);
    632          }
    633          #endif /* PNG_TIME_RFC1123_SUPPORTED */
    634          
    635          #if 0
    636          /* Signature string for a PNG file. */
    637          png_bytep PNGAPI
    638          png_sig_bytes(void)
    639          {
    640             return ((png_bytep)"\211\120\116\107\015\012\032\012");
    641          }
    642          #endif
    643          
    644          png_charp PNGAPI
    645          png_get_copyright(png_structp png_ptr)
    646          {
    647             if (png_ptr != NULL || png_ptr == NULL)  /* silence compiler warning */
    648             return ((png_charp) "\n libpng version 1.2.1 - December 12, 2001\n\
    649             Copyright (c) 1998-2001 Glenn Randers-Pehrson\n\
    650             Copyright (c) 1996, 1997 Andreas Dilger\n\
    651             Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.\n");
    652             return ((png_charp) "");
    653          }
    654          
    655          /* The following return the library version as a short string in the
    656           * format 1.0.0 through 99.99.99zz.  To get the version of *.h files used
    657           * with your application, print out PNG_LIBPNG_VER_STRING, which is defined
    658           * in png.h.
    659           */
    660          
    661          png_charp PNGAPI
    662          png_get_libpng_ver(png_structp png_ptr)
    663          {
    664             /* Version of *.c files used when building libpng */
    665             if(png_ptr != NULL) /* silence compiler warning about unused png_ptr */
    666                return((png_charp) "1.2.1");
    667             return((png_charp) "1.2.1");
    668          }
    669          
    670          png_charp PNGAPI
    671          png_get_header_ver(png_structp png_ptr)
    672          {
    673             /* Version of *.h files used when building libpng */
    674             if(png_ptr != NULL) /* silence compiler warning about unused png_ptr */
    675                return((png_charp) PNG_LIBPNG_VER_STRING);
    676             return((png_charp) PNG_LIBPNG_VER_STRING);
    677          }
    678          
    679          png_charp PNGAPI
    680          png_get_header_version(png_structp png_ptr)
    681          {
    682             /* Returns longer string containing both version and date */
    683             if(png_ptr != NULL) /* silence compiler warning about unused png_ptr */
    684                return((png_charp) PNG_HEADER_VERSION_STRING);
    685             return((png_charp) PNG_HEADER_VERSION_STRING);
    686          }
    687          
    688          #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
    689          int /* PRIVATE */
    690          png_handle_as_unknown(png_structp png_ptr, png_bytep chunk_name)
    691          {
    692             /* check chunk_name and return "keep" value if it's on the list, else 0 */
    693             int i;
    694             png_bytep p;
    695             if((png_ptr == NULL && chunk_name == NULL) || png_ptr->num_chunk_list<=0)
    696                return 0;
    697             p=png_ptr->chunk_list+png_ptr->num_chunk_list*5-5;
    698             for (i = png_ptr->num_chunk_list; i; i--, p-=5)
    699                if (!png_memcmp(chunk_name, p, 4))
    700                  return ((int)*(p+4));
    701             return 0;
    702          }
    703          #endif
    704          
    705          /* This function, added to libpng-1.0.6g, is untested. */
    706          int PNGAPI
    707          png_reset_zstream(png_structp png_ptr)
    708          {
    709             return (inflateReset(&png_ptr->zstream));
    710          }
    711          
    712          /* This function was added to libpng-1.0.7 */
    713          png_uint_32 PNGAPI
    714          png_access_version_number(void)
    715          {
    716             /* Version of *.c files used when building libpng */
    717             return((png_uint_32) 10201L);
    718          }
    719          
    720          
    721          #if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
    722              /* GRR:  could add this:   && defined(PNG_MMX_CODE_SUPPORTED) */
    723          /* this INTERNAL function was added to libpng 1.2.0 */
    724          void /* PRIVATE */
    725          png_init_mmx_flags (png_structp png_ptr)
    726          {
    727              png_ptr->mmx_rowbytes_threshold = 0;
    728              png_ptr->mmx_bitdepth_threshold = 0;
    729          
    730          #  if (defined(PNG_USE_PNGVCRD) || defined(PNG_USE_PNGGCCRD))
    731          
    732              png_ptr->asm_flags |= PNG_ASM_FLAG_MMX_SUPPORT_COMPILED;
    733          
    734              if (png_mmx_support()) {
    735                  png_ptr->asm_flags |= PNG_ASM_FLAG_MMX_SUPPORT_IN_CPU
    736          #    ifdef PNG_HAVE_ASSEMBLER_COMBINE_ROW
    737                                        | PNG_ASM_FLAG_MMX_READ_COMBINE_ROW
    738          #    endif
    739          #    ifdef PNG_HAVE_ASSEMBLER_READ_INTERLACE
    740                                        | PNG_ASM_FLAG_MMX_READ_INTERLACE
    741          #    endif
    742          #    ifndef PNG_HAVE_ASSEMBLER_READ_FILTER_ROW
    743                                        ;
    744          #    else
    745                                        | PNG_ASM_FLAG_MMX_READ_FILTER_SUB
    746                                        | PNG_ASM_FLAG_MMX_READ_FILTER_UP
    747                                        | PNG_ASM_FLAG_MMX_READ_FILTER_AVG
    748                                        | PNG_ASM_FLAG_MMX_READ_FILTER_PAETH ;
    749          
    750                  png_ptr->mmx_rowbytes_threshold = PNG_MMX_ROWBYTES_THRESHOLD_DEFAULT;
    751                  png_ptr->mmx_bitdepth_threshold = PNG_MMX_BITDEPTH_THRESHOLD_DEFAULT;
    752          #    endif
    753              } else {
    754                  png_ptr->asm_flags &= ~( PNG_ASM_FLAG_MMX_SUPPORT_IN_CPU
    755                                         | PNG_MMX_READ_FLAGS
    756                                         | PNG_MMX_WRITE_FLAGS );
    757              }
    758          
    759          #  else /* !((PNGVCRD || PNGGCCRD) && PNG_ASSEMBLER_CODE_SUPPORTED)) */
    760          
    761              /* clear all MMX flags; no support is compiled in */
    762              png_ptr->asm_flags &= ~( PNG_MMX_FLAGS );
    763          
    764          #  endif /* ?(PNGVCRD || PNGGCCRD) */
    765          }
    766          
    767          #endif /* !(PNG_ASSEMBLER_CODE_SUPPORTED) */
    768          
    769          /* this function was added to libpng 1.2.0 */
    770          #if !defined(PNG_USE_PNGGCCRD) && \
    771              !(defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_USE_PNGVCRD))
    772          int PNGAPI
    773          png_mmx_support(void)
    774          {
    775              return -1;
    776          }
    777          #endif

Errors: 69
Warnings: none
