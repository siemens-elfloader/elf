##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    19/Jan/2011  13:21:05 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\grabber\jpeg-7\jdhuff.c                       #
#    Command line    =  C:\arm\grabber\jpeg-7\jdhuff.c -lC                   #
#                       C:\arm\grabber\Release_SGOLD\List\ -o                #
#                       C:\arm\grabber\Release_SGOLD\Obj\ -s9 --no_unroll    #
#                       --no_clustering --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --fpu None --dlib_config "C:\arm2\Embedded           #
#                       Workbench 4.0 Evaluation\ARM\LIB\dl5tpainl8n.h" -I   #
#                       "C:\arm2\Embedded Workbench 4.0                      #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  C:\arm\grabber\Release_SGOLD\List\jdhuff.lst         #
#    Object file     =  C:\arm\grabber\Release_SGOLD\Obj\jdhuff.r79          #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\grabber\jpeg-7\jdhuff.c
      1          /*
                  ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           * jdhuff.c
      3           *
      4           * Copyright (C) 1991-1997, Thomas G. Lane.
      5           * Modified 2006-2009 by Guido Vollbeding.
      6           * This file is part of the Independent JPEG Group's software.
      7           * For conditions of distribution and use, see the accompanying README file.
      8           *
      9           * This file contains Huffman entropy decoding routines.
     10           * Both sequential and progressive modes are supported in this single module.
     11           *
     12           * Much of the complexity here has to do with supporting input suspension.
     13           * If the data source module demands suspension, we want to be able to back
     14           * up to the start of the current MCU.  To do this, we copy state variables
     15           * into local working storage, and update them back to the permanent
     16           * storage only upon successful completion of an MCU.
     17           */
     18          
     19          #define JPEG_INTERNALS
     20          #include "jinclude.h"
     21          #include "jpeglib.h"
     22          
     23          
     24          /* Derived data constructed for each Huffman table */
     25          
     26          #define HUFF_LOOKAHEAD	8	/* # of bits of lookahead */
     27          
     28          typedef struct {
     29            /* Basic tables: (element [0] of each array is unused) */
     30            INT32 maxcode[18];		/* largest code of length k (-1 if none) */
     31            /* (maxcode[17] is a sentinel to ensure jpeg_huff_decode terminates) */
     32            INT32 valoffset[17];		/* huffval[] offset for codes of length k */
     33            /* valoffset[k] = huffval[] index of 1st symbol of code length k, less
     34             * the smallest code of length k; so given a code of length k, the
     35             * corresponding symbol is huffval[code + valoffset[k]]
     36             */
     37          
     38            /* Link to public Huffman table (needed only in jpeg_huff_decode) */
     39            JHUFF_TBL *pub;
     40          
     41            /* Lookahead tables: indexed by the next HUFF_LOOKAHEAD bits of
     42             * the input data stream.  If the next Huffman code is no more
     43             * than HUFF_LOOKAHEAD bits long, we can obtain its length and
     44             * the corresponding symbol directly from these tables.
     45             */
     46            int look_nbits[1<<HUFF_LOOKAHEAD]; /* # bits, or 0 if too long */
     47            UINT8 look_sym[1<<HUFF_LOOKAHEAD]; /* symbol, or unused */
     48          } d_derived_tbl;
     49          
     50          
     51          /*
     52           * Fetching the next N bits from the input stream is a time-critical operation
     53           * for the Huffman decoders.  We implement it with a combination of inline
     54           * macros and out-of-line subroutines.  Note that N (the number of bits
     55           * demanded at one time) never exceeds 15 for JPEG use.
     56           *
     57           * We read source bytes into get_buffer and dole out bits as needed.
     58           * If get_buffer already contains enough bits, they are fetched in-line
     59           * by the macros CHECK_BIT_BUFFER and GET_BITS.  When there aren't enough
     60           * bits, jpeg_fill_bit_buffer is called; it will attempt to fill get_buffer
     61           * as full as possible (not just to the number of bits needed; this
     62           * prefetching reduces the overhead cost of calling jpeg_fill_bit_buffer).
     63           * Note that jpeg_fill_bit_buffer may return FALSE to indicate suspension.
     64           * On TRUE return, jpeg_fill_bit_buffer guarantees that get_buffer contains
     65           * at least the requested number of bits --- dummy zeroes are inserted if
     66           * necessary.
     67           */
     68          
     69          typedef INT32 bit_buf_type;	/* type of bit-extraction buffer */
     70          #define BIT_BUF_SIZE  32	/* size of buffer in bits */
     71          
     72          /* If long is > 32 bits on your machine, and shifting/masking longs is
     73           * reasonably fast, making bit_buf_type be long and setting BIT_BUF_SIZE
     74           * appropriately should be a win.  Unfortunately we can't define the size
     75           * with something like  #define BIT_BUF_SIZE (sizeof(bit_buf_type)*8)
     76           * because not all machines measure sizeof in 8-bit bytes.
     77           */
     78          
     79          typedef struct {		/* Bitreading state saved across MCUs */
     80            bit_buf_type get_buffer;	/* current bit-extraction buffer */
     81            int bits_left;		/* # of unused bits in it */
     82          } bitread_perm_state;
     83          
     84          typedef struct {		/* Bitreading working state within an MCU */
     85            /* Current data source location */
     86            /* We need a copy, rather than munging the original, in case of suspension */
     87            const JOCTET * next_input_byte; /* => next byte to read from source */
     88            size_t bytes_in_buffer;	/* # of bytes remaining in source buffer */
     89            /* Bit input buffer --- note these values are kept in register variables,
     90             * not in this struct, inside the inner loops.
     91             */
     92            bit_buf_type get_buffer;	/* current bit-extraction buffer */
     93            int bits_left;		/* # of unused bits in it */
     94            /* Pointer needed by jpeg_fill_bit_buffer. */
     95            j_decompress_ptr cinfo;	/* back link to decompress master record */
     96          } bitread_working_state;
     97          
     98          /* Macros to declare and load/save bitread local variables. */
     99          #define BITREAD_STATE_VARS  \
    100          	register bit_buf_type get_buffer;  \
    101          	register int bits_left;  \
    102          	bitread_working_state br_state
    103          
    104          #define BITREAD_LOAD_STATE(cinfop,permstate)  \
    105          	br_state.cinfo = cinfop; \
    106          	br_state.next_input_byte = cinfop->src->next_input_byte; \
    107          	br_state.bytes_in_buffer = cinfop->src->bytes_in_buffer; \
    108          	get_buffer = permstate.get_buffer; \
    109          	bits_left = permstate.bits_left;
    110          
    111          #define BITREAD_SAVE_STATE(cinfop,permstate)  \
    112          	cinfop->src->next_input_byte = br_state.next_input_byte; \
    113          	cinfop->src->bytes_in_buffer = br_state.bytes_in_buffer; \
    114          	permstate.get_buffer = get_buffer; \
    115          	permstate.bits_left = bits_left
    116          
    117          /*
    118           * These macros provide the in-line portion of bit fetching.
    119           * Use CHECK_BIT_BUFFER to ensure there are N bits in get_buffer
    120           * before using GET_BITS, PEEK_BITS, or DROP_BITS.
    121           * The variables get_buffer and bits_left are assumed to be locals,
    122           * but the state struct might not be (jpeg_huff_decode needs this).
    123           *	CHECK_BIT_BUFFER(state,n,action);
    124           *		Ensure there are N bits in get_buffer; if suspend, take action.
    125           *      val = GET_BITS(n);
    126           *		Fetch next N bits.
    127           *      val = PEEK_BITS(n);
    128           *		Fetch next N bits without removing them from the buffer.
    129           *	DROP_BITS(n);
    130           *		Discard next N bits.
    131           * The value N should be a simple variable, not an expression, because it
    132           * is evaluated multiple times.
    133           */
    134          
    135          #define CHECK_BIT_BUFFER(state,nbits,action) \
    136          	{ if (bits_left < (nbits)) {  \
    137          	    if (! jpeg_fill_bit_buffer(&(state),get_buffer,bits_left,nbits))  \
    138          	      { action; }  \
    139          	    get_buffer = (state).get_buffer; bits_left = (state).bits_left; } }
    140          
    141          #define GET_BITS(nbits) \
    142          	(((int) (get_buffer >> (bits_left -= (nbits)))) & BIT_MASK(nbits))
    143          
    144          #define PEEK_BITS(nbits) \
    145          	(((int) (get_buffer >> (bits_left -  (nbits)))) & BIT_MASK(nbits))
    146          
    147          #define DROP_BITS(nbits) \
    148          	(bits_left -= (nbits))
    149          
    150          
    151          /*
    152           * Code for extracting next Huffman-coded symbol from input bit stream.
    153           * Again, this is time-critical and we make the main paths be macros.
    154           *
    155           * We use a lookahead table to process codes of up to HUFF_LOOKAHEAD bits
    156           * without looping.  Usually, more than 95% of the Huffman codes will be 8
    157           * or fewer bits long.  The few overlength codes are handled with a loop,
    158           * which need not be inline code.
    159           *
    160           * Notes about the HUFF_DECODE macro:
    161           * 1. Near the end of the data segment, we may fail to get enough bits
    162           *    for a lookahead.  In that case, we do it the hard way.
    163           * 2. If the lookahead table contains no entry, the next code must be
    164           *    more than HUFF_LOOKAHEAD bits long.
    165           * 3. jpeg_huff_decode returns -1 if forced to suspend.
    166           */
    167          
    168          #define HUFF_DECODE(result,state,htbl,failaction,slowlabel) \
    169          { register int nb, look; \
    170            if (bits_left < HUFF_LOOKAHEAD) { \
    171              if (! jpeg_fill_bit_buffer(&state,get_buffer,bits_left, 0)) {failaction;} \
    172              get_buffer = state.get_buffer; bits_left = state.bits_left; \
    173              if (bits_left < HUFF_LOOKAHEAD) { \
    174                nb = 1; goto slowlabel; \
    175              } \
    176            } \
    177            look = PEEK_BITS(HUFF_LOOKAHEAD); \
    178            if ((nb = htbl->look_nbits[look]) != 0) { \
    179              DROP_BITS(nb); \
    180              result = htbl->look_sym[look]; \
    181            } else { \
    182              nb = HUFF_LOOKAHEAD+1; \
    183          slowlabel: \
    184              if ((result=jpeg_huff_decode(&state,get_buffer,bits_left,htbl,nb)) < 0) \
    185          	{ failaction; } \
    186              get_buffer = state.get_buffer; bits_left = state.bits_left; \
    187            } \
    188          }
    189          
    190          
    191          /*
    192           * Expanded entropy decoder object for Huffman decoding.
    193           *
    194           * The savable_state subrecord contains fields that change within an MCU,
    195           * but must not be updated permanently until we complete the MCU.
    196           */
    197          
    198          typedef struct {
    199            unsigned int EOBRUN;			/* remaining EOBs in EOBRUN */
    200            int last_dc_val[MAX_COMPS_IN_SCAN];	/* last DC coef for each component */
    201          } savable_state;
    202          
    203          /* This macro is to work around compilers with missing or broken
    204           * structure assignment.  You'll need to fix this code if you have
    205           * such a compiler and you change MAX_COMPS_IN_SCAN.
    206           */
    207          
    208          #ifndef NO_STRUCT_ASSIGN
    209          #define ASSIGN_STATE(dest,src)  ((dest) = (src))
    210          #else
    211          #if MAX_COMPS_IN_SCAN == 4
    212          #define ASSIGN_STATE(dest,src)  \
    213          	((dest).EOBRUN = (src).EOBRUN, \
    214          	 (dest).last_dc_val[0] = (src).last_dc_val[0], \
    215          	 (dest).last_dc_val[1] = (src).last_dc_val[1], \
    216          	 (dest).last_dc_val[2] = (src).last_dc_val[2], \
    217          	 (dest).last_dc_val[3] = (src).last_dc_val[3])
    218          #endif
    219          #endif
    220          
    221          
    222          typedef struct {
    223            struct jpeg_entropy_decoder pub; /* public fields */
    224          
    225            /* These fields are loaded into local variables at start of each MCU.
    226             * In case of suspension, we exit WITHOUT updating them.
    227             */
    228            bitread_perm_state bitstate;	/* Bit buffer at start of MCU */
    229            savable_state saved;		/* Other state at start of MCU */
    230          
    231            /* These fields are NOT loaded into local working state. */
    232            unsigned int restarts_to_go;	/* MCUs left in this restart interval */
    233          
    234            /* Following two fields used only in progressive mode */
    235          
    236            /* Pointers to derived tables (these workspaces have image lifespan) */
    237            d_derived_tbl * derived_tbls[NUM_HUFF_TBLS];
    238          
    239            d_derived_tbl * ac_derived_tbl; /* active table during an AC scan */
    240          
    241            /* Following fields used only in sequential mode */
    242          
    243            /* Pointers to derived tables (these workspaces have image lifespan) */
    244            d_derived_tbl * dc_derived_tbls[NUM_HUFF_TBLS];
    245            d_derived_tbl * ac_derived_tbls[NUM_HUFF_TBLS];
    246          
    247            /* Precalculated info set up by start_pass for use in decode_mcu: */
    248          
    249            /* Pointers to derived tables to be used for each block within an MCU */
    250            d_derived_tbl * dc_cur_tbls[D_MAX_BLOCKS_IN_MCU];
    251            d_derived_tbl * ac_cur_tbls[D_MAX_BLOCKS_IN_MCU];
    252            /* Whether we care about the DC and AC coefficient values for each block */
    253            int coef_limit[D_MAX_BLOCKS_IN_MCU];
    254          } huff_entropy_decoder;
    255          
    256          typedef huff_entropy_decoder * huff_entropy_ptr;
    257          
    258          

   \                                 In segment DATA_C, align 4, align-sorted
    259          static const int jpeg_zigzag_order[8][8] = {
   \                     jpeg_zigzag_order:
   \   00000000   000000000100       DC32 0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12
   \              000005000000
   \              060000000E00
   \              00000F000000
   \              1B0000001C00
   \              000002000000
   \              040000000700
   \              00000D000000
   \              100000001A00
   \              00001D000000
   \              2A0000000300
   \              000008000000
   \              0C000000    
   \   0000004C   110000001900       DC32 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32
   \              00001E000000
   \              290000002B00
   \              000009000000
   \              0B0000001200
   \              000018000000
   \              1F0000002800
   \              00002C000000
   \              350000000A00
   \              000013000000
   \              170000002000
   \              0000        
   \   00000090   270000002D00       DC32 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50
   \              000034000000
   \              360000001400
   \              000016000000
   \              210000002600
   \              00002E000000
   \              330000003700
   \              00003C000000
   \              150000002200
   \              000025000000
   \              2F0000003200
   \              0000        
   \   000000D4   380000003B00       DC32 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63
   \              00003D000000
   \              230000002400
   \              000030000000
   \              310000003900
   \              00003A000000
   \              3E0000003F00
   \              0000        
    260            {  0,  1,  5,  6, 14, 15, 27, 28 },
    261            {  2,  4,  7, 13, 16, 26, 29, 42 },
    262            {  3,  8, 12, 17, 25, 30, 41, 43 },
    263            {  9, 11, 18, 24, 31, 40, 44, 53 },
    264            { 10, 19, 23, 32, 39, 45, 52, 54 },
    265            { 20, 22, 33, 38, 46, 51, 55, 60 },
    266            { 21, 34, 37, 47, 50, 56, 59, 61 },
    267            { 35, 36, 48, 49, 57, 58, 62, 63 }
    268          };
    269          
    270          
    271          /*
    272           * Compute the derived values for a Huffman table.
    273           * This routine also performs some validation checks on the table.
    274           */
    275          

   \                                 In segment CODE, align 4, keep-with-next
    276          LOCAL(void)
    277          jpeg_make_d_derived_tbl (j_decompress_ptr cinfo, boolean isDC, int tblno,
    278          			 d_derived_tbl ** pdtbl)
    279          {
   \                     jpeg_make_d_derived_tbl:
   \   00000000   F24F2DE9           PUSH     {R1,R4-R11,LR}
   \   00000004   43DF4DE2           SUB      SP,SP,#+268
   \   00000008   40DE4DE2           SUB      SP,SP,#+1024
   \   0000000C   0050A0E1           MOV      R5,R0
   \   00000010   0240A0E1           MOV      R4,R2
   \   00000014   0370A0E1           MOV      R7,R3
    280            JHUFF_TBL *htbl;
    281            d_derived_tbl *dtbl;
    282            int p, i, l, si, numsymbols;
    283            int lookbits, ctr;
    284            char huffsize[257];
    285            unsigned int huffcode[257];
    286            unsigned int code;
    287          
    288            /* Note that huffsize[] and huffcode[] are filled in code-length order,
    289             * paralleling the order of the symbols themselves in htbl->huffval[].
    290             */
    291          
    292            /* Find the input Huffman table */
    293            if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
   \   00000018   3480A0E3           MOV      R8,#+52
   \   0000001C   000054E3           CMP      R4,#+0
   \   00000020   0100004A           BMI      ??jpeg_make_d_derived_tbl_0
   \   00000024   040054E3           CMP      R4,#+4
   \   00000028   070000BA           BLT      ??jpeg_make_d_derived_tbl_1
    294              ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
   \                     ??jpeg_make_d_derived_tbl_0:
   \   0000002C   000095E5           LDR      R0,[R5, #+0]
   \   00000030   148080E5           STR      R8,[R0, #+20]
   \   00000034   000095E5           LDR      R0,[R5, #+0]
   \   00000038   184080E5           STR      R4,[R0, #+24]
   \   0000003C   001095E5           LDR      R1,[R5, #+0]
   \   00000040   0500A0E1           MOV      R0,R5
   \   00000044   001091E5           LDR      R1,[R1, #+0]
   \   00000048   31FF2FE1           BLX      R1
    295            htbl =
    296              isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
   \                     ??jpeg_make_d_derived_tbl_1:
   \   0000004C   0C159DE5           LDR      R1,[SP, #+1292]
   \   00000050   040185E0           ADD      R0,R5,R4, LSL #+2
   \   00000054   000051E3           CMP      R1,#+0
   \   00000058   B0609015           LDRNE    R6,[R0, #+176]
   \   0000005C   C0609005           LDREQ    R6,[R0, #+192]
    297            if (htbl == NULL)
   \   00000060   000056E3           CMP      R6,#+0
   \   00000064   0700001A           BNE      ??jpeg_make_d_derived_tbl_2
    298              ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
   \   00000068   000095E5           LDR      R0,[R5, #+0]
   \   0000006C   148080E5           STR      R8,[R0, #+20]
   \   00000070   000095E5           LDR      R0,[R5, #+0]
   \   00000074   184080E5           STR      R4,[R0, #+24]
   \   00000078   001095E5           LDR      R1,[R5, #+0]
   \   0000007C   0500A0E1           MOV      R0,R5
   \   00000080   001091E5           LDR      R1,[R1, #+0]
   \   00000084   31FF2FE1           BLX      R1
    299          
    300            /* Allocate a workspace if we haven't already done so. */
    301            if (*pdtbl == NULL)
   \                     ??jpeg_make_d_derived_tbl_2:
   \   00000088   000097E5           LDR      R0,[R7, #+0]
   \   0000008C   000050E3           CMP      R0,#+0
   \   00000090   0600001A           BNE      ??jpeg_make_d_derived_tbl_3
    302              *pdtbl = (d_derived_tbl *)
    303                (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
    304          				  SIZEOF(d_derived_tbl));
   \   00000094   043095E5           LDR      R3,[R5, #+4]
   \   00000098   592EA0E3           MOV      R2,#+1424
   \   0000009C   003093E5           LDR      R3,[R3, #+0]
   \   000000A0   0110A0E3           MOV      R1,#+1
   \   000000A4   0500A0E1           MOV      R0,R5
   \   000000A8   33FF2FE1           BLX      R3
   \   000000AC   000087E5           STR      R0,[R7, #+0]
    305            dtbl = *pdtbl;
   \                     ??jpeg_make_d_derived_tbl_3:
   \   000000B0   007097E5           LDR      R7,[R7, #+0]
    306            dtbl->pub = htbl;		/* fill in back link */
    307            
    308            /* Figure C.1: make table of Huffman code length for each symbol */
    309          
    310            p = 0;
   \   000000B4   0090A0E3           MOV      R9,#+0
   \   000000B8   8C6087E5           STR      R6,[R7, #+140]
    311            for (l = 1; l <= 16; l++) {
   \   000000BC   01A0A0E3           MOV      R10,#+1
   \   000000C0   0980A0E3           MOV      R8,#+9
    312              i = (int) htbl->bits[l];
   \                     ??jpeg_make_d_derived_tbl_4:
   \   000000C4   0640DAE7           LDRB     R4,[R10, +R6]
    313              if (i < 0 || p + i > 256)	/* protect against table overrun */
   \   000000C8   000054E3           CMP      R4,#+0
   \   000000CC   0300004A           BMI      ??jpeg_make_d_derived_tbl_5
   \   000000D0   090084E0           ADD      R0,R4,R9
   \   000000D4   F81088E2           ADD      R1,R8,#+248
   \   000000D8   010050E1           CMP      R0,R1
   \   000000DC   080000BA           BLT      ??jpeg_make_d_derived_tbl_6
    314                ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
   \                     ??jpeg_make_d_derived_tbl_5:
   \   000000E0   000095E5           LDR      R0,[R5, #+0]
   \   000000E4   148080E5           STR      R8,[R0, #+20]
   \   000000E8   001095E5           LDR      R1,[R5, #+0]
   \   000000EC   0500A0E1           MOV      R0,R5
   \   000000F0   001091E5           LDR      R1,[R1, #+0]
   \   000000F4   31FF2FE1           BLX      R1
   \   000000F8   010000EA           B        ??jpeg_make_d_derived_tbl_6
    315              while (i--)
    316                huffsize[p++] = (char) l;
   \                     ??jpeg_make_d_derived_tbl_7:
   \   000000FC   00A0C0E5           STRB     R10,[R0, #+0]
   \   00000100   019089E2           ADD      R9,R9,#+1
   \                     ??jpeg_make_d_derived_tbl_6:
   \   00000104   0410A0E1           MOV      R1,R4
   \   00000108   014041E2           SUB      R4,R1,#+1
   \   0000010C   08008DE2           ADD      R0,SP,#+8
   \   00000110   400E80E2           ADD      R0,R0,#+1024
   \   00000114   000089E0           ADD      R0,R9,R0
   \   00000118   000051E3           CMP      R1,#+0
   \   0000011C   F6FFFF1A           BNE      ??jpeg_make_d_derived_tbl_7
    317            }
   \   00000120   01A08AE2           ADD      R10,R10,#+1
   \   00000124   11005AE3           CMP      R10,#+17
   \   00000128   E5FFFFBA           BLT      ??jpeg_make_d_derived_tbl_4
    318            huffsize[p] = 0;
   \   0000012C   0040A0E3           MOV      R4,#+0
   \   00000130   0040C0E5           STRB     R4,[R0, #+0]
    319            numsymbols = p;
   \   00000134   00908DE5           STR      R9,[SP, #+0]
    320            
    321            /* Figure C.2: generate the codes themselves */
    322            /* We also validate that the counts represent a legal Huffman code tree. */
    323            
    324            code = 0;
    325            si = huffsize[0];
   \   00000138   08A4DDE5           LDRB     R10,[SP, #+1032]
    326            p = 0;
   \   0000013C   00B0A0E3           MOV      R11,#+0
   \   00000140   0190A0E3           MOV      R9,#+1
   \   00000144   00005AE3           CMP      R10,#+0
   \   00000148   1300001A           BNE      ??jpeg_make_d_derived_tbl_8
   \   0000014C   170000EA           B        ??jpeg_make_d_derived_tbl_9
    327            while (huffsize[p]) {
    328              while (((int) huffsize[p]) == si) {
    329                huffcode[p++] = code;
   \                     ??jpeg_make_d_derived_tbl_10:
   \   00000150   04008DE2           ADD      R0,SP,#+4
   \   00000154   0B4180E7           STR      R4,[R0, +R11, LSL #+2]
   \   00000158   01B08BE2           ADD      R11,R11,#+1
    330                code++;
   \   0000015C   014084E2           ADD      R4,R4,#+1
    331              }
   \                     ??jpeg_make_d_derived_tbl_11:
   \   00000160   08008DE2           ADD      R0,SP,#+8
   \   00000164   400E80E2           ADD      R0,R0,#+1024
   \   00000168   0000DBE7           LDRB     R0,[R11, +R0]
   \   0000016C   0A0050E1           CMP      R0,R10
   \   00000170   F6FFFF0A           BEQ      ??jpeg_make_d_derived_tbl_10
    332              /* code is now 1 more than the last code used for codelength si; but
    333               * it must still fit in si bits, since no code is allowed to be all ones.
    334               */
    335              if (((INT32) code) >= (((INT32) 1) << si))
   \   00000174   190A54E1           CMP      R4,R9, LSL R10
   \   00000178   050000BA           BLT      ??jpeg_make_d_derived_tbl_12
    336                ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
   \   0000017C   000095E5           LDR      R0,[R5, #+0]
   \   00000180   148080E5           STR      R8,[R0, #+20]
   \   00000184   001095E5           LDR      R1,[R5, #+0]
   \   00000188   0500A0E1           MOV      R0,R5
   \   0000018C   001091E5           LDR      R1,[R1, #+0]
   \   00000190   31FF2FE1           BLX      R1
    337              code <<= 1;
   \                     ??jpeg_make_d_derived_tbl_12:
   \   00000194   8440A0E1           LSL      R4,R4,#+1
    338              si++;
   \   00000198   01A08AE2           ADD      R10,R10,#+1
    339            }
   \                     ??jpeg_make_d_derived_tbl_8:
   \   0000019C   08008DE2           ADD      R0,SP,#+8
   \   000001A0   400E80E2           ADD      R0,R0,#+1024
   \   000001A4   0000DBE7           LDRB     R0,[R11, +R0]
   \   000001A8   000050E3           CMP      R0,#+0
   \   000001AC   EBFFFF1A           BNE      ??jpeg_make_d_derived_tbl_11
    340          
    341            /* Figure F.15: generate decoding tables for bit-sequential decoding */
    342          
    343            p = 0;
   \                     ??jpeg_make_d_derived_tbl_9:
   \   000001B0   0010A0E3           MOV      R1,#+0
    344            for (l = 1; l <= 16; l++) {
   \   000001B4   0100A0E3           MOV      R0,#+1
    345              if (htbl->bits[l]) {
   \                     ??jpeg_make_d_derived_tbl_13:
   \   000001B8   0620D0E7           LDRB     R2,[R0, +R6]
   \   000001BC   000052E3           CMP      R2,#+0
   \   000001C0   0A00000A           BEQ      ??jpeg_make_d_derived_tbl_14
    346                /* valoffset[l] = huffval[] index of 1st symbol of code length l,
    347                 * minus the minimum code of length l
    348                 */
    349                dtbl->valoffset[l] = (INT32) p - (INT32) huffcode[p];
   \   000001C4   04308DE2           ADD      R3,SP,#+4
   \   000001C8   013193E7           LDR      R3,[R3, +R1, LSL #+2]
   \   000001CC   002187E0           ADD      R2,R7,R0, LSL #+2
   \   000001D0   033041E0           SUB      R3,R1,R3
   \   000001D4   483082E5           STR      R3,[R2, #+72]
    350                p += htbl->bits[l];
   \   000001D8   0620D0E7           LDRB     R2,[R0, +R6]
   \   000001DC   011082E0           ADD      R1,R2,R1
    351                dtbl->maxcode[l] = huffcode[p-1]; /* maximum code of length l */
   \   000001E0   04208DE2           ADD      R2,SP,#+4
   \   000001E4   012182E0           ADD      R2,R2,R1, LSL #+2
   \   000001E8   042012E5           LDR      R2,[R2, #-4]
   \   000001EC   000000EA           B        ??jpeg_make_d_derived_tbl_15
    352              } else {
    353                dtbl->maxcode[l] = -1;	/* -1 if no codes of this length */
   \                     ??jpeg_make_d_derived_tbl_14:
   \   000001F0   002069E2           RSB      R2,R9,#+0
   \                     ??jpeg_make_d_derived_tbl_15:
   \   000001F4   002187E7           STR      R2,[R7, +R0, LSL #+2]
    354              }
    355            }
   \   000001F8   010080E2           ADD      R0,R0,#+1
   \   000001FC   110050E3           CMP      R0,#+17
   \   00000200   ECFFFFBA           BLT      ??jpeg_make_d_derived_tbl_13
    356            dtbl->maxcode[17] = 0xFFFFFL; /* ensures jpeg_huff_decode terminates */
   \   00000204   F004E0E3           MVN      R0,#-268435456
   \   00000208   FF06C0E3           BIC      R0,R0,#0xFF00000
   \   0000020C   440087E5           STR      R0,[R7, #+68]
    357          
    358            /* Compute lookahead tables to speed up decoding.
    359             * First we set all the table entries to 0, indicating "too long";
    360             * then we iterate through the Huffman codes that are short enough and
    361             * fill in all the entries that correspond to bit sequences starting
    362             * with that code.
    363             */
    364          
    365            MEMZERO(dtbl->look_nbits, SIZEOF(dtbl->look_nbits));
   \   00000210   402EA0E3           MOV      R2,#+1024
   \   00000214   0010A0E3           MOV      R1,#+0
   \   00000218   900087E2           ADD      R0,R7,#+144
   \   0000021C   BB0000EF           SWI      +187
    366          
    367            p = 0;
   \   00000220   0000A0E3           MOV      R0,#+0
    368            for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
   \   00000224   0110A0E3           MOV      R1,#+1
    369              for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {
   \                     ??jpeg_make_d_derived_tbl_16:
   \   00000228   0620D1E7           LDRB     R2,[R1, +R6]
   \   0000022C   0140A0E3           MOV      R4,#+1
   \   00000230   000052E3           CMP      R2,#+0
   \   00000234   1300001A           BNE      ??jpeg_make_d_derived_tbl_17
   \   00000238   150000EA           B        ??jpeg_make_d_derived_tbl_18
    370                /* l = current code's length, p = its index in huffcode[] & huffval[]. */
    371                /* Generate left-justified code followed by all possible bit sequences */
    372                lookbits = huffcode[p] << (HUFF_LOOKAHEAD-l);
   \                     ??jpeg_make_d_derived_tbl_19:
   \   0000023C   04208DE2           ADD      R2,SP,#+4
   \   00000240   002192E7           LDR      R2,[R2, +R0, LSL #+2]
   \   00000244   083061E2           RSB      R3,R1,#+8
   \   00000248   1223A0E1           LSL      R2,R2,R3
    373                for (ctr = 1 << (HUFF_LOOKAHEAD-l); ctr > 0; ctr--) {
   \   0000024C   1933A0E1           LSL      R3,R9,R3
   \   00000250   010053E3           CMP      R3,#+1
   \   00000254   090000BA           BLT      ??jpeg_make_d_derived_tbl_20
    374          	dtbl->look_nbits[lookbits] = l;
   \                     ??jpeg_make_d_derived_tbl_21:
   \   00000258   02A187E0           ADD      R10,R7,R2, LSL #+2
   \   0000025C   90108AE5           STR      R1,[R10, #+144]
    375          	dtbl->look_sym[lookbits] = htbl->huffval[p];
   \   00000260   06B080E0           ADD      R11,R0,R6
   \   00000264   11B0DBE5           LDRB     R11,[R11, #+17]
   \   00000268   07A082E0           ADD      R10,R2,R7
    376          	lookbits++;
   \   0000026C   012082E2           ADD      R2,R2,#+1
   \   00000270   90B4CAE5           STRB     R11,[R10, #+1168]
    377                }
   \   00000274   013043E2           SUB      R3,R3,#+1
   \   00000278   010053E3           CMP      R3,#+1
   \   0000027C   F5FFFFAA           BGE      ??jpeg_make_d_derived_tbl_21
    378              }
   \                     ??jpeg_make_d_derived_tbl_20:
   \   00000280   014084E2           ADD      R4,R4,#+1
   \   00000284   010080E2           ADD      R0,R0,#+1
   \                     ??jpeg_make_d_derived_tbl_17:
   \   00000288   0620D1E7           LDRB     R2,[R1, +R6]
   \   0000028C   040052E1           CMP      R2,R4
   \   00000290   E9FFFFAA           BGE      ??jpeg_make_d_derived_tbl_19
    379            }
   \                     ??jpeg_make_d_derived_tbl_18:
   \   00000294   011081E2           ADD      R1,R1,#+1
   \   00000298   090051E3           CMP      R1,#+9
   \   0000029C   E1FFFFBA           BLT      ??jpeg_make_d_derived_tbl_16
    380          
    381            /* Validate symbols as being reasonable.
    382             * For AC tables, we make no check, but accept all byte values 0..255.
    383             * For DC tables, we require the symbols to be in range 0..15.
    384             * (Tighter bounds could be applied depending on the data depth and mode,
    385             * but this is sufficient to ensure safe decoding.)
    386             */
    387            if (isDC) {
   \   000002A0   0C059DE5           LDR      R0,[SP, #+1292]
   \   000002A4   000050E3           CMP      R0,#+0
   \   000002A8   1500000A           BEQ      ??jpeg_make_d_derived_tbl_22
    388              for (i = 0; i < numsymbols; i++) {
   \   000002AC   00009DE5           LDR      R0,[SP, #+0]
   \   000002B0   0040A0E3           MOV      R4,#+0
   \   000002B4   010050E3           CMP      R0,#+1
   \   000002B8   0E0000AA           BGE      ??jpeg_make_d_derived_tbl_23
   \   000002BC   51DE8DE2           ADD      SP,SP,#+1296
   \   000002C0   F08FBDE8           POP      {R4-R11,PC}
    389                int sym = htbl->huffval[i];
   \                     ??jpeg_make_d_derived_tbl_24:
   \   000002C4   060084E0           ADD      R0,R4,R6
   \   000002C8   1100D0E5           LDRB     R0,[R0, #+17]
    390                if (sym < 0 || sym > 15)
   \   000002CC   000050E3           CMP      R0,#+0
   \   000002D0   0100004A           BMI      ??jpeg_make_d_derived_tbl_25
   \   000002D4   100050E3           CMP      R0,#+16
   \   000002D8   050000BA           BLT      ??jpeg_make_d_derived_tbl_26
    391          	ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
   \                     ??jpeg_make_d_derived_tbl_25:
   \   000002DC   000095E5           LDR      R0,[R5, #+0]
   \   000002E0   148080E5           STR      R8,[R0, #+20]
   \   000002E4   001095E5           LDR      R1,[R5, #+0]
   \   000002E8   0500A0E1           MOV      R0,R5
   \   000002EC   001091E5           LDR      R1,[R1, #+0]
   \   000002F0   31FF2FE1           BLX      R1
    392              }
   \                     ??jpeg_make_d_derived_tbl_26:
   \   000002F4   014084E2           ADD      R4,R4,#+1
   \                     ??jpeg_make_d_derived_tbl_23:
   \   000002F8   00009DE5           LDR      R0,[SP, #+0]
   \   000002FC   000054E1           CMP      R4,R0
   \   00000300   EFFFFFBA           BLT      ??jpeg_make_d_derived_tbl_24
    393            }
    394          }
   \                     ??jpeg_make_d_derived_tbl_22:
   \   00000304   51DE8DE2           ADD      SP,SP,#+1296     ;; stack cleaning
   \   00000308   F08FBDE8           POP      {R4-R11,PC}      ;; return
    395          
    396          
    397          /*
    398           * Out-of-line code for bit fetching.
    399           * Note: current values of get_buffer and bits_left are passed as parameters,
    400           * but are returned in the corresponding fields of the state struct.
    401           *
    402           * On most machines MIN_GET_BITS should be 25 to allow the full 32-bit width
    403           * of get_buffer to be used.  (On machines with wider words, an even larger
    404           * buffer could be used.)  However, on some machines 32-bit shifts are
    405           * quite slow and take time proportional to the number of places shifted.
    406           * (This is true with most PC compilers, for instance.)  In this case it may
    407           * be a win to set MIN_GET_BITS to the minimum value of 15.  This reduces the
    408           * average shift distance at the cost of more calls to jpeg_fill_bit_buffer.
    409           */
    410          
    411          #ifdef SLOW_SHIFT_32
    412          #define MIN_GET_BITS  15	/* minimum allowable value */
    413          #else
    414          #define MIN_GET_BITS  (BIT_BUF_SIZE-7)
    415          #endif
    416          
    417          

   \                                 In segment CODE, align 4, keep-with-next
    418          LOCAL(boolean)
    419          jpeg_fill_bit_buffer (bitread_working_state * state,
    420          		      register bit_buf_type get_buffer, register int bits_left,
    421          		      int nbits)
    422          /* Load up the bit buffer to a depth of at least nbits */
    423          {
   \                     jpeg_fill_bit_buffer:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    424            /* Copy heavily used state fields into locals (hopefully registers) */
    425            register const JOCTET * next_input_byte = state->next_input_byte;
    426            register size_t bytes_in_buffer = state->bytes_in_buffer;
    427            j_decompress_ptr cinfo = state->cinfo;
   \   00000008   108094E5           LDR      R8,[R4, #+16]
   \   0000000C   009094E5           LDR      R9,[R4, #+0]
    428          
    429            /* Attempt to load at least MIN_GET_BITS bits into get_buffer. */
    430            /* (It is assumed that no request will be for more than that many bits.) */
    431            /* We fail to do so only if we hit a marker or are forced to suspend. */
    432          
    433            if (cinfo->unread_marker == 0) {	/* cannot advance past a marker */
   \   00000010   A00198E5           LDR      R0,[R8, #+416]
   \   00000014   04A094E5           LDR      R10,[R4, #+4]
   \   00000018   0150A0E1           MOV      R5,R1
   \   0000001C   0260A0E1           MOV      R6,R2
   \   00000020   0370A0E1           MOV      R7,R3
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   2700001A           BNE      ??jpeg_fill_bit_buffer_0
   \   0000002C   1A0000EA           B        ??jpeg_fill_bit_buffer_1
    434              while (bits_left < MIN_GET_BITS) {
    435                register int c;
    436          
    437                /* Attempt to read a byte */
    438                if (bytes_in_buffer == 0) {
    439          	if (! (*cinfo->src->fill_input_buffer) (cinfo))
    440          	  return FALSE;
    441          	next_input_byte = cinfo->src->next_input_byte;
   \                     ??jpeg_fill_bit_buffer_2:
   \   00000030   180098E5           LDR      R0,[R8, #+24]
   \   00000034   009090E5           LDR      R9,[R0, #+0]
    442          	bytes_in_buffer = cinfo->src->bytes_in_buffer;
   \   00000038   04A090E5           LDR      R10,[R0, #+4]
    443                }
    444                bytes_in_buffer--;
    445                c = GETJOCTET(*next_input_byte++);
   \                     ??jpeg_fill_bit_buffer_3:
   \   0000003C   ........           LDRB     R0,[R9], #+1
   \   00000040   01A04AE2           SUB      R10,R10,#+1
    446          
    447                /* If it's 0xFF, check and discard stuffed zero byte */
    448                if (c == 0xFF) {
   \   00000044   FF0050E3           CMP      R0,#+255
   \   00000048   1100001A           BNE      ??jpeg_fill_bit_buffer_4
    449          	/* Loop here to discard any padding FF's on terminating marker,
    450          	 * so that we can save a valid unread_marker value.  NOTE: we will
    451          	 * accept multiple FF's followed by a 0 as meaning a single FF data
    452          	 * byte.  This data pattern is not valid according to the standard.
    453          	 */
    454          	do {
    455          	  if (bytes_in_buffer == 0) {
   \                     ??jpeg_fill_bit_buffer_5:
   \   0000004C   00005AE3           CMP      R10,#+0
   \   00000050   0800001A           BNE      ??jpeg_fill_bit_buffer_6
    456          	    if (! (*cinfo->src->fill_input_buffer) (cinfo))
   \   00000054   181098E5           LDR      R1,[R8, #+24]
   \   00000058   0800A0E1           MOV      R0,R8
   \   0000005C   0C1091E5           LDR      R1,[R1, #+12]
   \   00000060   31FF2FE1           BLX      R1
   \   00000064   000050E3           CMP      R0,#+0
   \   00000068   F087BD08           POPEQ    {R4-R10,PC}
    457          	      return FALSE;
    458          	    next_input_byte = cinfo->src->next_input_byte;
   \   0000006C   180098E5           LDR      R0,[R8, #+24]
   \   00000070   009090E5           LDR      R9,[R0, #+0]
    459          	    bytes_in_buffer = cinfo->src->bytes_in_buffer;
   \   00000074   04A090E5           LDR      R10,[R0, #+4]
    460          	  }
    461          	  bytes_in_buffer--;
    462          	  c = GETJOCTET(*next_input_byte++);
   \                     ??jpeg_fill_bit_buffer_6:
   \   00000078   ........           LDRB     R0,[R9], #+1
   \   0000007C   01A04AE2           SUB      R10,R10,#+1
    463          	} while (c == 0xFF);
   \   00000080   FF0050E3           CMP      R0,#+255
   \   00000084   F0FFFF0A           BEQ      ??jpeg_fill_bit_buffer_5
    464          
    465          	if (c == 0) {
   \   00000088   000050E3           CMP      R0,#+0
   \   0000008C   0D00001A           BNE      ??jpeg_fill_bit_buffer_7
    466          	  /* Found FF/00, which represents an FF data byte */
    467          	  c = 0xFF;
   \   00000090   FF00A0E3           MOV      R0,#+255
    468          	} else {
    469          	  /* Oops, it's actually a marker indicating end of compressed data.
    470          	   * Save the marker code for later use.
    471          	   * Fine point: it might appear that we should save the marker into
    472          	   * bitread working state, not straight into permanent state.  But
    473          	   * once we have hit a marker, we cannot need to suspend within the
    474          	   * current MCU, because we will read no more bytes from the data
    475          	   * source.  So it is OK to update permanent state right away.
    476          	   */
    477          	  cinfo->unread_marker = c;
    478          	  /* See if we need to insert some fake zero bits. */
    479          	  goto no_more_bytes;
    480          	}
    481                }
    482          
    483                /* OK, load c into get_buffer */
    484                get_buffer = (get_buffer << 8) | c;
   \                     ??jpeg_fill_bit_buffer_4:
   \   00000094   055480E1           ORR      R5,R0,R5, LSL #+8
    485                bits_left += 8;
   \   00000098   086086E2           ADD      R6,R6,#+8
   \                     ??jpeg_fill_bit_buffer_1:
   \   0000009C   190056E3           CMP      R6,#+25
   \   000000A0   1D0000AA           BGE      ??jpeg_fill_bit_buffer_8
   \   000000A4   00005AE3           CMP      R10,#+0
   \   000000A8   E3FFFF1A           BNE      ??jpeg_fill_bit_buffer_3
   \   000000AC   181098E5           LDR      R1,[R8, #+24]
   \   000000B0   0800A0E1           MOV      R0,R8
   \   000000B4   0C1091E5           LDR      R1,[R1, #+12]
   \   000000B8   31FF2FE1           BLX      R1
   \   000000BC   000050E3           CMP      R0,#+0
   \   000000C0   DAFFFF1A           BNE      ??jpeg_fill_bit_buffer_2
   \   000000C4   F087BDE8           POP      {R4-R10,PC}
   \                     ??jpeg_fill_bit_buffer_7:
   \   000000C8   A00188E5           STR      R0,[R8, #+416]
    486              } /* end while */
    487            } else {
    488            no_more_bytes:
    489              /* We get here if we've read the marker that terminates the compressed
    490               * data segment.  There should be enough bits in the buffer register
    491               * to satisfy the request; if so, no problem.
    492               */
    493              if (nbits > bits_left) {
   \                     ??jpeg_fill_bit_buffer_0:
   \   000000CC   070056E1           CMP      R6,R7
   \   000000D0   110000AA           BGE      ??jpeg_fill_bit_buffer_8
    494                /* Uh-oh.  Report corrupted data to user and stuff zeroes into
    495                 * the data stream, so that we can produce some kind of image.
    496                 * We use a nonvolatile flag to ensure that only one warning message
    497                 * appears per data segment.
    498                 */
    499                if (! cinfo->entropy->insufficient_data) {
   \   000000D4   BC0198E5           LDR      R0,[R8, #+444]
   \   000000D8   080090E5           LDR      R0,[R0, #+8]
   \   000000DC   000050E3           CMP      R0,#+0
   \   000000E0   0A00001A           BNE      ??jpeg_fill_bit_buffer_9
    500          	WARNMS(cinfo, JWRN_HIT_MARKER);
   \   000000E4   000098E5           LDR      R0,[R8, #+0]
   \   000000E8   7810A0E3           MOV      R1,#+120
   \   000000EC   141080E5           STR      R1,[R0, #+20]
   \   000000F0   002098E5           LDR      R2,[R8, #+0]
   \   000000F4   0010E0E3           MVN      R1,#+0
   \   000000F8   042092E5           LDR      R2,[R2, #+4]
   \   000000FC   0800A0E1           MOV      R0,R8
   \   00000100   32FF2FE1           BLX      R2
    501          	cinfo->entropy->insufficient_data = TRUE;
   \   00000104   BC0198E5           LDR      R0,[R8, #+444]
   \   00000108   0110A0E3           MOV      R1,#+1
   \   0000010C   081080E5           STR      R1,[R0, #+8]
    502                }
    503                /* Fill the buffer with zero bits */
    504                get_buffer <<= MIN_GET_BITS - bits_left;
   \                     ??jpeg_fill_bit_buffer_9:
   \   00000110   190066E2           RSB      R0,R6,#+25
   \   00000114   1550A0E1           LSL      R5,R5,R0
    505                bits_left = MIN_GET_BITS;
   \   00000118   1960A0E3           MOV      R6,#+25
    506              }
    507            }
    508          
    509            /* Unload the local registers */
    510            state->next_input_byte = next_input_byte;
   \                     ??jpeg_fill_bit_buffer_8:
   \   0000011C   009084E5           STR      R9,[R4, #+0]
    511            state->bytes_in_buffer = bytes_in_buffer;
   \   00000120   04A084E5           STR      R10,[R4, #+4]
    512            state->get_buffer = get_buffer;
   \   00000124   085084E5           STR      R5,[R4, #+8]
    513            state->bits_left = bits_left;
   \   00000128   0C6084E5           STR      R6,[R4, #+12]
    514          
    515            return TRUE;
   \   0000012C   0100A0E3           MOV      R0,#+1
   \   00000130   F087BDE8           POP      {R4-R10,PC}      ;; return
    516          }
    517          
    518          
    519          /*
    520           * Figure F.12: extend sign bit.
    521           * On some machines, a shift and sub will be faster than a table lookup.
    522           */
    523          
    524          #ifdef AVOID_TABLES
    525          
    526          #define BIT_MASK(nbits)   ((1<<(nbits))-1)
    527          #define HUFF_EXTEND(x,s)  ((x) < (1<<((s)-1)) ? (x) - ((1<<(s))-1) : (x))
    528          
    529          #else
    530          
    531          #define BIT_MASK(nbits)   bmask[nbits]
    532          #define HUFF_EXTEND(x,s)  ((x) <= bmask[(s) - 1] ? (x) - bmask[s] : (x))
    533          

   \                                 In segment DATA_C, align 4, align-sorted
    534          static const int bmask[16] =	/* bmask[n] is mask for n rightmost bits */
   \                     bmask:
   \   00000000   000000000100       DC32 0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191
   \              000003000000
   \              070000000F00
   \              00001F000000
   \              3F0000007F00
   \              0000FF000000
   \              FF010000FF03
   \              0000FF070000
   \              FF0F0000FF1F
   \              0000        
   \   00000038   FF3F0000FF7F       DC32 16383, 32767
   \              0000        
    535            { 0, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF,
    536              0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF };
    537          
    538          #endif /* AVOID_TABLES */
    539          
    540          
    541          /*
    542           * Out-of-line code for Huffman code decoding.
    543           */
    544          

   \                                 In segment CODE, align 4, keep-with-next
    545          LOCAL(int)
    546          jpeg_huff_decode (bitread_working_state * state,
    547          		  register bit_buf_type get_buffer, register int bits_left,
    548          		  d_derived_tbl * htbl, int min_bits)
    549          {
   \                     jpeg_huff_decode:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   14609DE5           LDR      R6,[SP, #+20]
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0350A0E1           MOV      R5,R3
    550            register int l = min_bits;
    551            register INT32 code;
    552          
    553            /* HUFF_DECODE has determined that the code is at least min_bits */
    554            /* bits long, so fetch that many bits in one swoop. */
    555          
    556            CHECK_BIT_BUFFER(*state, l, return -1);
   \   00000010   060052E1           CMP      R2,R6
   \   00000014   070000AA           BGE      ??jpeg_huff_decode_0
   \   00000018   0630A0E1           MOV      R3,R6
   \   0000001C   ........           BL       jpeg_fill_bit_buffer
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0100001A           BNE      ??jpeg_huff_decode_1
   \                     ??jpeg_huff_decode_2:
   \   00000028   0000E0E3           MVN      R0,#+0
   \   0000002C   F080BDE8           POP      {R4-R7,PC}
   \                     ??jpeg_huff_decode_1:
   \   00000030   081094E5           LDR      R1,[R4, #+8]
   \   00000034   0C2094E5           LDR      R2,[R4, #+12]
    557            code = GET_BITS(l);
   \                     ??jpeg_huff_decode_0:
   \   00000038   ........           LDR      R0,??DataTable8  ;; bmask
   \   0000003C   062042E0           SUB      R2,R2,R6
   \   00000040   060190E7           LDR      R0,[R0, +R6, LSL #+2]
   \   00000044   517200E0           AND      R7,R0,R1, ASR R2
   \   00000048   0E0000EA           B        ??jpeg_huff_decode_3
    558          
    559            /* Collect the rest of the Huffman code one bit at a time. */
    560            /* This is per Figure F.16 in the JPEG spec. */
    561          
    562            while (code > htbl->maxcode[l]) {
    563              code <<= 1;
   \                     ??jpeg_huff_decode_4:
   \   0000004C   8770A0E1           LSL      R7,R7,#+1
    564              CHECK_BIT_BUFFER(*state, 1, return -1);
   \   00000050   010052E3           CMP      R2,#+1
   \   00000054   060000AA           BGE      ??jpeg_huff_decode_5
   \   00000058   0130A0E3           MOV      R3,#+1
   \   0000005C   0400A0E1           MOV      R0,R4
   \   00000060   ........           BL       jpeg_fill_bit_buffer
   \   00000064   000050E3           CMP      R0,#+0
   \   00000068   EEFFFF0A           BEQ      ??jpeg_huff_decode_2
   \   0000006C   081094E5           LDR      R1,[R4, #+8]
   \   00000070   0C2094E5           LDR      R2,[R4, #+12]
    565              code |= GET_BITS(1);
   \                     ??jpeg_huff_decode_5:
   \   00000074   0100A0E3           MOV      R0,#+1
   \   00000078   012042E2           SUB      R2,R2,#+1
   \   0000007C   510200E0           AND      R0,R0,R1, ASR R2
   \   00000080   077080E1           ORR      R7,R0,R7
    566              l++;
   \   00000084   016086E2           ADD      R6,R6,#+1
    567            }
   \                     ??jpeg_huff_decode_3:
   \   00000088   060195E7           LDR      R0,[R5, +R6, LSL #+2]
   \   0000008C   070050E1           CMP      R0,R7
   \   00000090   EDFFFFBA           BLT      ??jpeg_huff_decode_4
    568          
    569            /* Unload the local registers */
    570            state->get_buffer = get_buffer;
   \   00000094   081084E5           STR      R1,[R4, #+8]
    571            state->bits_left = bits_left;
   \   00000098   0C2084E5           STR      R2,[R4, #+12]
    572          
    573            /* With garbage input we may reach the sentinel value l = 17. */
    574          
    575            if (l > 16) {
   \   0000009C   110056E3           CMP      R6,#+17
   \   000000A0   0B0000BA           BLT      ??jpeg_huff_decode_6
    576              WARNMS(state->cinfo, JWRN_HUFF_BAD_CODE);
   \   000000A4   100094E5           LDR      R0,[R4, #+16]
   \   000000A8   7910A0E3           MOV      R1,#+121
   \   000000AC   000090E5           LDR      R0,[R0, #+0]
   \   000000B0   141080E5           STR      R1,[R0, #+20]
   \   000000B4   102094E5           LDR      R2,[R4, #+16]
   \   000000B8   0010E0E3           MVN      R1,#+0
   \   000000BC   0200A0E1           MOV      R0,R2
   \   000000C0   002092E5           LDR      R2,[R2, #+0]
   \   000000C4   042092E5           LDR      R2,[R2, #+4]
   \   000000C8   32FF2FE1           BLX      R2
    577              return 0;			/* fake a zero as the safest result */
   \   000000CC   0000A0E3           MOV      R0,#+0
   \   000000D0   F080BDE8           POP      {R4-R7,PC}
    578            }
    579          
    580            return htbl->pub->huffval[ (int) (code + htbl->valoffset[l]) ];
   \                     ??jpeg_huff_decode_6:
   \   000000D4   8C1095E5           LDR      R1,[R5, #+140]
   \   000000D8   060185E0           ADD      R0,R5,R6, LSL #+2
   \   000000DC   480090E5           LDR      R0,[R0, #+72]
   \   000000E0   070080E0           ADD      R0,R0,R7
   \   000000E4   010080E0           ADD      R0,R0,R1
   \   000000E8   1100D0E5           LDRB     R0,[R0, #+17]
   \   000000EC   F080BDE8           POP      {R4-R7,PC}       ;; return
    581          }
    582          
    583          
    584          /*
    585           * Check for a restart marker & resynchronize decoder.
    586           * Returns FALSE if must suspend.
    587           */
    588          

   \                                 In segment CODE, align 4, keep-with-next
    589          LOCAL(boolean)
    590          process_restart (j_decompress_ptr cinfo)
    591          {
   \                     process_restart:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    592            huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
   \   00000008   BC5194E5           LDR      R5,[R4, #+444]
    593            int ci;
    594          
    595            /* Throw away any unused bits remaining in bit buffer; */
    596            /* include any full bytes in next_marker's count of discarded bytes */
    597            cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;
   \   0000000C   B81194E5           LDR      R1,[R4, #+440]
   \   00000010   100095E5           LDR      R0,[R5, #+16]
   \   00000014   182091E5           LDR      R2,[R1, #+24]
   \   00000018   4031A0E1           ASR      R3,R0,#+2
   \   0000001C   A30E80E0           ADD      R0,R0,R3, LSR #+29
   \   00000020   C00182E0           ADD      R0,R2,R0, ASR #+3
   \   00000024   180081E5           STR      R0,[R1, #+24]
    598            entropy->bitstate.bits_left = 0;
   \   00000028   0060A0E3           MOV      R6,#+0
   \   0000002C   106085E5           STR      R6,[R5, #+16]
    599          
    600            /* Advance past the RSTn marker */
    601            if (! (*cinfo->marker->read_restart_marker) (cinfo))
   \   00000030   B81194E5           LDR      R1,[R4, #+440]
   \   00000034   0400A0E1           MOV      R0,R4
   \   00000038   081091E5           LDR      R1,[R1, #+8]
   \   0000003C   31FF2FE1           BLX      R1
   \   00000040   000050E3           CMP      R0,#+0
   \   00000044   0000A0E3           MOV      R0,#+0
   \   00000048   7080BD08           POPEQ    {R4-R6,PC}
    602              return FALSE;
    603          
    604            /* Re-initialize DC predictions to 0 */
    605            for (ci = 0; ci < cinfo->comps_in_scan; ci++)
   \   0000004C   481194E5           LDR      R1,[R4, #+328]
   \   00000050   010051E3           CMP      R1,#+1
   \   00000054   030000AA           BGE      ??process_restart_0
   \   00000058   050000EA           B        ??process_restart_1
    606              entropy->saved.last_dc_val[ci] = 0;
   \                     ??process_restart_2:
   \   0000005C   001185E0           ADD      R1,R5,R0, LSL #+2
   \   00000060   186081E5           STR      R6,[R1, #+24]
   \   00000064   010080E2           ADD      R0,R0,#+1
   \                     ??process_restart_0:
   \   00000068   481194E5           LDR      R1,[R4, #+328]
   \   0000006C   010050E1           CMP      R0,R1
   \   00000070   F9FFFFBA           BLT      ??process_restart_2
    607            /* Re-init EOB run count, too */
    608            entropy->saved.EOBRUN = 0;
   \                     ??process_restart_1:
   \   00000074   146085E5           STR      R6,[R5, #+20]
    609          
    610            /* Reset restart counter */
    611            entropy->restarts_to_go = cinfo->restart_interval;
   \   00000078   100194E5           LDR      R0,[R4, #+272]
   \   0000007C   280085E5           STR      R0,[R5, #+40]
    612          
    613            /* Reset out-of-data flag, unless read_restart_marker left us smack up
    614             * against a marker.  In that case we will end up treating the next data
    615             * segment as empty, and we can avoid producing bogus output pixels by
    616             * leaving the flag set.
    617             */
    618            if (cinfo->unread_marker == 0)
   \   00000080   A00194E5           LDR      R0,[R4, #+416]
   \   00000084   000050E3           CMP      R0,#+0
    619              entropy->pub.insufficient_data = FALSE;
   \   00000088   08608505           STREQ    R6,[R5, #+8]
    620          
    621            return TRUE;
   \   0000008C   0100A0E3           MOV      R0,#+1
   \   00000090   7080BDE8           POP      {R4-R6,PC}       ;; return
    622          }
    623          
    624          
    625          /*
    626           * Huffman MCU decoding.
    627           * Each of these routines decodes and returns one MCU's worth of
    628           * Huffman-compressed coefficients. 
    629           * The coefficients are reordered from zigzag order into natural array order,
    630           * but are not dequantized.
    631           *
    632           * The i'th block of the MCU is stored into the block pointed to by
    633           * MCU_data[i].  WE ASSUME THIS AREA IS INITIALLY ZEROED BY THE CALLER.
    634           * (Wholesale zeroing is usually a little faster than retail...)
    635           *
    636           * We return FALSE if data source requested suspension.  In that case no
    637           * changes have been made to permanent state.  (Exception: some output
    638           * coefficients may already have been assigned.  This is harmless for
    639           * spectral selection, since we'll just re-assign them on the next call.
    640           * Successive approximation AC refinement has to be more careful, however.)
    641           */
    642          
    643          /*
    644           * MCU decoding for DC initial scan (either spectral selection,
    645           * or first pass of successive approximation).
    646           */
    647          

   \                                 In segment CODE, align 4, keep-with-next
    648          METHODDEF(boolean)
    649          decode_mcu_DC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
    650          {   
   \                     decode_mcu_DC_first:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   28D04DE2           SUB      SP,SP,#+40
   \   00000008   0050A0E1           MOV      R5,R0
    651            huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
    652            int Al = cinfo->Al;
    653            register int s, r;
    654            int blkn, ci;
    655            JBLOCKROW block;
    656            BITREAD_STATE_VARS;
    657            savable_state state;
    658            d_derived_tbl * tbl;
    659            jpeg_component_info * compptr;
    660          
    661            /* Process restart marker if needed; may have to suspend */
    662            if (cinfo->restart_interval) {
   \   0000000C   100195E5           LDR      R0,[R5, #+272]
   \   00000010   BC7195E5           LDR      R7,[R5, #+444]
   \   00000014   9C8195E5           LDR      R8,[R5, #+412]
   \   00000018   0160A0E1           MOV      R6,R1
   \   0000001C   000050E3           CMP      R0,#+0
   \   00000020   0900000A           BEQ      ??decode_mcu_DC_first_0
    663              if (entropy->restarts_to_go == 0)
   \   00000024   280097E5           LDR      R0,[R7, #+40]
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   0600001A           BNE      ??decode_mcu_DC_first_0
    664                if (! process_restart(cinfo))
   \   00000030   0500A0E1           MOV      R0,R5
   \   00000034   ........           BL       process_restart
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0200001A           BNE      ??decode_mcu_DC_first_0
    665          	return FALSE;
   \                     ??decode_mcu_DC_first_1:
   \   00000040   0000A0E3           MOV      R0,#+0
   \   00000044   28D08DE2           ADD      SP,SP,#+40
   \   00000048   F08FBDE8           POP      {R4-R11,PC}
    666            }
    667          
    668            /* If we've run out of data, just leave the MCU set to zeroes.
    669             * This way, we return uniform gray for the remainder of the segment.
    670             */
    671            if (! entropy->pub.insufficient_data) {
   \                     ??decode_mcu_DC_first_0:
   \   0000004C   080097E5           LDR      R0,[R7, #+8]
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   6400001A           BNE      ??decode_mcu_DC_first_2
    672          
    673              /* Load up working state */
    674              BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
   \   00000058   10508DE5           STR      R5,[SP, #+16]
   \   0000005C   181095E5           LDR      R1,[R5, #+24]
    675              ASSIGN_STATE(state, entropy->saved);
   \   00000060   14008DE2           ADD      R0,SP,#+20
   \   00000064   001091E5           LDR      R1,[R1, #+0]
   \   00000068   143087E2           ADD      R3,R7,#+20
   \   0000006C   00108DE5           STR      R1,[SP, #+0]
   \   00000070   181095E5           LDR      R1,[R5, #+24]
   \   00000074   041091E5           LDR      R1,[R1, #+4]
   \   00000078   04108DE5           STR      R1,[SP, #+4]
   \   0000007C   0C1097E5           LDR      R1,[R7, #+12]
   \   00000080   102097E5           LDR      R2,[R7, #+16]
   \   00000084   101E93E8           LDM      R3,{R4,R9-R12}
   \   00000088   101E80E8           STM      R0,{R4,R9-R12}
    676          
    677              /* Outer loop handles each block in the MCU */
    678          
    679              for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
   \   0000008C   0090A0E3           MOV      R9,#+0
   \   00000090   070000EA           B        ??decode_mcu_DC_first_3
    680                block = MCU_data[blkn];
    681                ci = cinfo->MCU_membership[blkn];
    682                compptr = cinfo->cur_comp_info[ci];
    683                tbl = entropy->derived_tbls[compptr->dc_tbl_no];
    684          
    685                /* Decode a single block's worth of coefficients */
    686          
    687                /* Section F.2.2.1: decode the DC coefficient difference */
    688                HUFF_DECODE(s, br_state, tbl, return FALSE, label1);
    689                if (s) {
    690          	CHECK_BIT_BUFFER(br_state, s, return FALSE);
    691          	r = GET_BITS(s);
    692          	s = HUFF_EXTEND(r, s);
    693                }
    694          
    695                /* Convert DC difference to actual value, update last_dc_val */
    696                s += state.last_dc_val[ci];
   \                     ??decode_mcu_DC_first_4:
   \   00000094   14008DE2           ADD      R0,SP,#+20
   \   00000098   0B0180E0           ADD      R0,R0,R11, LSL #+2
   \   0000009C   043090E5           LDR      R3,[R0, #+4]
    697                state.last_dc_val[ci] = s;
    698                /* Scale and output the coefficient (assumes jpeg_natural_order[0]=0) */
    699                (*block)[0] = (JCOEF) (s << Al);
   \   000000A0   019089E2           ADD      R9,R9,#+1
   \   000000A4   044083E0           ADD      R4,R3,R4
   \   000000A8   044080E5           STR      R4,[R0, #+4]
   \   000000AC   1408A0E1           LSL      R0,R4,R8
   \   000000B0   B000CAE1           STRH     R0,[R10, #+0]
   \                     ??decode_mcu_DC_first_3:
   \   000000B4   640195E5           LDR      R0,[R5, #+356]
   \   000000B8   000059E1           CMP      R9,R0
   \   000000BC   3E0000AA           BGE      ??decode_mcu_DC_first_5
   \   000000C0   09A196E7           LDR      R10,[R6, +R9, LSL #+2]
   \   000000C4   090185E0           ADD      R0,R5,R9, LSL #+2
   \   000000C8   68B190E5           LDR      R11,[R0, #+360]
   \   000000CC   080052E3           CMP      R2,#+8
   \   000000D0   0B0185E0           ADD      R0,R5,R11, LSL #+2
   \   000000D4   4C0190E5           LDR      R0,[R0, #+332]
   \   000000D8   140090E5           LDR      R0,[R0, #+20]
   \   000000DC   000187E0           ADD      R0,R7,R0, LSL #+2
   \   000000E0   2C4090E5           LDR      R4,[R0, #+44]
   \   000000E4   090000AA           BGE      ??decode_mcu_DC_first_6
   \   000000E8   0030A0E3           MOV      R3,#+0
   \   000000EC   0D00A0E1           MOV      R0,SP
   \   000000F0   ........           BL       jpeg_fill_bit_buffer
   \   000000F4   000050E3           CMP      R0,#+0
   \   000000F8   3F00000A           BEQ      ??decode_mcu_DC_first_7
   \   000000FC   0C209DE5           LDR      R2,[SP, #+12]
   \   00000100   08109DE5           LDR      R1,[SP, #+8]
   \   00000104   080052E3           CMP      R2,#+8
   \   00000108   0100A0B3           MOVLT    R0,#+1
   \   0000010C   0B0000BA           BLT      ??decode_mcu_DC_first_8
   \                     ??decode_mcu_DC_first_6:
   \   00000110   F80082E2           ADD      R0,R2,#+248
   \   00000114   FF30A0E3           MOV      R3,#+255
   \   00000118   513003E0           AND      R3,R3,R1, ASR R0
   \   0000011C   030184E0           ADD      R0,R4,R3, LSL #+2
   \   00000120   900090E5           LDR      R0,[R0, #+144]
   \   00000124   000050E3           CMP      R0,#+0
   \   00000128   0300000A           BEQ      ??decode_mcu_DC_first_9
   \   0000012C   002042E0           SUB      R2,R2,R0
   \   00000130   040083E0           ADD      R0,R3,R4
   \   00000134   9044D0E5           LDRB     R4,[R0, #+1168]
   \   00000138   090000EA           B        ??decode_mcu_DC_first_10
   \                     ??decode_mcu_DC_first_9:
   \   0000013C   0900A0E3           MOV      R0,#+9
   \                     ??decode_mcu_DC_first_8:
   \   00000140   01002DE9           PUSH     {R0}
   \   00000144   0430A0E1           MOV      R3,R4
   \   00000148   04008DE2           ADD      R0,SP,#+4
   \   0000014C   ........           BL       jpeg_huff_decode
   \   00000150   0040B0E1           MOVS     R4,R0
   \   00000154   04D08DE2           ADD      SP,SP,#+4
   \   00000158   B8FFFF4A           BMI      ??decode_mcu_DC_first_1
   \   0000015C   08109DE5           LDR      R1,[SP, #+8]
   \   00000160   0C209DE5           LDR      R2,[SP, #+12]
   \                     ??decode_mcu_DC_first_10:
   \   00000164   000054E3           CMP      R4,#+0
   \   00000168   C9FFFF0A           BEQ      ??decode_mcu_DC_first_4
   \   0000016C   040052E1           CMP      R2,R4
   \   00000170   060000AA           BGE      ??decode_mcu_DC_first_11
   \   00000174   0430A0E1           MOV      R3,R4
   \   00000178   0D00A0E1           MOV      R0,SP
   \   0000017C   ........           BL       jpeg_fill_bit_buffer
   \   00000180   000050E3           CMP      R0,#+0
   \   00000184   1C00000A           BEQ      ??decode_mcu_DC_first_7
   \   00000188   08109DE5           LDR      R1,[SP, #+8]
   \   0000018C   0C209DE5           LDR      R2,[SP, #+12]
   \                     ??decode_mcu_DC_first_11:
   \   00000190   ........           LDR      R0,??DataTable8  ;; bmask
   \   00000194   043190E7           LDR      R3,[R0, +R4, LSL #+2]
   \   00000198   04C180E0           ADD      R12,R0,R4, LSL #+2
   \   0000019C   04C01CE5           LDR      R12,[R12, #-4]
   \   000001A0   042042E0           SUB      R2,R2,R4
   \   000001A4   513203E0           AND      R3,R3,R1, ASR R2
   \   000001A8   03005CE1           CMP      R12,R3
   \   000001AC   040190A7           LDRGE    R0,[R0, +R4, LSL #+2]
   \   000001B0   0340A0B1           MOVLT    R4,R3
   \   000001B4   004043A0           SUBGE    R4,R3,R0
   \   000001B8   B5FFFFEA           B        ??decode_mcu_DC_first_4
    700              }
    701          
    702              /* Completed MCU, so update state */
    703              BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
   \                     ??decode_mcu_DC_first_5:
   \   000001BC   180095E5           LDR      R0,[R5, #+24]
   \   000001C0   00309DE5           LDR      R3,[SP, #+0]
   \   000001C4   003080E5           STR      R3,[R0, #+0]
   \   000001C8   180095E5           LDR      R0,[R5, #+24]
   \   000001CC   04309DE5           LDR      R3,[SP, #+4]
   \   000001D0   043080E5           STR      R3,[R0, #+4]
   \   000001D4   0C1087E5           STR      R1,[R7, #+12]
   \   000001D8   102087E5           STR      R2,[R7, #+16]
    704              ASSIGN_STATE(entropy->saved, state);
   \   000001DC   140087E2           ADD      R0,R7,#+20
   \   000001E0   14108DE2           ADD      R1,SP,#+20
   \   000001E4   7C0091E8           LDM      R1,{R2-R6}
   \   000001E8   7C0080E8           STM      R0,{R2-R6}
    705            }
    706          
    707            /* Account for restart interval (no-op if not using restarts) */
    708            entropy->restarts_to_go--;
   \                     ??decode_mcu_DC_first_2:
   \   000001EC   280097E5           LDR      R0,[R7, #+40]
   \   000001F0   010040E2           SUB      R0,R0,#+1
   \   000001F4   280087E5           STR      R0,[R7, #+40]
    709          
    710            return TRUE;
   \   000001F8   0100A0E3           MOV      R0,#+1
   \                     ??decode_mcu_DC_first_7:
   \   000001FC   28D08DE2           ADD      SP,SP,#+40       ;; stack cleaning
   \   00000200   F08FBDE8           POP      {R4-R11,PC}      ;; return
    711          }
    712          
    713          
    714          /*
    715           * MCU decoding for AC initial scan (either spectral selection,
    716           * or first pass of successive approximation).
    717           */
    718          

   \                                 In segment CODE, align 4, keep-with-next
    719          METHODDEF(boolean)
    720          decode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
    721          {   
   \                     decode_mcu_AC_first:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   20D04DE2           SUB      SP,SP,#+32
   \   00000008   0070A0E1           MOV      R7,R0
    722            huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
   \   0000000C   BC5197E5           LDR      R5,[R7, #+444]
   \   00000010   0140A0E1           MOV      R4,R1
    723            int Se = cinfo->Se;
   \   00000014   941197E5           LDR      R1,[R7, #+404]
   \   00000018   14108DE5           STR      R1,[SP, #+20]
    724            int Al = cinfo->Al;
   \   0000001C   9C1197E5           LDR      R1,[R7, #+412]
   \   00000020   18108DE5           STR      R1,[SP, #+24]
    725            register int s, k, r;
    726            unsigned int EOBRUN;
    727            JBLOCKROW block;
    728            BITREAD_STATE_VARS;
    729            d_derived_tbl * tbl;
    730          
    731            /* Process restart marker if needed; may have to suspend */
    732            if (cinfo->restart_interval) {
   \   00000024   100197E5           LDR      R0,[R7, #+272]
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   0900000A           BEQ      ??decode_mcu_AC_first_0
    733              if (entropy->restarts_to_go == 0)
   \   00000030   280095E5           LDR      R0,[R5, #+40]
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   0600001A           BNE      ??decode_mcu_AC_first_0
    734                if (! process_restart(cinfo))
   \   0000003C   0700A0E1           MOV      R0,R7
   \   00000040   ........           BL       process_restart
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0200001A           BNE      ??decode_mcu_AC_first_0
    735          	return FALSE;
   \                     ??decode_mcu_AC_first_1:
   \   0000004C   0000A0E3           MOV      R0,#+0
   \   00000050   20D08DE2           ADD      SP,SP,#+32
   \   00000054   F08FBDE8           POP      {R4-R11,PC}
    736            }
    737          
    738            /* If we've run out of data, just leave the MCU set to zeroes.
    739             * This way, we return uniform gray for the remainder of the segment.
    740             */
    741            if (! entropy->pub.insufficient_data) {
   \                     ??decode_mcu_AC_first_0:
   \   00000058   080095E5           LDR      R0,[R5, #+8]
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   7300001A           BNE      ??decode_mcu_AC_first_2
    742          
    743              /* Load up working state.
    744               * We can avoid loading/saving bitread state if in an EOB run.
    745               */
    746              EOBRUN = entropy->saved.EOBRUN;	/* only part of saved state we need */
   \   00000064   146095E5           LDR      R6,[R5, #+20]
    747          
    748              /* There is always only one block per MCU */
    749          
    750              if (EOBRUN > 0)		/* if it's a band of zeroes... */
   \   00000068   000056E3           CMP      R6,#+0
    751                EOBRUN--;			/* ...process it now (we do nothing) */
   \   0000006C   01604612           SUBNE    R6,R6,#+1
   \   00000070   6E00001A           BNE      ??decode_mcu_AC_first_3
    752              else {
    753                BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
    754                block = MCU_data[0];
    755                tbl = entropy->ac_derived_tbl;
    756          
    757                for (k = cinfo->Ss; k <= Se; k++) {
   \   00000074   ........           LDR      R11,??DataTable8  ;; bmask
   \   00000078   10708DE5           STR      R7,[SP, #+16]
   \   0000007C   181097E5           LDR      R1,[R7, #+24]
   \   00000080   001091E5           LDR      R1,[R1, #+0]
   \   00000084   00108DE5           STR      R1,[SP, #+0]
   \   00000088   181097E5           LDR      R1,[R7, #+24]
   \   0000008C   041091E5           LDR      R1,[R1, #+4]
   \   00000090   04108DE5           STR      R1,[SP, #+4]
   \   00000094   003094E5           LDR      R3,[R4, #+0]
   \   00000098   0C1095E5           LDR      R1,[R5, #+12]
   \   0000009C   102095E5           LDR      R2,[R5, #+16]
   \   000000A0   1C308DE5           STR      R3,[SP, #+28]
   \   000000A4   3C8095E5           LDR      R8,[R5, #+60]
   \   000000A8   909197E5           LDR      R9,[R7, #+400]
   \   000000AC   320000EA           B        ??decode_mcu_AC_first_4
    758          	HUFF_DECODE(s, br_state, tbl, return FALSE, label2);
   \                     ??decode_mcu_AC_first_5:
   \   000000B0   F80082E2           ADD      R0,R2,#+248
   \   000000B4   FF30A0E3           MOV      R3,#+255
   \   000000B8   510003E0           AND      R0,R3,R1, ASR R0
   \   000000BC   003188E0           ADD      R3,R8,R0, LSL #+2
   \   000000C0   903093E5           LDR      R3,[R3, #+144]
   \   000000C4   000053E3           CMP      R3,#+0
   \   000000C8   0300000A           BEQ      ??decode_mcu_AC_first_6
   \   000000CC   032042E0           SUB      R2,R2,R3
   \   000000D0   080080E0           ADD      R0,R0,R8
   \   000000D4   9044D0E5           LDRB     R4,[R0, #+1168]
   \   000000D8   090000EA           B        ??decode_mcu_AC_first_7
   \                     ??decode_mcu_AC_first_6:
   \   000000DC   0930A0E3           MOV      R3,#+9
   \                     ??decode_mcu_AC_first_8:
   \   000000E0   08002DE9           PUSH     {R3}
   \   000000E4   04008DE2           ADD      R0,SP,#+4
   \   000000E8   0830A0E1           MOV      R3,R8
   \   000000EC   ........           BL       jpeg_huff_decode
   \   000000F0   0040B0E1           MOVS     R4,R0
   \   000000F4   04D08DE2           ADD      SP,SP,#+4
   \   000000F8   D3FFFF4A           BMI      ??decode_mcu_AC_first_1
   \   000000FC   08109DE5           LDR      R1,[SP, #+8]
   \   00000100   0C209DE5           LDR      R2,[SP, #+12]
    759          	r = s >> 4;
   \                     ??decode_mcu_AC_first_7:
   \   00000104   44A2A0E1           ASR      R10,R4,#+4
    760          	s &= 15;
   \   00000108   0F4014E2           ANDS     R4,R4,#0xF
    761          	if (s) {
   \   0000010C   2A00000A           BEQ      ??decode_mcu_AC_first_9
    762          	  k += r;
   \   00000110   09908AE0           ADD      R9,R10,R9
    763          	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
   \   00000114   040052E1           CMP      R2,R4
   \   00000118   060000AA           BGE      ??decode_mcu_AC_first_10
   \   0000011C   0430A0E1           MOV      R3,R4
   \   00000120   0D00A0E1           MOV      R0,SP
   \   00000124   ........           BL       jpeg_fill_bit_buffer
   \   00000128   000050E3           CMP      R0,#+0
   \   0000012C   4400000A           BEQ      ??decode_mcu_AC_first_11
   \   00000130   08109DE5           LDR      R1,[SP, #+8]
   \   00000134   0C209DE5           LDR      R2,[SP, #+12]
    764          	  r = GET_BITS(s);
   \                     ??decode_mcu_AC_first_10:
   \   00000138   04019BE7           LDR      R0,[R11, +R4, LSL #+2]
    765          	  s = HUFF_EXTEND(r, s);
    766          	  /* Scale and output coefficient in natural (dezigzagged) order */
    767          	  (*block)[jpeg_natural_order[k]] = (JCOEF) (s << Al);
   \   0000013C   1C309DE5           LDR      R3,[SP, #+28]
   \   00000140   042042E0           SUB      R2,R2,R4
   \   00000144   51A200E0           AND      R10,R0,R1, ASR R2
   \   00000148   04018BE0           ADD      R0,R11,R4, LSL #+2
   \   0000014C   040010E5           LDR      R0,[R0, #-4]
   \   00000150   0A0050E1           CMP      R0,R10
   \   00000154   04019BA7           LDRGE    R0,[R11, +R4, LSL #+2]
   \   00000158   0A40A0B1           MOVLT    R4,R10
   \   0000015C   00404AA0           SUBGE    R4,R10,R0
   \   00000160   ........           LDR      R0,??DataTable9  ;; jpeg_natural_order
   \   00000164   090190E7           LDR      R0,[R0, +R9, LSL #+2]
   \   00000168   800083E0           ADD      R0,R3,R0, LSL #+1
   \   0000016C   18309DE5           LDR      R3,[SP, #+24]
   \   00000170   1433A0E1           LSL      R3,R4,R3
   \   00000174   B030C0E1           STRH     R3,[R0, #+0]
    768          	} else {
   \                     ??decode_mcu_AC_first_12:
   \   00000178   019089E2           ADD      R9,R9,#+1
   \                     ??decode_mcu_AC_first_4:
   \   0000017C   14009DE5           LDR      R0,[SP, #+20]
   \   00000180   090050E1           CMP      R0,R9
   \   00000184   210000BA           BLT      ??decode_mcu_AC_first_13
   \   00000188   080052E3           CMP      R2,#+8
   \   0000018C   C7FFFFAA           BGE      ??decode_mcu_AC_first_5
   \   00000190   0030A0E3           MOV      R3,#+0
   \   00000194   0D00A0E1           MOV      R0,SP
   \   00000198   ........           BL       jpeg_fill_bit_buffer
   \   0000019C   000050E3           CMP      R0,#+0
   \   000001A0   2700000A           BEQ      ??decode_mcu_AC_first_11
   \   000001A4   0C209DE5           LDR      R2,[SP, #+12]
   \   000001A8   08109DE5           LDR      R1,[SP, #+8]
   \   000001AC   080052E3           CMP      R2,#+8
   \   000001B0   BEFFFFAA           BGE      ??decode_mcu_AC_first_5
   \   000001B4   0130A0E3           MOV      R3,#+1
   \   000001B8   C8FFFFEA           B        ??decode_mcu_AC_first_8
    769          	  if (r == 15) {	/* ZRL */
   \                     ??decode_mcu_AC_first_9:
   \   000001BC   0F005AE3           CMP      R10,#+15
    770          	    k += 15;		/* skip 15 zeroes in band */
   \   000001C0   0F908902           ADDEQ    R9,R9,#+15
   \   000001C4   EBFFFF0A           BEQ      ??decode_mcu_AC_first_12
    771          	  } else {		/* EOBr, run length is 2^r + appended bits */
    772          	    EOBRUN = 1 << r;
   \   000001C8   0100A0E3           MOV      R0,#+1
   \   000001CC   106AA0E1           LSL      R6,R0,R10
    773          	    if (r) {		/* EOBr, r > 0 */
   \   000001D0   00005AE3           CMP      R10,#+0
   \   000001D4   0C00000A           BEQ      ??decode_mcu_AC_first_14
    774          	      CHECK_BIT_BUFFER(br_state, r, return FALSE);
   \   000001D8   0A0052E1           CMP      R2,R10
   \   000001DC   060000AA           BGE      ??decode_mcu_AC_first_15
   \   000001E0   0A30A0E1           MOV      R3,R10
   \   000001E4   0D00A0E1           MOV      R0,SP
   \   000001E8   ........           BL       jpeg_fill_bit_buffer
   \   000001EC   000050E3           CMP      R0,#+0
   \   000001F0   1300000A           BEQ      ??decode_mcu_AC_first_11
   \   000001F4   08109DE5           LDR      R1,[SP, #+8]
   \   000001F8   0C209DE5           LDR      R2,[SP, #+12]
    775          	      r = GET_BITS(r);
    776          	      EOBRUN += r;
   \                     ??decode_mcu_AC_first_15:
   \   000001FC   0A019BE7           LDR      R0,[R11, +R10, LSL #+2]
   \   00000200   0A2042E0           SUB      R2,R2,R10
   \   00000204   510200E0           AND      R0,R0,R1, ASR R2
   \   00000208   066080E0           ADD      R6,R0,R6
    777          	    }
    778          	    EOBRUN--;		/* this band is processed at this moment */
   \                     ??decode_mcu_AC_first_14:
   \   0000020C   016046E2           SUB      R6,R6,#+1
    779          	    break;		/* force end-of-band */
    780          	  }
    781          	}
    782                }
    783          
    784                BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
   \                     ??decode_mcu_AC_first_13:
   \   00000210   180097E5           LDR      R0,[R7, #+24]
   \   00000214   00309DE5           LDR      R3,[SP, #+0]
   \   00000218   003080E5           STR      R3,[R0, #+0]
   \   0000021C   180097E5           LDR      R0,[R7, #+24]
   \   00000220   04309DE5           LDR      R3,[SP, #+4]
   \   00000224   043080E5           STR      R3,[R0, #+4]
   \   00000228   0C1085E5           STR      R1,[R5, #+12]
   \   0000022C   102085E5           STR      R2,[R5, #+16]
    785              }
    786          
    787              /* Completed MCU, so update state */
    788              entropy->saved.EOBRUN = EOBRUN;	/* only part of saved state we need */
   \                     ??decode_mcu_AC_first_3:
   \   00000230   146085E5           STR      R6,[R5, #+20]
    789            }
    790          
    791            /* Account for restart interval (no-op if not using restarts) */
    792            entropy->restarts_to_go--;
   \                     ??decode_mcu_AC_first_2:
   \   00000234   280095E5           LDR      R0,[R5, #+40]
   \   00000238   010040E2           SUB      R0,R0,#+1
   \   0000023C   280085E5           STR      R0,[R5, #+40]
    793          
    794            return TRUE;
   \   00000240   0100A0E3           MOV      R0,#+1
   \                     ??decode_mcu_AC_first_11:
   \   00000244   20D08DE2           ADD      SP,SP,#+32       ;; stack cleaning
   \   00000248   F08FBDE8           POP      {R4-R11,PC}      ;; return
    795          }
    796          
    797          
    798          /*
    799           * MCU decoding for DC successive approximation refinement scan.
    800           * Note: we assume such scans can be multi-component, although the spec
    801           * is not very clear on the point.
    802           */
    803          

   \                                 In segment CODE, align 4, keep-with-next
    804          METHODDEF(boolean)
    805          decode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
    806          {   
   \                     decode_mcu_DC_refine:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   14D04DE2           SUB      SP,SP,#+20
   \   00000008   0040A0E1           MOV      R4,R0
    807            huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
   \   0000000C   BC6194E5           LDR      R6,[R4, #+444]
   \   00000010   0150A0E1           MOV      R5,R1
    808            int p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
   \   00000014   9C1194E5           LDR      R1,[R4, #+412]
   \   00000018   0100A0E3           MOV      R0,#+1
   \   0000001C   1071A0E1           LSL      R7,R0,R1
    809            int blkn;
    810            JBLOCKROW block;
    811            BITREAD_STATE_VARS;
    812          
    813            /* Process restart marker if needed; may have to suspend */
    814            if (cinfo->restart_interval) {
   \   00000020   100194E5           LDR      R0,[R4, #+272]
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   0600000A           BEQ      ??decode_mcu_DC_refine_0
    815              if (entropy->restarts_to_go == 0)
   \   0000002C   280096E5           LDR      R0,[R6, #+40]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0300001A           BNE      ??decode_mcu_DC_refine_0
    816                if (! process_restart(cinfo))
   \   00000038   0400A0E1           MOV      R0,R4
   \   0000003C   ........           BL       process_restart
   \   00000040   000050E3           CMP      R0,#+0
   \   00000044   2A00000A           BEQ      ??decode_mcu_DC_refine_1
    817          	return FALSE;
    818            }
    819          
    820            /* Not worth the cycles to check insufficient_data here,
    821             * since we will not change the data anyway if we read zeroes.
    822             */
    823          
    824            /* Load up working state */
    825            BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
   \                     ??decode_mcu_DC_refine_0:
   \   00000048   10408DE5           STR      R4,[SP, #+16]
   \   0000004C   181094E5           LDR      R1,[R4, #+24]
    826          
    827            /* Outer loop handles each block in the MCU */
    828          
    829            for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
   \   00000050   0080A0E3           MOV      R8,#+0
   \   00000054   001091E5           LDR      R1,[R1, #+0]
   \   00000058   00108DE5           STR      R1,[SP, #+0]
   \   0000005C   181094E5           LDR      R1,[R4, #+24]
   \   00000060   041091E5           LDR      R1,[R1, #+4]
   \   00000064   04108DE5           STR      R1,[SP, #+4]
   \   00000068   0C1096E5           LDR      R1,[R6, #+12]
   \   0000006C   102096E5           LDR      R2,[R6, #+16]
   \   00000070   100000EA           B        ??decode_mcu_DC_refine_2
    830              block = MCU_data[blkn];
   \                     ??decode_mcu_DC_refine_3:
   \   00000074   089195E7           LDR      R9,[R5, +R8, LSL #+2]
    831          
    832              /* Encoded data is simply the next bit of the two's-complement DC value */
    833              CHECK_BIT_BUFFER(br_state, 1, return FALSE);
   \   00000078   010052E3           CMP      R2,#+1
   \   0000007C   060000AA           BGE      ??decode_mcu_DC_refine_4
   \   00000080   0130A0E3           MOV      R3,#+1
   \   00000084   0D00A0E1           MOV      R0,SP
   \   00000088   ........           BL       jpeg_fill_bit_buffer
   \   0000008C   000050E3           CMP      R0,#+0
   \   00000090   1700000A           BEQ      ??decode_mcu_DC_refine_1
   \   00000094   08109DE5           LDR      R1,[SP, #+8]
   \   00000098   0C209DE5           LDR      R2,[SP, #+12]
    834              if (GET_BITS(1))
    835                (*block)[0] |= p1;
    836              /* Note: since we use |=, repeating the assignment later is safe */
    837            }
   \                     ??decode_mcu_DC_refine_4:
   \   0000009C   018088E2           ADD      R8,R8,#+1
   \   000000A0   012042E2           SUB      R2,R2,#+1
   \   000000A4   5102A0E1           ASR      R0,R1,R2
   \   000000A8   010010E3           TST      R0,#0x1
   \   000000AC   F000D911           LDRSHNE  R0,[R9, #+0]
   \   000000B0   00008711           ORRNE    R0,R7,R0
   \   000000B4   B000C911           STRHNE   R0,[R9, #+0]
   \                     ??decode_mcu_DC_refine_2:
   \   000000B8   640194E5           LDR      R0,[R4, #+356]
   \   000000BC   000058E1           CMP      R8,R0
   \   000000C0   EBFFFFBA           BLT      ??decode_mcu_DC_refine_3
    838          
    839            /* Completed MCU, so update state */
    840            BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
   \   000000C4   180094E5           LDR      R0,[R4, #+24]
   \   000000C8   00309DE5           LDR      R3,[SP, #+0]
   \   000000CC   003080E5           STR      R3,[R0, #+0]
   \   000000D0   180094E5           LDR      R0,[R4, #+24]
   \   000000D4   04309DE5           LDR      R3,[SP, #+4]
   \   000000D8   043080E5           STR      R3,[R0, #+4]
   \   000000DC   0C1086E5           STR      R1,[R6, #+12]
   \   000000E0   102086E5           STR      R2,[R6, #+16]
    841          
    842            /* Account for restart interval (no-op if not using restarts) */
    843            entropy->restarts_to_go--;
   \   000000E4   280096E5           LDR      R0,[R6, #+40]
   \   000000E8   010040E2           SUB      R0,R0,#+1
   \   000000EC   280086E5           STR      R0,[R6, #+40]
    844          
    845            return TRUE;
   \   000000F0   0100A0E3           MOV      R0,#+1
   \                     ??decode_mcu_DC_refine_1:
   \   000000F4   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   000000F8   F083BDE8           POP      {R4-R9,PC}       ;; return
    846          }
    847          
    848          
    849          /*
    850           * MCU decoding for AC successive approximation refinement scan.
    851           */
    852          

   \                                 In segment CODE, align 4, keep-with-next
    853          METHODDEF(boolean)
    854          decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
    855          {   
   \                     decode_mcu_AC_refine:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   4CDF4DE2           SUB      SP,SP,#+304
   \   00000008   0050A0E1           MOV      R5,R0
   \   0000000C   0140A0E1           MOV      R4,R1
    856            huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
   \   00000010   BC1195E5           LDR      R1,[R5, #+444]
    857            int Se = cinfo->Se;
    858            int p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
   \   00000014   0120A0E3           MOV      R2,#+1
   \   00000018   00108DE5           STR      R1,[SP, #+0]
   \   0000001C   941195E5           LDR      R1,[R5, #+404]
   \   00000020   28108DE5           STR      R1,[SP, #+40]
   \   00000024   9C0195E5           LDR      R0,[R5, #+412]
   \   00000028   1220A0E1           LSL      R2,R2,R0
   \   0000002C   08208DE5           STR      R2,[SP, #+8]
    859            int m1 = (-1) << cinfo->Al;	/* -1 in the bit position being coded */
   \   00000030   0020E0E3           MVN      R2,#+0
   \   00000034   1200A0E1           LSL      R0,R2,R0
   \   00000038   2C008DE5           STR      R0,[SP, #+44]
    860            register int s, k, r;
    861            unsigned int EOBRUN;
    862            JBLOCKROW block;
    863            JCOEFPTR thiscoef;
    864            BITREAD_STATE_VARS;
    865            d_derived_tbl * tbl;
    866            int num_newnz;
    867            int newnz_pos[DCTSIZE2];
    868          
    869            /* Process restart marker if needed; may have to suspend */
    870            if (cinfo->restart_interval) {
   \   0000003C   100195E5           LDR      R0,[R5, #+272]
   \   00000040   000050E3           CMP      R0,#+0
   \   00000044   0A00000A           BEQ      ??decode_mcu_AC_refine_0
    871              if (entropy->restarts_to_go == 0)
   \   00000048   00009DE5           LDR      R0,[SP, #+0]
   \   0000004C   280090E5           LDR      R0,[R0, #+40]
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   0600001A           BNE      ??decode_mcu_AC_refine_0
    872                if (! process_restart(cinfo))
   \   00000058   0500A0E1           MOV      R0,R5
   \   0000005C   ........           BL       process_restart
   \   00000060   000050E3           CMP      R0,#+0
   \   00000064   0200001A           BNE      ??decode_mcu_AC_refine_0
    873          	return FALSE;
   \                     ??decode_mcu_AC_refine_1:
   \   00000068   0000A0E3           MOV      R0,#+0
   \   0000006C   4CDF8DE2           ADD      SP,SP,#+304
   \   00000070   F08FBDE8           POP      {R4-R11,PC}      ;; return
    874            }
    875          
    876            /* If we've run out of data, don't modify the MCU.
    877             */
    878            if (! entropy->pub.insufficient_data) {
   \                     ??decode_mcu_AC_refine_0:
   \   00000074   00009DE5           LDR      R0,[SP, #+0]
   \   00000078   080090E5           LDR      R0,[R0, #+8]
   \   0000007C   000050E3           CMP      R0,#+0
   \   00000080   DE00001A           BNE      ??decode_mcu_AC_refine_2
    879          
    880              /* Load up working state */
    881              BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
   \   00000084   20508DE5           STR      R5,[SP, #+32]
   \   00000088   181095E5           LDR      R1,[R5, #+24]
    882              EOBRUN = entropy->saved.EOBRUN; /* only part of saved state we need */
    883          
    884              /* There is always only one block per MCU */
    885              block = MCU_data[0];
    886              tbl = entropy->ac_derived_tbl;
    887          
    888              /* If we are forced to suspend, we must undo the assignments to any newly
    889               * nonzero coefficients in the block, because otherwise we'd get confused
    890               * next time about which coefficients were already nonzero.
    891               * But we need not undo addition of bits to already-nonzero coefficients;
    892               * instead, we can test the current bit to see if we already did it.
    893               */
    894              num_newnz = 0;
   \   0000008C   0080A0E3           MOV      R8,#+0
   \   00000090   001091E5           LDR      R1,[R1, #+0]
   \   00000094   10108DE5           STR      R1,[SP, #+16]
   \   00000098   181095E5           LDR      R1,[R5, #+24]
   \   0000009C   041091E5           LDR      R1,[R1, #+4]
   \   000000A0   14108DE5           STR      R1,[SP, #+20]
   \   000000A4   00009DE5           LDR      R0,[SP, #+0]
   \   000000A8   0C6090E5           LDR      R6,[R0, #+12]
   \   000000AC   141090E5           LDR      R1,[R0, #+20]
   \   000000B0   107090E5           LDR      R7,[R0, #+16]
   \   000000B4   04108DE5           STR      R1,[SP, #+4]
   \   000000B8   001094E5           LDR      R1,[R4, #+0]
   \   000000BC   0C108DE5           STR      R1,[SP, #+12]
   \   000000C0   3C1090E5           LDR      R1,[R0, #+60]
   \   000000C4   24108DE5           STR      R1,[SP, #+36]
    895          
    896              /* initialize coefficient loop counter to start of band */
    897              k = cinfo->Ss;
   \   000000C8   04009DE5           LDR      R0,[SP, #+4]
   \   000000CC   909195E5           LDR      R9,[R5, #+400]
   \   000000D0   000050E3           CMP      R0,#+0
   \   000000D4   1400000A           BEQ      ??decode_mcu_AC_refine_3
    898          
    899              if (EOBRUN == 0) {
    900                for (; k <= Se; k++) {
    901          	HUFF_DECODE(s, br_state, tbl, goto undoit, label3);
    902          	r = s >> 4;
    903          	s &= 15;
    904          	if (s) {
    905          	  if (s != 1)		/* size of new coef should always be 1 */
    906          	    WARNMS(cinfo, JWRN_HUFF_BAD_CODE);
    907          	  CHECK_BIT_BUFFER(br_state, 1, goto undoit);
    908          	  if (GET_BITS(1))
    909          	    s = p1;		/* newly nonzero coef is positive */
    910          	  else
    911          	    s = m1;		/* newly nonzero coef is negative */
    912          	} else {
    913          	  if (r != 15) {
    914          	    EOBRUN = 1 << r;	/* EOBr, run length is 2^r + appended bits */
    915          	    if (r) {
    916          	      CHECK_BIT_BUFFER(br_state, r, goto undoit);
    917          	      r = GET_BITS(r);
    918          	      EOBRUN += r;
    919          	    }
    920          	    break;		/* rest of block is handled by EOB logic */
    921          	  }
    922          	  /* note s = 0 for processing ZRL */
    923          	}
    924          	/* Advance over already-nonzero coefs and r still-zero coefs,
    925          	 * appending correction bits to the nonzeroes.  A correction bit is 1
    926          	 * if the absolute value of the coefficient must be increased.
    927          	 */
    928          	do {
    929          	  thiscoef = *block + jpeg_natural_order[k];
    930          	  if (*thiscoef != 0) {
    931          	    CHECK_BIT_BUFFER(br_state, 1, goto undoit);
    932          	    if (GET_BITS(1)) {
    933          	      if ((*thiscoef & p1) == 0) { /* do nothing if already set it */
    934          		if (*thiscoef >= 0)
    935          		  *thiscoef += p1;
    936          		else
    937          		  *thiscoef += m1;
    938          	      }
    939          	    }
    940          	  } else {
    941          	    if (--r < 0)
    942          	      break;		/* reached target zero coefficient */
    943          	  }
    944          	  k++;
    945          	} while (k <= Se);
    946          	if (s) {
    947          	  int pos = jpeg_natural_order[k];
    948          	  /* Output newly nonzero coefficient */
    949          	  (*block)[pos] = (JCOEF) s;
    950          	  /* Remember its position in case we have to suspend */
    951          	  newnz_pos[num_newnz++] = pos;
    952          	}
    953                }
    954              }
    955          
    956              if (EOBRUN > 0) {
   \                     ??decode_mcu_AC_refine_4:
   \   000000D8   04009DE5           LDR      R0,[SP, #+4]
   \   000000DC   000050E3           CMP      R0,#+0
   \   000000E0   9400001A           BNE      ??decode_mcu_AC_refine_5
   \   000000E4   B80000EA           B        ??decode_mcu_AC_refine_6
   \                     ??decode_mcu_AC_refine_7:
   \   000000E8   01A05AE2           SUBS     R10,R10,#+1
   \   000000EC   0300004A           BMI      ??decode_mcu_AC_refine_8
   \                     ??decode_mcu_AC_refine_9:
   \   000000F0   28009DE5           LDR      R0,[SP, #+40]
   \   000000F4   019089E2           ADD      R9,R9,#+1
   \   000000F8   090050E1           CMP      R0,R9
   \   000000FC   510000AA           BGE      ??decode_mcu_AC_refine_10
   \                     ??decode_mcu_AC_refine_8:
   \   00000100   000054E3           CMP      R4,#+0
   \   00000104   0700000A           BEQ      ??decode_mcu_AC_refine_11
   \   00000108   ........           LDR      R0,??DataTable9  ;; jpeg_natural_order
   \   0000010C   0C109DE5           LDR      R1,[SP, #+12]
   \   00000110   090190E7           LDR      R0,[R0, +R9, LSL #+2]
   \   00000114   801081E0           ADD      R1,R1,R0, LSL #+1
   \   00000118   B040C1E1           STRH     R4,[R1, #+0]
   \   0000011C   30108DE2           ADD      R1,SP,#+48
   \   00000120   080181E7           STR      R0,[R1, +R8, LSL #+2]
   \   00000124   018088E2           ADD      R8,R8,#+1
   \                     ??decode_mcu_AC_refine_11:
   \   00000128   019089E2           ADD      R9,R9,#+1
   \                     ??decode_mcu_AC_refine_3:
   \   0000012C   28009DE5           LDR      R0,[SP, #+40]
   \   00000130   090050E1           CMP      R0,R9
   \   00000134   A40000BA           BLT      ??decode_mcu_AC_refine_6
   \   00000138   080057E3           CMP      R7,#+8
   \   0000013C   0B0000AA           BGE      ??decode_mcu_AC_refine_12
   \   00000140   0030A0E3           MOV      R3,#+0
   \   00000144   0720A0E1           MOV      R2,R7
   \   00000148   0610A0E1           MOV      R1,R6
   \   0000014C   10008DE2           ADD      R0,SP,#+16
   \   00000150   ........           BL       jpeg_fill_bit_buffer
   \   00000154   000050E3           CMP      R0,#+0
   \   00000158   AF00000A           BEQ      ??decode_mcu_AC_refine_13
   \   0000015C   1C709DE5           LDR      R7,[SP, #+28]
   \   00000160   18609DE5           LDR      R6,[SP, #+24]
   \   00000164   080057E3           CMP      R7,#+8
   \   00000168   0100A0B3           MOVLT    R0,#+1
   \   0000016C   0D0000BA           BLT      ??decode_mcu_AC_refine_14
   \                     ??decode_mcu_AC_refine_12:
   \   00000170   F80087E2           ADD      R0,R7,#+248
   \   00000174   FF10A0E3           MOV      R1,#+255
   \   00000178   561001E0           AND      R1,R1,R6, ASR R0
   \   0000017C   24009DE5           LDR      R0,[SP, #+36]
   \   00000180   010180E0           ADD      R0,R0,R1, LSL #+2
   \   00000184   900090E5           LDR      R0,[R0, #+144]
   \   00000188   000050E3           CMP      R0,#+0
   \   0000018C   0400000A           BEQ      ??decode_mcu_AC_refine_15
   \   00000190   007047E0           SUB      R7,R7,R0
   \   00000194   24009DE5           LDR      R0,[SP, #+36]
   \   00000198   000081E0           ADD      R0,R1,R0
   \   0000019C   9044D0E5           LDRB     R4,[R0, #+1168]
   \   000001A0   0B0000EA           B        ??decode_mcu_AC_refine_16
   \                     ??decode_mcu_AC_refine_15:
   \   000001A4   0900A0E3           MOV      R0,#+9
   \                     ??decode_mcu_AC_refine_14:
   \   000001A8   01002DE9           PUSH     {R0}
   \   000001AC   28309DE5           LDR      R3,[SP, #+40]
   \   000001B0   0720A0E1           MOV      R2,R7
   \   000001B4   0610A0E1           MOV      R1,R6
   \   000001B8   14008DE2           ADD      R0,SP,#+20
   \   000001BC   ........           BL       jpeg_huff_decode
   \   000001C0   0040B0E1           MOVS     R4,R0
   \   000001C4   04D08DE2           ADD      SP,SP,#+4
   \   000001C8   9300004A           BMI      ??decode_mcu_AC_refine_13
   \   000001CC   18609DE5           LDR      R6,[SP, #+24]
   \   000001D0   1C709DE5           LDR      R7,[SP, #+28]
   \                     ??decode_mcu_AC_refine_16:
   \   000001D4   44A2A0E1           ASR      R10,R4,#+4
   \   000001D8   0F4014E2           ANDS     R4,R4,#0xF
   \   000001DC   3900000A           BEQ      ??decode_mcu_AC_refine_17
   \   000001E0   010054E3           CMP      R4,#+1
   \   000001E4   0700000A           BEQ      ??decode_mcu_AC_refine_18
   \   000001E8   000095E5           LDR      R0,[R5, #+0]
   \   000001EC   7910A0E3           MOV      R1,#+121
   \   000001F0   141080E5           STR      R1,[R0, #+20]
   \   000001F4   002095E5           LDR      R2,[R5, #+0]
   \   000001F8   0010E0E3           MVN      R1,#+0
   \   000001FC   042092E5           LDR      R2,[R2, #+4]
   \   00000200   0500A0E1           MOV      R0,R5
   \   00000204   32FF2FE1           BLX      R2
   \                     ??decode_mcu_AC_refine_18:
   \   00000208   010057E3           CMP      R7,#+1
   \   0000020C   080000AA           BGE      ??decode_mcu_AC_refine_19
   \   00000210   0130A0E3           MOV      R3,#+1
   \   00000214   0720A0E1           MOV      R2,R7
   \   00000218   0610A0E1           MOV      R1,R6
   \   0000021C   10008DE2           ADD      R0,SP,#+16
   \   00000220   ........           BL       jpeg_fill_bit_buffer
   \   00000224   000050E3           CMP      R0,#+0
   \   00000228   7B00000A           BEQ      ??decode_mcu_AC_refine_13
   \   0000022C   18609DE5           LDR      R6,[SP, #+24]
   \   00000230   1C709DE5           LDR      R7,[SP, #+28]
   \                     ??decode_mcu_AC_refine_19:
   \   00000234   017047E2           SUB      R7,R7,#+1
   \   00000238   5607A0E1           ASR      R0,R6,R7
   \   0000023C   010010E3           TST      R0,#0x1
   \   00000240   2C409D05           LDREQ    R4,[SP, #+44]
   \   00000244   08409D15           LDRNE    R4,[SP, #+8]
   \                     ??decode_mcu_AC_refine_10:
   \   00000248   ........           LDR      R0,??DataTable9  ;; jpeg_natural_order
   \   0000024C   0C109DE5           LDR      R1,[SP, #+12]
   \   00000250   090190E7           LDR      R0,[R0, +R9, LSL #+2]
   \   00000254   80B081E0           ADD      R11,R1,R0, LSL #+1
   \   00000258   F000DBE1           LDRSH    R0,[R11, #+0]
   \   0000025C   000050E3           CMP      R0,#+0
   \   00000260   A0FFFF0A           BEQ      ??decode_mcu_AC_refine_7
   \   00000264   010057E3           CMP      R7,#+1
   \   00000268   080000AA           BGE      ??decode_mcu_AC_refine_20
   \   0000026C   0130A0E3           MOV      R3,#+1
   \   00000270   0720A0E1           MOV      R2,R7
   \   00000274   0610A0E1           MOV      R1,R6
   \   00000278   10008DE2           ADD      R0,SP,#+16
   \   0000027C   ........           BL       jpeg_fill_bit_buffer
   \   00000280   000050E3           CMP      R0,#+0
   \   00000284   6400000A           BEQ      ??decode_mcu_AC_refine_13
   \   00000288   18609DE5           LDR      R6,[SP, #+24]
   \   0000028C   1C709DE5           LDR      R7,[SP, #+28]
   \                     ??decode_mcu_AC_refine_20:
   \   00000290   017047E2           SUB      R7,R7,#+1
   \   00000294   5607A0E1           ASR      R0,R6,R7
   \   00000298   010010E3           TST      R0,#0x1
   \   0000029C   93FFFF0A           BEQ      ??decode_mcu_AC_refine_9
   \   000002A0   F000DBE1           LDRSH    R0,[R11, #+0]
   \   000002A4   08209DE5           LDR      R2,[SP, #+8]
   \   000002A8   000012E1           TST      R2,R0
   \   000002AC   8FFFFF1A           BNE      ??decode_mcu_AC_refine_9
   \   000002B0   000050E3           CMP      R0,#+0
   \   000002B4   2C109D45           LDRMI    R1,[SP, #+44]
   \   000002B8   00008250           ADDPL    R0,R2,R0
   \   000002BC   00008140           ADDMI    R0,R1,R0
   \   000002C0   B000CBE1           STRH     R0,[R11, #+0]
   \   000002C4   89FFFFEA           B        ??decode_mcu_AC_refine_9
   \                     ??decode_mcu_AC_refine_17:
   \   000002C8   0F005AE3           CMP      R10,#+15
   \   000002CC   DDFFFF0A           BEQ      ??decode_mcu_AC_refine_10
   \   000002D0   0110A0E3           MOV      R1,#+1
   \   000002D4   111AA0E1           LSL      R1,R1,R10
   \   000002D8   04108DE5           STR      R1,[SP, #+4]
   \   000002DC   00005AE3           CMP      R10,#+0
   \   000002E0   7CFFFF0A           BEQ      ??decode_mcu_AC_refine_4
   \   000002E4   0A0057E1           CMP      R7,R10
   \   000002E8   080000AA           BGE      ??decode_mcu_AC_refine_21
   \   000002EC   0A30A0E1           MOV      R3,R10
   \   000002F0   0720A0E1           MOV      R2,R7
   \   000002F4   0610A0E1           MOV      R1,R6
   \   000002F8   10008DE2           ADD      R0,SP,#+16
   \   000002FC   ........           BL       jpeg_fill_bit_buffer
   \   00000300   000050E3           CMP      R0,#+0
   \   00000304   4400000A           BEQ      ??decode_mcu_AC_refine_13
   \   00000308   18609DE5           LDR      R6,[SP, #+24]
   \   0000030C   1C709DE5           LDR      R7,[SP, #+28]
   \                     ??decode_mcu_AC_refine_21:
   \   00000310   ........           LDR      R2,??DataTable8  ;; bmask
   \   00000314   04109DE5           LDR      R1,[SP, #+4]
   \   00000318   0A2192E7           LDR      R2,[R2, +R10, LSL #+2]
   \   0000031C   0A7047E0           SUB      R7,R7,R10
   \   00000320   562702E0           AND      R2,R2,R6, ASR R7
   \   00000324   011082E0           ADD      R1,R2,R1
   \   00000328   04108DE5           STR      R1,[SP, #+4]
   \   0000032C   69FFFFEA           B        ??decode_mcu_AC_refine_4
    957                /* Scan any remaining coefficient positions after the end-of-band
    958                 * (the last newly nonzero coefficient, if any).  Append a correction
    959                 * bit to each already-nonzero coefficient.  A correction bit is 1
    960                 * if the absolute value of the coefficient must be increased.
    961                 */
    962                for (; k <= Se; k++) {
    963          	thiscoef = *block + jpeg_natural_order[k];
    964          	if (*thiscoef != 0) {
    965          	  CHECK_BIT_BUFFER(br_state, 1, goto undoit);
    966          	  if (GET_BITS(1)) {
    967          	    if ((*thiscoef & p1) == 0) { /* do nothing if already changed it */
    968          	      if (*thiscoef >= 0)
    969          		*thiscoef += p1;
   \                     ??decode_mcu_AC_refine_22:
   \   00000330   B000CBE1           STRH     R0,[R11, #+0]
   \                     ??decode_mcu_AC_refine_23:
   \   00000334   019089E2           ADD      R9,R9,#+1
   \                     ??decode_mcu_AC_refine_5:
   \   00000338   28009DE5           LDR      R0,[SP, #+40]
   \   0000033C   090050E1           CMP      R0,R9
   \   00000340   1E0000BA           BLT      ??decode_mcu_AC_refine_24
   \   00000344   ........           LDR      R0,??DataTable9  ;; jpeg_natural_order
   \   00000348   0C109DE5           LDR      R1,[SP, #+12]
   \   0000034C   090190E7           LDR      R0,[R0, +R9, LSL #+2]
   \   00000350   80B081E0           ADD      R11,R1,R0, LSL #+1
   \   00000354   F000DBE1           LDRSH    R0,[R11, #+0]
   \   00000358   000050E3           CMP      R0,#+0
   \   0000035C   F4FFFF0A           BEQ      ??decode_mcu_AC_refine_23
   \   00000360   010057E3           CMP      R7,#+1
   \   00000364   080000AA           BGE      ??decode_mcu_AC_refine_25
   \   00000368   0130A0E3           MOV      R3,#+1
   \   0000036C   0720A0E1           MOV      R2,R7
   \   00000370   0610A0E1           MOV      R1,R6
   \   00000374   10008DE2           ADD      R0,SP,#+16
   \   00000378   ........           BL       jpeg_fill_bit_buffer
   \   0000037C   000050E3           CMP      R0,#+0
   \   00000380   2500000A           BEQ      ??decode_mcu_AC_refine_13
   \   00000384   18609DE5           LDR      R6,[SP, #+24]
   \   00000388   1C709DE5           LDR      R7,[SP, #+28]
   \                     ??decode_mcu_AC_refine_25:
   \   0000038C   017047E2           SUB      R7,R7,#+1
   \   00000390   5607A0E1           ASR      R0,R6,R7
   \   00000394   010010E3           TST      R0,#0x1
   \   00000398   E5FFFF0A           BEQ      ??decode_mcu_AC_refine_23
   \   0000039C   F000DBE1           LDRSH    R0,[R11, #+0]
   \   000003A0   08209DE5           LDR      R2,[SP, #+8]
   \   000003A4   000012E1           TST      R2,R0
   \   000003A8   E1FFFF1A           BNE      ??decode_mcu_AC_refine_23
   \   000003AC   000050E3           CMP      R0,#+0
   \   000003B0   2C109D45           LDRMI    R1,[SP, #+44]
   \   000003B4   00008250           ADDPL    R0,R2,R0
   \   000003B8   00008140           ADDMI    R0,R1,R0
   \   000003BC   DBFFFFEA           B        ??decode_mcu_AC_refine_22
    970          	      else
    971          		*thiscoef += m1;
    972          	    }
    973          	  }
    974          	}
    975                }
    976                /* Count one block completed in EOB run */
    977                EOBRUN--;
   \                     ??decode_mcu_AC_refine_24:
   \   000003C0   04109DE5           LDR      R1,[SP, #+4]
   \   000003C4   011041E2           SUB      R1,R1,#+1
   \   000003C8   04108DE5           STR      R1,[SP, #+4]
    978              }
    979          
    980              /* Completed MCU, so update state */
    981              BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
   \                     ??decode_mcu_AC_refine_6:
   \   000003CC   180095E5           LDR      R0,[R5, #+24]
   \   000003D0   10109DE5           LDR      R1,[SP, #+16]
   \   000003D4   001080E5           STR      R1,[R0, #+0]
   \   000003D8   180095E5           LDR      R0,[R5, #+24]
   \   000003DC   14109DE5           LDR      R1,[SP, #+20]
   \   000003E0   041080E5           STR      R1,[R0, #+4]
   \   000003E4   00009DE5           LDR      R0,[SP, #+0]
   \   000003E8   0C6080E5           STR      R6,[R0, #+12]
   \   000003EC   00009DE5           LDR      R0,[SP, #+0]
   \   000003F0   107080E5           STR      R7,[R0, #+16]
    982              entropy->saved.EOBRUN = EOBRUN; /* only part of saved state we need */
   \   000003F4   00009DE5           LDR      R0,[SP, #+0]
   \   000003F8   04109DE5           LDR      R1,[SP, #+4]
   \   000003FC   141080E5           STR      R1,[R0, #+20]
    983            }
    984          
    985            /* Account for restart interval (no-op if not using restarts) */
    986            entropy->restarts_to_go--;
   \                     ??decode_mcu_AC_refine_2:
   \   00000400   00009DE5           LDR      R0,[SP, #+0]
   \   00000404   281090E5           LDR      R1,[R0, #+40]
   \   00000408   011041E2           SUB      R1,R1,#+1
   \   0000040C   281080E5           STR      R1,[R0, #+40]
    987          
    988            return TRUE;
   \   00000410   0100A0E3           MOV      R0,#+1
   \   00000414   4CDF8DE2           ADD      SP,SP,#+304
   \   00000418   F08FBDE8           POP      {R4-R11,PC}
    989          
    990          undoit:
    991            /* Re-zero any output coefficients that we made newly nonzero */
    992            while (num_newnz > 0)
   \                     ??decode_mcu_AC_refine_13:
   \   0000041C   010058E3           CMP      R8,#+1
   \   00000420   10FFFFBA           BLT      ??decode_mcu_AC_refine_1
    993              (*block)[newnz_pos[--num_newnz]] = 0;
   \   00000424   0C109DE5           LDR      R1,[SP, #+12]
   \   00000428   018048E2           SUB      R8,R8,#+1
   \   0000042C   30008DE2           ADD      R0,SP,#+48
   \   00000430   080190E7           LDR      R0,[R0, +R8, LSL #+2]
   \   00000434   800081E0           ADD      R0,R1,R0, LSL #+1
   \   00000438   0010A0E3           MOV      R1,#+0
   \   0000043C   B010C0E1           STRH     R1,[R0, #+0]
   \   00000440   F5FFFFEA           B        ??decode_mcu_AC_refine_13
    994          
    995            return FALSE;
    996          }
    997          
    998          
    999          /*
   1000           * Decode one MCU's worth of Huffman-compressed coefficients.
   1001           */
   1002          

   \                                 In segment CODE, align 4, keep-with-next
   1003          METHODDEF(boolean)
   1004          decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
   1005          {
   \                     decode_mcu:
   \   00000000   F24F2DE9           PUSH     {R1,R4-R11,LR}
   \   00000004   2CD04DE2           SUB      SP,SP,#+44
   \   00000008   0050A0E1           MOV      R5,R0
   1006            huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
   1007            int blkn;
   1008            BITREAD_STATE_VARS;
   1009            savable_state state;
   1010          
   1011            /* Process restart marker if needed; may have to suspend */
   1012            if (cinfo->restart_interval) {
   \   0000000C   100195E5           LDR      R0,[R5, #+272]
   \   00000010   BC6195E5           LDR      R6,[R5, #+444]
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0900000A           BEQ      ??decode_mcu_0
   1013              if (entropy->restarts_to_go == 0)
   \   0000001C   280096E5           LDR      R0,[R6, #+40]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0600001A           BNE      ??decode_mcu_0
   1014                if (! process_restart(cinfo))
   \   00000028   0500A0E1           MOV      R0,R5
   \   0000002C   ........           BL       process_restart
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0200001A           BNE      ??decode_mcu_0
   1015          	return FALSE;
   \                     ??decode_mcu_1:
   \   00000038   0000A0E3           MOV      R0,#+0
   \   0000003C   30D08DE2           ADD      SP,SP,#+48
   \   00000040   F08FBDE8           POP      {R4-R11,PC}
   1016            }
   1017          
   1018            /* If we've run out of data, just leave the MCU set to zeroes.
   1019             * This way, we return uniform gray for the remainder of the segment.
   1020             */
   1021            if (! entropy->pub.insufficient_data) {
   \                     ??decode_mcu_0:
   \   00000044   080096E5           LDR      R0,[R6, #+8]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   EF00001A           BNE      ??decode_mcu_2
   1022          
   1023              /* Load up working state */
   1024              BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
   1025              ASSIGN_STATE(state, entropy->saved);
   1026          
   1027              /* Outer loop handles each block in the MCU */
   1028          
   1029              for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
   \   00000050   ........           LDR      R11,??DataTable8  ;; bmask
   \   00000054   10508DE5           STR      R5,[SP, #+16]
   \   00000058   181095E5           LDR      R1,[R5, #+24]
   \   0000005C   18008DE2           ADD      R0,SP,#+24
   \   00000060   001091E5           LDR      R1,[R1, #+0]
   \   00000064   143086E2           ADD      R3,R6,#+20
   \   00000068   00108DE5           STR      R1,[SP, #+0]
   \   0000006C   181095E5           LDR      R1,[R5, #+24]
   \   00000070   041091E5           LDR      R1,[R1, #+4]
   \   00000074   04108DE5           STR      R1,[SP, #+4]
   \   00000078   0C1096E5           LDR      R1,[R6, #+12]
   \   0000007C   102096E5           LDR      R2,[R6, #+16]
   \   00000080   900793E8           LDM      R3,{R4,R7-R10}
   \   00000084   900780E8           STM      R0,{R4,R7-R10}
   \   00000088   0070A0E3           MOV      R7,#+0
   \   0000008C   000000EA           B        ??decode_mcu_3
   \                     ??decode_mcu_4:
   \   00000090   017087E2           ADD      R7,R7,#+1
   \                     ??decode_mcu_3:
   \   00000094   640195E5           LDR      R0,[R5, #+356]
   \   00000098   000057E1           CMP      R7,R0
   \   0000009C   CF0000AA           BGE      ??decode_mcu_5
   1030                JBLOCKROW block = MCU_data[blkn];
   \   000000A0   2C309DE5           LDR      R3,[SP, #+44]
   1031                d_derived_tbl * htbl;
   1032                register int s, k, r;
   1033                int coef_limit, ci;
   1034          
   1035                /* Decode a single block's worth of coefficients */
   1036          
   1037                /* Section F.2.2.1: decode the DC coefficient difference */
   1038                htbl = entropy->dc_cur_tbls[blkn];
   \   000000A4   07A186E0           ADD      R10,R6,R7, LSL #+2
   \   000000A8   073193E7           LDR      R3,[R3, +R7, LSL #+2]
   1039                HUFF_DECODE(s, br_state, htbl, return FALSE, label1);
   \   000000AC   080052E3           CMP      R2,#+8
   \   000000B0   14308DE5           STR      R3,[SP, #+20]
   \   000000B4   60809AE5           LDR      R8,[R10, #+96]
   \   000000B8   090000AA           BGE      ??decode_mcu_6
   \   000000BC   0030A0E3           MOV      R3,#+0
   \   000000C0   0D00A0E1           MOV      R0,SP
   \   000000C4   ........           BL       jpeg_fill_bit_buffer
   \   000000C8   000050E3           CMP      R0,#+0
   \   000000CC   D300000A           BEQ      ??decode_mcu_7
   \   000000D0   0C209DE5           LDR      R2,[SP, #+12]
   \   000000D4   08109DE5           LDR      R1,[SP, #+8]
   \   000000D8   080052E3           CMP      R2,#+8
   \   000000DC   0100A0B3           MOVLT    R0,#+1
   \   000000E0   0B0000BA           BLT      ??decode_mcu_8
   \                     ??decode_mcu_6:
   \   000000E4   F80082E2           ADD      R0,R2,#+248
   \   000000E8   FF30A0E3           MOV      R3,#+255
   \   000000EC   513003E0           AND      R3,R3,R1, ASR R0
   \   000000F0   030188E0           ADD      R0,R8,R3, LSL #+2
   \   000000F4   900090E5           LDR      R0,[R0, #+144]
   \   000000F8   000050E3           CMP      R0,#+0
   \   000000FC   0300000A           BEQ      ??decode_mcu_9
   \   00000100   002042E0           SUB      R2,R2,R0
   \   00000104   080083E0           ADD      R0,R3,R8
   \   00000108   9044D0E5           LDRB     R4,[R0, #+1168]
   \   0000010C   090000EA           B        ??decode_mcu_10
   \                     ??decode_mcu_9:
   \   00000110   0900A0E3           MOV      R0,#+9
   \                     ??decode_mcu_8:
   \   00000114   01002DE9           PUSH     {R0}
   \   00000118   0830A0E1           MOV      R3,R8
   \   0000011C   04008DE2           ADD      R0,SP,#+4
   \   00000120   ........           BL       jpeg_huff_decode
   \   00000124   0040B0E1           MOVS     R4,R0
   \   00000128   04D08DE2           ADD      SP,SP,#+4
   \   0000012C   C1FFFF4A           BMI      ??decode_mcu_1
   \   00000130   08109DE5           LDR      R1,[SP, #+8]
   \   00000134   0C209DE5           LDR      R2,[SP, #+12]
   1040          
   1041                htbl = entropy->ac_cur_tbls[blkn];
   \                     ??decode_mcu_10:
   \   00000138   88809AE5           LDR      R8,[R10, #+136]
   1042                k = 1;
   1043                coef_limit = entropy->coef_limit[blkn];
   \   0000013C   B0A09AE5           LDR      R10,[R10, #+176]
   \   00000140   0190A0E3           MOV      R9,#+1
   1044                if (coef_limit) {
   \   00000144   00005AE3           CMP      R10,#+0
   \   00000148   6000000A           BEQ      ??decode_mcu_11
   1045          	/* Convert DC difference to actual value, update last_dc_val */
   1046          	if (s) {
   \   0000014C   000054E3           CMP      R4,#+0
   \   00000150   1100000A           BEQ      ??decode_mcu_12
   1047          	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
   \   00000154   040052E1           CMP      R2,R4
   \   00000158   060000AA           BGE      ??decode_mcu_13
   \   0000015C   0430A0E1           MOV      R3,R4
   \   00000160   0D00A0E1           MOV      R0,SP
   \   00000164   ........           BL       jpeg_fill_bit_buffer
   \   00000168   000050E3           CMP      R0,#+0
   \   0000016C   AB00000A           BEQ      ??decode_mcu_7
   \   00000170   08109DE5           LDR      R1,[SP, #+8]
   \   00000174   0C209DE5           LDR      R2,[SP, #+12]
   1048          	  r = GET_BITS(s);
   \                     ??decode_mcu_13:
   \   00000178   04019BE7           LDR      R0,[R11, +R4, LSL #+2]
   1049          	  s = HUFF_EXTEND(r, s);
   \   0000017C   04318BE0           ADD      R3,R11,R4, LSL #+2
   \   00000180   043013E5           LDR      R3,[R3, #-4]
   \   00000184   042042E0           SUB      R2,R2,R4
   \   00000188   510200E0           AND      R0,R0,R1, ASR R2
   \   0000018C   000053E1           CMP      R3,R0
   \   00000190   04319BA7           LDRGE    R3,[R11, +R4, LSL #+2]
   \   00000194   0040A0B1           MOVLT    R4,R0
   \   00000198   034040A0           SUBGE    R4,R0,R3
   1050          	}
   1051          	ci = cinfo->MCU_membership[blkn];
   \                     ??decode_mcu_12:
   \   0000019C   070185E0           ADD      R0,R5,R7, LSL #+2
   \   000001A0   680190E5           LDR      R0,[R0, #+360]
   1052          	s += state.last_dc_val[ci];
   \   000001A4   18308DE2           ADD      R3,SP,#+24
   \   000001A8   000183E0           ADD      R0,R3,R0, LSL #+2
   \   000001AC   043090E5           LDR      R3,[R0, #+4]
   \   000001B0   044083E0           ADD      R4,R3,R4
   1053          	state.last_dc_val[ci] = s;
   \   000001B4   044080E5           STR      R4,[R0, #+4]
   1054          	/* Output the DC coefficient */
   1055          	(*block)[0] = (JCOEF) s;
   \   000001B8   14009DE5           LDR      R0,[SP, #+20]
   \   000001BC   B040C0E1           STRH     R4,[R0, #+0]
   \   000001C0   030000EA           B        ??decode_mcu_14
   1056          
   1057          	/* Section F.2.2.2: decode the AC coefficients */
   1058          	/* Since zeroes are skipped, output area must be cleared beforehand */
   1059          	for (; k < coef_limit; k++) {
   1060          	  HUFF_DECODE(s, br_state, htbl, return FALSE, label2);
   1061          
   1062          	  r = s >> 4;
   1063          	  s &= 15;
   1064          
   1065          	  if (s) {
   1066          	    k += r;
   1067          	    CHECK_BIT_BUFFER(br_state, s, return FALSE);
   1068          	    r = GET_BITS(s);
   1069          	    s = HUFF_EXTEND(r, s);
   1070          	    /* Output coefficient in natural (dezigzagged) order.
   1071          	     * Note: the extra entries in jpeg_natural_order[] will save us
   1072          	     * if k >= DCTSIZE2, which could happen if the data is corrupted.
   1073          	     */
   1074          	    (*block)[jpeg_natural_order[k]] = (JCOEF) s;
   1075          	  } else {
   1076          	    if (r != 15)
   \                     ??decode_mcu_15:
   \   000001C4   0F0050E3           CMP      R0,#+15
   \   000001C8   B0FFFF1A           BNE      ??decode_mcu_4
   1077          	      goto EndOfBlock;
   1078          	    k += 15;
   \   000001CC   0F9089E2           ADD      R9,R9,#+15
   1079          	  }
   \                     ??decode_mcu_16:
   \   000001D0   019089E2           ADD      R9,R9,#+1
   \                     ??decode_mcu_14:
   \   000001D4   0A0059E1           CMP      R9,R10
   \   000001D8   710000AA           BGE      ??decode_mcu_17
   \   000001DC   080052E3           CMP      R2,#+8
   \   000001E0   090000AA           BGE      ??decode_mcu_18
   \   000001E4   0030A0E3           MOV      R3,#+0
   \   000001E8   0D00A0E1           MOV      R0,SP
   \   000001EC   ........           BL       jpeg_fill_bit_buffer
   \   000001F0   000050E3           CMP      R0,#+0
   \   000001F4   8900000A           BEQ      ??decode_mcu_7
   \   000001F8   0C209DE5           LDR      R2,[SP, #+12]
   \   000001FC   08109DE5           LDR      R1,[SP, #+8]
   \   00000200   080052E3           CMP      R2,#+8
   \   00000204   0100A0B3           MOVLT    R0,#+1
   \   00000208   0B0000BA           BLT      ??decode_mcu_19
   \                     ??decode_mcu_18:
   \   0000020C   F80082E2           ADD      R0,R2,#+248
   \   00000210   FF30A0E3           MOV      R3,#+255
   \   00000214   513003E0           AND      R3,R3,R1, ASR R0
   \   00000218   030188E0           ADD      R0,R8,R3, LSL #+2
   \   0000021C   900090E5           LDR      R0,[R0, #+144]
   \   00000220   000050E3           CMP      R0,#+0
   \   00000224   0300000A           BEQ      ??decode_mcu_20
   \   00000228   002042E0           SUB      R2,R2,R0
   \   0000022C   080083E0           ADD      R0,R3,R8
   \   00000230   9044D0E5           LDRB     R4,[R0, #+1168]
   \   00000234   090000EA           B        ??decode_mcu_21
   \                     ??decode_mcu_20:
   \   00000238   0900A0E3           MOV      R0,#+9
   \                     ??decode_mcu_19:
   \   0000023C   01002DE9           PUSH     {R0}
   \   00000240   0830A0E1           MOV      R3,R8
   \   00000244   04008DE2           ADD      R0,SP,#+4
   \   00000248   ........           BL       jpeg_huff_decode
   \   0000024C   0040B0E1           MOVS     R4,R0
   \   00000250   04D08DE2           ADD      SP,SP,#+4
   \   00000254   77FFFF4A           BMI      ??decode_mcu_1
   \   00000258   08109DE5           LDR      R1,[SP, #+8]
   \   0000025C   0C209DE5           LDR      R2,[SP, #+12]
   \                     ??decode_mcu_21:
   \   00000260   4402A0E1           ASR      R0,R4,#+4
   \   00000264   0F4014E2           ANDS     R4,R4,#0xF
   \   00000268   D5FFFF0A           BEQ      ??decode_mcu_15
   \   0000026C   099080E0           ADD      R9,R0,R9
   \   00000270   040052E1           CMP      R2,R4
   \   00000274   060000AA           BGE      ??decode_mcu_22
   \   00000278   0430A0E1           MOV      R3,R4
   \   0000027C   0D00A0E1           MOV      R0,SP
   \   00000280   ........           BL       jpeg_fill_bit_buffer
   \   00000284   000050E3           CMP      R0,#+0
   \   00000288   6400000A           BEQ      ??decode_mcu_7
   \   0000028C   08109DE5           LDR      R1,[SP, #+8]
   \   00000290   0C209DE5           LDR      R2,[SP, #+12]
   \                     ??decode_mcu_22:
   \   00000294   04019BE7           LDR      R0,[R11, +R4, LSL #+2]
   \   00000298   04318BE0           ADD      R3,R11,R4, LSL #+2
   \   0000029C   043013E5           LDR      R3,[R3, #-4]
   \   000002A0   042042E0           SUB      R2,R2,R4
   \   000002A4   510200E0           AND      R0,R0,R1, ASR R2
   \   000002A8   000053E1           CMP      R3,R0
   \   000002AC   04319BA7           LDRGE    R3,[R11, +R4, LSL #+2]
   \   000002B0   0040A0B1           MOVLT    R4,R0
   \   000002B4   034040A0           SUBGE    R4,R0,R3
   \   000002B8   ........           LDR      R0,??DataTable9  ;; jpeg_natural_order
   \   000002BC   14309DE5           LDR      R3,[SP, #+20]
   \   000002C0   090190E7           LDR      R0,[R0, +R9, LSL #+2]
   \   000002C4   800083E0           ADD      R0,R3,R0, LSL #+1
   \   000002C8   B040C0E1           STRH     R4,[R0, #+0]
   \   000002CC   BFFFFFEA           B        ??decode_mcu_16
   1080          	}
   1081                } else {
   1082          	if (s) {
   \                     ??decode_mcu_11:
   \   000002D0   000054E3           CMP      R4,#+0
   \   000002D4   3400000A           BEQ      ??decode_mcu_23
   1083          	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
   \   000002D8   040052E1           CMP      R2,R4
   \   000002DC   060000AA           BGE      ??decode_mcu_24
   \   000002E0   0430A0E1           MOV      R3,R4
   \   000002E4   0D00A0E1           MOV      R0,SP
   \   000002E8   ........           BL       jpeg_fill_bit_buffer
   \   000002EC   000050E3           CMP      R0,#+0
   \   000002F0   4A00000A           BEQ      ??decode_mcu_7
   \   000002F4   08109DE5           LDR      R1,[SP, #+8]
   \   000002F8   0C209DE5           LDR      R2,[SP, #+12]
   1084          	  DROP_BITS(s);
   \                     ??decode_mcu_24:
   \   000002FC   042042E0           SUB      R2,R2,R4
   \   00000300   290000EA           B        ??decode_mcu_23
   1085          	}
   1086                }
   1087          
   1088                /* Section F.2.2.2: decode the AC coefficients */
   1089                /* In this path we just discard the values */
   1090                for (; k < DCTSIZE2; k++) {
   1091          	HUFF_DECODE(s, br_state, htbl, return FALSE, label3);
   \                     ??decode_mcu_25:
   \   00000304   F80082E2           ADD      R0,R2,#+248
   \   00000308   FF30A0E3           MOV      R3,#+255
   \   0000030C   510003E0           AND      R0,R3,R1, ASR R0
   \   00000310   003188E0           ADD      R3,R8,R0, LSL #+2
   \   00000314   903093E5           LDR      R3,[R3, #+144]
   \   00000318   000053E3           CMP      R3,#+0
   \   0000031C   0300000A           BEQ      ??decode_mcu_26
   \   00000320   032042E0           SUB      R2,R2,R3
   \   00000324   080080E0           ADD      R0,R0,R8
   \   00000328   9044D0E5           LDRB     R4,[R0, #+1168]
   \   0000032C   090000EA           B        ??decode_mcu_27
   \                     ??decode_mcu_26:
   \   00000330   0930A0E3           MOV      R3,#+9
   \                     ??decode_mcu_28:
   \   00000334   08002DE9           PUSH     {R3}
   \   00000338   04008DE2           ADD      R0,SP,#+4
   \   0000033C   0830A0E1           MOV      R3,R8
   \   00000340   ........           BL       jpeg_huff_decode
   \   00000344   0040B0E1           MOVS     R4,R0
   \   00000348   04D08DE2           ADD      SP,SP,#+4
   \   0000034C   39FFFF4A           BMI      ??decode_mcu_1
   \   00000350   08109DE5           LDR      R1,[SP, #+8]
   \   00000354   0C209DE5           LDR      R2,[SP, #+12]
   1092          
   1093          	r = s >> 4;
   \                     ??decode_mcu_27:
   \   00000358   4402A0E1           ASR      R0,R4,#+4
   1094          	s &= 15;
   \   0000035C   0F4014E2           ANDS     R4,R4,#0xF
   1095          
   1096          	if (s) {
   \   00000360   0B00000A           BEQ      ??decode_mcu_29
   1097          	  k += r;
   \   00000364   099080E0           ADD      R9,R0,R9
   1098          	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
   \   00000368   040052E1           CMP      R2,R4
   \   0000036C   060000AA           BGE      ??decode_mcu_30
   \   00000370   0430A0E1           MOV      R3,R4
   \   00000374   0D00A0E1           MOV      R0,SP
   \   00000378   ........           BL       jpeg_fill_bit_buffer
   \   0000037C   000050E3           CMP      R0,#+0
   \   00000380   2600000A           BEQ      ??decode_mcu_7
   \   00000384   08109DE5           LDR      R1,[SP, #+8]
   \   00000388   0C209DE5           LDR      R2,[SP, #+12]
   1099          	  DROP_BITS(s);
   \                     ??decode_mcu_30:
   \   0000038C   042042E0           SUB      R2,R2,R4
   \   00000390   020000EA           B        ??decode_mcu_31
   1100          	} else {
   1101          	  if (r != 15)
   \                     ??decode_mcu_29:
   \   00000394   0F0050E3           CMP      R0,#+15
   \   00000398   3CFFFF1A           BNE      ??decode_mcu_4
   1102          	    break;
   1103          	  k += 15;
   \   0000039C   0F9089E2           ADD      R9,R9,#+15
   1104          	}
   \                     ??decode_mcu_31:
   \   000003A0   019089E2           ADD      R9,R9,#+1
   \                     ??decode_mcu_17:
   \   000003A4   400059E3           CMP      R9,#+64
   \   000003A8   38FFFFAA           BGE      ??decode_mcu_4
   \                     ??decode_mcu_23:
   \   000003AC   080052E3           CMP      R2,#+8
   \   000003B0   D3FFFFAA           BGE      ??decode_mcu_25
   \   000003B4   0030A0E3           MOV      R3,#+0
   \   000003B8   0D00A0E1           MOV      R0,SP
   \   000003BC   ........           BL       jpeg_fill_bit_buffer
   \   000003C0   000050E3           CMP      R0,#+0
   \   000003C4   1500000A           BEQ      ??decode_mcu_7
   \   000003C8   0C209DE5           LDR      R2,[SP, #+12]
   \   000003CC   08109DE5           LDR      R1,[SP, #+8]
   \   000003D0   080052E3           CMP      R2,#+8
   \   000003D4   CAFFFFAA           BGE      ??decode_mcu_25
   \   000003D8   0130A0E3           MOV      R3,#+1
   \   000003DC   D4FFFFEA           B        ??decode_mcu_28
   1105                }
   1106          
   1107                EndOfBlock: ;
   1108              }
   1109          
   1110              /* Completed MCU, so update state */
   1111              BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
   \                     ??decode_mcu_5:
   \   000003E0   180095E5           LDR      R0,[R5, #+24]
   \   000003E4   00309DE5           LDR      R3,[SP, #+0]
   \   000003E8   003080E5           STR      R3,[R0, #+0]
   \   000003EC   180095E5           LDR      R0,[R5, #+24]
   \   000003F0   04309DE5           LDR      R3,[SP, #+4]
   \   000003F4   043080E5           STR      R3,[R0, #+4]
   \   000003F8   0C1086E5           STR      R1,[R6, #+12]
   \   000003FC   102086E5           STR      R2,[R6, #+16]
   1112              ASSIGN_STATE(entropy->saved, state);
   \   00000400   140086E2           ADD      R0,R6,#+20
   \   00000404   18108DE2           ADD      R1,SP,#+24
   \   00000408   BC0091E8           LDM      R1,{R2-R5,R7}
   \   0000040C   BC0080E8           STM      R0,{R2-R5,R7}
   1113            }
   1114          
   1115            /* Account for restart interval (no-op if not using restarts) */
   1116            entropy->restarts_to_go--;
   \                     ??decode_mcu_2:
   \   00000410   280096E5           LDR      R0,[R6, #+40]
   \   00000414   010040E2           SUB      R0,R0,#+1
   \   00000418   280086E5           STR      R0,[R6, #+40]
   1117          
   1118            return TRUE;
   \   0000041C   0100A0E3           MOV      R0,#+1
   \                     ??decode_mcu_7:
   \   00000420   30D08DE2           ADD      SP,SP,#+48       ;; stack cleaning
   \   00000424   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1119          }
   1120          
   1121          
   1122          /*
   1123           * Initialize for a Huffman-compressed scan.
   1124           */
   1125          

   \                                 In segment CODE, align 4, keep-with-next
   1126          METHODDEF(void)
   1127          start_pass_huff_decoder (j_decompress_ptr cinfo)
   1128          {
   \                     start_pass_huff_decoder:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1129            huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
   1130            int ci, blkn, dctbl, actbl, i;
   1131            jpeg_component_info * compptr;
   1132          
   1133            if (cinfo->progressive_mode) {
   \   00000008   D80094E5           LDR      R0,[R4, #+216]
   \   0000000C   BC5194E5           LDR      R5,[R4, #+444]
   \   00000010   0060A0E3           MOV      R6,#+0
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   900194E5           LDR      R0,[R4, #+400]
   \   0000001C   9A00000A           BEQ      ??start_pass_huff_decoder_0
   1134              /* Validate progressive scan parameters */
   1135              if (cinfo->Ss == 0) {
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   940194E5           LDR      R0,[R4, #+404]
   \   00000028   0200001A           BNE      ??start_pass_huff_decoder_1
   1136                if (cinfo->Se != 0)
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   1200001A           BNE      ??start_pass_huff_decoder_2
   \   00000034   070000EA           B        ??start_pass_huff_decoder_3
   1137          	goto bad;
   1138              } else {
   1139                /* need not check Ss/Se < 0 since they came from unsigned bytes */
   1140                if (cinfo->Se < cinfo->Ss || cinfo->Se >= DCTSIZE2)
   \                     ??start_pass_huff_decoder_1:
   \   00000038   901194E5           LDR      R1,[R4, #+400]
   \   0000003C   010050E1           CMP      R0,R1
   \   00000040   0E0000BA           BLT      ??start_pass_huff_decoder_2
   \   00000044   400050E3           CMP      R0,#+64
   \   00000048   0C0000AA           BGE      ??start_pass_huff_decoder_2
   1141          	goto bad;
   1142                /* AC scans may have only one component */
   1143                if (cinfo->comps_in_scan != 1)
   \   0000004C   480194E5           LDR      R0,[R4, #+328]
   \   00000050   010050E3           CMP      R0,#+1
   \   00000054   0900001A           BNE      ??start_pass_huff_decoder_2
   1144          	goto bad;
   1145              }
   1146              if (cinfo->Ah != 0) {
   \                     ??start_pass_huff_decoder_3:
   \   00000058   980194E5           LDR      R0,[R4, #+408]
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   0300000A           BEQ      ??start_pass_huff_decoder_4
   1147                /* Successive approximation refinement scan: must have Al = Ah-1. */
   1148                if (cinfo->Ah-1 != cinfo->Al)
   \   00000064   9C1194E5           LDR      R1,[R4, #+412]
   \   00000068   010040E2           SUB      R0,R0,#+1
   \   0000006C   010050E1           CMP      R0,R1
   \   00000070   0200001A           BNE      ??start_pass_huff_decoder_2
   1149          	goto bad;
   1150              }
   1151              if (cinfo->Al > 13) {	/* need not check for < 0 */
   \                     ??start_pass_huff_decoder_4:
   \   00000074   9C0194E5           LDR      R0,[R4, #+412]
   \   00000078   0E0050E3           CMP      R0,#+14
   \   0000007C   120000BA           BLT      ??start_pass_huff_decoder_5
   1152                /* Arguably the maximum Al value should be less than 13 for 8-bit precision,
   1153                 * but the spec doesn't say so, and we try to be liberal about what we
   1154                 * accept.  Note: large Al values could result in out-of-range DC
   1155                 * coefficients during early scans, leading to bizarre displays due to
   1156                 * overflows in the IDCT math.  But we won't crash.
   1157                 */
   1158                bad:
   1159                ERREXIT4(cinfo, JERR_BAD_PROGRESSION,
   1160          	       cinfo->Ss, cinfo->Se, cinfo->Ah, cinfo->Al);
   \                     ??start_pass_huff_decoder_2:
   \   00000080   000094E5           LDR      R0,[R4, #+0]
   \   00000084   1110A0E3           MOV      R1,#+17
   \   00000088   141080E5           STR      R1,[R0, #+20]
   \   0000008C   000094E5           LDR      R0,[R4, #+0]
   \   00000090   901194E5           LDR      R1,[R4, #+400]
   \   00000094   181080E5           STR      R1,[R0, #+24]
   \   00000098   000094E5           LDR      R0,[R4, #+0]
   \   0000009C   941194E5           LDR      R1,[R4, #+404]
   \   000000A0   1C1080E5           STR      R1,[R0, #+28]
   \   000000A4   000094E5           LDR      R0,[R4, #+0]
   \   000000A8   981194E5           LDR      R1,[R4, #+408]
   \   000000AC   201080E5           STR      R1,[R0, #+32]
   \   000000B0   000094E5           LDR      R0,[R4, #+0]
   \   000000B4   9C1194E5           LDR      R1,[R4, #+412]
   \   000000B8   241080E5           STR      R1,[R0, #+36]
   \   000000BC   001094E5           LDR      R1,[R4, #+0]
   \   000000C0   0400A0E1           MOV      R0,R4
   \   000000C4   001091E5           LDR      R1,[R1, #+0]
   \   000000C8   31FF2FE1           BLX      R1
   1161              }
   1162              /* Update progression status, and verify that scan order is legal.
   1163               * Note that inter-scan inconsistencies are treated as warnings
   1164               * not fatal errors ... not clear if this is right way to behave.
   1165               */
   1166              for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
   \                     ??start_pass_huff_decoder_5:
   \   000000CC   480194E5           LDR      R0,[R4, #+328]
   \   000000D0   0070A0E3           MOV      R7,#+0
   \   000000D4   010050E3           CMP      R0,#+1
   \   000000D8   76A0A0E3           MOV      R10,#+118
   \   000000DC   1C0000AA           BGE      ??start_pass_huff_decoder_6
   1167                int coefi, cindex = cinfo->cur_comp_info[ci]->component_index;
   1168                int *coef_bit_ptr = & cinfo->coef_bits[cindex][0];
   1169                if (cinfo->Ss && coef_bit_ptr[0] < 0) /* AC without prior DC scan */
   1170          	WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, 0);
   1171                for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {
   1172          	int expected = (coef_bit_ptr[coefi] < 0) ? 0 : coef_bit_ptr[coefi];
   1173          	if (cinfo->Ah != expected)
   1174          	  WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, coefi);
   1175          	coef_bit_ptr[coefi] = cinfo->Al;
   1176                }
   1177              }
   1178          
   1179              /* Select MCU decoding routine */
   1180              if (cinfo->Ah == 0) {
   \                     ??start_pass_huff_decoder_7:
   \   000000E0   980194E5           LDR      R0,[R4, #+408]
   \   000000E4   000050E3           CMP      R0,#+0
   \   000000E8   900194E5           LDR      R0,[R4, #+400]
   \   000000EC   3A00001A           BNE      ??start_pass_huff_decoder_8
   1181                if (cinfo->Ss == 0)
   \   000000F0   000050E3           CMP      R0,#+0
   \   000000F4   F8029F15           LDRNE    R0,??start_pass_huff_decoder_9  ;; decode_mcu_AC_first
   1182          	entropy->pub.decode_mcu = decode_mcu_DC_first;
   \   000000F8   F8029F05           LDREQ    R0,??start_pass_huff_decoder_9+0x4  ;; decode_mcu_DC_first
   \   000000FC   390000EA           B        ??start_pass_huff_decoder_10
   1183                else
   1184          	entropy->pub.decode_mcu = decode_mcu_AC_first;
   1185              } else {
   \                     ??start_pass_huff_decoder_11:
   \   00000100   981194E5           LDR      R1,[R4, #+408]
   \   00000104   000051E1           CMP      R1,R0
   \   00000108   0A00000A           BEQ      ??start_pass_huff_decoder_12
   \   0000010C   000094E5           LDR      R0,[R4, #+0]
   \   00000110   0610E0E1           MVN      R1,R6
   \   00000114   14A080E5           STR      R10,[R0, #+20]
   \   00000118   000094E5           LDR      R0,[R4, #+0]
   \   0000011C   18B080E5           STR      R11,[R0, #+24]
   \   00000120   000094E5           LDR      R0,[R4, #+0]
   \   00000124   1C9080E5           STR      R9,[R0, #+28]
   \   00000128   002094E5           LDR      R2,[R4, #+0]
   \   0000012C   0400A0E1           MOV      R0,R4
   \   00000130   042092E5           LDR      R2,[R2, #+4]
   \   00000134   32FF2FE1           BLX      R2
   \                     ??start_pass_huff_decoder_12:
   \   00000138   9C0194E5           LDR      R0,[R4, #+412]
   \   0000013C   090188E7           STR      R0,[R8, +R9, LSL #+2]
   \   00000140   940194E5           LDR      R0,[R4, #+404]
   \   00000144   019089E2           ADD      R9,R9,#+1
   \   00000148   090050E1           CMP      R0,R9
   \   0000014C   1D0000AA           BGE      ??start_pass_huff_decoder_13
   \                     ??start_pass_huff_decoder_14:
   \   00000150   017087E2           ADD      R7,R7,#+1
   \                     ??start_pass_huff_decoder_6:
   \   00000154   480194E5           LDR      R0,[R4, #+328]
   \   00000158   000057E1           CMP      R7,R0
   \   0000015C   DFFFFFAA           BGE      ??start_pass_huff_decoder_7
   \   00000160   070184E0           ADD      R0,R4,R7, LSL #+2
   \   00000164   4C0190E5           LDR      R0,[R0, #+332]
   \   00000168   04B090E5           LDR      R11,[R0, #+4]
   \   0000016C   9C0094E5           LDR      R0,[R4, #+156]
   \   00000170   0B8480E0           ADD      R8,R0,R11, LSL #+8
   \   00000174   900194E5           LDR      R0,[R4, #+400]
   \   00000178   000050E3           CMP      R0,#+0
   \   0000017C   0D00000A           BEQ      ??start_pass_huff_decoder_15
   \   00000180   000098E5           LDR      R0,[R8, #+0]
   \   00000184   000050E3           CMP      R0,#+0
   \   00000188   0A00005A           BPL      ??start_pass_huff_decoder_15
   \   0000018C   000094E5           LDR      R0,[R4, #+0]
   \   00000190   0610E0E1           MVN      R1,R6
   \   00000194   14A080E5           STR      R10,[R0, #+20]
   \   00000198   000094E5           LDR      R0,[R4, #+0]
   \   0000019C   18B080E5           STR      R11,[R0, #+24]
   \   000001A0   000094E5           LDR      R0,[R4, #+0]
   \   000001A4   1C6080E5           STR      R6,[R0, #+28]
   \   000001A8   002094E5           LDR      R2,[R4, #+0]
   \   000001AC   0400A0E1           MOV      R0,R4
   \   000001B0   042092E5           LDR      R2,[R2, #+4]
   \   000001B4   32FF2FE1           BLX      R2
   \                     ??start_pass_huff_decoder_15:
   \   000001B8   909194E5           LDR      R9,[R4, #+400]
   \   000001BC   940194E5           LDR      R0,[R4, #+404]
   \   000001C0   090050E1           CMP      R0,R9
   \   000001C4   E1FFFFBA           BLT      ??start_pass_huff_decoder_14
   \                     ??start_pass_huff_decoder_13:
   \   000001C8   090198E7           LDR      R0,[R8, +R9, LSL #+2]
   \   000001CC   000050E3           CMP      R0,#+0
   \   000001D0   CAFFFF5A           BPL      ??start_pass_huff_decoder_11
   \   000001D4   0000A0E3           MOV      R0,#+0
   \   000001D8   C8FFFFEA           B        ??start_pass_huff_decoder_11
   1186                if (cinfo->Ss == 0)
   \                     ??start_pass_huff_decoder_8:
   \   000001DC   000050E3           CMP      R0,#+0
   1187          	entropy->pub.decode_mcu = decode_mcu_DC_refine;
   \   000001E0   14029F05           LDREQ    R0,??start_pass_huff_decoder_9+0x8  ;; decode_mcu_DC_refine
   1188                else
   1189          	entropy->pub.decode_mcu = decode_mcu_AC_refine;
   \   000001E4   14029F15           LDRNE    R0,??start_pass_huff_decoder_9+0xC  ;; decode_mcu_AC_refine
   1190              }
   1191          
   1192              for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
   \                     ??start_pass_huff_decoder_10:
   \   000001E8   0070A0E3           MOV      R7,#+0
   \   000001EC   040085E5           STR      R0,[R5, #+4]
   \   000001F0   480194E5           LDR      R0,[R4, #+328]
   \   000001F4   010050E3           CMP      R0,#+1
   \   000001F8   110000AA           BGE      ??start_pass_huff_decoder_16
   1193                compptr = cinfo->cur_comp_info[ci];
   1194                /* Make sure requested tables are present, and compute derived tables.
   1195                 * We may build same derived table more than once, but it's not expensive.
   1196                 */
   1197                if (cinfo->Ss == 0) {
   1198          	if (cinfo->Ah == 0) {	/* DC refinement needs no table */
   1199          	  i = compptr->dc_tbl_no;
   1200          	  jpeg_make_d_derived_tbl(cinfo, TRUE, i,
   1201          				  & entropy->derived_tbls[i]);
   1202          	}
   1203                } else {
   1204          	i = compptr->ac_tbl_no;
   1205          	jpeg_make_d_derived_tbl(cinfo, FALSE, i,
   1206          				& entropy->derived_tbls[i]);
   1207          	/* remember the single active table */
   1208          	entropy->ac_derived_tbl = entropy->derived_tbls[i];
   1209                }
   1210                /* Initialize DC predictions to 0 */
   1211                entropy->saved.last_dc_val[ci] = 0;
   1212              }
   1213          
   1214              /* Initialize private state variables */
   1215              entropy->saved.EOBRUN = 0;
   \                     ??start_pass_huff_decoder_17:
   \   000001FC   146085E5           STR      R6,[R5, #+20]
   1216            } else {
   1217              /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.
   1218               * This ought to be an error condition, but we make it a warning because
   1219               * there are some baseline files out there with all zeroes in these bytes.
   1220               */
   1221              if (cinfo->Ss != 0 || cinfo->Se != DCTSIZE2-1 ||
   1222          	cinfo->Ah != 0 || cinfo->Al != 0)
   1223                WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);
   1224          
   1225              /* Select MCU decoding routine */
   1226              entropy->pub.decode_mcu = decode_mcu;
   1227          
   1228              for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
   1229                compptr = cinfo->cur_comp_info[ci];
   1230                dctbl = compptr->dc_tbl_no;
   1231                actbl = compptr->ac_tbl_no;
   1232                /* Compute derived values for Huffman tables */
   1233                /* We may do this more than once for a table, but it's not expensive */
   1234                jpeg_make_d_derived_tbl(cinfo, TRUE, dctbl,
   1235          			      & entropy->dc_derived_tbls[dctbl]);
   1236                jpeg_make_d_derived_tbl(cinfo, FALSE, actbl,
   1237          			      & entropy->ac_derived_tbls[actbl]);
   1238                /* Initialize DC predictions to 0 */
   1239                entropy->saved.last_dc_val[ci] = 0;
   1240              }
   1241          
   1242              /* Precalculate decoding info for each block in an MCU of this scan */
   1243              for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
   1244                ci = cinfo->MCU_membership[blkn];
   1245                compptr = cinfo->cur_comp_info[ci];
   1246                /* Precalculate which table to use for each block */
   1247                entropy->dc_cur_tbls[blkn] = entropy->dc_derived_tbls[compptr->dc_tbl_no];
   1248                entropy->ac_cur_tbls[blkn] = entropy->ac_derived_tbls[compptr->ac_tbl_no];
   1249                /* Decide whether we really care about the coefficient values */
   1250                if (compptr->component_needed) {
   1251          	ci = compptr->DCT_v_scaled_size;
   1252          	if (ci <= 0 || ci > 8) ci = 8;
   1253          	i = compptr->DCT_h_scaled_size;
   1254          	if (i <= 0 || i > 8) i = 8;
   1255          	entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order[ci - 1][i - 1];
   1256                } else {
   1257          	entropy->coef_limit[blkn] = 0;
   1258                }
   1259              }
   1260            }
   1261          
   1262            /* Initialize bitread state variables */
   1263            entropy->bitstate.bits_left = 0;
   \                     ??start_pass_huff_decoder_18:
   \   00000200   106085E5           STR      R6,[R5, #+16]
   1264            entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
   \   00000204   0C6085E5           STR      R6,[R5, #+12]
   1265            entropy->pub.insufficient_data = FALSE;
   \   00000208   086085E5           STR      R6,[R5, #+8]
   1266          
   1267            /* Initialize restart counter */
   1268            entropy->restarts_to_go = cinfo->restart_interval;
   \   0000020C   100194E5           LDR      R0,[R4, #+272]
   \   00000210   280085E5           STR      R0,[R5, #+40]
   1269          }
   \   00000214   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??start_pass_huff_decoder_19:
   \   00000218   182091E5           LDR      R2,[R1, #+24]
   \   0000021C   0010A0E3           MOV      R1,#+0
   \   00000220   028185E0           ADD      R8,R5,R2, LSL #+2
   \   00000224   2C3088E2           ADD      R3,R8,#+44
   \   00000228   0400A0E1           MOV      R0,R4
   \   0000022C   ........           BL       jpeg_make_d_derived_tbl
   \   00000230   2C0098E5           LDR      R0,[R8, #+44]
   \   00000234   3C0085E5           STR      R0,[R5, #+60]
   \                     ??start_pass_huff_decoder_20:
   \   00000238   070185E0           ADD      R0,R5,R7, LSL #+2
   \   0000023C   186080E5           STR      R6,[R0, #+24]
   \   00000240   017087E2           ADD      R7,R7,#+1
   \                     ??start_pass_huff_decoder_16:
   \   00000244   480194E5           LDR      R0,[R4, #+328]
   \   00000248   000057E1           CMP      R7,R0
   \   0000024C   EAFFFFAA           BGE      ??start_pass_huff_decoder_17
   \   00000250   070184E0           ADD      R0,R4,R7, LSL #+2
   \   00000254   4C1190E5           LDR      R1,[R0, #+332]
   \   00000258   900194E5           LDR      R0,[R4, #+400]
   \   0000025C   000050E3           CMP      R0,#+0
   \   00000260   ECFFFF1A           BNE      ??start_pass_huff_decoder_19
   \   00000264   980194E5           LDR      R0,[R4, #+408]
   \   00000268   000050E3           CMP      R0,#+0
   \   0000026C   F1FFFF1A           BNE      ??start_pass_huff_decoder_20
   \   00000270   142091E5           LDR      R2,[R1, #+20]
   \   00000274   0110A0E3           MOV      R1,#+1
   \   00000278   020185E0           ADD      R0,R5,R2, LSL #+2
   \   0000027C   2C3080E2           ADD      R3,R0,#+44
   \   00000280   0400A0E1           MOV      R0,R4
   \   00000284   ........           BL       jpeg_make_d_derived_tbl
   \   00000288   EAFFFFEA           B        ??start_pass_huff_decoder_20
   \                     ??start_pass_huff_decoder_0:
   \   0000028C   000050E3           CMP      R0,#+0
   \   00000290   94019405           LDREQ    R0,[R4, #+404]
   \   00000294   3F005003           CMPEQ    R0,#+63
   \   00000298   98019405           LDREQ    R0,[R4, #+408]
   \   0000029C   00005003           CMPEQ    R0,#+0
   \   000002A0   9C019405           LDREQ    R0,[R4, #+412]
   \   000002A4   00005003           CMPEQ    R0,#+0
   \   000002A8   0700000A           BEQ      ??start_pass_huff_decoder_21
   \   000002AC   000094E5           LDR      R0,[R4, #+0]
   \   000002B0   7D10A0E3           MOV      R1,#+125
   \   000002B4   141080E5           STR      R1,[R0, #+20]
   \   000002B8   002094E5           LDR      R2,[R4, #+0]
   \   000002BC   0610E0E1           MVN      R1,R6
   \   000002C0   042092E5           LDR      R2,[R2, #+4]
   \   000002C4   0400A0E1           MOV      R0,R4
   \   000002C8   32FF2FE1           BLX      R2
   \                     ??start_pass_huff_decoder_21:
   \   000002CC   30019FE5           LDR      R0,??start_pass_huff_decoder_9+0x10  ;; decode_mcu
   \   000002D0   0070A0E3           MOV      R7,#+0
   \   000002D4   040085E5           STR      R0,[R5, #+4]
   \   000002D8   480194E5           LDR      R0,[R4, #+328]
   \   000002DC   010050E3           CMP      R0,#+1
   \   000002E0   120000AA           BGE      ??start_pass_huff_decoder_22
   \   000002E4   140000EA           B        ??start_pass_huff_decoder_23
   \                     ??start_pass_huff_decoder_24:
   \   000002E8   070184E0           ADD      R0,R4,R7, LSL #+2
   \   000002EC   4C1190E5           LDR      R1,[R0, #+332]
   \   000002F0   142091E5           LDR      R2,[R1, #+20]
   \   000002F4   188091E5           LDR      R8,[R1, #+24]
   \   000002F8   020185E0           ADD      R0,R5,R2, LSL #+2
   \   000002FC   403080E2           ADD      R3,R0,#+64
   \   00000300   0110A0E3           MOV      R1,#+1
   \   00000304   0400A0E1           MOV      R0,R4
   \   00000308   ........           BL       jpeg_make_d_derived_tbl
   \   0000030C   080185E0           ADD      R0,R5,R8, LSL #+2
   \   00000310   503080E2           ADD      R3,R0,#+80
   \   00000314   0820A0E1           MOV      R2,R8
   \   00000318   0010A0E3           MOV      R1,#+0
   \   0000031C   0400A0E1           MOV      R0,R4
   \   00000320   ........           BL       jpeg_make_d_derived_tbl
   \   00000324   070185E0           ADD      R0,R5,R7, LSL #+2
   \   00000328   186080E5           STR      R6,[R0, #+24]
   \   0000032C   017087E2           ADD      R7,R7,#+1
   \                     ??start_pass_huff_decoder_22:
   \   00000330   480194E5           LDR      R0,[R4, #+328]
   \   00000334   000057E1           CMP      R7,R0
   \   00000338   EAFFFFBA           BLT      ??start_pass_huff_decoder_24
   \                     ??start_pass_huff_decoder_23:
   \   0000033C   641194E5           LDR      R1,[R4, #+356]
   \   00000340   0000A0E3           MOV      R0,#+0
   \   00000344   010051E3           CMP      R1,#+1
   \   00000348   020000AA           BGE      ??start_pass_huff_decoder_25
   \   0000034C   ABFFFFEA           B        ??start_pass_huff_decoder_18
   \                     ??start_pass_huff_decoder_26:
   \   00000350   B06083E5           STR      R6,[R3, #+176]
   \                     ??start_pass_huff_decoder_27:
   \   00000354   010080E2           ADD      R0,R0,#+1
   \                     ??start_pass_huff_decoder_25:
   \   00000358   641194E5           LDR      R1,[R4, #+356]
   \   0000035C   010050E1           CMP      R0,R1
   \   00000360   A6FFFFAA           BGE      ??start_pass_huff_decoder_18
   \   00000364   001184E0           ADD      R1,R4,R0, LSL #+2
   \   00000368   681191E5           LDR      R1,[R1, #+360]
   \   0000036C   003185E0           ADD      R3,R5,R0, LSL #+2
   \   00000370   011184E0           ADD      R1,R4,R1, LSL #+2
   \   00000374   4C1191E5           LDR      R1,[R1, #+332]
   \   00000378   142091E5           LDR      R2,[R1, #+20]
   \   0000037C   022185E0           ADD      R2,R5,R2, LSL #+2
   \   00000380   402092E5           LDR      R2,[R2, #+64]
   \   00000384   602083E5           STR      R2,[R3, #+96]
   \   00000388   182091E5           LDR      R2,[R1, #+24]
   \   0000038C   022185E0           ADD      R2,R5,R2, LSL #+2
   \   00000390   502092E5           LDR      R2,[R2, #+80]
   \   00000394   882083E5           STR      R2,[R3, #+136]
   \   00000398   342091E5           LDR      R2,[R1, #+52]
   \   0000039C   000052E3           CMP      R2,#+0
   \   000003A0   EAFFFF0A           BEQ      ??start_pass_huff_decoder_26
   \   000003A4   287091E5           LDR      R7,[R1, #+40]
   \   000003A8   010057E3           CMP      R7,#+1
   \   000003AC   010000BA           BLT      ??start_pass_huff_decoder_28
   \   000003B0   090057E3           CMP      R7,#+9
   \   000003B4   000000BA           BLT      ??start_pass_huff_decoder_29
   \                     ??start_pass_huff_decoder_28:
   \   000003B8   0870A0E3           MOV      R7,#+8
   \                     ??start_pass_huff_decoder_29:
   \   000003BC   242091E5           LDR      R2,[R1, #+36]
   \   000003C0   010052E3           CMP      R2,#+1
   \   000003C4   010000BA           BLT      ??start_pass_huff_decoder_30
   \   000003C8   090052E3           CMP      R2,#+9
   \   000003CC   000000BA           BLT      ??start_pass_huff_decoder_31
   \                     ??start_pass_huff_decoder_30:
   \   000003D0   0820A0E3           MOV      R2,#+8
   \                     ??start_pass_huff_decoder_31:
   \   000003D4   011042E2           SUB      R1,R2,#+1
   \   000003D8   28209FE5           LDR      R2,??start_pass_huff_decoder_9+0x14  ;; jpeg_zigzag_order
   \   000003DC   011182E0           ADD      R1,R2,R1, LSL #+2
   \   000003E0   871281E0           ADD      R1,R1,R7, LSL #+5
   \   000003E4   201011E5           LDR      R1,[R1, #-32]
   \   000003E8   011081E2           ADD      R1,R1,#+1
   \   000003EC   B01083E5           STR      R1,[R3, #+176]
   \   000003F0   D7FFFFEA           B        ??start_pass_huff_decoder_27
   \                     ??start_pass_huff_decoder_9:
   \   000003F4   ........           DC32     decode_mcu_AC_first
   \   000003F8   ........           DC32     decode_mcu_DC_first
   \   000003FC   ........           DC32     decode_mcu_DC_refine
   \   00000400   ........           DC32     decode_mcu_AC_refine
   \   00000404   ........           DC32     decode_mcu
   \   00000408   ........           DC32     jpeg_zigzag_order
   1270          
   1271          
   1272          /*
   1273           * Module initialization routine for Huffman entropy decoding.
   1274           */
   1275          

   \                                 In segment CODE, align 4, keep-with-next
   1276          GLOBAL(void)
   1277          jinit_huff_decoder (j_decompress_ptr cinfo)
   1278          {
   \                     jinit_huff_decoder:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1279            huff_entropy_ptr entropy;
   1280            int i;
   1281          
   1282            entropy = (huff_entropy_ptr)
   1283              (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
   1284          				SIZEOF(huff_entropy_decoder));
   \   00000008   043094E5           LDR      R3,[R4, #+4]
   \   0000000C   D820A0E3           MOV      R2,#+216
   \   00000010   003093E5           LDR      R3,[R3, #+0]
   \   00000014   0110A0E3           MOV      R1,#+1
   \   00000018   33FF2FE1           BLX      R3
   \   0000001C   0050A0E1           MOV      R5,R0
   1285            cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
   1286            entropy->pub.start_pass = start_pass_huff_decoder;
   \   00000020   AC009FE5           LDR      R0,??jinit_huff_decoder_0  ;; start_pass_huff_decoder
   \   00000024   BC5184E5           STR      R5,[R4, #+444]
   \   00000028   000085E5           STR      R0,[R5, #+0]
   1287          
   1288            if (cinfo->progressive_mode) {
   \   0000002C   D80094E5           LDR      R0,[R4, #+216]
   \   00000030   0060A0E3           MOV      R6,#+0
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   1D00000A           BEQ      ??jinit_huff_decoder_1
   1289              /* Create progression status table */
   1290              int *coef_bit_ptr, ci;
   1291              cinfo->coef_bits = (int (*)[DCTSIZE2])
   1292                (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
   1293          				  cinfo->num_components*DCTSIZE2*SIZEOF(int));
   \   0000003C   240094E5           LDR      R0,[R4, #+36]
   \   00000040   043094E5           LDR      R3,[R4, #+4]
   \   00000044   0024A0E1           LSL      R2,R0,#+8
   \   00000048   003093E5           LDR      R3,[R3, #+0]
   \   0000004C   0110A0E3           MOV      R1,#+1
   \   00000050   0400A0E1           MOV      R0,R4
   \   00000054   33FF2FE1           BLX      R3
   \   00000058   9C0084E5           STR      R0,[R4, #+156]
   1294              coef_bit_ptr = & cinfo->coef_bits[0][0];
   1295              for (ci = 0; ci < cinfo->num_components; ci++)
   \   0000005C   242094E5           LDR      R2,[R4, #+36]
   \   00000060   0010A0E3           MOV      R1,#+0
   \   00000064   010052E3           CMP      R2,#+1
   \   00000068   0130E0E1           MVN      R3,R1
   \   0000006C   060000AA           BGE      ??jinit_huff_decoder_2
   \   00000070   080000EA           B        ??jinit_huff_decoder_3
   1296                for (i = 0; i < DCTSIZE2; i++)
   \                     ??jinit_huff_decoder_4:
   \   00000074   0020A0E3           MOV      R2,#+0
   1297          	*coef_bit_ptr++ = -1;
   \                     ??jinit_huff_decoder_5:
   \   00000078   ........           STR      R3,[R0], #+4
   \   0000007C   012082E2           ADD      R2,R2,#+1
   \   00000080   400052E3           CMP      R2,#+64
   \   00000084   FBFFFFBA           BLT      ??jinit_huff_decoder_5
   \   00000088   011081E2           ADD      R1,R1,#+1
   \                     ??jinit_huff_decoder_2:
   \   0000008C   242094E5           LDR      R2,[R4, #+36]
   \   00000090   020051E1           CMP      R1,R2
   \   00000094   F6FFFFBA           BLT      ??jinit_huff_decoder_4
   1298          
   1299              /* Mark derived tables unallocated */
   1300              for (i = 0; i < NUM_HUFF_TBLS; i++) {
   \                     ??jinit_huff_decoder_3:
   \   00000098   0000A0E3           MOV      R0,#+0
   1301                entropy->derived_tbls[i] = NULL;
   \                     ??jinit_huff_decoder_6:
   \   0000009C   001185E0           ADD      R1,R5,R0, LSL #+2
   \   000000A0   2C6081E5           STR      R6,[R1, #+44]
   1302              }
   \   000000A4   010080E2           ADD      R0,R0,#+1
   \   000000A8   040050E3           CMP      R0,#+4
   \   000000AC   7080BDA8           POPGE    {R4-R6,PC}
   \   000000B0   F9FFFFEA           B        ??jinit_huff_decoder_6
   1303            } else {
   1304              /* Mark tables unallocated */
   1305              for (i = 0; i < NUM_HUFF_TBLS; i++) {
   1306                entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
   \                     ??jinit_huff_decoder_1:
   \   000000B4   001185E0           ADD      R1,R5,R0, LSL #+2
   \   000000B8   506081E5           STR      R6,[R1, #+80]
   \   000000BC   0020A0E3           MOV      R2,#+0
   \   000000C0   402081E5           STR      R2,[R1, #+64]
   1307              }
   \   000000C4   010080E2           ADD      R0,R0,#+1
   \   000000C8   040050E3           CMP      R0,#+4
   \   000000CC   F8FFFFBA           BLT      ??jinit_huff_decoder_1
   1308            }
   1309          }
   \   000000D0   7080BDE8           POP      {R4-R6,PC}       ;; return
   \                     ??jinit_huff_decoder_0:
   \   000000D4   ........           DC32     start_pass_huff_decoder

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   ........           DC32     bmask

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   ........           DC32     jpeg_natural_order

   Maximum stack usage in bytes:

     Function                CSTACK
     --------                ------
     decode_mcu                 88
     decode_mcu_AC_first        72
     decode_mcu_AC_refine      344
     decode_mcu_DC_first        80
     decode_mcu_DC_refine       48
     jinit_huff_decoder         16
     jpeg_fill_bit_buffer       32
     jpeg_huff_decode           20
     jpeg_make_d_derived_tbl  1332
     process_restart            16
     start_pass_huff_decoder    36


   Segment part sizes:

     Function/Label          Bytes
     --------------          -----
     jpeg_zigzag_order        256
     jpeg_make_d_derived_tbl  780
     jpeg_fill_bit_buffer     308
     bmask                     64
     jpeg_huff_decode         240
     process_restart          148
     decode_mcu_DC_first      516
     decode_mcu_AC_first      588
     decode_mcu_DC_refine     252
     decode_mcu_AC_refine    1092
     decode_mcu              1064
     start_pass_huff_decoder 1036
     jinit_huff_decoder       216
     ??DataTable8               4
     ??DataTable9               4
      Others                   44

 
 6 292 bytes in segment CODE
   320 bytes in segment DATA_C
 
 6 248 bytes of CODE  memory (+ 44 bytes shared)
   320 bytes of CONST memory

Errors: none
Warnings: 1
