##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    19/Jan/2011  13:20:57 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\grabber\jpeg-7\jcsample.c                     #
#    Command line    =  C:\arm\grabber\jpeg-7\jcsample.c -lC                 #
#                       C:\arm\grabber\Release_SGOLD\List\ -o                #
#                       C:\arm\grabber\Release_SGOLD\Obj\ -s9 --no_unroll    #
#                       --no_clustering --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --fpu None --dlib_config "C:\arm2\Embedded           #
#                       Workbench 4.0 Evaluation\ARM\LIB\dl5tpainl8n.h" -I   #
#                       "C:\arm2\Embedded Workbench 4.0                      #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  C:\arm\grabber\Release_SGOLD\List\jcsample.lst       #
#    Object file     =  C:\arm\grabber\Release_SGOLD\Obj\jcsample.r79        #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\grabber\jpeg-7\jcsample.c
      1          /*
                  ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           * jcsample.c
      3           *
      4           * Copyright (C) 1991-1996, Thomas G. Lane.
      5           * This file is part of the Independent JPEG Group's software.
      6           * For conditions of distribution and use, see the accompanying README file.
      7           *
      8           * This file contains downsampling routines.
      9           *
     10           * Downsampling input data is counted in "row groups".  A row group
     11           * is defined to be max_v_samp_factor pixel rows of each component,
     12           * from which the downsampler produces v_samp_factor sample rows.
     13           * A single row group is processed in each call to the downsampler module.
     14           *
     15           * The downsampler is responsible for edge-expansion of its output data
     16           * to fill an integral number of DCT blocks horizontally.  The source buffer
     17           * may be modified if it is helpful for this purpose (the source buffer is
     18           * allocated wide enough to correspond to the desired output width).
     19           * The caller (the prep controller) is responsible for vertical padding.
     20           *
     21           * The downsampler may request "context rows" by setting need_context_rows
     22           * during startup.  In this case, the input arrays will contain at least
     23           * one row group's worth of pixels above and below the passed-in data;
     24           * the caller will create dummy rows at image top and bottom by replicating
     25           * the first or last real pixel row.
     26           *
     27           * An excellent reference for image resampling is
     28           *   Digital Image Warping, George Wolberg, 1990.
     29           *   Pub. by IEEE Computer Society Press, Los Alamitos, CA. ISBN 0-8186-8944-7.
     30           *
     31           * The downsampling algorithm used here is a simple average of the source
     32           * pixels covered by the output pixel.  The hi-falutin sampling literature
     33           * refers to this as a "box filter".  In general the characteristics of a box
     34           * filter are not very good, but for the specific cases we normally use (1:1
     35           * and 2:1 ratios) the box is equivalent to a "triangle filter" which is not
     36           * nearly so bad.  If you intend to use other sampling ratios, you'd be well
     37           * advised to improve this code.
     38           *
     39           * A simple input-smoothing capability is provided.  This is mainly intended
     40           * for cleaning up color-dithered GIF input files (if you find it inadequate,
     41           * we suggest using an external filtering program such as pnmconvol).  When
     42           * enabled, each input pixel P is replaced by a weighted sum of itself and its
     43           * eight neighbors.  P's weight is 1-8*SF and each neighbor's weight is SF,
     44           * where SF = (smoothing_factor / 1024).
     45           * Currently, smoothing is only supported for 2h2v sampling factors.
     46           */
     47          
     48          #define JPEG_INTERNALS
     49          #include "jinclude.h"
     50          #include "jpeglib.h"
     51          
     52          
     53          /* Pointer to routine to downsample a single component */
     54          typedef JMETHOD(void, downsample1_ptr,
     55          		(j_compress_ptr cinfo, jpeg_component_info * compptr,
     56          		 JSAMPARRAY input_data, JSAMPARRAY output_data));
     57          
     58          /* Private subobject */
     59          
     60          typedef struct {
     61            struct jpeg_downsampler pub;	/* public fields */
     62          
     63            /* Downsampling method pointers, one per component */
     64            downsample1_ptr methods[MAX_COMPONENTS];
     65          
     66            /* Height of an output row group for each component. */
     67            int rowgroup_height[MAX_COMPONENTS];
     68          
     69            /* These arrays save pixel expansion factors so that int_downsample need not
     70             * recompute them each time.  They are unused for other downsampling methods.
     71             */
     72            UINT8 h_expand[MAX_COMPONENTS];
     73            UINT8 v_expand[MAX_COMPONENTS];
     74          } my_downsampler;
     75          
     76          typedef my_downsampler * my_downsample_ptr;
     77          
     78          
     79          /*
     80           * Initialize for a downsampling pass.
     81           */
     82          

   \                                 In segment CODE, align 4, keep-with-next
     83          METHODDEF(void)
     84          start_pass_downsample (j_compress_ptr cinfo)
     85          {
     86            /* no work for now */
     87          }
   \                     start_pass_downsample:
   \   00000000   1EFF2FE1           BX       LR               ;; return
     88          
     89          
     90          /*
     91           * Expand a component horizontally from width input_cols to width output_cols,
     92           * by duplicating the rightmost samples.
     93           */
     94          

   \                                 In segment CODE, align 4, keep-with-next
     95          LOCAL(void)
     96          expand_right_edge (JSAMPARRAY image_data, int num_rows,
     97          		   JDIMENSION input_cols, JDIMENSION output_cols)
     98          {
   \                     expand_right_edge:
   \   00000000   70002DE9           PUSH     {R4-R6}
     99            register JSAMPROW ptr;
    100            register JSAMPLE pixval;
    101            register int count;
    102            int row;
    103            int numcols = (int) (output_cols - input_cols);
   \   00000004   023043E0           SUB      R3,R3,R2
    104          
    105            if (numcols > 0) {
   \   00000008   010053E3           CMP      R3,#+1
   \   0000000C   0E0000BA           BLT      ??expand_right_edge_0
    106              for (row = 0; row < num_rows; row++) {
   \   00000010   00C0A0E3           MOV      R12,#+0
   \   00000014   010051E3           CMP      R1,#+1
   \   00000018   090000AA           BGE      ??expand_right_edge_1
   \   0000001C   0A0000EA           B        ??expand_right_edge_0
    107                ptr = image_data[row] + input_cols;
   \                     ??expand_right_edge_2:
   \   00000020   0C4190E7           LDR      R4,[R0, +R12, LSL #+2]
    108                pixval = ptr[-1];		/* don't need GETJSAMPLE() here */
    109                for (count = numcols; count > 0; count--)
   \   00000024   0360A0E1           MOV      R6,R3
   \   00000028   044082E0           ADD      R4,R2,R4
   \   0000002C   015054E5           LDRB     R5,[R4, #-1]
    110          	*ptr++ = pixval;
   \                     ??expand_right_edge_3:
   \   00000030   016046E2           SUB      R6,R6,#+1
   \   00000034   ........           STRB     R5,[R4], #+1
   \   00000038   010056E3           CMP      R6,#+1
   \   0000003C   FBFFFFAA           BGE      ??expand_right_edge_3
    111              }
   \   00000040   01C08CE2           ADD      R12,R12,#+1
   \                     ??expand_right_edge_1:
   \   00000044   01005CE1           CMP      R12,R1
   \   00000048   F4FFFFBA           BLT      ??expand_right_edge_2
    112            }
    113          }
   \                     ??expand_right_edge_0:
   \   0000004C   7000BDE8           POP      {R4-R6}
   \   00000050   1EFF2FE1           BX       LR               ;; return
    114          
    115          
    116          /*
    117           * Do downsampling for a whole row group (all components).
    118           *
    119           * In this version we simply downsample each component independently.
    120           */
    121          

   \                                 In segment CODE, align 4, keep-with-next
    122          METHODDEF(void)
    123          sep_downsample (j_compress_ptr cinfo,
    124          		JSAMPIMAGE input_buf, JDIMENSION in_row_index,
    125          		JSAMPIMAGE output_buf, JDIMENSION out_row_group_index)
    126          {
   \                     sep_downsample:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   24809DE5           LDR      R8,[SP, #+36]
   \   00000008   0040A0E1           MOV      R4,R0
    127            my_downsample_ptr downsample = (my_downsample_ptr) cinfo->downsample;
    128            int ci;
    129            jpeg_component_info * compptr;
    130            JSAMPARRAY in_ptr, out_ptr;
    131          
    132            for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
   \   0000000C   480094E5           LDR      R0,[R4, #+72]
   \   00000010   8C9194E5           LDR      R9,[R4, #+396]
   \   00000014   50B094E5           LDR      R11,[R4, #+80]
   \   00000018   0150A0E1           MOV      R5,R1
   \   0000001C   0260A0E1           MOV      R6,R2
   \   00000020   0370A0E1           MOV      R7,R3
   \   00000024   00A0A0E3           MOV      R10,#+0
   \   00000028   010050E3           CMP      R0,#+1
   \   0000002C   0D0000AA           BGE      ??sep_downsample_0
   \   00000030   F08FBDE8           POP      {R4-R11,PC}
    133                 ci++, compptr++) {
    134              in_ptr = input_buf[ci] + in_row_index;
    135              out_ptr = output_buf[ci] +
    136          	      (out_row_group_index * downsample->rowgroup_height[ci]);
    137              (*downsample->methods[ci]) (cinfo, compptr, in_ptr, out_ptr);
   \                     ??sep_downsample_1:
   \   00000034   0AC189E0           ADD      R12,R9,R10, LSL #+2
   \   00000038   34009CE5           LDR      R0,[R12, #+52]
   \   0000003C   0CC09CE5           LDR      R12,[R12, #+12]
   \   00000040   900801E0           MUL      R1,R0,R8
   \   00000044   0A0197E7           LDR      R0,[R7, +R10, LSL #+2]
   \   00000048   013180E0           ADD      R3,R0,R1, LSL #+2
   \   0000004C   0A0195E7           LDR      R0,[R5, +R10, LSL #+2]
   \   00000050   0B10A0E1           MOV      R1,R11
   \   00000054   062180E0           ADD      R2,R0,R6, LSL #+2
   \   00000058   0400A0E1           MOV      R0,R4
   \   0000005C   3CFF2FE1           BLX      R12
    138            }
   \   00000060   01A08AE2           ADD      R10,R10,#+1
   \   00000064   58B08BE2           ADD      R11,R11,#+88
   \                     ??sep_downsample_0:
   \   00000068   480094E5           LDR      R0,[R4, #+72]
   \   0000006C   00005AE1           CMP      R10,R0
   \   00000070   EFFFFFBA           BLT      ??sep_downsample_1
    139          }
   \   00000074   F08FBDE8           POP      {R4-R11,PC}      ;; return
    140          
    141          
    142          /*
    143           * Downsample pixel values of a single component.
    144           * One row group is processed per call.
    145           * This version handles arbitrary integral sampling ratios, without smoothing.
    146           * Note that this version is not actually used for customary sampling ratios.
    147           */
    148          

   \                                 In segment CODE, align 4, keep-with-next
    149          METHODDEF(void)
    150          int_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
    151          		JSAMPARRAY input_data, JSAMPARRAY output_data)
    152          {
   \                     int_downsample:
   \   00000000   F94F2DE9           PUSH     {R0,R3-R11,LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
    153            my_downsample_ptr downsample = (my_downsample_ptr) cinfo->downsample;
   \   00000008   8C0190E5           LDR      R0,[R0, #+396]
    154            int inrow, outrow, h_expand, v_expand, numpix, numpix2, h, v;
    155            JDIMENSION outcol, outcol_h;	/* outcol_h == outcol*h_expand */
    156            JDIMENSION output_cols = compptr->width_in_blocks * compptr->DCT_h_scaled_size;
   \   0000000C   243091E5           LDR      R3,[R1, #+36]
   \   00000010   0240A0E1           MOV      R4,R2
   \   00000014   1C2091E5           LDR      R2,[R1, #+28]
    157            JSAMPROW inptr, outptr;
    158            INT32 outvalue;
    159          
    160            h_expand = downsample->h_expand[compptr->component_index];
   \   00000018   041091E5           LDR      R1,[R1, #+4]
   \   0000001C   930205E0           MUL      R5,R3,R2
   \   00000020   000081E0           ADD      R0,R1,R0
   \   00000024   5C60D0E5           LDRB     R6,[R0, #+92]
    161            v_expand = downsample->v_expand[compptr->component_index];
   \   00000028   6670D0E5           LDRB     R7,[R0, #+102]
    162            numpix = h_expand * v_expand;
    163            numpix2 = numpix/2;
    164          
    165            /* Expand input data enough to let all the output samples be generated
    166             * by the standard loop.  Special-casing padded output would be more
    167             * efficient.
    168             */
    169            expand_right_edge(input_data, cinfo->max_v_samp_factor,
    170          		    cinfo->image_width, output_cols * h_expand);
   \   0000002C   08009DE5           LDR      R0,[SP, #+8]
   \   00000030   960503E0           MUL      R3,R6,R5
   \   00000034   970601E0           MUL      R1,R7,R6
    171          
    172            inrow = outrow = 0;
   \   00000038   0090A0E3           MOV      R9,#+0
   \   0000003C   00108DE5           STR      R1,[SP, #+0]
   \   00000040   A11F81E0           ADD      R1,R1,R1, LSR #+31
   \   00000044   C110A0E1           ASR      R1,R1,#+1
   \   00000048   04108DE5           STR      R1,[SP, #+4]
   \   0000004C   1C2090E5           LDR      R2,[R0, #+28]
   \   00000050   0C1190E5           LDR      R1,[R0, #+268]
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   ........           BL       expand_right_edge
   \   0000005C   08009DE5           LDR      R0,[SP, #+8]
   \   00000060   0080A0E3           MOV      R8,#+0
   \   00000064   0C0190E5           LDR      R0,[R0, #+268]
   \   00000068   010050E3           CMP      R0,#+1
   \   0000006C   020000AA           BGE      ??int_downsample_0
    173            while (inrow < cinfo->max_v_samp_factor) {
    174              outptr = output_data[outrow];
    175              for (outcol = 0, outcol_h = 0; outcol < output_cols;
    176          	 outcol++, outcol_h += h_expand) {
    177                outvalue = 0;
    178                for (v = 0; v < v_expand; v++) {
    179          	inptr = input_data[inrow+v] + outcol_h;
    180          	for (h = 0; h < h_expand; h++) {
    181          	  outvalue += (INT32) GETJSAMPLE(*inptr++);
    182          	}
    183                }
    184                *outptr++ = (JSAMPLE) ((outvalue + numpix2) / numpix);
    185              }
    186              inrow += v_expand;
    187              outrow++;
    188            }
    189          }
   \   00000070   FF8FBDE8           POP      {R0-R11,PC}      ;; return
   \                     ??int_downsample_1:
   \   00000074   088087E0           ADD      R8,R7,R8
   \   00000078   019089E2           ADD      R9,R9,#+1
   \                     ??int_downsample_0:
   \   0000007C   08009DE5           LDR      R0,[SP, #+8]
   \   00000080   0C0190E5           LDR      R0,[R0, #+268]
   \   00000084   000058E1           CMP      R8,R0
   \   00000088   FF8FBDA8           POPGE    {R0-R11,PC}
   \   0000008C   0C009DE5           LDR      R0,[SP, #+12]
   \   00000090   0020A0E3           MOV      R2,#+0
   \   00000094   09A190E7           LDR      R10,[R0, +R9, LSL #+2]
   \   00000098   0030A0E3           MOV      R3,#+0
   \   0000009C   000055E3           CMP      R5,#+0
   \   000000A0   0700001A           BNE      ??int_downsample_2
   \   000000A4   F2FFFFEA           B        ??int_downsample_1
   \                     ??int_downsample_3:
   \   000000A8   04109DE5           LDR      R1,[SP, #+4]
   \   000000AC   012082E2           ADD      R2,R2,#+1
   \   000000B0   000081E0           ADD      R0,R1,R0
   \   000000B4   00109DE5           LDR      R1,[SP, #+0]
   \   000000B8   033086E0           ADD      R3,R6,R3
   \   000000BC   ........           _BLF     ??div32_a,??rA??div32_a
   \   000000C0   ........           STRB     R1,[R10], #+1
   \                     ??int_downsample_2:
   \   000000C4   050052E1           CMP      R2,R5
   \   000000C8   E9FFFF2A           BCS      ??int_downsample_1
   \   000000CC   0000A0E3           MOV      R0,#+0
   \   000000D0   0010A0E3           MOV      R1,#+0
   \   000000D4   010057E3           CMP      R7,#+1
   \   000000D8   060000AA           BGE      ??int_downsample_4
   \   000000DC   F1FFFFEA           B        ??int_downsample_3
   \                     ??int_downsample_5:
   \   000000E0   ........           LDRB     R11,[R12], #+1
   \   000000E4   01E08EE2           ADD      LR,LR,#+1
   \   000000E8   00008BE0           ADD      R0,R11,R0
   \                     ??int_downsample_6:
   \   000000EC   06005EE1           CMP      LR,R6
   \   000000F0   FAFFFFBA           BLT      ??int_downsample_5
   \                     ??int_downsample_7:
   \   000000F4   011081E2           ADD      R1,R1,#+1
   \                     ??int_downsample_4:
   \   000000F8   070051E1           CMP      R1,R7
   \   000000FC   E9FFFFAA           BGE      ??int_downsample_3
   \   00000100   08B081E0           ADD      R11,R1,R8
   \   00000104   0BB194E7           LDR      R11,[R4, +R11, LSL #+2]
   \   00000108   00E0A0E3           MOV      LR,#+0
   \   0000010C   0BC083E0           ADD      R12,R3,R11
   \   00000110   010056E3           CMP      R6,#+1
   \   00000114   F4FFFFAA           BGE      ??int_downsample_6
   \   00000118   F5FFFFEA           B        ??int_downsample_7
    190          
    191          
    192          /*
    193           * Downsample pixel values of a single component.
    194           * This version handles the special case of a full-size component,
    195           * without smoothing.
    196           */
    197          

   \                                 In segment CODE, align 4, keep-with-next
    198          METHODDEF(void)
    199          fullsize_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
    200          		     JSAMPARRAY input_data, JSAMPARRAY output_data)
    201          {
   \                     fullsize_downsample:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    202            /* Copy the data */
    203            jcopy_sample_rows(input_data, 0, output_data, 0,
    204          		    cinfo->max_v_samp_factor, cinfo->image_width);
   \   0000000C   1C1094E5           LDR      R1,[R4, #+28]
   \   00000010   0200A0E1           MOV      R0,R2
   \   00000014   02002DE9           PUSH     {R1}
   \   00000018   0C1194E5           LDR      R1,[R4, #+268]
   \   0000001C   0360A0E1           MOV      R6,R3
   \   00000020   02002DE9           PUSH     {R1}
   \   00000024   0030A0E3           MOV      R3,#+0
   \   00000028   0620A0E1           MOV      R2,R6
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   ........           _BLF     jcopy_sample_rows,??jcopy_sample_rows??rA
    205            /* Edge-expand */
    206            expand_right_edge(output_data, cinfo->max_v_samp_factor, cinfo->image_width,
    207          		    compptr->width_in_blocks * compptr->DCT_h_scaled_size);
   \   00000034   1C0095E5           LDR      R0,[R5, #+28]
   \   00000038   241095E5           LDR      R1,[R5, #+36]
   \   0000003C   1C2094E5           LDR      R2,[R4, #+28]
   \   00000040   910003E0           MUL      R3,R1,R0
   \   00000044   0C1194E5           LDR      R1,[R4, #+268]
   \   00000048   0600A0E1           MOV      R0,R6
   \   0000004C   ........           BL       expand_right_edge
    208          }
   \   00000050   7380BDE8           POP      {R0,R1,R4-R6,PC}  ;; return
    209          
    210          
    211          /*
    212           * Downsample pixel values of a single component.
    213           * This version handles the common case of 2:1 horizontal and 1:1 vertical,
    214           * without smoothing.
    215           *
    216           * A note about the "bias" calculations: when rounding fractional values to
    217           * integer, we do not want to always round 0.5 up to the next integer.
    218           * If we did that, we'd introduce a noticeable bias towards larger values.
    219           * Instead, this code is arranged so that 0.5 will be rounded up or down at
    220           * alternate pixel locations (a simple ordered dither pattern).
    221           */
    222          

   \                                 In segment CODE, align 4, keep-with-next
    223          METHODDEF(void)
    224          h2v1_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
    225          		 JSAMPARRAY input_data, JSAMPARRAY output_data)
    226          {
   \                     h2v1_downsample:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    227            int inrow;
    228            JDIMENSION outcol;
    229            JDIMENSION output_cols = compptr->width_in_blocks * compptr->DCT_h_scaled_size;
   \   00000008   1C0091E5           LDR      R0,[R1, #+28]
   \   0000000C   241091E5           LDR      R1,[R1, #+36]
   \   00000010   0250A0E1           MOV      R5,R2
    230            register JSAMPROW inptr, outptr;
    231            register int bias;
    232          
    233            /* Expand input data enough to let all the output samples be generated
    234             * by the standard loop.  Special-casing padded output would be more
    235             * efficient.
    236             */
    237            expand_right_edge(input_data, cinfo->max_v_samp_factor,
    238          		    cinfo->image_width, output_cols * 2);
   \   00000014   1C2094E5           LDR      R2,[R4, #+28]
   \   00000018   910007E0           MUL      R7,R1,R0
   \   0000001C   0C1194E5           LDR      R1,[R4, #+268]
   \   00000020   0360A0E1           MOV      R6,R3
   \   00000024   8730A0E1           LSL      R3,R7,#+1
   \   00000028   0500A0E1           MOV      R0,R5
   \   0000002C   ........           BL       expand_right_edge
    239          
    240            for (inrow = 0; inrow < cinfo->max_v_samp_factor; inrow++) {
   \   00000030   0C1194E5           LDR      R1,[R4, #+268]
   \   00000034   0000A0E3           MOV      R0,#+0
   \   00000038   010051E3           CMP      R1,#+1
   \   0000003C   0C0000AA           BGE      ??h2v1_downsample_0
    241              outptr = output_data[inrow];
    242              inptr = input_data[inrow];
    243              bias = 0;			/* bias = 0,1,0,1,... for successive samples */
    244              for (outcol = 0; outcol < output_cols; outcol++) {
    245                *outptr++ = (JSAMPLE) ((GETJSAMPLE(*inptr) + GETJSAMPLE(inptr[1])
    246          			      + bias) >> 1);
    247                bias ^= 1;		/* 0=>1, 1=>0 */
    248                inptr += 2;
    249              }
    250            }
    251          }
   \   00000040   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??h2v1_downsample_1:
   \   00000044   00E0D2E5           LDRB     LR,[R2, #+0]
   \   00000048   0180D2E5           LDRB     R8,[R2, #+1]
   \   0000004C   022082E2           ADD      R2,R2,#+2
   \   00000050   01C08CE2           ADD      R12,R12,#+1
   \   00000054   0E8088E0           ADD      R8,R8,LR
   \   00000058   088083E0           ADD      R8,R3,R8
   \   0000005C   C880A0E1           ASR      R8,R8,#+1
   \   00000060   ........           STRB     R8,[R1], #+1
   \   00000064   013023E2           EOR      R3,R3,#0x1
   \                     ??h2v1_downsample_2:
   \   00000068   07005CE1           CMP      R12,R7
   \   0000006C   F4FFFF3A           BCC      ??h2v1_downsample_1
   \                     ??h2v1_downsample_3:
   \   00000070   010080E2           ADD      R0,R0,#+1
   \                     ??h2v1_downsample_0:
   \   00000074   0C1194E5           LDR      R1,[R4, #+268]
   \   00000078   010050E1           CMP      R0,R1
   \   0000007C   F081BDA8           POPGE    {R4-R8,PC}
   \   00000080   001196E7           LDR      R1,[R6, +R0, LSL #+2]
   \   00000084   002195E7           LDR      R2,[R5, +R0, LSL #+2]
   \   00000088   0030A0E3           MOV      R3,#+0
   \   0000008C   00C0A0E3           MOV      R12,#+0
   \   00000090   000057E3           CMP      R7,#+0
   \   00000094   F3FFFF1A           BNE      ??h2v1_downsample_2
   \   00000098   F4FFFFEA           B        ??h2v1_downsample_3
    252          
    253          
    254          /*
    255           * Downsample pixel values of a single component.
    256           * This version handles the standard case of 2:1 horizontal and 2:1 vertical,
    257           * without smoothing.
    258           */
    259          

   \                                 In segment CODE, align 4, keep-with-next
    260          METHODDEF(void)
    261          h2v2_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
    262          		 JSAMPARRAY input_data, JSAMPARRAY output_data)
    263          {
   \                     h2v2_downsample:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    264            int inrow, outrow;
    265            JDIMENSION outcol;
    266            JDIMENSION output_cols = compptr->width_in_blocks * compptr->DCT_h_scaled_size;
   \   00000008   1C0091E5           LDR      R0,[R1, #+28]
   \   0000000C   241091E5           LDR      R1,[R1, #+36]
   \   00000010   0250A0E1           MOV      R5,R2
    267            register JSAMPROW inptr0, inptr1, outptr;
    268            register int bias;
    269          
    270            /* Expand input data enough to let all the output samples be generated
    271             * by the standard loop.  Special-casing padded output would be more
    272             * efficient.
    273             */
    274            expand_right_edge(input_data, cinfo->max_v_samp_factor,
    275          		    cinfo->image_width, output_cols * 2);
   \   00000014   1C2094E5           LDR      R2,[R4, #+28]
   \   00000018   910007E0           MUL      R7,R1,R0
   \   0000001C   0C1194E5           LDR      R1,[R4, #+268]
   \   00000020   0360A0E1           MOV      R6,R3
   \   00000024   8730A0E1           LSL      R3,R7,#+1
   \   00000028   0500A0E1           MOV      R0,R5
   \   0000002C   ........           BL       expand_right_edge
    276          
    277            inrow = outrow = 0;
   \   00000030   0C2194E5           LDR      R2,[R4, #+268]
   \   00000034   0000A0E3           MOV      R0,#+0
   \   00000038   0010A0E3           MOV      R1,#+0
   \   0000003C   010052E3           CMP      R2,#+1
   \   00000040   120000AA           BGE      ??h2v2_downsample_0
    278            while (inrow < cinfo->max_v_samp_factor) {
    279              outptr = output_data[outrow];
    280              inptr0 = input_data[inrow];
    281              inptr1 = input_data[inrow+1];
    282              bias = 1;			/* bias = 1,2,1,2,... for successive samples */
    283              for (outcol = 0; outcol < output_cols; outcol++) {
    284                *outptr++ = (JSAMPLE) ((GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[1]) +
    285          			      GETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[1])
    286          			      + bias) >> 2);
    287                bias ^= 3;		/* 1=>2, 2=>1 */
    288                inptr0 += 2; inptr1 += 2;
    289              }
    290              inrow += 2;
    291              outrow++;
    292            }
    293          }
   \   00000044   F087BDE8           POP      {R4-R10,PC}      ;; return
   \                     ??h2v2_downsample_1:
   \   00000048   0090D3E5           LDRB     R9,[R3, #+0]
   \   0000004C   01A0D3E5           LDRB     R10,[R3, #+1]
   \   00000050   023083E2           ADD      R3,R3,#+2
   \   00000054   018088E2           ADD      R8,R8,#+1
   \   00000058   09908AE0           ADD      R9,R10,R9
   \   0000005C   00A0DCE5           LDRB     R10,[R12, #+0]
   \   00000060   09908AE0           ADD      R9,R10,R9
   \   00000064   01A0DCE5           LDRB     R10,[R12, #+1]
   \   00000068   02C08CE2           ADD      R12,R12,#+2
   \   0000006C   09908AE0           ADD      R9,R10,R9
   \   00000070   09908EE0           ADD      R9,LR,R9
   \   00000074   4991A0E1           ASR      R9,R9,#+2
   \   00000078   ........           STRB     R9,[R2], #+1
   \   0000007C   03E02EE2           EOR      LR,LR,#0x3
   \                     ??h2v2_downsample_2:
   \   00000080   070058E1           CMP      R8,R7
   \   00000084   EFFFFF3A           BCC      ??h2v2_downsample_1
   \                     ??h2v2_downsample_3:
   \   00000088   021081E2           ADD      R1,R1,#+2
   \   0000008C   010080E2           ADD      R0,R0,#+1
   \                     ??h2v2_downsample_0:
   \   00000090   0C2194E5           LDR      R2,[R4, #+268]
   \   00000094   020051E1           CMP      R1,R2
   \   00000098   F087BDA8           POPGE    {R4-R10,PC}
   \   0000009C   002196E7           LDR      R2,[R6, +R0, LSL #+2]
   \   000000A0   018185E0           ADD      R8,R5,R1, LSL #+2
   \   000000A4   003098E5           LDR      R3,[R8, #+0]
   \   000000A8   04C098E5           LDR      R12,[R8, #+4]
   \   000000AC   01E0A0E3           MOV      LR,#+1
   \   000000B0   0080A0E3           MOV      R8,#+0
   \   000000B4   000057E3           CMP      R7,#+0
   \   000000B8   F0FFFF1A           BNE      ??h2v2_downsample_2
   \   000000BC   F1FFFFEA           B        ??h2v2_downsample_3
    294          
    295          
    296          #ifdef INPUT_SMOOTHING_SUPPORTED
    297          
    298          /*
    299           * Downsample pixel values of a single component.
    300           * This version handles the standard case of 2:1 horizontal and 2:1 vertical,
    301           * with smoothing.  One row of context is required.
    302           */
    303          

   \                                 In segment CODE, align 4, keep-with-next
    304          METHODDEF(void)
    305          h2v2_smooth_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
    306          			JSAMPARRAY input_data, JSAMPARRAY output_data)
    307          {
   \                     h2v2_smooth_downsample:
   \   00000000   FC4F2DE9           PUSH     {R2-R11,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
    308            int inrow, outrow;
    309            JDIMENSION colctr;
    310            JDIMENSION output_cols = compptr->width_in_blocks * compptr->DCT_h_scaled_size;
   \   00000008   1C2091E5           LDR      R2,[R1, #+28]
   \   0000000C   241091E5           LDR      R1,[R1, #+36]
   \   00000010   0040A0E1           MOV      R4,R0
   \   00000014   910202E0           MUL      R2,R1,R2
   \   00000018   00208DE5           STR      R2,[SP, #+0]
    311            register JSAMPROW inptr0, inptr1, above_ptr, below_ptr, outptr;
    312            INT32 membersum, neighsum, memberscale, neighscale;
    313          
    314            /* Expand input data enough to let all the output samples be generated
    315             * by the standard loop.  Special-casing padded output would be more
    316             * efficient.
    317             */
    318            expand_right_edge(input_data - 1, cinfo->max_v_samp_factor + 2,
    319          		    cinfo->image_width, output_cols * 2);
   \   0000001C   0C0194E5           LDR      R0,[R4, #+268]
   \   00000020   8230A0E1           LSL      R3,R2,#+1
   \   00000024   1C2094E5           LDR      R2,[R4, #+28]
   \   00000028   021080E2           ADD      R1,R0,#+2
   \   0000002C   04009DE5           LDR      R0,[SP, #+4]
   \   00000030   040040E2           SUB      R0,R0,#+4
   \   00000034   ........           BL       expand_right_edge
    320          
    321            /* We don't bother to form the individual "smoothed" input pixel values;
    322             * we can directly compute the output which is the average of the four
    323             * smoothed values.  Each of the four member pixels contributes a fraction
    324             * (1-8*SF) to its own smoothed image and a fraction SF to each of the three
    325             * other smoothed pixels, therefore a total fraction (1-5*SF)/4 to the final
    326             * output.  The four corner-adjacent neighbor pixels contribute a fraction
    327             * SF to just one smoothed pixel, or SF/4 to the final output; while the
    328             * eight edge-adjacent neighbors contribute SF to each of two smoothed
    329             * pixels, or SF/2 overall.  In order to use integer arithmetic, these
    330             * factors are scaled by 2^16 = 65536.
    331             * Also recall that SF = smoothing_factor / 1024.
    332             */
    333          
    334            memberscale = 16384 - cinfo->smoothing_factor * 80; /* scaled (1-5*SF)/4 */
   \   00000038   E01094E5           LDR      R1,[R4, #+224]
    335            neighscale = cinfo->smoothing_factor * 16; /* scaled SF/4 */
    336          
    337            inrow = outrow = 0;
   \   0000003C   0C5194E5           LDR      R5,[R4, #+268]
   \   00000040   5000A0E3           MOV      R0,#+80
   \   00000044   900102E0           MUL      R2,R0,R1
   \   00000048   0112A0E1           LSL      R1,R1,#+4
   \   0000004C   400C62E2           RSB      R0,R2,#+16384
   \   00000050   0020A0E3           MOV      R2,#+0
   \   00000054   0030A0E3           MOV      R3,#+0
   \   00000058   010055E3           CMP      R5,#+1
   \   0000005C   810000AA           BGE      ??h2v2_smooth_downsample_0
   \   00000060   F78FBDE8           POP      {R0-R2,R4-R11,PC}
    338            while (inrow < cinfo->max_v_samp_factor) {
    339              outptr = output_data[outrow];
   \                     ??h2v2_smooth_downsample_1:
   \   00000064   08509DE5           LDR      R5,[SP, #+8]
   \   00000068   02C195E7           LDR      R12,[R5, +R2, LSL #+2]
    340              inptr0 = input_data[inrow];
   \   0000006C   04509DE5           LDR      R5,[SP, #+4]
   \   00000070   036185E0           ADD      R6,R5,R3, LSL #+2
   \   00000074   00E096E5           LDR      LR,[R6, #+0]
    341              inptr1 = input_data[inrow+1];
   \   00000078   047086E2           ADD      R7,R6,#+4
    342              above_ptr = input_data[inrow-1];
   \   0000007C   046016E5           LDR      R6,[R6, #-4]
    343              below_ptr = input_data[inrow+2];
    344          
    345              /* Special case for first column: pretend column -1 is same as column 0 */
    346              membersum = GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[1]) +
    347          		GETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[1]);
    348              neighsum = GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[1]) +
    349          	       GETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[1]) +
    350          	       GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[2]) +
    351          	       GETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[2]);
    352              neighsum += neighsum;
    353              neighsum += GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[2]) +
    354          		GETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[2]);
    355              membersum = membersum * memberscale + neighsum * neighscale;
    356              *outptr++ = (JSAMPLE) ((membersum + 32768) >> 16);
   \   00000080   0080D6E5           LDRB     R8,[R6, #+0]
   \   00000084   0190D6E5           LDRB     R9,[R6, #+1]
   \   00000088   005097E5           LDR      R5,[R7, #+0]
   \   0000008C   047097E5           LDR      R7,[R7, #+4]
   \   00000090   01A0DEE5           LDRB     R10,[LR, #+1]
   \   00000094   088089E0           ADD      R8,R9,R8
   \   00000098   0090D7E5           LDRB     R9,[R7, #+0]
   \   0000009C   088089E0           ADD      R8,R9,R8
   \   000000A0   0190D7E5           LDRB     R9,[R7, #+1]
   \   000000A4   088089E0           ADD      R8,R9,R8
   \   000000A8   0090DEE5           LDRB     R9,[LR, #+0]
   \   000000AC   088089E0           ADD      R8,R9,R8
   \   000000B0   0290DEE5           LDRB     R9,[LR, #+2]
   \   000000B4   088089E0           ADD      R8,R9,R8
   \   000000B8   0090D5E5           LDRB     R9,[R5, #+0]
   \   000000BC   088089E0           ADD      R8,R9,R8
   \   000000C0   0290D5E5           LDRB     R9,[R5, #+2]
   \   000000C4   088089E0           ADD      R8,R9,R8
   \   000000C8   0090D6E5           LDRB     R9,[R6, #+0]
   \   000000CC   888089E0           ADD      R8,R9,R8, LSL #+1
   \   000000D0   0290D6E5           LDRB     R9,[R6, #+2]
    357              inptr0 += 2; inptr1 += 2; above_ptr += 2; below_ptr += 2;
   \   000000D4   026086E2           ADD      R6,R6,#+2
   \   000000D8   088089E0           ADD      R8,R9,R8
   \   000000DC   0090D7E5           LDRB     R9,[R7, #+0]
   \   000000E0   088089E0           ADD      R8,R9,R8
   \   000000E4   0290D7E5           LDRB     R9,[R7, #+2]
   \   000000E8   027087E2           ADD      R7,R7,#+2
   \   000000EC   088089E0           ADD      R8,R9,R8
   \   000000F0   0090DEE5           LDRB     R9,[LR, #+0]
   \   000000F4   02E08EE2           ADD      LR,LR,#+2
   \   000000F8   09908AE0           ADD      R9,R10,R9
   \   000000FC   00A0D5E5           LDRB     R10,[R5, #+0]
   \   00000100   09908AE0           ADD      R9,R10,R9
   \   00000104   01A0D5E5           LDRB     R10,[R5, #+1]
   \   00000108   025085E2           ADD      R5,R5,#+2
   \   0000010C   09908AE0           ADD      R9,R10,R9
   \   00000110   900909E0           MUL      R9,R0,R9
   \   00000114   919828E0           MLA      R8,R1,R8,R9
   \   00000118   808C88E2           ADD      R8,R8,#+32768
   \   0000011C   4888A0E1           ASR      R8,R8,#+16
   \   00000120   ........           STRB     R8,[R12], #+1
    358          
    359              for (colctr = output_cols - 2; colctr > 0; colctr--) {
   \   00000124   00809DE5           LDR      R8,[SP, #+0]
   \   00000128   028058E2           SUBS     R8,R8,#+2
   \   0000012C   2800000A           BEQ      ??h2v2_smooth_downsample_2
    360                /* sum of pixels directly mapped to this output element */
    361                membersum = GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[1]) +
    362          		  GETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[1]);
    363                /* sum of edge-neighbor pixels */
    364                neighsum = GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[1]) +
    365          		 GETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[1]) +
    366          		 GETJSAMPLE(inptr0[-1]) + GETJSAMPLE(inptr0[2]) +
    367          		 GETJSAMPLE(inptr1[-1]) + GETJSAMPLE(inptr1[2]);
    368                /* The edge-neighbors count twice as much as corner-neighbors */
    369                neighsum += neighsum;
    370                /* Add in the corner-neighbors */
    371                neighsum += GETJSAMPLE(above_ptr[-1]) + GETJSAMPLE(above_ptr[2]) +
    372          		  GETJSAMPLE(below_ptr[-1]) + GETJSAMPLE(below_ptr[2]);
    373                /* form final output scaled up by 2^16 */
    374                membersum = membersum * memberscale + neighsum * neighscale;
    375                /* round, descale and output it */
    376                *outptr++ = (JSAMPLE) ((membersum + 32768) >> 16);
   \                     ??h2v2_smooth_downsample_3:
   \   00000130   0090D6E5           LDRB     R9,[R6, #+0]
   \   00000134   01A0D6E5           LDRB     R10,[R6, #+1]
   \   00000138   01B0DEE5           LDRB     R11,[LR, #+1]
    377                inptr0 += 2; inptr1 += 2; above_ptr += 2; below_ptr += 2;
    378              }
   \   0000013C   018058E2           SUBS     R8,R8,#+1
   \   00000140   09908AE0           ADD      R9,R10,R9
   \   00000144   00A0D7E5           LDRB     R10,[R7, #+0]
   \   00000148   09908AE0           ADD      R9,R10,R9
   \   0000014C   01A0D7E5           LDRB     R10,[R7, #+1]
   \   00000150   09908AE0           ADD      R9,R10,R9
   \   00000154   01A05EE5           LDRB     R10,[LR, #-1]
   \   00000158   09908AE0           ADD      R9,R10,R9
   \   0000015C   02A0DEE5           LDRB     R10,[LR, #+2]
   \   00000160   09908AE0           ADD      R9,R10,R9
   \   00000164   01A055E5           LDRB     R10,[R5, #-1]
   \   00000168   09908AE0           ADD      R9,R10,R9
   \   0000016C   02A0D5E5           LDRB     R10,[R5, #+2]
   \   00000170   09908AE0           ADD      R9,R10,R9
   \   00000174   01A056E5           LDRB     R10,[R6, #-1]
   \   00000178   89908AE0           ADD      R9,R10,R9, LSL #+1
   \   0000017C   02A0D6E5           LDRB     R10,[R6, #+2]
   \   00000180   026086E2           ADD      R6,R6,#+2
   \   00000184   09908AE0           ADD      R9,R10,R9
   \   00000188   01A057E5           LDRB     R10,[R7, #-1]
   \   0000018C   09908AE0           ADD      R9,R10,R9
   \   00000190   02A0D7E5           LDRB     R10,[R7, #+2]
   \   00000194   027087E2           ADD      R7,R7,#+2
   \   00000198   09908AE0           ADD      R9,R10,R9
   \   0000019C   00A0DEE5           LDRB     R10,[LR, #+0]
   \   000001A0   02E08EE2           ADD      LR,LR,#+2
   \   000001A4   0AA08BE0           ADD      R10,R11,R10
   \   000001A8   00B0D5E5           LDRB     R11,[R5, #+0]
   \   000001AC   0AA08BE0           ADD      R10,R11,R10
   \   000001B0   01B0D5E5           LDRB     R11,[R5, #+1]
   \   000001B4   025085E2           ADD      R5,R5,#+2
   \   000001B8   0AA08BE0           ADD      R10,R11,R10
   \   000001BC   900A0AE0           MUL      R10,R0,R10
   \   000001C0   91A929E0           MLA      R9,R1,R9,R10
   \   000001C4   809C89E2           ADD      R9,R9,#+32768
   \   000001C8   4998A0E1           ASR      R9,R9,#+16
   \   000001CC   ........           STRB     R9,[R12], #+1
   \   000001D0   D6FFFF1A           BNE      ??h2v2_smooth_downsample_3
    379          
    380              /* Special case for last column */
    381              membersum = GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[1]) +
    382          		GETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[1]);
    383              neighsum = GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[1]) +
    384          	       GETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[1]) +
    385          	       GETJSAMPLE(inptr0[-1]) + GETJSAMPLE(inptr0[1]) +
    386          	       GETJSAMPLE(inptr1[-1]) + GETJSAMPLE(inptr1[1]);
    387              neighsum += neighsum;
    388              neighsum += GETJSAMPLE(above_ptr[-1]) + GETJSAMPLE(above_ptr[1]) +
    389          		GETJSAMPLE(below_ptr[-1]) + GETJSAMPLE(below_ptr[1]);
    390              membersum = membersum * memberscale + neighsum * neighscale;
    391              *outptr = (JSAMPLE) ((membersum + 32768) >> 16);
   \                     ??h2v2_smooth_downsample_2:
   \   000001D4   0080D6E5           LDRB     R8,[R6, #+0]
   \   000001D8   0190D6E5           LDRB     R9,[R6, #+1]
    392          
    393              inrow += 2;
   \   000001DC   023083E2           ADD      R3,R3,#+2
    394              outrow++;
   \   000001E0   012082E2           ADD      R2,R2,#+1
   \   000001E4   088089E0           ADD      R8,R9,R8
   \   000001E8   0090D7E5           LDRB     R9,[R7, #+0]
   \   000001EC   088089E0           ADD      R8,R9,R8
   \   000001F0   0190D7E5           LDRB     R9,[R7, #+1]
   \   000001F4   088089E0           ADD      R8,R9,R8
   \   000001F8   01905EE5           LDRB     R9,[LR, #-1]
   \   000001FC   088089E0           ADD      R8,R9,R8
   \   00000200   0190DEE5           LDRB     R9,[LR, #+1]
   \   00000204   088089E0           ADD      R8,R9,R8
   \   00000208   019055E5           LDRB     R9,[R5, #-1]
   \   0000020C   088089E0           ADD      R8,R9,R8
   \   00000210   0190D5E5           LDRB     R9,[R5, #+1]
   \   00000214   088089E0           ADD      R8,R9,R8
   \   00000218   019056E5           LDRB     R9,[R6, #-1]
   \   0000021C   0160D6E5           LDRB     R6,[R6, #+1]
   \   00000220   888089E0           ADD      R8,R9,R8, LSL #+1
   \   00000224   086086E0           ADD      R6,R6,R8
   \   00000228   018057E5           LDRB     R8,[R7, #-1]
   \   0000022C   0170D7E5           LDRB     R7,[R7, #+1]
   \   00000230   066088E0           ADD      R6,R8,R6
   \   00000234   0180DEE5           LDRB     R8,[LR, #+1]
   \   00000238   066087E0           ADD      R6,R7,R6
   \   0000023C   0070DEE5           LDRB     R7,[LR, #+0]
   \   00000240   077088E0           ADD      R7,R8,R7
   \   00000244   0080D5E5           LDRB     R8,[R5, #+0]
   \   00000248   0150D5E5           LDRB     R5,[R5, #+1]
   \   0000024C   077088E0           ADD      R7,R8,R7
   \   00000250   075085E0           ADD      R5,R5,R7
   \   00000254   900505E0           MUL      R5,R0,R5
   \   00000258   915625E0           MLA      R5,R1,R6,R5
   \   0000025C   805C85E2           ADD      R5,R5,#+32768
   \   00000260   4558A0E1           ASR      R5,R5,#+16
   \   00000264   0050CCE5           STRB     R5,[R12, #+0]
    395            }
   \                     ??h2v2_smooth_downsample_0:
   \   00000268   0C5194E5           LDR      R5,[R4, #+268]
   \   0000026C   050053E1           CMP      R3,R5
   \   00000270   7BFFFFBA           BLT      ??h2v2_smooth_downsample_1
    396          }
   \   00000274   F78FBDE8           POP      {R0-R2,R4-R11,PC}  ;; return
    397          
    398          
    399          /*
    400           * Downsample pixel values of a single component.
    401           * This version handles the special case of a full-size component,
    402           * with smoothing.  One row of context is required.
    403           */
    404          

   \                                 In segment CODE, align 4, keep-with-next
    405          METHODDEF(void)
    406          fullsize_smooth_downsample (j_compress_ptr cinfo, jpeg_component_info *compptr,
    407          			    JSAMPARRAY input_data, JSAMPARRAY output_data)
    408          {
   \                     fullsize_smooth_downsample:
   \   00000000   FC4F2DE9           PUSH     {R2-R11,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
    409            int inrow;
    410            JDIMENSION colctr;
    411            JDIMENSION output_cols = compptr->width_in_blocks * compptr->DCT_h_scaled_size;
   \   00000008   1C2091E5           LDR      R2,[R1, #+28]
   \   0000000C   241091E5           LDR      R1,[R1, #+36]
   \   00000010   0040A0E1           MOV      R4,R0
   \   00000014   910202E0           MUL      R2,R1,R2
   \   00000018   00208DE5           STR      R2,[SP, #+0]
    412            register JSAMPROW inptr, above_ptr, below_ptr, outptr;
    413            INT32 membersum, neighsum, memberscale, neighscale;
    414            int colsum, lastcolsum, nextcolsum;
    415          
    416            /* Expand input data enough to let all the output samples be generated
    417             * by the standard loop.  Special-casing padded output would be more
    418             * efficient.
    419             */
    420            expand_right_edge(input_data - 1, cinfo->max_v_samp_factor + 2,
    421          		    cinfo->image_width, output_cols);
   \   0000001C   0C0194E5           LDR      R0,[R4, #+268]
   \   00000020   0230A0E1           MOV      R3,R2
   \   00000024   1C2094E5           LDR      R2,[R4, #+28]
   \   00000028   021080E2           ADD      R1,R0,#+2
   \   0000002C   04009DE5           LDR      R0,[SP, #+4]
   \   00000030   040040E2           SUB      R0,R0,#+4
   \   00000034   ........           BL       expand_right_edge
    422          
    423            /* Each of the eight neighbor pixels contributes a fraction SF to the
    424             * smoothed pixel, while the main pixel contributes (1-8*SF).  In order
    425             * to use integer arithmetic, these factors are multiplied by 2^16 = 65536.
    426             * Also recall that SF = smoothing_factor / 1024.
    427             */
    428          
    429            memberscale = 65536L - cinfo->smoothing_factor * 512L; /* scaled 1-8*SF */
   \   00000038   E01094E5           LDR      R1,[R4, #+224]
    430            neighscale = cinfo->smoothing_factor * 64; /* scaled SF */
    431          
    432            for (inrow = 0; inrow < cinfo->max_v_samp_factor; inrow++) {
   \   0000003C   0C3194E5           LDR      R3,[R4, #+268]
   \   00000040   400BA0E3           MOV      R0,#+65536
   \   00000044   810440E0           SUB      R0,R0,R1, LSL #+9
   \   00000048   0113A0E1           LSL      R1,R1,#+6
   \   0000004C   0020A0E3           MOV      R2,#+0
   \   00000050   010053E3           CMP      R3,#+1
   \   00000054   380000AA           BGE      ??fullsize_smooth_downsample_0
   \   00000058   F78FBDE8           POP      {R0-R2,R4-R11,PC}
    433              outptr = output_data[inrow];
    434              inptr = input_data[inrow];
   \                     ??fullsize_smooth_downsample_1:
   \   0000005C   04509DE5           LDR      R5,[SP, #+4]
   \   00000060   08309DE5           LDR      R3,[SP, #+8]
   \   00000064   025185E0           ADD      R5,R5,R2, LSL #+2
   \   00000068   00C095E5           LDR      R12,[R5, #+0]
    435              above_ptr = input_data[inrow-1];
   \   0000006C   04E015E5           LDR      LR,[R5, #-4]
    436              below_ptr = input_data[inrow+1];
   \   00000070   045095E5           LDR      R5,[R5, #+4]
    437          
    438              /* Special case for first column */
    439              colsum = GETJSAMPLE(*above_ptr++) + GETJSAMPLE(*below_ptr++) +
    440          	     GETJSAMPLE(*inptr);
   \   00000074   ........           LDRB     R6,[LR], #+1
   \   00000078   ........           LDRB     R7,[R5], #+1
    441              membersum = GETJSAMPLE(*inptr++);
    442              nextcolsum = GETJSAMPLE(*above_ptr) + GETJSAMPLE(*below_ptr) +
    443          		 GETJSAMPLE(*inptr);
   \   0000007C   0080DEE5           LDRB     R8,[LR, #+0]
   \   00000080   0090D5E5           LDRB     R9,[R5, #+0]
   \   00000084   023193E7           LDR      R3,[R3, +R2, LSL #+2]
   \   00000088   066087E0           ADD      R6,R7,R6
   \   0000008C   0070DCE5           LDRB     R7,[R12, #+0]
   \   00000090   088089E0           ADD      R8,R9,R8
   \   00000094   066087E0           ADD      R6,R7,R6
   \   00000098   ........           LDRB     R7,[R12], #+1
   \   0000009C   0090DCE5           LDRB     R9,[R12, #+0]
   \   000000A0   088089E0           ADD      R8,R9,R8
    444              neighsum = colsum + (colsum - membersum) + nextcolsum;
    445              membersum = membersum * memberscale + neighsum * neighscale;
    446              *outptr++ = (JSAMPLE) ((membersum + 32768) >> 16);
   \   000000A4   869067E0           RSB      R9,R7,R6, LSL #+1
   \   000000A8   099088E0           ADD      R9,R8,R9
   \   000000AC   900707E0           MUL      R7,R0,R7
   \   000000B0   917927E0           MLA      R7,R1,R9,R7
    447              lastcolsum = colsum; colsum = nextcolsum;
   \   000000B4   0890A0E1           MOV      R9,R8
   \   000000B8   807C87E2           ADD      R7,R7,#+32768
   \   000000BC   4778A0E1           ASR      R7,R7,#+16
   \   000000C0   ........           STRB     R7,[R3], #+1
    448          
    449              for (colctr = output_cols - 2; colctr > 0; colctr--) {
   \   000000C4   00709DE5           LDR      R7,[SP, #+0]
   \   000000C8   02A057E2           SUBS     R10,R7,#+2
   \   000000CC   1100000A           BEQ      ??fullsize_smooth_downsample_2
    450                membersum = GETJSAMPLE(*inptr++);
    451                above_ptr++; below_ptr++;
    452                nextcolsum = GETJSAMPLE(*above_ptr) + GETJSAMPLE(*below_ptr) +
    453          		   GETJSAMPLE(*inptr);
   \                     ??fullsize_smooth_downsample_3:
   \   000000D0   0180FEE5           LDRB     R8,[LR, #+1]!
   \   000000D4   01B0F5E5           LDRB     R11,[R5, #+1]!
   \   000000D8   ........           LDRB     R7,[R12], #+1
    454                neighsum = lastcolsum + (colsum - membersum) + nextcolsum;
    455                membersum = membersum * memberscale + neighsum * neighscale;
    456                *outptr++ = (JSAMPLE) ((membersum + 32768) >> 16);
   \   000000DC   066089E0           ADD      R6,R9,R6
   \   000000E0   08808BE0           ADD      R8,R11,R8
   \   000000E4   00B0DCE5           LDRB     R11,[R12, #+0]
   \   000000E8   076046E0           SUB      R6,R6,R7
   \   000000EC   900707E0           MUL      R7,R0,R7
   \   000000F0   08808BE0           ADD      R8,R11,R8
   \   000000F4   066088E0           ADD      R6,R8,R6
   \   000000F8   917626E0           MLA      R6,R1,R6,R7
    457                lastcolsum = colsum; colsum = nextcolsum;
    458              }
   \   000000FC   01A05AE2           SUBS     R10,R10,#+1
   \   00000100   806C86E2           ADD      R6,R6,#+32768
   \   00000104   4668A0E1           ASR      R6,R6,#+16
   \   00000108   ........           STRB     R6,[R3], #+1
   \   0000010C   0960A0E1           MOV      R6,R9
   \   00000110   0890A0E1           MOV      R9,R8
   \   00000114   EDFFFF1A           BNE      ??fullsize_smooth_downsample_3
    459          
    460              /* Special case for last column */
    461              membersum = GETJSAMPLE(*inptr);
   \                     ??fullsize_smooth_downsample_2:
   \   00000118   0050DCE5           LDRB     R5,[R12, #+0]
    462              neighsum = lastcolsum + (colsum - membersum) + colsum;
    463              membersum = membersum * memberscale + neighsum * neighscale;
    464              *outptr = (JSAMPLE) ((membersum + 32768) >> 16);
    465          
    466            }
   \   0000011C   012082E2           ADD      R2,R2,#+1
   \   00000120   056046E0           SUB      R6,R6,R5
   \   00000124   896086E0           ADD      R6,R6,R9, LSL #+1
   \   00000128   900505E0           MUL      R5,R0,R5
   \   0000012C   915625E0           MLA      R5,R1,R6,R5
   \   00000130   805C85E2           ADD      R5,R5,#+32768
   \   00000134   4558A0E1           ASR      R5,R5,#+16
   \   00000138   0050C3E5           STRB     R5,[R3, #+0]
   \                     ??fullsize_smooth_downsample_0:
   \   0000013C   0C3194E5           LDR      R3,[R4, #+268]
   \   00000140   030052E1           CMP      R2,R3
   \   00000144   C4FFFFBA           BLT      ??fullsize_smooth_downsample_1
    467          }
   \   00000148   F78FBDE8           POP      {R0-R2,R4-R11,PC}  ;; return
    468          
    469          #endif /* INPUT_SMOOTHING_SUPPORTED */
    470          
    471          
    472          /*
    473           * Module initialization routine for downsampling.
    474           * Note that we must select a routine for each component.
    475           */
    476          

   \                                 In segment CODE, align 4, keep-with-next
    477          GLOBAL(void)
    478          jinit_downsampler (j_compress_ptr cinfo)
    479          {
   \                     jinit_downsampler:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    480            my_downsample_ptr downsample;
    481            int ci;
    482            jpeg_component_info * compptr;
    483            boolean smoothok = TRUE;
    484            int h_in_group, v_in_group, h_out_group, v_out_group;
    485          
    486            downsample = (my_downsample_ptr)
    487              (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
    488          				SIZEOF(my_downsampler));
   \   00000008   043094E5           LDR      R3,[R4, #+4]
   \   0000000C   7020A0E3           MOV      R2,#+112
   \   00000010   003093E5           LDR      R3,[R3, #+0]
   \   00000014   0110A0E3           MOV      R1,#+1
   \   00000018   33FF2FE1           BLX      R3
   \   0000001C   0060A0E1           MOV      R6,R0
    489            cinfo->downsample = (struct jpeg_downsampler *) downsample;
    490            downsample->pub.start_pass = start_pass_downsample;
   \   00000020   CC019FE5           LDR      R0,??jinit_downsampler_0  ;; start_pass_downsample
   \   00000024   8C6184E5           STR      R6,[R4, #+396]
   \   00000028   000086E5           STR      R0,[R6, #+0]
    491            downsample->pub.downsample = sep_downsample;
   \   0000002C   C4019FE5           LDR      R0,??jinit_downsampler_0+0x4  ;; sep_downsample
   \   00000030   0150A0E3           MOV      R5,#+1
   \   00000034   040086E5           STR      R0,[R6, #+4]
    492            downsample->pub.need_context_rows = FALSE;
   \   00000038   0000A0E3           MOV      R0,#+0
   \   0000003C   080086E5           STR      R0,[R6, #+8]
    493          
    494            if (cinfo->CCIR601_sampling)
   \   00000040   D80094E5           LDR      R0,[R4, #+216]
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0600000A           BEQ      ??jinit_downsampler_1
    495              ERREXIT(cinfo, JERR_CCIR601_NOTIMPL);
   \   0000004C   000094E5           LDR      R0,[R4, #+0]
   \   00000050   1A10A0E3           MOV      R1,#+26
   \   00000054   141080E5           STR      R1,[R0, #+20]
   \   00000058   001094E5           LDR      R1,[R4, #+0]
   \   0000005C   0400A0E1           MOV      R0,R4
   \   00000060   001091E5           LDR      R1,[R1, #+0]
   \   00000064   31FF2FE1           BLX      R1
    496          
    497            /* Verify we can handle the sampling factors, and set up method pointers */
    498            for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
   \                     ??jinit_downsampler_1:
   \   00000068   480094E5           LDR      R0,[R4, #+72]
   \   0000006C   508094E5           LDR      R8,[R4, #+80]
   \   00000070   0070A0E3           MOV      R7,#+0
   \   00000074   010050E3           CMP      R0,#+1
   \   00000078   160000AA           BGE      ??jinit_downsampler_2
    499                 ci++, compptr++) {
    500              /* Compute size of an "output group" for DCT scaling.  This many samples
    501               * are to be converted from max_h_samp_factor * max_v_samp_factor pixels.
    502               */
    503              h_out_group = (compptr->h_samp_factor * compptr->DCT_h_scaled_size) /
    504          		  cinfo->min_DCT_h_scaled_size;
    505              v_out_group = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
    506          		  cinfo->min_DCT_v_scaled_size;
    507              h_in_group = cinfo->max_h_samp_factor;
    508              v_in_group = cinfo->max_v_samp_factor;
    509              downsample->rowgroup_height[ci] = v_out_group; /* save for use later */
    510              if (h_in_group == h_out_group && v_in_group == v_out_group) {
    511          #ifdef INPUT_SMOOTHING_SUPPORTED
    512                if (cinfo->smoothing_factor) {
    513          	downsample->methods[ci] = fullsize_smooth_downsample;
    514          	downsample->pub.need_context_rows = TRUE;
    515                } else
    516          #endif
    517          	downsample->methods[ci] = fullsize_downsample;
    518              } else if (h_in_group == h_out_group * 2 &&
    519          	       v_in_group == v_out_group) {
    520                smoothok = FALSE;
    521                downsample->methods[ci] = h2v1_downsample;
    522              } else if (h_in_group == h_out_group * 2 &&
    523          	       v_in_group == v_out_group * 2) {
    524          #ifdef INPUT_SMOOTHING_SUPPORTED
    525                if (cinfo->smoothing_factor) {
    526          	downsample->methods[ci] = h2v2_smooth_downsample;
    527          	downsample->pub.need_context_rows = TRUE;
    528                } else
    529          #endif
    530          	downsample->methods[ci] = h2v2_downsample;
    531              } else if ((h_in_group % h_out_group) == 0 &&
    532          	       (v_in_group % v_out_group) == 0) {
    533                smoothok = FALSE;
    534                downsample->methods[ci] = int_downsample;
    535                downsample->h_expand[ci] = (UINT8) (h_in_group / h_out_group);
    536                downsample->v_expand[ci] = (UINT8) (v_in_group / v_out_group);
    537              } else
    538                ERREXIT(cinfo, JERR_FRACT_SAMPLE_NOTIMPL);
    539            }
    540          
    541          #ifdef INPUT_SMOOTHING_SUPPORTED
    542            if (cinfo->smoothing_factor && !smoothok)
   \                     ??jinit_downsampler_3:
   \   0000007C   E00094E5           LDR      R0,[R4, #+224]
   \   00000080   000050E3           CMP      R0,#+0
   \   00000084   F08FBD08           POPEQ    {R4-R11,PC}
   \   00000088   000055E3           CMP      R5,#+0
   \   0000008C   F08FBD18           POPNE    {R4-R11,PC}
    543              TRACEMS(cinfo, 0, JTRC_SMOOTH_NOTIMPL);
   \   00000090   000094E5           LDR      R0,[R4, #+0]
   \   00000094   6510A0E3           MOV      R1,#+101
   \   00000098   141080E5           STR      R1,[R0, #+20]
   \   0000009C   002094E5           LDR      R2,[R4, #+0]
   \   000000A0   0010A0E3           MOV      R1,#+0
   \   000000A4   042092E5           LDR      R2,[R2, #+4]
   \   000000A8   0400A0E1           MOV      R0,R4
   \   000000AC   32FF2FE1           BLX      R2
    544          #endif
    545          }
   \   000000B0   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??jinit_downsampler_4:
   \   000000B4   000094E5           LDR      R0,[R4, #+0]
   \   000000B8   2710A0E3           MOV      R1,#+39
   \   000000BC   141080E5           STR      R1,[R0, #+20]
   \   000000C0   001094E5           LDR      R1,[R4, #+0]
   \   000000C4   0400A0E1           MOV      R0,R4
   \   000000C8   001091E5           LDR      R1,[R1, #+0]
   \   000000CC   31FF2FE1           BLX      R1
   \                     ??jinit_downsampler_5:
   \   000000D0   017087E2           ADD      R7,R7,#+1
   \   000000D4   588088E2           ADD      R8,R8,#+88
   \                     ??jinit_downsampler_2:
   \   000000D8   480094E5           LDR      R0,[R4, #+72]
   \   000000DC   000057E1           CMP      R7,R0
   \   000000E0   E5FFFFAA           BGE      ??jinit_downsampler_3
   \   000000E4   080098E5           LDR      R0,[R8, #+8]
   \   000000E8   241098E5           LDR      R1,[R8, #+36]
   \   000000EC   089194E5           LDR      R9,[R4, #+264]
   \   000000F0   0CA194E5           LDR      R10,[R4, #+268]
   \   000000F4   910000E0           MUL      R0,R1,R0
   \   000000F8   101194E5           LDR      R1,[R4, #+272]
   \   000000FC   07B186E0           ADD      R11,R6,R7, LSL #+2
   \   00000100   ........           _BLF     ??div32_a,??rA??div32_a
   \   00000104   0C0098E5           LDR      R0,[R8, #+12]
   \   00000108   0120A0E1           MOV      R2,R1
   \   0000010C   281098E5           LDR      R1,[R8, #+40]
   \   00000110   910000E0           MUL      R0,R1,R0
   \   00000114   141194E5           LDR      R1,[R4, #+276]
   \   00000118   ........           _BLF     ??div32_a,??rA??div32_a
   \   0000011C   0130A0E1           MOV      R3,R1
   \   00000120   34308BE5           STR      R3,[R11, #+52]
   \   00000124   0100A0E3           MOV      R0,#+1
   \   00000128   020059E1           CMP      R9,R2
   \   0000012C   03005A01           CMPEQ    R10,R3
   \   00000130   0900001A           BNE      ??jinit_downsampler_6
   \   00000134   E01094E5           LDR      R1,[R4, #+224]
   \   00000138   000051E3           CMP      R1,#+0
   \   0000013C   0300000A           BEQ      ??jinit_downsampler_7
   \   00000140   B4109FE5           LDR      R1,??jinit_downsampler_0+0x8  ;; fullsize_smooth_downsample
   \                     ??jinit_downsampler_8:
   \   00000144   0C108BE5           STR      R1,[R11, #+12]
   \   00000148   080086E5           STR      R0,[R6, #+8]
   \   0000014C   DFFFFFEA           B        ??jinit_downsampler_5
   \                     ??jinit_downsampler_7:
   \   00000150   A8009FE5           LDR      R0,??jinit_downsampler_0+0xC  ;; fullsize_downsample
   \                     ??jinit_downsampler_9:
   \   00000154   0C008BE5           STR      R0,[R11, #+12]
   \   00000158   DCFFFFEA           B        ??jinit_downsampler_5
   \                     ??jinit_downsampler_6:
   \   0000015C   820059E1           CMP      R9,R2, LSL #+1
   \   00000160   0B00001A           BNE      ??jinit_downsampler_10
   \   00000164   03005AE1           CMP      R10,R3
   \   00000168   94009F05           LDREQ    R0,??jinit_downsampler_0+0x10  ;; h2v1_downsample
   \   0000016C   0050A003           MOVEQ    R5,#+0
   \   00000170   F7FFFF0A           BEQ      ??jinit_downsampler_9
   \   00000174   83005AE1           CMP      R10,R3, LSL #+1
   \   00000178   0500001A           BNE      ??jinit_downsampler_10
   \   0000017C   E01094E5           LDR      R1,[R4, #+224]
   \   00000180   000051E3           CMP      R1,#+0
   \   00000184   7C109F15           LDRNE    R1,??jinit_downsampler_0+0x14  ;; h2v2_smooth_downsample
   \   00000188   EDFFFF1A           BNE      ??jinit_downsampler_8
   \   0000018C   78009FE5           LDR      R0,??jinit_downsampler_0+0x18  ;; h2v2_downsample
   \   00000190   EFFFFFEA           B        ??jinit_downsampler_9
   \                     ??jinit_downsampler_10:
   \   00000194   0900A0E1           MOV      R0,R9
   \   00000198   0210A0E1           MOV      R1,R2
   \   0000019C   ........           _BLF     ??div32_a,??rA??div32_a
   \   000001A0   000050E3           CMP      R0,#+0
   \   000001A4   C2FFFF1A           BNE      ??jinit_downsampler_4
   \   000001A8   0A00A0E1           MOV      R0,R10
   \   000001AC   0310A0E1           MOV      R1,R3
   \   000001B0   ........           _BLF     ??div32_a,??rA??div32_a
   \   000001B4   000050E3           CMP      R0,#+0
   \   000001B8   BDFFFF1A           BNE      ??jinit_downsampler_4
   \   000001BC   4C009FE5           LDR      R0,??jinit_downsampler_0+0x1C  ;; int_downsample
   \   000001C0   0050A0E3           MOV      R5,#+0
   \   000001C4   0C008BE5           STR      R0,[R11, #+12]
   \   000001C8   06B087E0           ADD      R11,R7,R6
   \   000001CC   0900A0E1           MOV      R0,R9
   \   000001D0   0210A0E1           MOV      R1,R2
   \   000001D4   ........           _BLF     ??div32_a,??rA??div32_a
   \   000001D8   5C10CBE5           STRB     R1,[R11, #+92]
   \   000001DC   062087E0           ADD      R2,R7,R6
   \   000001E0   0A00A0E1           MOV      R0,R10
   \   000001E4   0310A0E1           MOV      R1,R3
   \   000001E8   ........           _BLF     ??div32_a,??rA??div32_a
   \   000001EC   6610C2E5           STRB     R1,[R2, #+102]
   \   000001F0   B6FFFFEA           B        ??jinit_downsampler_5
   \                     ??jinit_downsampler_0:
   \   000001F4   ........           DC32     start_pass_downsample
   \   000001F8   ........           DC32     sep_downsample
   \   000001FC   ........           DC32     fullsize_smooth_downsample
   \   00000200   ........           DC32     fullsize_downsample
   \   00000204   ........           DC32     h2v1_downsample
   \   00000208   ........           DC32     h2v2_smooth_downsample
   \   0000020C   ........           DC32     h2v2_downsample
   \   00000210   ........           DC32     int_downsample

   Maximum stack usage in bytes:

     Function                   CSTACK
     --------                   ------
     expand_right_edge             12
     fullsize_downsample           24
     fullsize_smooth_downsample    48
     h2v1_downsample               24
     h2v2_downsample               32
     h2v2_smooth_downsample        48
     int_downsample                52
     jinit_downsampler             36
     sep_downsample                36
     start_pass_downsample          0


   Segment part sizes:

     Function/Label             Bytes
     --------------             -----
     start_pass_downsample         4
     expand_right_edge            84
     sep_downsample              120
     int_downsample              284
     fullsize_downsample          84
     h2v1_downsample             156
     h2v2_downsample             192
     h2v2_smooth_downsample      632
     fullsize_smooth_downsample  332
     jinit_downsampler           532
      Others                      64

 
 2 484 bytes in segment CODE
 
 2 420 bytes of CODE memory (+ 64 bytes shared)

Errors: none
Warnings: 1
