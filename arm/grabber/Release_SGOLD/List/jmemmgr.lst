##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    19/Jan/2011  13:20:30 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\grabber\jpeg-7\jmemmgr.c                      #
#    Command line    =  C:\arm\grabber\jpeg-7\jmemmgr.c -lC                  #
#                       C:\arm\grabber\Release_SGOLD\List\ -o                #
#                       C:\arm\grabber\Release_SGOLD\Obj\ -s9 --no_unroll    #
#                       --no_clustering --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --fpu None --dlib_config "C:\arm2\Embedded           #
#                       Workbench 4.0 Evaluation\ARM\LIB\dl5tpainl8n.h" -I   #
#                       "C:\arm2\Embedded Workbench 4.0                      #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  C:\arm\grabber\Release_SGOLD\List\jmemmgr.lst        #
#    Object file     =  C:\arm\grabber\Release_SGOLD\Obj\jmemmgr.r79         #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\grabber\jpeg-7\jmemmgr.c
      1          /*
      2           * jmemmgr.c
      3           *
      4           * Copyright (C) 1991-1997, Thomas G. Lane.
      5           * This file is part of the Independent JPEG Group's software.
      6           * For conditions of distribution and use, see the accompanying README file.
      7           *
      8           * This file contains the JPEG system-independent memory management
      9           * routines.  This code is usable across a wide variety of machines; most
     10           * of the system dependencies have been isolated in a separate file.
     11           * The major functions provided here are:
     12           *   * pool-based allocation and freeing of memory;
     13           *   * policy decisions about how to divide available memory among the
     14           *     virtual arrays;
     15           *   * control logic for swapping virtual arrays between main memory and
     16           *     backing storage.
     17           * The separate system-dependent file provides the actual backing-storage
     18           * access code, and it contains the policy decision about how much total
     19           * main memory to use.
     20           * This file is system-dependent in the sense that some of its functions
     21           * are unnecessary in some systems.  For example, if there is enough virtual
     22           * memory so that backing storage will never be used, much of the virtual
     23           * array control logic could be removed.  (Of course, if you have that much
     24           * memory then you shouldn't care about a little bit of unused code...)
     25           */
     26          
     27          #define JPEG_INTERNALS
     28          #define AM_MEMORY_MANAGER	/* we define jvirt_Xarray_control structs */
     29          #include "jinclude.h"
     30          #include "jpeglib.h"
     31          #include "jmemsys.h"		/* import the system-dependent declarations */
     32          
     33          #ifndef NO_GETENV
     34          #ifndef HAVE_STDLIB_H		/* <stdlib.h> should declare getenv() */
     35          extern char * getenv JPP((const char * name));
     36          #endif
     37          #endif
     38          
     39          
     40          /*
     41           * Some important notes:
     42           *   The allocation routines provided here must never return NULL.
     43           *   They should exit to error_exit if unsuccessful.
     44           *
     45           *   It's not a good idea to try to merge the sarray and barray routines,
     46           *   even though they are textually almost the same, because samples are
     47           *   usually stored as bytes while coefficients are shorts or ints.  Thus,
     48           *   in machines where byte pointers have a different representation from
     49           *   word pointers, the resulting machine code could not be the same.
     50           */
     51          
     52          
     53          /*
     54           * Many machines require storage alignment: longs must start on 4-byte
     55           * boundaries, doubles on 8-byte boundaries, etc.  On such machines, malloc()
     56           * always returns pointers that are multiples of the worst-case alignment
     57           * requirement, and we had better do so too.
     58           * There isn't any really portable way to determine the worst-case alignment
     59           * requirement.  This module assumes that the alignment requirement is
     60           * multiples of sizeof(ALIGN_TYPE).
     61           * By default, we define ALIGN_TYPE as double.  This is necessary on some
     62           * workstations (where doubles really do need 8-byte alignment) and will work
     63           * fine on nearly everything.  If your machine has lesser alignment needs,
     64           * you can save a few bytes by making ALIGN_TYPE smaller.
     65           * The only place I know of where this will NOT work is certain Macintosh
     66           * 680x0 compilers that define double as a 10-byte IEEE extended float.
     67           * Doing 10-byte alignment is counterproductive because longwords won't be
     68           * aligned well.  Put "#define ALIGN_TYPE long" in jconfig.h if you have
     69           * such a compiler.
     70           */
     71          
     72          #ifndef ALIGN_TYPE		/* so can override from jconfig.h */
     73          #define ALIGN_TYPE  double
     74          #endif
     75          
     76          
     77          /*
     78           * We allocate objects from "pools", where each pool is gotten with a single
     79           * request to jpeg_get_small() or jpeg_get_large().  There is no per-object
     80           * overhead within a pool, except for alignment padding.  Each pool has a
     81           * header with a link to the next pool of the same class.
     82           * Small and large pool headers are identical except that the latter's
     83           * link pointer must be FAR on 80x86 machines.
     84           * Notice that the "real" header fields are union'ed with a dummy ALIGN_TYPE
     85           * field.  This forces the compiler to make SIZEOF(small_pool_hdr) a multiple
     86           * of the alignment requirement of ALIGN_TYPE.
     87           */
     88          
     89          typedef union small_pool_struct * small_pool_ptr;
     90          
     91          typedef union small_pool_struct {
     92            struct {
     93              small_pool_ptr next;	/* next in list of pools */
     94              size_t bytes_used;		/* how many bytes already used within pool */
     95              size_t bytes_left;		/* bytes still available in this pool */
     96            } hdr;
     97            ALIGN_TYPE dummy;		/* included in union to ensure alignment */
     98          } small_pool_hdr;
     99          
    100          typedef union large_pool_struct FAR * large_pool_ptr;
    101          
    102          typedef union large_pool_struct {
    103            struct {
    104              large_pool_ptr next;	/* next in list of pools */
    105              size_t bytes_used;		/* how many bytes already used within pool */
    106              size_t bytes_left;		/* bytes still available in this pool */
    107            } hdr;
    108            ALIGN_TYPE dummy;		/* included in union to ensure alignment */
    109          } large_pool_hdr;
    110          
    111          
    112          /*
    113           * Here is the full definition of a memory manager object.
    114           */
    115          
    116          typedef struct {
    117            struct jpeg_memory_mgr pub;	/* public fields */
    118          
    119            /* Each pool identifier (lifetime class) names a linked list of pools. */
    120            small_pool_ptr small_list[JPOOL_NUMPOOLS];
    121            large_pool_ptr large_list[JPOOL_NUMPOOLS];
    122          
    123            /* Since we only have one lifetime class of virtual arrays, only one
    124             * linked list is necessary (for each datatype).  Note that the virtual
    125             * array control blocks being linked together are actually stored somewhere
    126             * in the small-pool list.
    127             */
    128            jvirt_sarray_ptr virt_sarray_list;
    129            jvirt_barray_ptr virt_barray_list;
    130          
    131            /* This counts total space obtained from jpeg_get_small/large */
    132            long total_space_allocated;
    133          
    134            /* alloc_sarray and alloc_barray set this value for use by virtual
    135             * array routines.
    136             */
    137            JDIMENSION last_rowsperchunk;	/* from most recent alloc_sarray/barray */
    138          } my_memory_mgr;
    139          
    140          typedef my_memory_mgr * my_mem_ptr;
    141          
    142          
    143          /*
    144           * The control blocks for virtual arrays.
    145           * Note that these blocks are allocated in the "small" pool area.
    146           * System-dependent info for the associated backing store (if any) is hidden
    147           * inside the backing_store_info struct.
    148           */
    149          
    150          struct jvirt_sarray_control {
    151            JSAMPARRAY mem_buffer;	/* => the in-memory buffer */
    152            JDIMENSION rows_in_array;	/* total virtual array height */
    153            JDIMENSION samplesperrow;	/* width of array (and of memory buffer) */
    154            JDIMENSION maxaccess;		/* max rows accessed by access_virt_sarray */
    155            JDIMENSION rows_in_mem;	/* height of memory buffer */
    156            JDIMENSION rowsperchunk;	/* allocation chunk size in mem_buffer */
    157            JDIMENSION cur_start_row;	/* first logical row # in the buffer */
    158            JDIMENSION first_undef_row;	/* row # of first uninitialized row */
    159            boolean pre_zero;		/* pre-zero mode requested? */
    160            boolean dirty;		/* do current buffer contents need written? */
    161            boolean b_s_open;		/* is backing-store data valid? */
    162            jvirt_sarray_ptr next;	/* link to next virtual sarray control block */
    163            backing_store_info b_s_info;	/* System-dependent control info */
    164          };
    165          
    166          struct jvirt_barray_control {
    167            JBLOCKARRAY mem_buffer;	/* => the in-memory buffer */
    168            JDIMENSION rows_in_array;	/* total virtual array height */
    169            JDIMENSION blocksperrow;	/* width of array (and of memory buffer) */
    170            JDIMENSION maxaccess;		/* max rows accessed by access_virt_barray */
    171            JDIMENSION rows_in_mem;	/* height of memory buffer */
    172            JDIMENSION rowsperchunk;	/* allocation chunk size in mem_buffer */
    173            JDIMENSION cur_start_row;	/* first logical row # in the buffer */
    174            JDIMENSION first_undef_row;	/* row # of first uninitialized row */
    175            boolean pre_zero;		/* pre-zero mode requested? */
    176            boolean dirty;		/* do current buffer contents need written? */
    177            boolean b_s_open;		/* is backing-store data valid? */
    178            jvirt_barray_ptr next;	/* link to next virtual barray control block */
    179            backing_store_info b_s_info;	/* System-dependent control info */
    180          };
    181          
    182          
    183          #ifdef MEM_STATS		/* optional extra stuff for statistics */
    184          
    185          LOCAL(void)
    186          print_mem_stats (j_common_ptr cinfo, int pool_id)
    187          {
    188            my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
    189            small_pool_ptr shdr_ptr;
    190            large_pool_ptr lhdr_ptr;
    191          
    192            /* Since this is only a debugging stub, we can cheat a little by using
    193             * fprintf directly rather than going through the trace message code.
    194             * This is helpful because message parm array can't handle longs.
    195             */
    196            fprintf(stderr, "Freeing pool %d, total space = %ld\n",
    197          	  pool_id, mem->total_space_allocated);
    198          
    199            for (lhdr_ptr = mem->large_list[pool_id]; lhdr_ptr != NULL;
    200                 lhdr_ptr = lhdr_ptr->hdr.next) {
    201              fprintf(stderr, "  Large chunk used %ld\n",
    202          	    (long) lhdr_ptr->hdr.bytes_used);
    203            }
    204          
    205            for (shdr_ptr = mem->small_list[pool_id]; shdr_ptr != NULL;
    206                 shdr_ptr = shdr_ptr->hdr.next) {
    207              fprintf(stderr, "  Small chunk used %ld free %ld\n",
    208          	    (long) shdr_ptr->hdr.bytes_used,
    209          	    (long) shdr_ptr->hdr.bytes_left);
    210            }
    211          }
    212          
    213          #endif /* MEM_STATS */
    214          
    215          
    216          LOCAL(void)
    217          out_of_memory (j_common_ptr cinfo, int which)
    218          /* Report an out-of-memory error and stop execution */
    219          /* If we compiled MEM_STATS support, report alloc requests before dying */
    220          {
    221          #ifdef MEM_STATS
    222            cinfo->err->trace_level = 2;	/* force self_destruct to report stats */
    223          #endif
    224            ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, which);
    225          }
    226          
    227          
    228          /*
    229           * Allocation of "small" objects.
    230           *
    231           * For these, we use pooled storage.  When a new pool must be created,
    232           * we try to get enough space for the current request plus a "slop" factor,
    233           * where the slop will be the amount of leftover space in the new pool.
    234           * The speed vs. space tradeoff is largely determined by the slop values.
    235           * A different slop value is provided for each pool class (lifetime),
    236           * and we also distinguish the first pool of a class from later ones.
    237           * NOTE: the values given work fairly well on both 16- and 32-bit-int
    238           * machines, but may be too small if longs are 64 bits or more.
    239           */
    240          

   \                                 In segment DATA_C, align 4, align-sorted
    241          static const size_t first_pool_slop[JPOOL_NUMPOOLS] = 
   \                     first_pool_slop:
   \   00000000   40060000803E       DC32 1600, 16000
   \              0000        
    242          {
    243          	1600,			/* first PERMANENT pool */
    244          	16000			/* first IMAGE pool */
    245          };
    246          

   \                                 In segment DATA_C, align 4, align-sorted
    247          static const size_t extra_pool_slop[JPOOL_NUMPOOLS] = 
   \                     extra_pool_slop:
   \   00000000   000000008813       DC32 0, 5000
   \              0000        
    248          {
    249          	0,			/* additional PERMANENT pools */
    250          	5000			/* additional IMAGE pools */
    251          };
    252          
    253          #define MIN_SLOP  50		/* greater than 0 to avoid futile looping */
    254          
    255          

   \                                 In segment CODE, align 4, keep-with-next
    256          METHODDEF(void *)
    257          alloc_small (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
    258          /* Allocate a "small" object */
    259          {
   \                     alloc_small:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0050A0E1           MOV      R5,R0
    260            my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
    261            small_pool_ptr hdr_ptr, prev_hdr_ptr;
    262            char * data_ptr;
    263            size_t odd_bytes, min_request, slop;
    264          
    265            /* Check for unsatisfiable request (do now to ensure no overflow below) */
    266            if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(small_pool_hdr)))
   \   00000008   ........           LDR      R0,??DataTable2  ;; 0x3b9ac9f5
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   046095E5           LDR      R6,[R5, #+4]
   \   00000014   01B0A0E1           MOV      R11,R1
   \   00000018   0240A0E1           MOV      R4,R2
   \   0000001C   3870A0E3           MOV      R7,#+56
   \   00000020   000054E1           CMP      R4,R0
   \   00000024   0800003A           BCC      ??alloc_small_0
    267              out_of_memory(cinfo, 1);	/* request exceeds malloc's ability */
   \   00000028   000095E5           LDR      R0,[R5, #+0]
   \   0000002C   0110A0E3           MOV      R1,#+1
   \   00000030   147080E5           STR      R7,[R0, #+20]
   \   00000034   000095E5           LDR      R0,[R5, #+0]
   \   00000038   181080E5           STR      R1,[R0, #+24]
   \   0000003C   001095E5           LDR      R1,[R5, #+0]
   \   00000040   0500A0E1           MOV      R0,R5
   \   00000044   001091E5           LDR      R1,[R1, #+0]
   \   00000048   31FF2FE1           BLX      R1
    268          
    269            /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
    270            odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
   \                     ??alloc_small_0:
   \   0000004C   070014E2           ANDS     R0,R4,#0x7
    271            if (odd_bytes > 0)
    272              sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
   \   00000050   08108412           ADDNE    R1,R4,#+8
   \   00000054   00404110           SUBNE    R4,R1,R0
    273          
    274            /* See if space is available in any existing pool */
    275            if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
   \   00000058   00005BE3           CMP      R11,#+0
   \   0000005C   0100004A           BMI      ??alloc_small_1
   \   00000060   02005BE3           CMP      R11,#+2
   \   00000064   080000BA           BLT      ??alloc_small_2
    276              ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
   \                     ??alloc_small_1:
   \   00000068   000095E5           LDR      R0,[R5, #+0]
   \   0000006C   0F10A0E3           MOV      R1,#+15
   \   00000070   141080E5           STR      R1,[R0, #+20]
   \   00000074   000095E5           LDR      R0,[R5, #+0]
   \   00000078   18B080E5           STR      R11,[R0, #+24]
   \   0000007C   001095E5           LDR      R1,[R5, #+0]
   \   00000080   0500A0E1           MOV      R0,R5
   \   00000084   001091E5           LDR      R1,[R1, #+0]
   \   00000088   31FF2FE1           BLX      R1
    277            prev_hdr_ptr = NULL;
   \                     ??alloc_small_2:
   \   0000008C   0080A0E3           MOV      R8,#+0
   \   00000090   0090A0E3           MOV      R9,#+0
    278            hdr_ptr = mem->small_list[pool_id];
   \   00000094   0B1186E0           ADD      R1,R6,R11, LSL #+2
   \   00000098   00108DE5           STR      R1,[SP, #+0]
   \   0000009C   340091E5           LDR      R0,[R1, #+52]
   \   000000A0   040000EA           B        ??alloc_small_3
    279            while (hdr_ptr != NULL) {
    280              if (hdr_ptr->hdr.bytes_left >= sizeofobject)
   \                     ??alloc_small_4:
   \   000000A4   081090E5           LDR      R1,[R0, #+8]
   \   000000A8   040051E1           CMP      R1,R4
   \   000000AC   2B00002A           BCS      ??alloc_small_5
    281                break;			/* found pool with enough space */
    282              prev_hdr_ptr = hdr_ptr;
   \   000000B0   0090A0E1           MOV      R9,R0
    283              hdr_ptr = hdr_ptr->hdr.next;
   \   000000B4   000090E5           LDR      R0,[R0, #+0]
    284            }
   \                     ??alloc_small_3:
   \   000000B8   000050E3           CMP      R0,#+0
   \   000000BC   F8FFFF1A           BNE      ??alloc_small_4
    285          
    286            /* Time to make a new pool? */
    287            if (hdr_ptr == NULL) {
    288              /* min_request is what we need now, slop is what will be leftover */
    289              min_request = sizeofobject + SIZEOF(small_pool_hdr);
    290              if (prev_hdr_ptr == NULL)	/* first pool in class? */
   \   000000C0   000059E3           CMP      R9,#+0
    291                slop = first_pool_slop[pool_id];
   \   000000C4   BC009F05           LDREQ    R0,??alloc_small_6  ;; first_pool_slop
   \   000000C8   0CA084E2           ADD      R10,R4,#+12
    292              else
    293                slop = extra_pool_slop[pool_id];
   \   000000CC   B8009F15           LDRNE    R0,??alloc_small_6+0x4  ;; extra_pool_slop
   \   000000D0   0BB190E7           LDR      R11,[R0, +R11, LSL #+2]
   \   000000D4   ........           LDR      R0,??DataTable6  ;; 0x3b9aca00
   \   000000D8   0A0040E0           SUB      R0,R0,R10
   \   000000DC   0B0050E1           CMP      R0,R11
   \   000000E0   0D00002A           BCS      ??alloc_small_7
    294              /* Don't ask for more than MAX_ALLOC_CHUNK */
    295              if (slop > (size_t) (MAX_ALLOC_CHUNK-min_request))
    296                slop = (size_t) (MAX_ALLOC_CHUNK-min_request);
   \   000000E4   00B0A0E1           MOV      R11,R0
   \   000000E8   0B0000EA           B        ??alloc_small_7
    297              /* Try to get space, if fail reduce slop and try again */
    298              for (;;) {
    299                hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request + slop);
    300                if (hdr_ptr != NULL)
    301          	break;
    302                slop /= 2;
   \                     ??alloc_small_8:
   \   000000EC   ABB0A0E1           LSR      R11,R11,#+1
    303                if (slop < MIN_SLOP)	/* give up when it gets real small */
   \   000000F0   32005BE3           CMP      R11,#+50
   \   000000F4   0800002A           BCS      ??alloc_small_7
    304          	out_of_memory(cinfo, 2); /* jpeg_get_small failed */
   \   000000F8   000095E5           LDR      R0,[R5, #+0]
   \   000000FC   0210A0E3           MOV      R1,#+2
   \   00000100   147080E5           STR      R7,[R0, #+20]
   \   00000104   000095E5           LDR      R0,[R5, #+0]
   \   00000108   181080E5           STR      R1,[R0, #+24]
   \   0000010C   001095E5           LDR      R1,[R5, #+0]
   \   00000110   0500A0E1           MOV      R0,R5
   \   00000114   001091E5           LDR      R1,[R1, #+0]
   \   00000118   31FF2FE1           BLX      R1
   \                     ??alloc_small_7:
   \   0000011C   0A108BE0           ADD      R1,R11,R10
   \   00000120   0500A0E1           MOV      R0,R5
   \   00000124   ........           _BLF     jpeg_get_small,??jpeg_get_small??rA
   \   00000128   000050E3           CMP      R0,#+0
   \   0000012C   EEFFFF0A           BEQ      ??alloc_small_8
    305              }
    306              mem->total_space_allocated += min_request + slop;
   \   00000130   4C1096E5           LDR      R1,[R6, #+76]
    307              /* Success, initialize the new pool header and add to end of list */
    308              hdr_ptr->hdr.next = NULL;
    309              hdr_ptr->hdr.bytes_used = 0;
    310              hdr_ptr->hdr.bytes_left = sizeofobject + slop;
    311              if (prev_hdr_ptr == NULL)	/* first pool in class? */
   \   00000134   000059E3           CMP      R9,#+0
   \   00000138   01108AE0           ADD      R1,R10,R1
   \   0000013C   01108BE0           ADD      R1,R11,R1
   \   00000140   4C1086E5           STR      R1,[R6, #+76]
   \   00000144   008080E5           STR      R8,[R0, #+0]
   \   00000148   048080E5           STR      R8,[R0, #+4]
   \   0000014C   04108BE0           ADD      R1,R11,R4
   \   00000150   081080E5           STR      R1,[R0, #+8]
    312                mem->small_list[pool_id] = hdr_ptr;
   \   00000154   00109D05           LDREQ    R1,[SP, #+0]
    313              else
    314                prev_hdr_ptr->hdr.next = hdr_ptr;
   \   00000158   00008915           STRNE    R0,[R9, #+0]
   \   0000015C   34008105           STREQ    R0,[R1, #+52]
    315            }
    316          
    317            /* OK, allocate the object from the current pool */
    318            data_ptr = (char *) (hdr_ptr + 1); /* point to first data byte in pool */
    319            data_ptr += hdr_ptr->hdr.bytes_used; /* point to place for object */
   \                     ??alloc_small_5:
   \   00000160   042090E5           LDR      R2,[R0, #+4]
   \   00000164   001082E0           ADD      R1,R2,R0
    320            hdr_ptr->hdr.bytes_used += sizeofobject;
   \   00000168   022084E0           ADD      R2,R4,R2
   \   0000016C   042080E5           STR      R2,[R0, #+4]
    321            hdr_ptr->hdr.bytes_left -= sizeofobject;
   \   00000170   082090E5           LDR      R2,[R0, #+8]
   \   00000174   0C1081E2           ADD      R1,R1,#+12
   \   00000178   042042E0           SUB      R2,R2,R4
   \   0000017C   082080E5           STR      R2,[R0, #+8]
    322          
    323            return (void *) data_ptr;
   \   00000180   0100A0E1           MOV      R0,R1
   \   00000184   F28FBDE8           POP      {R1,R4-R11,PC}   ;; return
   \                     ??alloc_small_6:
   \   00000188   ........           DC32     first_pool_slop
   \   0000018C   ........           DC32     extra_pool_slop
    324          }
    325          
    326          
    327          /*
    328           * Allocation of "large" objects.
    329           *
    330           * The external semantics of these are the same as "small" objects,
    331           * except that FAR pointers are used on 80x86.  However the pool
    332           * management heuristics are quite different.  We assume that each
    333           * request is large enough that it may as well be passed directly to
    334           * jpeg_get_large; the pool management just links everything together
    335           * so that we can free it all on demand.
    336           * Note: the major use of "large" objects is in JSAMPARRAY and JBLOCKARRAY
    337           * structures.  The routines that create these structures (see below)
    338           * deliberately bunch rows together to ensure a large request size.
    339           */
    340          

   \                                 In segment CODE, align 4, keep-with-next
    341          METHODDEF(void FAR *)
    342          alloc_large (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
    343          /* Allocate a "large" object */
    344          {
   \                     alloc_large:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0050A0E1           MOV      R5,R0
    345            my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
    346            large_pool_ptr hdr_ptr;
    347            size_t odd_bytes;
    348          
    349            /* Check for unsatisfiable request (do now to ensure no overflow below) */
    350            if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)))
   \   00000008   ........           LDR      R0,??DataTable2  ;; 0x3b9ac9f5
   \   0000000C   047095E5           LDR      R7,[R5, #+4]
   \   00000010   0160A0E1           MOV      R6,R1
   \   00000014   0240A0E1           MOV      R4,R2
   \   00000018   3880A0E3           MOV      R8,#+56
   \   0000001C   000054E1           CMP      R4,R0
   \   00000020   0800003A           BCC      ??alloc_large_0
    351              out_of_memory(cinfo, 3);	/* request exceeds malloc's ability */
   \   00000024   000095E5           LDR      R0,[R5, #+0]
   \   00000028   0310A0E3           MOV      R1,#+3
   \   0000002C   148080E5           STR      R8,[R0, #+20]
   \   00000030   000095E5           LDR      R0,[R5, #+0]
   \   00000034   181080E5           STR      R1,[R0, #+24]
   \   00000038   001095E5           LDR      R1,[R5, #+0]
   \   0000003C   0500A0E1           MOV      R0,R5
   \   00000040   001091E5           LDR      R1,[R1, #+0]
   \   00000044   31FF2FE1           BLX      R1
    352          
    353            /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
    354            odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
   \                     ??alloc_large_0:
   \   00000048   070014E2           ANDS     R0,R4,#0x7
    355            if (odd_bytes > 0)
    356              sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
   \   0000004C   08108412           ADDNE    R1,R4,#+8
   \   00000050   00404110           SUBNE    R4,R1,R0
    357          
    358            /* Always make a new pool */
    359            if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
   \   00000054   000056E3           CMP      R6,#+0
   \   00000058   0100004A           BMI      ??alloc_large_1
   \   0000005C   020056E3           CMP      R6,#+2
   \   00000060   080000BA           BLT      ??alloc_large_2
    360              ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
   \                     ??alloc_large_1:
   \   00000064   000095E5           LDR      R0,[R5, #+0]
   \   00000068   0F10A0E3           MOV      R1,#+15
   \   0000006C   141080E5           STR      R1,[R0, #+20]
   \   00000070   000095E5           LDR      R0,[R5, #+0]
   \   00000074   186080E5           STR      R6,[R0, #+24]
   \   00000078   001095E5           LDR      R1,[R5, #+0]
   \   0000007C   0500A0E1           MOV      R0,R5
   \   00000080   001091E5           LDR      R1,[R1, #+0]
   \   00000084   31FF2FE1           BLX      R1
    361          
    362            hdr_ptr = (large_pool_ptr) jpeg_get_large(cinfo, sizeofobject +
    363          					    SIZEOF(large_pool_hdr));
   \                     ??alloc_large_2:
   \   00000088   0C1084E2           ADD      R1,R4,#+12
   \   0000008C   0500A0E1           MOV      R0,R5
   \   00000090   ........           _BLF     jpeg_get_large,??jpeg_get_large??rA
   \   00000094   0090B0E1           MOVS     R9,R0
    364            if (hdr_ptr == NULL)
   \   00000098   0800001A           BNE      ??alloc_large_3
    365              out_of_memory(cinfo, 4);	/* jpeg_get_large failed */
   \   0000009C   000095E5           LDR      R0,[R5, #+0]
   \   000000A0   0410A0E3           MOV      R1,#+4
   \   000000A4   148080E5           STR      R8,[R0, #+20]
   \   000000A8   000095E5           LDR      R0,[R5, #+0]
   \   000000AC   181080E5           STR      R1,[R0, #+24]
   \   000000B0   001095E5           LDR      R1,[R5, #+0]
   \   000000B4   0500A0E1           MOV      R0,R5
   \   000000B8   001091E5           LDR      R1,[R1, #+0]
   \   000000BC   31FF2FE1           BLX      R1
    366            mem->total_space_allocated += sizeofobject + SIZEOF(large_pool_hdr);
   \                     ??alloc_large_3:
   \   000000C0   4C0097E5           LDR      R0,[R7, #+76]
   \   000000C4   000084E0           ADD      R0,R4,R0
   \   000000C8   0C0080E2           ADD      R0,R0,#+12
   \   000000CC   4C0087E5           STR      R0,[R7, #+76]
    367          
    368            /* Success, initialize the new pool header and add to list */
    369            hdr_ptr->hdr.next = mem->large_list[pool_id];
   \   000000D0   060187E0           ADD      R0,R7,R6, LSL #+2
   \   000000D4   3C1090E5           LDR      R1,[R0, #+60]
   \   000000D8   001089E5           STR      R1,[R9, #+0]
    370            /* We maintain space counts in each pool header for statistical purposes,
    371             * even though they are not needed for allocation.
    372             */
    373            hdr_ptr->hdr.bytes_used = sizeofobject;
   \   000000DC   044089E5           STR      R4,[R9, #+4]
    374            hdr_ptr->hdr.bytes_left = 0;
   \   000000E0   0010A0E3           MOV      R1,#+0
   \   000000E4   081089E5           STR      R1,[R9, #+8]
    375            mem->large_list[pool_id] = hdr_ptr;
   \   000000E8   3C9080E5           STR      R9,[R0, #+60]
    376          
    377            return (void FAR *) (hdr_ptr + 1); /* point to first data byte in pool */
   \   000000EC   0C0089E2           ADD      R0,R9,#+12
   \   000000F0   F083BDE8           POP      {R4-R9,PC}       ;; return
    378          }
    379          
    380          
    381          /*
    382           * Creation of 2-D sample arrays.
    383           * The pointers are in near heap, the samples themselves in FAR heap.
    384           *
    385           * To minimize allocation overhead and to allow I/O of large contiguous
    386           * blocks, we allocate the sample rows in groups of as many rows as possible
    387           * without exceeding MAX_ALLOC_CHUNK total bytes per allocation request.
    388           * NB: the virtual array control routines, later in this file, know about
    389           * this chunking of rows.  The rowsperchunk value is left in the mem manager
    390           * object so that it can be saved away if this sarray is the workspace for
    391           * a virtual array.
    392           */
    393          

   \                                 In segment CODE, align 4, keep-with-next
    394          METHODDEF(JSAMPARRAY)
    395          alloc_sarray (j_common_ptr cinfo, int pool_id,
    396          	      JDIMENSION samplesperrow, JDIMENSION numrows)
    397          /* Allocate a 2-D sample array */
    398          {
   \                     alloc_sarray:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    399            my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
   \   00000008   049094E5           LDR      R9,[R4, #+4]
    400            JSAMPARRAY result;
    401            JSAMPROW workspace;
    402            JDIMENSION rowsperchunk, currow, i;
    403            long ltemp;
    404          
    405            /* Calculate max # of rows allowed in one allocation chunk */
    406            ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
    407          	  ((long) samplesperrow * SIZEOF(JSAMPLE));
   \   0000000C   ........           LDR      R0,??DataTable4  ;; 0x3b9ac9f4
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   0370A0E1           MOV      R7,R3
   \   0000001C   0610A0E1           MOV      R1,R6
   \   00000020   ........           _BLF     ??divu32_a,??rA??divu32_a
   \   00000024   0180A0E1           MOV      R8,R1
    408            if (ltemp <= 0)
   \   00000028   010058E3           CMP      R8,#+1
   \   0000002C   060000AA           BGE      ??alloc_sarray_0
    409              ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
   \   00000030   000094E5           LDR      R0,[R4, #+0]
   \   00000034   4810A0E3           MOV      R1,#+72
   \   00000038   141080E5           STR      R1,[R0, #+20]
   \   0000003C   001094E5           LDR      R1,[R4, #+0]
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   001091E5           LDR      R1,[R1, #+0]
   \   00000048   31FF2FE1           BLX      R1
    410            if (ltemp < (long) numrows)
   \                     ??alloc_sarray_0:
   \   0000004C   070058E1           CMP      R8,R7
    411              rowsperchunk = (JDIMENSION) ltemp;
    412            else
    413              rowsperchunk = numrows;
   \   00000050   0780A0A1           MOVGE    R8,R7
    414            mem->last_rowsperchunk = rowsperchunk;
   \   00000054   508089E5           STR      R8,[R9, #+80]
    415          
    416            /* Get space for row pointers (small object) */
    417            result = (JSAMPARRAY) alloc_small(cinfo, pool_id,
    418          				    (size_t) (numrows * SIZEOF(JSAMPROW)));
   \   00000058   0721A0E1           LSL      R2,R7,#+2
   \   0000005C   0510A0E1           MOV      R1,R5
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   ........           BL       alloc_small
   \   00000068   0090A0E1           MOV      R9,R0
    419          
    420            /* Get the rows themselves (large objects) */
    421            currow = 0;
   \   0000006C   00A0A0E3           MOV      R10,#+0
   \   00000070   000057E3           CMP      R7,#+0
   \   00000074   0F00001A           BNE      ??alloc_sarray_1
   \   00000078   0900A0E1           MOV      R0,R9
   \   0000007C   F087BDE8           POP      {R4-R10,PC}
    422            while (currow < numrows) {
    423              rowsperchunk = MIN(rowsperchunk, numrows - currow);
   \                     ??alloc_sarray_2:
   \   00000080   0A0047E0           SUB      R0,R7,R10
   \   00000084   000058E1           CMP      R8,R0
   \   00000088   0080A021           MOVCS    R8,R0
    424              workspace = (JSAMPROW) alloc_large(cinfo, pool_id,
    425          	(size_t) ((size_t) rowsperchunk * (size_t) samplesperrow
    426          		  * SIZEOF(JSAMPLE)));
   \   0000008C   960802E0           MUL      R2,R6,R8
   \   00000090   0510A0E1           MOV      R1,R5
   \   00000094   0400A0E1           MOV      R0,R4
   \   00000098   ........           BL       alloc_large
    427              for (i = rowsperchunk; i > 0; i--) {
   \   0000009C   0810B0E1           MOVS     R1,R8
   \   000000A0   F6FFFF0A           BEQ      ??alloc_sarray_2
    428                result[currow++] = workspace;
   \                     ??alloc_sarray_3:
   \   000000A4   0A0189E7           STR      R0,[R9, +R10, LSL #+2]
   \   000000A8   01A08AE2           ADD      R10,R10,#+1
    429                workspace += samplesperrow;
   \   000000AC   000086E0           ADD      R0,R6,R0
    430              }
   \   000000B0   011051E2           SUBS     R1,R1,#+1
   \   000000B4   FAFFFF1A           BNE      ??alloc_sarray_3
    431            }
   \                     ??alloc_sarray_1:
   \   000000B8   07005AE1           CMP      R10,R7
   \   000000BC   EFFFFF3A           BCC      ??alloc_sarray_2
    432          
    433            return result;
   \   000000C0   0900A0E1           MOV      R0,R9
   \   000000C4   F087BDE8           POP      {R4-R10,PC}      ;; return
    434          }
    435          
    436          
    437          /*
    438           * Creation of 2-D coefficient-block arrays.
    439           * This is essentially the same as the code for sample arrays, above.
    440           */
    441          

   \                                 In segment CODE, align 4, keep-with-next
    442          METHODDEF(JBLOCKARRAY)
    443          alloc_barray (j_common_ptr cinfo, int pool_id,
    444          	      JDIMENSION blocksperrow, JDIMENSION numrows)
    445          /* Allocate a 2-D coefficient-block array */
    446          {
   \                     alloc_barray:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    447            my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
   \   00000008   049094E5           LDR      R9,[R4, #+4]
    448            JBLOCKARRAY result;
    449            JBLOCKROW workspace;
    450            JDIMENSION rowsperchunk, currow, i;
    451            long ltemp;
    452          
    453            /* Calculate max # of rows allowed in one allocation chunk */
    454            ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
    455          	  ((long) blocksperrow * SIZEOF(JBLOCK));
   \   0000000C   ........           LDR      R0,??DataTable4  ;; 0x3b9ac9f4
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   0370A0E1           MOV      R7,R3
   \   0000001C   8613A0E1           LSL      R1,R6,#+7
   \   00000020   ........           _BLF     ??divu32_a,??rA??divu32_a
   \   00000024   0180A0E1           MOV      R8,R1
    456            if (ltemp <= 0)
   \   00000028   010058E3           CMP      R8,#+1
   \   0000002C   060000AA           BGE      ??alloc_barray_0
    457              ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
   \   00000030   000094E5           LDR      R0,[R4, #+0]
   \   00000034   4810A0E3           MOV      R1,#+72
   \   00000038   141080E5           STR      R1,[R0, #+20]
   \   0000003C   001094E5           LDR      R1,[R4, #+0]
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   001091E5           LDR      R1,[R1, #+0]
   \   00000048   31FF2FE1           BLX      R1
    458            if (ltemp < (long) numrows)
   \                     ??alloc_barray_0:
   \   0000004C   070058E1           CMP      R8,R7
    459              rowsperchunk = (JDIMENSION) ltemp;
    460            else
    461              rowsperchunk = numrows;
   \   00000050   0780A0A1           MOVGE    R8,R7
    462            mem->last_rowsperchunk = rowsperchunk;
   \   00000054   508089E5           STR      R8,[R9, #+80]
    463          
    464            /* Get space for row pointers (small object) */
    465            result = (JBLOCKARRAY) alloc_small(cinfo, pool_id,
    466          				     (size_t) (numrows * SIZEOF(JBLOCKROW)));
   \   00000058   0721A0E1           LSL      R2,R7,#+2
   \   0000005C   0510A0E1           MOV      R1,R5
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   ........           BL       alloc_small
   \   00000068   0090A0E1           MOV      R9,R0
    467          
    468            /* Get the rows themselves (large objects) */
    469            currow = 0;
   \   0000006C   00A0A0E3           MOV      R10,#+0
   \   00000070   000057E3           CMP      R7,#+0
   \   00000074   1000001A           BNE      ??alloc_barray_1
   \   00000078   0900A0E1           MOV      R0,R9
   \   0000007C   F087BDE8           POP      {R4-R10,PC}
    470            while (currow < numrows) {
    471              rowsperchunk = MIN(rowsperchunk, numrows - currow);
   \                     ??alloc_barray_2:
   \   00000080   0A0047E0           SUB      R0,R7,R10
   \   00000084   000058E1           CMP      R8,R0
   \   00000088   0080A021           MOVCS    R8,R0
    472              workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,
    473          	(size_t) ((size_t) rowsperchunk * (size_t) blocksperrow
    474          		  * SIZEOF(JBLOCK)));
   \   0000008C   960800E0           MUL      R0,R6,R8
   \   00000090   0510A0E1           MOV      R1,R5
   \   00000094   8023A0E1           LSL      R2,R0,#+7
   \   00000098   0400A0E1           MOV      R0,R4
   \   0000009C   ........           BL       alloc_large
    475              for (i = rowsperchunk; i > 0; i--) {
   \   000000A0   0810B0E1           MOVS     R1,R8
   \   000000A4   F5FFFF0A           BEQ      ??alloc_barray_2
    476                result[currow++] = workspace;
   \                     ??alloc_barray_3:
   \   000000A8   0A0189E7           STR      R0,[R9, +R10, LSL #+2]
   \   000000AC   01A08AE2           ADD      R10,R10,#+1
    477                workspace += blocksperrow;
   \   000000B0   860380E0           ADD      R0,R0,R6, LSL #+7
    478              }
   \   000000B4   011051E2           SUBS     R1,R1,#+1
   \   000000B8   FAFFFF1A           BNE      ??alloc_barray_3
    479            }
   \                     ??alloc_barray_1:
   \   000000BC   07005AE1           CMP      R10,R7
   \   000000C0   EEFFFF3A           BCC      ??alloc_barray_2
    480          
    481            return result;
   \   000000C4   0900A0E1           MOV      R0,R9
   \   000000C8   F087BDE8           POP      {R4-R10,PC}      ;; return
    482          }
    483          
    484          
    485          /*
    486           * About virtual array management:
    487           *
    488           * The above "normal" array routines are only used to allocate strip buffers
    489           * (as wide as the image, but just a few rows high).  Full-image-sized buffers
    490           * are handled as "virtual" arrays.  The array is still accessed a strip at a
    491           * time, but the memory manager must save the whole array for repeated
    492           * accesses.  The intended implementation is that there is a strip buffer in
    493           * memory (as high as is possible given the desired memory limit), plus a
    494           * backing file that holds the rest of the array.
    495           *
    496           * The request_virt_array routines are told the total size of the image and
    497           * the maximum number of rows that will be accessed at once.  The in-memory
    498           * buffer must be at least as large as the maxaccess value.
    499           *
    500           * The request routines create control blocks but not the in-memory buffers.
    501           * That is postponed until realize_virt_arrays is called.  At that time the
    502           * total amount of space needed is known (approximately, anyway), so free
    503           * memory can be divided up fairly.
    504           *
    505           * The access_virt_array routines are responsible for making a specific strip
    506           * area accessible (after reading or writing the backing file, if necessary).
    507           * Note that the access routines are told whether the caller intends to modify
    508           * the accessed strip; during a read-only pass this saves having to rewrite
    509           * data to disk.  The access routines are also responsible for pre-zeroing
    510           * any newly accessed rows, if pre-zeroing was requested.
    511           *
    512           * In current usage, the access requests are usually for nonoverlapping
    513           * strips; that is, successive access start_row numbers differ by exactly
    514           * num_rows = maxaccess.  This means we can get good performance with simple
    515           * buffer dump/reload logic, by making the in-memory buffer be a multiple
    516           * of the access height; then there will never be accesses across bufferload
    517           * boundaries.  The code will still work with overlapping access requests,
    518           * but it doesn't handle bufferload overlaps very efficiently.
    519           */
    520          
    521          

   \                                 In segment CODE, align 4, keep-with-next
    522          METHODDEF(jvirt_sarray_ptr)
    523          request_virt_sarray (j_common_ptr cinfo, int pool_id, boolean pre_zero,
    524          		     JDIMENSION samplesperrow, JDIMENSION numrows,
    525          		     JDIMENSION maxaccess)
    526          /* Request a virtual 2-D sample array */
    527          {
   \                     request_virt_sarray:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   20809DE5           LDR      R8,[SP, #+32]
   \   00000008   24909DE5           LDR      R9,[SP, #+36]
   \   0000000C   0060A0E1           MOV      R6,R0
    528            my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
   \   00000010   04A096E5           LDR      R10,[R6, #+4]
   \   00000014   0170A0E1           MOV      R7,R1
   \   00000018   0240A0E1           MOV      R4,R2
   \   0000001C   0350A0E1           MOV      R5,R3
    529            jvirt_sarray_ptr result;
    530          
    531            /* Only IMAGE-lifetime virtual arrays are currently supported */
    532            if (pool_id != JPOOL_IMAGE)
   \   00000020   010057E3           CMP      R7,#+1
   \   00000024   0800000A           BEQ      ??request_virt_sarray_0
    533              ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
   \   00000028   000096E5           LDR      R0,[R6, #+0]
   \   0000002C   0F10A0E3           MOV      R1,#+15
   \   00000030   141080E5           STR      R1,[R0, #+20]
   \   00000034   000096E5           LDR      R0,[R6, #+0]
   \   00000038   187080E5           STR      R7,[R0, #+24]
   \   0000003C   001096E5           LDR      R1,[R6, #+0]
   \   00000040   0600A0E1           MOV      R0,R6
   \   00000044   001091E5           LDR      R1,[R1, #+0]
   \   00000048   31FF2FE1           BLX      R1
    534          
    535            /* get control block */
    536            result = (jvirt_sarray_ptr) alloc_small(cinfo, pool_id,
    537          					  SIZEOF(struct jvirt_sarray_control));
   \                     ??request_virt_sarray_0:
   \   0000004C   8020A0E3           MOV      R2,#+128
   \   00000050   0710A0E1           MOV      R1,R7
   \   00000054   0600A0E1           MOV      R0,R6
   \   00000058   ........           BL       alloc_small
    538          
    539            result->mem_buffer = NULL;	/* marks array not yet realized */
   \   0000005C   0010A0E3           MOV      R1,#+0
   \   00000060   001080E5           STR      R1,[R0, #+0]
    540            result->rows_in_array = numrows;
   \   00000064   048080E5           STR      R8,[R0, #+4]
    541            result->samplesperrow = samplesperrow;
   \   00000068   085080E5           STR      R5,[R0, #+8]
    542            result->maxaccess = maxaccess;
   \   0000006C   0C9080E5           STR      R9,[R0, #+12]
    543            result->pre_zero = pre_zero;
   \   00000070   204080E5           STR      R4,[R0, #+32]
    544            result->b_s_open = FALSE;	/* no associated backing-store object */
   \   00000074   281080E5           STR      R1,[R0, #+40]
    545            result->next = mem->virt_sarray_list; /* add to list of virtual arrays */
   \   00000078   44109AE5           LDR      R1,[R10, #+68]
   \   0000007C   2C1080E5           STR      R1,[R0, #+44]
    546            mem->virt_sarray_list = result;
   \   00000080   44008AE5           STR      R0,[R10, #+68]
    547          
    548            return result;
   \   00000084   F087BDE8           POP      {R4-R10,PC}      ;; return
    549          }
    550          
    551          

   \                                 In segment CODE, align 4, keep-with-next
    552          METHODDEF(jvirt_barray_ptr)
    553          request_virt_barray (j_common_ptr cinfo, int pool_id, boolean pre_zero,
    554          		     JDIMENSION blocksperrow, JDIMENSION numrows,
    555          		     JDIMENSION maxaccess)
    556          /* Request a virtual 2-D coefficient-block array */
    557          {
   \                     request_virt_barray:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   20809DE5           LDR      R8,[SP, #+32]
   \   00000008   24909DE5           LDR      R9,[SP, #+36]
   \   0000000C   0060A0E1           MOV      R6,R0
    558            my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
   \   00000010   04A096E5           LDR      R10,[R6, #+4]
   \   00000014   0170A0E1           MOV      R7,R1
   \   00000018   0240A0E1           MOV      R4,R2
   \   0000001C   0350A0E1           MOV      R5,R3
    559            jvirt_barray_ptr result;
    560          
    561            /* Only IMAGE-lifetime virtual arrays are currently supported */
    562            if (pool_id != JPOOL_IMAGE)
   \   00000020   010057E3           CMP      R7,#+1
   \   00000024   0800000A           BEQ      ??request_virt_barray_0
    563              ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
   \   00000028   000096E5           LDR      R0,[R6, #+0]
   \   0000002C   0F10A0E3           MOV      R1,#+15
   \   00000030   141080E5           STR      R1,[R0, #+20]
   \   00000034   000096E5           LDR      R0,[R6, #+0]
   \   00000038   187080E5           STR      R7,[R0, #+24]
   \   0000003C   001096E5           LDR      R1,[R6, #+0]
   \   00000040   0600A0E1           MOV      R0,R6
   \   00000044   001091E5           LDR      R1,[R1, #+0]
   \   00000048   31FF2FE1           BLX      R1
    564          
    565            /* get control block */
    566            result = (jvirt_barray_ptr) alloc_small(cinfo, pool_id,
    567          					  SIZEOF(struct jvirt_barray_control));
   \                     ??request_virt_barray_0:
   \   0000004C   8020A0E3           MOV      R2,#+128
   \   00000050   0710A0E1           MOV      R1,R7
   \   00000054   0600A0E1           MOV      R0,R6
   \   00000058   ........           BL       alloc_small
    568          
    569            result->mem_buffer = NULL;	/* marks array not yet realized */
   \   0000005C   0010A0E3           MOV      R1,#+0
   \   00000060   001080E5           STR      R1,[R0, #+0]
    570            result->rows_in_array = numrows;
   \   00000064   048080E5           STR      R8,[R0, #+4]
    571            result->blocksperrow = blocksperrow;
   \   00000068   085080E5           STR      R5,[R0, #+8]
    572            result->maxaccess = maxaccess;
   \   0000006C   0C9080E5           STR      R9,[R0, #+12]
    573            result->pre_zero = pre_zero;
   \   00000070   204080E5           STR      R4,[R0, #+32]
    574            result->b_s_open = FALSE;	/* no associated backing-store object */
   \   00000074   281080E5           STR      R1,[R0, #+40]
    575            result->next = mem->virt_barray_list; /* add to list of virtual arrays */
   \   00000078   48109AE5           LDR      R1,[R10, #+72]
   \   0000007C   2C1080E5           STR      R1,[R0, #+44]
    576            mem->virt_barray_list = result;
   \   00000080   48008AE5           STR      R0,[R10, #+72]
    577          
    578            return result;
   \   00000084   F087BDE8           POP      {R4-R10,PC}      ;; return
    579          }
    580          
    581          

   \                                 In segment CODE, align 4, keep-with-next
    582          METHODDEF(void)
    583          realize_virt_arrays (j_common_ptr cinfo)
    584          /* Allocate the in-memory buffers for any unrealized virtual arrays */
    585          {
   \                     realize_virt_arrays:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    586            my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
   \   00000008   045094E5           LDR      R5,[R4, #+4]
    587            long space_per_minheight, maximum_space, avail_mem;
    588            long minheights, max_minheights;
    589            jvirt_sarray_ptr sptr;
    590            jvirt_barray_ptr bptr;
    591          
    592            /* Compute the minimum space needed (maxaccess rows in each buffer)
    593             * and the maximum space needed (full image height in each buffer).
    594             * These may be of use to the system-dependent jpeg_mem_available routine.
    595             */
    596            space_per_minheight = 0;
   \   0000000C   0060A0E3           MOV      R6,#+0
    597            maximum_space = 0;
    598            for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
   \   00000010   447095E5           LDR      R7,[R5, #+68]
   \   00000014   0080A0E3           MOV      R8,#+0
   \   00000018   0690A0E1           MOV      R9,R6
   \   0000001C   000057E3           CMP      R7,#+0
   \   00000020   0A00000A           BEQ      ??realize_virt_arrays_0
    599              if (sptr->mem_buffer == NULL) { /* if not realized yet */
   \                     ??realize_virt_arrays_1:
   \   00000024   000097E5           LDR      R0,[R7, #+0]
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   0400001A           BNE      ??realize_virt_arrays_2
    600                space_per_minheight += (long) sptr->maxaccess *
    601          			     (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
   \   00000030   080097E5           LDR      R0,[R7, #+8]
   \   00000034   0C1097E5           LDR      R1,[R7, #+12]
   \   00000038   908128E0           MLA      R8,R0,R1,R8
    602                maximum_space += (long) sptr->rows_in_array *
    603          		       (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
   \   0000003C   041097E5           LDR      R1,[R7, #+4]
   \   00000040   909129E0           MLA      R9,R0,R1,R9
    604              }
    605            }
   \                     ??realize_virt_arrays_2:
   \   00000044   2C7097E5           LDR      R7,[R7, #+44]
   \   00000048   000057E3           CMP      R7,#+0
   \   0000004C   F4FFFF1A           BNE      ??realize_virt_arrays_1
    606            for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
   \                     ??realize_virt_arrays_0:
   \   00000050   487095E5           LDR      R7,[R5, #+72]
   \   00000054   000057E3           CMP      R7,#+0
   \   00000058   0C00000A           BEQ      ??realize_virt_arrays_3
    607              if (bptr->mem_buffer == NULL) { /* if not realized yet */
   \                     ??realize_virt_arrays_4:
   \   0000005C   000097E5           LDR      R0,[R7, #+0]
   \   00000060   000050E3           CMP      R0,#+0
   \   00000064   0600001A           BNE      ??realize_virt_arrays_5
    608                space_per_minheight += (long) bptr->maxaccess *
    609          			     (long) bptr->blocksperrow * SIZEOF(JBLOCK);
   \   00000068   080097E5           LDR      R0,[R7, #+8]
   \   0000006C   0C1097E5           LDR      R1,[R7, #+12]
   \   00000070   900101E0           MUL      R1,R0,R1
   \   00000074   818388E0           ADD      R8,R8,R1, LSL #+7
    610                maximum_space += (long) bptr->rows_in_array *
    611          		       (long) bptr->blocksperrow * SIZEOF(JBLOCK);
   \   00000078   041097E5           LDR      R1,[R7, #+4]
   \   0000007C   900101E0           MUL      R1,R0,R1
   \   00000080   819389E0           ADD      R9,R9,R1, LSL #+7
    612              }
    613            }
   \                     ??realize_virt_arrays_5:
   \   00000084   2C7097E5           LDR      R7,[R7, #+44]
   \   00000088   000057E3           CMP      R7,#+0
   \   0000008C   F2FFFF1A           BNE      ??realize_virt_arrays_4
    614          
    615            if (space_per_minheight <= 0)
   \                     ??realize_virt_arrays_3:
   \   00000090   010058E3           CMP      R8,#+1
   \   00000094   F083BDB8           POPLT    {R4-R9,PC}
    616              return;			/* no unrealized arrays, no work */
    617          
    618            /* Determine amount of memory to actually use; this is system-dependent. */
    619            avail_mem = jpeg_mem_available(cinfo, space_per_minheight, maximum_space,
    620          				 mem->total_space_allocated);
   \   00000098   4C3095E5           LDR      R3,[R5, #+76]
   \   0000009C   0920A0E1           MOV      R2,R9
   \   000000A0   0810A0E1           MOV      R1,R8
   \   000000A4   0400A0E1           MOV      R0,R4
   \   000000A8   ........           _BLF     jpeg_mem_available,??jpeg_mem_available??rA
    621          
    622            /* If the maximum space needed is available, make all the buffers full
    623             * height; otherwise parcel it out with the same number of minheights
    624             * in each buffer.
    625             */
    626            if (avail_mem >= maximum_space)
   \   000000AC   090050E1           CMP      R0,R9
    627              max_minheights = 1000000000L;
   \   000000B0   ........           LDRGE    R8,??DataTable6  ;; 0x3b9aca00
   \   000000B4   040000AA           BGE      ??realize_virt_arrays_6
    628            else {
    629              max_minheights = avail_mem / space_per_minheight;
   \   000000B8   0810A0E1           MOV      R1,R8
   \   000000BC   ........           _BLF     ??div32_a,??rA??div32_a
   \   000000C0   0180A0E1           MOV      R8,R1
    630              /* If there doesn't seem to be enough space, try to get the minimum
    631               * anyway.  This allows a "stub" implementation of jpeg_mem_available().
    632               */
    633              if (max_minheights <= 0)
   \   000000C4   010058E3           CMP      R8,#+1
    634                max_minheights = 1;
   \   000000C8   0180A0B3           MOVLT    R8,#+1
    635            }
    636          
    637            /* Allocate the in-memory buffers and initialize backing store as needed. */
    638          
    639            for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
   \                     ??realize_virt_arrays_6:
   \   000000CC   447095E5           LDR      R7,[R5, #+68]
   \   000000D0   0190A0E3           MOV      R9,#+1
   \   000000D4   000057E3           CMP      R7,#+0
   \   000000D8   2100000A           BEQ      ??realize_virt_arrays_7
    640              if (sptr->mem_buffer == NULL) { /* if not realized yet */
   \                     ??realize_virt_arrays_8:
   \   000000DC   000097E5           LDR      R0,[R7, #+0]
   \   000000E0   000050E3           CMP      R0,#+0
   \   000000E4   1B00001A           BNE      ??realize_virt_arrays_9
    641                minheights = ((long) sptr->rows_in_array - 1L) / sptr->maxaccess + 1L;
    642                if (minheights <= max_minheights) {
   \   000000E8   0C3097E5           LDR      R3,[R7, #+12]
   \   000000EC   042097E5           LDR      R2,[R7, #+4]
   \   000000F0   0310A0E1           MOV      R1,R3
   \   000000F4   010042E2           SUB      R0,R2,#+1
   \   000000F8   ........           _BLF     ??divu32_a,??rA??divu32_a
   \   000000FC   010081E2           ADD      R0,R1,#+1
   \   00000100   000058E1           CMP      R8,R0
    643          	/* This buffer fits in memory */
    644          	sptr->rows_in_mem = sptr->rows_in_array;
   \   00000104   102087A5           STRGE    R2,[R7, #+16]
   \   00000108   070000AA           BGE      ??realize_virt_arrays_10
    645                } else {
    646          	/* It doesn't fit in memory, create backing store. */
    647          	sptr->rows_in_mem = (JDIMENSION) (max_minheights * sptr->maxaccess);
   \   0000010C   930800E0           MUL      R0,R3,R8
    648          	jpeg_open_backing_store(cinfo, & sptr->b_s_info,
    649          				(long) sptr->rows_in_array *
    650          				(long) sptr->samplesperrow *
    651          				(long) SIZEOF(JSAMPLE));
   \   00000110   301087E2           ADD      R1,R7,#+48
   \   00000114   100087E5           STR      R0,[R7, #+16]
   \   00000118   080097E5           LDR      R0,[R7, #+8]
   \   0000011C   900202E0           MUL      R2,R0,R2
   \   00000120   0400A0E1           MOV      R0,R4
   \   00000124   ........           _BLF     jpeg_open_backing_store,??jpeg_open_backing_store??rA
    652          	sptr->b_s_open = TRUE;
   \   00000128   289087E5           STR      R9,[R7, #+40]
    653                }
    654                sptr->mem_buffer = alloc_sarray(cinfo, JPOOL_IMAGE,
    655          				      sptr->samplesperrow, sptr->rows_in_mem);
   \                     ??realize_virt_arrays_10:
   \   0000012C   103097E5           LDR      R3,[R7, #+16]
   \   00000130   082097E5           LDR      R2,[R7, #+8]
   \   00000134   0110A0E3           MOV      R1,#+1
   \   00000138   0400A0E1           MOV      R0,R4
   \   0000013C   ........           BL       alloc_sarray
   \   00000140   000087E5           STR      R0,[R7, #+0]
    656                sptr->rowsperchunk = mem->last_rowsperchunk;
   \   00000144   500095E5           LDR      R0,[R5, #+80]
   \   00000148   140087E5           STR      R0,[R7, #+20]
    657                sptr->cur_start_row = 0;
   \   0000014C   186087E5           STR      R6,[R7, #+24]
    658                sptr->first_undef_row = 0;
   \   00000150   1C6087E5           STR      R6,[R7, #+28]
    659                sptr->dirty = FALSE;
   \   00000154   246087E5           STR      R6,[R7, #+36]
    660              }
    661            }
   \                     ??realize_virt_arrays_9:
   \   00000158   2C7097E5           LDR      R7,[R7, #+44]
   \   0000015C   000057E3           CMP      R7,#+0
   \   00000160   DDFFFF1A           BNE      ??realize_virt_arrays_8
    662          
    663            for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
   \                     ??realize_virt_arrays_7:
   \   00000164   487095E5           LDR      R7,[R5, #+72]
   \   00000168   000057E3           CMP      R7,#+0
   \   0000016C   F083BD08           POPEQ    {R4-R9,PC}
    664              if (bptr->mem_buffer == NULL) { /* if not realized yet */
   \                     ??realize_virt_arrays_11:
   \   00000170   000097E5           LDR      R0,[R7, #+0]
   \   00000174   000050E3           CMP      R0,#+0
   \   00000178   1C00001A           BNE      ??realize_virt_arrays_12
    665                minheights = ((long) bptr->rows_in_array - 1L) / bptr->maxaccess + 1L;
    666                if (minheights <= max_minheights) {
   \   0000017C   0C3097E5           LDR      R3,[R7, #+12]
   \   00000180   042097E5           LDR      R2,[R7, #+4]
   \   00000184   0310A0E1           MOV      R1,R3
   \   00000188   010042E2           SUB      R0,R2,#+1
   \   0000018C   ........           _BLF     ??divu32_a,??rA??divu32_a
   \   00000190   010081E2           ADD      R0,R1,#+1
   \   00000194   000058E1           CMP      R8,R0
    667          	/* This buffer fits in memory */
    668          	bptr->rows_in_mem = bptr->rows_in_array;
   \   00000198   102087A5           STRGE    R2,[R7, #+16]
   \   0000019C   080000AA           BGE      ??realize_virt_arrays_13
    669                } else {
    670          	/* It doesn't fit in memory, create backing store. */
    671          	bptr->rows_in_mem = (JDIMENSION) (max_minheights * bptr->maxaccess);
   \   000001A0   930800E0           MUL      R0,R3,R8
   \   000001A4   100087E5           STR      R0,[R7, #+16]
    672          	jpeg_open_backing_store(cinfo, & bptr->b_s_info,
    673          				(long) bptr->rows_in_array *
    674          				(long) bptr->blocksperrow *
    675          				(long) SIZEOF(JBLOCK));
   \   000001A8   080097E5           LDR      R0,[R7, #+8]
   \   000001AC   900201E0           MUL      R1,R0,R2
   \   000001B0   0400A0E1           MOV      R0,R4
   \   000001B4   8123A0E1           LSL      R2,R1,#+7
   \   000001B8   301087E2           ADD      R1,R7,#+48
   \   000001BC   ........           _BLF     jpeg_open_backing_store,??jpeg_open_backing_store??rA
    676          	bptr->b_s_open = TRUE;
   \   000001C0   289087E5           STR      R9,[R7, #+40]
    677                }
    678                bptr->mem_buffer = alloc_barray(cinfo, JPOOL_IMAGE,
    679          				      bptr->blocksperrow, bptr->rows_in_mem);
   \                     ??realize_virt_arrays_13:
   \   000001C4   103097E5           LDR      R3,[R7, #+16]
   \   000001C8   082097E5           LDR      R2,[R7, #+8]
   \   000001CC   0110A0E3           MOV      R1,#+1
   \   000001D0   0400A0E1           MOV      R0,R4
   \   000001D4   ........           BL       alloc_barray
   \   000001D8   000087E5           STR      R0,[R7, #+0]
    680                bptr->rowsperchunk = mem->last_rowsperchunk;
   \   000001DC   500095E5           LDR      R0,[R5, #+80]
   \   000001E0   140087E5           STR      R0,[R7, #+20]
    681                bptr->cur_start_row = 0;
   \   000001E4   186087E5           STR      R6,[R7, #+24]
    682                bptr->first_undef_row = 0;
   \   000001E8   1C6087E5           STR      R6,[R7, #+28]
    683                bptr->dirty = FALSE;
   \   000001EC   246087E5           STR      R6,[R7, #+36]
    684              }
    685            }
   \                     ??realize_virt_arrays_12:
   \   000001F0   2C7097E5           LDR      R7,[R7, #+44]
   \   000001F4   000057E3           CMP      R7,#+0
   \   000001F8   DCFFFF1A           BNE      ??realize_virt_arrays_11
   \   000001FC   F083BDE8           POP      {R4-R9,PC}       ;; return
    686          }
    687          
    688          

   \                                 In segment CODE, align 4, keep-with-next
    689          LOCAL(void)
    690          do_sarray_io (j_common_ptr cinfo, jvirt_sarray_ptr ptr, boolean writing)
    691          /* Do backing store read or write of a virtual sample array */
    692          {
   \                     do_sarray_io:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    693            long bytesperrow, file_offset, byte_count, rows, thisrow, i;
    694          
    695            bytesperrow = (long) ptr->samplesperrow * SIZEOF(JSAMPLE);
   \   0000000C   087095E5           LDR      R7,[R5, #+8]
    696            file_offset = ptr->cur_start_row * bytesperrow;
   \   00000010   180095E5           LDR      R0,[R5, #+24]
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   970008E0           MUL      R8,R7,R0
    697            /* Loop to read or write each allocation chunk in mem_buffer */
    698            for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
   \   0000001C   0090A0E3           MOV      R9,#+0
   \   00000020   050000EA           B        ??do_sarray_io_0
    699              /* One chunk, but check for short chunk at end of buffer */
    700              rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
    701              /* Transfer no more than is currently defined */
    702              thisrow = (long) ptr->cur_start_row + i;
    703              rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
    704              /* Transfer no more than fits in file */
    705              rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
    706              if (rows <= 0)		/* this chunk might be past end of file! */
    707                break;
    708              byte_count = rows * bytesperrow;
    709              if (writing)
    710                (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
    711          					    (void FAR *) ptr->mem_buffer[i],
    712          					    file_offset, byte_count);
    713              else
    714                (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
    715          					   (void FAR *) ptr->mem_buffer[i],
    716          					   file_offset, byte_count);
   \                     ??do_sarray_io_1:
   \   00000024   30C095E5           LDR      R12,[R5, #+48]
   \   00000028   3CFF2FE1           BLX      R12
   \                     ??do_sarray_io_2:
   \   0000002C   04D08DE2           ADD      SP,SP,#+4
    717              file_offset += byte_count;
   \   00000030   140095E5           LDR      R0,[R5, #+20]
   \   00000034   08808AE0           ADD      R8,R10,R8
   \   00000038   099080E0           ADD      R9,R0,R9
   \                     ??do_sarray_io_0:
   \   0000003C   100095E5           LDR      R0,[R5, #+16]
   \   00000040   000059E1           CMP      R9,R0
   \   00000044   F087BDA8           POPGE    {R4-R10,PC}
   \   00000048   141095E5           LDR      R1,[R5, #+20]
   \   0000004C   1C2095E5           LDR      R2,[R5, #+28]
   \   00000050   090040E0           SUB      R0,R0,R9
   \   00000054   000051E1           CMP      R1,R0
   \   00000058   0100A0B1           MOVLT    R0,R1
   \   0000005C   181095E5           LDR      R1,[R5, #+24]
   \   00000060   011089E0           ADD      R1,R9,R1
   \   00000064   012042E0           SUB      R2,R2,R1
   \   00000068   020050E1           CMP      R0,R2
   \   0000006C   0200A0A1           MOVGE    R0,R2
   \   00000070   042095E5           LDR      R2,[R5, #+4]
   \   00000074   011042E0           SUB      R1,R2,R1
   \   00000078   010050E1           CMP      R0,R1
   \   0000007C   0100A0A1           MOVGE    R0,R1
   \   00000080   010050E3           CMP      R0,#+1
   \   00000084   F087BDB8           POPLT    {R4-R10,PC}
   \   00000088   97000AE0           MUL      R10,R7,R0
   \   0000008C   000095E5           LDR      R0,[R5, #+0]
   \   00000090   0A10A0E1           MOV      R1,R10
   \   00000094   02002DE9           PUSH     {R1}
   \   00000098   090180E0           ADD      R0,R0,R9, LSL #+2
   \   0000009C   002090E5           LDR      R2,[R0, #+0]
   \   000000A0   000056E3           CMP      R6,#+0
   \   000000A4   0830A0E1           MOV      R3,R8
   \   000000A8   301085E2           ADD      R1,R5,#+48
   \   000000AC   0400A0E1           MOV      R0,R4
   \   000000B0   DBFFFF0A           BEQ      ??do_sarray_io_1
   \   000000B4   34C095E5           LDR      R12,[R5, #+52]
   \   000000B8   3CFF2FE1           BLX      R12
   \   000000BC   DAFFFFEA           B        ??do_sarray_io_2
    718            }
    719          }
    720          
    721          

   \                                 In segment CODE, align 4, keep-with-next
    722          LOCAL(void)
    723          do_barray_io (j_common_ptr cinfo, jvirt_barray_ptr ptr, boolean writing)
    724          /* Do backing store read or write of a virtual coefficient-block array */
    725          {
   \                     do_barray_io:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    726            long bytesperrow, file_offset, byte_count, rows, thisrow, i;
    727          
    728            bytesperrow = (long) ptr->blocksperrow * SIZEOF(JBLOCK);
   \   0000000C   080095E5           LDR      R0,[R5, #+8]
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   8073A0E1           LSL      R7,R0,#+7
    729            file_offset = ptr->cur_start_row * bytesperrow;
   \   00000018   180095E5           LDR      R0,[R5, #+24]
    730            /* Loop to read or write each allocation chunk in mem_buffer */
    731            for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
   \   0000001C   0090A0E3           MOV      R9,#+0
   \   00000020   970008E0           MUL      R8,R7,R0
   \   00000024   050000EA           B        ??do_barray_io_0
    732              /* One chunk, but check for short chunk at end of buffer */
    733              rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
    734              /* Transfer no more than is currently defined */
    735              thisrow = (long) ptr->cur_start_row + i;
    736              rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
    737              /* Transfer no more than fits in file */
    738              rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
    739              if (rows <= 0)		/* this chunk might be past end of file! */
    740                break;
    741              byte_count = rows * bytesperrow;
    742              if (writing)
    743                (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
    744          					    (void FAR *) ptr->mem_buffer[i],
    745          					    file_offset, byte_count);
    746              else
    747                (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
    748          					   (void FAR *) ptr->mem_buffer[i],
    749          					   file_offset, byte_count);
   \                     ??do_barray_io_1:
   \   00000028   30C095E5           LDR      R12,[R5, #+48]
   \   0000002C   3CFF2FE1           BLX      R12
   \                     ??do_barray_io_2:
   \   00000030   04D08DE2           ADD      SP,SP,#+4
    750              file_offset += byte_count;
   \   00000034   140095E5           LDR      R0,[R5, #+20]
   \   00000038   08808AE0           ADD      R8,R10,R8
   \   0000003C   099080E0           ADD      R9,R0,R9
   \                     ??do_barray_io_0:
   \   00000040   100095E5           LDR      R0,[R5, #+16]
   \   00000044   000059E1           CMP      R9,R0
   \   00000048   F087BDA8           POPGE    {R4-R10,PC}
   \   0000004C   141095E5           LDR      R1,[R5, #+20]
   \   00000050   1C2095E5           LDR      R2,[R5, #+28]
   \   00000054   090040E0           SUB      R0,R0,R9
   \   00000058   000051E1           CMP      R1,R0
   \   0000005C   0100A0B1           MOVLT    R0,R1
   \   00000060   181095E5           LDR      R1,[R5, #+24]
   \   00000064   011089E0           ADD      R1,R9,R1
   \   00000068   012042E0           SUB      R2,R2,R1
   \   0000006C   020050E1           CMP      R0,R2
   \   00000070   0200A0A1           MOVGE    R0,R2
   \   00000074   042095E5           LDR      R2,[R5, #+4]
   \   00000078   011042E0           SUB      R1,R2,R1
   \   0000007C   010050E1           CMP      R0,R1
   \   00000080   0100A0A1           MOVGE    R0,R1
   \   00000084   010050E3           CMP      R0,#+1
   \   00000088   F087BDB8           POPLT    {R4-R10,PC}
   \   0000008C   97000AE0           MUL      R10,R7,R0
   \   00000090   000095E5           LDR      R0,[R5, #+0]
   \   00000094   0A10A0E1           MOV      R1,R10
   \   00000098   02002DE9           PUSH     {R1}
   \   0000009C   090180E0           ADD      R0,R0,R9, LSL #+2
   \   000000A0   002090E5           LDR      R2,[R0, #+0]
   \   000000A4   000056E3           CMP      R6,#+0
   \   000000A8   0830A0E1           MOV      R3,R8
   \   000000AC   301085E2           ADD      R1,R5,#+48
   \   000000B0   0400A0E1           MOV      R0,R4
   \   000000B4   DBFFFF0A           BEQ      ??do_barray_io_1
   \   000000B8   34C095E5           LDR      R12,[R5, #+52]
   \   000000BC   3CFF2FE1           BLX      R12
   \   000000C0   DAFFFFEA           B        ??do_barray_io_2
    751            }
    752          }
    753          
    754          

   \                                 In segment CODE, align 4, keep-with-next
    755          METHODDEF(JSAMPARRAY)
    756          access_virt_sarray (j_common_ptr cinfo, jvirt_sarray_ptr ptr,
    757          		    JDIMENSION start_row, JDIMENSION num_rows,
    758          		    boolean writable)
    759          /* Access the part of a virtual sample array starting at start_row */
    760          /* and extending for num_rows rows.  writable is true if  */
    761          /* caller intends to modify the accessed area. */
    762          {
   \                     access_virt_sarray:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   20709DE5           LDR      R7,[SP, #+32]
   \   0000000C   0150A0E1           MOV      R5,R1
    763            JDIMENSION end_row = start_row + num_rows;
    764            JDIMENSION undef_row;
    765          
    766            /* debugging check */
    767            if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
    768                ptr->mem_buffer == NULL)
   \   00000010   040095E5           LDR      R0,[R5, #+4]
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   068083E0           ADD      R8,R3,R6
   \   0000001C   080050E1           CMP      R0,R8
   \   00000020   0C009525           LDRCS    R0,[R5, #+12]
   \   00000024   1790A0E3           MOV      R9,#+23
   \   00000028   03005021           CMPCS    R0,R3
   \   0000002C   0200003A           BCC      ??access_virt_sarray_0
   \   00000030   000095E5           LDR      R0,[R5, #+0]
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   0400001A           BNE      ??access_virt_sarray_1
    769              ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
   \                     ??access_virt_sarray_0:
   \   0000003C   001094E5           LDR      R1,[R4, #+0]
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   149081E5           STR      R9,[R1, #+20]
   \   00000048   001091E5           LDR      R1,[R1, #+0]
   \   0000004C   31FF2FE1           BLX      R1
    770          
    771            /* Make the desired part of the virtual array accessible */
    772            if (start_row < ptr->cur_start_row ||
    773                end_row > ptr->cur_start_row+ptr->rows_in_mem) {
   \                     ??access_virt_sarray_1:
   \   00000050   180095E5           LDR      R0,[R5, #+24]
   \   00000054   000056E1           CMP      R6,R0
   \   00000058   0300003A           BCC      ??access_virt_sarray_2
   \   0000005C   101095E5           LDR      R1,[R5, #+16]
   \   00000060   000081E0           ADD      R0,R1,R0
   \   00000064   080050E1           CMP      R0,R8
   \   00000068   1D00002A           BCS      ??access_virt_sarray_3
    774              if (! ptr->b_s_open)
   \                     ??access_virt_sarray_2:
   \   0000006C   280095E5           LDR      R0,[R5, #+40]
   \   00000070   000050E3           CMP      R0,#+0
   \   00000074   0500001A           BNE      ??access_virt_sarray_4
    775                ERREXIT(cinfo, JERR_VIRTUAL_BUG);
   \   00000078   001094E5           LDR      R1,[R4, #+0]
   \   0000007C   4700A0E3           MOV      R0,#+71
   \   00000080   140081E5           STR      R0,[R1, #+20]
   \   00000084   001091E5           LDR      R1,[R1, #+0]
   \   00000088   0400A0E1           MOV      R0,R4
   \   0000008C   31FF2FE1           BLX      R1
    776              /* Flush old buffer contents if necessary */
    777              if (ptr->dirty) {
   \                     ??access_virt_sarray_4:
   \   00000090   240095E5           LDR      R0,[R5, #+36]
   \   00000094   000050E3           CMP      R0,#+0
   \   00000098   0500000A           BEQ      ??access_virt_sarray_5
    778                do_sarray_io(cinfo, ptr, TRUE);
   \   0000009C   0120A0E3           MOV      R2,#+1
   \   000000A0   0510A0E1           MOV      R1,R5
   \   000000A4   0400A0E1           MOV      R0,R4
   \   000000A8   ........           BL       do_sarray_io
    779                ptr->dirty = FALSE;
   \   000000AC   0000A0E3           MOV      R0,#+0
   \   000000B0   240085E5           STR      R0,[R5, #+36]
    780              }
    781              /* Decide what part of virtual array to access.
    782               * Algorithm: if target address > current window, assume forward scan,
    783               * load starting at target address.  If target address < current window,
    784               * assume backward scan, load so that target area is top of window.
    785               * Note that when switching from forward write to forward read, will have
    786               * start_row = 0, so the limiting case applies and we load from 0 anyway.
    787               */
    788              if (start_row > ptr->cur_start_row) {
   \                     ??access_virt_sarray_5:
   \   000000B4   180095E5           LDR      R0,[R5, #+24]
   \   000000B8   060050E1           CMP      R0,R6
    789                ptr->cur_start_row = start_row;
   \   000000BC   0600A031           MOVCC    R0,R6
   \   000000C0   0200003A           BCC      ??access_virt_sarray_6
    790              } else {
    791                /* use long arithmetic here to avoid overflow & unsigned problems */
    792                long ltemp;
    793          
    794                ltemp = (long) end_row - (long) ptr->rows_in_mem;
   \   000000C4   100095E5           LDR      R0,[R5, #+16]
   \   000000C8   000058E0           SUBS     R0,R8,R0
    795                if (ltemp < 0)
    796          	ltemp = 0;		/* don't fall off front end of file */
   \   000000CC   0000A043           MOVMI    R0,#+0
    797                ptr->cur_start_row = (JDIMENSION) ltemp;
   \                     ??access_virt_sarray_6:
   \   000000D0   180085E5           STR      R0,[R5, #+24]
    798              }
    799              /* Read in the selected part of the array.
    800               * During the initial write pass, we will do no actual read
    801               * because the selected part is all undefined.
    802               */
    803              do_sarray_io(cinfo, ptr, FALSE);
   \   000000D4   0020A0E3           MOV      R2,#+0
   \   000000D8   0510A0E1           MOV      R1,R5
   \   000000DC   0400A0E1           MOV      R0,R4
   \   000000E0   ........           BL       do_sarray_io
    804            }
    805            /* Ensure the accessed part of the array is defined; prezero if needed.
    806             * To improve locality of access, we only prezero the part of the array
    807             * that the caller is about to access, not the entire in-memory array.
    808             */
    809            if (ptr->first_undef_row < end_row) {
   \                     ??access_virt_sarray_3:
   \   000000E4   1CA095E5           LDR      R10,[R5, #+28]
   \   000000E8   08005AE1           CMP      R10,R8
   \   000000EC   1B00002A           BCS      ??access_virt_sarray_7
    810              if (ptr->first_undef_row < start_row) {
   \   000000F0   06005AE1           CMP      R10,R6
   \   000000F4   0700002A           BCS      ??access_virt_sarray_8
    811                if (writable)		/* writer skipped over a section of array */
   \   000000F8   000057E3           CMP      R7,#+0
   \   000000FC   0400000A           BEQ      ??access_virt_sarray_9
    812          	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
   \   00000100   001094E5           LDR      R1,[R4, #+0]
   \   00000104   0400A0E1           MOV      R0,R4
   \   00000108   149081E5           STR      R9,[R1, #+20]
   \   0000010C   001091E5           LDR      R1,[R1, #+0]
   \   00000110   31FF2FE1           BLX      R1
    813                undef_row = start_row;	/* but reader is allowed to read ahead */
   \                     ??access_virt_sarray_9:
   \   00000114   06A0A0E1           MOV      R10,R6
    814              } else {
    815                undef_row = ptr->first_undef_row;
    816              }
    817              if (writable)
   \                     ??access_virt_sarray_8:
   \   00000118   000057E3           CMP      R7,#+0
    818                ptr->first_undef_row = end_row;
   \   0000011C   1C808515           STRNE    R8,[R5, #+28]
    819              if (ptr->pre_zero) {
   \   00000120   200095E5           LDR      R0,[R5, #+32]
   \   00000124   000050E3           CMP      R0,#+0
   \   00000128   1400000A           BEQ      ??access_virt_sarray_10
    820                size_t bytesperrow = (size_t) ptr->samplesperrow * SIZEOF(JSAMPLE);
    821                undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
   \   0000012C   180095E5           LDR      R0,[R5, #+24]
   \   00000130   084095E5           LDR      R4,[R5, #+8]
   \   00000134   00A04AE0           SUB      R10,R10,R0
    822                end_row -= ptr->cur_start_row;
   \   00000138   008048E0           SUB      R8,R8,R0
   \   0000013C   08005AE1           CMP      R10,R8
   \   00000140   0600002A           BCS      ??access_virt_sarray_7
    823                while (undef_row < end_row) {
    824          	jzero_far((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
   \                     ??access_virt_sarray_11:
   \   00000144   000095E5           LDR      R0,[R5, #+0]
   \   00000148   0410A0E1           MOV      R1,R4
   \   0000014C   0A0190E7           LDR      R0,[R0, +R10, LSL #+2]
    825          	undef_row++;
   \   00000150   01A08AE2           ADD      R10,R10,#+1
   \   00000154   ........           _BLF     jzero_far,??jzero_far??rA
    826                }
   \   00000158   08005AE1           CMP      R10,R8
   \   0000015C   F8FFFF3A           BCC      ??access_virt_sarray_11
    827              } else {
    828                if (! writable)		/* reader looking at undefined data */
    829          	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
    830              }
    831            }
    832            /* Flag the buffer dirty if caller will write in it */
    833            if (writable)
   \                     ??access_virt_sarray_7:
   \   00000160   000057E3           CMP      R7,#+0
    834              ptr->dirty = TRUE;
   \   00000164   0100A013           MOVNE    R0,#+1
   \   00000168   24008515           STRNE    R0,[R5, #+36]
    835            /* Return address of proper part of the buffer */
    836            return ptr->mem_buffer + (start_row - ptr->cur_start_row);
   \                     ??access_virt_sarray_12:
   \   0000016C   180095E5           LDR      R0,[R5, #+24]
   \   00000170   001095E5           LDR      R1,[R5, #+0]
   \   00000174   000046E0           SUB      R0,R6,R0
   \   00000178   000181E0           ADD      R0,R1,R0, LSL #+2
   \   0000017C   F087BDE8           POP      {R4-R10,PC}      ;; return
   \                     ??access_virt_sarray_10:
   \   00000180   000057E3           CMP      R7,#+0
   \   00000184   F5FFFF1A           BNE      ??access_virt_sarray_7
   \   00000188   001094E5           LDR      R1,[R4, #+0]
   \   0000018C   0400A0E1           MOV      R0,R4
   \   00000190   149081E5           STR      R9,[R1, #+20]
   \   00000194   001091E5           LDR      R1,[R1, #+0]
   \   00000198   31FF2FE1           BLX      R1
   \   0000019C   F2FFFFEA           B        ??access_virt_sarray_12
    837          }
    838          
    839          

   \                                 In segment CODE, align 4, keep-with-next
    840          METHODDEF(JBLOCKARRAY)
    841          access_virt_barray (j_common_ptr cinfo, jvirt_barray_ptr ptr,
    842          		    JDIMENSION start_row, JDIMENSION num_rows,
    843          		    boolean writable)
    844          /* Access the part of a virtual block array starting at start_row */
    845          /* and extending for num_rows rows.  writable is true if  */
    846          /* caller intends to modify the accessed area. */
    847          {
   \                     access_virt_barray:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   20709DE5           LDR      R7,[SP, #+32]
   \   0000000C   0150A0E1           MOV      R5,R1
    848            JDIMENSION end_row = start_row + num_rows;
    849            JDIMENSION undef_row;
    850          
    851            /* debugging check */
    852            if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
    853                ptr->mem_buffer == NULL)
   \   00000010   040095E5           LDR      R0,[R5, #+4]
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   068083E0           ADD      R8,R3,R6
   \   0000001C   080050E1           CMP      R0,R8
   \   00000020   0C009525           LDRCS    R0,[R5, #+12]
   \   00000024   1790A0E3           MOV      R9,#+23
   \   00000028   03005021           CMPCS    R0,R3
   \   0000002C   0200003A           BCC      ??access_virt_barray_0
   \   00000030   000095E5           LDR      R0,[R5, #+0]
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   0400001A           BNE      ??access_virt_barray_1
    854              ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
   \                     ??access_virt_barray_0:
   \   0000003C   001094E5           LDR      R1,[R4, #+0]
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   149081E5           STR      R9,[R1, #+20]
   \   00000048   001091E5           LDR      R1,[R1, #+0]
   \   0000004C   31FF2FE1           BLX      R1
    855          
    856            /* Make the desired part of the virtual array accessible */
    857            if (start_row < ptr->cur_start_row ||
    858                end_row > ptr->cur_start_row+ptr->rows_in_mem) {
   \                     ??access_virt_barray_1:
   \   00000050   180095E5           LDR      R0,[R5, #+24]
   \   00000054   000056E1           CMP      R6,R0
   \   00000058   0300003A           BCC      ??access_virt_barray_2
   \   0000005C   101095E5           LDR      R1,[R5, #+16]
   \   00000060   000081E0           ADD      R0,R1,R0
   \   00000064   080050E1           CMP      R0,R8
   \   00000068   1D00002A           BCS      ??access_virt_barray_3
    859              if (! ptr->b_s_open)
   \                     ??access_virt_barray_2:
   \   0000006C   280095E5           LDR      R0,[R5, #+40]
   \   00000070   000050E3           CMP      R0,#+0
   \   00000074   0500001A           BNE      ??access_virt_barray_4
    860                ERREXIT(cinfo, JERR_VIRTUAL_BUG);
   \   00000078   001094E5           LDR      R1,[R4, #+0]
   \   0000007C   4700A0E3           MOV      R0,#+71
   \   00000080   140081E5           STR      R0,[R1, #+20]
   \   00000084   001091E5           LDR      R1,[R1, #+0]
   \   00000088   0400A0E1           MOV      R0,R4
   \   0000008C   31FF2FE1           BLX      R1
    861              /* Flush old buffer contents if necessary */
    862              if (ptr->dirty) {
   \                     ??access_virt_barray_4:
   \   00000090   240095E5           LDR      R0,[R5, #+36]
   \   00000094   000050E3           CMP      R0,#+0
   \   00000098   0500000A           BEQ      ??access_virt_barray_5
    863                do_barray_io(cinfo, ptr, TRUE);
   \   0000009C   0120A0E3           MOV      R2,#+1
   \   000000A0   0510A0E1           MOV      R1,R5
   \   000000A4   0400A0E1           MOV      R0,R4
   \   000000A8   ........           BL       do_barray_io
    864                ptr->dirty = FALSE;
   \   000000AC   0000A0E3           MOV      R0,#+0
   \   000000B0   240085E5           STR      R0,[R5, #+36]
    865              }
    866              /* Decide what part of virtual array to access.
    867               * Algorithm: if target address > current window, assume forward scan,
    868               * load starting at target address.  If target address < current window,
    869               * assume backward scan, load so that target area is top of window.
    870               * Note that when switching from forward write to forward read, will have
    871               * start_row = 0, so the limiting case applies and we load from 0 anyway.
    872               */
    873              if (start_row > ptr->cur_start_row) {
   \                     ??access_virt_barray_5:
   \   000000B4   180095E5           LDR      R0,[R5, #+24]
   \   000000B8   060050E1           CMP      R0,R6
    874                ptr->cur_start_row = start_row;
   \   000000BC   0600A031           MOVCC    R0,R6
   \   000000C0   0200003A           BCC      ??access_virt_barray_6
    875              } else {
    876                /* use long arithmetic here to avoid overflow & unsigned problems */
    877                long ltemp;
    878          
    879                ltemp = (long) end_row - (long) ptr->rows_in_mem;
   \   000000C4   100095E5           LDR      R0,[R5, #+16]
   \   000000C8   000058E0           SUBS     R0,R8,R0
    880                if (ltemp < 0)
    881          	ltemp = 0;		/* don't fall off front end of file */
   \   000000CC   0000A043           MOVMI    R0,#+0
    882                ptr->cur_start_row = (JDIMENSION) ltemp;
   \                     ??access_virt_barray_6:
   \   000000D0   180085E5           STR      R0,[R5, #+24]
    883              }
    884              /* Read in the selected part of the array.
    885               * During the initial write pass, we will do no actual read
    886               * because the selected part is all undefined.
    887               */
    888              do_barray_io(cinfo, ptr, FALSE);
   \   000000D4   0020A0E3           MOV      R2,#+0
   \   000000D8   0510A0E1           MOV      R1,R5
   \   000000DC   0400A0E1           MOV      R0,R4
   \   000000E0   ........           BL       do_barray_io
    889            }
    890            /* Ensure the accessed part of the array is defined; prezero if needed.
    891             * To improve locality of access, we only prezero the part of the array
    892             * that the caller is about to access, not the entire in-memory array.
    893             */
    894            if (ptr->first_undef_row < end_row) {
   \                     ??access_virt_barray_3:
   \   000000E4   1CA095E5           LDR      R10,[R5, #+28]
   \   000000E8   08005AE1           CMP      R10,R8
   \   000000EC   1C00002A           BCS      ??access_virt_barray_7
    895              if (ptr->first_undef_row < start_row) {
   \   000000F0   06005AE1           CMP      R10,R6
   \   000000F4   0700002A           BCS      ??access_virt_barray_8
    896                if (writable)		/* writer skipped over a section of array */
   \   000000F8   000057E3           CMP      R7,#+0
   \   000000FC   0400000A           BEQ      ??access_virt_barray_9
    897          	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
   \   00000100   001094E5           LDR      R1,[R4, #+0]
   \   00000104   0400A0E1           MOV      R0,R4
   \   00000108   149081E5           STR      R9,[R1, #+20]
   \   0000010C   001091E5           LDR      R1,[R1, #+0]
   \   00000110   31FF2FE1           BLX      R1
    898                undef_row = start_row;	/* but reader is allowed to read ahead */
   \                     ??access_virt_barray_9:
   \   00000114   06A0A0E1           MOV      R10,R6
    899              } else {
    900                undef_row = ptr->first_undef_row;
    901              }
    902              if (writable)
   \                     ??access_virt_barray_8:
   \   00000118   000057E3           CMP      R7,#+0
    903                ptr->first_undef_row = end_row;
   \   0000011C   1C808515           STRNE    R8,[R5, #+28]
    904              if (ptr->pre_zero) {
   \   00000120   200095E5           LDR      R0,[R5, #+32]
   \   00000124   000050E3           CMP      R0,#+0
   \   00000128   1500000A           BEQ      ??access_virt_barray_10
    905                size_t bytesperrow = (size_t) ptr->blocksperrow * SIZEOF(JBLOCK);
   \   0000012C   080095E5           LDR      R0,[R5, #+8]
   \   00000130   8043A0E1           LSL      R4,R0,#+7
    906                undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
   \   00000134   180095E5           LDR      R0,[R5, #+24]
   \   00000138   00A04AE0           SUB      R10,R10,R0
    907                end_row -= ptr->cur_start_row;
   \   0000013C   008048E0           SUB      R8,R8,R0
   \   00000140   08005AE1           CMP      R10,R8
   \   00000144   0600002A           BCS      ??access_virt_barray_7
    908                while (undef_row < end_row) {
    909          	jzero_far((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
   \                     ??access_virt_barray_11:
   \   00000148   000095E5           LDR      R0,[R5, #+0]
   \   0000014C   0410A0E1           MOV      R1,R4
   \   00000150   0A0190E7           LDR      R0,[R0, +R10, LSL #+2]
    910          	undef_row++;
   \   00000154   01A08AE2           ADD      R10,R10,#+1
   \   00000158   ........           _BLF     jzero_far,??jzero_far??rA
    911                }
   \   0000015C   08005AE1           CMP      R10,R8
   \   00000160   F8FFFF3A           BCC      ??access_virt_barray_11
    912              } else {
    913                if (! writable)		/* reader looking at undefined data */
    914          	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
    915              }
    916            }
    917            /* Flag the buffer dirty if caller will write in it */
    918            if (writable)
   \                     ??access_virt_barray_7:
   \   00000164   000057E3           CMP      R7,#+0
    919              ptr->dirty = TRUE;
   \   00000168   0100A013           MOVNE    R0,#+1
   \   0000016C   24008515           STRNE    R0,[R5, #+36]
    920            /* Return address of proper part of the buffer */
    921            return ptr->mem_buffer + (start_row - ptr->cur_start_row);
   \                     ??access_virt_barray_12:
   \   00000170   180095E5           LDR      R0,[R5, #+24]
   \   00000174   001095E5           LDR      R1,[R5, #+0]
   \   00000178   000046E0           SUB      R0,R6,R0
   \   0000017C   000181E0           ADD      R0,R1,R0, LSL #+2
   \   00000180   F087BDE8           POP      {R4-R10,PC}      ;; return
   \                     ??access_virt_barray_10:
   \   00000184   000057E3           CMP      R7,#+0
   \   00000188   F5FFFF1A           BNE      ??access_virt_barray_7
   \   0000018C   001094E5           LDR      R1,[R4, #+0]
   \   00000190   0400A0E1           MOV      R0,R4
   \   00000194   149081E5           STR      R9,[R1, #+20]
   \   00000198   001091E5           LDR      R1,[R1, #+0]
   \   0000019C   31FF2FE1           BLX      R1
   \   000001A0   F2FFFFEA           B        ??access_virt_barray_12
    922          }
    923          
    924          
    925          /*
    926           * Release all objects belonging to a specified pool.
    927           */
    928          

   \                                 In segment CODE, align 4, keep-with-next
    929          METHODDEF(void)
    930          free_pool (j_common_ptr cinfo, int pool_id)
    931          {
   \                     free_pool:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    932            my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
   \   00000008   045094E5           LDR      R5,[R4, #+4]
   \   0000000C   0170B0E1           MOVS     R7,R1
    933            small_pool_ptr shdr_ptr;
    934            large_pool_ptr lhdr_ptr;
    935            size_t space_freed;
    936          
    937            if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
   \   00000010   0100004A           BMI      ??free_pool_0
   \   00000014   020057E3           CMP      R7,#+2
   \   00000018   080000BA           BLT      ??free_pool_1
    938              ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
   \                     ??free_pool_0:
   \   0000001C   000094E5           LDR      R0,[R4, #+0]
   \   00000020   0F10A0E3           MOV      R1,#+15
   \   00000024   141080E5           STR      R1,[R0, #+20]
   \   00000028   000094E5           LDR      R0,[R4, #+0]
   \   0000002C   187080E5           STR      R7,[R0, #+24]
   \   00000030   001094E5           LDR      R1,[R4, #+0]
   \   00000034   0400A0E1           MOV      R0,R4
   \   00000038   001091E5           LDR      R1,[R1, #+0]
   \   0000003C   31FF2FE1           BLX      R1
    939          
    940          #ifdef MEM_STATS
    941            if (cinfo->err->trace_level > 1)
    942              print_mem_stats(cinfo, pool_id); /* print pool's memory usage statistics */
    943          #endif
    944          
    945            /* If freeing IMAGE pool, close any virtual arrays first */
    946            if (pool_id == JPOOL_IMAGE) {
   \                     ??free_pool_1:
   \   00000040   0060A0E3           MOV      R6,#+0
   \   00000044   010057E3           CMP      R7,#+1
   \   00000048   1D00001A           BNE      ??free_pool_2
    947              jvirt_sarray_ptr sptr;
    948              jvirt_barray_ptr bptr;
    949          
    950              for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
   \   0000004C   448095E5           LDR      R8,[R5, #+68]
   \   00000050   000058E3           CMP      R8,#+0
   \   00000054   0A00000A           BEQ      ??free_pool_3
    951                if (sptr->b_s_open) {	/* there may be no backing store */
   \                     ??free_pool_4:
   \   00000058   280098E5           LDR      R0,[R8, #+40]
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   0400000A           BEQ      ??free_pool_5
    952          	sptr->b_s_open = FALSE;	/* prevent recursive close if error */
   \   00000064   286088E5           STR      R6,[R8, #+40]
    953          	(*sptr->b_s_info.close_backing_store) (cinfo, & sptr->b_s_info);
   \   00000068   382098E5           LDR      R2,[R8, #+56]
   \   0000006C   301088E2           ADD      R1,R8,#+48
   \   00000070   0400A0E1           MOV      R0,R4
   \   00000074   32FF2FE1           BLX      R2
    954                }
    955              }
   \                     ??free_pool_5:
   \   00000078   2C8098E5           LDR      R8,[R8, #+44]
   \   0000007C   000058E3           CMP      R8,#+0
   \   00000080   F4FFFF1A           BNE      ??free_pool_4
    956              mem->virt_sarray_list = NULL;
   \                     ??free_pool_3:
   \   00000084   446085E5           STR      R6,[R5, #+68]
    957              for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
   \   00000088   488095E5           LDR      R8,[R5, #+72]
   \   0000008C   000058E3           CMP      R8,#+0
   \   00000090   0A00000A           BEQ      ??free_pool_6
    958                if (bptr->b_s_open) {	/* there may be no backing store */
   \                     ??free_pool_7:
   \   00000094   280098E5           LDR      R0,[R8, #+40]
   \   00000098   000050E3           CMP      R0,#+0
   \   0000009C   0400000A           BEQ      ??free_pool_8
    959          	bptr->b_s_open = FALSE;	/* prevent recursive close if error */
   \   000000A0   286088E5           STR      R6,[R8, #+40]
    960          	(*bptr->b_s_info.close_backing_store) (cinfo, & bptr->b_s_info);
   \   000000A4   382098E5           LDR      R2,[R8, #+56]
   \   000000A8   301088E2           ADD      R1,R8,#+48
   \   000000AC   0400A0E1           MOV      R0,R4
   \   000000B0   32FF2FE1           BLX      R2
    961                }
    962              }
   \                     ??free_pool_8:
   \   000000B4   2C8098E5           LDR      R8,[R8, #+44]
   \   000000B8   000058E3           CMP      R8,#+0
   \   000000BC   F4FFFF1A           BNE      ??free_pool_7
    963              mem->virt_barray_list = NULL;
   \                     ??free_pool_6:
   \   000000C0   486085E5           STR      R6,[R5, #+72]
    964            }
    965          
    966            /* Release large objects */
    967            lhdr_ptr = mem->large_list[pool_id];
   \                     ??free_pool_2:
   \   000000C4   077185E0           ADD      R7,R5,R7, LSL #+2
   \   000000C8   3C1097E5           LDR      R1,[R7, #+60]
    968            mem->large_list[pool_id] = NULL;
   \   000000CC   3C6087E5           STR      R6,[R7, #+60]
   \   000000D0   000051E3           CMP      R1,#+0
   \   000000D4   0C00000A           BEQ      ??free_pool_9
    969          
    970            while (lhdr_ptr != NULL) {
    971              large_pool_ptr next_lhdr_ptr = lhdr_ptr->hdr.next;
    972              space_freed = lhdr_ptr->hdr.bytes_used +
    973          		  lhdr_ptr->hdr.bytes_left +
    974          		  SIZEOF(large_pool_hdr);
   \                     ??free_pool_10:
   \   000000D8   080091E5           LDR      R0,[R1, #+8]
   \   000000DC   042091E5           LDR      R2,[R1, #+4]
   \   000000E0   008091E5           LDR      R8,[R1, #+0]
   \   000000E4   000082E0           ADD      R0,R2,R0
   \   000000E8   0C9080E2           ADD      R9,R0,#+12
    975              jpeg_free_large(cinfo, (void FAR *) lhdr_ptr, space_freed);
   \   000000EC   0920A0E1           MOV      R2,R9
   \   000000F0   0400A0E1           MOV      R0,R4
   \   000000F4   ........           _BLF     jpeg_free_large,??jpeg_free_large??rA
    976              mem->total_space_allocated -= space_freed;
   \   000000F8   4C0095E5           LDR      R0,[R5, #+76]
    977              lhdr_ptr = next_lhdr_ptr;
   \   000000FC   0810B0E1           MOVS     R1,R8
   \   00000100   090040E0           SUB      R0,R0,R9
   \   00000104   4C0085E5           STR      R0,[R5, #+76]
    978            }
   \   00000108   F2FFFF1A           BNE      ??free_pool_10
    979          
    980            /* Release small objects */
    981            shdr_ptr = mem->small_list[pool_id];
   \                     ??free_pool_9:
   \   0000010C   341097E5           LDR      R1,[R7, #+52]
    982            mem->small_list[pool_id] = NULL;
   \   00000110   346087E5           STR      R6,[R7, #+52]
   \   00000114   000051E3           CMP      R1,#+0
   \   00000118   F083BD08           POPEQ    {R4-R9,PC}
    983          
    984            while (shdr_ptr != NULL) {
    985              small_pool_ptr next_shdr_ptr = shdr_ptr->hdr.next;
    986              space_freed = shdr_ptr->hdr.bytes_used +
    987          		  shdr_ptr->hdr.bytes_left +
    988          		  SIZEOF(small_pool_hdr);
   \                     ??free_pool_11:
   \   0000011C   080091E5           LDR      R0,[R1, #+8]
   \   00000120   042091E5           LDR      R2,[R1, #+4]
   \   00000124   006091E5           LDR      R6,[R1, #+0]
   \   00000128   000082E0           ADD      R0,R2,R0
   \   0000012C   0C9080E2           ADD      R9,R0,#+12
    989              jpeg_free_small(cinfo, (void *) shdr_ptr, space_freed);
   \   00000130   0920A0E1           MOV      R2,R9
   \   00000134   0400A0E1           MOV      R0,R4
   \   00000138   ........           _BLF     jpeg_free_small,??jpeg_free_small??rA
    990              mem->total_space_allocated -= space_freed;
   \   0000013C   4C0095E5           LDR      R0,[R5, #+76]
    991              shdr_ptr = next_shdr_ptr;
   \   00000140   0610B0E1           MOVS     R1,R6
   \   00000144   090040E0           SUB      R0,R0,R9
   \   00000148   4C0085E5           STR      R0,[R5, #+76]
    992            }
   \   0000014C   F2FFFF1A           BNE      ??free_pool_11
    993          }
   \   00000150   F083BDE8           POP      {R4-R9,PC}       ;; return
    994          
    995          
    996          /*
    997           * Close up shop entirely.
    998           * Note that this cannot be called unless cinfo->mem is non-NULL.
    999           */
   1000          

   \                                 In segment CODE, align 4, keep-with-next
   1001          METHODDEF(void)
   1002          self_destruct (j_common_ptr cinfo)
   1003          {
   \                     self_destruct:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1004            int pool;
   1005          
   1006            /* Close all backing store, release all memory.
   1007             * Releasing pools in reverse order might help avoid fragmentation
   1008             * with some (brain-damaged) malloc libraries.
   1009             */
   1010            for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
   \   00000008   0150A0E3           MOV      R5,#+1
   1011              free_pool(cinfo, pool);
   \                     ??self_destruct_0:
   \   0000000C   0510A0E1           MOV      R1,R5
   \   00000010   0400A0E1           MOV      R0,R4
   \   00000014   ........           BL       free_pool
   1012            }
   \   00000018   015055E2           SUBS     R5,R5,#+1
   \   0000001C   FAFFFF5A           BPL      ??self_destruct_0
   1013          
   1014            /* Release the memory manager control block too. */
   1015            jpeg_free_small(cinfo, (void *) cinfo->mem, SIZEOF(my_memory_mgr));
   \   00000020   041094E5           LDR      R1,[R4, #+4]
   \   00000024   5420A0E3           MOV      R2,#+84
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           _BLF     jpeg_free_small,??jpeg_free_small??rA
   1016            cinfo->mem = NULL;		/* ensures I will be called only once */
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   040084E5           STR      R0,[R4, #+4]
   1017          
   1018            jpeg_mem_term(cinfo);		/* system-dependent cleanup */
   \   00000038   0400A0E1           MOV      R0,R4
   \   0000003C   3040BDE8           POP      {R4,R5,LR}       ;; Pop
   \   00000040   ........           _BF      jpeg_mem_term,??jpeg_mem_term??rA  ;; tailcall
   1019          }
   1020          
   1021          
   1022          /*
   1023           * Memory manager initialization.
   1024           * When this is called, only the error manager pointer is valid in cinfo!
   1025           */
   1026          

   \                                 In segment CODE, align 4, keep-with-next
   1027          GLOBAL(void)
   1028          jinit_memory_mgr (j_common_ptr cinfo)
   1029          {
   \                     jinit_memory_mgr:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1030            my_mem_ptr mem;
   1031            long max_to_use;
   1032            int pool;
   1033            size_t test_mac;
   1034          
   1035            cinfo->mem = NULL;		/* for safety if init fails */
   \   00000008   0050A0E3           MOV      R5,#+0
   \   0000000C   045084E5           STR      R5,[R4, #+4]
   1036          
   1037            /* Check for configuration errors.
   1038             * SIZEOF(ALIGN_TYPE) should be a power of 2; otherwise, it probably
   1039             * doesn't reflect any real hardware alignment requirement.
   1040             * The test is a little tricky: for X>0, X and X-1 have no one-bits
   1041             * in common if and only if X is a power of 2, ie has only one one-bit.
   1042             * Some compilers may give an "unreachable code" warning here; ignore it.
   1043             */
   1044            if ((SIZEOF(ALIGN_TYPE) & (SIZEOF(ALIGN_TYPE)-1)) != 0)
   1045              ERREXIT(cinfo, JERR_BAD_ALIGN_TYPE);
   1046            /* MAX_ALLOC_CHUNK must be representable as type size_t, and must be
   1047             * a multiple of SIZEOF(ALIGN_TYPE).
   1048             * Again, an "unreachable code" warning may be ignored here.
   1049             * But a "constant too large" warning means you need to fix MAX_ALLOC_CHUNK.
   1050             */
   1051            test_mac = (size_t) MAX_ALLOC_CHUNK;
   1052            if ((long) test_mac != MAX_ALLOC_CHUNK ||
   1053                (MAX_ALLOC_CHUNK % SIZEOF(ALIGN_TYPE)) != 0)
   1054              ERREXIT(cinfo, JERR_BAD_ALLOC_CHUNK);
   1055          
   1056            max_to_use = jpeg_mem_init(cinfo); /* system-dependent initialization */
   \   00000010   ........           _BLF     jpeg_mem_init,??jpeg_mem_init??rA
   \   00000014   0070A0E1           MOV      R7,R0
   1057          
   1058            /* Attempt to allocate memory manager's control block */
   1059            mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));
   \   00000018   5410A0E3           MOV      R1,#+84
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           _BLF     jpeg_get_small,??jpeg_get_small??rA
   \   00000024   0060B0E1           MOVS     R6,R0
   1060          
   1061            if (mem == NULL) {
   \   00000028   0800001A           BNE      ??jinit_memory_mgr_0
   1062              jpeg_mem_term(cinfo);	/* system-dependent cleanup */
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           _BLF     jpeg_mem_term,??jpeg_mem_term??rA
   1063              ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 0);
   \   00000034   001094E5           LDR      R1,[R4, #+0]
   \   00000038   3800A0E3           MOV      R0,#+56
   \   0000003C   140081E5           STR      R0,[R1, #+20]
   \   00000040   185081E5           STR      R5,[R1, #+24]
   \   00000044   001091E5           LDR      R1,[R1, #+0]
   \   00000048   0400A0E1           MOV      R0,R4
   \   0000004C   31FF2FE1           BLX      R1
   1064            }
   1065          
   1066            /* OK, fill in the method pointers */
   1067            mem->pub.alloc_small = alloc_small;
   \                     ??jinit_memory_mgr_0:
   \   00000050   8C009FE5           LDR      R0,??jinit_memory_mgr_1  ;; alloc_small
   \   00000054   000086E5           STR      R0,[R6, #+0]
   1068            mem->pub.alloc_large = alloc_large;
   \   00000058   88009FE5           LDR      R0,??jinit_memory_mgr_1+0x4  ;; alloc_large
   \   0000005C   040086E5           STR      R0,[R6, #+4]
   1069            mem->pub.alloc_sarray = alloc_sarray;
   \   00000060   84009FE5           LDR      R0,??jinit_memory_mgr_1+0x8  ;; alloc_sarray
   \   00000064   080086E5           STR      R0,[R6, #+8]
   1070            mem->pub.alloc_barray = alloc_barray;
   \   00000068   80009FE5           LDR      R0,??jinit_memory_mgr_1+0xC  ;; alloc_barray
   \   0000006C   0C0086E5           STR      R0,[R6, #+12]
   1071            mem->pub.request_virt_sarray = request_virt_sarray;
   \   00000070   7C009FE5           LDR      R0,??jinit_memory_mgr_1+0x10  ;; request_virt_sarray
   \   00000074   100086E5           STR      R0,[R6, #+16]
   1072            mem->pub.request_virt_barray = request_virt_barray;
   \   00000078   78009FE5           LDR      R0,??jinit_memory_mgr_1+0x14  ;; request_virt_barray
   \   0000007C   140086E5           STR      R0,[R6, #+20]
   1073            mem->pub.realize_virt_arrays = realize_virt_arrays;
   \   00000080   74009FE5           LDR      R0,??jinit_memory_mgr_1+0x18  ;; realize_virt_arrays
   \   00000084   180086E5           STR      R0,[R6, #+24]
   1074            mem->pub.access_virt_sarray = access_virt_sarray;
   \   00000088   70009FE5           LDR      R0,??jinit_memory_mgr_1+0x1C  ;; access_virt_sarray
   \   0000008C   1C0086E5           STR      R0,[R6, #+28]
   1075            mem->pub.access_virt_barray = access_virt_barray;
   \   00000090   6C009FE5           LDR      R0,??jinit_memory_mgr_1+0x20  ;; access_virt_barray
   \   00000094   200086E5           STR      R0,[R6, #+32]
   1076            mem->pub.free_pool = free_pool;
   \   00000098   68009FE5           LDR      R0,??jinit_memory_mgr_1+0x24  ;; free_pool
   \   0000009C   240086E5           STR      R0,[R6, #+36]
   1077            mem->pub.self_destruct = self_destruct;
   \   000000A0   64009FE5           LDR      R0,??jinit_memory_mgr_1+0x28  ;; self_destruct
   \   000000A4   280086E5           STR      R0,[R6, #+40]
   1078          
   1079            /* Make MAX_ALLOC_CHUNK accessible to other modules */
   1080            mem->pub.max_alloc_chunk = MAX_ALLOC_CHUNK;
   \   000000A8   ........           LDR      R0,??DataTable6  ;; 0x3b9aca00
   \   000000AC   300086E5           STR      R0,[R6, #+48]
   1081          
   1082            /* Initialize working state */
   1083            mem->pub.max_memory_to_use = max_to_use;
   \   000000B0   2C7086E5           STR      R7,[R6, #+44]
   1084          
   1085            for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
   \   000000B4   0100A0E3           MOV      R0,#+1
   1086              mem->small_list[pool] = NULL;
   \                     ??jinit_memory_mgr_2:
   \   000000B8   001186E0           ADD      R1,R6,R0, LSL #+2
   \   000000BC   345081E5           STR      R5,[R1, #+52]
   1087              mem->large_list[pool] = NULL;
   \   000000C0   3C5081E5           STR      R5,[R1, #+60]
   1088            }
   \   000000C4   010050E2           SUBS     R0,R0,#+1
   \   000000C8   FAFFFF5A           BPL      ??jinit_memory_mgr_2
   1089            mem->virt_sarray_list = NULL;
   \   000000CC   445086E5           STR      R5,[R6, #+68]
   1090            mem->virt_barray_list = NULL;
   \   000000D0   485086E5           STR      R5,[R6, #+72]
   1091          
   1092            mem->total_space_allocated = SIZEOF(my_memory_mgr);
   \   000000D4   5400A0E3           MOV      R0,#+84
   \   000000D8   4C0086E5           STR      R0,[R6, #+76]
   1093          
   1094            /* Declare ourselves open for business */
   1095            cinfo->mem = & mem->pub;
   \   000000DC   046084E5           STR      R6,[R4, #+4]
   1096          
   1097            /* Check for an environment variable JPEGMEM; if found, override the
   1098             * default max_memory setting from jpeg_mem_init.  Note that the
   1099             * surrounding application may again override this value.
   1100             * If your system doesn't support getenv(), define NO_GETENV to disable
   1101             * this feature.
   1102             */
   1103          #ifndef NO_GETENV
   1104            /*{
   1105              char * memenv;
   1106          
   1107              if ((memenv = getenv("JPEGMEM")) != NULL)
   1108              {
   1109                char ch = 'x';
   1110          
   1111                if (sscanf(memenv, "%ld%c", &max_to_use, &ch) > 0) {
   1112          	if (ch == 'm' || ch == 'M')
   1113          	  max_to_use *= 1000L;
   1114          	mem->pub.max_memory_to_use = max_to_use * 1000L;
   1115                }
   1116              }
   1117            }*/ //???
   1118          #endif
   1119          
   1120          }
   \   000000E0   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??jinit_memory_mgr_1:
   \   000000E4   ........           DC32     alloc_small
   \   000000E8   ........           DC32     alloc_large
   \   000000EC   ........           DC32     alloc_sarray
   \   000000F0   ........           DC32     alloc_barray
   \   000000F4   ........           DC32     request_virt_sarray
   \   000000F8   ........           DC32     request_virt_barray
   \   000000FC   ........           DC32     realize_virt_arrays
   \   00000100   ........           DC32     access_virt_sarray
   \   00000104   ........           DC32     access_virt_barray
   \   00000108   ........           DC32     free_pool
   \   0000010C   ........           DC32     self_destruct

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   F5C99A3B           DC32     0x3b9ac9f5

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   F4C99A3B           DC32     0x3b9ac9f4

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   00CA9A3B           DC32     0x3b9aca00

   Maximum stack usage in bytes:

     Function            CSTACK
     --------            ------
     access_virt_barray     32
     access_virt_sarray     32
     alloc_barray           32
     alloc_large            28
     alloc_sarray           32
     alloc_small            40
     do_barray_io           36
     do_sarray_io           36
     free_pool              28
     jinit_memory_mgr       20
     realize_virt_arrays    28
     request_virt_barray    32
     request_virt_sarray    32
     self_destruct          12


   Segment part sizes:

     Function/Label      Bytes
     --------------      -----
     first_pool_slop        8
     extra_pool_slop        8
     alloc_small          400
     alloc_large          244
     alloc_sarray         200
     alloc_barray         204
     request_virt_sarray  136
     request_virt_barray  136
     realize_virt_arrays  512
     do_sarray_io         192
     do_barray_io         196
     access_virt_sarray   416
     access_virt_barray   420
     free_pool            340
     self_destruct         68
     jinit_memory_mgr     272
     ??DataTable2           4
     ??DataTable4           4
     ??DataTable6           4
      Others              188

 
 3 936 bytes in segment CODE
    16 bytes in segment DATA_C
 
 3 748 bytes of CODE  memory (+ 188 bytes shared)
    16 bytes of CONST memory

Errors: none
Warnings: none
