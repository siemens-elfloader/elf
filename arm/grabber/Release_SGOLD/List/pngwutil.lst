##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    19/Jan/2011  13:20:28 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\grabber\pnglib\pngwutil.c                     #
#    Command line    =  C:\arm\grabber\pnglib\pngwutil.c -lC                 #
#                       C:\arm\grabber\Release_SGOLD\List\ -o                #
#                       C:\arm\grabber\Release_SGOLD\Obj\ -s9 --no_unroll    #
#                       --no_clustering --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --fpu None --dlib_config "C:\arm2\Embedded           #
#                       Workbench 4.0 Evaluation\ARM\LIB\dl5tpainl8n.h" -I   #
#                       "C:\arm2\Embedded Workbench 4.0                      #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  C:\arm\grabber\Release_SGOLD\List\pngwutil.lst       #
#    Object file     =  C:\arm\grabber\Release_SGOLD\Obj\pngwutil.r79        #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\grabber\pnglib\pngwutil.c
      1          
      2          /* pngwutil.c - utilities to write a PNG file
      3           *
      4           * libpng 1.2.1 - December 12, 2001
      5           * For conditions of distribution and use, see copyright notice in png.h
      6           * Copyright (c) 1998-2001 Glenn Randers-Pehrson
      7           * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
      8           * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
      9           */
     10          
     11          #define PNG_INTERNAL
     12          #include "../pnglib/png.h"

  int CRYPTO_set_mem_functions(void *(*m)(size_t),void *(*r)(void *,size_t), void (*f)(void *));
                                          ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\crypto.h",298  Error[Pe092]: 
          identifier-list parameters may only be used in a function definition

  int CRYPTO_set_mem_functions(void *(*m)(size_t),void *(*r)(void *,size_t), void (*f)(void *));
                                                                    ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\crypto.h",298  Error[Pe020]: 
          identifier "size_t" is undefined

  int CRYPTO_set_locked_mem_functions(void *(*m)(size_t), void (*free_func)(void *));
                                                 ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\crypto.h",299  Error[Pe092]: 
          identifier-list parameters may only be used in a function definition

  void CRYPTO_get_mem_functions(void *(**m)(size_t),void *(**r)(void *, size_t), void (**f)(void *));
                                            ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\crypto.h",301  Error[Pe092]: 
          identifier-list parameters may only be used in a function definition

  void CRYPTO_get_mem_functions(void *(**m)(size_t),void *(**r)(void *, size_t), void (**f)(void *));
                                                                        ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\crypto.h",301  Error[Pe020]: 
          identifier "size_t" is undefined

  void CRYPTO_get_locked_mem_functions(void *(**m)(size_t), void (**f)(void *));
                                                   ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\crypto.h",302  Error[Pe092]: 
          identifier-list parameters may only be used in a function definition

  __swi __arm void *calloc(size_t nelem, size_t elsize);
                           ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",1623  Error[Pe020]: 
          identifier "size_t" is undefined

  __swi __arm void *calloc(size_t nelem, size_t elsize);
                                         ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",1623  Error[Pe020]: 
          identifier "size_t" is undefined

  __swi __arm png_structp png_create_read_struct(png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warn_fn);
              ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2236  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm png_structp png_create_read_struct(png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warn_fn);
                                                 ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2236  Error[Pe020]: 
          identifier "png_const_charp" is undefined

  __swi __arm png_structp png_create_read_struct(png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warn_fn);
                                                                               ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2236  Error[Pe020]: 
          identifier "png_voidp" is undefined

  __swi __arm png_structp png_create_read_struct(png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warn_fn);
                                                                                                    ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2236  Error[Pe020]: 
          identifier "png_error_ptr" is undefined

  __swi __arm png_structp png_create_read_struct(png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warn_fn);
                                                                                                                            ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2236  Error[Pe020]: 
          identifier "png_error_ptr" is undefined

  __swi __arm png_infop png_create_info_struct(png_structp png_ptr);
              ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2241  Error[Pe020]: 
          identifier "png_infop" is undefined

  __swi __arm png_infop png_create_info_struct(png_structp png_ptr);
                                               ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2241  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_destroy_read_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr, png_infopp end_info_ptr_ptr);
                                           ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2246  Error[Pe020]: 
          identifier "png_structpp" is undefined

  __swi __arm void png_destroy_read_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr, png_infopp end_info_ptr_ptr);
                                                                     ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2246  Error[Pe020]: 
          identifier "png_infopp" is undefined

  __swi __arm void png_destroy_read_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr, png_infopp end_info_ptr_ptr);
                                                                                              ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2246  Error[Pe020]: 
          identifier "png_infopp" is undefined

  __swi __arm void png_set_sig_bytes(png_structp png_ptr,int num_bytes);
                                     ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2251  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_read_info(png_structp png_ptr, png_infop info_ptr);
                                 ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2256  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_read_info(png_structp png_ptr, png_infop info_ptr);
                                                      ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2256  Error[Pe020]: 
          identifier "png_infop" is undefined

  __swi __arm png_uint_32 png_get_IHDR(png_structp png_ptr,png_infop info_ptr, png_uint_32 *width, png_uint_32 *height, int *bit_depth, int *color_type, int *interlace_method, int *compression_method, int *filter_method);
              ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2261  Error[Pe020]: 
          identifier "png_uint_32" is undefined

  __swi __arm png_uint_32 png_get_IHDR(png_structp png_ptr,png_infop info_ptr, png_uint_32 *width, png_uint_32 *height, int *bit_depth, int *color_type, int *interlace_method, int *compression_method, int *filter_method);
                                       ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2261  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm png_uint_32 png_get_IHDR(png_structp png_ptr,png_infop info_ptr, png_uint_32 *width, png_uint_32 *height, int *bit_depth, int *color_type, int *interlace_method, int *compression_method, int *filter_method);
                                                           ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2261  Error[Pe020]: 
          identifier "png_infop" is undefined

  __swi __arm png_uint_32 png_get_IHDR(png_structp png_ptr,png_infop info_ptr, png_uint_32 *width, png_uint_32 *height, int *bit_depth, int *color_type, int *interlace_method, int *compression_method, int *filter_method);
                                                                               ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2261  Error[Pe020]: 
          identifier "png_uint_32" is undefined

  __swi __arm png_uint_32 png_get_IHDR(png_structp png_ptr,png_infop info_ptr, png_uint_32 *width, png_uint_32 *height, int *bit_depth, int *color_type, int *interlace_method, int *compression_method, int *filter_method);
                                                                                                   ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2261  Error[Pe020]: 
          identifier "png_uint_32" is undefined

  __swi __arm png_voidp png_malloc(png_structp png_ptr, png_uint_32 size);
              ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2266  Error[Pe020]: 
          identifier "png_voidp" is undefined

  __swi __arm png_voidp png_malloc(png_structp png_ptr, png_uint_32 size);
                                   ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2266  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm png_voidp png_malloc(png_structp png_ptr, png_uint_32 size);
                                                        ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2266  Error[Pe020]: 
          identifier "png_uint_32" is undefined

  __swi __arm void png_read_image(png_structp png_ptr, png_bytepp image);
                                  ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2271  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_read_image(png_structp png_ptr, png_bytepp image);
                                                       ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2271  Error[Pe020]: 
          identifier "png_bytepp" is undefined

  __swi __arm void png_read_end(png_structp png_ptr, png_infop info_ptr);
                                ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2276  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_read_end(png_structp png_ptr, png_infop info_ptr);
                                                     ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2276  Error[Pe020]: 
          identifier "png_infop" is undefined

  __swi __arm png_voidp png_get_io_ptr(png_structp png_ptr);
              ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2281  Error[Pe020]: 
          identifier "png_voidp" is undefined

  __swi __arm png_voidp png_get_io_ptr(png_structp png_ptr);
                                       ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2281  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm png_uint_32 png_get_rowbytes(png_structp png_ptr,png_infop info_ptr);
              ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2286  Error[Pe020]: 
          identifier "png_uint_32" is undefined

  __swi __arm png_uint_32 png_get_rowbytes(png_structp png_ptr,png_infop info_ptr);
                                           ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2286  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm png_uint_32 png_get_rowbytes(png_structp png_ptr,png_infop info_ptr);
                                                               ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2286  Error[Pe020]: 
          identifier "png_infop" is undefined

  __swi __arm void png_read_row(png_structp png_ptr,png_bytep row,png_bytep dsp_row);
                                ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2291  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_read_row(png_structp png_ptr,png_bytep row,png_bytep dsp_row);
                                                    ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2291  Error[Pe020]: 
          identifier "png_bytep" is undefined

  __swi __arm void png_read_row(png_structp png_ptr,png_bytep row,png_bytep dsp_row);
                                                                  ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2291  Error[Pe020]: 
          identifier "png_bytep" is undefined

  __swi __arm void png_init_io(png_structp png_ptr, int fp);
                               ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2296  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm png_structp png_create_read_struct_2(png_const_charp user_png_ver, png_voidp error_ptr,
              ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2640  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm png_structp png_create_read_struct_2(png_const_charp user_png_ver, png_voidp error_ptr,
                                                   ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2640  Error[Pe020]: 
          identifier "png_const_charp" is undefined

  __swi __arm png_structp png_create_read_struct_2(png_const_charp user_png_ver, png_voidp error_ptr,
                                                                                 ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2640  Error[Pe020]: 
          identifier "png_voidp" is undefined

                                                   png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,
                                                   ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2641  Error[Pe020]: 
          identifier "png_error_ptr" is undefined

                                                   png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,
                                                                           ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2641  Error[Pe020]: 
          identifier "png_error_ptr" is undefined

                                                   png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,
                                                                                                  ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2641  Error[Pe020]: 
          identifier "png_voidp" is undefined

                                                   png_malloc_ptr malloc_fn, png_free_ptr free_fn);
                                                   ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2642  Error[Pe020]: 
          identifier "png_malloc_ptr" is undefined

                                                   png_malloc_ptr malloc_fn, png_free_ptr free_fn);
                                                                             ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2642  Error[Pe020]: 
          identifier "png_free_ptr" is undefined

  __swi __arm void png_set_read_fn(png_structp png_ptr, png_voidp io_ptr, png_rw_ptr read_data_fn);
                                   ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2647  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_set_read_fn(png_structp png_ptr, png_voidp io_ptr, png_rw_ptr read_data_fn);
                                                        ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2647  Error[Pe020]: 
          identifier "png_voidp" is undefined

  __swi __arm void png_set_read_fn(png_structp png_ptr, png_voidp io_ptr, png_rw_ptr read_data_fn);
                                                                          ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2647  Error[Pe020]: 
          identifier "png_rw_ptr" is undefined

  __swi __arm void png_read_update_info(png_structp png_ptr,void *info_ptr);
                                        ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2652  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_set_palette_to_rgb(png_structp png_ptr);
                                          ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2657  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm png_uint_32 png_get_valid(png_structp png_ptr,png_infop info_ptr, png_uint_32 flag);
              ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2662  Error[Pe020]: 
          identifier "png_uint_32" is undefined

  __swi __arm png_uint_32 png_get_valid(png_structp png_ptr,png_infop info_ptr, png_uint_32 flag);
                                        ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2662  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm png_uint_32 png_get_valid(png_structp png_ptr,png_infop info_ptr, png_uint_32 flag);
                                                            ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2662  Error[Pe020]: 
          identifier "png_infop" is undefined

  __swi __arm png_uint_32 png_get_valid(png_structp png_ptr,png_infop info_ptr, png_uint_32 flag);
                                                                                ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2662  Error[Pe020]: 
          identifier "png_uint_32" is undefined

  __swi __arm void png_set_tRNS_to_alpha(png_structp png_ptr);
                                         ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2667  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_set_filler(png_structp png_ptr,png_uint_32 filler, int flags);
                                  ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2672  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_set_filler(png_structp png_ptr,png_uint_32 filler, int flags);
                                                      ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2672  Error[Pe020]: 
          identifier "png_uint_32" is undefined

  __swi __arm void png_set_strip_16(png_structp png_ptr);
                                    ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2677  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_set_packing(png_structp png_ptr);
                                   ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2682  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_set_gray_to_rgb(png_structp png_ptr);
                                       ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2687  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm int png_check_sig(png_bytep sig, int num);
                                ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2692  Error[Pe020]: 
          identifier "png_bytep" is undefined

  __swi __arm void png_set_gray_1_2_4_to_8(png_structp png_ptr);
                                           ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2888  Error[Pe020]: 
          identifier "png_structp" is undefined

  __swi __arm void png_set_invert_mono(png_structp png_ptr);
                                       ^
"C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\swilib.h",2893  Error[Pe020]: 
          identifier "png_structp" is undefined

  extern PNG_EXPORT(void,png_read_update_info) PNGARG((png_structp png_ptr,
         ^
"C:\arm\grabber\pnglib\png.h",1525  Error[Pe147]: declaration is incompatible
          with "void png_read_update_info(<error-type>, void *)" (declared at
          line 2652 of "C:\arm2\Embedded Workbench 4.0
          Evaluation\ARM\INC\swilib.h")
     13          #ifdef PNG_WRITE_SUPPORTED
     14          
     15          /* Place a 32-bit number into a buffer in PNG byte order.  We work
     16           * with unsigned numbers for convenience, although one supported
     17           * ancillary chunk uses signed (two's complement) numbers.
     18           */
     19          void /* PRIVATE */
     20          png_save_uint_32(png_bytep buf, png_uint_32 i)
     21          {
     22             buf[0] = (png_byte)((i >> 24) & 0xff);
     23             buf[1] = (png_byte)((i >> 16) & 0xff);
     24             buf[2] = (png_byte)((i >> 8) & 0xff);
     25             buf[3] = (png_byte)(i & 0xff);
     26          }
     27          
     28          #if defined(PNG_WRITE_pCAL_SUPPORTED) || defined(PNG_WRITE_oFFs_SUPPORTED)
     29          /* The png_save_int_32 function assumes integers are stored in two's
     30           * complement format.  If this isn't the case, then this routine needs to
     31           * be modified to write data in two's complement format.
     32           */
     33          void /* PRIVATE */
     34          png_save_int_32(png_bytep buf, png_int_32 i)
     35          {
     36             buf[0] = (png_byte)((i >> 24) & 0xff);
     37             buf[1] = (png_byte)((i >> 16) & 0xff);
     38             buf[2] = (png_byte)((i >> 8) & 0xff);
     39             buf[3] = (png_byte)(i & 0xff);
     40          }
     41          #endif
     42          
     43          /* Place a 16-bit number into a buffer in PNG byte order.
     44           * The parameter is declared unsigned int, not png_uint_16,
     45           * just to avoid potential problems on pre-ANSI C compilers.
     46           */
     47          void /* PRIVATE */
     48          png_save_uint_16(png_bytep buf, unsigned int i)
     49          {
     50             buf[0] = (png_byte)((i >> 8) & 0xff);
     51             buf[1] = (png_byte)(i & 0xff);
     52          }
     53          
     54          /* Write a PNG chunk all at once.  The type is an array of ASCII characters
     55           * representing the chunk name.  The array must be at least 4 bytes in
     56           * length, and does not need to be null terminated.  To be safe, pass the
     57           * pre-defined chunk names here, and if you need a new one, define it
     58           * where the others are defined.  The length is the length of the data.
     59           * All the data must be present.  If that is not possible, use the
     60           * png_write_chunk_start(), png_write_chunk_data(), and png_write_chunk_end()
     61           * functions instead.
     62           */
     63          void PNGAPI
     64          png_write_chunk(png_structp png_ptr, png_bytep chunk_name,
     65             png_bytep data, png_size_t length)
     66          {
     67             png_write_chunk_start(png_ptr, chunk_name, (png_uint_32)length);
     68             png_write_chunk_data(png_ptr, data, length);
     69             png_write_chunk_end(png_ptr);
     70          }
     71          
     72          /* Write the start of a PNG chunk.  The type is the chunk type.
     73           * The total_length is the sum of the lengths of all the data you will be
     74           * passing in png_write_chunk_data().
     75           */
     76          void PNGAPI
     77          png_write_chunk_start(png_structp png_ptr, png_bytep chunk_name,
     78             png_uint_32 length)
     79          {
     80             png_byte buf[4];
     81             png_debug2(0, "Writing %s chunk (%lu bytes)\n", chunk_name, length);
     82          
     83             /* write the length */
     84             png_save_uint_32(buf, length);
     85             png_write_data(png_ptr, buf, (png_size_t)4);
     86          
     87             /* write the chunk name */
     88             png_write_data(png_ptr, chunk_name, (png_size_t)4);
     89             /* reset the crc and run it over the chunk name */
     90             png_reset_crc(png_ptr);
     91             png_calculate_crc(png_ptr, chunk_name, (png_size_t)4);
     92          }
     93          
     94          /* Write the data of a PNG chunk started with png_write_chunk_start().
     95           * Note that multiple calls to this function are allowed, and that the
     96           * sum of the lengths from these calls *must* add up to the total_length
     97           * given to png_write_chunk_start().
     98           */
     99          void PNGAPI
    100          png_write_chunk_data(png_structp png_ptr, png_bytep data, png_size_t length)
    101          {
    102             /* write the data, and run the CRC over it */
    103             if (data != NULL && length > 0)
    104             {
    105                png_calculate_crc(png_ptr, data, length);
    106                png_write_data(png_ptr, data, length);
    107             }
    108          }
    109          
    110          /* Finish a chunk started with png_write_chunk_start(). */
    111          void PNGAPI
    112          png_write_chunk_end(png_structp png_ptr)
    113          {
    114             png_byte buf[4];
    115          
    116             /* write the crc */
    117             png_save_uint_32(buf, png_ptr->crc);
    118          
    119             png_write_data(png_ptr, buf, (png_size_t)4);
    120          }
    121          
    122          /* Simple function to write the signature.  If we have already written
    123           * the magic bytes of the signature, or more likely, the PNG stream is
    124           * being embedded into another stream and doesn't need its own signature,
    125           * we should call png_set_sig_bytes() to tell libpng how many of the
    126           * bytes have already been written.
    127           */
    128          void /* PRIVATE */
    129          png_write_sig(png_structp png_ptr)
    130          {
    131             png_byte png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};
    132             /* write the rest of the 8 byte signature */
    133             png_write_data(png_ptr, &png_signature[png_ptr->sig_bytes],
    134                (png_size_t)8 - png_ptr->sig_bytes);
    135             if(png_ptr->sig_bytes < 3)
    136                png_ptr->mode |= PNG_HAVE_PNG_SIGNATURE;
    137          }
    138          
    139          #if defined(PNG_WRITE_TEXT_SUPPORTED) || defined(PNG_WRITE_iCCP_SUPPORTED)
    140          /*
    141           * This pair of functions encapsulates the operation of (a) compressing a
    142           * text string, and (b) issuing it later as a series of chunk data writes.
    143           * The compression_state structure is shared context for these functions
    144           * set up by the caller in order to make the whole mess thread-safe.
    145           */
    146          
    147          typedef struct
    148          {
    149              char *input;   /* the uncompressed input data */
    150              int input_len;   /* its length */
    151              int num_output_ptr; /* number of output pointers used */
    152              int max_output_ptr; /* size of output_ptr */
    153              png_charpp output_ptr; /* array of pointers to output */
    154          } compression_state;
    155          
    156          /* compress given text into storage in the png_ptr structure */
    157          static int /* PRIVATE */
    158          png_text_compress(png_structp png_ptr,
    159                  png_charp text, png_size_t text_len, int compression,
    160                  compression_state *comp)
    161          {
    162             int ret;
    163          
    164             comp->num_output_ptr = comp->max_output_ptr = 0;
    165             comp->output_ptr = NULL;
    166             comp->input = NULL;
    167          
    168             /* we may just want to pass the text right through */
    169             if (compression == PNG_TEXT_COMPRESSION_NONE)
    170             {
    171                 comp->input = text;
    172                 comp->input_len = (int)text_len; // JL 03/24/2002 - fixed incorrect typeconversion
    173                 return((int)text_len);
    174             }
    175          
    176             if (compression >= PNG_TEXT_COMPRESSION_LAST)
    177             {
    178          #if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
    179                char msg[50];
    180                sprintf(msg, "Unknown compression type %d", compression);
    181                png_warning(png_ptr, msg);
    182          #else
    183                png_warning(png_ptr, "Unknown compression type");
    184          #endif
    185             }
    186          
    187             /* We can't write the chunk until we find out how much data we have,
    188              * which means we need to run the compressor first and save the
    189              * output.  This shouldn't be a problem, as the vast majority of
    190              * comments should be reasonable, but we will set up an array of
    191              * malloc'd pointers to be sure.
    192              *
    193              * If we knew the application was well behaved, we could simplify this
    194              * greatly by assuming we can always malloc an output buffer large
    195              * enough to hold the compressed text ((1001 * text_len / 1000) + 12)
    196              * and malloc this directly.  The only time this would be a bad idea is
    197              * if we can't malloc more than 64K and we have 64K of random input
    198              * data, or if the input string is incredibly large (although this
    199              * wouldn't cause a failure, just a slowdown due to swapping).
    200              */
    201          
    202             /* set up the compression buffers */
    203             png_ptr->zstream.avail_in = (uInt)text_len;
    204             png_ptr->zstream.next_in = (Bytef *)text;
    205             png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
    206             png_ptr->zstream.next_out = (Bytef *)png_ptr->zbuf;
    207          
    208             /* this is the same compression loop as in png_write_row() */
    209             do
    210             {
    211                /* compress the data */
    212                ret = deflate(&png_ptr->zstream, Z_NO_FLUSH);
    213                if (ret != Z_OK)
    214                {
    215                   /* error */
    216                   if (png_ptr->zstream.msg != NULL)
    217                      png_error(png_ptr, png_ptr->zstream.msg);
    218                   else
    219                      png_error(png_ptr, "zlib error");
    220                }
    221                /* check to see if we need more room */
    222                if (!png_ptr->zstream.avail_out && png_ptr->zstream.avail_in)
    223                {
    224                   /* make sure the output array has room */
    225                   if (comp->num_output_ptr >= comp->max_output_ptr)
    226                   {
    227                      int old_max;
    228          
    229                      old_max = comp->max_output_ptr;
    230                      comp->max_output_ptr = comp->num_output_ptr + 4;
    231                      if (comp->output_ptr != NULL)
    232                      {
    233                         png_charpp old_ptr;
    234          
    235                         old_ptr = comp->output_ptr;
    236                         comp->output_ptr = (png_charpp)png_malloc(png_ptr,
    237                            (png_uint_32)(comp->max_output_ptr * sizeof (png_charpp)));
    238                         png_memcpy(comp->output_ptr, old_ptr, old_max
    239                            * sizeof (png_charp));
    240                         png_free(png_ptr, old_ptr);
    241                      }
    242                      else
    243                         comp->output_ptr = (png_charpp)png_malloc(png_ptr,
    244                            (png_uint_32)(comp->max_output_ptr * sizeof (png_charp)));
    245                   }
    246          
    247                   /* save the data */
    248                   comp->output_ptr[comp->num_output_ptr] = (png_charp)png_malloc(png_ptr,
    249                      (png_uint_32)png_ptr->zbuf_size);
    250                   png_memcpy(comp->output_ptr[comp->num_output_ptr], png_ptr->zbuf,
    251                      png_ptr->zbuf_size);
    252                   comp->num_output_ptr++;
    253          
    254                   /* and reset the buffer */
    255                   png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
    256                   png_ptr->zstream.next_out = png_ptr->zbuf;
    257                }
    258             /* continue until we don't have any more to compress */
    259             } while (png_ptr->zstream.avail_in);
    260          
    261             /* finish the compression */
    262             do
    263             {
    264                /* tell zlib we are finished */
    265                ret = deflate(&png_ptr->zstream, Z_FINISH);
    266          
    267                if (ret == Z_OK)
    268                {
    269                   /* check to see if we need more room */
    270                   if (!(png_ptr->zstream.avail_out))
    271                   {
    272                      /* check to make sure our output array has room */
    273                      if (comp->num_output_ptr >= comp->max_output_ptr)
    274                      {
    275                         int old_max;
    276          
    277                         old_max = comp->max_output_ptr;
    278                         comp->max_output_ptr = comp->num_output_ptr + 4;
    279                         if (comp->output_ptr != NULL)
    280                         {
    281                            png_charpp old_ptr;
    282          
    283                            old_ptr = comp->output_ptr;
    284                            /* This could be optimized to realloc() */
    285                            comp->output_ptr = (png_charpp)png_malloc(png_ptr,
    286                               (png_uint_32)(comp->max_output_ptr * sizeof (png_charpp)));
    287                            png_memcpy(comp->output_ptr, old_ptr,
    288                               old_max * sizeof (png_charp));
    289                            png_free(png_ptr, old_ptr);
    290                         }
    291                         else
    292                            comp->output_ptr = (png_charpp)png_malloc(png_ptr,
    293                               (png_uint_32)(comp->max_output_ptr * sizeof (png_charp)));
    294                      }
    295          
    296                      /* save off the data */
    297                      comp->output_ptr[comp->num_output_ptr] =
    298                         (png_charp)png_malloc(png_ptr, (png_uint_32)png_ptr->zbuf_size);
    299                      png_memcpy(comp->output_ptr[comp->num_output_ptr], png_ptr->zbuf,
    300                         png_ptr->zbuf_size);
    301                      comp->num_output_ptr++;
    302          
    303                      /* and reset the buffer pointers */
    304                      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
    305                      png_ptr->zstream.next_out = png_ptr->zbuf;
    306                   }
    307                }
    308                else if (ret != Z_STREAM_END)
    309                {
    310                   /* we got an error */
    311                   if (png_ptr->zstream.msg != NULL)
    312                      png_error(png_ptr, png_ptr->zstream.msg);
    313                   else
    314                      png_error(png_ptr, "zlib error");
    315                }
    316             } while (ret != Z_STREAM_END);
    317          
    318             /* text length is number of buffers plus last buffer */
    319             text_len = png_ptr->zbuf_size * comp->num_output_ptr;
    320             if (png_ptr->zstream.avail_out < png_ptr->zbuf_size)
    321                text_len += png_ptr->zbuf_size - (png_size_t)png_ptr->zstream.avail_out;
    322          
    323             return((int)text_len);
    324          }
    325          
    326          /* ship the compressed text out via chunk writes */
    327          static void /* PRIVATE */
    328          png_write_compressed_data_out(png_structp png_ptr, compression_state *comp)
    329          {
    330             int i;
    331          
    332             /* handle the no-compression case */
    333             if (comp->input)
    334             {
    335                 png_write_chunk_data(png_ptr, (png_bytep)comp->input,
    336                                      (png_size_t)comp->input_len);
    337                 return;
    338             }
    339          
    340             /* write saved output buffers, if any */
    341             for (i = 0; i < comp->num_output_ptr; i++)
    342             {
    343                png_write_chunk_data(png_ptr,(png_bytep)comp->output_ptr[i],
    344                   png_ptr->zbuf_size);
    345                png_free(png_ptr, comp->output_ptr[i]);
    346                comp->output_ptr[i]=NULL;
    347             }
    348             if (comp->max_output_ptr != 0)
    349                png_free(png_ptr, comp->output_ptr);
    350                comp->output_ptr=NULL;
    351             /* write anything left in zbuf */
    352             if (png_ptr->zstream.avail_out < (png_uint_32)png_ptr->zbuf_size)
    353                png_write_chunk_data(png_ptr, png_ptr->zbuf,
    354                   png_ptr->zbuf_size - png_ptr->zstream.avail_out);
    355          
    356             /* reset zlib for another zTXt/iTXt or the image data */
    357             deflateReset(&png_ptr->zstream);
    358          
    359          }
    360          #endif
    361          
    362          /* Write the IHDR chunk, and update the png_struct with the necessary
    363           * information.  Note that the rest of this code depends upon this
    364           * information being correct.
    365           */
    366          void /* PRIVATE */
    367          png_write_IHDR(png_structp png_ptr, png_uint_32 width, png_uint_32 height,
    368             int bit_depth, int color_type, int compression_type, int filter_type,
    369             int interlace_type)
    370          {
    371          #ifdef PNG_USE_LOCAL_ARRAYS
    372             PNG_IHDR;
    373          #endif
    374             png_byte buf[13]; /* buffer to store the IHDR info */
    375          
    376             png_debug(1, "in png_write_IHDR\n");
    377             /* Check that we have valid input data from the application info */
    378             switch (color_type)
    379             {
    380                case PNG_COLOR_TYPE_GRAY:
    381                   switch (bit_depth)
    382                   {
    383                      case 1:
    384                      case 2:
    385                      case 4:
    386                      case 8:
    387                      case 16: png_ptr->channels = 1; break;
    388                      default: png_error(png_ptr,"Invalid bit depth for grayscale image");
    389                   }
    390                   break;
    391                case PNG_COLOR_TYPE_RGB:
    392                   if (bit_depth != 8 && bit_depth != 16)
    393                      png_error(png_ptr, "Invalid bit depth for RGB image");
    394                   png_ptr->channels = 3;
    395                   break;
    396                case PNG_COLOR_TYPE_PALETTE:
    397                   switch (bit_depth)
    398                   {
    399                      case 1:
    400                      case 2:
    401                      case 4:
    402                      case 8: png_ptr->channels = 1; break;
    403                      default: png_error(png_ptr, "Invalid bit depth for paletted image");
    404                   }
    405                   break;
    406                case PNG_COLOR_TYPE_GRAY_ALPHA:
    407                   if (bit_depth != 8 && bit_depth != 16)
    408                      png_error(png_ptr, "Invalid bit depth for grayscale+alpha image");
    409                   png_ptr->channels = 2;
    410                   break;
    411                case PNG_COLOR_TYPE_RGB_ALPHA:
    412                   if (bit_depth != 8 && bit_depth != 16)
    413                      png_error(png_ptr, "Invalid bit depth for RGBA image");
    414                   png_ptr->channels = 4;
    415                   break;
    416                default:
    417                   png_error(png_ptr, "Invalid image color type specified");
    418             }
    419          
    420             if (compression_type != PNG_COMPRESSION_TYPE_BASE)
    421             {
    422                png_warning(png_ptr, "Invalid compression type specified");
    423                compression_type = PNG_COMPRESSION_TYPE_BASE;
    424             }
    425          
    426             /* Write filter_method 64 (intrapixel differencing) only if
    427              * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and
    428              * 2. Libpng did not write a PNG signature (this filter_method is only
    429              *    used in PNG datastreams that are embedded in MNG datastreams) and
    430              * 3. The application called png_permit_mng_features with a mask that
    431              *    included PNG_FLAG_MNG_FILTER_64 and
    432              * 4. The filter_method is 64 and
    433              * 5. The color_type is RGB or RGBA
    434              */
    435             if (
    436          #if defined(PNG_MNG_FEATURES_SUPPORTED)
    437                !((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
    438                ((png_ptr->mode&PNG_HAVE_PNG_SIGNATURE) == 0) &&
    439                (color_type == PNG_COLOR_TYPE_RGB ||
    440                 color_type == PNG_COLOR_TYPE_RGB_ALPHA) &&
    441                (filter_type == PNG_INTRAPIXEL_DIFFERENCING)) &&
    442          #endif
    443                filter_type != PNG_FILTER_TYPE_BASE)
    444             {
    445                png_warning(png_ptr, "Invalid filter type specified");
    446                filter_type = PNG_FILTER_TYPE_BASE;
    447             }
    448          
    449          #ifdef PNG_WRITE_INTERLACING_SUPPORTED
    450             if (interlace_type != PNG_INTERLACE_NONE &&
    451                interlace_type != PNG_INTERLACE_ADAM7)
    452             {
    453                png_warning(png_ptr, "Invalid interlace type specified");
    454                interlace_type = PNG_INTERLACE_ADAM7;
    455             }
    456          #else
    457             interlace_type=PNG_INTERLACE_NONE;
    458          #endif
    459          
    460             /* save off the relevent information */
    461             png_ptr->bit_depth = (png_byte)bit_depth;
    462             png_ptr->color_type = (png_byte)color_type;
    463             png_ptr->interlaced = (png_byte)interlace_type;
    464          #if defined(PNG_MNG_FEATURES_SUPPORTED)
    465             png_ptr->filter_type = (png_byte)filter_type;
    466          #endif
    467             png_ptr->width = width;
    468             png_ptr->height = height;
    469          
    470             png_ptr->pixel_depth = (png_byte)(bit_depth * png_ptr->channels);
    471             png_ptr->rowbytes = ((width * (png_size_t)png_ptr->pixel_depth + 7) >> 3);
    472             /* set the usr info, so any transformations can modify it */
    473             png_ptr->usr_width = png_ptr->width;
    474             png_ptr->usr_bit_depth = png_ptr->bit_depth;
    475             png_ptr->usr_channels = png_ptr->channels;
    476          
    477             /* pack the header information into the buffer */
    478             png_save_uint_32(buf, width);
    479             png_save_uint_32(buf + 4, height);
    480             buf[8] = (png_byte)bit_depth;
    481             buf[9] = (png_byte)color_type;
    482             buf[10] = (png_byte)compression_type;
    483             buf[11] = (png_byte)filter_type;
    484             buf[12] = (png_byte)interlace_type;
    485          
    486             /* write the chunk */
    487             png_write_chunk(png_ptr, (png_bytep)png_IHDR, buf, (png_size_t)13);
    488          
    489             /* initialize zlib with PNG info */
    490             png_ptr->zstream.zalloc = png_zalloc;
    491             png_ptr->zstream.zfree = png_zfree;
    492             png_ptr->zstream.opaque = (voidpf)png_ptr;
    493             if (!(png_ptr->do_filter))
    494             {
    495                if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE ||
    496                   png_ptr->bit_depth < 8)
    497                   png_ptr->do_filter = PNG_FILTER_NONE;
    498                else
    499                   png_ptr->do_filter = PNG_ALL_FILTERS;
    500             }
    501             if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_STRATEGY))
    502             {
    503                if (png_ptr->do_filter != PNG_FILTER_NONE)
    504                   png_ptr->zlib_strategy = Z_FILTERED;
    505                else
    506                   png_ptr->zlib_strategy = Z_DEFAULT_STRATEGY;
    507             }
    508             if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_LEVEL))
    509                png_ptr->zlib_level = Z_DEFAULT_COMPRESSION;
    510             if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_MEM_LEVEL))
    511                png_ptr->zlib_mem_level = 8;
    512             if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_WINDOW_BITS))
    513                png_ptr->zlib_window_bits = 15;
    514             if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_METHOD))
    515                png_ptr->zlib_method = 8;
    516             deflateInit2(&png_ptr->zstream, png_ptr->zlib_level,
    517                png_ptr->zlib_method, png_ptr->zlib_window_bits,
    518                png_ptr->zlib_mem_level, png_ptr->zlib_strategy);
    519             png_ptr->zstream.next_out = png_ptr->zbuf;
    520             png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
    521          
    522             png_ptr->mode = PNG_HAVE_IHDR;
    523          }
    524          
    525          /* write the palette.  We are careful not to trust png_color to be in the
    526           * correct order for PNG, so people can redefine it to any convenient
    527           * structure.
    528           */
    529          void /* PRIVATE */
    530          png_write_PLTE(png_structp png_ptr, png_colorp palette, png_uint_32 num_pal)
    531          {
    532          #ifdef PNG_USE_LOCAL_ARRAYS
    533             PNG_PLTE;
    534          #endif
    535             png_uint_32 i;
    536             png_colorp pal_ptr;
    537             png_byte buf[3];
    538          
    539             png_debug(1, "in png_write_PLTE\n");
    540             if ((
    541          #if defined(PNG_MNG_FEATURES_SUPPORTED)
    542                  !(png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) &&
    543          #endif
    544                  num_pal == 0) || num_pal > 256)
    545             {
    546               if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
    547               {
    548                  png_error(png_ptr, "Invalid number of colors in palette");
    549               }
    550               else
    551               {
    552                  png_warning(png_ptr, "Invalid number of colors in palette");
    553                  return;
    554               }
    555             }
    556          
    557             if (!(png_ptr->color_type&PNG_COLOR_MASK_COLOR))
    558             {
    559                png_warning(png_ptr,
    560                  "Ignoring request to write a PLTE chunk in grayscale PNG");
    561                return;
    562             }
    563          
    564             png_ptr->num_palette = (png_uint_16)num_pal;
    565             png_debug1(3, "num_palette = %d\n", png_ptr->num_palette);
    566          
    567             png_write_chunk_start(png_ptr, (png_bytep)png_PLTE, num_pal * 3);
    568          #ifndef PNG_NO_POINTER_INDEXING
    569             for (i = 0, pal_ptr = palette; i < num_pal; i++, pal_ptr++)
    570             {
    571                buf[0] = pal_ptr->red;
    572                buf[1] = pal_ptr->green;
    573                buf[2] = pal_ptr->blue;
    574                png_write_chunk_data(png_ptr, buf, (png_size_t)3);
    575             }
    576          #else
    577             /* This is a little slower but some buggy compilers need to do this instead */
    578             pal_ptr=palette;
    579             for (i = 0; i < num_pal; i++)
    580             {
    581                buf[0] = pal_ptr[i].red;
    582                buf[1] = pal_ptr[i].green;
    583                buf[2] = pal_ptr[i].blue;
    584                png_write_chunk_data(png_ptr, buf, (png_size_t)3);
    585             }
    586          #endif
    587             png_write_chunk_end(png_ptr);
    588             png_ptr->mode |= PNG_HAVE_PLTE;
    589          }
    590          
    591          /* write an IDAT chunk */
    592          void /* PRIVATE */
    593          png_write_IDAT(png_structp png_ptr, png_bytep data, png_size_t length)
    594          {
    595          #ifdef PNG_USE_LOCAL_ARRAYS
    596             PNG_IDAT;
    597          #endif
    598             png_debug(1, "in png_write_IDAT\n");
    599             png_write_chunk(png_ptr, (png_bytep)png_IDAT, data, length);
    600             png_ptr->mode |= PNG_HAVE_IDAT;
    601          }
    602          
    603          /* write an IEND chunk */
    604          void /* PRIVATE */
    605          png_write_IEND(png_structp png_ptr)
    606          {
    607          #ifdef PNG_USE_LOCAL_ARRAYS
    608             PNG_IEND;
    609          #endif
    610             png_debug(1, "in png_write_IEND\n");
    611             png_write_chunk(png_ptr, (png_bytep)png_IEND, png_bytep_NULL,
    612               (png_size_t)0);
    613             png_ptr->mode |= PNG_HAVE_IEND;
    614          }
    615          
    616          #if defined(PNG_WRITE_gAMA_SUPPORTED)
    617          /* write a gAMA chunk */
    618          #ifdef PNG_FLOATING_POINT_SUPPORTED
    619          void /* PRIVATE */
    620          png_write_gAMA(png_structp png_ptr, double file_gamma)
    621          {
    622          #ifdef PNG_USE_LOCAL_ARRAYS
    623             PNG_gAMA;
    624          #endif
    625             png_uint_32 igamma;
    626             png_byte buf[4];
    627          
    628             png_debug(1, "in png_write_gAMA\n");
    629             /* file_gamma is saved in 1/100,000ths */
    630             igamma = (png_uint_32)(file_gamma * 100000.0 + 0.5);
    631             png_save_uint_32(buf, igamma);
    632             png_write_chunk(png_ptr, (png_bytep)png_gAMA, buf, (png_size_t)4);
    633          }
    634          #endif
    635          #ifdef PNG_FIXED_POINT_SUPPORTED
    636          void /* PRIVATE */
    637          png_write_gAMA_fixed(png_structp png_ptr, png_fixed_point file_gamma)
    638          {
    639          #ifdef PNG_USE_LOCAL_ARRAYS
    640             PNG_gAMA;
    641          #endif
    642             png_byte buf[4];
    643          
    644             png_debug(1, "in png_write_gAMA\n");
    645             /* file_gamma is saved in 1/100,000ths */
    646             png_save_uint_32(buf, (png_uint_32)file_gamma);
    647             png_write_chunk(png_ptr, (png_bytep)png_gAMA, buf, (png_size_t)4);
    648          }
    649          #endif
    650          #endif
    651          
    652          #if defined(PNG_WRITE_sRGB_SUPPORTED)
    653          /* write a sRGB chunk */
    654          void /* PRIVATE */
    655          png_write_sRGB(png_structp png_ptr, int srgb_intent)
    656          {
    657          #ifdef PNG_USE_LOCAL_ARRAYS
    658             PNG_sRGB;
    659          #endif
    660             png_byte buf[1];
    661          
    662             png_debug(1, "in png_write_sRGB\n");
    663             if(srgb_intent >= PNG_sRGB_INTENT_LAST)
    664                   png_warning(png_ptr,
    665                      "Invalid sRGB rendering intent specified");
    666             buf[0]=(png_byte)srgb_intent;
    667             png_write_chunk(png_ptr, (png_bytep)png_sRGB, buf, (png_size_t)1);
    668          }
    669          #endif
    670          
    671          #if defined(PNG_WRITE_iCCP_SUPPORTED)
    672          /* write an iCCP chunk */
    673          void /* PRIVATE */
    674          png_write_iCCP(png_structp png_ptr, png_charp name, int compression_type,
    675             png_charp profile, int profile_len)
    676          {
    677          #ifdef PNG_USE_LOCAL_ARRAYS
    678             PNG_iCCP;
    679          #endif
    680             png_size_t name_len;
    681             png_charp new_name;
    682             compression_state comp;
    683          
    684             png_debug(1, "in png_write_iCCP\n");
    685             if (name == NULL || (name_len = png_check_keyword(png_ptr, name,
    686                &new_name)) == 0)
    687             {
    688                png_warning(png_ptr, "Empty keyword in iCCP chunk");
    689                return;
    690             }
    691          
    692             if (compression_type != PNG_COMPRESSION_TYPE_BASE)
    693                png_warning(png_ptr, "Unknown compression type in iCCP chunk");
    694          
    695             if (profile == NULL)
    696                profile_len = 0;
    697          
    698             if (profile_len)
    699                 profile_len = png_text_compress(png_ptr, profile, (png_size_t)profile_len,
    700                    PNG_COMPRESSION_TYPE_BASE, &comp);
    701          
    702             /* make sure we include the NULL after the name and the compression type */
    703             png_write_chunk_start(png_ptr, (png_bytep)png_iCCP,
    704                    (png_uint_32)name_len+profile_len+2);
    705             new_name[name_len+1]=0x00;
    706             png_write_chunk_data(png_ptr, (png_bytep)new_name, name_len + 2);
    707          
    708             if (profile_len)
    709                png_write_compressed_data_out(png_ptr, &comp);
    710          
    711             png_write_chunk_end(png_ptr);
    712             png_free(png_ptr, new_name);
    713          }
    714          #endif
    715          
    716          #if defined(PNG_WRITE_sPLT_SUPPORTED)
    717          /* write a sPLT chunk */
    718          void /* PRIVATE */
    719          png_write_sPLT(png_structp png_ptr, png_sPLT_tp spalette)
    720          {
    721          #ifdef PNG_USE_LOCAL_ARRAYS
    722             PNG_sPLT;
    723          #endif
    724             png_size_t name_len;
    725             png_charp new_name;
    726             png_byte entrybuf[10];
    727             int entry_size = (spalette->depth == 8 ? 6 : 10);
    728             int palette_size = entry_size * spalette->nentries;
    729             png_sPLT_entryp ep;
    730          #ifdef PNG_NO_POINTER_INDEXING
    731             int i;
    732          #endif
    733          
    734             png_debug(1, "in png_write_sPLT\n");
    735             if (spalette->name == NULL || (name_len = png_check_keyword(png_ptr,
    736                spalette->name, &new_name))==0)
    737             {
    738                png_warning(png_ptr, "Empty keyword in sPLT chunk");
    739                return;
    740             }
    741          
    742             /* make sure we include the NULL after the name */
    743             png_write_chunk_start(png_ptr, (png_bytep)png_sPLT,
    744                    (png_uint_32)(name_len + 2 + palette_size));
    745             png_write_chunk_data(png_ptr, (png_bytep)new_name, name_len + 1);
    746             png_write_chunk_data(png_ptr, (png_bytep)&spalette->depth, 1);
    747          
    748             /* loop through each palette entry, writing appropriately */
    749          #ifndef PNG_NO_POINTER_INDEXING
    750             for (ep = spalette->entries; ep<spalette->entries+spalette->nentries; ep++)
    751             {
    752                 if (spalette->depth == 8)
    753                 {
    754                     entrybuf[0] = (png_byte)ep->red;
    755                     entrybuf[1] = (png_byte)ep->green;
    756                     entrybuf[2] = (png_byte)ep->blue;
    757                     entrybuf[3] = (png_byte)ep->alpha;
    758                     png_save_uint_16(entrybuf + 4, ep->frequency);
    759                 }
    760                 else
    761                 {
    762                     png_save_uint_16(entrybuf + 0, ep->red);
    763                     png_save_uint_16(entrybuf + 2, ep->green);
    764                     png_save_uint_16(entrybuf + 4, ep->blue);
    765                     png_save_uint_16(entrybuf + 6, ep->alpha);
    766                     png_save_uint_16(entrybuf + 8, ep->frequency);
    767                 }
    768                 png_write_chunk_data(png_ptr, entrybuf, (png_size_t)entry_size);
    769             }
    770          #else
    771             ep=spalette->entries;
    772             for (i=0; i>spalette->nentries; i++)
    773             {
    774                 if (spalette->depth == 8)
    775                 {
    776                     entrybuf[0] = (png_byte)ep[i].red;
    777                     entrybuf[1] = (png_byte)ep[i].green;
    778                     entrybuf[2] = (png_byte)ep[i].blue;
    779                     entrybuf[3] = (png_byte)ep[i].alpha;
    780                     png_save_uint_16(entrybuf + 4, ep[i].frequency);
    781                 }
    782                 else
    783                 {
    784                     png_save_uint_16(entrybuf + 0, ep[i].red);
    785                     png_save_uint_16(entrybuf + 2, ep[i].green);
    786                     png_save_uint_16(entrybuf + 4, ep[i].blue);
    787                     png_save_uint_16(entrybuf + 6, ep[i].alpha);
    788                     png_save_uint_16(entrybuf + 8, ep[i].frequency);
    789                 }
    790                 png_write_chunk_data(png_ptr, entrybuf, entry_size);
    791             }
    792          #endif
    793          
    794             png_write_chunk_end(png_ptr);
    795             png_free(png_ptr, new_name);
    796          }
    797          #endif
    798          
    799          #if defined(PNG_WRITE_sBIT_SUPPORTED)
    800          /* write the sBIT chunk */
    801          void /* PRIVATE */
    802          png_write_sBIT(png_structp png_ptr, png_color_8p sbit, int color_type)
    803          {
    804          #ifdef PNG_USE_LOCAL_ARRAYS
    805             PNG_sBIT;
    806          #endif
    807             png_byte buf[4];
    808             png_size_t size;
    809          
    810             png_debug(1, "in png_write_sBIT\n");
    811             /* make sure we don't depend upon the order of PNG_COLOR_8 */
    812             if (color_type & PNG_COLOR_MASK_COLOR)
    813             {
    814                png_byte maxbits;
    815          
    816                maxbits = (png_byte)(color_type==PNG_COLOR_TYPE_PALETTE ? 8 :
    817                          png_ptr->usr_bit_depth);
    818                if (sbit->red == 0 || sbit->red > maxbits ||
    819                    sbit->green == 0 || sbit->green > maxbits ||
    820                    sbit->blue == 0 || sbit->blue > maxbits)
    821                {
    822                   png_warning(png_ptr, "Invalid sBIT depth specified");
    823                   return;
    824                }
    825                buf[0] = sbit->red;
    826                buf[1] = sbit->green;
    827                buf[2] = sbit->blue;
    828                size = 3;
    829             }
    830             else
    831             {
    832                if (sbit->gray == 0 || sbit->gray > png_ptr->usr_bit_depth)
    833                {
    834                   png_warning(png_ptr, "Invalid sBIT depth specified");
    835                   return;
    836                }
    837                buf[0] = sbit->gray;
    838                size = 1;
    839             }
    840          
    841             if (color_type & PNG_COLOR_MASK_ALPHA)
    842             {
    843                if (sbit->alpha == 0 || sbit->alpha > png_ptr->usr_bit_depth)
    844                {
    845                   png_warning(png_ptr, "Invalid sBIT depth specified");
    846                   return;
    847                }
    848                buf[size++] = sbit->alpha;
    849             }
    850          
    851             png_write_chunk(png_ptr, (png_bytep)png_sBIT, buf, size);
    852          }
    853          #endif
    854          
    855          #if defined(PNG_WRITE_cHRM_SUPPORTED)
    856          /* write the cHRM chunk */
    857          #ifdef PNG_FLOATING_POINT_SUPPORTED
    858          void /* PRIVATE */
    859          png_write_cHRM(png_structp png_ptr, double white_x, double white_y,
    860             double red_x, double red_y, double green_x, double green_y,
    861             double blue_x, double blue_y)
    862          {
    863          #ifdef PNG_USE_LOCAL_ARRAYS
    864             PNG_cHRM;
    865          #endif
    866             png_byte buf[32];
    867             png_uint_32 itemp;
    868          
    869             png_debug(1, "in png_write_cHRM\n");
    870             /* each value is saved in 1/100,000ths */
    871             if (white_x < 0 || white_x > 0.8 || white_y < 0 || white_y > 0.8 ||
    872                 white_x + white_y > 1.0)
    873             {
    874                png_warning(png_ptr, "Invalid cHRM white point specified");
    875          #if !defined(PNG_NO_CONSOLE_IO)
    876                fprintf(stderr,"white_x=%f, white_y=%f\n",white_x, white_y);
    877          #endif
    878                return;
    879             }
    880             itemp = (png_uint_32)(white_x * 100000.0 + 0.5);
    881             png_save_uint_32(buf, itemp);
    882             itemp = (png_uint_32)(white_y * 100000.0 + 0.5);
    883             png_save_uint_32(buf + 4, itemp);
    884          
    885             if (red_x < 0 || red_x > 0.8 || red_y < 0 || red_y > 0.8 ||
    886                 red_x + red_y > 1.0)
    887             {
    888                png_warning(png_ptr, "Invalid cHRM red point specified");
    889                return;
    890             }
    891             itemp = (png_uint_32)(red_x * 100000.0 + 0.5);
    892             png_save_uint_32(buf + 8, itemp);
    893             itemp = (png_uint_32)(red_y * 100000.0 + 0.5);
    894             png_save_uint_32(buf + 12, itemp);
    895          
    896             if (green_x < 0 || green_x > 0.8 || green_y < 0 || green_y > 0.8 ||
    897                 green_x + green_y > 1.0)
    898             {
    899                png_warning(png_ptr, "Invalid cHRM green point specified");
    900                return;
    901             }
    902             itemp = (png_uint_32)(green_x * 100000.0 + 0.5);
    903             png_save_uint_32(buf + 16, itemp);
    904             itemp = (png_uint_32)(green_y * 100000.0 + 0.5);
    905             png_save_uint_32(buf + 20, itemp);
    906          
    907             if (blue_x < 0 || blue_x > 0.8 || blue_y < 0 || blue_y > 0.8 ||
    908                 blue_x + blue_y > 1.0)
    909             {
    910                png_warning(png_ptr, "Invalid cHRM blue point specified");
    911                return;
    912             }
    913             itemp = (png_uint_32)(blue_x * 100000.0 + 0.5);
    914             png_save_uint_32(buf + 24, itemp);
    915             itemp = (png_uint_32)(blue_y * 100000.0 + 0.5);
    916             png_save_uint_32(buf + 28, itemp);
    917          
    918             png_write_chunk(png_ptr, (png_bytep)png_cHRM, buf, (png_size_t)32);
    919          }
    920          #endif
    921          #ifdef PNG_FIXED_POINT_SUPPORTED
    922          void /* PRIVATE */
    923          png_write_cHRM_fixed(png_structp png_ptr, png_fixed_point white_x,
    924             png_fixed_point white_y, png_fixed_point red_x, png_fixed_point red_y,
    925             png_fixed_point green_x, png_fixed_point green_y, png_fixed_point blue_x,
    926             png_fixed_point blue_y)
    927          {
    928          #ifdef PNG_USE_LOCAL_ARRAYS
    929             PNG_cHRM;
    930          #endif
    931             png_byte buf[32];
    932          
    933             png_debug(1, "in png_write_cHRM\n");
    934             /* each value is saved in 1/100,000ths */
    935             if (white_x > 80000L || white_y > 80000L || white_x + white_y > 100000L)
    936             {
    937                png_warning(png_ptr, "Invalid fixed cHRM white point specified");
    938          #if !defined(PNG_NO_CONSOLE_IO)
    939                sprintf(lgn,"white_x=%ld, white_y=%ld\n",white_x, white_y);Tlog(lgn);
    940          #endif
    941                return;
    942             }
    943             png_save_uint_32(buf, (png_uint_32)white_x);
    944             png_save_uint_32(buf + 4, (png_uint_32)white_y);
    945          
    946             if (red_x > 80000L || red_y > 80000L || red_x + red_y > 100000L)
    947             {
    948                png_warning(png_ptr, "Invalid cHRM fixed red point specified");
    949                return;
    950             }
    951             png_save_uint_32(buf + 8, (png_uint_32)red_x);
    952             png_save_uint_32(buf + 12, (png_uint_32)red_y);
    953          
    954             if (green_x > 80000L || green_y > 80000L || green_x + green_y > 100000L)
    955             {
    956                png_warning(png_ptr, "Invalid fixed cHRM green point specified");
    957                return;
    958             }
    959             png_save_uint_32(buf + 16, (png_uint_32)green_x);
    960             png_save_uint_32(buf + 20, (png_uint_32)green_y);
    961          
    962             if (blue_x > 80000L || blue_y > 80000L || blue_x + blue_y > 100000L)
    963             {
    964                png_warning(png_ptr, "Invalid fixed cHRM blue point specified");
    965                return;
    966             }
    967             png_save_uint_32(buf + 24, (png_uint_32)blue_x);
    968             png_save_uint_32(buf + 28, (png_uint_32)blue_y);
    969          
    970             png_write_chunk(png_ptr, (png_bytep)png_cHRM, buf, (png_size_t)32);
    971          }
    972          #endif
    973          #endif
    974          
    975          #if defined(PNG_WRITE_tRNS_SUPPORTED)
    976          /* write the tRNS chunk */
    977          void /* PRIVATE */
    978          png_write_tRNS(png_structp png_ptr, png_bytep trans, png_color_16p tran,
    979             int num_trans, int color_type)
    980          {
    981          #ifdef PNG_USE_LOCAL_ARRAYS
    982             PNG_tRNS;
    983          #endif
    984             png_byte buf[6];
    985          
    986             png_debug(1, "in png_write_tRNS\n");
    987             if (color_type == PNG_COLOR_TYPE_PALETTE)
    988             {
    989                if (num_trans <= 0 || num_trans > (int)png_ptr->num_palette)
    990                {
    991                   png_warning(png_ptr,"Invalid number of transparent colors specified");
    992                   return;
    993                }
    994                /* write the chunk out as it is */
    995                png_write_chunk(png_ptr, (png_bytep)png_tRNS, trans, (png_size_t)num_trans);
    996             }
    997             else if (color_type == PNG_COLOR_TYPE_GRAY)
    998             {
    999                /* one 16 bit value */
   1000                if(tran->gray >= (1 << png_ptr->bit_depth))
   1001                {
   1002                   png_warning(png_ptr,
   1003                     "Ignoring attempt to write tRNS chunk out-of-range for bit_depth");
   1004                   return;
   1005                }
   1006                png_save_uint_16(buf, tran->gray);
   1007                png_write_chunk(png_ptr, (png_bytep)png_tRNS, buf, (png_size_t)2);
   1008             }
   1009             else if (color_type == PNG_COLOR_TYPE_RGB)
   1010             {
   1011                /* three 16 bit values */
   1012                png_save_uint_16(buf, tran->red);
   1013                png_save_uint_16(buf + 2, tran->green);
   1014                png_save_uint_16(buf + 4, tran->blue);
   1015                if(png_ptr->bit_depth == 8 && (buf[0] | buf[2] | buf[4]))
   1016                   {
   1017                      png_warning(png_ptr,
   1018                        "Ignoring attempt to write 16-bit tRNS chunk when bit_depth is 8");
   1019                      return;
   1020                   }
   1021                png_write_chunk(png_ptr, (png_bytep)png_tRNS, buf, (png_size_t)6);
   1022             }
   1023             else
   1024             {
   1025                png_warning(png_ptr, "Can't write tRNS with an alpha channel");
   1026             }
   1027          }
   1028          #endif
   1029          
   1030          #if defined(PNG_WRITE_bKGD_SUPPORTED)
   1031          /* write the background chunk */
   1032          void /* PRIVATE */
   1033          png_write_bKGD(png_structp png_ptr, png_color_16p back, int color_type)
   1034          {
   1035          #ifdef PNG_USE_LOCAL_ARRAYS
   1036             PNG_bKGD;
   1037          #endif
   1038             png_byte buf[6];
   1039          
   1040             png_debug(1, "in png_write_bKGD\n");
   1041             if (color_type == PNG_COLOR_TYPE_PALETTE)
   1042             {
   1043                if (
   1044          #if defined(PNG_MNG_FEATURES_SUPPORTED)
   1045                    (png_ptr->num_palette ||
   1046                    (!(png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE))) &&
   1047          #endif
   1048                   back->index > png_ptr->num_palette)
   1049                {
   1050                   png_warning(png_ptr, "Invalid background palette index");
   1051                   return;
   1052                }
   1053                buf[0] = back->index;
   1054                png_write_chunk(png_ptr, (png_bytep)png_bKGD, buf, (png_size_t)1);
   1055             }
   1056             else if (color_type & PNG_COLOR_MASK_COLOR)
   1057             {
   1058                png_save_uint_16(buf, back->red);
   1059                png_save_uint_16(buf + 2, back->green);
   1060                png_save_uint_16(buf + 4, back->blue);
   1061                if(png_ptr->bit_depth == 8 && (buf[0] | buf[2] | buf[4]))
   1062                   {
   1063                      png_warning(png_ptr,
   1064                        "Ignoring attempt to write 16-bit bKGD chunk when bit_depth is 8");
   1065                      return;
   1066                   }
   1067                png_write_chunk(png_ptr, (png_bytep)png_bKGD, buf, (png_size_t)6);
   1068             }
   1069             else
   1070             {
   1071                if(back->gray >= (1 << png_ptr->bit_depth))
   1072                {
   1073                   png_warning(png_ptr,
   1074                     "Ignoring attempt to write bKGD chunk out-of-range for bit_depth");
   1075                   return;
   1076                }
   1077                png_save_uint_16(buf, back->gray);
   1078                png_write_chunk(png_ptr, (png_bytep)png_bKGD, buf, (png_size_t)2);
   1079             }
   1080          }
   1081          #endif
   1082          
   1083          #if defined(PNG_WRITE_hIST_SUPPORTED)
   1084          /* write the histogram */
   1085          void /* PRIVATE */
   1086          png_write_hIST(png_structp png_ptr, png_uint_16p hist, int num_hist)
   1087          {
   1088          #ifdef PNG_USE_LOCAL_ARRAYS
   1089             PNG_hIST;
   1090          #endif
   1091             int i;
   1092             png_byte buf[3];
   1093          
   1094             png_debug(1, "in png_write_hIST\n");
   1095             if (num_hist > (int)png_ptr->num_palette)
   1096             {
   1097                png_debug2(3, "num_hist = %d, num_palette = %d\n", num_hist,
   1098                   png_ptr->num_palette);
   1099                png_warning(png_ptr, "Invalid number of histogram entries specified");
   1100                return;
   1101             }
   1102          
   1103             png_write_chunk_start(png_ptr, (png_bytep)png_hIST, (png_uint_32)(num_hist * 2));
   1104             for (i = 0; i < num_hist; i++)
   1105             {
   1106                png_save_uint_16(buf, hist[i]);
   1107                png_write_chunk_data(png_ptr, buf, (png_size_t)2);
   1108             }
   1109             png_write_chunk_end(png_ptr);
   1110          }
   1111          #endif
   1112          
   1113          #if defined(PNG_WRITE_TEXT_SUPPORTED) || defined(PNG_WRITE_pCAL_SUPPORTED) || \
   1114              defined(PNG_WRITE_iCCP_SUPPORTED) || defined(PNG_WRITE_sPLT_SUPPORTED)
   1115          /* Check that the tEXt or zTXt keyword is valid per PNG 1.0 specification,
   1116           * and if invalid, correct the keyword rather than discarding the entire
   1117           * chunk.  The PNG 1.0 specification requires keywords 1-79 characters in
   1118           * length, forbids leading or trailing whitespace, multiple internal spaces,
   1119           * and the non-break space (0x80) from ISO 8859-1.  Returns keyword length.
   1120           *
   1121           * The new_key is allocated to hold the corrected keyword and must be freed
   1122           * by the calling routine.  This avoids problems with trying to write to
   1123           * static keywords without having to have duplicate copies of the strings.
   1124           */
   1125          png_size_t /* PRIVATE */
   1126          png_check_keyword(png_structp png_ptr, png_charp key, png_charpp new_key)
   1127          {
   1128             png_size_t key_len;
   1129             png_charp kp, dp;
   1130             int kflag;
   1131             int kwarn=0;
   1132          
   1133             png_debug(1, "in png_check_keyword\n");
   1134             *new_key = NULL;
   1135          
   1136             if (key == NULL || (key_len = png_strlen(key)) == 0)
   1137             {
   1138                png_warning(png_ptr, "zero length keyword");
   1139                return ((png_size_t)0);
   1140             }
   1141          
   1142             png_debug1(2, "Keyword to be checked is '%s'\n", key);
   1143          
   1144             *new_key = (png_charp)png_malloc(png_ptr, (png_uint_32)(key_len + 2));
   1145          
   1146             /* Replace non-printing characters with a blank and print a warning */
   1147             for (kp = key, dp = *new_key; *kp != '\0'; kp++, dp++)
   1148             {
   1149                if (*kp < 0x20 || (*kp > 0x7E && (png_byte)*kp < 0xA1))
   1150                {
   1151          #if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
   1152                   char msg[40];
   1153          
   1154                   sprintf(msg, "invalid keyword character 0x%02X", *kp);
   1155                   png_warning(png_ptr, msg);
   1156          #else
   1157                   png_warning(png_ptr, "invalid character in keyword");
   1158          #endif
   1159                   *dp = ' ';
   1160                }
   1161                else
   1162                {
   1163                   *dp = *kp;
   1164                }
   1165             }
   1166             *dp = '\0';
   1167          
   1168             /* Remove any trailing white space. */
   1169             kp = *new_key + key_len - 1;
   1170             if (*kp == ' ')
   1171             {
   1172                png_warning(png_ptr, "trailing spaces removed from keyword");
   1173          
   1174                while (*kp == ' ')
   1175                {
   1176                  *(kp--) = '\0';
   1177                  key_len--;
   1178                }
   1179             }
   1180          
   1181             /* Remove any leading white space. */
   1182             kp = *new_key;
   1183             if (*kp == ' ')
   1184             {
   1185                png_warning(png_ptr, "leading spaces removed from keyword");
   1186          
   1187                while (*kp == ' ')
   1188                {
   1189                  kp++;
   1190                  key_len--;
   1191                }
   1192             }
   1193          
   1194             png_debug1(2, "Checking for multiple internal spaces in '%s'\n", kp);
   1195          
   1196             /* Remove multiple internal spaces. */
   1197             for (kflag = 0, dp = *new_key; *kp != '\0'; kp++)
   1198             {
   1199                if (*kp == ' ' && kflag == 0)
   1200                {
   1201                   *(dp++) = *kp;
   1202                   kflag = 1;
   1203                }
   1204                else if (*kp == ' ')
   1205                {
   1206                   key_len--;
   1207                   kwarn=1;
   1208                }
   1209                else
   1210                {
   1211                   *(dp++) = *kp;
   1212                   kflag = 0;
   1213                }
   1214             }
   1215             *dp = '\0';
   1216             if(kwarn)
   1217                png_warning(png_ptr, "extra interior spaces removed from keyword");
   1218          
   1219             if (key_len == 0)
   1220             {
   1221                png_free(png_ptr, *new_key);
   1222                *new_key=NULL;
   1223                png_warning(png_ptr, "Zero length keyword");
   1224             }
   1225          
   1226             if (key_len > 79)
   1227             {
   1228                png_warning(png_ptr, "keyword length must be 1 - 79 characters");
   1229                new_key[79] = '\0';
   1230                key_len = 79;
   1231             }
   1232          
   1233             return (key_len);
   1234          }
   1235          #endif
   1236          
   1237          #if defined(PNG_WRITE_tEXt_SUPPORTED)
   1238          /* write a tEXt chunk */
   1239          void /* PRIVATE */
   1240          png_write_tEXt(png_structp png_ptr, png_charp key, png_charp text,
   1241             png_size_t text_len)
   1242          {
   1243          #ifdef PNG_USE_LOCAL_ARRAYS
   1244             PNG_tEXt;
   1245          #endif
   1246             png_size_t key_len;
   1247             png_charp new_key;
   1248          
   1249             png_debug(1, "in png_write_tEXt\n");
   1250             if (key == NULL || (key_len = png_check_keyword(png_ptr, key, &new_key))==0)
   1251             {
   1252                png_warning(png_ptr, "Empty keyword in tEXt chunk");
   1253                return;
   1254             }
   1255          
   1256             if (text == NULL || *text == '\0')
   1257                text_len = 0;
   1258             else
   1259                text_len = png_strlen(text);
   1260          
   1261             /* make sure we include the 0 after the key */
   1262             png_write_chunk_start(png_ptr, (png_bytep)png_tEXt, (png_uint_32)key_len+text_len+1);
   1263             /*
   1264              * We leave it to the application to meet PNG-1.0 requirements on the
   1265              * contents of the text.  PNG-1.0 through PNG-1.2 discourage the use of
   1266              * any non-Latin-1 characters except for NEWLINE.  ISO PNG will forbid them.
   1267              * The NUL character is forbidden by PNG-1.0 through PNG-1.2 and ISO PNG.
   1268              */
   1269             png_write_chunk_data(png_ptr, (png_bytep)new_key, key_len + 1);
   1270             if (text_len)
   1271                png_write_chunk_data(png_ptr, (png_bytep)text, text_len);
   1272          
   1273             png_write_chunk_end(png_ptr);
   1274             png_free(png_ptr, new_key);
   1275          }
   1276          #endif
   1277          
   1278          #if defined(PNG_WRITE_zTXt_SUPPORTED)
   1279          /* write a compressed text chunk */
   1280          void /* PRIVATE */
   1281          png_write_zTXt(png_structp png_ptr, png_charp key, png_charp text,
   1282             png_size_t text_len, int compression)
   1283          {
   1284          #ifdef PNG_USE_LOCAL_ARRAYS
   1285             PNG_zTXt;
   1286          #endif
   1287             png_size_t key_len;
   1288             char buf[1];
   1289             png_charp new_key;
   1290             compression_state comp;
   1291          
   1292             png_debug(1, "in png_write_zTXt\n");
   1293          
   1294             if (key == NULL || (key_len = png_check_keyword(png_ptr, key, &new_key))==0)
   1295             {
   1296                png_warning(png_ptr, "Empty keyword in zTXt chunk");
   1297                return;
   1298             }
   1299          
   1300             if (text == NULL || *text == '\0' || compression==PNG_TEXT_COMPRESSION_NONE)
   1301             {
   1302                png_write_tEXt(png_ptr, new_key, text, (png_size_t)0);
   1303                png_free(png_ptr, new_key);
   1304                return;
   1305             }
   1306          
   1307             text_len = png_strlen(text);
   1308          
   1309             png_free(png_ptr, new_key);
   1310          
   1311             /* compute the compressed data; do it now for the length */
   1312             text_len = png_text_compress(png_ptr, text, text_len, compression,
   1313                 &comp);
   1314          
   1315             /* write start of chunk */
   1316             png_write_chunk_start(png_ptr, (png_bytep)png_zTXt, (png_uint_32)
   1317                (key_len+text_len+2));
   1318             /* write key */
   1319             png_write_chunk_data(png_ptr, (png_bytep)key, key_len + 1);
   1320             buf[0] = (png_byte)compression;
   1321             /* write compression */
   1322             png_write_chunk_data(png_ptr, (png_bytep)buf, (png_size_t)1);
   1323             /* write the compressed data */
   1324             png_write_compressed_data_out(png_ptr, &comp);
   1325          
   1326             /* close the chunk */
   1327             png_write_chunk_end(png_ptr);
   1328          }
   1329          #endif
   1330          
   1331          #if defined(PNG_WRITE_iTXt_SUPPORTED)
   1332          /* write an iTXt chunk */
   1333          void /* PRIVATE */
   1334          png_write_iTXt(png_structp png_ptr, int compression, png_charp key,
   1335              png_charp lang, png_charp lang_key, png_charp text)
   1336          {
   1337          #ifdef PNG_USE_LOCAL_ARRAYS
   1338             PNG_iTXt;
   1339          #endif
   1340             png_size_t lang_len, key_len, lang_key_len, text_len;
   1341             png_charp new_lang, new_key;
   1342             png_byte cbuf[2];
   1343             compression_state comp;
   1344          
   1345             png_debug(1, "in png_write_iTXt\n");
   1346          
   1347             if (key == NULL || (key_len = png_check_keyword(png_ptr, key, &new_key))==0)
   1348             {
   1349                png_warning(png_ptr, "Empty keyword in iTXt chunk");
   1350                return;
   1351             }
   1352             if (lang == NULL || (lang_len = png_check_keyword(png_ptr, lang,
   1353                &new_lang))==0)
   1354             {
   1355                png_warning(png_ptr, "Empty language field in iTXt chunk");
   1356                return;
   1357             }
   1358             lang_key_len = png_strlen(lang_key);
   1359             text_len = png_strlen(text);
   1360          
   1361             if (text == NULL || *text == '\0')
   1362                text_len = 0;
   1363          
   1364             /* compute the compressed data; do it now for the length */
   1365             text_len = png_text_compress(png_ptr, text, text_len, compression-2,
   1366                &comp);
   1367          
   1368             /* make sure we include the compression flag, the compression byte,
   1369              * and the NULs after the key, lang, and lang_key parts */
   1370          
   1371             png_write_chunk_start(png_ptr, (png_bytep)png_iTXt,
   1372                    (png_uint_32)(
   1373                  5 /* comp byte, comp flag, terminators for key, lang and lang_key */
   1374                  + key_len
   1375                  + lang_len
   1376                  + lang_key_len
   1377                  + text_len));
   1378          
   1379             /*
   1380              * We leave it to the application to meet PNG-1.0 requirements on the
   1381              * contents of the text.  PNG-1.0 through PNG-1.2 discourage the use of
   1382              * any non-Latin-1 characters except for NEWLINE.  ISO PNG will forbid them.
   1383              * The NUL character is forbidden by PNG-1.0 through PNG-1.2 and ISO PNG.
   1384              */
   1385             png_write_chunk_data(png_ptr, (png_bytep)new_key, key_len + 1);
   1386          
   1387             /* set the compression flag */
   1388             if (compression == PNG_ITXT_COMPRESSION_NONE || \
   1389                 compression == PNG_TEXT_COMPRESSION_NONE)
   1390                 cbuf[0] = 0;
   1391             else /* compression == PNG_ITXT_COMPRESSION_zTXt */
   1392                 cbuf[0] = 1;
   1393             /* set the compression method */
   1394             cbuf[1] = 0;
   1395             png_write_chunk_data(png_ptr, cbuf, 2);
   1396          
   1397             png_write_chunk_data(png_ptr, (png_bytep)new_lang, lang_len + 1);
   1398             png_write_chunk_data(png_ptr, (png_bytep)lang_key, lang_key_len+1);
   1399             png_write_chunk_data(png_ptr, '\0', 1);
   1400          
   1401             png_write_compressed_data_out(png_ptr, &comp);
   1402          
   1403             png_write_chunk_end(png_ptr);
   1404             png_free(png_ptr, new_key);
   1405             png_free(png_ptr, new_lang);
   1406          }
   1407          #endif
   1408          
   1409          #if defined(PNG_WRITE_oFFs_SUPPORTED)
   1410          /* write the oFFs chunk */
   1411          void /* PRIVATE */
   1412          png_write_oFFs(png_structp png_ptr, png_int_32 x_offset, png_int_32 y_offset,
   1413             int unit_type)
   1414          {
   1415          #ifdef PNG_USE_LOCAL_ARRAYS
   1416             PNG_oFFs;
   1417          #endif
   1418             png_byte buf[9];
   1419          
   1420             png_debug(1, "in png_write_oFFs\n");
   1421             if (unit_type >= PNG_OFFSET_LAST)
   1422                png_warning(png_ptr, "Unrecognized unit type for oFFs chunk");
   1423          
   1424             png_save_int_32(buf, x_offset);
   1425             png_save_int_32(buf + 4, y_offset);
   1426             buf[8] = (png_byte)unit_type;
   1427          
   1428             png_write_chunk(png_ptr, (png_bytep)png_oFFs, buf, (png_size_t)9);
   1429          }
   1430          #endif
   1431          
   1432          #if defined(PNG_WRITE_pCAL_SUPPORTED)
   1433          /* write the pCAL chunk (described in the PNG extensions document) */
   1434          void /* PRIVATE */
   1435          png_write_pCAL(png_structp png_ptr, png_charp purpose, png_int_32 X0,
   1436             png_int_32 X1, int type, int nparams, png_charp units, png_charpp params)
   1437          {
   1438          #ifdef PNG_USE_LOCAL_ARRAYS
   1439             PNG_pCAL;
   1440          #endif
   1441             png_size_t purpose_len, units_len, total_len;
   1442             png_uint_32p params_len;
   1443             png_byte buf[10];
   1444             png_charp new_purpose;
   1445             int i;
   1446          
   1447             png_debug1(1, "in png_write_pCAL (%d parameters)\n", nparams);
   1448             if (type >= PNG_EQUATION_LAST)
   1449                png_warning(png_ptr, "Unrecognized equation type for pCAL chunk");
   1450          
   1451             purpose_len = png_check_keyword(png_ptr, purpose, &new_purpose) + 1;
   1452             png_debug1(3, "pCAL purpose length = %d\n", (int)purpose_len);
   1453             units_len = png_strlen(units) + (nparams == 0 ? 0 : 1);
   1454             png_debug1(3, "pCAL units length = %d\n", (int)units_len);
   1455             total_len = purpose_len + units_len + 10;
   1456          
   1457             params_len = (png_uint_32p)png_malloc(png_ptr, (png_uint_32)(nparams
   1458                *sizeof(png_uint_32)));
   1459          
   1460             /* Find the length of each parameter, making sure we don't count the
   1461                null terminator for the last parameter. */
   1462             for (i = 0; i < nparams; i++)
   1463             {
   1464                params_len[i] = (png_uint_32)(png_strlen(params[i]) + (i == nparams - 1 ? 0 : 1));
   1465          	  // JL 03/24/2002 - fixed incorrect typeconversion
   1466                png_debug2(3, "pCAL parameter %d length = %lu\n", i, params_len[i]);
   1467                total_len += (png_size_t)params_len[i];
   1468             }
   1469          
   1470             png_debug1(3, "pCAL total length = %d\n", (int)total_len);
   1471             png_write_chunk_start(png_ptr, (png_bytep)png_pCAL, (png_uint_32)total_len);
   1472             png_write_chunk_data(png_ptr, (png_bytep)new_purpose, purpose_len);
   1473             png_save_int_32(buf, X0);
   1474             png_save_int_32(buf + 4, X1);
   1475             buf[8] = (png_byte)type;
   1476             buf[9] = (png_byte)nparams;
   1477             png_write_chunk_data(png_ptr, buf, (png_size_t)10);
   1478             png_write_chunk_data(png_ptr, (png_bytep)units, (png_size_t)units_len);
   1479          
   1480             png_free(png_ptr, new_purpose);
   1481          
   1482             for (i = 0; i < nparams; i++)
   1483             {
   1484                png_write_chunk_data(png_ptr, (png_bytep)params[i],
   1485                   (png_size_t)params_len[i]);
   1486             }
   1487          
   1488             png_free(png_ptr, params_len);
   1489             png_write_chunk_end(png_ptr);
   1490          }
   1491          #endif
   1492          
   1493          #if defined(PNG_WRITE_sCAL_SUPPORTED)
   1494          /* write the sCAL chunk */
   1495          #if defined(PNG_FLOATING_POINT_SUPPORTED) && !defined(PNG_NO_STDIO)
   1496          void /* PRIVATE */
   1497          png_write_sCAL(png_structp png_ptr, int unit, double width,double height)
   1498          {
   1499          #ifdef PNG_USE_LOCAL_ARRAYS
   1500             PNG_sCAL;
   1501          #endif
   1502             png_size_t total_len;
   1503             char wbuf[32], hbuf[32];
   1504          
   1505             png_debug(1, "in png_write_sCAL\n");
   1506          
   1507          #if defined(_WIN32_WCE)
   1508          /* sprintf() function is not supported on WindowsCE */
   1509             {
   1510                wchar_t wc_buf[32];
   1511                swprintf(wc_buf, TEXT("%12.12e"), width);
   1512                WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, wbuf, 32, NULL, NULL);
   1513                swprintf(wc_buf, TEXT("%12.12e"), height);
   1514                WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, hbuf, 32, NULL, NULL);
   1515             }
   1516          #else
   1517             sprintf(wbuf, "%12.12e", width);
   1518             sprintf(hbuf, "%12.12e", height);
   1519          #endif
   1520             total_len = 1 + png_strlen(wbuf)+1 + png_strlen(hbuf);
   1521          
   1522             png_debug1(3, "sCAL total length = %d\n", (int)total_len);
   1523             png_write_chunk_start(png_ptr, (png_bytep)png_sCAL, (png_uint_32)total_len);
   1524             png_write_chunk_data(png_ptr, (png_bytep)&unit, 1);
   1525             png_write_chunk_data(png_ptr, (png_bytep)wbuf, png_strlen(wbuf)+1);
   1526             png_write_chunk_data(png_ptr, (png_bytep)hbuf, png_strlen(hbuf));
   1527          
   1528             png_write_chunk_end(png_ptr);
   1529          }
   1530          #else
   1531          #ifdef PNG_FIXED_POINT_SUPPORTED
   1532          void /* PRIVATE */
   1533          png_write_sCAL_s(png_structp png_ptr, int unit, png_charp width,
   1534             png_charp height)
   1535          {
   1536          #ifdef PNG_USE_LOCAL_ARRAYS
   1537             PNG_sCAL;
   1538          #endif
   1539             png_size_t total_len;
   1540             char wbuf[32], hbuf[32];
   1541          
   1542             png_debug(1, "in png_write_sCAL_s\n");
   1543          
   1544             png_strcpy(wbuf,(const char *)width);
   1545             png_strcpy(hbuf,(const char *)height);
   1546             total_len = 1 + png_strlen(wbuf)+1 + png_strlen(hbuf);
   1547          
   1548             png_debug1(3, "sCAL total length = %d\n", total_len);
   1549             png_write_chunk_start(png_ptr, (png_bytep)png_sCAL, (png_uint_32)total_len);
   1550             png_write_chunk_data(png_ptr, (png_bytep)&unit, 1);
   1551             png_write_chunk_data(png_ptr, (png_bytep)wbuf, png_strlen(wbuf)+1);
   1552             png_write_chunk_data(png_ptr, (png_bytep)hbuf, png_strlen(hbuf));
   1553          
   1554             png_write_chunk_end(png_ptr);
   1555          }
   1556          #endif
   1557          #endif
   1558          #endif
   1559          
   1560          #if defined(PNG_WRITE_pHYs_SUPPORTED)
   1561          /* write the pHYs chunk */
   1562          void /* PRIVATE */
   1563          png_write_pHYs(png_structp png_ptr, png_uint_32 x_pixels_per_unit,
   1564             png_uint_32 y_pixels_per_unit,
   1565             int unit_type)
   1566          {
   1567          #ifdef PNG_USE_LOCAL_ARRAYS
   1568             PNG_pHYs;
   1569          #endif
   1570             png_byte buf[9];
   1571          
   1572             png_debug(1, "in png_write_pHYs\n");
   1573             if (unit_type >= PNG_RESOLUTION_LAST)
   1574                png_warning(png_ptr, "Unrecognized unit type for pHYs chunk");
   1575          
   1576             png_save_uint_32(buf, x_pixels_per_unit);
   1577             png_save_uint_32(buf + 4, y_pixels_per_unit);
   1578             buf[8] = (png_byte)unit_type;
   1579          
   1580             png_write_chunk(png_ptr, (png_bytep)png_pHYs, buf, (png_size_t)9);
   1581          }
   1582          #endif
   1583          
   1584          #if defined(PNG_WRITE_tIME_SUPPORTED)
   1585          /* Write the tIME chunk.  Use either png_convert_from_struct_tm()
   1586           * or png_convert_from_time_t(), or fill in the structure yourself.
   1587           */
   1588          void /* PRIVATE */
   1589          png_write_tIME(png_structp png_ptr, png_timep mod_time)
   1590          {
   1591          #ifdef PNG_USE_LOCAL_ARRAYS
   1592             PNG_tIME;
   1593          #endif
   1594             png_byte buf[7];
   1595          
   1596             png_debug(1, "in png_write_tIME\n");
   1597             if (mod_time->month  > 12 || mod_time->month  < 1 ||
   1598                 mod_time->day    > 31 || mod_time->day    < 1 ||
   1599                 mod_time->hour   > 23 || mod_time->second > 60)
   1600             {
   1601                png_warning(png_ptr, "Invalid time specified for tIME chunk");
   1602                return;
   1603             }
   1604          
   1605             png_save_uint_16(buf, mod_time->year);
   1606             buf[2] = mod_time->month;
   1607             buf[3] = mod_time->day;
   1608             buf[4] = mod_time->hour;
   1609             buf[5] = mod_time->minute;
   1610             buf[6] = mod_time->second;
   1611          
   1612             png_write_chunk(png_ptr, (png_bytep)png_tIME, buf, (png_size_t)7);
   1613          }
   1614          #endif
   1615          
   1616          /* initializes the row writing capability of libpng */
   1617          void /* PRIVATE */
   1618          png_write_start_row(png_structp png_ptr)
   1619          {
   1620          #ifdef PNG_USE_LOCAL_ARRAYS
   1621             /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
   1622          
   1623             /* start of interlace block */
   1624             int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
   1625          
   1626             /* offset to next interlace block */
   1627             int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
   1628          
   1629             /* start of interlace block in the y direction */
   1630             int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
   1631          
   1632             /* offset to next interlace block in the y direction */
   1633             int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
   1634          #endif
   1635          
   1636             png_size_t buf_size;
   1637          
   1638             png_debug(1, "in png_write_start_row\n");
   1639             buf_size = (png_size_t)(((png_ptr->width * png_ptr->usr_channels *
   1640                                      png_ptr->usr_bit_depth + 7) >> 3) + 1);
   1641          
   1642             /* set up row buffer */
   1643             png_ptr->row_buf = (png_bytep)png_malloc(png_ptr, (png_uint_32)buf_size);
   1644             png_ptr->row_buf[0] = PNG_FILTER_VALUE_NONE;
   1645          
   1646             /* set up filtering buffer, if using this filter */
   1647             if (png_ptr->do_filter & PNG_FILTER_SUB)
   1648             {
   1649                png_ptr->sub_row = (png_bytep)png_malloc(png_ptr,
   1650                   (png_ptr->rowbytes + 1));
   1651                png_ptr->sub_row[0] = PNG_FILTER_VALUE_SUB;
   1652             }
   1653          
   1654             /* We only need to keep the previous row if we are using one of these. */
   1655             if (png_ptr->do_filter & (PNG_FILTER_AVG | PNG_FILTER_UP | PNG_FILTER_PAETH))
   1656             {
   1657               /* set up previous row buffer */
   1658                png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, (png_uint_32)buf_size);
   1659                png_memset(png_ptr->prev_row, 0, buf_size);
   1660          
   1661                if (png_ptr->do_filter & PNG_FILTER_UP)
   1662                {
   1663                   png_ptr->up_row = (png_bytep )png_malloc(png_ptr,
   1664                      (png_ptr->rowbytes + 1));
   1665                   png_ptr->up_row[0] = PNG_FILTER_VALUE_UP;
   1666                }
   1667          
   1668                if (png_ptr->do_filter & PNG_FILTER_AVG)
   1669                {
   1670                   png_ptr->avg_row = (png_bytep)png_malloc(png_ptr,
   1671                      (png_ptr->rowbytes + 1));
   1672                   png_ptr->avg_row[0] = PNG_FILTER_VALUE_AVG;
   1673                }
   1674          
   1675                if (png_ptr->do_filter & PNG_FILTER_PAETH)
   1676                {
   1677                   png_ptr->paeth_row = (png_bytep )png_malloc(png_ptr,
   1678                      (png_ptr->rowbytes + 1));
   1679                   png_ptr->paeth_row[0] = PNG_FILTER_VALUE_PAETH;
   1680                }
   1681             }
   1682          
   1683          #ifdef PNG_WRITE_INTERLACING_SUPPORTED
   1684             /* if interlaced, we need to set up width and height of pass */
   1685             if (png_ptr->interlaced)
   1686             {
   1687                if (!(png_ptr->transformations & PNG_INTERLACE))
   1688                {
   1689                   png_ptr->num_rows = (png_ptr->height + png_pass_yinc[0] - 1 -
   1690                      png_pass_ystart[0]) / png_pass_yinc[0];
   1691                   png_ptr->usr_width = (png_ptr->width + png_pass_inc[0] - 1 -
   1692                      png_pass_start[0]) / png_pass_inc[0];
   1693                }
   1694                else
   1695                {
   1696                   png_ptr->num_rows = png_ptr->height;
   1697                   png_ptr->usr_width = png_ptr->width;
   1698                }
   1699             }
   1700             else
   1701          #endif
   1702             {
   1703                png_ptr->num_rows = png_ptr->height;
   1704                png_ptr->usr_width = png_ptr->width;
   1705             }
   1706             png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
   1707             png_ptr->zstream.next_out = png_ptr->zbuf;
   1708          }
   1709          
   1710          /* Internal use only.  Called when finished processing a row of data. */
   1711          void /* PRIVATE */
   1712          png_write_finish_row(png_structp png_ptr)
   1713          {
   1714          #ifdef PNG_USE_LOCAL_ARRAYS
   1715             /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
   1716          
   1717             /* start of interlace block */
   1718             int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
   1719          
   1720             /* offset to next interlace block */
   1721             int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
   1722          
   1723             /* start of interlace block in the y direction */
   1724             int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
   1725          
   1726             /* offset to next interlace block in the y direction */
   1727             int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
   1728          #endif
   1729          
   1730             int ret;
   1731          
   1732             png_debug(1, "in png_write_finish_row\n");
   1733             /* next row */
   1734             png_ptr->row_number++;
   1735          
   1736             /* see if we are done */
   1737             if (png_ptr->row_number < png_ptr->num_rows)
   1738                return;
   1739          
   1740          #ifdef PNG_WRITE_INTERLACING_SUPPORTED
   1741             /* if interlaced, go to next pass */
   1742             if (png_ptr->interlaced)
   1743             {
   1744                png_ptr->row_number = 0;
   1745                if (png_ptr->transformations & PNG_INTERLACE)
   1746                {
   1747                   png_ptr->pass++;
   1748                }
   1749                else
   1750                {
   1751                   /* loop until we find a non-zero width or height pass */
   1752                   do
   1753                   {
   1754                      png_ptr->pass++;
   1755                      if (png_ptr->pass >= 7)
   1756                         break;
   1757                      png_ptr->usr_width = (png_ptr->width +
   1758                         png_pass_inc[png_ptr->pass] - 1 -
   1759                         png_pass_start[png_ptr->pass]) /
   1760                         png_pass_inc[png_ptr->pass];
   1761                      png_ptr->num_rows = (png_ptr->height +
   1762                         png_pass_yinc[png_ptr->pass] - 1 -
   1763                         png_pass_ystart[png_ptr->pass]) /
   1764                         png_pass_yinc[png_ptr->pass];
   1765                      if (png_ptr->transformations & PNG_INTERLACE)
   1766                         break;
   1767                   } while (png_ptr->usr_width == 0 || png_ptr->num_rows == 0);
   1768          
   1769                }
   1770          
   1771                /* reset the row above the image for the next pass */
   1772                if (png_ptr->pass < 7)
   1773                {
   1774                   if (png_ptr->prev_row != NULL)
   1775                      png_memset(png_ptr->prev_row, 0,
   1776                         (png_size_t) (((png_uint_32)png_ptr->usr_channels *
   1777                         (png_uint_32)png_ptr->usr_bit_depth *
   1778                         png_ptr->width + 7) >> 3) + 1);
   1779                   return;
   1780                }
   1781             }
   1782          #endif
   1783          
   1784             /* if we get here, we've just written the last row, so we need
   1785                to flush the compressor */
   1786             do
   1787             {
   1788                /* tell the compressor we are done */
   1789                ret = deflate(&png_ptr->zstream, Z_FINISH);
   1790                /* check for an error */
   1791                if (ret == Z_OK)
   1792                {
   1793                   /* check to see if we need more room */
   1794                   if (!(png_ptr->zstream.avail_out))
   1795                   {
   1796                      png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);
   1797                      png_ptr->zstream.next_out = png_ptr->zbuf;
   1798                      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
   1799                   }
   1800                }
   1801                else if (ret != Z_STREAM_END)
   1802                {
   1803                   if (png_ptr->zstream.msg != NULL)
   1804                      png_error(png_ptr, png_ptr->zstream.msg);
   1805                   else
   1806                      png_error(png_ptr, "zlib error");
   1807                }
   1808             } while (ret != Z_STREAM_END);
   1809          
   1810             /* write any extra space */
   1811             if (png_ptr->zstream.avail_out < png_ptr->zbuf_size)
   1812             {
   1813                png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size -
   1814                   png_ptr->zstream.avail_out);
   1815             }
   1816          
   1817             deflateReset(&png_ptr->zstream);
   1818          }
   1819          
   1820          #if defined(PNG_WRITE_INTERLACING_SUPPORTED)
   1821          /* Pick out the correct pixels for the interlace pass.
   1822           * The basic idea here is to go through the row with a source
   1823           * pointer and a destination pointer (sp and dp), and copy the
   1824           * correct pixels for the pass.  As the row gets compacted,
   1825           * sp will always be >= dp, so we should never overwrite anything.
   1826           * See the default: case for the easiest code to understand.
   1827           */
   1828          void /* PRIVATE */
   1829          png_do_write_interlace(png_row_infop row_info, png_bytep row, int pass)
   1830          {
   1831          #ifdef PNG_USE_LOCAL_ARRAYS
   1832             /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
   1833          
   1834             /* start of interlace block */
   1835             int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
   1836          
   1837             /* offset to next interlace block */
   1838             int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
   1839          #endif
   1840          
   1841             png_debug(1, "in png_do_write_interlace\n");
   1842             /* we don't have to do anything on the last pass (6) */
   1843          #if defined(PNG_USELESS_TESTS_SUPPORTED)
   1844             if (row != NULL && row_info != NULL && pass < 6)
   1845          #else
   1846             if (pass < 6)
   1847          #endif
   1848             {
   1849                /* each pixel depth is handled separately */
   1850                switch (row_info->pixel_depth)
   1851                {
   1852                   case 1:
   1853                   {
   1854                      png_bytep sp;
   1855                      png_bytep dp;
   1856                      int shift;
   1857                      int d;
   1858                      int value;
   1859                      png_uint_32 i;
   1860                      png_uint_32 row_width = row_info->width;
   1861          
   1862                      dp = row;
   1863                      d = 0;
   1864                      shift = 7;
   1865                      for (i = png_pass_start[pass]; i < row_width;
   1866                         i += png_pass_inc[pass])
   1867                      {
   1868                         sp = row + (png_size_t)(i >> 3);
   1869                         value = (int)(*sp >> (7 - (int)(i & 0x07))) & 0x01;
   1870                         d |= (value << shift);
   1871          
   1872                         if (shift == 0)
   1873                         {
   1874                            shift = 7;
   1875                            *dp++ = (png_byte)d;
   1876                            d = 0;
   1877                         }
   1878                         else
   1879                            shift--;
   1880          
   1881                      }
   1882                      if (shift != 7)
   1883                         *dp = (png_byte)d;
   1884                      break;
   1885                   }
   1886                   case 2:
   1887                   {
   1888                      png_bytep sp;
   1889                      png_bytep dp;
   1890                      int shift;
   1891                      int d;
   1892                      int value;
   1893                      png_uint_32 i;
   1894                      png_uint_32 row_width = row_info->width;
   1895          
   1896                      dp = row;
   1897                      shift = 6;
   1898                      d = 0;
   1899                      for (i = png_pass_start[pass]; i < row_width;
   1900                         i += png_pass_inc[pass])
   1901                      {
   1902                         sp = row + (png_size_t)(i >> 2);
   1903                         value = (*sp >> ((3 - (int)(i & 0x03)) << 1)) & 0x03;
   1904                         d |= (value << shift);
   1905          
   1906                         if (shift == 0)
   1907                         {
   1908                            shift = 6;
   1909                            *dp++ = (png_byte)d;
   1910                            d = 0;
   1911                         }
   1912                         else
   1913                            shift -= 2;
   1914                      }
   1915                      if (shift != 6)
   1916                             *dp = (png_byte)d;
   1917                      break;
   1918                   }
   1919                   case 4:
   1920                   {
   1921                      png_bytep sp;
   1922                      png_bytep dp;
   1923                      int shift;
   1924                      int d;
   1925                      int value;
   1926                      png_uint_32 i;
   1927                      png_uint_32 row_width = row_info->width;
   1928          
   1929                      dp = row;
   1930                      shift = 4;
   1931                      d = 0;
   1932                      for (i = png_pass_start[pass]; i < row_width;
   1933                         i += png_pass_inc[pass])
   1934                      {
   1935                         sp = row + (png_size_t)(i >> 1);
   1936                         value = (*sp >> ((1 - (int)(i & 0x01)) << 2)) & 0x0f;
   1937                         d |= (value << shift);
   1938          
   1939                         if (shift == 0)
   1940                         {
   1941                            shift = 4;
   1942                            *dp++ = (png_byte)d;
   1943                            d = 0;
   1944                         }
   1945                         else
   1946                            shift -= 4;
   1947                      }
   1948                      if (shift != 4)
   1949                         *dp = (png_byte)d;
   1950                      break;
   1951                   }
   1952                   default:
   1953                   {
   1954                      png_bytep sp;
   1955                      png_bytep dp;
   1956                      png_uint_32 i;
   1957                      png_uint_32 row_width = row_info->width;
   1958                      png_size_t pixel_bytes;
   1959          
   1960                      /* start at the beginning */
   1961                      dp = row;
   1962                      /* find out how many bytes each pixel takes up */
   1963                      pixel_bytes = (row_info->pixel_depth >> 3);
   1964                      /* loop through the row, only looking at the pixels that
   1965                         matter */
   1966                      for (i = png_pass_start[pass]; i < row_width;
   1967                         i += png_pass_inc[pass])
   1968                      {
   1969                         /* find out where the original pixel is */
   1970                         sp = row + (png_size_t)i * pixel_bytes;
   1971                         /* move the pixel */
   1972                         if (dp != sp)
   1973                            png_memcpy(dp, sp, pixel_bytes);
   1974                         /* next pixel */
   1975                         dp += pixel_bytes;
   1976                      }
   1977                      break;
   1978                   }
   1979                }
   1980                /* set new row width */
   1981                row_info->width = (row_info->width +
   1982                   png_pass_inc[pass] - 1 -
   1983                   png_pass_start[pass]) /
   1984                   png_pass_inc[pass];
   1985                   row_info->rowbytes = ((row_info->width *
   1986                      row_info->pixel_depth + 7) >> 3);
   1987             }
   1988          }
   1989          #endif
   1990          
   1991          /* This filters the row, chooses which filter to use, if it has not already
   1992           * been specified by the application, and then writes the row out with the
   1993           * chosen filter.
   1994           */
   1995          #define PNG_MAXSUM (~((png_uint_32)0) >> 1)
   1996          #define PNG_HISHIFT 10
   1997          #define PNG_LOMASK ((png_uint_32)0xffffL)
   1998          #define PNG_HIMASK ((png_uint_32)(~PNG_LOMASK >> PNG_HISHIFT))
   1999          void /* PRIVATE */
   2000          png_write_find_filter(png_structp png_ptr, png_row_infop row_info)
   2001          {
   2002             png_bytep prev_row, best_row, row_buf;
   2003             png_uint_32 mins, bpp;
   2004             png_byte filter_to_do = png_ptr->do_filter;
   2005             png_uint_32 row_bytes = row_info->rowbytes;
   2006          #if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
   2007             int num_p_filters = (int)png_ptr->num_prev_filters;
   2008          #endif
   2009          
   2010             png_debug(1, "in png_write_find_filter\n");
   2011             /* find out how many bytes offset each pixel is */
   2012             bpp = (row_info->pixel_depth + 7) / 8;
   2013          
   2014             prev_row = png_ptr->prev_row;
   2015             best_row = row_buf = png_ptr->row_buf;
   2016             mins = PNG_MAXSUM;
   2017          
   2018             /* The prediction method we use is to find which method provides the
   2019              * smallest value when summing the absolute values of the distances
   2020              * from zero, using anything >= 128 as negative numbers.  This is known
   2021              * as the "minimum sum of absolute differences" heuristic.  Other
   2022              * heuristics are the "weighted minimum sum of absolute differences"
   2023              * (experimental and can in theory improve compression), and the "zlib
   2024              * predictive" method (not implemented yet), which does test compressions
   2025              * of lines using different filter methods, and then chooses the
   2026              * (series of) filter(s) that give minimum compressed data size (VERY
   2027              * computationally expensive).
   2028              *
   2029              * GRR 980525:  consider also
   2030              *   (1) minimum sum of absolute differences from running average (i.e.,
   2031              *       keep running sum of non-absolute differences & count of bytes)
   2032              *       [track dispersion, too?  restart average if dispersion too large?]
   2033              *  (1b) minimum sum of absolute differences from sliding average, probably
   2034              *       with window size <= deflate window (usually 32K)
   2035              *   (2) minimum sum of squared differences from zero or running average
   2036              *       (i.e., ~ root-mean-square approach)
   2037              */
   2038          
   2039          
   2040             /* We don't need to test the 'no filter' case if this is the only filter
   2041              * that has been chosen, as it doesn't actually do anything to the data.
   2042              */
   2043             if ((filter_to_do & PNG_FILTER_NONE) &&
   2044                 filter_to_do != PNG_FILTER_NONE)
   2045             {
   2046                png_bytep rp;
   2047                png_uint_32 sum = 0;
   2048                png_uint_32 i;
   2049                int v;
   2050          
   2051                for (i = 0, rp = row_buf + 1; i < row_bytes; i++, rp++)
   2052                {
   2053                   v = *rp;
   2054                   sum += (v < 128) ? v : 256 - v;
   2055                }
   2056          
   2057          #if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
   2058                if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
   2059                {
   2060                   png_uint_32 sumhi, sumlo;
   2061                   int j;
   2062                   sumlo = sum & PNG_LOMASK;
   2063                   sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK; /* Gives us some footroom */
   2064          
   2065                   /* Reduce the sum if we match any of the previous rows */
   2066                   for (j = 0; j < num_p_filters; j++)
   2067                   {
   2068                      if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_NONE)
   2069                      {
   2070                         sumlo = (sumlo * png_ptr->filter_weights[j]) >>
   2071                            PNG_WEIGHT_SHIFT;
   2072                         sumhi = (sumhi * png_ptr->filter_weights[j]) >>
   2073                            PNG_WEIGHT_SHIFT;
   2074                      }
   2075                   }
   2076          
   2077                   /* Factor in the cost of this filter (this is here for completeness,
   2078                    * but it makes no sense to have a "cost" for the NONE filter, as
   2079                    * it has the minimum possible computational cost - none).
   2080                    */
   2081                   sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_NONE]) >>
   2082                      PNG_COST_SHIFT;
   2083                   sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_NONE]) >>
   2084                      PNG_COST_SHIFT;
   2085          
   2086                   if (sumhi > PNG_HIMASK)
   2087                      sum = PNG_MAXSUM;
   2088                   else
   2089                      sum = (sumhi << PNG_HISHIFT) + sumlo;
   2090                }
   2091          #endif
   2092                mins = sum;
   2093             }
   2094          
   2095             /* sub filter */
   2096             if (filter_to_do == PNG_FILTER_SUB)
   2097             /* it's the only filter so no testing is needed */
   2098             {
   2099                png_bytep rp, lp, dp;
   2100                png_uint_32 i;
   2101                for (i = 0, rp = row_buf + 1, dp = png_ptr->sub_row + 1; i < bpp;
   2102                     i++, rp++, dp++)
   2103                {
   2104                   *dp = *rp;
   2105                }
   2106                for (lp = row_buf + 1; i < row_bytes;
   2107                   i++, rp++, lp++, dp++)
   2108                {
   2109                   *dp = (png_byte)(((int)*rp - (int)*lp) & 0xff);
   2110                }
   2111                best_row = png_ptr->sub_row;
   2112             }
   2113          
   2114             else if (filter_to_do & PNG_FILTER_SUB)
   2115             {
   2116                png_bytep rp, dp, lp;
   2117                png_uint_32 sum = 0, lmins = mins;
   2118                png_uint_32 i;
   2119                int v;
   2120          
   2121          #if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
   2122                /* We temporarily increase the "minimum sum" by the factor we
   2123                 * would reduce the sum of this filter, so that we can do the
   2124                 * early exit comparison without scaling the sum each time.
   2125                 */
   2126                if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
   2127                {
   2128                   int j;
   2129                   png_uint_32 lmhi, lmlo;
   2130                   lmlo = lmins & PNG_LOMASK;
   2131                   lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;
   2132          
   2133                   for (j = 0; j < num_p_filters; j++)
   2134                   {
   2135                      if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_SUB)
   2136                      {
   2137                         lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
   2138                            PNG_WEIGHT_SHIFT;
   2139                         lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
   2140                            PNG_WEIGHT_SHIFT;
   2141                      }
   2142                   }
   2143          
   2144                   lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
   2145                      PNG_COST_SHIFT;
   2146                   lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
   2147                      PNG_COST_SHIFT;
   2148          
   2149                   if (lmhi > PNG_HIMASK)
   2150                      lmins = PNG_MAXSUM;
   2151                   else
   2152                      lmins = (lmhi << PNG_HISHIFT) + lmlo;
   2153                }
   2154          #endif
   2155          
   2156                for (i = 0, rp = row_buf + 1, dp = png_ptr->sub_row + 1; i < bpp;
   2157                     i++, rp++, dp++)
   2158                {
   2159                   v = *dp = *rp;
   2160          
   2161                   sum += (v < 128) ? v : 256 - v;
   2162                }
   2163                for (lp = row_buf + 1; i < row_info->rowbytes;
   2164                   i++, rp++, lp++, dp++)
   2165                {
   2166                   v = *dp = (png_byte)(((int)*rp - (int)*lp) & 0xff);
   2167          
   2168                   sum += (v < 128) ? v : 256 - v;
   2169          
   2170                   if (sum > lmins)  /* We are already worse, don't continue. */
   2171                      break;
   2172                }
   2173          
   2174          #if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
   2175                if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
   2176                {
   2177                   int j;
   2178                   png_uint_32 sumhi, sumlo;
   2179                   sumlo = sum & PNG_LOMASK;
   2180                   sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;
   2181          
   2182                   for (j = 0; j < num_p_filters; j++)
   2183                   {
   2184                      if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_SUB)
   2185                      {
   2186                         sumlo = (sumlo * png_ptr->inv_filter_weights[j]) >>
   2187                            PNG_WEIGHT_SHIFT;
   2188                         sumhi = (sumhi * png_ptr->inv_filter_weights[j]) >>
   2189                            PNG_WEIGHT_SHIFT;
   2190                      }
   2191                   }
   2192          
   2193                   sumlo = (sumlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
   2194                      PNG_COST_SHIFT;
   2195                   sumhi = (sumhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
   2196                      PNG_COST_SHIFT;
   2197          
   2198                   if (sumhi > PNG_HIMASK)
   2199                      sum = PNG_MAXSUM;
   2200                   else
   2201                      sum = (sumhi << PNG_HISHIFT) + sumlo;
   2202                }
   2203          #endif
   2204          
   2205                if (sum < mins)
   2206                {
   2207                   mins = sum;
   2208                   best_row = png_ptr->sub_row;
   2209                }
   2210             }
   2211          
   2212             /* up filter */
   2213             if (filter_to_do == PNG_FILTER_UP)
   2214             {
   2215                png_bytep rp, dp, pp;
   2216                png_uint_32 i;
   2217          
   2218                for (i = 0, rp = row_buf + 1, dp = png_ptr->up_row + 1,
   2219                     pp = prev_row + 1; i < row_bytes;
   2220                     i++, rp++, pp++, dp++)
   2221                {
   2222                   *dp = (png_byte)(((int)*rp - (int)*pp) & 0xff);
   2223                }
   2224                best_row = png_ptr->up_row;
   2225             }
   2226          
   2227             else if (filter_to_do & PNG_FILTER_UP)
   2228             {
   2229                png_bytep rp, dp, pp;
   2230                png_uint_32 sum = 0, lmins = mins;
   2231                png_uint_32 i;
   2232                int v;
   2233          
   2234          
   2235          #if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
   2236                if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
   2237                {
   2238                   int j;
   2239                   png_uint_32 lmhi, lmlo;
   2240                   lmlo = lmins & PNG_LOMASK;
   2241                   lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;
   2242          
   2243                   for (j = 0; j < num_p_filters; j++)
   2244                   {
   2245                      if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_UP)
   2246                      {
   2247                         lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
   2248                            PNG_WEIGHT_SHIFT;
   2249                         lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
   2250                            PNG_WEIGHT_SHIFT;
   2251                      }
   2252                   }
   2253          
   2254                   lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_UP]) >>
   2255                      PNG_COST_SHIFT;
   2256                   lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_UP]) >>
   2257                      PNG_COST_SHIFT;
   2258          
   2259                   if (lmhi > PNG_HIMASK)
   2260                      lmins = PNG_MAXSUM;
   2261                   else
   2262                      lmins = (lmhi << PNG_HISHIFT) + lmlo;
   2263                }
   2264          #endif
   2265          
   2266                for (i = 0, rp = row_buf + 1, dp = png_ptr->up_row + 1,
   2267                     pp = prev_row + 1; i < row_bytes; i++)
   2268                {
   2269                   v = *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);
   2270          
   2271                   sum += (v < 128) ? v : 256 - v;
   2272          
   2273                   if (sum > lmins)  /* We are already worse, don't continue. */
   2274                      break;
   2275                }
   2276          
   2277          #if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
   2278                if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
   2279                {
   2280                   int j;
   2281                   png_uint_32 sumhi, sumlo;
   2282                   sumlo = sum & PNG_LOMASK;
   2283                   sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;
   2284          
   2285                   for (j = 0; j < num_p_filters; j++)
   2286                   {
   2287                      if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_UP)
   2288                      {
   2289                         sumlo = (sumlo * png_ptr->filter_weights[j]) >>
   2290                            PNG_WEIGHT_SHIFT;
   2291                         sumhi = (sumhi * png_ptr->filter_weights[j]) >>
   2292                            PNG_WEIGHT_SHIFT;
   2293                      }
   2294                   }
   2295          
   2296                   sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_UP]) >>
   2297                      PNG_COST_SHIFT;
   2298                   sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_UP]) >>
   2299                      PNG_COST_SHIFT;
   2300          
   2301                   if (sumhi > PNG_HIMASK)
   2302                      sum = PNG_MAXSUM;
   2303                   else
   2304                      sum = (sumhi << PNG_HISHIFT) + sumlo;
   2305                }
   2306          #endif
   2307          
   2308                if (sum < mins)
   2309                {
   2310                   mins = sum;
   2311                   best_row = png_ptr->up_row;
   2312                }
   2313             }
   2314          
   2315             /* avg filter */
   2316             if (filter_to_do == PNG_FILTER_AVG)
   2317             {
   2318                png_bytep rp, dp, pp, lp;
   2319                png_uint_32 i;
   2320                for (i = 0, rp = row_buf + 1, dp = png_ptr->avg_row + 1,
   2321                     pp = prev_row + 1; i < bpp; i++)
   2322                {
   2323                   *dp++ = (png_byte)(((int)*rp++ - ((int)*pp++ / 2)) & 0xff);
   2324                }
   2325                for (lp = row_buf + 1; i < row_bytes; i++)
   2326                {
   2327                   *dp++ = (png_byte)(((int)*rp++ - (((int)*pp++ + (int)*lp++) / 2))
   2328                           & 0xff);
   2329                }
   2330                best_row = png_ptr->avg_row;
   2331             }
   2332          
   2333             else if (filter_to_do & PNG_FILTER_AVG)
   2334             {
   2335                png_bytep rp, dp, pp, lp;
   2336                png_uint_32 sum = 0, lmins = mins;
   2337                png_uint_32 i;
   2338                int v;
   2339          
   2340          #if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
   2341                if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
   2342                {
   2343                   int j;
   2344                   png_uint_32 lmhi, lmlo;
   2345                   lmlo = lmins & PNG_LOMASK;
   2346                   lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;
   2347          
   2348                   for (j = 0; j < num_p_filters; j++)
   2349                   {
   2350                      if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_AVG)
   2351                      {
   2352                         lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
   2353                            PNG_WEIGHT_SHIFT;
   2354                         lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
   2355                            PNG_WEIGHT_SHIFT;
   2356                      }
   2357                   }
   2358          
   2359                   lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_AVG]) >>
   2360                      PNG_COST_SHIFT;
   2361                   lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_AVG]) >>
   2362                      PNG_COST_SHIFT;
   2363          
   2364                   if (lmhi > PNG_HIMASK)
   2365                      lmins = PNG_MAXSUM;
   2366                   else
   2367                      lmins = (lmhi << PNG_HISHIFT) + lmlo;
   2368                }
   2369          #endif
   2370          
   2371                for (i = 0, rp = row_buf + 1, dp = png_ptr->avg_row + 1,
   2372                     pp = prev_row + 1; i < bpp; i++)
   2373                {
   2374                   v = *dp++ = (png_byte)(((int)*rp++ - ((int)*pp++ / 2)) & 0xff);
   2375          
   2376                   sum += (v < 128) ? v : 256 - v;
   2377                }
   2378                for (lp = row_buf + 1; i < row_bytes; i++)
   2379                {
   2380                   v = *dp++ =
   2381                    (png_byte)(((int)*rp++ - (((int)*pp++ + (int)*lp++) / 2)) & 0xff);
   2382          
   2383                   sum += (v < 128) ? v : 256 - v;
   2384          
   2385                   if (sum > lmins)  /* We are already worse, don't continue. */
   2386                      break;
   2387                }
   2388          
   2389          #if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
   2390                if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
   2391                {
   2392                   int j;
   2393                   png_uint_32 sumhi, sumlo;
   2394                   sumlo = sum & PNG_LOMASK;
   2395                   sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;
   2396          
   2397                   for (j = 0; j < num_p_filters; j++)
   2398                   {
   2399                      if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_NONE)
   2400                      {
   2401                         sumlo = (sumlo * png_ptr->filter_weights[j]) >>
   2402                            PNG_WEIGHT_SHIFT;
   2403                         sumhi = (sumhi * png_ptr->filter_weights[j]) >>
   2404                            PNG_WEIGHT_SHIFT;
   2405                      }
   2406                   }
   2407          
   2408                   sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_AVG]) >>
   2409                      PNG_COST_SHIFT;
   2410                   sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_AVG]) >>
   2411                      PNG_COST_SHIFT;
   2412          
   2413                   if (sumhi > PNG_HIMASK)
   2414                      sum = PNG_MAXSUM;
   2415                   else
   2416                      sum = (sumhi << PNG_HISHIFT) + sumlo;
   2417                }
   2418          #endif
   2419          
   2420                if (sum < mins)
   2421                {
   2422                   mins = sum;
   2423                   best_row = png_ptr->avg_row;
   2424                }
   2425             }
   2426          
   2427             /* Paeth filter */
   2428             if (filter_to_do == PNG_FILTER_PAETH)
   2429             {
   2430                png_bytep rp, dp, pp, cp, lp;
   2431                png_uint_32 i;
   2432                for (i = 0, rp = row_buf + 1, dp = png_ptr->paeth_row + 1,
   2433                     pp = prev_row + 1; i < bpp; i++)
   2434                {
   2435                   *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);
   2436                }
   2437          
   2438                for (lp = row_buf + 1, cp = prev_row + 1; i < row_bytes; i++)
   2439                {
   2440                   int a, b, c, pa, pb, pc, p;
   2441          
   2442                   b = *pp++;
   2443                   c = *cp++;
   2444                   a = *lp++;
   2445          
   2446                   p = b - c;
   2447                   pc = a - c;
   2448          
   2449          #ifdef PNG_USE_ABS
   2450                   pa = abs(p);
   2451                   pb = abs(pc);
   2452                   pc = abs(p + pc);
   2453          #else
   2454                   pa = p < 0 ? -p : p;
   2455                   pb = pc < 0 ? -pc : pc;
   2456                   pc = (p + pc) < 0 ? -(p + pc) : p + pc;
   2457          #endif
   2458          
   2459                   p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;
   2460          
   2461                   *dp++ = (png_byte)(((int)*rp++ - p) & 0xff);
   2462                }
   2463                best_row = png_ptr->paeth_row;
   2464             }
   2465          
   2466             else if (filter_to_do & PNG_FILTER_PAETH)
   2467             {
   2468                png_bytep rp, dp, pp, cp, lp;
   2469                png_uint_32 sum = 0, lmins = mins;
   2470                png_uint_32 i;
   2471                int v;
   2472          
   2473          #if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
   2474                if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
   2475                {
   2476                   int j;
   2477                   png_uint_32 lmhi, lmlo;
   2478                   lmlo = lmins & PNG_LOMASK;
   2479                   lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;
   2480          
   2481                   for (j = 0; j < num_p_filters; j++)
   2482                   {
   2483                      if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_PAETH)
   2484                      {
   2485                         lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
   2486                            PNG_WEIGHT_SHIFT;
   2487                         lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
   2488                            PNG_WEIGHT_SHIFT;
   2489                      }
   2490                   }
   2491          
   2492                   lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_PAETH]) >>
   2493                      PNG_COST_SHIFT;
   2494                   lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_PAETH]) >>
   2495                      PNG_COST_SHIFT;
   2496          
   2497                   if (lmhi > PNG_HIMASK)
   2498                      lmins = PNG_MAXSUM;
   2499                   else
   2500                      lmins = (lmhi << PNG_HISHIFT) + lmlo;
   2501                }
   2502          #endif
   2503          
   2504                for (i = 0, rp = row_buf + 1, dp = png_ptr->paeth_row + 1,
   2505                     pp = prev_row + 1; i < bpp; i++)
   2506                {
   2507                   v = *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);
   2508          
   2509                   sum += (v < 128) ? v : 256 - v;
   2510                }
   2511          
   2512                for (lp = row_buf + 1, cp = prev_row + 1; i < row_bytes; i++)
   2513                {
   2514                   int a, b, c, pa, pb, pc, p;
   2515          
   2516                   b = *pp++;
   2517                   c = *cp++;
   2518                   a = *lp++;
   2519          
   2520          #ifndef PNG_SLOW_PAETH
   2521                   p = b - c;
   2522                   pc = a - c;
   2523          #ifdef PNG_USE_ABS
   2524                   pa = abs(p);
   2525                   pb = abs(pc);
   2526                   pc = abs(p + pc);
   2527          #else
   2528                   pa = p < 0 ? -p : p;
   2529                   pb = pc < 0 ? -pc : pc;
   2530                   pc = (p + pc) < 0 ? -(p + pc) : p + pc;
   2531          #endif
   2532                   p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;
   2533          #else /* PNG_SLOW_PAETH */
   2534                   p = a + b - c;
   2535                   pa = abs(p - a);
   2536                   pb = abs(p - b);
   2537                   pc = abs(p - c);
   2538                   if (pa <= pb && pa <= pc)
   2539                      p = a;
   2540                   else if (pb <= pc)
   2541                      p = b;
   2542                   else
   2543                      p = c;
   2544          #endif /* PNG_SLOW_PAETH */
   2545          
   2546                   v = *dp++ = (png_byte)(((int)*rp++ - p) & 0xff);
   2547          
   2548                   sum += (v < 128) ? v : 256 - v;
   2549          
   2550                   if (sum > lmins)  /* We are already worse, don't continue. */
   2551                      break;
   2552                }
   2553          
   2554          #if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
   2555                if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
   2556                {
   2557                   int j;
   2558                   png_uint_32 sumhi, sumlo;
   2559                   sumlo = sum & PNG_LOMASK;
   2560                   sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;
   2561          
   2562                   for (j = 0; j < num_p_filters; j++)
   2563                   {
   2564                      if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_PAETH)
   2565                      {
   2566                         sumlo = (sumlo * png_ptr->filter_weights[j]) >>
   2567                            PNG_WEIGHT_SHIFT;
   2568                         sumhi = (sumhi * png_ptr->filter_weights[j]) >>
   2569                            PNG_WEIGHT_SHIFT;
   2570                      }
   2571                   }
   2572          
   2573                   sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_PAETH]) >>
   2574                      PNG_COST_SHIFT;
   2575                   sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_PAETH]) >>
   2576                      PNG_COST_SHIFT;
   2577          
   2578                   if (sumhi > PNG_HIMASK)
   2579                      sum = PNG_MAXSUM;
   2580                   else
   2581                      sum = (sumhi << PNG_HISHIFT) + sumlo;
   2582                }
   2583          #endif
   2584          
   2585                if (sum < mins)
   2586                {
   2587                   best_row = png_ptr->paeth_row;
   2588                }
   2589             }
   2590          
   2591             /* Do the actual writing of the filtered row data from the chosen filter. */
   2592          
   2593             png_write_filtered_row(png_ptr, best_row);
   2594          
   2595          #if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
   2596             /* Save the type of filter we picked this time for future calculations */
   2597             if (png_ptr->num_prev_filters > 0)
   2598             {
   2599                int j;
   2600                for (j = 1; j < num_p_filters; j++)
   2601                {
   2602                   png_ptr->prev_filters[j] = png_ptr->prev_filters[j - 1];
   2603                }
   2604                png_ptr->prev_filters[j] = best_row[0];
   2605             }
   2606          #endif
   2607          }
   2608          
   2609          
   2610          /* Do the actual writing of a previously filtered row. */
   2611          void /* PRIVATE */
   2612          png_write_filtered_row(png_structp png_ptr, png_bytep filtered_row)
   2613          {
   2614             png_debug(1, "in png_write_filtered_row\n");
   2615             png_debug1(2, "filter = %d\n", filtered_row[0]);
   2616             /* set up the zlib input buffer */
   2617          
   2618             png_ptr->zstream.next_in = filtered_row;
   2619             png_ptr->zstream.avail_in = (uInt)png_ptr->row_info.rowbytes + 1;
   2620             /* repeat until we have compressed all the data */
   2621             do
   2622             {
   2623                int ret; /* return of zlib */
   2624          
   2625                /* compress the data */
   2626                ret = deflate(&png_ptr->zstream, Z_NO_FLUSH);
   2627                /* check for compression errors */
   2628                if (ret != Z_OK)
   2629                {
   2630                   if (png_ptr->zstream.msg != NULL)
   2631                      png_error(png_ptr, png_ptr->zstream.msg);
   2632                   else
   2633                      png_error(png_ptr, "zlib error");
   2634                }
   2635          
   2636                /* see if it is time to write another IDAT */
   2637                if (!(png_ptr->zstream.avail_out))
   2638                {
   2639                   /* write the IDAT and reset the zlib output buffer */
   2640                   png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);
   2641                   png_ptr->zstream.next_out = png_ptr->zbuf;
   2642                   png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
   2643                }
   2644             /* repeat until all data has been compressed */
   2645             } while (png_ptr->zstream.avail_in);
   2646          
   2647             /* swap the current and previous rows */
   2648             if (png_ptr->prev_row != NULL)
   2649             {
   2650                png_bytep tptr;
   2651          
   2652                tptr = png_ptr->prev_row;
   2653                png_ptr->prev_row = png_ptr->row_buf;
   2654                png_ptr->row_buf = tptr;
   2655             }
   2656          
   2657             /* finish row - updates counters and flushes zlib if last row */
   2658             png_write_finish_row(png_ptr);
   2659          
   2660          #if defined(PNG_WRITE_FLUSH_SUPPORTED)
   2661             png_ptr->flush_rows++;
   2662          
   2663             if (png_ptr->flush_dist > 0 &&
   2664                 png_ptr->flush_rows >= png_ptr->flush_dist)
   2665             {
   2666                png_write_flush(png_ptr);
   2667             }
   2668          #endif
   2669          }
   2670          #endif /* PNG_WRITE_SUPPORTED */

Errors: 69
Warnings: none
