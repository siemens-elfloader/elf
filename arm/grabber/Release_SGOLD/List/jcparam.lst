##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    19/Jan/2011  13:20:55 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\grabber\jpeg-7\jcparam.c                      #
#    Command line    =  C:\arm\grabber\jpeg-7\jcparam.c -lC                  #
#                       C:\arm\grabber\Release_SGOLD\List\ -o                #
#                       C:\arm\grabber\Release_SGOLD\Obj\ -s9 --no_unroll    #
#                       --no_clustering --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --fpu None --dlib_config "C:\arm2\Embedded           #
#                       Workbench 4.0 Evaluation\ARM\LIB\dl5tpainl8n.h" -I   #
#                       "C:\arm2\Embedded Workbench 4.0                      #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  C:\arm\grabber\Release_SGOLD\List\jcparam.lst        #
#    Object file     =  C:\arm\grabber\Release_SGOLD\Obj\jcparam.r79         #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\grabber\jpeg-7\jcparam.c
      1          /*
                  ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           * jcparam.c
      3           *
      4           * Copyright (C) 1991-1998, Thomas G. Lane.
      5           * Modified 2003-2008 by Guido Vollbeding.
      6           * This file is part of the Independent JPEG Group's software.
      7           * For conditions of distribution and use, see the accompanying README file.
      8           *
      9           * This file contains optional default-setting code for the JPEG compressor.
     10           * Applications do not have to use this file, but those that don't use it
     11           * must know a lot more about the innards of the JPEG code.
     12           */
     13          
     14          #define JPEG_INTERNALS
     15          #include "jinclude.h"
     16          #include "jpeglib.h"
     17          
     18          
     19          /*
     20           * Quantization table setup routines
     21           */
     22          

   \                                 In segment CODE, align 4, keep-with-next
     23          GLOBAL(void)
     24          jpeg_add_quant_table (j_compress_ptr cinfo, int which_tbl,
     25          		      const unsigned int *basic_table,
     26          		      int scale_factor, boolean force_baseline)
     27          /* Define a quantization table equal to the basic_table times
     28           * a scale factor (given as a percentage).
     29           * If force_baseline is TRUE, the computed quantization table entries
     30           * are limited to 1..255 for JPEG baseline compatibility.
     31           */
     32          {
   \                     jpeg_add_quant_table:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   18609DE5           LDR      R6,[SP, #+24]
   \   00000008   0070A0E1           MOV      R7,R0
     33            JQUANT_TBL ** qtblptr;
     34            int i;
     35            long temp;
     36          
     37            /* Safety check to ensure start_compress not called yet. */
     38            if (cinfo->global_state != CSTATE_START)
   \   0000000C   140097E5           LDR      R0,[R7, #+20]
   \   00000010   0180A0E1           MOV      R8,R1
   \   00000014   0240A0E1           MOV      R4,R2
   \   00000018   0350A0E1           MOV      R5,R3
   \   0000001C   640050E3           CMP      R0,#+100
   \   00000020   0900000A           BEQ      ??jpeg_add_quant_table_0
     39              ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
   \   00000024   000097E5           LDR      R0,[R7, #+0]
   \   00000028   1510A0E3           MOV      R1,#+21
   \   0000002C   141080E5           STR      R1,[R0, #+20]
   \   00000030   000097E5           LDR      R0,[R7, #+0]
   \   00000034   141097E5           LDR      R1,[R7, #+20]
   \   00000038   181080E5           STR      R1,[R0, #+24]
   \   0000003C   001097E5           LDR      R1,[R7, #+0]
   \   00000040   0700A0E1           MOV      R0,R7
   \   00000044   001091E5           LDR      R1,[R1, #+0]
   \   00000048   31FF2FE1           BLX      R1
     40          
     41            if (which_tbl < 0 || which_tbl >= NUM_QUANT_TBLS)
   \                     ??jpeg_add_quant_table_0:
   \   0000004C   000058E3           CMP      R8,#+0
   \   00000050   0100004A           BMI      ??jpeg_add_quant_table_1
   \   00000054   040058E3           CMP      R8,#+4
   \   00000058   080000BA           BLT      ??jpeg_add_quant_table_2
     42              ERREXIT1(cinfo, JERR_DQT_INDEX, which_tbl);
   \                     ??jpeg_add_quant_table_1:
   \   0000005C   000097E5           LDR      R0,[R7, #+0]
   \   00000060   2010A0E3           MOV      R1,#+32
   \   00000064   141080E5           STR      R1,[R0, #+20]
   \   00000068   000097E5           LDR      R0,[R7, #+0]
   \   0000006C   188080E5           STR      R8,[R0, #+24]
   \   00000070   001097E5           LDR      R1,[R7, #+0]
   \   00000074   0700A0E1           MOV      R0,R7
   \   00000078   001091E5           LDR      R1,[R1, #+0]
   \   0000007C   31FF2FE1           BLX      R1
     43          
     44            qtblptr = & cinfo->quant_tbl_ptrs[which_tbl];
   \                     ??jpeg_add_quant_table_2:
   \   00000080   080187E0           ADD      R0,R7,R8, LSL #+2
   \   00000084   548080E2           ADD      R8,R0,#+84
     45          
     46            if (*qtblptr == NULL)
   \   00000088   000098E5           LDR      R0,[R8, #+0]
   \   0000008C   000050E3           CMP      R0,#+0
   \   00000090   0200001A           BNE      ??jpeg_add_quant_table_3
     47              *qtblptr = jpeg_alloc_quant_table((j_common_ptr) cinfo);
   \   00000094   0700A0E1           MOV      R0,R7
   \   00000098   ........           _BLF     jpeg_alloc_quant_table,??jpeg_alloc_quant_table??rA
   \   0000009C   000088E5           STR      R0,[R8, #+0]
     48          
     49            for (i = 0; i < DCTSIZE2; i++) {
   \                     ??jpeg_add_quant_table_3:
   \   000000A0   0000A0E3           MOV      R0,#+0
     50              temp = ((long) basic_table[i] * scale_factor + 50L) / 100L;
   \                     ??jpeg_add_quant_table_4:
   \   000000A4   001194E7           LDR      R1,[R4, +R0, LSL #+2]
   \   000000A8   60209FE5           LDR      R2,??jpeg_add_quant_table_5  ;; 0x51eb851f
   \   000000AC   950101E0           MUL      R1,R5,R1
   \   000000B0   321081E2           ADD      R1,R1,#+50
   \   000000B4   9231C7E0           SMULL    R3,R7,R2,R1
   \   000000B8   C772A0E1           ASR      R7,R7,#+5
   \   000000BC   A11F87E0           ADD      R1,R7,R1, LSR #+31
     51              /* limit the values to the valid range */
     52              if (temp <= 0L) temp = 1L;
   \   000000C0   010051E3           CMP      R1,#+1
   \   000000C4   0110A0B3           MOVLT    R1,#+1
   \   000000C8   020000BA           BLT      ??jpeg_add_quant_table_6
     53              if (temp > 32767L) temp = 32767L; /* max quantizer needed for 12 bits */
   \   000000CC   800C51E3           CMP      R1,#+32768
   \   000000D0   FF10A0A3           MOVGE    R1,#+255
   \   000000D4   7F1C81A3           ORRGE    R1,R1,#0x7F00
     54              if (force_baseline && temp > 255L)
   \                     ??jpeg_add_quant_table_6:
   \   000000D8   000056E3           CMP      R6,#+0
   \   000000DC   0100000A           BEQ      ??jpeg_add_quant_table_7
   \   000000E0   400F51E3           CMP      R1,#+256
     55                temp = 255L;		/* limit to baseline range if requested */
   \   000000E4   FF10A0A3           MOVGE    R1,#+255
     56              (*qtblptr)->quantval[i] = (UINT16) temp;
   \                     ??jpeg_add_quant_table_7:
   \   000000E8   002098E5           LDR      R2,[R8, #+0]
   \   000000EC   802082E0           ADD      R2,R2,R0, LSL #+1
   \   000000F0   B010C2E1           STRH     R1,[R2, #+0]
     57            }
   \   000000F4   010080E2           ADD      R0,R0,#+1
   \   000000F8   400050E3           CMP      R0,#+64
   \   000000FC   E8FFFFBA           BLT      ??jpeg_add_quant_table_4
     58          
     59            /* Initialize sent_table FALSE so table will be written to JPEG file. */
     60            (*qtblptr)->sent_table = FALSE;
   \   00000100   000098E5           LDR      R0,[R8, #+0]
   \   00000104   0010A0E3           MOV      R1,#+0
   \   00000108   801080E5           STR      R1,[R0, #+128]
     61          }
   \   0000010C   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??jpeg_add_quant_table_5:
   \   00000110   1F85EB51           DC32     0x51eb851f
     62          
     63          
     64          /* These are the sample quantization tables given in JPEG spec section K.1.
     65           * The spec says that the values given produce "good" quality, and
     66           * when divided by 2, "very good" quality.
     67           */

   \                                 In segment DATA_C, align 4, align-sorted
     68          static const unsigned int std_luminance_quant_tbl[DCTSIZE2] = {
   \                     std_luminance_quant_tbl:
   \   00000000   100000000B00       DC32 16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14
   \              00000A000000
   \              100000001800
   \              000028000000
   \              330000003D00
   \              00000C000000
   \              0C0000000E00
   \              000013000000
   \              1A0000003A00
   \              00003C000000
   \              370000000E00
   \              0000        
   \   00000044   0D0000001000       DC32 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22
   \              000018000000
   \              280000003900
   \              000045000000
   \              380000000E00
   \              000011000000
   \              160000001D00
   \              000033000000
   \              570000005000
   \              00003E000000
   \              120000001600
   \              0000        
   \   00000088   250000003800       DC32 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64
   \              000044000000
   \              6D0000006700
   \              00004D000000
   \              180000002300
   \              000037000000
   \              400000005100
   \              000068000000
   \              710000005C00
   \              000031000000
   \              40000000    
   \   000000C8   4E0000005700       DC32 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99
   \              000067000000
   \              790000007800
   \              000065000000
   \              480000005C00
   \              00005F000000
   \              620000007000
   \              000064000000
   \              670000006300
   \              0000        
     69            16,  11,  10,  16,  24,  40,  51,  61,
     70            12,  12,  14,  19,  26,  58,  60,  55,
     71            14,  13,  16,  24,  40,  57,  69,  56,
     72            14,  17,  22,  29,  51,  87,  80,  62,
     73            18,  22,  37,  56,  68, 109, 103,  77,
     74            24,  35,  55,  64,  81, 104, 113,  92,
     75            49,  64,  78,  87, 103, 121, 120, 101,
     76            72,  92,  95,  98, 112, 100, 103,  99
     77          };

   \                                 In segment DATA_C, align 4, align-sorted
     78          static const unsigned int std_chrominance_quant_tbl[DCTSIZE2] = {
   \                     std_chrominance_quant_tbl:
   \   00000000   110000001200       DC32 17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24
   \              000018000000
   \              2F0000006300
   \              000063000000
   \              630000006300
   \              000012000000
   \              150000001A00
   \              000042000000
   \              630000006300
   \              000063000000
   \              630000001800
   \              0000        
   \   00000044   1A0000003800       DC32 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99
   \              000063000000
   \              630000006300
   \              000063000000
   \              630000002F00
   \              000042000000
   \              630000006300
   \              000063000000
   \              630000006300
   \              000063000000
   \              630000006300
   \              0000        
   \   00000088   630000006300       DC32 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99
   \              000063000000
   \              630000006300
   \              000063000000
   \              630000006300
   \              000063000000
   \              630000006300
   \              000063000000
   \              630000006300
   \              000063000000
   \              630000006300
   \              0000        
   \   000000CC   630000006300       DC32 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99
   \              000063000000
   \              630000006300
   \              000063000000
   \              630000006300
   \              000063000000
   \              630000006300
   \              000063000000
   \              63000000    
     79            17,  18,  24,  47,  99,  99,  99,  99,
     80            18,  21,  26,  66,  99,  99,  99,  99,
     81            24,  26,  56,  99,  99,  99,  99,  99,
     82            47,  66,  99,  99,  99,  99,  99,  99,
     83            99,  99,  99,  99,  99,  99,  99,  99,
     84            99,  99,  99,  99,  99,  99,  99,  99,
     85            99,  99,  99,  99,  99,  99,  99,  99,
     86            99,  99,  99,  99,  99,  99,  99,  99
     87          };
     88          
     89          

   \                                 In segment CODE, align 4, keep-with-next
     90          GLOBAL(void)
     91          jpeg_default_qtables (j_compress_ptr cinfo, boolean force_baseline)
     92          /* Set or change the 'quality' (quantization) setting, using default tables
     93           * and straight percentage-scaling quality scales.
     94           * This entry point allows different scalings for luminance and chrominance.
     95           */
     96          {
     97            /* Set up two quantization tables using the specified scaling */
     98            jpeg_add_quant_table(cinfo, 0, std_luminance_quant_tbl,
     99          		       cinfo->q_scale_factor[0], force_baseline);
   \                     jpeg_default_qtables:
   \   00000000   ........           LDR      R2,??DataTable2  ;; std_luminance_quant_tbl
   \   00000004   30402DE9           PUSH     {R4,R5,LR}
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0500A0E1           MOV      R0,R5
   \   00000014   01002DE9           PUSH     {R0}
   \   00000018   643094E5           LDR      R3,[R4, #+100]
   \   0000001C   0010A0E3           MOV      R1,#+0
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           BL       jpeg_add_quant_table
    100            jpeg_add_quant_table(cinfo, 1, std_chrominance_quant_tbl,
    101          		       cinfo->q_scale_factor[1], force_baseline);
   \   00000028   ........           LDR      R2,??DataTable3  ;; std_chrominance_quant_tbl
   \   0000002C   20002DE9           PUSH     {R5}
   \   00000030   683094E5           LDR      R3,[R4, #+104]
   \   00000034   0110A0E3           MOV      R1,#+1
   \   00000038   0400A0E1           MOV      R0,R4
   \   0000003C   ........           BL       jpeg_add_quant_table
    102          }
   \   00000040   3380BDE8           POP      {R0,R1,R4,R5,PC}  ;; return
    103          
    104          

   \                                 In segment CODE, align 4, keep-with-next
    105          GLOBAL(void)
    106          jpeg_set_linear_quality (j_compress_ptr cinfo, int scale_factor,
    107          			 boolean force_baseline)
    108          /* Set or change the 'quality' (quantization) setting, using default tables
    109           * and a straight percentage-scaling quality scale.  In most cases it's better
    110           * to use jpeg_set_quality (below); this entry point is provided for
    111           * applications that insist on a linear percentage scaling.
    112           */
    113          {
   \                     jpeg_set_linear_quality:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
    114            /* Set up two quantization tables using the specified scaling */
    115            jpeg_add_quant_table(cinfo, 0, std_luminance_quant_tbl,
    116          		       scale_factor, force_baseline);
   \   00000010   ........           LDR      R2,??DataTable2  ;; std_luminance_quant_tbl
   \   00000014   0600A0E1           MOV      R0,R6
   \   00000018   01002DE9           PUSH     {R0}
   \   0000001C   0530A0E1           MOV      R3,R5
   \   00000020   0010A0E3           MOV      R1,#+0
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   ........           BL       jpeg_add_quant_table
    117            jpeg_add_quant_table(cinfo, 1, std_chrominance_quant_tbl,
    118          		       scale_factor, force_baseline);
   \   0000002C   ........           LDR      R2,??DataTable3  ;; std_chrominance_quant_tbl
   \   00000030   40002DE9           PUSH     {R6}
   \   00000034   0530A0E1           MOV      R3,R5
   \   00000038   0110A0E3           MOV      R1,#+1
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   ........           BL       jpeg_add_quant_table
    119          }
   \   00000044   7380BDE8           POP      {R0,R1,R4-R6,PC}  ;; return
    120          
    121          

   \                                 In segment CODE, align 4, keep-with-next
    122          GLOBAL(int)
    123          jpeg_quality_scaling (int quality)
    124          /* Convert a user-specified quality rating to a percentage scaling factor
    125           * for an underlying quantization table, using our recommended scaling curve.
    126           * The input 'quality' factor should be 0 (terrible) to 100 (very good).
    127           */
    128          {
   \                     jpeg_quality_scaling:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   0010A0E1           MOV      R1,R0
    129            /* Safety limit on quality factor.  Convert 0 to 1 to avoid zero divide. */
    130            if (quality <= 0) quality = 1;
   \   00000008   010051E3           CMP      R1,#+1
   \   0000000C   0110A0B3           MOVLT    R1,#+1
   \   00000010   070000BA           BLT      ??jpeg_quality_scaling_0
    131            if (quality > 100) quality = 100;
   \   00000014   650051E3           CMP      R1,#+101
   \   00000018   030000BA           BLT      ??jpeg_quality_scaling_1
   \   0000001C   6410A0E3           MOV      R1,#+100
    132          
    133            /* The basic table is used as-is (scaling 100) for a quality of 50.
    134             * Qualities 50..100 are converted to scaling percentage 200 - 2*Q;
    135             * note that at Q=100 the scaling is 0, which will cause jpeg_add_quant_table
    136             * to make all the table entries 1 (hence, minimum quantization loss).
    137             * Qualities 1..50 are converted to scaling percentage 5000/Q.
    138             */
    139            if (quality < 50)
    140              quality = 5000 / quality;
    141            else
    142              quality = 200 - quality*2;
   \                     ??jpeg_quality_scaling_2:
   \   00000020   C800A0E3           MOV      R0,#+200
   \   00000024   810040E0           SUB      R0,R0,R1, LSL #+1
    143          
    144            return quality;
   \   00000028   0080BDE8           POP      {PC}             ;; return
   \                     ??jpeg_quality_scaling_1:
   \   0000002C   320051E3           CMP      R1,#+50
   \   00000030   FAFFFFAA           BGE      ??jpeg_quality_scaling_2
   \                     ??jpeg_quality_scaling_0:
   \   00000034   8800A0E3           MOV      R0,#+136
   \   00000038   4C0D80E3           ORR      R0,R0,#0x1300
   \   0000003C   ........           _BLF     ??div32_a,??rA??div32_a
   \   00000040   0100A0E1           MOV      R0,R1
   \   00000044   0080BDE8           POP      {PC}
    145          }
    146          
    147          

   \                                 In segment CODE, align 4, keep-with-next
    148          GLOBAL(void)
    149          jpeg_set_quality (j_compress_ptr cinfo, int quality, boolean force_baseline)
    150          /* Set or change the 'quality' (quantization) setting, using default tables.
    151           * This is the standard quality-adjusting entry point for typical user
    152           * interfaces; only those who want detailed control over quantization tables
    153           * would use the preceding three routines directly.
    154           */
    155          {
   \                     jpeg_set_quality:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0100A0E1           MOV      R0,R1
   \   0000000C   0250A0E1           MOV      R5,R2
    156            /* Convert user 0-100 rating to percentage scaling */
    157            quality = jpeg_quality_scaling(quality);
   \   00000010   ........           BL       jpeg_quality_scaling
    158          
    159            /* Set up standard quality tables */
    160            jpeg_set_linear_quality(cinfo, quality, force_baseline);
   \   00000014   0520A0E1           MOV      R2,R5
   \   00000018   0010A0E1           MOV      R1,R0
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   3040BDE8           POP      {R4,R5,LR}       ;; Pop
   \   00000024   ........           B        jpeg_set_linear_quality  ;; tailcall
    161          }
    162          
    163          
    164          /*
    165           * Huffman table setup routines
    166           */
    167          

   \                                 In segment CODE, align 4, keep-with-next
    168          LOCAL(void)
    169          add_huff_table (j_compress_ptr cinfo,
    170          		JHUFF_TBL **htblptr, const UINT8 *bits, const UINT8 *val)
    171          /* Define a Huffman table */
    172          {
   \                     add_huff_table:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    173            int nsymbols, len;
    174          
    175            if (*htblptr == NULL)
   \   0000000C   000095E5           LDR      R0,[R5, #+0]
   \   00000010   0280A0E1           MOV      R8,R2
   \   00000014   0360A0E1           MOV      R6,R3
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0200001A           BNE      ??add_huff_table_0
    176              *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           _BLF     jpeg_alloc_huff_table,??jpeg_alloc_huff_table??rA
   \   00000028   000085E5           STR      R0,[R5, #+0]
    177          
    178            /* Copy the number-of-symbols-of-each-code-length counts */
    179            MEMCOPY((*htblptr)->bits, bits, SIZEOF((*htblptr)->bits));
   \                     ??add_huff_table_0:
   \   0000002C   000095E5           LDR      R0,[R5, #+0]
   \   00000030   1120A0E3           MOV      R2,#+17
   \   00000034   0810A0E1           MOV      R1,R8
   \   00000038   1E0100EF           SWI      +286
    180          
    181            /* Validate the counts.  We do this here mainly so we can copy the right
    182             * number of symbols from the val[] array, without risking marching off
    183             * the end of memory.  jchuff.c will do a more thorough test later.
    184             */
    185            nsymbols = 0;
   \   0000003C   0070A0E3           MOV      R7,#+0
    186            for (len = 1; len <= 16; len++)
   \   00000040   0100A0E3           MOV      R0,#+1
    187              nsymbols += bits[len];
   \                     ??add_huff_table_1:
   \   00000044   0810D0E7           LDRB     R1,[R0, +R8]
   \   00000048   010080E2           ADD      R0,R0,#+1
   \   0000004C   110050E3           CMP      R0,#+17
   \   00000050   077081E0           ADD      R7,R1,R7
   \   00000054   FAFFFFBA           BLT      ??add_huff_table_1
    188            if (nsymbols < 1 || nsymbols > 256)
   \   00000058   010057E3           CMP      R7,#+1
   \   0000005C   030000BA           BLT      ??add_huff_table_2
   \   00000060   0100A0E3           MOV      R0,#+1
   \   00000064   400F80E3           ORR      R0,R0,#0x100
   \   00000068   000057E1           CMP      R7,R0
   \   0000006C   060000BA           BLT      ??add_huff_table_3
    189              ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
   \                     ??add_huff_table_2:
   \   00000070   000094E5           LDR      R0,[R4, #+0]
   \   00000074   0910A0E3           MOV      R1,#+9
   \   00000078   141080E5           STR      R1,[R0, #+20]
   \   0000007C   001094E5           LDR      R1,[R4, #+0]
   \   00000080   0400A0E1           MOV      R0,R4
   \   00000084   001091E5           LDR      R1,[R1, #+0]
   \   00000088   31FF2FE1           BLX      R1
    190          
    191            MEMCOPY((*htblptr)->huffval, val, nsymbols * SIZEOF(UINT8));
   \                     ??add_huff_table_3:
   \   0000008C   000095E5           LDR      R0,[R5, #+0]
   \   00000090   0720A0E1           MOV      R2,R7
   \   00000094   0610A0E1           MOV      R1,R6
   \   00000098   110080E2           ADD      R0,R0,#+17
   \   0000009C   1E0100EF           SWI      +286
    192          
    193            /* Initialize sent_table FALSE so table will be written to JPEG file. */
    194            (*htblptr)->sent_table = FALSE;
   \   000000A0   000095E5           LDR      R0,[R5, #+0]
   \   000000A4   0010A0E3           MOV      R1,#+0
   \   000000A8   141180E5           STR      R1,[R0, #+276]
    195          }
   \   000000AC   F081BDE8           POP      {R4-R8,PC}       ;; return
    196          
    197          
    198          LOCAL(void)
    199          std_huff_tables (j_compress_ptr cinfo)
    200          /* Set up the standard Huffman tables (cf. JPEG standard section K.3) */
    201          /* IMPORTANT: these are only valid for 8-bit data precision! */
    202          {

   \                                 In segment DATA_C, align 4, align-sorted
    203            static const UINT8 bits_dc_luminance[17] =
   \                     ??bits_dc_luminance:
   \   00000000   000001050101       DC8 0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              010101010000
   \              000000000000
   \              0000        
    204              { /* 0-base */ 0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 };

   \                                 In segment DATA_C, align 4, align-sorted
    205            static const UINT8 val_dc_luminance[] =
   \                     ??val_dc_luminance:
   \   00000000   000102030405       DC8 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
   \              060708090A0B
    206              { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
    207            

   \                                 In segment DATA_C, align 4, align-sorted
    208            static const UINT8 bits_dc_chrominance[17] =
   \                     ??bits_dc_chrominance:
   \   00000000   000003010101       DC8 0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0
   \              010101010101
   \              000000000000
   \              0000        
    209              { /* 0-base */ 0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 };

   \                                 In segment DATA_C, align 4, align-sorted
    210            static const UINT8 val_dc_chrominance[] =
   \                     ??val_dc_chrominance:
   \   00000000   000102030405       DC8 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
   \              060708090A0B
    211              { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
    212            

   \                                 In segment DATA_C, align 4, align-sorted
    213            static const UINT8 bits_ac_luminance[17] =
   \                     ??bits_ac_luminance:
   \   00000000   000002010303       DC8 0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125, 0, 0, 0
   \              020403050504
   \              040000017D00
   \              0000        
    214              { /* 0-base */ 0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d };

   \                                 In segment DATA_C, align 4, align-sorted
    215            static const UINT8 val_ac_luminance[] =
   \                     ??val_ac_luminance:
   \   00000000   010203000411       DC8 1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20
   \              051221314106
   \              135161072271
   \              14          
   \   00000013   328191A10823       DC8 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51
   \              42B1C11552D1
   \              F02433      
   \   00000022   627282090A16       DC8 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52
   \              1718191A2526
   \              2728292A34  
   \   00000033   35363738393A       DC8 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85
   \              434445464748
   \              494A535455  
   \   00000044   565758595A63       DC8 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116
   \              646566676869
   \              6A7374      
   \   00000053   75767778797A       DC8 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137
   \              838485868788
   \              89          
   \   00000060   8A9293949596       DC8 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164
   \              9798999AA2A3
   \              A4          
   \   0000006D   A5A6A7A8A9AA       DC8 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184
   \              B2B3B4B5B6B7
   \              B8          
   \   0000007A   B9BAC2C3C4C5       DC8 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211
   \              C6C7C8C9CAD2
   \              D3          
   \   00000087   D4D5D6D7D8D9       DC8 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230
   \              DAE1E2E3E4E5
   \              E6          
   \   00000094   E7E8E9EAF1F2       DC8 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249
   \              F3F4F5F6F7F8
   \              F9          
   \   000000A1   FA0000             DC8 250, 0, 0
    216              { 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,
    217                0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,
    218                0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08,
    219                0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0,
    220                0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16,
    221                0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28,
    222                0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
    223                0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
    224                0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
    225                0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
    226                0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
    227                0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
    228                0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,
    229                0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
    230                0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6,
    231                0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5,
    232                0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4,
    233                0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2,
    234                0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea,
    235                0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
    236                0xf9, 0xfa };
    237            

   \                                 In segment DATA_C, align 4, align-sorted
    238            static const UINT8 bits_ac_chrominance[17] =
   \                     ??bits_ac_chrominance:
   \   00000000   000002010204       DC8 0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119, 0, 0, 0
   \              040304070504
   \              040001027700
   \              0000        
    239              { /* 0-base */ 0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77 };

   \                                 In segment DATA_C, align 4, align-sorted
    240            static const UINT8 val_ac_chrominance[] =
   \                     ??val_ac_chrominance:
   \   00000000   000102031104       DC8 0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50
   \              052131061241
   \              510761711322
   \              32          
   \   00000013   8108144291A1       DC8 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114
   \              B1C109233352
   \              F0156272    
   \   00000023   D10A162434E1       DC8 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41
   \              25F11718191A
   \              26272829    
   \   00000033   2A3536373839       DC8 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84
   \              3A4344454647
   \              48494A5354  
   \   00000044   55565758595A       DC8 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115
   \              636465666768
   \              696A73      
   \   00000053   747576777879       DC8 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135
   \              7A8283848586
   \              87          
   \   00000060   88898A929394       DC8 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162
   \              95969798999A
   \              A2          
   \   0000006D   A3A4A5A6A7A8       DC8 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182
   \              A9AAB2B3B4B5
   \              B6          
   \   0000007A   B7B8B9BAC2C3       DC8 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202
   \              C4C5C6C7C8C9
   \              CA          
   \   00000087   D2D3D4D5D6D7       DC8 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229
   \              D8D9DAE2E3E4
   \              E5          
   \   00000094   E6E7E8E9EAF2       DC8 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249
   \              F3F4F5F6F7F8
   \              F9          
   \   000000A1   FA0000             DC8 250, 0, 0
    241              { 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21,
    242                0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,
    243                0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91,
    244                0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0,
    245                0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34,
    246                0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26,
    247                0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38,
    248                0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
    249                0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
    250                0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
    251                0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
    252                0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
    253                0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96,
    254                0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5,
    255                0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4,
    256                0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3,
    257                0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2,
    258                0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda,
    259                0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9,
    260                0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
    261                0xf9, 0xfa };
    262            
    263            add_huff_table(cinfo, &cinfo->dc_huff_tbl_ptrs[0],
    264          		 bits_dc_luminance, val_dc_luminance);
    265            add_huff_table(cinfo, &cinfo->ac_huff_tbl_ptrs[0],
    266          		 bits_ac_luminance, val_ac_luminance);
    267            add_huff_table(cinfo, &cinfo->dc_huff_tbl_ptrs[1],
    268          		 bits_dc_chrominance, val_dc_chrominance);
    269            add_huff_table(cinfo, &cinfo->ac_huff_tbl_ptrs[1],
    270          		 bits_ac_chrominance, val_ac_chrominance);
    271          }
    272          
    273          
    274          /*
    275           * Default parameter setup for compression.
    276           *
    277           * Applications that don't choose to use this routine must do their
    278           * own setup of all these parameters.  Alternately, you can call this
    279           * to establish defaults and then alter parameters selectively.  This
    280           * is the recommended approach since, if we add any new parameters,
    281           * your code will still work (they'll be set to reasonable defaults).
    282           */
    283          

   \                                 In segment CODE, align 4, keep-with-next
    284          GLOBAL(void)
    285          jpeg_set_defaults (j_compress_ptr cinfo)
    286          {
   \                     jpeg_set_defaults:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    287            int i;
    288          
    289            /* Safety check to ensure start_compress not called yet. */
    290            if (cinfo->global_state != CSTATE_START)
   \   00000008   140094E5           LDR      R0,[R4, #+20]
   \   0000000C   640050E3           CMP      R0,#+100
   \   00000010   0900000A           BEQ      ??jpeg_set_defaults_0
    291              ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
   \   00000014   000094E5           LDR      R0,[R4, #+0]
   \   00000018   1510A0E3           MOV      R1,#+21
   \   0000001C   141080E5           STR      R1,[R0, #+20]
   \   00000020   000094E5           LDR      R0,[R4, #+0]
   \   00000024   141094E5           LDR      R1,[R4, #+20]
   \   00000028   181080E5           STR      R1,[R0, #+24]
   \   0000002C   001094E5           LDR      R1,[R4, #+0]
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   001091E5           LDR      R1,[R1, #+0]
   \   00000038   31FF2FE1           BLX      R1
    292          
    293            /* Allocate comp_info array large enough for maximum component count.
    294             * Array is made permanent in case application wants to compress
    295             * multiple images at same param settings.
    296             */
    297            if (cinfo->comp_info == NULL)
   \                     ??jpeg_set_defaults_0:
   \   0000003C   500094E5           LDR      R0,[R4, #+80]
   \   00000040   000050E3           CMP      R0,#+0
   \   00000044   0600001A           BNE      ??jpeg_set_defaults_1
    298              cinfo->comp_info = (jpeg_component_info *)
    299                (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
    300          				  MAX_COMPONENTS * SIZEOF(jpeg_component_info));
   \   00000048   043094E5           LDR      R3,[R4, #+4]
   \   0000004C   DC2FA0E3           MOV      R2,#+880
   \   00000050   003093E5           LDR      R3,[R3, #+0]
   \   00000054   0010A0E3           MOV      R1,#+0
   \   00000058   0400A0E1           MOV      R0,R4
   \   0000005C   33FF2FE1           BLX      R3
   \   00000060   500084E5           STR      R0,[R4, #+80]
    301          
    302            /* Initialize everything not dependent on the color space */
    303          
    304            cinfo->scale_num = 1;		/* 1:1 scaling */
   \                     ??jpeg_set_defaults_1:
   \   00000064   0150A0E3           MOV      R5,#+1
   \   00000068   345084E5           STR      R5,[R4, #+52]
    305            cinfo->scale_denom = 1;
   \   0000006C   385084E5           STR      R5,[R4, #+56]
    306            cinfo->data_precision = BITS_IN_JSAMPLE;
   \   00000070   0800A0E3           MOV      R0,#+8
   \   00000074   440084E5           STR      R0,[R4, #+68]
    307            /* Set up two quantization tables using default quality of 75 */
    308            jpeg_set_quality(cinfo, 75, TRUE);
   \   00000078   4B00A0E3           MOV      R0,#+75
   \   0000007C   ........           BL       jpeg_quality_scaling
   \   00000080   0120A0E3           MOV      R2,#+1
   \   00000084   0010A0E1           MOV      R1,R0
   \   00000088   0400A0E1           MOV      R0,R4
   \   0000008C   ........           BL       jpeg_set_linear_quality
    309            /* Set up two Huffman tables */
    310            std_huff_tables(cinfo);
   \   00000090   C8309FE5           LDR      R3,??jpeg_set_defaults_2  ;; ??val_dc_luminance
   \   00000094   C8209FE5           LDR      R2,??jpeg_set_defaults_2+0x4  ;; ??bits_dc_luminance
   \   00000098   741084E2           ADD      R1,R4,#+116
   \   0000009C   0400A0E1           MOV      R0,R4
   \   000000A0   ........           BL       add_huff_table
   \   000000A4   BC309FE5           LDR      R3,??jpeg_set_defaults_2+0x8  ;; ??val_ac_luminance
   \   000000A8   BC209FE5           LDR      R2,??jpeg_set_defaults_2+0xC  ;; ??bits_ac_luminance
   \   000000AC   841084E2           ADD      R1,R4,#+132
   \   000000B0   0400A0E1           MOV      R0,R4
   \   000000B4   ........           BL       add_huff_table
   \   000000B8   B0309FE5           LDR      R3,??jpeg_set_defaults_2+0x10  ;; ??val_dc_chrominance
   \   000000BC   B0209FE5           LDR      R2,??jpeg_set_defaults_2+0x14  ;; ??bits_dc_chrominance
   \   000000C0   781084E2           ADD      R1,R4,#+120
   \   000000C4   0400A0E1           MOV      R0,R4
   \   000000C8   ........           BL       add_huff_table
   \   000000CC   A4309FE5           LDR      R3,??jpeg_set_defaults_2+0x18  ;; ??val_ac_chrominance
   \   000000D0   A4209FE5           LDR      R2,??jpeg_set_defaults_2+0x1C  ;; ??bits_ac_chrominance
   \   000000D4   881084E2           ADD      R1,R4,#+136
   \   000000D8   0400A0E1           MOV      R0,R4
   \   000000DC   ........           BL       add_huff_table
    311          
    312            /* Initialize default arithmetic coding conditioning */
    313            for (i = 0; i < NUM_ARITH_TBLS; i++) {
   \   000000E0   0000A0E3           MOV      R0,#+0
   \   000000E4   0010A0E1           MOV      R1,R0
   \   000000E8   0530A0E3           MOV      R3,#+5
    314              cinfo->arith_dc_L[i] = 0;
   \                     ??jpeg_set_defaults_3:
   \   000000EC   042080E0           ADD      R2,R0,R4
   \   000000F0   9410C2E5           STRB     R1,[R2, #+148]
    315              cinfo->arith_dc_U[i] = 1;
   \   000000F4   A450C2E5           STRB     R5,[R2, #+164]
    316              cinfo->arith_ac_K[i] = 5;
   \   000000F8   B430C2E5           STRB     R3,[R2, #+180]
    317            }
   \   000000FC   010080E2           ADD      R0,R0,#+1
   \   00000100   100050E3           CMP      R0,#+16
   \   00000104   F8FFFFBA           BLT      ??jpeg_set_defaults_3
    318          
    319            /* Default is no multiple-scan output */
    320            cinfo->scan_info = NULL;
   \   00000108   C81084E5           STR      R1,[R4, #+200]
    321            cinfo->num_scans = 0;
   \   0000010C   C41084E5           STR      R1,[R4, #+196]
    322          
    323            /* Expect normal source image, not raw downsampled data */
    324            cinfo->raw_data_in = FALSE;
   \   00000110   CC1084E5           STR      R1,[R4, #+204]
    325          
    326            /* Use Huffman coding, not arithmetic coding, by default */
    327            cinfo->arith_code = FALSE;
   \   00000114   D01084E5           STR      R1,[R4, #+208]
    328          
    329            /* By default, don't do extra passes to optimize entropy coding */
    330            cinfo->optimize_coding = FALSE;
   \   00000118   D41084E5           STR      R1,[R4, #+212]
    331            /* The standard Huffman tables are only valid for 8-bit data precision.
    332             * If the precision is higher, force optimization on so that usable
    333             * tables will be computed.  This test can be removed if default tables
    334             * are supplied that are valid for the desired precision.
    335             */
    336            if (cinfo->data_precision > 8)
   \   0000011C   440094E5           LDR      R0,[R4, #+68]
   \   00000120   090050E3           CMP      R0,#+9
    337              cinfo->optimize_coding = TRUE;
   \   00000124   D45084A5           STRGE    R5,[R4, #+212]
    338          
    339            /* By default, use the simpler non-cosited sampling alignment */
    340            cinfo->CCIR601_sampling = FALSE;
   \   00000128   D81084E5           STR      R1,[R4, #+216]
    341          
    342            /* By default, apply fancy downsampling */
    343            cinfo->do_fancy_downsampling = TRUE;
   \   0000012C   DC5084E5           STR      R5,[R4, #+220]
    344          
    345            /* No input smoothing */
    346            cinfo->smoothing_factor = 0;
   \   00000130   E01084E5           STR      R1,[R4, #+224]
    347          
    348            /* DCT algorithm preference */
    349            cinfo->dct_method = JDCT_DEFAULT;
   \   00000134   E410C4E5           STRB     R1,[R4, #+228]
    350          
    351            /* No restart markers */
    352            cinfo->restart_interval = 0;
   \   00000138   E81084E5           STR      R1,[R4, #+232]
    353            cinfo->restart_in_rows = 0;
   \   0000013C   EC1084E5           STR      R1,[R4, #+236]
    354          
    355            /* Fill in default JFIF marker parameters.  Note that whether the marker
    356             * will actually be written is determined by jpeg_set_colorspace.
    357             *
    358             * By default, the library emits JFIF version code 1.01.
    359             * An application that wants to emit JFIF 1.02 extension markers should set
    360             * JFIF_minor_version to 2.  We could probably get away with just defaulting
    361             * to 1.02, but there may still be some decoders in use that will complain
    362             * about that; saying 1.01 should minimize compatibility problems.
    363             */
    364            cinfo->JFIF_major_version = 1; /* Default JFIF version = 1.01 */
   \   00000140   F450C4E5           STRB     R5,[R4, #+244]
    365            cinfo->JFIF_minor_version = 1;
   \   00000144   F550C4E5           STRB     R5,[R4, #+245]
    366            cinfo->density_unit = 0;	/* Pixel size is unknown by default */
   \   00000148   F610C4E5           STRB     R1,[R4, #+246]
    367            cinfo->X_density = 1;		/* Pixel aspect ratio is square by default */
   \   0000014C   B85FC4E1           STRH     R5,[R4, #+248]
    368            cinfo->Y_density = 1;
   \   00000150   BA5FC4E1           STRH     R5,[R4, #+250]
    369          
    370            /* Choose JPEG colorspace based on input space, set defaults accordingly */
    371          
    372            jpeg_default_colorspace(cinfo);
   \   00000154   0400A0E1           MOV      R0,R4
   \   00000158   ........           BL       jpeg_default_colorspace
    373          }
   \   0000015C   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??jpeg_set_defaults_2:
   \   00000160   ........           DC32     ??val_dc_luminance
   \   00000164   ........           DC32     ??bits_dc_luminance
   \   00000168   ........           DC32     ??val_ac_luminance
   \   0000016C   ........           DC32     ??bits_ac_luminance
   \   00000170   ........           DC32     ??val_dc_chrominance
   \   00000174   ........           DC32     ??bits_dc_chrominance
   \   00000178   ........           DC32     ??val_ac_chrominance
   \   0000017C   ........           DC32     ??bits_ac_chrominance
    374          
    375          
    376          /*
    377           * Select an appropriate JPEG colorspace for in_color_space.
    378           */
    379          

   \                                 In segment CODE, align 4, keep-with-next
    380          GLOBAL(void)
    381          jpeg_default_colorspace (j_compress_ptr cinfo)
    382          {
   \                     jpeg_default_colorspace:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   0020A0E1           MOV      R2,R0
    383            switch (cinfo->in_color_space) {
   \   00000008   2800D2E5           LDRB     R0,[R2, #+40]
   \   0000000C   050050E3           CMP      R0,#+5
   \   00000010   1200008A           BHI      ??jpeg_default_colorspace_1
   \   00000014   011F8FE2           ADR      R1,??jpeg_default_colorspace_0
   \   00000018   0010D1E7           LDRB     R1,[R1, R0]
   \   0000001C   01F18FE0           ADD      PC,PC,R1, LSL #+2
   \                     ??jpeg_default_colorspace_0:
   \   00000020   0D010303           DC8      +13,+1,+3,+3
   \   00000024   070B0000           DC8      +7,+11,+0,+0
    384            case JCS_GRAYSCALE:
    385              jpeg_set_colorspace(cinfo, JCS_GRAYSCALE);
   \                     ??jpeg_default_colorspace_2:
   \   00000028   0110A0E3           MOV      R1,#+1
   \   0000002C   040000EA           B        ??jpeg_default_colorspace_3
    386              break;
    387            case JCS_RGB:
    388              jpeg_set_colorspace(cinfo, JCS_YCbCr);
   \                     ??jpeg_default_colorspace_4:
   \   00000030   0310A0E3           MOV      R1,#+3
   \   00000034   0200A0E1           MOV      R0,R2
   \   00000038   ........           BL       jpeg_set_colorspace
   \   0000003C   0080BDE8           POP      {PC}
    389              break;
    390            case JCS_YCbCr:
    391              jpeg_set_colorspace(cinfo, JCS_YCbCr);
    392              break;
    393            case JCS_CMYK:
    394              jpeg_set_colorspace(cinfo, JCS_CMYK); /* By default, no translation */
   \                     ??jpeg_default_colorspace_5:
   \   00000040   0410A0E3           MOV      R1,#+4
   \                     ??jpeg_default_colorspace_3:
   \   00000044   0200A0E1           MOV      R0,R2
   \   00000048   ........           BL       jpeg_set_colorspace
   \   0000004C   0080BDE8           POP      {PC}
    395              break;
    396            case JCS_YCCK:
    397              jpeg_set_colorspace(cinfo, JCS_YCCK);
   \                     ??jpeg_default_colorspace_6:
   \   00000050   0510A0E3           MOV      R1,#+5
   \   00000054   FAFFFFEA           B        ??jpeg_default_colorspace_3
    398              break;
    399            case JCS_UNKNOWN:
    400              jpeg_set_colorspace(cinfo, JCS_UNKNOWN);
   \                     ??jpeg_default_colorspace_7:
   \   00000058   0010A0E3           MOV      R1,#+0
   \   0000005C   F8FFFFEA           B        ??jpeg_default_colorspace_3
    401              break;
    402            default:
    403              ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
   \                     ??jpeg_default_colorspace_1:
   \   00000060   000092E5           LDR      R0,[R2, #+0]
   \   00000064   0A10A0E3           MOV      R1,#+10
   \   00000068   141080E5           STR      R1,[R0, #+20]
   \   0000006C   001092E5           LDR      R1,[R2, #+0]
   \   00000070   0200A0E1           MOV      R0,R2
   \   00000074   001091E5           LDR      R1,[R1, #+0]
   \   00000078   31FF2FE1           BLX      R1
    404            }
    405          }
   \   0000007C   0080BDE8           POP      {PC}             ;; return
    406          
    407          
    408          /*
    409           * Set the JPEG colorspace, and choose colorspace-dependent default values.
    410           */
    411          

   \                                 In segment CODE, align 4, keep-with-next
    412          GLOBAL(void)
    413          jpeg_set_colorspace (j_compress_ptr cinfo, J_COLOR_SPACE colorspace)
    414          {
   \                     jpeg_set_colorspace:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0060A0E1           MOV      R6,R0
    415            jpeg_component_info * compptr;
    416            int ci;
    417          
    418          #define SET_COMP(index,id,hsamp,vsamp,quant,dctbl,actbl)  \
    419            (compptr = &cinfo->comp_info[index], \
    420             compptr->component_id = (id), \
    421             compptr->h_samp_factor = (hsamp), \
    422             compptr->v_samp_factor = (vsamp), \
    423             compptr->quant_tbl_no = (quant), \
    424             compptr->dc_tbl_no = (dctbl), \
    425             compptr->ac_tbl_no = (actbl) )
    426          
    427            /* Safety check to ensure start_compress not called yet. */
    428            if (cinfo->global_state != CSTATE_START)
   \   00000008   140096E5           LDR      R0,[R6, #+20]
   \   0000000C   0170A0E1           MOV      R7,R1
   \   00000010   640050E3           CMP      R0,#+100
   \   00000014   0900000A           BEQ      ??jpeg_set_colorspace_1
    429              ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
   \   00000018   000096E5           LDR      R0,[R6, #+0]
   \   0000001C   1510A0E3           MOV      R1,#+21
   \   00000020   141080E5           STR      R1,[R0, #+20]
   \   00000024   000096E5           LDR      R0,[R6, #+0]
   \   00000028   141096E5           LDR      R1,[R6, #+20]
   \   0000002C   181080E5           STR      R1,[R0, #+24]
   \   00000030   001096E5           LDR      R1,[R6, #+0]
   \   00000034   0600A0E1           MOV      R0,R6
   \   00000038   001091E5           LDR      R1,[R1, #+0]
   \   0000003C   31FF2FE1           BLX      R1
    430          
    431            /* For all colorspaces, we use Q and Huff tables 0 for luminance components,
    432             * tables 1 for chrominance components.
    433             */
    434          
    435            cinfo->jpeg_color_space = colorspace;
   \                     ??jpeg_set_colorspace_1:
   \   00000040   4C70C6E5           STRB     R7,[R6, #+76]
    436          
    437            cinfo->write_JFIF_header = FALSE; /* No marker for non-JFIF colorspaces */
   \   00000044   0040A0E3           MOV      R4,#+0
   \   00000048   F04086E5           STR      R4,[R6, #+240]
    438            cinfo->write_Adobe_marker = FALSE; /* write no Adobe marker by default */
   \   0000004C   FC4086E5           STR      R4,[R6, #+252]
    439          
    440            switch (colorspace) {
   \   00000050   420FA0E3           MOV      R0,#+264
   \   00000054   0310A0E3           MOV      R1,#+3
   \   00000058   0220A0E3           MOV      R2,#+2
   \   0000005C   0430A0E3           MOV      R3,#+4
   \   00000060   0150A0E3           MOV      R5,#+1
   \   00000064   050057E3           CMP      R7,#+5
   \   00000068   9D00008A           BHI      ??jpeg_set_colorspace_2
   \   0000006C   01CF8FE2           ADR      R12,??jpeg_set_colorspace_0
   \   00000070   07C0DCE7           LDRB     R12,[R12, R7]
   \   00000074   0CF18FE0           ADD      PC,PC,R12, LSL #+2
   \                     ??jpeg_set_colorspace_0:
   \   00000078   7501061C           DC8      +117,+1,+6,+28
   \   0000007C   34580000           DC8      +52,+88,+0,+0
    441            case JCS_GRAYSCALE:
    442              cinfo->write_JFIF_header = TRUE; /* Write a JFIF marker */
   \                     ??jpeg_set_colorspace_3:
   \   00000080   F05086E5           STR      R5,[R6, #+240]
    443              cinfo->num_components = 1;
   \   00000084   485086E5           STR      R5,[R6, #+72]
    444              /* JFIF specifies component ID 1 */
    445              SET_COMP(0, 1, 1,1, 0, 0,0);
   \   00000088   500096E5           LDR      R0,[R6, #+80]
   \   0000008C   005080E5           STR      R5,[R0, #+0]
   \   00000090   4B0000EA           B        ??jpeg_set_colorspace_4
    446              break;
    447            case JCS_RGB:
    448              cinfo->write_Adobe_marker = TRUE; /* write Adobe marker to flag RGB */
   \                     ??jpeg_set_colorspace_5:
   \   00000094   FC5086E5           STR      R5,[R6, #+252]
    449              cinfo->num_components = 3;
   \   00000098   481086E5           STR      R1,[R6, #+72]
    450              SET_COMP(0, 0x52 /* 'R' */, 1,1, 0, 0,0);
   \   0000009C   500096E5           LDR      R0,[R6, #+80]
   \   000000A0   5210A0E3           MOV      R1,#+82
   \   000000A4   001080E5           STR      R1,[R0, #+0]
   \   000000A8   085080E5           STR      R5,[R0, #+8]
   \   000000AC   0C5080E5           STR      R5,[R0, #+12]
   \   000000B0   104080E5           STR      R4,[R0, #+16]
   \   000000B4   144080E5           STR      R4,[R0, #+20]
   \   000000B8   184080E5           STR      R4,[R0, #+24]
    451              SET_COMP(1, 0x47 /* 'G' */, 1,1, 0, 0,0);
   \   000000BC   500096E5           LDR      R0,[R6, #+80]
   \   000000C0   4710A0E3           MOV      R1,#+71
   \   000000C4   5810A0E5           STR      R1,[R0, #+88]!
   \   000000C8   085080E5           STR      R5,[R0, #+8]
   \   000000CC   0C5080E5           STR      R5,[R0, #+12]
   \   000000D0   104080E5           STR      R4,[R0, #+16]
   \   000000D4   144080E5           STR      R4,[R0, #+20]
   \   000000D8   184080E5           STR      R4,[R0, #+24]
    452              SET_COMP(2, 0x42 /* 'B' */, 1,1, 0, 0,0);
   \   000000DC   500096E5           LDR      R0,[R6, #+80]
   \   000000E0   4210A0E3           MOV      R1,#+66
   \   000000E4   B00080E2           ADD      R0,R0,#+176
   \   000000E8   340000EA           B        ??jpeg_set_colorspace_6
    453              break;
    454            case JCS_YCbCr:
    455              cinfo->write_JFIF_header = TRUE; /* Write a JFIF marker */
   \                     ??jpeg_set_colorspace_7:
   \   000000EC   F05086E5           STR      R5,[R6, #+240]
    456              cinfo->num_components = 3;
   \   000000F0   481086E5           STR      R1,[R6, #+72]
    457              /* JFIF specifies component IDs 1,2,3 */
    458              /* We default to 2x2 subsamples of chrominance */
    459              SET_COMP(0, 1, 2,2, 0, 0,0);
   \   000000F4   500096E5           LDR      R0,[R6, #+80]
   \   000000F8   005080E5           STR      R5,[R0, #+0]
   \   000000FC   082080E5           STR      R2,[R0, #+8]
   \   00000100   0C2080E5           STR      R2,[R0, #+12]
   \   00000104   104080E5           STR      R4,[R0, #+16]
   \   00000108   144080E5           STR      R4,[R0, #+20]
   \   0000010C   184080E5           STR      R4,[R0, #+24]
    460              SET_COMP(1, 2, 1,1, 1, 1,1);
   \   00000110   500096E5           LDR      R0,[R6, #+80]
   \   00000114   5820A0E5           STR      R2,[R0, #+88]!
   \   00000118   085080E5           STR      R5,[R0, #+8]
   \   0000011C   0C5080E5           STR      R5,[R0, #+12]
   \   00000120   105080E5           STR      R5,[R0, #+16]
   \   00000124   145080E5           STR      R5,[R0, #+20]
   \   00000128   185080E5           STR      R5,[R0, #+24]
    461              SET_COMP(2, 3, 1,1, 1, 1,1);
   \   0000012C   500096E5           LDR      R0,[R6, #+80]
   \   00000130   B010A0E5           STR      R1,[R0, #+176]!
   \   00000134   085080E5           STR      R5,[R0, #+8]
   \   00000138   0C5080E5           STR      R5,[R0, #+12]
   \   0000013C   105080E5           STR      R5,[R0, #+16]
   \   00000140   145080E5           STR      R5,[R0, #+20]
   \   00000144   185080E5           STR      R5,[R0, #+24]
   \   00000148   F080BDE8           POP      {R4-R7,PC}
    462              break;
    463            case JCS_CMYK:
    464              cinfo->write_Adobe_marker = TRUE; /* write Adobe marker to flag CMYK */
   \                     ??jpeg_set_colorspace_8:
   \   0000014C   FC5086E5           STR      R5,[R6, #+252]
    465              cinfo->num_components = 4;
   \   00000150   483086E5           STR      R3,[R6, #+72]
    466              SET_COMP(0, 0x43 /* 'C' */, 1,1, 0, 0,0);
   \   00000154   501096E5           LDR      R1,[R6, #+80]
   \   00000158   4320A0E3           MOV      R2,#+67
   \   0000015C   002081E5           STR      R2,[R1, #+0]
   \   00000160   085081E5           STR      R5,[R1, #+8]
   \   00000164   0C5081E5           STR      R5,[R1, #+12]
   \   00000168   104081E5           STR      R4,[R1, #+16]
   \   0000016C   144081E5           STR      R4,[R1, #+20]
   \   00000170   184081E5           STR      R4,[R1, #+24]
    467              SET_COMP(1, 0x4D /* 'M' */, 1,1, 0, 0,0);
   \   00000174   501096E5           LDR      R1,[R6, #+80]
   \   00000178   4D20A0E3           MOV      R2,#+77
   \   0000017C   5820A1E5           STR      R2,[R1, #+88]!
   \   00000180   085081E5           STR      R5,[R1, #+8]
   \   00000184   0C5081E5           STR      R5,[R1, #+12]
   \   00000188   104081E5           STR      R4,[R1, #+16]
   \   0000018C   144081E5           STR      R4,[R1, #+20]
   \   00000190   184081E5           STR      R4,[R1, #+24]
    468              SET_COMP(2, 0x59 /* 'Y' */, 1,1, 0, 0,0);
   \   00000194   501096E5           LDR      R1,[R6, #+80]
   \   00000198   5920A0E3           MOV      R2,#+89
   \   0000019C   B020A1E5           STR      R2,[R1, #+176]!
   \   000001A0   085081E5           STR      R5,[R1, #+8]
   \   000001A4   0C5081E5           STR      R5,[R1, #+12]
   \   000001A8   104081E5           STR      R4,[R1, #+16]
   \   000001AC   144081E5           STR      R4,[R1, #+20]
   \   000001B0   184081E5           STR      R4,[R1, #+24]
    469              SET_COMP(3, 0x4B /* 'K' */, 1,1, 0, 0,0);
   \   000001B4   501096E5           LDR      R1,[R6, #+80]
   \   000001B8   010080E0           ADD      R0,R0,R1
   \   000001BC   4B10A0E3           MOV      R1,#+75
   \                     ??jpeg_set_colorspace_6:
   \   000001C0   001080E5           STR      R1,[R0, #+0]
   \                     ??jpeg_set_colorspace_4:
   \   000001C4   085080E5           STR      R5,[R0, #+8]
   \   000001C8   0C5080E5           STR      R5,[R0, #+12]
   \                     ??jpeg_set_colorspace_9:
   \   000001CC   104080E5           STR      R4,[R0, #+16]
   \   000001D0   144080E5           STR      R4,[R0, #+20]
   \   000001D4   184080E5           STR      R4,[R0, #+24]
   \   000001D8   F080BDE8           POP      {R4-R7,PC}
    470              break;
    471            case JCS_YCCK:
    472              cinfo->write_Adobe_marker = TRUE; /* write Adobe marker to flag YCCK */
   \                     ??jpeg_set_colorspace_10:
   \   000001DC   FC5086E5           STR      R5,[R6, #+252]
    473              cinfo->num_components = 4;
   \   000001E0   483086E5           STR      R3,[R6, #+72]
    474              SET_COMP(0, 1, 2,2, 0, 0,0);
   \   000001E4   507096E5           LDR      R7,[R6, #+80]
   \   000001E8   005087E5           STR      R5,[R7, #+0]
   \   000001EC   082087E5           STR      R2,[R7, #+8]
   \   000001F0   0C2087E5           STR      R2,[R7, #+12]
   \   000001F4   104087E5           STR      R4,[R7, #+16]
   \   000001F8   144087E5           STR      R4,[R7, #+20]
   \   000001FC   184087E5           STR      R4,[R7, #+24]
    475              SET_COMP(1, 2, 1,1, 1, 1,1);
   \   00000200   507096E5           LDR      R7,[R6, #+80]
   \   00000204   5820A7E5           STR      R2,[R7, #+88]!
   \   00000208   085087E5           STR      R5,[R7, #+8]
   \   0000020C   0C5087E5           STR      R5,[R7, #+12]
   \   00000210   105087E5           STR      R5,[R7, #+16]
   \   00000214   145087E5           STR      R5,[R7, #+20]
   \   00000218   185087E5           STR      R5,[R7, #+24]
    476              SET_COMP(2, 3, 1,1, 1, 1,1);
   \   0000021C   507096E5           LDR      R7,[R6, #+80]
   \   00000220   B010A7E5           STR      R1,[R7, #+176]!
   \   00000224   085087E5           STR      R5,[R7, #+8]
   \   00000228   0C5087E5           STR      R5,[R7, #+12]
   \   0000022C   105087E5           STR      R5,[R7, #+16]
   \   00000230   145087E5           STR      R5,[R7, #+20]
   \   00000234   185087E5           STR      R5,[R7, #+24]
    477              SET_COMP(3, 4, 2,2, 0, 0,0);
   \   00000238   501096E5           LDR      R1,[R6, #+80]
   \   0000023C   010080E0           ADD      R0,R0,R1
   \   00000240   003080E5           STR      R3,[R0, #+0]
   \   00000244   082080E5           STR      R2,[R0, #+8]
   \   00000248   0C2080E5           STR      R2,[R0, #+12]
   \   0000024C   DEFFFFEA           B        ??jpeg_set_colorspace_9
    478              break;
    479            case JCS_UNKNOWN:
    480              cinfo->num_components = cinfo->input_components;
   \                     ??jpeg_set_colorspace_11:
   \   00000250   240096E5           LDR      R0,[R6, #+36]
   \   00000254   480086E5           STR      R0,[R6, #+72]
    481              if (cinfo->num_components < 1 || cinfo->num_components > MAX_COMPONENTS)
   \   00000258   010050E3           CMP      R0,#+1
   \   0000025C   010000BA           BLT      ??jpeg_set_colorspace_12
   \   00000260   0B0050E3           CMP      R0,#+11
   \   00000264   0C0000BA           BLT      ??jpeg_set_colorspace_13
    482                ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,
    483          	       MAX_COMPONENTS);
   \                     ??jpeg_set_colorspace_12:
   \   00000268   000096E5           LDR      R0,[R6, #+0]
   \   0000026C   1B10A0E3           MOV      R1,#+27
   \   00000270   141080E5           STR      R1,[R0, #+20]
   \   00000274   000096E5           LDR      R0,[R6, #+0]
   \   00000278   481096E5           LDR      R1,[R6, #+72]
   \   0000027C   181080E5           STR      R1,[R0, #+24]
   \   00000280   000096E5           LDR      R0,[R6, #+0]
   \   00000284   0A10A0E3           MOV      R1,#+10
   \   00000288   1C1080E5           STR      R1,[R0, #+28]
   \   0000028C   001096E5           LDR      R1,[R6, #+0]
   \   00000290   0600A0E1           MOV      R0,R6
   \   00000294   001091E5           LDR      R1,[R1, #+0]
   \   00000298   31FF2FE1           BLX      R1
    484              for (ci = 0; ci < cinfo->num_components; ci++) {
   \                     ??jpeg_set_colorspace_13:
   \   0000029C   480096E5           LDR      R0,[R6, #+72]
   \   000002A0   0010A0E3           MOV      R1,#+0
   \   000002A4   010050E3           CMP      R0,#+1
   \   000002A8   5820A0E3           MOV      R2,#+88
   \   000002AC   F080BDB8           POPLT    {R4-R7,PC}
   \                     ??jpeg_set_colorspace_14:
   \   000002B0   480096E5           LDR      R0,[R6, #+72]
   \   000002B4   000051E1           CMP      R1,R0
   \   000002B8   F080BDA8           POPGE    {R4-R7,PC}
    485                SET_COMP(ci, ci, 1,1, 0, 0,0);
   \   000002BC   500096E5           LDR      R0,[R6, #+80]
   \   000002C0   920120E0           MLA      R0,R2,R1,R0
   \   000002C4   001080E5           STR      R1,[R0, #+0]
   \   000002C8   085080E5           STR      R5,[R0, #+8]
   \   000002CC   0C5080E5           STR      R5,[R0, #+12]
   \   000002D0   104080E5           STR      R4,[R0, #+16]
   \   000002D4   144080E5           STR      R4,[R0, #+20]
   \   000002D8   184080E5           STR      R4,[R0, #+24]
    486              }
   \   000002DC   011081E2           ADD      R1,R1,#+1
   \   000002E0   F2FFFFEA           B        ??jpeg_set_colorspace_14
    487              break;
    488            default:
    489              ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
   \                     ??jpeg_set_colorspace_2:
   \   000002E4   000096E5           LDR      R0,[R6, #+0]
   \   000002E8   0B10A0E3           MOV      R1,#+11
   \   000002EC   141080E5           STR      R1,[R0, #+20]
   \   000002F0   001096E5           LDR      R1,[R6, #+0]
   \   000002F4   0600A0E1           MOV      R0,R6
   \   000002F8   001091E5           LDR      R1,[R1, #+0]
   \   000002FC   31FF2FE1           BLX      R1
    490            }
    491          }
   \   00000300   F080BDE8           POP      {R4-R7,PC}       ;; return
    492          
    493          
    494          #ifdef C_PROGRESSIVE_SUPPORTED
    495          
    496          LOCAL(jpeg_scan_info *)
    497          fill_a_scan (jpeg_scan_info * scanptr, int ci,
    498          	     int Ss, int Se, int Ah, int Al)
    499          /* Support routine: generate one scan for specified component */
    500          {
    501            scanptr->comps_in_scan = 1;
    502            scanptr->component_index[0] = ci;
    503            scanptr->Ss = Ss;
    504            scanptr->Se = Se;
    505            scanptr->Ah = Ah;
    506            scanptr->Al = Al;
    507            scanptr++;
    508            return scanptr;
    509          }
    510          
    511          LOCAL(jpeg_scan_info *)
    512          fill_scans (jpeg_scan_info * scanptr, int ncomps,
    513          	    int Ss, int Se, int Ah, int Al)
    514          /* Support routine: generate one scan for each component */
    515          {
    516            int ci;
    517          
    518            for (ci = 0; ci < ncomps; ci++) {
    519              scanptr->comps_in_scan = 1;
    520              scanptr->component_index[0] = ci;
    521              scanptr->Ss = Ss;
    522              scanptr->Se = Se;
    523              scanptr->Ah = Ah;
    524              scanptr->Al = Al;
    525              scanptr++;
    526            }
    527            return scanptr;
    528          }
    529          

   \                                 In segment CODE, align 4, keep-with-next
    530          LOCAL(jpeg_scan_info *)
    531          fill_dc_scans (jpeg_scan_info * scanptr, int ncomps, int Ah, int Al)
    532          /* Support routine: generate interleaved DC scan if possible, else N scans */
    533          {
   \                     fill_dc_scans:
   \   00000000   30002DE9           PUSH     {R4,R5}
    534            int ci;
    535          
    536            if (ncomps <= MAX_COMPS_IN_SCAN) {
   \   00000004   00C0A0E3           MOV      R12,#+0
   \   00000008   050051E3           CMP      R1,#+5
   \   0000000C   110000AA           BGE      ??fill_dc_scans_0
    537              /* Single interleaved DC scan */
    538              scanptr->comps_in_scan = ncomps;
   \   00000010   001080E5           STR      R1,[R0, #+0]
    539              for (ci = 0; ci < ncomps; ci++)
   \   00000014   0040A0E3           MOV      R4,#+0
   \   00000018   010051E3           CMP      R1,#+1
   \   0000001C   030000AA           BGE      ??fill_dc_scans_1
   \   00000020   040000EA           B        ??fill_dc_scans_2
    540                scanptr->component_index[ci] = ci;
   \                     ??fill_dc_scans_3:
   \   00000024   045180E0           ADD      R5,R0,R4, LSL #+2
   \   00000028   044085E5           STR      R4,[R5, #+4]
   \   0000002C   014084E2           ADD      R4,R4,#+1
   \                     ??fill_dc_scans_1:
   \   00000030   010054E1           CMP      R4,R1
   \   00000034   FAFFFFBA           BLT      ??fill_dc_scans_3
    541              scanptr->Ss = scanptr->Se = 0;
   \                     ??fill_dc_scans_2:
   \   00000038   18C080E5           STR      R12,[R0, #+24]
   \   0000003C   0010A0E3           MOV      R1,#+0
   \   00000040   141080E5           STR      R1,[R0, #+20]
    542              scanptr->Ah = Ah;
   \   00000044   1C2080E5           STR      R2,[R0, #+28]
    543              scanptr->Al = Al;
   \   00000048   203080E5           STR      R3,[R0, #+32]
    544              scanptr++;
   \   0000004C   3000BDE8           POP      {R4,R5}
   \   00000050   240080E2           ADD      R0,R0,#+36
   \   00000054   1EFF2FE1           BX       LR
    545            } else {
    546              /* Noninterleaved DC scan for each component */
    547              scanptr = fill_scans(scanptr, ncomps, 0, 0, Ah, Al);
   \                     ??fill_dc_scans_0:
   \   00000058   0040A0E3           MOV      R4,#+0
   \   0000005C   0150A0E3           MOV      R5,#+1
   \   00000060   070000EA           B        ??fill_dc_scans_4
   \                     ??fill_dc_scans_5:
   \   00000064   005080E5           STR      R5,[R0, #+0]
   \   00000068   044080E5           STR      R4,[R0, #+4]
   \   0000006C   14C080E5           STR      R12,[R0, #+20]
   \   00000070   18C080E5           STR      R12,[R0, #+24]
   \   00000074   1C2080E5           STR      R2,[R0, #+28]
   \   00000078   203080E5           STR      R3,[R0, #+32]
   \   0000007C   240080E2           ADD      R0,R0,#+36
   \   00000080   014084E2           ADD      R4,R4,#+1
   \                     ??fill_dc_scans_4:
   \   00000084   010054E1           CMP      R4,R1
   \   00000088   F5FFFFBA           BLT      ??fill_dc_scans_5
    548            }
    549            return scanptr;
   \   0000008C   3000BDE8           POP      {R4,R5}
   \   00000090   1EFF2FE1           BX       LR               ;; return
    550          }
    551          
    552          
    553          /*
    554           * Create a recommended progressive-JPEG script.
    555           * cinfo->num_components and cinfo->jpeg_color_space must be correct.
    556           */
    557          

   \                                 In segment CODE, align 4, keep-with-next
    558          GLOBAL(void)
    559          jpeg_simple_progression (j_compress_ptr cinfo)
    560          {
   \                     jpeg_simple_progression:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   00B0A0E1           MOV      R11,R0
    561            int ncomps = cinfo->num_components;
    562            int nscans;
    563            jpeg_scan_info * scanptr;
    564          
    565            /* Safety check to ensure start_compress not called yet. */
    566            if (cinfo->global_state != CSTATE_START)
   \   00000008   14009BE5           LDR      R0,[R11, #+20]
   \   0000000C   48A09BE5           LDR      R10,[R11, #+72]
   \   00000010   640050E3           CMP      R0,#+100
   \   00000014   0900000A           BEQ      ??jpeg_simple_progression_0
    567              ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
   \   00000018   00009BE5           LDR      R0,[R11, #+0]
   \   0000001C   1510A0E3           MOV      R1,#+21
   \   00000020   141080E5           STR      R1,[R0, #+20]
   \   00000024   00009BE5           LDR      R0,[R11, #+0]
   \   00000028   14109BE5           LDR      R1,[R11, #+20]
   \   0000002C   181080E5           STR      R1,[R0, #+24]
   \   00000030   00109BE5           LDR      R1,[R11, #+0]
   \   00000034   0B00A0E1           MOV      R0,R11
   \   00000038   001091E5           LDR      R1,[R1, #+0]
   \   0000003C   31FF2FE1           BLX      R1
    568          
    569            /* Figure space needed for script.  Calculation must match code below! */
    570            if (ncomps == 3 && cinfo->jpeg_color_space == JCS_YCbCr) {
   \                     ??jpeg_simple_progression_0:
   \   00000040   03005AE3           CMP      R10,#+3
   \   00000044   0400001A           BNE      ??jpeg_simple_progression_1
   \   00000048   4C00DBE5           LDRB     R0,[R11, #+76]
   \   0000004C   030050E3           CMP      R0,#+3
   \   00000050   0500001A           BNE      ??jpeg_simple_progression_2
    571              /* Custom script for YCbCr color images. */
    572              nscans = 10;
   \   00000054   0A40A0E3           MOV      R4,#+10
   \   00000058   050000EA           B        ??jpeg_simple_progression_3
    573            } else {
    574              /* All-purpose script for other color spaces. */
    575              if (ncomps > MAX_COMPS_IN_SCAN)
   \                     ??jpeg_simple_progression_1:
   \   0000005C   05005AE3           CMP      R10,#+5
    576                nscans = 6 * ncomps;	/* 2 DC + 4 AC scans per component */
   \   00000060   0600A0A3           MOVGE    R0,#+6
   \   00000064   900A04A0           MULGE    R4,R0,R10
   \   00000068   010000AA           BGE      ??jpeg_simple_progression_3
    577              else
    578                nscans = 2 + 4 * ncomps;	/* 2 DC scans; 4 AC scans per component */
   \                     ??jpeg_simple_progression_2:
   \   0000006C   0200A0E3           MOV      R0,#+2
   \   00000070   0A4180E0           ADD      R4,R0,R10, LSL #+2
    579            }
    580          
    581            /* Allocate space for script.
    582             * We need to put it in the permanent pool in case the application performs
    583             * multiple compressions without changing the settings.  To avoid a memory
    584             * leak if jpeg_simple_progression is called repeatedly for the same JPEG
    585             * object, we try to re-use previously allocated space, and we allocate
    586             * enough space to handle YCbCr even if initially asked for grayscale.
    587             */
    588            if (cinfo->script_space == NULL || cinfo->script_space_size < nscans) {
   \                     ??jpeg_simple_progression_3:
   \   00000074   98019BE5           LDR      R0,[R11, #+408]
   \   00000078   000050E3           CMP      R0,#+0
   \   0000007C   0200000A           BEQ      ??jpeg_simple_progression_4
   \   00000080   9C019BE5           LDR      R0,[R11, #+412]
   \   00000084   040050E1           CMP      R0,R4
   \   00000088   0B0000AA           BGE      ??jpeg_simple_progression_5
    589              cinfo->script_space_size = MAX(nscans, 10);
   \                     ??jpeg_simple_progression_4:
   \   0000008C   0B0054E3           CMP      R4,#+11
   \   00000090   0400A0A1           MOVGE    R0,R4
   \   00000094   0A00A0B3           MOVLT    R0,#+10
   \   00000098   9C018BE5           STR      R0,[R11, #+412]
    590              cinfo->script_space = (jpeg_scan_info *)
    591                (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
    592          			cinfo->script_space_size * SIZEOF(jpeg_scan_info));
   \   0000009C   04309BE5           LDR      R3,[R11, #+4]
   \   000000A0   2410A0E3           MOV      R1,#+36
   \   000000A4   003093E5           LDR      R3,[R3, #+0]
   \   000000A8   910002E0           MUL      R2,R1,R0
   \   000000AC   0010A0E3           MOV      R1,#+0
   \   000000B0   0B00A0E1           MOV      R0,R11
   \   000000B4   33FF2FE1           BLX      R3
   \   000000B8   98018BE5           STR      R0,[R11, #+408]
    593            }
    594            scanptr = cinfo->script_space;
   \                     ??jpeg_simple_progression_5:
   \   000000BC   98019BE5           LDR      R0,[R11, #+408]
    595            cinfo->scan_info = scanptr;
    596            cinfo->num_scans = nscans;
    597          
    598            if (ncomps == 3 && cinfo->jpeg_color_space == JCS_YCbCr) {
   \   000000C0   03005AE3           CMP      R10,#+3
   \   000000C4   C8008BE5           STR      R0,[R11, #+200]
   \   000000C8   C4408BE5           STR      R4,[R11, #+196]
   \   000000CC   4C10DB05           LDRBEQ   R1,[R11, #+76]
   \   000000D0   3F40A0E3           MOV      R4,#+63
   \   000000D4   0150A0E3           MOV      R5,#+1
   \   000000D8   0260A0E3           MOV      R6,#+2
   \   000000DC   0670A0E3           MOV      R7,#+6
   \   000000E0   0580A0E3           MOV      R8,#+5
   \   000000E4   0090A0E3           MOV      R9,#+0
   \   000000E8   03005103           CMPEQ    R1,#+3
   \   000000EC   3800001A           BNE      ??jpeg_simple_progression_6
    599              /* Custom script for YCbCr color images. */
    600              /* Initial DC scan */
    601              scanptr = fill_dc_scans(scanptr, ncomps, 0, 1);
   \   000000F0   0130A0E3           MOV      R3,#+1
   \   000000F4   0920A0E1           MOV      R2,R9
   \   000000F8   ........           BL       fill_dc_scans
    602              /* Initial AC scan: get some luma data out in a hurry */
    603              scanptr = fill_a_scan(scanptr, 0, 1, 5, 0, 2);
   \   000000FC   005080E5           STR      R5,[R0, #+0]
   \   00000100   049080E5           STR      R9,[R0, #+4]
   \   00000104   145080E5           STR      R5,[R0, #+20]
   \   00000108   188080E5           STR      R8,[R0, #+24]
   \   0000010C   1C9080E5           STR      R9,[R0, #+28]
   \   00000110   206080E5           STR      R6,[R0, #+32]
    604              /* Chroma data is too small to be worth expending many scans on */
    605              scanptr = fill_a_scan(scanptr, 2, 1, 63, 0, 1);
   \   00000114   2450A0E5           STR      R5,[R0, #+36]!
   \   00000118   046080E5           STR      R6,[R0, #+4]
   \   0000011C   145080E5           STR      R5,[R0, #+20]
   \   00000120   184080E5           STR      R4,[R0, #+24]
   \   00000124   1C9080E5           STR      R9,[R0, #+28]
   \   00000128   205080E5           STR      R5,[R0, #+32]
    606              scanptr = fill_a_scan(scanptr, 1, 1, 63, 0, 1);
   \   0000012C   2450A0E5           STR      R5,[R0, #+36]!
   \   00000130   045080E5           STR      R5,[R0, #+4]
   \   00000134   145080E5           STR      R5,[R0, #+20]
   \   00000138   184080E5           STR      R4,[R0, #+24]
   \   0000013C   1C9080E5           STR      R9,[R0, #+28]
   \   00000140   205080E5           STR      R5,[R0, #+32]
    607              /* Complete spectral selection for luma AC */
    608              scanptr = fill_a_scan(scanptr, 0, 6, 63, 0, 2);
   \   00000144   2450A0E5           STR      R5,[R0, #+36]!
   \   00000148   049080E5           STR      R9,[R0, #+4]
   \   0000014C   147080E5           STR      R7,[R0, #+20]
   \   00000150   184080E5           STR      R4,[R0, #+24]
   \   00000154   1C9080E5           STR      R9,[R0, #+28]
   \   00000158   206080E5           STR      R6,[R0, #+32]
    609              /* Refine next bit of luma AC */
    610              scanptr = fill_a_scan(scanptr, 0, 1, 63, 2, 1);
   \   0000015C   2450A0E5           STR      R5,[R0, #+36]!
   \   00000160   049080E5           STR      R9,[R0, #+4]
   \   00000164   145080E5           STR      R5,[R0, #+20]
   \   00000168   184080E5           STR      R4,[R0, #+24]
   \   0000016C   1C6080E5           STR      R6,[R0, #+28]
   \   00000170   205080E5           STR      R5,[R0, #+32]
    611              /* Finish DC successive approximation */
    612              scanptr = fill_dc_scans(scanptr, ncomps, 1, 0);
   \   00000174   0930A0E1           MOV      R3,R9
   \   00000178   0520A0E1           MOV      R2,R5
   \   0000017C   0310A0E3           MOV      R1,#+3
   \   00000180   240080E2           ADD      R0,R0,#+36
   \   00000184   ........           BL       fill_dc_scans
    613              /* Finish AC successive approximation */
    614              scanptr = fill_a_scan(scanptr, 2, 1, 63, 1, 0);
   \   00000188   005080E5           STR      R5,[R0, #+0]
   \   0000018C   046080E5           STR      R6,[R0, #+4]
   \   00000190   145080E5           STR      R5,[R0, #+20]
   \   00000194   184080E5           STR      R4,[R0, #+24]
   \   00000198   1C5080E5           STR      R5,[R0, #+28]
   \   0000019C   209080E5           STR      R9,[R0, #+32]
    615              scanptr = fill_a_scan(scanptr, 1, 1, 63, 1, 0);
   \   000001A0   2450A0E5           STR      R5,[R0, #+36]!
   \   000001A4   045080E5           STR      R5,[R0, #+4]
   \   000001A8   145080E5           STR      R5,[R0, #+20]
   \   000001AC   184080E5           STR      R4,[R0, #+24]
   \   000001B0   1C5080E5           STR      R5,[R0, #+28]
   \   000001B4   209080E5           STR      R9,[R0, #+32]
    616              /* Luma bottom bit comes last since it's usually largest scan */
    617              scanptr = fill_a_scan(scanptr, 0, 1, 63, 1, 0);
   \   000001B8   2450A0E5           STR      R5,[R0, #+36]!
   \   000001BC   049080E5           STR      R9,[R0, #+4]
   \   000001C0   145080E5           STR      R5,[R0, #+20]
   \   000001C4   184080E5           STR      R4,[R0, #+24]
   \   000001C8   1C5080E5           STR      R5,[R0, #+28]
   \   000001CC   209080E5           STR      R9,[R0, #+32]
   \   000001D0   F08FBDE8           POP      {R4-R11,PC}
    618            } else {
    619              /* All-purpose script for other color spaces. */
    620              /* Successive approximation first pass */
    621              scanptr = fill_dc_scans(scanptr, ncomps, 0, 1);
    622              scanptr = fill_scans(scanptr, ncomps, 1, 5, 0, 2);
   \                     ??jpeg_simple_progression_6:
   \   000001D4   0130A0E3           MOV      R3,#+1
   \   000001D8   0920A0E1           MOV      R2,R9
   \   000001DC   0A10A0E1           MOV      R1,R10
   \   000001E0   ........           BL       fill_dc_scans
   \   000001E4   0910A0E1           MOV      R1,R9
   \   000001E8   01005AE3           CMP      R10,#+1
   \   000001EC   080000AA           BGE      ??jpeg_simple_progression_7
   \   000001F0   090000EA           B        ??jpeg_simple_progression_8
   \                     ??jpeg_simple_progression_9:
   \   000001F4   005080E5           STR      R5,[R0, #+0]
   \   000001F8   041080E5           STR      R1,[R0, #+4]
   \   000001FC   145080E5           STR      R5,[R0, #+20]
   \   00000200   188080E5           STR      R8,[R0, #+24]
   \   00000204   1C9080E5           STR      R9,[R0, #+28]
   \   00000208   206080E5           STR      R6,[R0, #+32]
   \   0000020C   240080E2           ADD      R0,R0,#+36
   \   00000210   011081E2           ADD      R1,R1,#+1
   \                     ??jpeg_simple_progression_7:
   \   00000214   0A0051E1           CMP      R1,R10
   \   00000218   F5FFFFBA           BLT      ??jpeg_simple_progression_9
    623              scanptr = fill_scans(scanptr, ncomps, 6, 63, 0, 2);
   \                     ??jpeg_simple_progression_8:
   \   0000021C   0010A0E3           MOV      R1,#+0
   \   00000220   01005AE3           CMP      R10,#+1
   \   00000224   080000AA           BGE      ??jpeg_simple_progression_10
   \   00000228   090000EA           B        ??jpeg_simple_progression_11
   \                     ??jpeg_simple_progression_12:
   \   0000022C   005080E5           STR      R5,[R0, #+0]
   \   00000230   041080E5           STR      R1,[R0, #+4]
   \   00000234   147080E5           STR      R7,[R0, #+20]
   \   00000238   184080E5           STR      R4,[R0, #+24]
   \   0000023C   1C9080E5           STR      R9,[R0, #+28]
   \   00000240   206080E5           STR      R6,[R0, #+32]
   \   00000244   240080E2           ADD      R0,R0,#+36
   \   00000248   011081E2           ADD      R1,R1,#+1
   \                     ??jpeg_simple_progression_10:
   \   0000024C   0A0051E1           CMP      R1,R10
   \   00000250   F5FFFFBA           BLT      ??jpeg_simple_progression_12
    624              /* Successive approximation second pass */
    625              scanptr = fill_scans(scanptr, ncomps, 1, 63, 2, 1);
   \                     ??jpeg_simple_progression_11:
   \   00000254   0010A0E3           MOV      R1,#+0
   \   00000258   01005AE3           CMP      R10,#+1
   \   0000025C   080000AA           BGE      ??jpeg_simple_progression_13
   \   00000260   090000EA           B        ??jpeg_simple_progression_14
   \                     ??jpeg_simple_progression_15:
   \   00000264   005080E5           STR      R5,[R0, #+0]
   \   00000268   041080E5           STR      R1,[R0, #+4]
   \   0000026C   145080E5           STR      R5,[R0, #+20]
   \   00000270   184080E5           STR      R4,[R0, #+24]
   \   00000274   1C6080E5           STR      R6,[R0, #+28]
   \   00000278   205080E5           STR      R5,[R0, #+32]
   \   0000027C   240080E2           ADD      R0,R0,#+36
   \   00000280   011081E2           ADD      R1,R1,#+1
   \                     ??jpeg_simple_progression_13:
   \   00000284   0A0051E1           CMP      R1,R10
   \   00000288   F5FFFFBA           BLT      ??jpeg_simple_progression_15
    626              /* Successive approximation final pass */
    627              scanptr = fill_dc_scans(scanptr, ncomps, 1, 0);
    628              scanptr = fill_scans(scanptr, ncomps, 1, 63, 1, 0);
   \                     ??jpeg_simple_progression_14:
   \   0000028C   0030A0E3           MOV      R3,#+0
   \   00000290   0520A0E1           MOV      R2,R5
   \   00000294   0A10A0E1           MOV      R1,R10
   \   00000298   ........           BL       fill_dc_scans
   \   0000029C   0910A0E1           MOV      R1,R9
   \   000002A0   01005AE3           CMP      R10,#+1
   \   000002A4   080000AA           BGE      ??jpeg_simple_progression_16
   \   000002A8   F08FBDE8           POP      {R4-R11,PC}
   \                     ??jpeg_simple_progression_17:
   \   000002AC   005080E5           STR      R5,[R0, #+0]
   \   000002B0   041080E5           STR      R1,[R0, #+4]
   \   000002B4   145080E5           STR      R5,[R0, #+20]
   \   000002B8   184080E5           STR      R4,[R0, #+24]
   \   000002BC   1C5080E5           STR      R5,[R0, #+28]
   \   000002C0   209080E5           STR      R9,[R0, #+32]
   \   000002C4   240080E2           ADD      R0,R0,#+36
   \   000002C8   011081E2           ADD      R1,R1,#+1
   \                     ??jpeg_simple_progression_16:
   \   000002CC   0A0051E1           CMP      R1,R10
   \   000002D0   F5FFFFBA           BLT      ??jpeg_simple_progression_17
    629            }
    630          }
   \   000002D4   F08FBDE8           POP      {R4-R11,PC}      ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     std_luminance_quant_tbl

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   ........           DC32     std_chrominance_quant_tbl
    631          
    632          #endif /* C_PROGRESSIVE_SUPPORTED */

   Maximum stack usage in bytes:

     Function                CSTACK
     --------                ------
     add_huff_table             24
     fill_dc_scans               8
     jpeg_add_quant_table       24
     jpeg_default_colorspace     4
     jpeg_default_qtables       20
     jpeg_quality_scaling        4
     jpeg_set_colorspace        20
     jpeg_set_defaults          12
     jpeg_set_linear_quality    24
     jpeg_set_quality           12
     jpeg_simple_progression    36


   Segment part sizes:

     Function/Label            Bytes
     --------------            -----
     jpeg_add_quant_table       276
     std_luminance_quant_tbl    256
     std_chrominance_quant_tbl  256
     jpeg_default_qtables        68
     jpeg_set_linear_quality     72
     jpeg_quality_scaling        72
     jpeg_set_quality            40
     add_huff_table             176
     bits_dc_luminance           20
     val_dc_luminance            12
     bits_dc_chrominance         20
     val_dc_chrominance          12
     bits_ac_luminance           20
     val_ac_luminance           164
     bits_ac_chrominance         20
     val_ac_chrominance         164
     jpeg_set_defaults          384
     jpeg_default_colorspace    128
     jpeg_set_colorspace        772
     fill_dc_scans              148
     jpeg_simple_progression    728
     ??DataTable2                 4
     ??DataTable3                 4
      Others                     80

 
 2 952 bytes in segment CODE
   944 bytes in segment DATA_C
 
 2 872 bytes of CODE  memory (+ 80 bytes shared)
   944 bytes of CONST memory

Errors: none
Warnings: 1
