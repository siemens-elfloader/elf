##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    19/Jan/2011  13:20:31 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\grabber\jpeg-7\jdcolor.c                      #
#    Command line    =  C:\arm\grabber\jpeg-7\jdcolor.c -lC                  #
#                       C:\arm\grabber\Release_SGOLD\List\ -o                #
#                       C:\arm\grabber\Release_SGOLD\Obj\ -s9 --no_unroll    #
#                       --no_clustering --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --fpu None --dlib_config "C:\arm2\Embedded           #
#                       Workbench 4.0 Evaluation\ARM\LIB\dl5tpainl8n.h" -I   #
#                       "C:\arm2\Embedded Workbench 4.0                      #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  C:\arm\grabber\Release_SGOLD\List\jdcolor.lst        #
#    Object file     =  C:\arm\grabber\Release_SGOLD\Obj\jdcolor.r79         #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\grabber\jpeg-7\jdcolor.c
      1          /*
                  ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           * jdcolor.c
      3           *
      4           * Copyright (C) 1991-1997, Thomas G. Lane.
      5           * This file is part of the Independent JPEG Group's software.
      6           * For conditions of distribution and use, see the accompanying README file.
      7           *
      8           * This file contains output colorspace conversion routines.
      9           */
     10          
     11          #define JPEG_INTERNALS
     12          #include "jinclude.h"
     13          #include "jpeglib.h"
     14          
     15          
     16          /* Private subobject */
     17          
     18          typedef struct {
     19            struct jpeg_color_deconverter pub; /* public fields */
     20          
     21            /* Private state for YCC->RGB conversion */
     22            int * Cr_r_tab;		/* => table for Cr to R conversion */
     23            int * Cb_b_tab;		/* => table for Cb to B conversion */
     24            INT32 * Cr_g_tab;		/* => table for Cr to G conversion */
     25            INT32 * Cb_g_tab;		/* => table for Cb to G conversion */
     26          } my_color_deconverter;
     27          
     28          typedef my_color_deconverter * my_cconvert_ptr;
     29          
     30          
     31          /**************** YCbCr -> RGB conversion: most common case **************/
     32          
     33          /*
     34           * YCbCr is defined per CCIR 601-1, except that Cb and Cr are
     35           * normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.
     36           * The conversion equations to be implemented are therefore
     37           *	R = Y                + 1.40200 * Cr
     38           *	G = Y - 0.34414 * Cb - 0.71414 * Cr
     39           *	B = Y + 1.77200 * Cb
     40           * where Cb and Cr represent the incoming values less CENTERJSAMPLE.
     41           * (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.)
     42           *
     43           * To avoid floating-point arithmetic, we represent the fractional constants
     44           * as integers scaled up by 2^16 (about 4 digits precision); we have to divide
     45           * the products by 2^16, with appropriate rounding, to get the correct answer.
     46           * Notice that Y, being an integral input, does not contribute any fraction
     47           * so it need not participate in the rounding.
     48           *
     49           * For even more speed, we avoid doing any multiplications in the inner loop
     50           * by precalculating the constants times Cb and Cr for all possible values.
     51           * For 8-bit JSAMPLEs this is very reasonable (only 256 entries per table);
     52           * for 12-bit samples it is still acceptable.  It's not very reasonable for
     53           * 16-bit samples, but if you want lossless storage you shouldn't be changing
     54           * colorspace anyway.
     55           * The Cr=>R and Cb=>B values can be rounded to integers in advance; the
     56           * values for the G calculation are left scaled up, since we must add them
     57           * together before rounding.
     58           */
     59          
     60          #define SCALEBITS	16	/* speediest right-shift on some machines */
     61          #define ONE_HALF	((INT32) 1 << (SCALEBITS-1))
     62          #define FIX(x)		((INT32) ((x) * (1L<<SCALEBITS) + 0.5))
     63          
     64          
     65          /*
     66           * Initialize tables for YCC->RGB colorspace conversion.
     67           */
     68          

   \                                 In segment CODE, align 4, keep-with-next
     69          LOCAL(void)
     70          build_ycc_rgb_table (j_decompress_ptr cinfo)
     71          {
   \                     build_ycc_rgb_table:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
     72            my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
     73            int i;
     74            INT32 x;
     75            SHIFT_TEMPS
     76          
     77            cconvert->Cr_r_tab = (int *)
     78              (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
     79          				(MAXJSAMPLE+1) * SIZEOF(int));
   \   00000004   402EA0E3           MOV      R2,#+1024
   \   00000008   0110A0E3           MOV      R1,#+1
   \   0000000C   0050A0E1           MOV      R5,R0
   \   00000010   C84195E5           LDR      R4,[R5, #+456]
   \   00000014   043095E5           LDR      R3,[R5, #+4]
   \   00000018   003093E5           LDR      R3,[R3, #+0]
   \   0000001C   33FF2FE1           BLX      R3
   \   00000020   080084E5           STR      R0,[R4, #+8]
     80            cconvert->Cb_b_tab = (int *)
     81              (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
     82          				(MAXJSAMPLE+1) * SIZEOF(int));
   \   00000024   043095E5           LDR      R3,[R5, #+4]
   \   00000028   402EA0E3           MOV      R2,#+1024
   \   0000002C   003093E5           LDR      R3,[R3, #+0]
   \   00000030   0110A0E3           MOV      R1,#+1
   \   00000034   0500A0E1           MOV      R0,R5
   \   00000038   33FF2FE1           BLX      R3
   \   0000003C   0C0084E5           STR      R0,[R4, #+12]
     83            cconvert->Cr_g_tab = (INT32 *)
     84              (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
     85          				(MAXJSAMPLE+1) * SIZEOF(INT32));
   \   00000040   043095E5           LDR      R3,[R5, #+4]
   \   00000044   402EA0E3           MOV      R2,#+1024
   \   00000048   003093E5           LDR      R3,[R3, #+0]
   \   0000004C   0110A0E3           MOV      R1,#+1
   \   00000050   0500A0E1           MOV      R0,R5
   \   00000054   33FF2FE1           BLX      R3
   \   00000058   100084E5           STR      R0,[R4, #+16]
     86            cconvert->Cb_g_tab = (INT32 *)
     87              (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
     88          				(MAXJSAMPLE+1) * SIZEOF(INT32));
   \   0000005C   043095E5           LDR      R3,[R5, #+4]
   \   00000060   402EA0E3           MOV      R2,#+1024
   \   00000064   003093E5           LDR      R3,[R3, #+0]
   \   00000068   0110A0E3           MOV      R1,#+1
   \   0000006C   0500A0E1           MOV      R0,R5
   \   00000070   33FF2FE1           BLX      R3
   \   00000074   140084E5           STR      R0,[R4, #+20]
     89          
     90            for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
   \   00000078   0000A0E3           MOV      R0,#+0
   \   0000007C   7F10E0E3           MVN      R1,#+127
     91              /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
     92              /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
     93              /* Cr=>R value is nearest int to 1.40200 * x */
     94              cconvert->Cr_r_tab[i] = (int)
     95          		    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);
   \                     ??build_ycc_rgb_table_0:
   \   00000080   68309FE5           LDR      R3,??build_ycc_rgb_table_1  ;; 0x166e9
   \   00000084   082094E5           LDR      R2,[R4, #+8]
   \   00000088   930105E0           MUL      R5,R3,R1
   \   0000008C   803C85E2           ADD      R3,R5,#+32768
   \   00000090   4338A0E1           ASR      R3,R3,#+16
   \   00000094   003182E7           STR      R3,[R2, +R0, LSL #+2]
     96              /* Cb=>B value is nearest int to 1.77200 * x */
     97              cconvert->Cb_b_tab[i] = (int)
     98          		    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);
   \   00000098   54309FE5           LDR      R3,??build_ycc_rgb_table_1+0x4  ;; 0x1c5a2
   \   0000009C   0C2094E5           LDR      R2,[R4, #+12]
   \   000000A0   930105E0           MUL      R5,R3,R1
   \   000000A4   803C85E2           ADD      R3,R5,#+32768
   \   000000A8   4338A0E1           ASR      R3,R3,#+16
   \   000000AC   003182E7           STR      R3,[R2, +R0, LSL #+2]
     99              /* Cr=>G value is scaled-up -0.71414 * x */
    100              cconvert->Cr_g_tab[i] = (- FIX(0.71414)) * x;
   \   000000B0   102094E5           LDR      R2,[R4, #+16]
   \   000000B4   D130E0E3           MVN      R3,#+209
   \   000000B8   B63CC3E3           BIC      R3,R3,#0xB600
   \   000000BC   930105E0           MUL      R5,R3,R1
    101              /* Cb=>G value is scaled-up -0.34414 * x */
    102              /* We also add in ONE_HALF so that need not do it in inner loop */
    103              cconvert->Cb_g_tab[i] = (- FIX(0.34414)) * x + ONE_HALF;
   \   000000C0   1930E0E3           MVN      R3,#+25
   \   000000C4   005182E7           STR      R5,[R2, +R0, LSL #+2]
   \   000000C8   142094E5           LDR      R2,[R4, #+20]
   \   000000CC   583CC3E3           BIC      R3,R3,#0x5800
   \   000000D0   930105E0           MUL      R5,R3,R1
    104            }
   \   000000D4   011081E2           ADD      R1,R1,#+1
   \   000000D8   803C85E2           ADD      R3,R5,#+32768
   \   000000DC   003182E7           STR      R3,[R2, +R0, LSL #+2]
   \   000000E0   010080E2           ADD      R0,R0,#+1
   \   000000E4   400F50E3           CMP      R0,#+256
   \   000000E8   E4FFFFBA           BLT      ??build_ycc_rgb_table_0
    105          }
   \   000000EC   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??build_ycc_rgb_table_1:
   \   000000F0   E9660100           DC32     0x166e9
   \   000000F4   A2C50100           DC32     0x1c5a2
    106          
    107          
    108          /*
    109           * Convert some rows of samples to the output colorspace.
    110           *
    111           * Note that we change from noninterleaved, one-plane-per-component format
    112           * to interleaved-pixel format.  The output buffer is therefore three times
    113           * as wide as the input buffer.
    114           * A starting row offset is provided only for the input buffer.  The caller
    115           * can easily adjust the passed output_buf value to accommodate any row
    116           * offset required on that side.
    117           */
    118          

   \                                 In segment CODE, align 4, keep-with-next
    119          METHODDEF(void)
    120          ycc_rgb_convert (j_decompress_ptr cinfo,
    121          		 JSAMPIMAGE input_buf, JDIMENSION input_row,
    122          		 JSAMPARRAY output_buf, int num_rows)
    123          {
   \                     ycc_rgb_convert:
   \   00000000   F84F2DE9           PUSH     {R3-R11,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
   \   00000008   38C09DE5           LDR      R12,[SP, #+56]
   \   0000000C   0030A0E1           MOV      R3,R0
    124            my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
   \   00000010   C84193E5           LDR      R4,[R3, #+456]
    125            register int y, cb, cr;
    126            register JSAMPROW outptr;
    127            register JSAMPROW inptr0, inptr1, inptr2;
    128            register JDIMENSION col;
    129            JDIMENSION num_cols = cinfo->output_width;
   \   00000014   6C0093E5           LDR      R0,[R3, #+108]
    130            /* copy these pointers into registers if possible */
    131            register JSAMPLE * range_limit = cinfo->sample_range_limit;
    132            register int * Crrtab = cconvert->Cr_r_tab;
   \   00000018   086094E5           LDR      R6,[R4, #+8]
   \   0000001C   443193E5           LDR      R3,[R3, #+324]
   \   00000020   00608DE5           STR      R6,[SP, #+0]
    133            register int * Cbbtab = cconvert->Cb_b_tab;
   \   00000024   0C6094E5           LDR      R6,[R4, #+12]
   \   00000028   04608DE5           STR      R6,[SP, #+4]
    134            register INT32 * Crgtab = cconvert->Cr_g_tab;
   \   0000002C   106094E5           LDR      R6,[R4, #+16]
   \   00000030   08608DE5           STR      R6,[SP, #+8]
    135            register INT32 * Cbgtab = cconvert->Cb_g_tab;
   \   00000034   144094E5           LDR      R4,[R4, #+20]
   \   00000038   0C408DE5           STR      R4,[SP, #+12]
    136            SHIFT_TEMPS
    137          
    138            while (--num_rows >= 0) {
   \                     ??ycc_rgb_convert_0:
   \   0000003C   01C05CE2           SUBS     R12,R12,#+1
   \   00000040   2700004A           BMI      ??ycc_rgb_convert_1
    139              inptr0 = input_buf[0][input_row];
   \   00000044   004091E5           LDR      R4,[R1, #+0]
    140              inptr1 = input_buf[1][input_row];
   \   00000048   045091E5           LDR      R5,[R1, #+4]
    141              inptr2 = input_buf[2][input_row];
   \   0000004C   086091E5           LDR      R6,[R1, #+8]
    142              input_row++;
    143              outptr = *output_buf++;
   \   00000050   10909DE5           LDR      R9,[SP, #+16]
   \   00000054   024194E7           LDR      R4,[R4, +R2, LSL #+2]
   \   00000058   025195E7           LDR      R5,[R5, +R2, LSL #+2]
   \   0000005C   026196E7           LDR      R6,[R6, +R2, LSL #+2]
   \   00000060   ........           LDR      R7,[R9], #+4
   \   00000064   012082E2           ADD      R2,R2,#+1
   \   00000068   10908DE5           STR      R9,[SP, #+16]
    144              for (col = 0; col < num_cols; col++) {
   \   0000006C   0080A0E3           MOV      R8,#+0
   \   00000070   000050E3           CMP      R0,#+0
   \   00000074   F0FFFF0A           BEQ      ??ycc_rgb_convert_0
   \                     ??ycc_rgb_convert_2:
   \   00000078   000058E1           CMP      R8,R0
   \   0000007C   EEFFFF2A           BCS      ??ycc_rgb_convert_0
    145                y  = GETJSAMPLE(inptr0[col]);
    146                cb = GETJSAMPLE(inptr1[col]);
    147                cr = GETJSAMPLE(inptr2[col]);
   \   00000080   06B0D8E7           LDRB     R11,[R8, +R6]
   \   00000084   0490D8E7           LDRB     R9,[R8, +R4]
    148                /* Range-limiting is essential due to noise introduced by DCT losses. */
    149                outptr[RGB_RED] =   range_limit[y + Crrtab[cr]];
   \   00000088   00E09DE5           LDR      LR,[SP, #+0]
   \   0000008C   05A0D8E7           LDRB     R10,[R8, +R5]
   \   00000090   0BE19EE7           LDR      LR,[LR, +R11, LSL #+2]
    150                outptr[RGB_GREEN] = range_limit[y +
    151          			      ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
    152          						 SCALEBITS))];
    153                outptr[RGB_BLUE] =  range_limit[y + Cbbtab[cb]];
    154                outptr += RGB_PIXELSIZE;
    155              }
   \   00000094   018088E2           ADD      R8,R8,#+1
   \   00000098   09E08EE0           ADD      LR,LR,R9
   \   0000009C   03E0DEE7           LDRB     LR,[LR, +R3]
   \   000000A0   ........           STRB     LR,[R7], #+1
   \   000000A4   0CE09DE5           LDR      LR,[SP, #+12]
   \   000000A8   0AE19EE7           LDR      LR,[LR, +R10, LSL #+2]
   \   000000AC   00402DE9           PUSH     {LR}
   \   000000B0   0CE09DE5           LDR      LR,[SP, #+12]
   \   000000B4   0BB19EE7           LDR      R11,[LR, +R11, LSL #+2]
   \   000000B8   0040BDE8           POP      {LR}
   \   000000BC   0EB08BE0           ADD      R11,R11,LR
   \   000000C0   4BB889E0           ADD      R11,R9,R11, ASR #+16
   \   000000C4   03B0DBE7           LDRB     R11,[R11, +R3]
   \   000000C8   ........           STRB     R11,[R7], #+1
   \   000000CC   04B09DE5           LDR      R11,[SP, #+4]
   \   000000D0   0AA19BE7           LDR      R10,[R11, +R10, LSL #+2]
   \   000000D4   09908AE0           ADD      R9,R10,R9
   \   000000D8   0390D9E7           LDRB     R9,[R9, +R3]
   \   000000DC   ........           STRB     R9,[R7], #+1
   \   000000E0   E4FFFFEA           B        ??ycc_rgb_convert_2
    156            }
    157          }
   \                     ??ycc_rgb_convert_1:
   \   000000E4   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   000000E8   F08FBDE8           POP      {R4-R11,PC}      ;; return
    158          
    159          
    160          /**************** Cases other than YCbCr -> RGB **************/
    161          
    162          
    163          /*
    164           * Color conversion for no colorspace change: just copy the data,
    165           * converting from separate-planes to interleaved representation.
    166           */
    167          

   \                                 In segment CODE, align 4, keep-with-next
    168          METHODDEF(void)
    169          null_convert (j_decompress_ptr cinfo,
    170          	      JSAMPIMAGE input_buf, JDIMENSION input_row,
    171          	      JSAMPARRAY output_buf, int num_rows)
    172          {
   \                     null_convert:
   \   00000000   F0032DE9           PUSH     {R4-R9}
   \   00000004   18C09DE5           LDR      R12,[SP, #+24]
    173            register JSAMPROW inptr, outptr;
    174            register JDIMENSION count;
    175            register int num_components = cinfo->num_components;
   \   00000008   244090E5           LDR      R4,[R0, #+36]
    176            JDIMENSION num_cols = cinfo->output_width;
   \   0000000C   6C0090E5           LDR      R0,[R0, #+108]
   \   00000010   0F0000EA           B        ??null_convert_0
    177            int ci;
    178          
    179            while (--num_rows >= 0) {
    180              for (ci = 0; ci < num_components; ci++) {
    181                inptr = input_buf[ci][input_row];
   \                     ??null_convert_1:
   \   00000014   065191E7           LDR      R5,[R1, +R6, LSL #+2]
    182                outptr = output_buf[0] + ci;
   \   00000018   007093E5           LDR      R7,[R3, #+0]
   \   0000001C   025195E7           LDR      R5,[R5, +R2, LSL #+2]
   \   00000020   077086E0           ADD      R7,R6,R7
    183                for (count = num_cols; count > 0; count--) {
   \   00000024   0080B0E1           MOVS     R8,R0
   \   00000028   0400000A           BEQ      ??null_convert_2
    184          	*outptr = *inptr++;	/* needn't bother with GETJSAMPLE() here */
   \                     ??null_convert_3:
   \   0000002C   ........           LDRB     R9,[R5], #+1
    185          	outptr += num_components;
    186                }
   \   00000030   018058E2           SUBS     R8,R8,#+1
   \   00000034   0090C7E5           STRB     R9,[R7, #+0]
   \   00000038   077084E0           ADD      R7,R4,R7
   \   0000003C   FAFFFF1A           BNE      ??null_convert_3
    187              }
   \                     ??null_convert_2:
   \   00000040   016086E2           ADD      R6,R6,#+1
   \                     ??null_convert_4:
   \   00000044   040056E1           CMP      R6,R4
   \   00000048   F1FFFFBA           BLT      ??null_convert_1
    188              input_row++;
   \                     ??null_convert_5:
   \   0000004C   012082E2           ADD      R2,R2,#+1
    189              output_buf++;
   \   00000050   043083E2           ADD      R3,R3,#+4
   \                     ??null_convert_0:
   \   00000054   01C05CE2           SUBS     R12,R12,#+1
   \   00000058   0300004A           BMI      ??null_convert_6
   \   0000005C   0060A0E3           MOV      R6,#+0
   \   00000060   010054E3           CMP      R4,#+1
   \   00000064   F6FFFFAA           BGE      ??null_convert_4
   \   00000068   F7FFFFEA           B        ??null_convert_5
    190            }
    191          }
   \                     ??null_convert_6:
   \   0000006C   F003BDE8           POP      {R4-R9}
   \   00000070   1EFF2FE1           BX       LR               ;; return
    192          
    193          
    194          /*
    195           * Color conversion for grayscale: just copy the data.
    196           * This also works for YCbCr -> grayscale conversion, in which
    197           * we just copy the Y (luminance) component and ignore chrominance.
    198           */
    199          

   \                                 In segment CODE, align 4, keep-with-next
    200          METHODDEF(void)
    201          grayscale_convert (j_decompress_ptr cinfo,
    202          		   JSAMPIMAGE input_buf, JDIMENSION input_row,
    203          		   JSAMPARRAY output_buf, int num_rows)
    204          {
   \                     grayscale_convert:
   \   00000000   00402DE9           PUSH     {LR}
    205            jcopy_sample_rows(input_buf[0], (int) input_row, output_buf, 0,
    206          		    num_rows, cinfo->output_width);
   \   00000004   6C0090E5           LDR      R0,[R0, #+108]
   \   00000008   01C0A0E1           MOV      R12,R1
   \   0000000C   0210A0E1           MOV      R1,R2
   \   00000010   0320A0E1           MOV      R2,R3
   \   00000014   04309DE5           LDR      R3,[SP, #+4]
   \   00000018   01002DE9           PUSH     {R0}
   \   0000001C   08002DE9           PUSH     {R3}
   \   00000020   00009CE5           LDR      R0,[R12, #+0]
   \   00000024   0030A0E3           MOV      R3,#+0
   \   00000028   ........           _BLF     jcopy_sample_rows,??jcopy_sample_rows??rA
    207          }
   \   0000002C   0380BDE8           POP      {R0,R1,PC}       ;; return
    208          
    209          
    210          /*
    211           * Convert grayscale to RGB: just duplicate the graylevel three times.
    212           * This is provided to support applications that don't want to cope
    213           * with grayscale as a separate case.
    214           */
    215          

   \                                 In segment CODE, align 4, keep-with-next
    216          METHODDEF(void)
    217          gray_rgb_convert (j_decompress_ptr cinfo,
    218          		  JSAMPIMAGE input_buf, JDIMENSION input_row,
    219          		  JSAMPARRAY output_buf, int num_rows)
    220          {
   \                     gray_rgb_convert:
   \   00000000   F0002DE9           PUSH     {R4-R7}
   \   00000004   10C09DE5           LDR      R12,[SP, #+16]
    221            register JSAMPROW inptr, outptr;
    222            register JDIMENSION col;
    223            JDIMENSION num_cols = cinfo->output_width;
   \   00000008   6C0090E5           LDR      R0,[R0, #+108]
    224          
    225            while (--num_rows >= 0) {
   \                     ??gray_rgb_convert_0:
   \   0000000C   01C05CE2           SUBS     R12,R12,#+1
   \   00000010   0E00004A           BMI      ??gray_rgb_convert_1
    226              inptr = input_buf[0][input_row++];
   \   00000014   004091E5           LDR      R4,[R1, #+0]
    227              outptr = *output_buf++;
   \   00000018   ........           LDR      R5,[R3], #+4
   \   0000001C   024194E7           LDR      R4,[R4, +R2, LSL #+2]
   \   00000020   012082E2           ADD      R2,R2,#+1
    228              for (col = 0; col < num_cols; col++) {
   \   00000024   0060A0E3           MOV      R6,#+0
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   F6FFFF0A           BEQ      ??gray_rgb_convert_0
   \                     ??gray_rgb_convert_2:
   \   00000030   000056E1           CMP      R6,R0
   \   00000034   F4FFFF2A           BCS      ??gray_rgb_convert_0
    229                /* We can dispense with GETJSAMPLE() here */
    230                outptr[RGB_RED] = outptr[RGB_GREEN] = outptr[RGB_BLUE] = inptr[col];
   \   00000038   0470D6E7           LDRB     R7,[R6, +R4]
    231                outptr += RGB_PIXELSIZE;
    232              }
   \   0000003C   016086E2           ADD      R6,R6,#+1
   \   00000040   0270C5E5           STRB     R7,[R5, #+2]
   \   00000044   0170C5E5           STRB     R7,[R5, #+1]
   \   00000048   ........           STRB     R7,[R5], #+3
   \   0000004C   F7FFFFEA           B        ??gray_rgb_convert_2
    233            }
    234          }
   \                     ??gray_rgb_convert_1:
   \   00000050   F000BDE8           POP      {R4-R7}
   \   00000054   1EFF2FE1           BX       LR               ;; return
    235          
    236          
    237          /*
    238           * Adobe-style YCCK->CMYK conversion.
    239           * We convert YCbCr to R=1-C, G=1-M, and B=1-Y using the same
    240           * conversion as above, while passing K (black) unchanged.
    241           * We assume build_ycc_rgb_table has been called.
    242           */
    243          

   \                                 In segment CODE, align 4, keep-with-next
    244          METHODDEF(void)
    245          ycck_cmyk_convert (j_decompress_ptr cinfo,
    246          		   JSAMPIMAGE input_buf, JDIMENSION input_row,
    247          		   JSAMPARRAY output_buf, int num_rows)
    248          {
   \                     ycck_cmyk_convert:
   \   00000000   FA4F2DE9           PUSH     {R1,R3-R11,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
   \   00000008   3C309DE5           LDR      R3,[SP, #+60]
   \   0000000C   0010A0E1           MOV      R1,R0
    249            my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
   \   00000010   C84191E5           LDR      R4,[R1, #+456]
    250            register int y, cb, cr;
    251            register JSAMPROW outptr;
    252            register JSAMPROW inptr0, inptr1, inptr2, inptr3;
    253            register JDIMENSION col;
    254            JDIMENSION num_cols = cinfo->output_width;
   \   00000014   6C0091E5           LDR      R0,[R1, #+108]
    255            /* copy these pointers into registers if possible */
    256            register JSAMPLE * range_limit = cinfo->sample_range_limit;
    257            register int * Crrtab = cconvert->Cr_r_tab;
   \   00000018   086094E5           LDR      R6,[R4, #+8]
   \   0000001C   441191E5           LDR      R1,[R1, #+324]
   \   00000020   00608DE5           STR      R6,[SP, #+0]
    258            register int * Cbbtab = cconvert->Cb_b_tab;
   \   00000024   0C6094E5           LDR      R6,[R4, #+12]
   \   00000028   04608DE5           STR      R6,[SP, #+4]
    259            register INT32 * Crgtab = cconvert->Cr_g_tab;
   \   0000002C   106094E5           LDR      R6,[R4, #+16]
   \   00000030   08608DE5           STR      R6,[SP, #+8]
    260            register INT32 * Cbgtab = cconvert->Cb_g_tab;
   \   00000034   144094E5           LDR      R4,[R4, #+20]
   \   00000038   0C408DE5           STR      R4,[SP, #+12]
    261            SHIFT_TEMPS
    262          
    263            while (--num_rows >= 0) {
   \                     ??ycck_cmyk_convert_0:
   \   0000003C   013053E2           SUBS     R3,R3,#+1
   \   00000040   3000004A           BMI      ??ycck_cmyk_convert_1
    264              inptr0 = input_buf[0][input_row];
   \   00000044   10409DE5           LDR      R4,[SP, #+16]
    265              inptr1 = input_buf[1][input_row];
    266              inptr2 = input_buf[2][input_row];
   \   00000048   10509DE5           LDR      R5,[SP, #+16]
   \   0000004C   004094E5           LDR      R4,[R4, #+0]
    267              inptr3 = input_buf[3][input_row];
   \   00000050   10609DE5           LDR      R6,[SP, #+16]
   \   00000054   02C194E7           LDR      R12,[R4, +R2, LSL #+2]
   \   00000058   10409DE5           LDR      R4,[SP, #+16]
   \   0000005C   085095E5           LDR      R5,[R5, #+8]
   \   00000060   044094E5           LDR      R4,[R4, #+4]
   \   00000064   0C6096E5           LDR      R6,[R6, #+12]
    268              input_row++;
    269              outptr = *output_buf++;
   \   00000068   14909DE5           LDR      R9,[SP, #+20]
   \   0000006C   024194E7           LDR      R4,[R4, +R2, LSL #+2]
   \   00000070   025195E7           LDR      R5,[R5, +R2, LSL #+2]
   \   00000074   026196E7           LDR      R6,[R6, +R2, LSL #+2]
   \   00000078   ........           LDR      R7,[R9], #+4
   \   0000007C   012082E2           ADD      R2,R2,#+1
   \   00000080   14908DE5           STR      R9,[SP, #+20]
    270              for (col = 0; col < num_cols; col++) {
   \   00000084   0080A0E3           MOV      R8,#+0
   \   00000088   000050E3           CMP      R0,#+0
   \   0000008C   EAFFFF0A           BEQ      ??ycck_cmyk_convert_0
   \                     ??ycck_cmyk_convert_2:
   \   00000090   000058E1           CMP      R8,R0
   \   00000094   E8FFFF2A           BCS      ??ycck_cmyk_convert_0
    271                y  = GETJSAMPLE(inptr0[col]);
    272                cb = GETJSAMPLE(inptr1[col]);
    273                cr = GETJSAMPLE(inptr2[col]);
   \   00000098   05A0D8E7           LDRB     R10,[R8, +R5]
   \   0000009C   0CB0D8E7           LDRB     R11,[R8, +R12]
    274                /* Range-limiting is essential due to noise introduced by DCT losses. */
    275                outptr[0] = range_limit[MAXJSAMPLE - (y + Crrtab[cr])];	/* red */
   \   000000A0   00E09DE5           LDR      LR,[SP, #+0]
   \   000000A4   0490D8E7           LDRB     R9,[R8, +R4]
   \   000000A8   0AE19EE7           LDR      LR,[LR, +R10, LSL #+2]
   \   000000AC   FFB06BE2           RSB      R11,R11,#+255
   \   000000B0   0EE04BE0           SUB      LR,R11,LR
   \   000000B4   01E0DEE7           LDRB     LR,[LR, +R1]
   \   000000B8   ........           STRB     LR,[R7], #+1
    276                outptr[1] = range_limit[MAXJSAMPLE - (y +			/* green */
    277          			      ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
    278          						 SCALEBITS)))];
   \   000000BC   0CE09DE5           LDR      LR,[SP, #+12]
   \   000000C0   09E19EE7           LDR      LR,[LR, +R9, LSL #+2]
   \   000000C4   00402DE9           PUSH     {LR}
   \   000000C8   0CE09DE5           LDR      LR,[SP, #+12]
   \   000000CC   0AA19EE7           LDR      R10,[LR, +R10, LSL #+2]
   \   000000D0   0040BDE8           POP      {LR}
   \   000000D4   0EA08AE0           ADD      R10,R10,LR
   \   000000D8   4AA84BE0           SUB      R10,R11,R10, ASR #+16
   \   000000DC   01A0DAE7           LDRB     R10,[R10, +R1]
   \   000000E0   ........           STRB     R10,[R7], #+1
    279                outptr[2] = range_limit[MAXJSAMPLE - (y + Cbbtab[cb])];	/* blue */
   \   000000E4   04A09DE5           LDR      R10,[SP, #+4]
   \   000000E8   09919AE7           LDR      R9,[R10, +R9, LSL #+2]
   \   000000EC   09904BE0           SUB      R9,R11,R9
   \   000000F0   0190D9E7           LDRB     R9,[R9, +R1]
   \   000000F4   ........           STRB     R9,[R7], #+1
    280                /* K passes through unchanged */
    281                outptr[3] = inptr3[col];	/* don't need GETJSAMPLE here */
   \   000000F8   0690D8E7           LDRB     R9,[R8, +R6]
    282                outptr += 4;
    283              }
   \   000000FC   018088E2           ADD      R8,R8,#+1
   \   00000100   ........           STRB     R9,[R7], #+1
   \   00000104   E1FFFFEA           B        ??ycck_cmyk_convert_2
    284            }
    285          }
   \                     ??ycck_cmyk_convert_1:
   \   00000108   18D08DE2           ADD      SP,SP,#+24       ;; stack cleaning
   \   0000010C   F08FBDE8           POP      {R4-R11,PC}      ;; return
    286          
    287          
    288          /*
    289           * Empty method for start_pass.
    290           */
    291          

   \                                 In segment CODE, align 4, keep-with-next
    292          METHODDEF(void)
    293          start_pass_dcolor (j_decompress_ptr cinfo)
    294          {
    295            /* no work needed */
    296          }
   \                     start_pass_dcolor:
   \   00000000   1EFF2FE1           BX       LR               ;; return
    297          
    298          
    299          /*
    300           * Module initialization routine for output colorspace conversion.
    301           */
    302          

   \                                 In segment CODE, align 4, keep-with-next
    303          GLOBAL(void)
    304          jinit_color_deconverter (j_decompress_ptr cinfo)
    305          {
   \                     jinit_color_deconverter:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    306            my_cconvert_ptr cconvert;
    307            int ci;
    308          
    309            cconvert = (my_cconvert_ptr)
    310              (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
    311          				SIZEOF(my_color_deconverter));
   \   00000004   1820A0E3           MOV      R2,#+24
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   043094E5           LDR      R3,[R4, #+4]
   \   00000010   0110A0E3           MOV      R1,#+1
   \   00000014   003093E5           LDR      R3,[R3, #+0]
   \   00000018   33FF2FE1           BLX      R3
   \   0000001C   0050A0E1           MOV      R5,R0
    312            cinfo->cconvert = (struct jpeg_color_deconverter *) cconvert;
    313            cconvert->pub.start_pass = start_pass_dcolor;
   \   00000020   A4019FE5           LDR      R0,??jinit_color_deconverter_0  ;; start_pass_dcolor
   \   00000024   C85184E5           STR      R5,[R4, #+456]
   \   00000028   000085E5           STR      R0,[R5, #+0]
    314          
    315            /* Make sure num_components agrees with jpeg_color_space */
    316            switch (cinfo->jpeg_color_space) {
   \   0000002C   2800D4E5           LDRB     R0,[R4, #+40]
   \   00000030   010050E2           SUBS     R0,R0,#+1
   \   00000034   0600000A           BEQ      ??jinit_color_deconverter_1
   \   00000038   010040E2           SUB      R0,R0,#+1
   \   0000003C   010050E3           CMP      R0,#+1
   \   00000040   0E00009A           BLS      ??jinit_color_deconverter_2
   \   00000044   020040E2           SUB      R0,R0,#+2
   \   00000048   010050E3           CMP      R0,#+1
   \   0000004C   0F00009A           BLS      ??jinit_color_deconverter_3
   \   00000050   110000EA           B        ??jinit_color_deconverter_4
    317            case JCS_GRAYSCALE:
    318              if (cinfo->num_components != 1)
   \                     ??jinit_color_deconverter_1:
   \   00000054   240094E5           LDR      R0,[R4, #+36]
   \   00000058   010050E3           CMP      R0,#+1
   \   0000005C   1100000A           BEQ      ??jinit_color_deconverter_5
    319                ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
   \                     ??jinit_color_deconverter_6:
   \   00000060   000094E5           LDR      R0,[R4, #+0]
   \   00000064   0B10A0E3           MOV      R1,#+11
   \   00000068   141080E5           STR      R1,[R0, #+20]
   \   0000006C   001094E5           LDR      R1,[R4, #+0]
   \   00000070   0400A0E1           MOV      R0,R4
   \   00000074   001091E5           LDR      R1,[R1, #+0]
   \   00000078   31FF2FE1           BLX      R1
   \   0000007C   090000EA           B        ??jinit_color_deconverter_5
    320              break;
    321          
    322            case JCS_RGB:
    323            case JCS_YCbCr:
    324              if (cinfo->num_components != 3)
   \                     ??jinit_color_deconverter_2:
   \   00000080   240094E5           LDR      R0,[R4, #+36]
   \   00000084   030050E3           CMP      R0,#+3
   \                     ??jinit_color_deconverter_7:
   \   00000088   F4FFFF1A           BNE      ??jinit_color_deconverter_6
   \   0000008C   050000EA           B        ??jinit_color_deconverter_5
    325                ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    326              break;
    327          
    328            case JCS_CMYK:
    329            case JCS_YCCK:
    330              if (cinfo->num_components != 4)
   \                     ??jinit_color_deconverter_3:
   \   00000090   240094E5           LDR      R0,[R4, #+36]
   \   00000094   040050E3           CMP      R0,#+4
   \   00000098   FAFFFFEA           B        ??jinit_color_deconverter_7
    331                ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    332              break;
    333          
    334            default:			/* JCS_UNKNOWN can be anything */
    335              if (cinfo->num_components < 1)
   \                     ??jinit_color_deconverter_4:
   \   0000009C   240094E5           LDR      R0,[R4, #+36]
   \   000000A0   010050E3           CMP      R0,#+1
   \   000000A4   EDFFFFBA           BLT      ??jinit_color_deconverter_6
    336                ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    337              break;
    338            }
    339          
    340            /* Set out_color_components and conversion method based on requested space.
    341             * Also clear the component_needed flags for any unused components,
    342             * so that earlier pipeline stages can avoid useless computation.
    343             */
    344          
    345            switch (cinfo->out_color_space) {
   \                     ??jinit_color_deconverter_5:
   \   000000A8   2910D4E5           LDRB     R1,[R4, #+41]
   \   000000AC   2800D4E5           LDRB     R0,[R4, #+40]
   \   000000B0   18219FE5           LDR      R2,??jinit_color_deconverter_0+0x4  ;; null_convert
   \   000000B4   013051E2           SUBS     R3,R1,#+1
   \   000000B8   0400000A           BEQ      ??jinit_color_deconverter_8
   \   000000BC   013053E2           SUBS     R3,R3,#+1
   \   000000C0   1700000A           BEQ      ??jinit_color_deconverter_9
   \   000000C4   023053E2           SUBS     R3,R3,#+2
   \   000000C8   2500000A           BEQ      ??jinit_color_deconverter_10
   \   000000CC   330000EA           B        ??jinit_color_deconverter_11
    346            case JCS_GRAYSCALE:
    347              cinfo->out_color_components = 1;
   \                     ??jinit_color_deconverter_8:
   \   000000D0   0110A0E3           MOV      R1,#+1
   \   000000D4   741084E5           STR      R1,[R4, #+116]
    348              if (cinfo->jpeg_color_space == JCS_GRAYSCALE ||
    349          	cinfo->jpeg_color_space == JCS_YCbCr) {
   \   000000D8   010050E3           CMP      R0,#+1
   \   000000DC   03005013           CMPNE    R0,#+3
   \   000000E0   2600001A           BNE      ??jinit_color_deconverter_12
    350                cconvert->pub.color_convert = grayscale_convert;
   \   000000E4   E8009FE5           LDR      R0,??jinit_color_deconverter_0+0x8  ;; grayscale_convert
   \   000000E8   040085E5           STR      R0,[R5, #+4]
    351                /* For color->grayscale conversion, only the Y (0) component is needed */
    352                for (ci = 1; ci < cinfo->num_components; ci++)
   \   000000EC   241094E5           LDR      R1,[R4, #+36]
   \   000000F0   0100A0E3           MOV      R0,#+1
   \   000000F4   020051E3           CMP      R1,#+2
   \   000000F8   2D0000BA           BLT      ??jinit_color_deconverter_13
   \                     ??jinit_color_deconverter_14:
   \   000000FC   241094E5           LDR      R1,[R4, #+36]
   \   00000100   010050E1           CMP      R0,R1
   \   00000104   2A0000AA           BGE      ??jinit_color_deconverter_13
    353          	cinfo->comp_info[ci].component_needed = FALSE;
   \   00000108   D42094E5           LDR      R2,[R4, #+212]
   \   0000010C   5810A0E3           MOV      R1,#+88
   \   00000110   912022E0           MLA      R2,R1,R0,R2
   \   00000114   0010A0E3           MOV      R1,#+0
   \   00000118   341082E5           STR      R1,[R2, #+52]
   \   0000011C   010080E2           ADD      R0,R0,#+1
   \   00000120   F5FFFFEA           B        ??jinit_color_deconverter_14
    354              } else
    355                ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    356              break;
    357          
    358            case JCS_RGB:
    359              cinfo->out_color_components = RGB_PIXELSIZE;
   \                     ??jinit_color_deconverter_9:
   \   00000124   0310A0E3           MOV      R1,#+3
   \   00000128   741084E5           STR      R1,[R4, #+116]
    360              if (cinfo->jpeg_color_space == JCS_YCbCr) {
   \   0000012C   030050E3           CMP      R0,#+3
   \   00000130   0400001A           BNE      ??jinit_color_deconverter_15
    361                cconvert->pub.color_convert = ycc_rgb_convert;
   \   00000134   9C009FE5           LDR      R0,??jinit_color_deconverter_0+0xC  ;; ycc_rgb_convert
   \                     ??jinit_color_deconverter_16:
   \   00000138   040085E5           STR      R0,[R5, #+4]
    362                build_ycc_rgb_table(cinfo);
   \   0000013C   0400A0E1           MOV      R0,R4
   \   00000140   ........           BL       build_ycc_rgb_table
   \   00000144   1A0000EA           B        ??jinit_color_deconverter_13
    363              } else if (cinfo->jpeg_color_space == JCS_GRAYSCALE) {
   \                     ??jinit_color_deconverter_15:
   \   00000148   010050E3           CMP      R0,#+1
    364                cconvert->pub.color_convert = gray_rgb_convert;
   \   0000014C   88009F05           LDREQ    R0,??jinit_color_deconverter_0+0x10  ;; gray_rgb_convert
   \   00000150   04008505           STREQ    R0,[R5, #+4]
   \   00000154   1600000A           BEQ      ??jinit_color_deconverter_13
    365              } else if (cinfo->jpeg_color_space == JCS_RGB && RGB_PIXELSIZE == 3) {
   \   00000158   020050E3           CMP      R0,#+2
   \   0000015C   0700001A           BNE      ??jinit_color_deconverter_12
    366                cconvert->pub.color_convert = null_convert;
   \   00000160   120000EA           B        ??jinit_color_deconverter_17
    367              } else
    368                ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    369              break;
    370          
    371            case JCS_CMYK:
    372              cinfo->out_color_components = 4;
   \                     ??jinit_color_deconverter_10:
   \   00000164   0410A0E3           MOV      R1,#+4
   \   00000168   741084E5           STR      R1,[R4, #+116]
    373              if (cinfo->jpeg_color_space == JCS_YCCK) {
   \   0000016C   050050E3           CMP      R0,#+5
    374                cconvert->pub.color_convert = ycck_cmyk_convert;
   \   00000170   68009F05           LDREQ    R0,??jinit_color_deconverter_0+0x14  ;; ycck_cmyk_convert
   \   00000174   EFFFFF0A           BEQ      ??jinit_color_deconverter_16
    375                build_ycc_rgb_table(cinfo);
    376              } else if (cinfo->jpeg_color_space == JCS_CMYK) {
   \   00000178   040050E3           CMP      R0,#+4
   \   0000017C   0B00000A           BEQ      ??jinit_color_deconverter_17
   \                     ??jinit_color_deconverter_12:
   \   00000180   000094E5           LDR      R0,[R4, #+0]
   \   00000184   1C10A0E3           MOV      R1,#+28
   \   00000188   141080E5           STR      R1,[R0, #+20]
   \   0000018C   001094E5           LDR      R1,[R4, #+0]
   \   00000190   0400A0E1           MOV      R0,R4
   \   00000194   001091E5           LDR      R1,[R1, #+0]
   \   00000198   31FF2FE1           BLX      R1
   \   0000019C   040000EA           B        ??jinit_color_deconverter_13
    377                cconvert->pub.color_convert = null_convert;
    378              } else
    379                ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    380              break;
    381          
    382            default:
    383              /* Permit null conversion to same output space */
    384              if (cinfo->out_color_space == cinfo->jpeg_color_space) {
   \                     ??jinit_color_deconverter_11:
   \   000001A0   000051E1           CMP      R1,R0
   \   000001A4   F5FFFF1A           BNE      ??jinit_color_deconverter_12
    385                cinfo->out_color_components = cinfo->num_components;
   \   000001A8   240094E5           LDR      R0,[R4, #+36]
   \   000001AC   740084E5           STR      R0,[R4, #+116]
    386                cconvert->pub.color_convert = null_convert;
   \                     ??jinit_color_deconverter_17:
   \   000001B0   042085E5           STR      R2,[R5, #+4]
    387              } else			/* unsupported non-null conversion */
    388                ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    389              break;
    390            }
    391          
    392            if (cinfo->quantize_colors)
   \                     ??jinit_color_deconverter_13:
   \   000001B4   500094E5           LDR      R0,[R4, #+80]
   \   000001B8   000050E3           CMP      R0,#+0
    393              cinfo->output_components = 1; /* single colormapped output component */
    394            else
    395              cinfo->output_components = cinfo->out_color_components;
   \   000001BC   74009405           LDREQ    R0,[R4, #+116]
   \   000001C0   0100A013           MOVNE    R0,#+1
   \   000001C4   780084E5           STR      R0,[R4, #+120]
    396          }
   \   000001C8   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??jinit_color_deconverter_0:
   \   000001CC   ........           DC32     start_pass_dcolor
   \   000001D0   ........           DC32     null_convert
   \   000001D4   ........           DC32     grayscale_convert
   \   000001D8   ........           DC32     ycc_rgb_convert
   \   000001DC   ........           DC32     gray_rgb_convert
   \   000001E0   ........           DC32     ycck_cmyk_convert

   Maximum stack usage in bytes:

     Function                CSTACK
     --------                ------
     build_ycc_rgb_table        12
     gray_rgb_convert           16
     grayscale_convert          12
     jinit_color_deconverter    12
     null_convert               24
     start_pass_dcolor           0
     ycc_rgb_convert            60
     ycck_cmyk_convert          64


   Segment part sizes:

     Function/Label          Bytes
     --------------          -----
     build_ycc_rgb_table      248
     ycc_rgb_convert          236
     null_convert             116
     grayscale_convert         48
     gray_rgb_convert          88
     ycck_cmyk_convert        272
     start_pass_dcolor          4
     jinit_color_deconverter  484
      Others                   44

 
 1 540 bytes in segment CODE
 
 1 496 bytes of CODE memory (+ 44 bytes shared)

Errors: none
Warnings: 1
