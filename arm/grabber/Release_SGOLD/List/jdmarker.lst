##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    19/Jan/2011  13:21:11 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\grabber\jpeg-7\jdmarker.c                     #
#    Command line    =  C:\arm\grabber\jpeg-7\jdmarker.c -lC                 #
#                       C:\arm\grabber\Release_SGOLD\List\ -o                #
#                       C:\arm\grabber\Release_SGOLD\Obj\ -s9 --no_unroll    #
#                       --no_clustering --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --fpu None --dlib_config "C:\arm2\Embedded           #
#                       Workbench 4.0 Evaluation\ARM\LIB\dl5tpainl8n.h" -I   #
#                       "C:\arm2\Embedded Workbench 4.0                      #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  C:\arm\grabber\Release_SGOLD\List\jdmarker.lst       #
#    Object file     =  C:\arm\grabber\Release_SGOLD\Obj\jdmarker.r79        #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\grabber\jpeg-7\jdmarker.c
      1          /*
                  ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           * jdmarker.c
      3           *
      4           * Copyright (C) 1991-1998, Thomas G. Lane.
      5           * This file is part of the Independent JPEG Group's software.
      6           * For conditions of distribution and use, see the accompanying README file.
      7           *
      8           * This file contains routines to decode JPEG datastream markers.
      9           * Most of the complexity arises from our desire to support input
     10           * suspension: if not all of the data for a marker is available,
     11           * we must exit back to the application.  On resumption, we reprocess
     12           * the marker.
     13           */
     14          
     15          #define JPEG_INTERNALS
     16          #include "jinclude.h"
     17          #include "jpeglib.h"
     18          
     19          
     20          typedef enum {			/* JPEG marker codes */
     21            M_SOF0  = 0xc0,
     22            M_SOF1  = 0xc1,
     23            M_SOF2  = 0xc2,
     24            M_SOF3  = 0xc3,
     25            
     26            M_SOF5  = 0xc5,
     27            M_SOF6  = 0xc6,
     28            M_SOF7  = 0xc7,
     29            
     30            M_JPG   = 0xc8,
     31            M_SOF9  = 0xc9,
     32            M_SOF10 = 0xca,
     33            M_SOF11 = 0xcb,
     34            
     35            M_SOF13 = 0xcd,
     36            M_SOF14 = 0xce,
     37            M_SOF15 = 0xcf,
     38            
     39            M_DHT   = 0xc4,
     40            
     41            M_DAC   = 0xcc,
     42            
     43            M_RST0  = 0xd0,
     44            M_RST1  = 0xd1,
     45            M_RST2  = 0xd2,
     46            M_RST3  = 0xd3,
     47            M_RST4  = 0xd4,
     48            M_RST5  = 0xd5,
     49            M_RST6  = 0xd6,
     50            M_RST7  = 0xd7,
     51            
     52            M_SOI   = 0xd8,
     53            M_EOI   = 0xd9,
     54            M_SOS   = 0xda,
     55            M_DQT   = 0xdb,
     56            M_DNL   = 0xdc,
     57            M_DRI   = 0xdd,
     58            M_DHP   = 0xde,
     59            M_EXP   = 0xdf,
     60            
     61            M_APP0  = 0xe0,
     62            M_APP1  = 0xe1,
     63            M_APP2  = 0xe2,
     64            M_APP3  = 0xe3,
     65            M_APP4  = 0xe4,
     66            M_APP5  = 0xe5,
     67            M_APP6  = 0xe6,
     68            M_APP7  = 0xe7,
     69            M_APP8  = 0xe8,
     70            M_APP9  = 0xe9,
     71            M_APP10 = 0xea,
     72            M_APP11 = 0xeb,
     73            M_APP12 = 0xec,
     74            M_APP13 = 0xed,
     75            M_APP14 = 0xee,
     76            M_APP15 = 0xef,
     77            
     78            M_JPG0  = 0xf0,
     79            M_JPG13 = 0xfd,
     80            M_COM   = 0xfe,
     81            
     82            M_TEM   = 0x01,
     83            
     84            M_ERROR = 0x100
     85          } JPEG_MARKER;
     86          
     87          
     88          /* Private state */
     89          
     90          typedef struct {
     91            struct jpeg_marker_reader pub; /* public fields */
     92          
     93            /* Application-overridable marker processing methods */
     94            jpeg_marker_parser_method process_COM;
     95            jpeg_marker_parser_method process_APPn[16];
     96          
     97            /* Limit on marker data length to save for each marker type */
     98            unsigned int length_limit_COM;
     99            unsigned int length_limit_APPn[16];
    100          
    101            /* Status of COM/APPn marker saving */
    102            jpeg_saved_marker_ptr cur_marker;	/* NULL if not processing a marker */
    103            unsigned int bytes_read;		/* data bytes read so far in marker */
    104            /* Note: cur_marker is not linked into marker_list until it's all read. */
    105          } my_marker_reader;
    106          
    107          typedef my_marker_reader * my_marker_ptr;
    108          
    109          
    110          /*
    111           * Macros for fetching data from the data source module.
    112           *
    113           * At all times, cinfo->src->next_input_byte and ->bytes_in_buffer reflect
    114           * the current restart point; we update them only when we have reached a
    115           * suitable place to restart if a suspension occurs.
    116           */
    117          
    118          /* Declare and initialize local copies of input pointer/count */
    119          #define INPUT_VARS(cinfo)  \
    120          	struct jpeg_source_mgr * datasrc = (cinfo)->src;  \
    121          	const JOCTET * next_input_byte = datasrc->next_input_byte;  \
    122          	size_t bytes_in_buffer = datasrc->bytes_in_buffer
    123          
    124          /* Unload the local copies --- do this only at a restart boundary */
    125          #define INPUT_SYNC(cinfo)  \
    126          	( datasrc->next_input_byte = next_input_byte,  \
    127          	  datasrc->bytes_in_buffer = bytes_in_buffer )
    128          
    129          /* Reload the local copies --- used only in MAKE_BYTE_AVAIL */
    130          #define INPUT_RELOAD(cinfo)  \
    131          	( next_input_byte = datasrc->next_input_byte,  \
    132          	  bytes_in_buffer = datasrc->bytes_in_buffer )
    133          
    134          /* Internal macro for INPUT_BYTE and INPUT_2BYTES: make a byte available.
    135           * Note we do *not* do INPUT_SYNC before calling fill_input_buffer,
    136           * but we must reload the local copies after a successful fill.
    137           */
    138          #define MAKE_BYTE_AVAIL(cinfo,action)  \
    139          	if (bytes_in_buffer == 0) {  \
    140          	  if (! (*datasrc->fill_input_buffer) (cinfo))  \
    141          	    { action; }  \
    142          	  INPUT_RELOAD(cinfo);  \
    143          	}
    144          
    145          /* Read a byte into variable V.
    146           * If must suspend, take the specified action (typically "return FALSE").
    147           */
    148          #define INPUT_BYTE(cinfo,V,action)  \
    149          	MAKESTMT( MAKE_BYTE_AVAIL(cinfo,action); \
    150          		  bytes_in_buffer--; \
    151          		  V = GETJOCTET(*next_input_byte++); )
    152          
    153          /* As above, but read two bytes interpreted as an unsigned 16-bit integer.
    154           * V should be declared unsigned int or perhaps INT32.
    155           */
    156          #define INPUT_2BYTES(cinfo,V,action)  \
    157          	MAKESTMT( MAKE_BYTE_AVAIL(cinfo,action); \
    158          		  bytes_in_buffer--; \
    159          		  V = ((unsigned int) GETJOCTET(*next_input_byte++)) << 8; \
    160          		  MAKE_BYTE_AVAIL(cinfo,action); \
    161          		  bytes_in_buffer--; \
    162          		  V += GETJOCTET(*next_input_byte++); )
    163          
    164          
    165          /*
    166           * Routines to process JPEG markers.
    167           *
    168           * Entry condition: JPEG marker itself has been read and its code saved
    169           *   in cinfo->unread_marker; input restart point is just after the marker.
    170           *
    171           * Exit: if return TRUE, have read and processed any parameters, and have
    172           *   updated the restart point to point after the parameters.
    173           *   If return FALSE, was forced to suspend before reaching end of
    174           *   marker parameters; restart point has not been moved.  Same routine
    175           *   will be called again after application supplies more input data.
    176           *
    177           * This approach to suspension assumes that all of a marker's parameters
    178           * can fit into a single input bufferload.  This should hold for "normal"
    179           * markers.  Some COM/APPn markers might have large parameter segments
    180           * that might not fit.  If we are simply dropping such a marker, we use
    181           * skip_input_data to get past it, and thereby put the problem on the
    182           * source manager's shoulders.  If we are saving the marker's contents
    183           * into memory, we use a slightly different convention: when forced to
    184           * suspend, the marker processor updates the restart point to the end of
    185           * what it's consumed (ie, the end of the buffer) before returning FALSE.
    186           * On resumption, cinfo->unread_marker still contains the marker code,
    187           * but the data source will point to the next chunk of marker data.
    188           * The marker processor must retain internal state to deal with this.
    189           *
    190           * Note that we don't bother to avoid duplicate trace messages if a
    191           * suspension occurs within marker parameters.  Other side effects
    192           * require more care.
    193           */
    194          
    195          

   \                                 In segment CODE, align 4, keep-with-next
    196          LOCAL(boolean)
    197          get_soi (j_decompress_ptr cinfo)
    198          /* Process an SOI marker */
    199          {
   \                     get_soi:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    200            int i;
    201            
    202            TRACEMS(cinfo, 1, JTRC_SOI);
   \   00000004   6810A0E3           MOV      R1,#+104
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   000094E5           LDR      R0,[R4, #+0]
   \   00000010   475F84E2           ADD      R5,R4,#+284
   \   00000014   141080E5           STR      R1,[R0, #+20]
   \   00000018   002094E5           LDR      R2,[R4, #+0]
   \   0000001C   0110A0E3           MOV      R1,#+1
   \   00000020   042092E5           LDR      R2,[R2, #+4]
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   32FF2FE1           BLX      R2
   \   0000002C   9C0095E5           LDR      R0,[R5, #+156]
   \   00000030   0C0090E5           LDR      R0,[R0, #+12]
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   0700000A           BEQ      ??get_soi_0
    203          
    204            if (cinfo->marker->saw_SOI)
    205              ERREXIT(cinfo, JERR_SOI_DUPLICATE);
   \   0000003C   000094E5           LDR      R0,[R4, #+0]
   \   00000040   3F10A0E3           MOV      R1,#+63
   \   00000044   141080E5           STR      R1,[R0, #+20]
   \   00000048   001094E5           LDR      R1,[R4, #+0]
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   001091E5           LDR      R1,[R1, #+0]
   \   00000054   31FF2FE1           BLX      R1
    206          
    207            /* Reset all parameters that are defined to be reset by SOI */
    208          
    209            for (i = 0; i < NUM_ARITH_TBLS; i++) {
   \   00000058   0000A0E3           MOV      R0,#+0
    210              cinfo->arith_dc_L[i] = 0;
   \                     ??get_soi_0:
   \   0000005C   0010A0E3           MOV      R1,#+0
   \   00000060   042080E0           ADD      R2,R0,R4
   \   00000064   E010C2E5           STRB     R1,[R2, #+224]
    211              cinfo->arith_dc_U[i] = 1;
   \   00000068   0120A0E3           MOV      R2,#+1
   \   0000006C   043080E0           ADD      R3,R0,R4
   \   00000070   F020C3E5           STRB     R2,[R3, #+240]
    212              cinfo->arith_ac_K[i] = 5;
   \   00000074   05C0A0E3           MOV      R12,#+5
   \   00000078   00C1C3E5           STRB     R12,[R3, #+256]
    213            }
   \   0000007C   010080E2           ADD      R0,R0,#+1
   \   00000080   100050E3           CMP      R0,#+16
   \   00000084   F4FFFFBA           BLT      ??get_soi_0
    214            cinfo->restart_interval = 0;
   \   00000088   101184E5           STR      R1,[R4, #+272]
    215          
    216            /* Set initial assumptions for colorspace etc */
    217          
    218            cinfo->jpeg_color_space = JCS_UNKNOWN;
   \   0000008C   2810C4E5           STRB     R1,[R4, #+40]
    219            cinfo->CCIR601_sampling = FALSE; /* Assume non-CCIR sampling??? */
   \   00000090   0C1085E5           STR      R1,[R5, #+12]
    220          
    221            cinfo->saw_JFIF_marker = FALSE;
   \   00000094   141184E5           STR      R1,[R4, #+276]
    222            cinfo->JFIF_major_version = 1; /* set default JFIF APP0 values */
   \   00000098   1821C4E5           STRB     R2,[R4, #+280]
    223            cinfo->JFIF_minor_version = 1;
   \   0000009C   1921C4E5           STRB     R2,[R4, #+281]
    224            cinfo->density_unit = 0;
   \   000000A0   1A11C4E5           STRB     R1,[R4, #+282]
    225            cinfo->X_density = 1;
   \   000000A4   B020C5E1           STRH     R2,[R5, #+0]
    226            cinfo->Y_density = 1;
   \   000000A8   B220C5E1           STRH     R2,[R5, #+2]
    227            cinfo->saw_Adobe_marker = FALSE;
   \   000000AC   041085E5           STR      R1,[R5, #+4]
    228            cinfo->Adobe_transform = 0;
   \   000000B0   0810C5E5           STRB     R1,[R5, #+8]
    229          
    230            cinfo->marker->saw_SOI = TRUE;
   \   000000B4   9C0095E5           LDR      R0,[R5, #+156]
   \   000000B8   0C2080E5           STR      R2,[R0, #+12]
    231          
    232            return TRUE;
   \   000000BC   0100A0E3           MOV      R0,#+1
   \   000000C0   3080BDE8           POP      {R4,R5,PC}       ;; return
    233          }
    234          
    235          

   \                                 In segment CODE, align 4, keep-with-next
    236          LOCAL(boolean)
    237          get_sof (j_decompress_ptr cinfo, boolean is_prog, boolean is_arith)
    238          /* Process a SOFn marker */
    239          {
   \                     get_sof:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    240            INT32 length;
    241            int c, ci;
    242            jpeg_component_info * compptr;
    243            INPUT_VARS(cinfo);
   \   00000008   185094E5           LDR      R5,[R4, #+24]
   \   0000000C   006095E5           LDR      R6,[R5, #+0]
   \   00000010   047095E5           LDR      R7,[R5, #+4]
    244          
    245            cinfo->progressive_mode = is_prog;
   \   00000014   D81084E5           STR      R1,[R4, #+216]
    246            cinfo->arith_code = is_arith;
   \   00000018   DC2084E5           STR      R2,[R4, #+220]
    247          
    248            INPUT_2BYTES(cinfo, length, return FALSE);
   \   0000001C   000057E3           CMP      R7,#+0
   \   00000020   0500001A           BNE      ??get_sof_0
   \   00000024   0C1095E5           LDR      R1,[R5, #+12]
   \   00000028   31FF2FE1           BLX      R1
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   F083BD08           POPEQ    {R4-R9,PC}
   \   00000034   006095E5           LDR      R6,[R5, #+0]
   \   00000038   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_sof_0:
   \   0000003C   ........           LDRB     R0,[R6], #+1
   \   00000040   017047E2           SUB      R7,R7,#+1
   \   00000044   000057E3           CMP      R7,#+0
   \   00000048   0084A0E1           LSL      R8,R0,#+8
   \   0000004C   0600001A           BNE      ??get_sof_1
   \   00000050   0C1095E5           LDR      R1,[R5, #+12]
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   31FF2FE1           BLX      R1
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   F083BD08           POPEQ    {R4-R9,PC}
   \   00000064   006095E5           LDR      R6,[R5, #+0]
   \   00000068   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_sof_1:
   \   0000006C   ........           LDRB     R0,[R6], #+1
   \   00000070   017047E2           SUB      R7,R7,#+1
    249          
    250            INPUT_BYTE(cinfo, cinfo->data_precision, return FALSE);
   \   00000074   000057E3           CMP      R7,#+0
   \   00000078   088080E0           ADD      R8,R0,R8
   \   0000007C   0600001A           BNE      ??get_sof_2
   \   00000080   0C1095E5           LDR      R1,[R5, #+12]
   \   00000084   0400A0E1           MOV      R0,R4
   \   00000088   31FF2FE1           BLX      R1
   \   0000008C   000050E3           CMP      R0,#+0
   \   00000090   F083BD08           POPEQ    {R4-R9,PC}
   \   00000094   006095E5           LDR      R6,[R5, #+0]
   \   00000098   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_sof_2:
   \   0000009C   ........           LDRB     R0,[R6], #+1
   \   000000A0   017057E2           SUBS     R7,R7,#+1
   \   000000A4   D00084E5           STR      R0,[R4, #+208]
    251            INPUT_2BYTES(cinfo, cinfo->image_height, return FALSE);
   \   000000A8   0600001A           BNE      ??get_sof_3
   \   000000AC   0C1095E5           LDR      R1,[R5, #+12]
   \   000000B0   0400A0E1           MOV      R0,R4
   \   000000B4   31FF2FE1           BLX      R1
   \   000000B8   000050E3           CMP      R0,#+0
   \   000000BC   F083BD08           POPEQ    {R4-R9,PC}
   \   000000C0   006095E5           LDR      R6,[R5, #+0]
   \   000000C4   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_sof_3:
   \   000000C8   ........           LDRB     R0,[R6], #+1
   \   000000CC   017047E2           SUB      R7,R7,#+1
   \   000000D0   000057E3           CMP      R7,#+0
   \   000000D4   0004A0E1           LSL      R0,R0,#+8
   \   000000D8   200084E5           STR      R0,[R4, #+32]
   \   000000DC   0600001A           BNE      ??get_sof_4
   \   000000E0   0C1095E5           LDR      R1,[R5, #+12]
   \   000000E4   0400A0E1           MOV      R0,R4
   \   000000E8   31FF2FE1           BLX      R1
   \   000000EC   000050E3           CMP      R0,#+0
   \   000000F0   F083BD08           POPEQ    {R4-R9,PC}
   \   000000F4   006095E5           LDR      R6,[R5, #+0]
   \   000000F8   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_sof_4:
   \   000000FC   ........           LDRB     R1,[R6], #+1
   \   00000100   200094E5           LDR      R0,[R4, #+32]
   \   00000104   017047E2           SUB      R7,R7,#+1
   \   00000108   000081E0           ADD      R0,R1,R0
   \   0000010C   200084E5           STR      R0,[R4, #+32]
    252            INPUT_2BYTES(cinfo, cinfo->image_width, return FALSE);
   \   00000110   000057E3           CMP      R7,#+0
   \   00000114   0600001A           BNE      ??get_sof_5
   \   00000118   0C1095E5           LDR      R1,[R5, #+12]
   \   0000011C   0400A0E1           MOV      R0,R4
   \   00000120   31FF2FE1           BLX      R1
   \   00000124   000050E3           CMP      R0,#+0
   \   00000128   F083BD08           POPEQ    {R4-R9,PC}
   \   0000012C   006095E5           LDR      R6,[R5, #+0]
   \   00000130   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_sof_5:
   \   00000134   ........           LDRB     R0,[R6], #+1
   \   00000138   017047E2           SUB      R7,R7,#+1
   \   0000013C   000057E3           CMP      R7,#+0
   \   00000140   0004A0E1           LSL      R0,R0,#+8
   \   00000144   1C0084E5           STR      R0,[R4, #+28]
   \   00000148   0600001A           BNE      ??get_sof_6
   \   0000014C   0C1095E5           LDR      R1,[R5, #+12]
   \   00000150   0400A0E1           MOV      R0,R4
   \   00000154   31FF2FE1           BLX      R1
   \   00000158   000050E3           CMP      R0,#+0
   \   0000015C   F083BD08           POPEQ    {R4-R9,PC}
   \   00000160   006095E5           LDR      R6,[R5, #+0]
   \   00000164   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_sof_6:
   \   00000168   ........           LDRB     R1,[R6], #+1
   \   0000016C   1C0094E5           LDR      R0,[R4, #+28]
   \   00000170   017047E2           SUB      R7,R7,#+1
   \   00000174   000081E0           ADD      R0,R1,R0
   \   00000178   1C0084E5           STR      R0,[R4, #+28]
    253            INPUT_BYTE(cinfo, cinfo->num_components, return FALSE);
   \   0000017C   000057E3           CMP      R7,#+0
   \   00000180   0600001A           BNE      ??get_sof_7
   \   00000184   0C1095E5           LDR      R1,[R5, #+12]
   \   00000188   0400A0E1           MOV      R0,R4
   \   0000018C   31FF2FE1           BLX      R1
   \   00000190   000050E3           CMP      R0,#+0
   \   00000194   F083BD08           POPEQ    {R4-R9,PC}
   \   00000198   006095E5           LDR      R6,[R5, #+0]
   \   0000019C   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_sof_7:
   \   000001A0   ........           LDRB     R0,[R6], #+1
   \   000001A4   017047E2           SUB      R7,R7,#+1
   \   000001A8   240084E5           STR      R0,[R4, #+36]
    254          
    255            length -= 8;
    256          
    257            TRACEMS4(cinfo, 1, JTRC_SOF, cinfo->unread_marker,
    258          	   (int) cinfo->image_width, (int) cinfo->image_height,
    259          	   cinfo->num_components);
   \   000001AC   000094E5           LDR      R0,[R4, #+0]
   \   000001B0   A01194E5           LDR      R1,[R4, #+416]
   \   000001B4   1810A0E5           STR      R1,[R0, #+24]!
   \   000001B8   1C1094E5           LDR      R1,[R4, #+28]
   \   000001BC   041080E5           STR      R1,[R0, #+4]
   \   000001C0   201094E5           LDR      R1,[R4, #+32]
   \   000001C4   081080E5           STR      R1,[R0, #+8]
   \   000001C8   241094E5           LDR      R1,[R4, #+36]
   \   000001CC   0C1080E5           STR      R1,[R0, #+12]
   \   000001D0   000094E5           LDR      R0,[R4, #+0]
   \   000001D4   6610A0E3           MOV      R1,#+102
   \   000001D8   141080E5           STR      R1,[R0, #+20]
   \   000001DC   002094E5           LDR      R2,[R4, #+0]
   \   000001E0   0110A0E3           MOV      R1,#+1
   \   000001E4   042092E5           LDR      R2,[R2, #+4]
   \   000001E8   0400A0E1           MOV      R0,R4
   \   000001EC   32FF2FE1           BLX      R2
    260          
    261            if (cinfo->marker->saw_SOF)
   \   000001F0   B80194E5           LDR      R0,[R4, #+440]
   \   000001F4   100090E5           LDR      R0,[R0, #+16]
   \   000001F8   000050E3           CMP      R0,#+0
   \   000001FC   0600000A           BEQ      ??get_sof_8
    262              ERREXIT(cinfo, JERR_SOF_DUPLICATE);
   \   00000200   000094E5           LDR      R0,[R4, #+0]
   \   00000204   3C10A0E3           MOV      R1,#+60
   \   00000208   141080E5           STR      R1,[R0, #+20]
   \   0000020C   001094E5           LDR      R1,[R4, #+0]
   \   00000210   0400A0E1           MOV      R0,R4
   \   00000214   001091E5           LDR      R1,[R1, #+0]
   \   00000218   31FF2FE1           BLX      R1
    263          
    264            /* We don't support files in which the image height is initially specified */
    265            /* as 0 and is later redefined by DNL.  As long as we have to check that,  */
    266            /* might as well have a general sanity check. */
    267            if (cinfo->image_height <= 0 || cinfo->image_width <= 0
    268                || cinfo->num_components <= 0)
   \                     ??get_sof_8:
   \   0000021C   200094E5           LDR      R0,[R4, #+32]
   \   00000220   000050E3           CMP      R0,#+0
   \   00000224   1C009415           LDRNE    R0,[R4, #+28]
   \   00000228   00005013           CMPNE    R0,#+0
   \   0000022C   0200000A           BEQ      ??get_sof_9
   \   00000230   240094E5           LDR      R0,[R4, #+36]
   \   00000234   010050E3           CMP      R0,#+1
   \   00000238   060000AA           BGE      ??get_sof_10
    269              ERREXIT(cinfo, JERR_EMPTY_IMAGE);
   \                     ??get_sof_9:
   \   0000023C   000094E5           LDR      R0,[R4, #+0]
   \   00000240   2110A0E3           MOV      R1,#+33
   \   00000244   141080E5           STR      R1,[R0, #+20]
   \   00000248   001094E5           LDR      R1,[R4, #+0]
   \   0000024C   0400A0E1           MOV      R0,R4
   \   00000250   001091E5           LDR      R1,[R1, #+0]
   \   00000254   31FF2FE1           BLX      R1
    270          
    271            if (length != (cinfo->num_components * 3))
   \                     ??get_sof_10:
   \   00000258   241094E5           LDR      R1,[R4, #+36]
   \   0000025C   080048E2           SUB      R0,R8,#+8
   \   00000260   811081E0           ADD      R1,R1,R1, LSL #+1
   \   00000264   010050E1           CMP      R0,R1
   \   00000268   0600000A           BEQ      ??get_sof_11
    272              ERREXIT(cinfo, JERR_BAD_LENGTH);
   \   0000026C   000094E5           LDR      R0,[R4, #+0]
   \   00000270   0C10A0E3           MOV      R1,#+12
   \   00000274   141080E5           STR      R1,[R0, #+20]
   \   00000278   001094E5           LDR      R1,[R4, #+0]
   \   0000027C   0400A0E1           MOV      R0,R4
   \   00000280   001091E5           LDR      R1,[R1, #+0]
   \   00000284   31FF2FE1           BLX      R1
    273          
    274            if (cinfo->comp_info == NULL)	/* do only once, even if suspend */
   \                     ??get_sof_11:
   \   00000288   D40094E5           LDR      R0,[R4, #+212]
   \   0000028C   000050E3           CMP      R0,#+0
   \   00000290   0800001A           BNE      ??get_sof_12
    275              cinfo->comp_info = (jpeg_component_info *) (*cinfo->mem->alloc_small)
    276          			((j_common_ptr) cinfo, JPOOL_IMAGE,
    277          			 cinfo->num_components * SIZEOF(jpeg_component_info));
   \   00000294   240094E5           LDR      R0,[R4, #+36]
   \   00000298   043094E5           LDR      R3,[R4, #+4]
   \   0000029C   5810A0E3           MOV      R1,#+88
   \   000002A0   003093E5           LDR      R3,[R3, #+0]
   \   000002A4   910002E0           MUL      R2,R1,R0
   \   000002A8   0110A0E3           MOV      R1,#+1
   \   000002AC   0400A0E1           MOV      R0,R4
   \   000002B0   33FF2FE1           BLX      R3
   \   000002B4   D40084E5           STR      R0,[R4, #+212]
    278            
    279            for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
   \                     ??get_sof_12:
   \   000002B8   D49094E5           LDR      R9,[R4, #+212]
   \   000002BC   0080A0E3           MOV      R8,#+0
   \   000002C0   3A0000EA           B        ??get_sof_13
    280                 ci++, compptr++) {
    281              compptr->component_index = ci;
   \                     ??get_sof_14:
   \   000002C4   048089E5           STR      R8,[R9, #+4]
    282              INPUT_BYTE(cinfo, compptr->component_id, return FALSE);
   \   000002C8   000057E3           CMP      R7,#+0
   \   000002CC   0600001A           BNE      ??get_sof_15
   \   000002D0   0C1095E5           LDR      R1,[R5, #+12]
   \   000002D4   0400A0E1           MOV      R0,R4
   \   000002D8   31FF2FE1           BLX      R1
   \   000002DC   000050E3           CMP      R0,#+0
   \   000002E0   F083BD08           POPEQ    {R4-R9,PC}
   \   000002E4   006095E5           LDR      R6,[R5, #+0]
   \   000002E8   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_sof_15:
   \   000002EC   ........           LDRB     R0,[R6], #+1
   \   000002F0   017057E2           SUBS     R7,R7,#+1
   \   000002F4   000089E5           STR      R0,[R9, #+0]
    283              INPUT_BYTE(cinfo, c, return FALSE);
   \   000002F8   0600001A           BNE      ??get_sof_16
   \   000002FC   0C1095E5           LDR      R1,[R5, #+12]
   \   00000300   0400A0E1           MOV      R0,R4
   \   00000304   31FF2FE1           BLX      R1
   \   00000308   000050E3           CMP      R0,#+0
   \   0000030C   F083BD08           POPEQ    {R4-R9,PC}
   \   00000310   006095E5           LDR      R6,[R5, #+0]
   \   00000314   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_sof_16:
   \   00000318   ........           LDRB     R0,[R6], #+1
   \   0000031C   017047E2           SUB      R7,R7,#+1
    284              compptr->h_samp_factor = (c >> 4) & 15;
   \   00000320   0F10A0E3           MOV      R1,#+15
   \   00000324   401201E0           AND      R1,R1,R0, ASR #+4
   \   00000328   081089E5           STR      R1,[R9, #+8]
    285              compptr->v_samp_factor = (c     ) & 15;
   \   0000032C   0F0000E2           AND      R0,R0,#0xF
   \   00000330   0C0089E5           STR      R0,[R9, #+12]
    286              INPUT_BYTE(cinfo, compptr->quant_tbl_no, return FALSE);
   \   00000334   000057E3           CMP      R7,#+0
   \   00000338   0600001A           BNE      ??get_sof_17
   \   0000033C   0C1095E5           LDR      R1,[R5, #+12]
   \   00000340   0400A0E1           MOV      R0,R4
   \   00000344   31FF2FE1           BLX      R1
   \   00000348   000050E3           CMP      R0,#+0
   \   0000034C   F083BD08           POPEQ    {R4-R9,PC}
   \   00000350   006095E5           LDR      R6,[R5, #+0]
   \   00000354   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_sof_17:
   \   00000358   ........           LDRB     R0,[R6], #+1
   \   0000035C   017047E2           SUB      R7,R7,#+1
    287          
    288              TRACEMS4(cinfo, 1, JTRC_SOF_COMPONENT,
    289          	     compptr->component_id, compptr->h_samp_factor,
    290          	     compptr->v_samp_factor, compptr->quant_tbl_no);
    291            }
   \   00000360   018088E2           ADD      R8,R8,#+1
   \   00000364   100089E5           STR      R0,[R9, #+16]
   \   00000368   000094E5           LDR      R0,[R4, #+0]
   \   0000036C   001099E5           LDR      R1,[R9, #+0]
   \   00000370   1810A0E5           STR      R1,[R0, #+24]!
   \   00000374   081099E5           LDR      R1,[R9, #+8]
   \   00000378   041080E5           STR      R1,[R0, #+4]
   \   0000037C   0C1099E5           LDR      R1,[R9, #+12]
   \   00000380   081080E5           STR      R1,[R0, #+8]
   \   00000384   101099E5           LDR      R1,[R9, #+16]
   \   00000388   589089E2           ADD      R9,R9,#+88
   \   0000038C   0C1080E5           STR      R1,[R0, #+12]
   \   00000390   000094E5           LDR      R0,[R4, #+0]
   \   00000394   6710A0E3           MOV      R1,#+103
   \   00000398   141080E5           STR      R1,[R0, #+20]
   \   0000039C   002094E5           LDR      R2,[R4, #+0]
   \   000003A0   0110A0E3           MOV      R1,#+1
   \   000003A4   042092E5           LDR      R2,[R2, #+4]
   \   000003A8   0400A0E1           MOV      R0,R4
   \   000003AC   32FF2FE1           BLX      R2
   \                     ??get_sof_13:
   \   000003B0   240094E5           LDR      R0,[R4, #+36]
   \   000003B4   000058E1           CMP      R8,R0
   \   000003B8   C1FFFFBA           BLT      ??get_sof_14
    292          
    293            cinfo->marker->saw_SOF = TRUE;
   \   000003BC   B80194E5           LDR      R0,[R4, #+440]
   \   000003C0   0110A0E3           MOV      R1,#+1
   \   000003C4   101080E5           STR      R1,[R0, #+16]
    294          
    295            INPUT_SYNC(cinfo);
   \   000003C8   006085E5           STR      R6,[R5, #+0]
   \   000003CC   047085E5           STR      R7,[R5, #+4]
    296            return TRUE;
   \   000003D0   0100A0E3           MOV      R0,#+1
   \   000003D4   F083BDE8           POP      {R4-R9,PC}       ;; return
    297          }
    298          
    299          

   \                                 In segment CODE, align 4, keep-with-next
    300          LOCAL(boolean)
    301          get_sos (j_decompress_ptr cinfo)
    302          /* Process a SOS marker */
    303          {
   \                     get_sos:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040A0E1           MOV      R4,R0
    304            INT32 length;
    305            int i, ci, n, c, cc;
    306            jpeg_component_info * compptr;
    307            INPUT_VARS(cinfo);
    308          
    309            if (! cinfo->marker->saw_SOF)
   \   0000000C   B80194E5           LDR      R0,[R4, #+440]
   \   00000010   185094E5           LDR      R5,[R4, #+24]
   \   00000014   100090E5           LDR      R0,[R0, #+16]
   \   00000018   006095E5           LDR      R6,[R5, #+0]
   \   0000001C   047095E5           LDR      R7,[R5, #+4]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0600001A           BNE      ??get_sos_0
    310              ERREXIT(cinfo, JERR_SOS_NO_SOF);
   \   00000028   000094E5           LDR      R0,[R4, #+0]
   \   0000002C   4010A0E3           MOV      R1,#+64
   \   00000030   141080E5           STR      R1,[R0, #+20]
   \   00000034   001094E5           LDR      R1,[R4, #+0]
   \   00000038   0400A0E1           MOV      R0,R4
   \   0000003C   001091E5           LDR      R1,[R1, #+0]
   \   00000040   31FF2FE1           BLX      R1
    311          
    312            INPUT_2BYTES(cinfo, length, return FALSE);
   \                     ??get_sos_0:
   \   00000044   000057E3           CMP      R7,#+0
   \   00000048   0600001A           BNE      ??get_sos_1
   \   0000004C   0C1095E5           LDR      R1,[R5, #+12]
   \   00000050   0400A0E1           MOV      R0,R4
   \   00000054   31FF2FE1           BLX      R1
   \   00000058   000050E3           CMP      R0,#+0
   \   0000005C   F28FBD08           POPEQ    {R1,R4-R11,PC}
   \   00000060   006095E5           LDR      R6,[R5, #+0]
   \   00000064   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_sos_1:
   \   00000068   ........           LDRB     R0,[R6], #+1
   \   0000006C   017047E2           SUB      R7,R7,#+1
   \   00000070   000057E3           CMP      R7,#+0
   \   00000074   0084A0E1           LSL      R8,R0,#+8
   \   00000078   0600001A           BNE      ??get_sos_2
   \   0000007C   0C1095E5           LDR      R1,[R5, #+12]
   \   00000080   0400A0E1           MOV      R0,R4
   \   00000084   31FF2FE1           BLX      R1
   \   00000088   000050E3           CMP      R0,#+0
   \   0000008C   F28FBD08           POPEQ    {R1,R4-R11,PC}
   \   00000090   006095E5           LDR      R6,[R5, #+0]
   \   00000094   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_sos_2:
   \   00000098   ........           LDRB     R0,[R6], #+1
   \   0000009C   017047E2           SUB      R7,R7,#+1
    313          
    314            INPUT_BYTE(cinfo, n, return FALSE); /* Number of components */
   \   000000A0   000057E3           CMP      R7,#+0
   \   000000A4   088080E0           ADD      R8,R0,R8
   \   000000A8   0600001A           BNE      ??get_sos_3
   \   000000AC   0C1095E5           LDR      R1,[R5, #+12]
   \   000000B0   0400A0E1           MOV      R0,R4
   \   000000B4   31FF2FE1           BLX      R1
   \   000000B8   000050E3           CMP      R0,#+0
   \   000000BC   F28FBD08           POPEQ    {R1,R4-R11,PC}
   \   000000C0   006095E5           LDR      R6,[R5, #+0]
   \   000000C4   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_sos_3:
   \   000000C8   ........           LDRB     R1,[R6], #+1
   \   000000CC   017047E2           SUB      R7,R7,#+1
   \   000000D0   00108DE5           STR      R1,[SP, #+0]
    315          
    316            TRACEMS1(cinfo, 1, JTRC_SOS, n);
   \   000000D4   000094E5           LDR      R0,[R4, #+0]
   \   000000D8   6910A0E3           MOV      R1,#+105
   \   000000DC   141080E5           STR      R1,[R0, #+20]
   \   000000E0   000094E5           LDR      R0,[R4, #+0]
   \   000000E4   00109DE5           LDR      R1,[SP, #+0]
   \   000000E8   181080E5           STR      R1,[R0, #+24]
   \   000000EC   002094E5           LDR      R2,[R4, #+0]
   \   000000F0   0110A0E3           MOV      R1,#+1
   \   000000F4   042092E5           LDR      R2,[R2, #+4]
   \   000000F8   0400A0E1           MOV      R0,R4
   \   000000FC   32FF2FE1           BLX      R2
    317          
    318            if (length != (n * 2 + 6) || n < 1 || n > MAX_COMPS_IN_SCAN)
   \   00000100   00009DE5           LDR      R0,[SP, #+0]
   \   00000104   0610A0E3           MOV      R1,#+6
   \   00000108   800081E0           ADD      R0,R1,R0, LSL #+1
   \   0000010C   000058E1           CMP      R8,R0
   \   00000110   0400001A           BNE      ??get_sos_4
   \   00000114   00009DE5           LDR      R0,[SP, #+0]
   \   00000118   010050E3           CMP      R0,#+1
   \   0000011C   010000BA           BLT      ??get_sos_4
   \   00000120   050050E3           CMP      R0,#+5
   \   00000124   060000BA           BLT      ??get_sos_5
    319              ERREXIT(cinfo, JERR_BAD_LENGTH);
   \                     ??get_sos_4:
   \   00000128   000094E5           LDR      R0,[R4, #+0]
   \   0000012C   0C10A0E3           MOV      R1,#+12
   \   00000130   141080E5           STR      R1,[R0, #+20]
   \   00000134   001094E5           LDR      R1,[R4, #+0]
   \   00000138   0400A0E1           MOV      R0,R4
   \   0000013C   001091E5           LDR      R1,[R1, #+0]
   \   00000140   31FF2FE1           BLX      R1
    320          
    321            cinfo->comps_in_scan = n;
   \                     ??get_sos_5:
   \   00000144   00009DE5           LDR      R0,[SP, #+0]
    322          
    323            /* Collect the component-spec parameters */
    324          
    325            for (i = 0; i < n; i++) {
   \   00000148   0080A0E3           MOV      R8,#+0
   \   0000014C   480184E5           STR      R0,[R4, #+328]
   \   00000150   260000EA           B        ??get_sos_6
    326              INPUT_BYTE(cinfo, cc, return FALSE);
    327              INPUT_BYTE(cinfo, c, return FALSE);
    328              
    329              for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
    330          	 ci++, compptr++) {
    331                if (cc == compptr->component_id)
   \                     ??get_sos_7:
   \   00000154   00109AE5           LDR      R1,[R10, #+0]
   \   00000158   010059E1           CMP      R9,R1
   \   0000015C   0D00000A           BEQ      ??get_sos_8
    332          	goto id_found;
    333              }
   \   00000160   010080E2           ADD      R0,R0,#+1
   \   00000164   58A08AE2           ADD      R10,R10,#+88
   \                     ??get_sos_9:
   \   00000168   241094E5           LDR      R1,[R4, #+36]
   \   0000016C   010050E1           CMP      R0,R1
   \   00000170   F7FFFFBA           BLT      ??get_sos_7
    334          
    335              ERREXIT1(cinfo, JERR_BAD_COMPONENT_ID, cc);
   \   00000174   000094E5           LDR      R0,[R4, #+0]
   \   00000178   0410A0E3           MOV      R1,#+4
   \   0000017C   141080E5           STR      R1,[R0, #+20]
   \   00000180   000094E5           LDR      R0,[R4, #+0]
   \   00000184   189080E5           STR      R9,[R0, #+24]
   \   00000188   001094E5           LDR      R1,[R4, #+0]
   \   0000018C   0400A0E1           MOV      R0,R4
   \   00000190   001091E5           LDR      R1,[R1, #+0]
   \   00000194   31FF2FE1           BLX      R1
    336          
    337            id_found:
    338          
    339              cinfo->cur_comp_info[i] = compptr;
   \                     ??get_sos_8:
   \   00000198   080184E0           ADD      R0,R4,R8, LSL #+2
   \   0000019C   4CA180E5           STR      R10,[R0, #+332]
    340              compptr->dc_tbl_no = (c >> 4) & 15;
   \   000001A0   0F00A0E3           MOV      R0,#+15
   \   000001A4   4B0200E0           AND      R0,R0,R11, ASR #+4
   \   000001A8   14008AE5           STR      R0,[R10, #+20]
    341              compptr->ac_tbl_no = (c     ) & 15;
   \   000001AC   0F000BE2           AND      R0,R11,#0xF
   \   000001B0   18008AE5           STR      R0,[R10, #+24]
    342              
    343              TRACEMS3(cinfo, 1, JTRC_SOS_COMPONENT, cc,
    344          	     compptr->dc_tbl_no, compptr->ac_tbl_no);
   \   000001B4   000094E5           LDR      R0,[R4, #+0]
   \   000001B8   018088E2           ADD      R8,R8,#+1
   \   000001BC   1890A0E5           STR      R9,[R0, #+24]!
   \   000001C0   14109AE5           LDR      R1,[R10, #+20]
   \   000001C4   041080E5           STR      R1,[R0, #+4]
   \   000001C8   18109AE5           LDR      R1,[R10, #+24]
   \   000001CC   081080E5           STR      R1,[R0, #+8]
   \   000001D0   000094E5           LDR      R0,[R4, #+0]
   \   000001D4   6A10A0E3           MOV      R1,#+106
   \   000001D8   141080E5           STR      R1,[R0, #+20]
   \   000001DC   002094E5           LDR      R2,[R4, #+0]
   \   000001E0   0110A0E3           MOV      R1,#+1
   \   000001E4   042092E5           LDR      R2,[R2, #+4]
   \   000001E8   0400A0E1           MOV      R0,R4
   \   000001EC   32FF2FE1           BLX      R2
   \                     ??get_sos_6:
   \   000001F0   00009DE5           LDR      R0,[SP, #+0]
   \   000001F4   0C1095E5           LDR      R1,[R5, #+12]
   \   000001F8   000058E1           CMP      R8,R0
   \   000001FC   160000AA           BGE      ??get_sos_10
   \   00000200   000057E3           CMP      R7,#+0
   \   00000204   0500001A           BNE      ??get_sos_11
   \   00000208   0400A0E1           MOV      R0,R4
   \   0000020C   31FF2FE1           BLX      R1
   \   00000210   000050E3           CMP      R0,#+0
   \   00000214   F28FBD08           POPEQ    {R1,R4-R11,PC}
   \   00000218   006095E5           LDR      R6,[R5, #+0]
   \   0000021C   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_sos_11:
   \   00000220   ........           LDRB     R9,[R6], #+1
   \   00000224   017057E2           SUBS     R7,R7,#+1
   \   00000228   0600001A           BNE      ??get_sos_12
   \   0000022C   0C1095E5           LDR      R1,[R5, #+12]
   \   00000230   0400A0E1           MOV      R0,R4
   \   00000234   31FF2FE1           BLX      R1
   \   00000238   000050E3           CMP      R0,#+0
   \   0000023C   F28FBD08           POPEQ    {R1,R4-R11,PC}
   \   00000240   006095E5           LDR      R6,[R5, #+0]
   \   00000244   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_sos_12:
   \   00000248   ........           LDRB     R11,[R6], #+1
   \   0000024C   D4A094E5           LDR      R10,[R4, #+212]
   \   00000250   017047E2           SUB      R7,R7,#+1
   \   00000254   0000A0E3           MOV      R0,#+0
   \   00000258   C2FFFFEA           B        ??get_sos_9
    345            }
    346          
    347            /* Collect the additional scan parameters Ss, Se, Ah/Al. */
    348            INPUT_BYTE(cinfo, c, return FALSE);
   \                     ??get_sos_10:
   \   0000025C   000057E3           CMP      R7,#+0
   \   00000260   0500001A           BNE      ??get_sos_13
   \   00000264   0400A0E1           MOV      R0,R4
   \   00000268   31FF2FE1           BLX      R1
   \   0000026C   000050E3           CMP      R0,#+0
   \   00000270   F28FBD08           POPEQ    {R1,R4-R11,PC}
   \   00000274   006095E5           LDR      R6,[R5, #+0]
   \   00000278   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_sos_13:
   \   0000027C   ........           LDRB     R11,[R6], #+1
   \   00000280   017057E2           SUBS     R7,R7,#+1
    349            cinfo->Ss = c;
   \   00000284   90B184E5           STR      R11,[R4, #+400]
    350            INPUT_BYTE(cinfo, c, return FALSE);
   \   00000288   0600001A           BNE      ??get_sos_14
   \   0000028C   0C1095E5           LDR      R1,[R5, #+12]
   \   00000290   0400A0E1           MOV      R0,R4
   \   00000294   31FF2FE1           BLX      R1
   \   00000298   000050E3           CMP      R0,#+0
   \   0000029C   F28FBD08           POPEQ    {R1,R4-R11,PC}
   \   000002A0   006095E5           LDR      R6,[R5, #+0]
   \   000002A4   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_sos_14:
   \   000002A8   ........           LDRB     R11,[R6], #+1
   \   000002AC   017057E2           SUBS     R7,R7,#+1
    351            cinfo->Se = c;
   \   000002B0   94B184E5           STR      R11,[R4, #+404]
    352            INPUT_BYTE(cinfo, c, return FALSE);
   \   000002B4   0600001A           BNE      ??get_sos_15
   \   000002B8   0C1095E5           LDR      R1,[R5, #+12]
   \   000002BC   0400A0E1           MOV      R0,R4
   \   000002C0   31FF2FE1           BLX      R1
   \   000002C4   000050E3           CMP      R0,#+0
   \   000002C8   F28FBD08           POPEQ    {R1,R4-R11,PC}
   \   000002CC   006095E5           LDR      R6,[R5, #+0]
   \   000002D0   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_sos_15:
   \   000002D4   ........           LDRB     R11,[R6], #+1
    353            cinfo->Ah = (c >> 4) & 15;
   \   000002D8   0F00A0E3           MOV      R0,#+15
   \   000002DC   4B0200E0           AND      R0,R0,R11, ASR #+4
   \   000002E0   980184E5           STR      R0,[R4, #+408]
    354            cinfo->Al = (c     ) & 15;
   \   000002E4   0F000BE2           AND      R0,R11,#0xF
   \   000002E8   9C0184E5           STR      R0,[R4, #+412]
    355          
    356            TRACEMS4(cinfo, 1, JTRC_SOS_PARAMS, cinfo->Ss, cinfo->Se,
    357          	   cinfo->Ah, cinfo->Al);
   \   000002EC   000094E5           LDR      R0,[R4, #+0]
   \   000002F0   901194E5           LDR      R1,[R4, #+400]
   \   000002F4   1810A0E5           STR      R1,[R0, #+24]!
   \   000002F8   941194E5           LDR      R1,[R4, #+404]
   \   000002FC   041080E5           STR      R1,[R0, #+4]
   \   00000300   981194E5           LDR      R1,[R4, #+408]
   \   00000304   081080E5           STR      R1,[R0, #+8]
   \   00000308   9C1194E5           LDR      R1,[R4, #+412]
   \   0000030C   0C1080E5           STR      R1,[R0, #+12]
   \   00000310   000094E5           LDR      R0,[R4, #+0]
   \   00000314   6B10A0E3           MOV      R1,#+107
   \   00000318   141080E5           STR      R1,[R0, #+20]
   \   0000031C   002094E5           LDR      R2,[R4, #+0]
   \   00000320   0110A0E3           MOV      R1,#+1
   \   00000324   042092E5           LDR      R2,[R2, #+4]
   \   00000328   0400A0E1           MOV      R0,R4
   \   0000032C   32FF2FE1           BLX      R2
    358          
    359            /* Prepare to scan data & restart markers */
    360            cinfo->marker->next_restart_num = 0;
   \   00000330   B80194E5           LDR      R0,[R4, #+440]
   \   00000334   0010A0E3           MOV      R1,#+0
   \   00000338   141080E5           STR      R1,[R0, #+20]
    361          
    362            /* Count another SOS marker */
    363            cinfo->input_scan_number++;
   \   0000033C   8C0094E5           LDR      R0,[R4, #+140]
   \   00000340   010080E2           ADD      R0,R0,#+1
   \   00000344   8C0084E5           STR      R0,[R4, #+140]
    364          
    365            INPUT_SYNC(cinfo);
   \   00000348   006085E5           STR      R6,[R5, #+0]
   \   0000034C   010047E2           SUB      R0,R7,#+1
   \   00000350   040085E5           STR      R0,[R5, #+4]
    366            return TRUE;
   \   00000354   0100A0E3           MOV      R0,#+1
   \   00000358   F28FBDE8           POP      {R1,R4-R11,PC}   ;; return
    367          }
    368          
    369          
    370          #ifdef D_ARITH_CODING_SUPPORTED
    371          

   \                                 In segment CODE, align 4, keep-with-next
    372          LOCAL(boolean)
    373          get_dac (j_decompress_ptr cinfo)
    374          /* Process a DAC marker */
    375          {
   \                     get_dac:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    376            INT32 length;
    377            int index, val;
    378            INPUT_VARS(cinfo);
   \   00000008   185094E5           LDR      R5,[R4, #+24]
   \   0000000C   006095E5           LDR      R6,[R5, #+0]
   \   00000010   047095E5           LDR      R7,[R5, #+4]
    379          
    380            INPUT_2BYTES(cinfo, length, return FALSE);
   \   00000014   000057E3           CMP      R7,#+0
   \   00000018   0500001A           BNE      ??get_dac_0
   \   0000001C   0C1095E5           LDR      R1,[R5, #+12]
   \   00000020   31FF2FE1           BLX      R1
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   F087BD08           POPEQ    {R4-R10,PC}
   \   0000002C   006095E5           LDR      R6,[R5, #+0]
   \   00000030   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_dac_0:
   \   00000034   ........           LDRB     R0,[R6], #+1
   \   00000038   017047E2           SUB      R7,R7,#+1
   \   0000003C   000057E3           CMP      R7,#+0
   \   00000040   0084A0E1           LSL      R8,R0,#+8
   \   00000044   0600001A           BNE      ??get_dac_1
   \   00000048   0C1095E5           LDR      R1,[R5, #+12]
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   31FF2FE1           BLX      R1
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   F087BD08           POPEQ    {R4-R10,PC}
   \   0000005C   006095E5           LDR      R6,[R5, #+0]
   \   00000060   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_dac_1:
   \   00000064   ........           LDRB     R0,[R6], #+1
   \   00000068   017047E2           SUB      R7,R7,#+1
   \   0000006C   080080E0           ADD      R0,R0,R8
    381            length -= 2;
   \   00000070   028040E2           SUB      R8,R0,#+2
   \   00000074   020000EA           B        ??get_dac_2
    382            
    383            while (length > 0) {
    384              INPUT_BYTE(cinfo, index, return FALSE);
    385              INPUT_BYTE(cinfo, val, return FALSE);
    386          
    387              length -= 2;
    388          
    389              TRACEMS2(cinfo, 1, JTRC_DAC, index, val);
    390          
    391              if (index < 0 || index >= (2*NUM_ARITH_TBLS))
    392                ERREXIT1(cinfo, JERR_DAC_INDEX, index);
    393          
    394              if (index >= NUM_ARITH_TBLS) { /* define AC table */
    395                cinfo->arith_ac_K[index-NUM_ARITH_TBLS] = (UINT8) val;
   \                     ??get_dac_3:
   \   00000078   10004AE2           SUB      R0,R10,#+16
   \   0000007C   040080E0           ADD      R0,R0,R4
   \   00000080   0091C0E5           STRB     R9,[R0, #+256]
    396              } else {			/* define DC table */
   \                     ??get_dac_2:
   \   00000084   010058E3           CMP      R8,#+1
   \   00000088   440000BA           BLT      ??get_dac_4
   \   0000008C   000057E3           CMP      R7,#+0
   \   00000090   0600001A           BNE      ??get_dac_5
   \   00000094   0C1095E5           LDR      R1,[R5, #+12]
   \   00000098   0400A0E1           MOV      R0,R4
   \   0000009C   31FF2FE1           BLX      R1
   \   000000A0   000050E3           CMP      R0,#+0
   \   000000A4   F087BD08           POPEQ    {R4-R10,PC}
   \   000000A8   006095E5           LDR      R6,[R5, #+0]
   \   000000AC   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_dac_5:
   \   000000B0   ........           LDRB     R10,[R6], #+1
   \   000000B4   017057E2           SUBS     R7,R7,#+1
   \   000000B8   0600001A           BNE      ??get_dac_6
   \   000000BC   0C1095E5           LDR      R1,[R5, #+12]
   \   000000C0   0400A0E1           MOV      R0,R4
   \   000000C4   31FF2FE1           BLX      R1
   \   000000C8   000050E3           CMP      R0,#+0
   \   000000CC   F087BD08           POPEQ    {R4-R10,PC}
   \   000000D0   006095E5           LDR      R6,[R5, #+0]
   \   000000D4   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_dac_6:
   \   000000D8   000094E5           LDR      R0,[R4, #+0]
   \   000000DC   ........           LDRB     R9,[R6], #+1
   \   000000E0   5110A0E3           MOV      R1,#+81
   \   000000E4   141080E5           STR      R1,[R0, #+20]
   \   000000E8   000094E5           LDR      R0,[R4, #+0]
   \   000000EC   017047E2           SUB      R7,R7,#+1
   \   000000F0   18A080E5           STR      R10,[R0, #+24]
   \   000000F4   000094E5           LDR      R0,[R4, #+0]
   \   000000F8   028048E2           SUB      R8,R8,#+2
   \   000000FC   1C9080E5           STR      R9,[R0, #+28]
   \   00000100   002094E5           LDR      R2,[R4, #+0]
   \   00000104   0110A0E3           MOV      R1,#+1
   \   00000108   042092E5           LDR      R2,[R2, #+4]
   \   0000010C   0400A0E1           MOV      R0,R4
   \   00000110   32FF2FE1           BLX      R2
   \   00000114   00005AE3           CMP      R10,#+0
   \   00000118   0100004A           BMI      ??get_dac_7
   \   0000011C   20005AE3           CMP      R10,#+32
   \   00000120   080000BA           BLT      ??get_dac_8
   \                     ??get_dac_7:
   \   00000124   000094E5           LDR      R0,[R4, #+0]
   \   00000128   1D10A0E3           MOV      R1,#+29
   \   0000012C   141080E5           STR      R1,[R0, #+20]
   \   00000130   000094E5           LDR      R0,[R4, #+0]
   \   00000134   18A080E5           STR      R10,[R0, #+24]
   \   00000138   001094E5           LDR      R1,[R4, #+0]
   \   0000013C   0400A0E1           MOV      R0,R4
   \   00000140   001091E5           LDR      R1,[R1, #+0]
   \   00000144   31FF2FE1           BLX      R1
   \                     ??get_dac_8:
   \   00000148   10005AE3           CMP      R10,#+16
   \   0000014C   C9FFFFAA           BGE      ??get_dac_3
    397                cinfo->arith_dc_L[index] = (UINT8) (val & 0x0F);
   \   00000150   04008AE0           ADD      R0,R10,R4
   \   00000154   0F1009E2           AND      R1,R9,#0xF
   \   00000158   E010C0E5           STRB     R1,[R0, #+224]
    398                cinfo->arith_dc_U[index] = (UINT8) (val >> 4);
   \   0000015C   4912A0E1           ASR      R1,R9,#+4
   \   00000160   F010C0E5           STRB     R1,[R0, #+240]
    399                if (cinfo->arith_dc_L[index] > cinfo->arith_dc_U[index])
   \   00000164   F000D0E5           LDRB     R0,[R0, #+240]
   \   00000168   04108AE0           ADD      R1,R10,R4
   \   0000016C   E010D1E5           LDRB     R1,[R1, #+224]
   \   00000170   010050E1           CMP      R0,R1
   \   00000174   C2FFFF2A           BCS      ??get_dac_2
    400          	ERREXIT1(cinfo, JERR_DAC_VALUE, val);
   \   00000178   000094E5           LDR      R0,[R4, #+0]
   \   0000017C   1E10A0E3           MOV      R1,#+30
   \   00000180   141080E5           STR      R1,[R0, #+20]
   \   00000184   000094E5           LDR      R0,[R4, #+0]
   \   00000188   189080E5           STR      R9,[R0, #+24]
   \   0000018C   001094E5           LDR      R1,[R4, #+0]
   \   00000190   0400A0E1           MOV      R0,R4
   \   00000194   001091E5           LDR      R1,[R1, #+0]
   \   00000198   31FF2FE1           BLX      R1
   \   0000019C   B8FFFFEA           B        ??get_dac_2
    401              }
    402            }
    403          
    404            if (length != 0)
   \                     ??get_dac_4:
   \   000001A0   000058E3           CMP      R8,#+0
   \   000001A4   0600000A           BEQ      ??get_dac_9
    405              ERREXIT(cinfo, JERR_BAD_LENGTH);
   \   000001A8   000094E5           LDR      R0,[R4, #+0]
   \   000001AC   0C10A0E3           MOV      R1,#+12
   \   000001B0   141080E5           STR      R1,[R0, #+20]
   \   000001B4   001094E5           LDR      R1,[R4, #+0]
   \   000001B8   0400A0E1           MOV      R0,R4
   \   000001BC   001091E5           LDR      R1,[R1, #+0]
   \   000001C0   31FF2FE1           BLX      R1
    406          
    407            INPUT_SYNC(cinfo);
   \                     ??get_dac_9:
   \   000001C4   006085E5           STR      R6,[R5, #+0]
   \   000001C8   047085E5           STR      R7,[R5, #+4]
    408            return TRUE;
   \   000001CC   0100A0E3           MOV      R0,#+1
   \   000001D0   F087BDE8           POP      {R4-R10,PC}      ;; return
    409          }
    410          
    411          #else /* ! D_ARITH_CODING_SUPPORTED */
    412          
    413          #define get_dac(cinfo)  skip_variable(cinfo)
    414          
    415          #endif /* D_ARITH_CODING_SUPPORTED */
    416          
    417          

   \                                 In segment CODE, align 4, keep-with-next
    418          LOCAL(boolean)
    419          get_dht (j_decompress_ptr cinfo)
    420          /* Process a DHT marker */
    421          {
   \                     get_dht:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   45DF4DE2           SUB      SP,SP,#+276
   \   00000008   0040A0E1           MOV      R4,R0
    422            INT32 length;
    423            UINT8 bits[17];
    424            UINT8 huffval[256];
    425            int i, index, count;
    426            JHUFF_TBL **htblptr;
    427            INPUT_VARS(cinfo);
   \   0000000C   185094E5           LDR      R5,[R4, #+24]
   \   00000010   007095E5           LDR      R7,[R5, #+0]
   \   00000014   048095E5           LDR      R8,[R5, #+4]
    428          
    429            INPUT_2BYTES(cinfo, length, return FALSE);
   \   00000018   000058E3           CMP      R8,#+0
   \   0000001C   0500001A           BNE      ??get_dht_0
   \   00000020   0C1095E5           LDR      R1,[R5, #+12]
   \   00000024   31FF2FE1           BLX      R1
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   C000000A           BEQ      ??get_dht_1
   \   00000030   007095E5           LDR      R7,[R5, #+0]
   \   00000034   048095E5           LDR      R8,[R5, #+4]
   \                     ??get_dht_0:
   \   00000038   ........           LDRB     R0,[R7], #+1
   \   0000003C   018048E2           SUB      R8,R8,#+1
   \   00000040   000058E3           CMP      R8,#+0
   \   00000044   0064A0E1           LSL      R6,R0,#+8
   \   00000048   0600001A           BNE      ??get_dht_2
   \   0000004C   0C1095E5           LDR      R1,[R5, #+12]
   \   00000050   0400A0E1           MOV      R0,R4
   \   00000054   31FF2FE1           BLX      R1
   \   00000058   000050E3           CMP      R0,#+0
   \   0000005C   B400000A           BEQ      ??get_dht_1
   \   00000060   007095E5           LDR      R7,[R5, #+0]
   \   00000064   048095E5           LDR      R8,[R5, #+4]
   \                     ??get_dht_2:
   \   00000068   ........           LDRB     R0,[R7], #+1
   \   0000006C   018048E2           SUB      R8,R8,#+1
   \   00000070   060080E0           ADD      R0,R0,R6
    430            length -= 2;
   \   00000074   026040E2           SUB      R6,R0,#+2
   \   00000078   1D0000EA           B        ??get_dht_3
    431            
    432            while (length > 16) {
    433              INPUT_BYTE(cinfo, index, return FALSE);
    434          
    435              TRACEMS1(cinfo, 1, JTRC_DHT, index);
    436                
    437              bits[0] = 0;
    438              count = 0;
    439              for (i = 1; i <= 16; i++) {
    440                INPUT_BYTE(cinfo, bits[i], return FALSE);
    441                count += bits[i];
    442              }
    443          
    444              length -= 1 + 16;
    445          
    446              TRACEMS8(cinfo, 2, JTRC_HUFFBITS,
    447          	     bits[1], bits[2], bits[3], bits[4],
    448          	     bits[5], bits[6], bits[7], bits[8]);
    449              TRACEMS8(cinfo, 2, JTRC_HUFFBITS,
    450          	     bits[9], bits[10], bits[11], bits[12],
    451          	     bits[13], bits[14], bits[15], bits[16]);
    452          
    453              /* Here we just do minimal validation of the counts to avoid walking
    454               * off the end of our table space.  jdhuff.c will check more carefully.
    455               */
    456              if (count > 256 || ((INT32) count) > length)
    457                ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
    458          
    459              for (i = 0; i < count; i++)
    460                INPUT_BYTE(cinfo, huffval[i], return FALSE);
    461          
    462              length -= count;
    463          
    464              if (index & 0x10) {		/* AC table definition */
    465                index -= 0x10;
    466                htblptr = &cinfo->ac_huff_tbl_ptrs[index];
    467              } else {			/* DC table definition */
    468                htblptr = &cinfo->dc_huff_tbl_ptrs[index];
   \                     ??get_dht_4:
   \   0000007C   090184E0           ADD      R0,R4,R9, LSL #+2
   \   00000080   B0A080E2           ADD      R10,R0,#+176
    469              }
    470          
    471              if (index < 0 || index >= NUM_HUFF_TBLS)
   \                     ??get_dht_5:
   \   00000084   000059E3           CMP      R9,#+0
   \   00000088   0100004A           BMI      ??get_dht_6
   \   0000008C   040059E3           CMP      R9,#+4
   \   00000090   080000BA           BLT      ??get_dht_7
    472                ERREXIT1(cinfo, JERR_DHT_INDEX, index);
   \                     ??get_dht_6:
   \   00000094   000094E5           LDR      R0,[R4, #+0]
   \   00000098   1F10A0E3           MOV      R1,#+31
   \   0000009C   141080E5           STR      R1,[R0, #+20]
   \   000000A0   000094E5           LDR      R0,[R4, #+0]
   \   000000A4   189080E5           STR      R9,[R0, #+24]
   \   000000A8   001094E5           LDR      R1,[R4, #+0]
   \   000000AC   0400A0E1           MOV      R0,R4
   \   000000B0   001091E5           LDR      R1,[R1, #+0]
   \   000000B4   31FF2FE1           BLX      R1
    473          
    474              if (*htblptr == NULL)
   \                     ??get_dht_7:
   \   000000B8   00009AE5           LDR      R0,[R10, #+0]
   \   000000BC   000050E3           CMP      R0,#+0
   \   000000C0   0200001A           BNE      ??get_dht_8
    475                *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
   \   000000C4   0400A0E1           MOV      R0,R4
   \   000000C8   ........           _BLF     jpeg_alloc_huff_table,??jpeg_alloc_huff_table??rA
   \   000000CC   00008AE5           STR      R0,[R10, #+0]
    476            
    477              MEMCOPY((*htblptr)->bits, bits, SIZEOF((*htblptr)->bits));
   \                     ??get_dht_8:
   \   000000D0   00009AE5           LDR      R0,[R10, #+0]
   \   000000D4   1120A0E3           MOV      R2,#+17
   \   000000D8   0D10A0E1           MOV      R1,SP
   \   000000DC   1E0100EF           SWI      +286
    478              MEMCOPY((*htblptr)->huffval, huffval, SIZEOF((*htblptr)->huffval));
   \   000000E0   00009AE5           LDR      R0,[R10, #+0]
   \   000000E4   402FA0E3           MOV      R2,#+256
   \   000000E8   14108DE2           ADD      R1,SP,#+20
   \   000000EC   110080E2           ADD      R0,R0,#+17
   \   000000F0   1E0100EF           SWI      +286
   \                     ??get_dht_3:
   \   000000F4   110056E3           CMP      R6,#+17
   \   000000F8   810000BA           BLT      ??get_dht_9
   \   000000FC   000058E3           CMP      R8,#+0
   \   00000100   0600001A           BNE      ??get_dht_10
   \   00000104   0C1095E5           LDR      R1,[R5, #+12]
   \   00000108   0400A0E1           MOV      R0,R4
   \   0000010C   31FF2FE1           BLX      R1
   \   00000110   000050E3           CMP      R0,#+0
   \   00000114   8600000A           BEQ      ??get_dht_1
   \   00000118   007095E5           LDR      R7,[R5, #+0]
   \   0000011C   048095E5           LDR      R8,[R5, #+4]
   \                     ??get_dht_10:
   \   00000120   ........           LDRB     R9,[R7], #+1
   \   00000124   000094E5           LDR      R0,[R4, #+0]
   \   00000128   5210A0E3           MOV      R1,#+82
   \   0000012C   141080E5           STR      R1,[R0, #+20]
   \   00000130   000094E5           LDR      R0,[R4, #+0]
   \   00000134   018048E2           SUB      R8,R8,#+1
   \   00000138   189080E5           STR      R9,[R0, #+24]
   \   0000013C   002094E5           LDR      R2,[R4, #+0]
   \   00000140   0110A0E3           MOV      R1,#+1
   \   00000144   042092E5           LDR      R2,[R2, #+4]
   \   00000148   0400A0E1           MOV      R0,R4
   \   0000014C   32FF2FE1           BLX      R2
   \   00000150   0010A0E3           MOV      R1,#+0
   \   00000154   0010CDE5           STRB     R1,[SP, #+0]
   \   00000158   00A0A0E3           MOV      R10,#+0
   \   0000015C   01B0A0E3           MOV      R11,#+1
   \                     ??get_dht_11:
   \   00000160   000058E3           CMP      R8,#+0
   \   00000164   0600001A           BNE      ??get_dht_12
   \   00000168   0C1095E5           LDR      R1,[R5, #+12]
   \   0000016C   0400A0E1           MOV      R0,R4
   \   00000170   31FF2FE1           BLX      R1
   \   00000174   000050E3           CMP      R0,#+0
   \   00000178   6D00000A           BEQ      ??get_dht_1
   \   0000017C   007095E5           LDR      R7,[R5, #+0]
   \   00000180   048095E5           LDR      R8,[R5, #+4]
   \                     ??get_dht_12:
   \   00000184   ........           LDRB     R1,[R7], #+1
   \   00000188   018048E2           SUB      R8,R8,#+1
   \   0000018C   0D00A0E1           MOV      R0,SP
   \   00000190   00008BE0           ADD      R0,R11,R0
   \   00000194   0010C0E5           STRB     R1,[R0, #+0]
   \   00000198   0AA081E0           ADD      R10,R1,R10
   \   0000019C   01B08BE2           ADD      R11,R11,#+1
   \   000001A0   11005BE3           CMP      R11,#+17
   \   000001A4   EDFFFFBA           BLT      ??get_dht_11
   \   000001A8   0110DDE5           LDRB     R1,[SP, #+1]
   \   000001AC   000094E5           LDR      R0,[R4, #+0]
   \   000001B0   58B0A0E3           MOV      R11,#+88
   \   000001B4   1810A0E5           STR      R1,[R0, #+24]!
   \   000001B8   0210DDE5           LDRB     R1,[SP, #+2]
   \   000001BC   116046E2           SUB      R6,R6,#+17
   \   000001C0   041080E5           STR      R1,[R0, #+4]
   \   000001C4   0310DDE5           LDRB     R1,[SP, #+3]
   \   000001C8   081080E5           STR      R1,[R0, #+8]
   \   000001CC   0410DDE5           LDRB     R1,[SP, #+4]
   \   000001D0   0C1080E5           STR      R1,[R0, #+12]
   \   000001D4   0510DDE5           LDRB     R1,[SP, #+5]
   \   000001D8   101080E5           STR      R1,[R0, #+16]
   \   000001DC   0610DDE5           LDRB     R1,[SP, #+6]
   \   000001E0   141080E5           STR      R1,[R0, #+20]
   \   000001E4   0710DDE5           LDRB     R1,[SP, #+7]
   \   000001E8   181080E5           STR      R1,[R0, #+24]
   \   000001EC   0810DDE5           LDRB     R1,[SP, #+8]
   \   000001F0   1C1080E5           STR      R1,[R0, #+28]
   \   000001F4   000094E5           LDR      R0,[R4, #+0]
   \   000001F8   0210A0E3           MOV      R1,#+2
   \   000001FC   14B080E5           STR      R11,[R0, #+20]
   \   00000200   002094E5           LDR      R2,[R4, #+0]
   \   00000204   0400A0E1           MOV      R0,R4
   \   00000208   042092E5           LDR      R2,[R2, #+4]
   \   0000020C   32FF2FE1           BLX      R2
   \   00000210   0910DDE5           LDRB     R1,[SP, #+9]
   \   00000214   000094E5           LDR      R0,[R4, #+0]
   \   00000218   1810A0E5           STR      R1,[R0, #+24]!
   \   0000021C   0A10DDE5           LDRB     R1,[SP, #+10]
   \   00000220   041080E5           STR      R1,[R0, #+4]
   \   00000224   0B10DDE5           LDRB     R1,[SP, #+11]
   \   00000228   081080E5           STR      R1,[R0, #+8]
   \   0000022C   0C10DDE5           LDRB     R1,[SP, #+12]
   \   00000230   0C1080E5           STR      R1,[R0, #+12]
   \   00000234   0D10DDE5           LDRB     R1,[SP, #+13]
   \   00000238   101080E5           STR      R1,[R0, #+16]
   \   0000023C   0E10DDE5           LDRB     R1,[SP, #+14]
   \   00000240   141080E5           STR      R1,[R0, #+20]
   \   00000244   0F10DDE5           LDRB     R1,[SP, #+15]
   \   00000248   181080E5           STR      R1,[R0, #+24]
   \   0000024C   1010DDE5           LDRB     R1,[SP, #+16]
   \   00000250   1C1080E5           STR      R1,[R0, #+28]
   \   00000254   000094E5           LDR      R0,[R4, #+0]
   \   00000258   0210A0E3           MOV      R1,#+2
   \   0000025C   14B080E5           STR      R11,[R0, #+20]
   \   00000260   002094E5           LDR      R2,[R4, #+0]
   \   00000264   0400A0E1           MOV      R0,R4
   \   00000268   042092E5           LDR      R2,[R2, #+4]
   \   0000026C   32FF2FE1           BLX      R2
   \   00000270   A9008BE2           ADD      R0,R11,#+169
   \   00000274   00005AE1           CMP      R10,R0
   \   00000278   010000AA           BGE      ??get_dht_13
   \   0000027C   0A0056E1           CMP      R6,R10
   \   00000280   060000AA           BGE      ??get_dht_14
   \                     ??get_dht_13:
   \   00000284   000094E5           LDR      R0,[R4, #+0]
   \   00000288   0910A0E3           MOV      R1,#+9
   \   0000028C   141080E5           STR      R1,[R0, #+20]
   \   00000290   001094E5           LDR      R1,[R4, #+0]
   \   00000294   0400A0E1           MOV      R0,R4
   \   00000298   001091E5           LDR      R1,[R1, #+0]
   \   0000029C   31FF2FE1           BLX      R1
   \                     ??get_dht_14:
   \   000002A0   00B0A0E3           MOV      R11,#+0
   \   000002A4   0D0000EA           B        ??get_dht_15
   \                     ??get_dht_16:
   \   000002A8   000058E3           CMP      R8,#+0
   \   000002AC   0600001A           BNE      ??get_dht_17
   \   000002B0   0C1095E5           LDR      R1,[R5, #+12]
   \   000002B4   0400A0E1           MOV      R0,R4
   \   000002B8   31FF2FE1           BLX      R1
   \   000002BC   000050E3           CMP      R0,#+0
   \   000002C0   1B00000A           BEQ      ??get_dht_1
   \   000002C4   007095E5           LDR      R7,[R5, #+0]
   \   000002C8   048095E5           LDR      R8,[R5, #+4]
   \                     ??get_dht_17:
   \   000002CC   ........           LDRB     R1,[R7], #+1
   \   000002D0   018048E2           SUB      R8,R8,#+1
   \   000002D4   14008DE2           ADD      R0,SP,#+20
   \   000002D8   0010CBE7           STRB     R1,[R11, +R0]
   \   000002DC   01B08BE2           ADD      R11,R11,#+1
   \                     ??get_dht_15:
   \   000002E0   0A005BE1           CMP      R11,R10
   \   000002E4   EFFFFFBA           BLT      ??get_dht_16
   \   000002E8   0A6046E0           SUB      R6,R6,R10
   \   000002EC   100019E3           TST      R9,#0x10
   \   000002F0   61FFFF0A           BEQ      ??get_dht_4
   \   000002F4   109049E2           SUB      R9,R9,#+16
   \   000002F8   090184E0           ADD      R0,R4,R9, LSL #+2
   \   000002FC   C0A080E2           ADD      R10,R0,#+192
   \   00000300   5FFFFFEA           B        ??get_dht_5
    479            }
    480          
    481            if (length != 0)
   \                     ??get_dht_9:
   \   00000304   000056E3           CMP      R6,#+0
   \   00000308   0600000A           BEQ      ??get_dht_18
    482              ERREXIT(cinfo, JERR_BAD_LENGTH);
   \   0000030C   000094E5           LDR      R0,[R4, #+0]
   \   00000310   0C10A0E3           MOV      R1,#+12
   \   00000314   141080E5           STR      R1,[R0, #+20]
   \   00000318   001094E5           LDR      R1,[R4, #+0]
   \   0000031C   0400A0E1           MOV      R0,R4
   \   00000320   001091E5           LDR      R1,[R1, #+0]
   \   00000324   31FF2FE1           BLX      R1
    483          
    484            INPUT_SYNC(cinfo);
   \                     ??get_dht_18:
   \   00000328   007085E5           STR      R7,[R5, #+0]
   \   0000032C   048085E5           STR      R8,[R5, #+4]
    485            return TRUE;
   \   00000330   0100A0E3           MOV      R0,#+1
   \                     ??get_dht_1:
   \   00000334   45DF8DE2           ADD      SP,SP,#+276      ;; stack cleaning
   \   00000338   F08FBDE8           POP      {R4-R11,PC}      ;; return
    486          }
    487          
    488          

   \                                 In segment CODE, align 4, keep-with-next
    489          LOCAL(boolean)
    490          get_dqt (j_decompress_ptr cinfo)
    491          /* Process a DQT marker */
    492          {
   \                     get_dqt:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040A0E1           MOV      R4,R0
    493            INT32 length;
    494            int n, i, prec;
    495            unsigned int tmp;
    496            JQUANT_TBL *quant_ptr;
    497            INPUT_VARS(cinfo);
   \   0000000C   185094E5           LDR      R5,[R4, #+24]
   \   00000010   008095E5           LDR      R8,[R5, #+0]
   \   00000014   049095E5           LDR      R9,[R5, #+4]
    498          
    499            INPUT_2BYTES(cinfo, length, return FALSE);
   \   00000018   000059E3           CMP      R9,#+0
   \   0000001C   0500001A           BNE      ??get_dqt_0
   \   00000020   0C1095E5           LDR      R1,[R5, #+12]
   \   00000024   31FF2FE1           BLX      R1
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   F28FBD08           POPEQ    {R1,R4-R11,PC}
   \   00000030   008095E5           LDR      R8,[R5, #+0]
   \   00000034   049095E5           LDR      R9,[R5, #+4]
   \                     ??get_dqt_0:
   \   00000038   ........           LDRB     R0,[R8], #+1
   \   0000003C   019049E2           SUB      R9,R9,#+1
   \   00000040   000059E3           CMP      R9,#+0
   \   00000044   0064A0E1           LSL      R6,R0,#+8
   \   00000048   0600001A           BNE      ??get_dqt_1
   \   0000004C   0C1095E5           LDR      R1,[R5, #+12]
   \   00000050   0400A0E1           MOV      R0,R4
   \   00000054   31FF2FE1           BLX      R1
   \   00000058   000050E3           CMP      R0,#+0
   \   0000005C   F28FBD08           POPEQ    {R1,R4-R11,PC}
   \   00000060   008095E5           LDR      R8,[R5, #+0]
   \   00000064   049095E5           LDR      R9,[R5, #+4]
   \                     ??get_dqt_1:
   \   00000068   ........           LDRB     R0,[R8], #+1
   \   0000006C   019049E2           SUB      R9,R9,#+1
   \   00000070   060080E0           ADD      R0,R0,R6
    500            length -= 2;
   \   00000074   026040E2           SUB      R6,R0,#+2
   \   00000078   370000EA           B        ??get_dqt_2
    501          
    502            while (length > 0) {
    503              INPUT_BYTE(cinfo, n, return FALSE);
    504              prec = n >> 4;
    505              n &= 0x0F;
    506          
    507              TRACEMS2(cinfo, 1, JTRC_DQT, n, prec);
    508          
    509              if (n >= NUM_QUANT_TBLS)
    510                ERREXIT1(cinfo, JERR_DQT_INDEX, n);
    511                
    512              if (cinfo->quant_tbl_ptrs[n] == NULL)
    513                cinfo->quant_tbl_ptrs[n] = jpeg_alloc_quant_table((j_common_ptr) cinfo);
    514              quant_ptr = cinfo->quant_tbl_ptrs[n];
    515          
    516              for (i = 0; i < DCTSIZE2; i++) {
    517                if (prec)
    518          	INPUT_2BYTES(cinfo, tmp, return FALSE);
    519                else
    520          	INPUT_BYTE(cinfo, tmp, return FALSE);
   \                     ??get_dqt_3:
   \   0000007C   000059E3           CMP      R9,#+0
   \   00000080   0500001A           BNE      ??get_dqt_4
   \   00000084   0400A0E1           MOV      R0,R4
   \   00000088   31FF2FE1           BLX      R1
   \   0000008C   000050E3           CMP      R0,#+0
   \   00000090   F28FBD08           POPEQ    {R1,R4-R11,PC}
   \   00000094   008095E5           LDR      R8,[R5, #+0]
   \   00000098   049095E5           LDR      R9,[R5, #+4]
   \                     ??get_dqt_4:
   \   0000009C   ........           LDRB     R11,[R8], #+1
   \   000000A0   019049E2           SUB      R9,R9,#+1
    521                /* We convert the zigzag-order table to natural array order. */
    522                quant_ptr->quantval[jpeg_natural_order[i]] = (UINT16) tmp;
   \                     ??get_dqt_5:
   \   000000A4   18029FE5           LDR      R0,??get_dqt_6   ;; jpeg_natural_order
   \   000000A8   0A0190E7           LDR      R0,[R0, +R10, LSL #+2]
   \   000000AC   01A08AE2           ADD      R10,R10,#+1
   \   000000B0   800087E0           ADD      R0,R7,R0, LSL #+1
   \   000000B4   B0B0C0E1           STRH     R11,[R0, #+0]
   \   000000B8   40005AE3           CMP      R10,#+64
   \   000000BC   570000BA           BLT      ??get_dqt_7
    523              }
    524          
    525              if (cinfo->err->trace_level >= 2) {
   \   000000C0   000094E5           LDR      R0,[R4, #+0]
   \   000000C4   680090E5           LDR      R0,[R0, #+104]
   \   000000C8   020050E3           CMP      R0,#+2
   \   000000CC   1E0000BA           BLT      ??get_dqt_8
    526                for (i = 0; i < DCTSIZE2; i += 8) {
   \   000000D0   00A0A0E3           MOV      R10,#+0
    527          	TRACEMS8(cinfo, 2, JTRC_QUANTVALS,
    528          		 quant_ptr->quantval[i],   quant_ptr->quantval[i+1],
    529          		 quant_ptr->quantval[i+2], quant_ptr->quantval[i+3],
    530          		 quant_ptr->quantval[i+4], quant_ptr->quantval[i+5],
    531          		 quant_ptr->quantval[i+6], quant_ptr->quantval[i+7]);
   \                     ??get_dqt_9:
   \   000000D4   000094E5           LDR      R0,[R4, #+0]
   \   000000D8   8A1087E0           ADD      R1,R7,R10, LSL #+1
   \   000000DC   B010D1E1           LDRH     R1,[R1, #+0]
   \   000000E0   1810A0E5           STR      R1,[R0, #+24]!
   \   000000E4   8A1087E0           ADD      R1,R7,R10, LSL #+1
   \   000000E8   B220D1E1           LDRH     R2,[R1, #+2]
    532                }
   \   000000EC   08A08AE2           ADD      R10,R10,#+8
   \   000000F0   042080E5           STR      R2,[R0, #+4]
   \   000000F4   B420D1E1           LDRH     R2,[R1, #+4]
   \   000000F8   082080E5           STR      R2,[R0, #+8]
   \   000000FC   B620D1E1           LDRH     R2,[R1, #+6]
   \   00000100   0C2080E5           STR      R2,[R0, #+12]
   \   00000104   B820D1E1           LDRH     R2,[R1, #+8]
   \   00000108   102080E5           STR      R2,[R0, #+16]
   \   0000010C   BA20D1E1           LDRH     R2,[R1, #+10]
   \   00000110   142080E5           STR      R2,[R0, #+20]
   \   00000114   BC20D1E1           LDRH     R2,[R1, #+12]
   \   00000118   182080E5           STR      R2,[R0, #+24]
   \   0000011C   BE10D1E1           LDRH     R1,[R1, #+14]
   \   00000120   1C1080E5           STR      R1,[R0, #+28]
   \   00000124   000094E5           LDR      R0,[R4, #+0]
   \   00000128   5F10A0E3           MOV      R1,#+95
   \   0000012C   141080E5           STR      R1,[R0, #+20]
   \   00000130   002094E5           LDR      R2,[R4, #+0]
   \   00000134   0210A0E3           MOV      R1,#+2
   \   00000138   042092E5           LDR      R2,[R2, #+4]
   \   0000013C   0400A0E1           MOV      R0,R4
   \   00000140   32FF2FE1           BLX      R2
   \   00000144   40005AE3           CMP      R10,#+64
   \   00000148   E1FFFFBA           BLT      ??get_dqt_9
    533              }
    534          
    535              length -= DCTSIZE2+1;
    536              if (prec) length -= DCTSIZE2;
   \                     ??get_dqt_8:
   \   0000014C   00009DE5           LDR      R0,[SP, #+0]
   \   00000150   416046E2           SUB      R6,R6,#+65
   \   00000154   000050E3           CMP      R0,#+0
   \   00000158   40604612           SUBNE    R6,R6,#+64
   \                     ??get_dqt_2:
   \   0000015C   010056E3           CMP      R6,#+1
   \   00000160   4A0000BA           BLT      ??get_dqt_10
   \   00000164   000059E3           CMP      R9,#+0
   \   00000168   0600001A           BNE      ??get_dqt_11
   \   0000016C   0C1095E5           LDR      R1,[R5, #+12]
   \   00000170   0400A0E1           MOV      R0,R4
   \   00000174   31FF2FE1           BLX      R1
   \   00000178   000050E3           CMP      R0,#+0
   \   0000017C   F28FBD08           POPEQ    {R1,R4-R11,PC}
   \   00000180   008095E5           LDR      R8,[R5, #+0]
   \   00000184   049095E5           LDR      R9,[R5, #+4]
   \                     ??get_dqt_11:
   \   00000188   ........           LDRB     R0,[R8], #+1
   \   0000018C   4022A0E1           ASR      R2,R0,#+4
   \   00000190   00208DE5           STR      R2,[SP, #+0]
   \   00000194   0F7000E2           AND      R7,R0,#0xF
   \   00000198   000094E5           LDR      R0,[R4, #+0]
   \   0000019C   5310A0E3           MOV      R1,#+83
   \   000001A0   141080E5           STR      R1,[R0, #+20]
   \   000001A4   000094E5           LDR      R0,[R4, #+0]
   \   000001A8   019049E2           SUB      R9,R9,#+1
   \   000001AC   187080E5           STR      R7,[R0, #+24]
   \   000001B0   000094E5           LDR      R0,[R4, #+0]
   \   000001B4   00109DE5           LDR      R1,[SP, #+0]
   \   000001B8   1C1080E5           STR      R1,[R0, #+28]
   \   000001BC   002094E5           LDR      R2,[R4, #+0]
   \   000001C0   0110A0E3           MOV      R1,#+1
   \   000001C4   042092E5           LDR      R2,[R2, #+4]
   \   000001C8   0400A0E1           MOV      R0,R4
   \   000001CC   32FF2FE1           BLX      R2
   \   000001D0   040057E3           CMP      R7,#+4
   \   000001D4   080000BA           BLT      ??get_dqt_12
   \   000001D8   000094E5           LDR      R0,[R4, #+0]
   \   000001DC   2010A0E3           MOV      R1,#+32
   \   000001E0   141080E5           STR      R1,[R0, #+20]
   \   000001E4   000094E5           LDR      R0,[R4, #+0]
   \   000001E8   187080E5           STR      R7,[R0, #+24]
   \   000001EC   001094E5           LDR      R1,[R4, #+0]
   \   000001F0   0400A0E1           MOV      R0,R4
   \   000001F4   001091E5           LDR      R1,[R1, #+0]
   \   000001F8   31FF2FE1           BLX      R1
   \                     ??get_dqt_12:
   \   000001FC   077184E0           ADD      R7,R4,R7, LSL #+2
   \   00000200   A00097E5           LDR      R0,[R7, #+160]
   \   00000204   000050E3           CMP      R0,#+0
   \   00000208   0200001A           BNE      ??get_dqt_13
   \   0000020C   0400A0E1           MOV      R0,R4
   \   00000210   ........           _BLF     jpeg_alloc_quant_table,??jpeg_alloc_quant_table??rA
   \   00000214   A00087E5           STR      R0,[R7, #+160]
   \                     ??get_dqt_13:
   \   00000218   A07097E5           LDR      R7,[R7, #+160]
   \   0000021C   00A0A0E3           MOV      R10,#+0
   \                     ??get_dqt_7:
   \   00000220   00009DE5           LDR      R0,[SP, #+0]
   \   00000224   0C1095E5           LDR      R1,[R5, #+12]
   \   00000228   000050E3           CMP      R0,#+0
   \   0000022C   92FFFF0A           BEQ      ??get_dqt_3
   \   00000230   000059E3           CMP      R9,#+0
   \   00000234   0500001A           BNE      ??get_dqt_14
   \   00000238   0400A0E1           MOV      R0,R4
   \   0000023C   31FF2FE1           BLX      R1
   \   00000240   000050E3           CMP      R0,#+0
   \   00000244   F28FBD08           POPEQ    {R1,R4-R11,PC}
   \   00000248   008095E5           LDR      R8,[R5, #+0]
   \   0000024C   049095E5           LDR      R9,[R5, #+4]
   \                     ??get_dqt_14:
   \   00000250   ........           LDRB     R0,[R8], #+1
   \   00000254   019049E2           SUB      R9,R9,#+1
   \   00000258   000059E3           CMP      R9,#+0
   \   0000025C   00B4A0E1           LSL      R11,R0,#+8
   \   00000260   0600001A           BNE      ??get_dqt_15
   \   00000264   0C1095E5           LDR      R1,[R5, #+12]
   \   00000268   0400A0E1           MOV      R0,R4
   \   0000026C   31FF2FE1           BLX      R1
   \   00000270   000050E3           CMP      R0,#+0
   \   00000274   F28FBD08           POPEQ    {R1,R4-R11,PC}
   \   00000278   008095E5           LDR      R8,[R5, #+0]
   \   0000027C   049095E5           LDR      R9,[R5, #+4]
   \                     ??get_dqt_15:
   \   00000280   ........           LDRB     R0,[R8], #+1
   \   00000284   019049E2           SUB      R9,R9,#+1
   \   00000288   0BB080E0           ADD      R11,R0,R11
   \   0000028C   84FFFFEA           B        ??get_dqt_5
    537            }
    538          
    539            if (length != 0)
   \                     ??get_dqt_10:
   \   00000290   000056E3           CMP      R6,#+0
   \   00000294   0600000A           BEQ      ??get_dqt_16
    540              ERREXIT(cinfo, JERR_BAD_LENGTH);
   \   00000298   000094E5           LDR      R0,[R4, #+0]
   \   0000029C   0C10A0E3           MOV      R1,#+12
   \   000002A0   141080E5           STR      R1,[R0, #+20]
   \   000002A4   001094E5           LDR      R1,[R4, #+0]
   \   000002A8   0400A0E1           MOV      R0,R4
   \   000002AC   001091E5           LDR      R1,[R1, #+0]
   \   000002B0   31FF2FE1           BLX      R1
    541          
    542            INPUT_SYNC(cinfo);
   \                     ??get_dqt_16:
   \   000002B4   008085E5           STR      R8,[R5, #+0]
   \   000002B8   049085E5           STR      R9,[R5, #+4]
    543            return TRUE;
   \   000002BC   0100A0E3           MOV      R0,#+1
   \   000002C0   F28FBDE8           POP      {R1,R4-R11,PC}   ;; return
   \                     ??get_dqt_6:
   \   000002C4   ........           DC32     jpeg_natural_order
    544          }
    545          
    546          

   \                                 In segment CODE, align 4, keep-with-next
    547          LOCAL(boolean)
    548          get_dri (j_decompress_ptr cinfo)
    549          /* Process a DRI marker */
    550          {
   \                     get_dri:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    551            INT32 length;
    552            unsigned int tmp;
    553            INPUT_VARS(cinfo);
   \   00000008   185094E5           LDR      R5,[R4, #+24]
   \   0000000C   006095E5           LDR      R6,[R5, #+0]
   \   00000010   047095E5           LDR      R7,[R5, #+4]
    554          
    555            INPUT_2BYTES(cinfo, length, return FALSE);
   \   00000014   000057E3           CMP      R7,#+0
   \   00000018   0500001A           BNE      ??get_dri_0
   \   0000001C   0C1095E5           LDR      R1,[R5, #+12]
   \   00000020   31FF2FE1           BLX      R1
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   F081BD08           POPEQ    {R4-R8,PC}
   \   0000002C   006095E5           LDR      R6,[R5, #+0]
   \   00000030   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_dri_0:
   \   00000034   ........           LDRB     R0,[R6], #+1
   \   00000038   017047E2           SUB      R7,R7,#+1
   \   0000003C   000057E3           CMP      R7,#+0
   \   00000040   0084A0E1           LSL      R8,R0,#+8
   \   00000044   0600001A           BNE      ??get_dri_1
   \   00000048   0C1095E5           LDR      R1,[R5, #+12]
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   31FF2FE1           BLX      R1
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   F081BD08           POPEQ    {R4-R8,PC}
   \   0000005C   006095E5           LDR      R6,[R5, #+0]
   \   00000060   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_dri_1:
   \   00000064   ........           LDRB     R0,[R6], #+1
   \   00000068   017047E2           SUB      R7,R7,#+1
   \   0000006C   088080E0           ADD      R8,R0,R8
    556            
    557            if (length != 4)
   \   00000070   040058E3           CMP      R8,#+4
   \   00000074   0600000A           BEQ      ??get_dri_2
    558              ERREXIT(cinfo, JERR_BAD_LENGTH);
   \   00000078   000094E5           LDR      R0,[R4, #+0]
   \   0000007C   0C10A0E3           MOV      R1,#+12
   \   00000080   141080E5           STR      R1,[R0, #+20]
   \   00000084   001094E5           LDR      R1,[R4, #+0]
   \   00000088   0400A0E1           MOV      R0,R4
   \   0000008C   001091E5           LDR      R1,[R1, #+0]
   \   00000090   31FF2FE1           BLX      R1
    559          
    560            INPUT_2BYTES(cinfo, tmp, return FALSE);
   \                     ??get_dri_2:
   \   00000094   000057E3           CMP      R7,#+0
   \   00000098   0600001A           BNE      ??get_dri_3
   \   0000009C   0C1095E5           LDR      R1,[R5, #+12]
   \   000000A0   0400A0E1           MOV      R0,R4
   \   000000A4   31FF2FE1           BLX      R1
   \   000000A8   000050E3           CMP      R0,#+0
   \   000000AC   F081BD08           POPEQ    {R4-R8,PC}
   \   000000B0   006095E5           LDR      R6,[R5, #+0]
   \   000000B4   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_dri_3:
   \   000000B8   ........           LDRB     R0,[R6], #+1
   \   000000BC   017047E2           SUB      R7,R7,#+1
   \   000000C0   000057E3           CMP      R7,#+0
   \   000000C4   0084A0E1           LSL      R8,R0,#+8
   \   000000C8   0600001A           BNE      ??get_dri_4
   \   000000CC   0C1095E5           LDR      R1,[R5, #+12]
   \   000000D0   0400A0E1           MOV      R0,R4
   \   000000D4   31FF2FE1           BLX      R1
   \   000000D8   000050E3           CMP      R0,#+0
   \   000000DC   F081BD08           POPEQ    {R4-R8,PC}
   \   000000E0   006095E5           LDR      R6,[R5, #+0]
   \   000000E4   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_dri_4:
   \   000000E8   ........           LDRB     R0,[R6], #+1
    561          
    562            TRACEMS1(cinfo, 1, JTRC_DRI, tmp);
   \   000000EC   5410A0E3           MOV      R1,#+84
   \   000000F0   088080E0           ADD      R8,R0,R8
   \   000000F4   000094E5           LDR      R0,[R4, #+0]
   \   000000F8   141080E5           STR      R1,[R0, #+20]
   \   000000FC   000094E5           LDR      R0,[R4, #+0]
   \   00000100   0110A0E3           MOV      R1,#+1
   \   00000104   188080E5           STR      R8,[R0, #+24]
   \   00000108   002094E5           LDR      R2,[R4, #+0]
   \   0000010C   0400A0E1           MOV      R0,R4
   \   00000110   042092E5           LDR      R2,[R2, #+4]
   \   00000114   32FF2FE1           BLX      R2
    563          
    564            cinfo->restart_interval = tmp;
   \   00000118   108184E5           STR      R8,[R4, #+272]
    565          
    566            INPUT_SYNC(cinfo);
   \   0000011C   006085E5           STR      R6,[R5, #+0]
   \   00000120   010047E2           SUB      R0,R7,#+1
   \   00000124   040085E5           STR      R0,[R5, #+4]
    567            return TRUE;
   \   00000128   0100A0E3           MOV      R0,#+1
   \   0000012C   F081BDE8           POP      {R4-R8,PC}       ;; return
    568          }
    569          
    570          
    571          /*
    572           * Routines for processing APPn and COM markers.
    573           * These are either saved in memory or discarded, per application request.
    574           * APP0 and APP14 are specially checked to see if they are
    575           * JFIF and Adobe markers, respectively.
    576           */
    577          
    578          #define APP0_DATA_LEN	14	/* Length of interesting data in APP0 */
    579          #define APP14_DATA_LEN	12	/* Length of interesting data in APP14 */
    580          #define APPN_DATA_LEN	14	/* Must be the largest of the above!! */
    581          
    582          

   \                                 In segment CODE, align 4, keep-with-next
    583          LOCAL(void)
    584          examine_app0 (j_decompress_ptr cinfo, JOCTET FAR * data,
    585          	      unsigned int datalen, INT32 remaining)
    586          /* Examine first few bytes from an APP0.
    587           * Take appropriate action if it is a JFIF marker.
    588           * datalen is # of bytes at data[], remaining is length of rest of marker data.
    589           */
    590          {
   \                     examine_app0:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    591            INT32 totallen = (INT32) datalen + remaining;
    592          
    593            if (datalen >= APP0_DATA_LEN &&
    594                GETJOCTET(data[0]) == 0x4A &&
    595                GETJOCTET(data[1]) == 0x46 &&
    596                GETJOCTET(data[2]) == 0x49 &&
    597                GETJOCTET(data[3]) == 0x46 &&
    598                GETJOCTET(data[4]) == 0) {
   \   00000008   000094E5           LDR      R0,[R4, #+0]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   026083E0           ADD      R6,R3,R2
   \   00000014   0E0052E3           CMP      R2,#+14
   \   00000018   5A00003A           BCC      ??examine_app0_0
   \   0000001C   0010D5E5           LDRB     R1,[R5, #+0]
   \   00000020   4A0051E3           CMP      R1,#+74
   \   00000024   0110D505           LDRBEQ   R1,[R5, #+1]
   \   00000028   46005103           CMPEQ    R1,#+70
   \   0000002C   0210D505           LDRBEQ   R1,[R5, #+2]
   \   00000030   49005103           CMPEQ    R1,#+73
   \   00000034   0310D505           LDRBEQ   R1,[R5, #+3]
   \   00000038   46005103           CMPEQ    R1,#+70
   \   0000003C   0410D505           LDRBEQ   R1,[R5, #+4]
   \   00000040   00005103           CMPEQ    R1,#+0
   \   00000044   5100001A           BNE      ??examine_app0_1
    599              /* Found JFIF APP0 marker: save info */
    600              cinfo->saw_JFIF_marker = TRUE;
   \   00000048   0100A0E3           MOV      R0,#+1
   \   0000004C   140184E5           STR      R0,[R4, #+276]
    601              cinfo->JFIF_major_version = GETJOCTET(data[5]);
   \   00000050   0500D5E5           LDRB     R0,[R5, #+5]
    602              cinfo->JFIF_minor_version = GETJOCTET(data[6]);
    603              cinfo->density_unit = GETJOCTET(data[7]);
   \   00000054   477F84E2           ADD      R7,R4,#+284
   \   00000058   1801C4E5           STRB     R0,[R4, #+280]
   \   0000005C   0610D5E5           LDRB     R1,[R5, #+6]
    604              cinfo->X_density = (GETJOCTET(data[8]) << 8) + GETJOCTET(data[9]);
    605              cinfo->Y_density = (GETJOCTET(data[10]) << 8) + GETJOCTET(data[11]);
    606              /* Check version.
    607               * Major version must be 1, anything else signals an incompatible change.
    608               * (We used to treat this as an error, but now it's a nonfatal warning,
    609               * because some bozo at Hijaak couldn't read the spec.)
    610               * Minor version should be 0..2, but process anyway if newer.
    611               */
    612              if (cinfo->JFIF_major_version != 1)
   \   00000060   010050E3           CMP      R0,#+1
   \   00000064   1911C4E5           STRB     R1,[R4, #+281]
   \   00000068   0710D5E5           LDRB     R1,[R5, #+7]
   \   0000006C   1A11C4E5           STRB     R1,[R4, #+282]
   \   00000070   0810D5E5           LDRB     R1,[R5, #+8]
   \   00000074   0920D5E5           LDRB     R2,[R5, #+9]
   \   00000078   011482E0           ADD      R1,R2,R1, LSL #+8
   \   0000007C   B010C7E1           STRH     R1,[R7, #+0]
   \   00000080   0A10D5E5           LDRB     R1,[R5, #+10]
   \   00000084   0B20D5E5           LDRB     R2,[R5, #+11]
   \   00000088   011482E0           ADD      R1,R2,R1, LSL #+8
   \   0000008C   B210C7E1           STRH     R1,[R7, #+2]
   \   00000090   0D00000A           BEQ      ??examine_app0_2
    613                WARNMS2(cinfo, JWRN_JFIF_MAJOR,
    614          	      cinfo->JFIF_major_version, cinfo->JFIF_minor_version);
   \   00000094   000094E5           LDR      R0,[R4, #+0]
   \   00000098   7A10A0E3           MOV      R1,#+122
   \   0000009C   141080E5           STR      R1,[R0, #+20]
   \   000000A0   1811D4E5           LDRB     R1,[R4, #+280]
   \   000000A4   000094E5           LDR      R0,[R4, #+0]
   \   000000A8   181080E5           STR      R1,[R0, #+24]
   \   000000AC   1911D4E5           LDRB     R1,[R4, #+281]
   \   000000B0   000094E5           LDR      R0,[R4, #+0]
   \   000000B4   1C1080E5           STR      R1,[R0, #+28]
   \   000000B8   002094E5           LDR      R2,[R4, #+0]
   \   000000BC   0010E0E3           MVN      R1,#+0
   \   000000C0   042092E5           LDR      R2,[R2, #+4]
   \   000000C4   0400A0E1           MOV      R0,R4
   \   000000C8   32FF2FE1           BLX      R2
    615              /* Generate trace messages */
    616              TRACEMS5(cinfo, 1, JTRC_JFIF,
    617          	     cinfo->JFIF_major_version, cinfo->JFIF_minor_version,
    618          	     cinfo->X_density, cinfo->Y_density, cinfo->density_unit);
   \                     ??examine_app0_2:
   \   000000CC   1811D4E5           LDRB     R1,[R4, #+280]
   \   000000D0   000094E5           LDR      R0,[R4, #+0]
   \   000000D4   1810A0E5           STR      R1,[R0, #+24]!
   \   000000D8   1911D4E5           LDRB     R1,[R4, #+281]
   \   000000DC   041080E5           STR      R1,[R0, #+4]
   \   000000E0   B010D7E1           LDRH     R1,[R7, #+0]
   \   000000E4   081080E5           STR      R1,[R0, #+8]
   \   000000E8   B210D7E1           LDRH     R1,[R7, #+2]
   \   000000EC   0C1080E5           STR      R1,[R0, #+12]
   \   000000F0   1A11D4E5           LDRB     R1,[R4, #+282]
   \   000000F4   101080E5           STR      R1,[R0, #+16]
   \   000000F8   000094E5           LDR      R0,[R4, #+0]
   \   000000FC   5910A0E3           MOV      R1,#+89
   \   00000100   141080E5           STR      R1,[R0, #+20]
   \   00000104   002094E5           LDR      R2,[R4, #+0]
   \   00000108   0110A0E3           MOV      R1,#+1
   \   0000010C   042092E5           LDR      R2,[R2, #+4]
   \   00000110   0400A0E1           MOV      R0,R4
   \   00000114   32FF2FE1           BLX      R2
    619              /* Validate thumbnail dimensions and issue appropriate messages */
    620              if (GETJOCTET(data[12]) | GETJOCTET(data[13]))
   \   00000118   0C00D5E5           LDRB     R0,[R5, #+12]
   \   0000011C   0D10D5E5           LDRB     R1,[R5, #+13]
   \   00000120   000091E1           ORRS     R0,R1,R0
   \   00000124   0D00000A           BEQ      ??examine_app0_3
    621                TRACEMS2(cinfo, 1, JTRC_JFIF_THUMBNAIL,
    622          	       GETJOCTET(data[12]), GETJOCTET(data[13]));
   \   00000128   000094E5           LDR      R0,[R4, #+0]
   \   0000012C   5C10A0E3           MOV      R1,#+92
   \   00000130   141080E5           STR      R1,[R0, #+20]
   \   00000134   0C10D5E5           LDRB     R1,[R5, #+12]
   \   00000138   000094E5           LDR      R0,[R4, #+0]
   \   0000013C   181080E5           STR      R1,[R0, #+24]
   \   00000140   0D10D5E5           LDRB     R1,[R5, #+13]
   \   00000144   000094E5           LDR      R0,[R4, #+0]
   \   00000148   1C1080E5           STR      R1,[R0, #+28]
   \   0000014C   002094E5           LDR      R2,[R4, #+0]
   \   00000150   0110A0E3           MOV      R1,#+1
   \   00000154   042092E5           LDR      R2,[R2, #+4]
   \   00000158   0400A0E1           MOV      R0,R4
   \   0000015C   32FF2FE1           BLX      R2
    623              totallen -= APP0_DATA_LEN;
    624              if (totallen !=
    625          	((INT32)GETJOCTET(data[12]) * (INT32)GETJOCTET(data[13]) * (INT32) 3))
   \                     ??examine_app0_3:
   \   00000160   0C00D5E5           LDRB     R0,[R5, #+12]
   \   00000164   0D10D5E5           LDRB     R1,[R5, #+13]
   \   00000168   0E6046E2           SUB      R6,R6,#+14
   \   0000016C   910000E0           MUL      R0,R1,R0
   \   00000170   800080E0           ADD      R0,R0,R0, LSL #+1
   \   00000174   000056E1           CMP      R6,R0
   \   00000178   F080BD08           POPEQ    {R4-R7,PC}
    626                TRACEMS1(cinfo, 1, JTRC_JFIF_BADTHUMBNAILSIZE, (int) totallen);
   \   0000017C   000094E5           LDR      R0,[R4, #+0]
   \   00000180   5A10A0E3           MOV      R1,#+90
   \   00000184   150000EA           B        ??examine_app0_4
    627            } else if (datalen >= 6 &&
    628                GETJOCTET(data[0]) == 0x4A &&
    629                GETJOCTET(data[1]) == 0x46 &&
    630                GETJOCTET(data[2]) == 0x58 &&
    631                GETJOCTET(data[3]) == 0x58 &&
    632                GETJOCTET(data[4]) == 0) {
   \                     ??examine_app0_0:
   \   00000188   060052E3           CMP      R2,#+6
   \   0000018C   2700003A           BCC      ??examine_app0_5
   \                     ??examine_app0_1:
   \   00000190   0010D5E5           LDRB     R1,[R5, #+0]
   \   00000194   4A0051E3           CMP      R1,#+74
   \   00000198   0110D505           LDRBEQ   R1,[R5, #+1]
   \   0000019C   46005103           CMPEQ    R1,#+70
   \   000001A0   0210D505           LDRBEQ   R1,[R5, #+2]
   \   000001A4   58005103           CMPEQ    R1,#+88
   \   000001A8   0310D505           LDRBEQ   R1,[R5, #+3]
   \   000001AC   58005103           CMPEQ    R1,#+88
   \   000001B0   0410D505           LDRBEQ   R1,[R5, #+4]
   \   000001B4   00005103           CMPEQ    R1,#+0
   \   000001B8   1C00001A           BNE      ??examine_app0_5
    633              /* Found JFIF "JFXX" extension APP0 marker */
    634              /* The library doesn't actually do anything with these,
    635               * but we try to produce a helpful trace message.
    636               */
    637              switch (GETJOCTET(data[5])) {
   \   000001BC   0510D5E5           LDRB     R1,[R5, #+5]
   \   000001C0   101051E2           SUBS     R1,R1,#+16
   \   000001C4   0400000A           BEQ      ??examine_app0_6
   \   000001C8   011051E2           SUBS     R1,R1,#+1
   \   000001CC   0B00000A           BEQ      ??examine_app0_7
   \   000001D0   021051E2           SUBS     R1,R1,#+2
   \   000001D4   0B00000A           BEQ      ??examine_app0_8
   \   000001D8   0C0000EA           B        ??examine_app0_9
    638              case 0x10:
    639                TRACEMS1(cinfo, 1, JTRC_THUMB_JPEG, (int) totallen);
   \                     ??examine_app0_6:
   \   000001DC   6E10A0E3           MOV      R1,#+110
   \                     ??examine_app0_4:
   \   000001E0   141080E5           STR      R1,[R0, #+20]
   \   000001E4   000094E5           LDR      R0,[R4, #+0]
   \   000001E8   186080E5           STR      R6,[R0, #+24]
   \                     ??examine_app0_10:
   \   000001EC   002094E5           LDR      R2,[R4, #+0]
   \   000001F0   0110A0E3           MOV      R1,#+1
   \   000001F4   042092E5           LDR      R2,[R2, #+4]
   \   000001F8   0400A0E1           MOV      R0,R4
   \   000001FC   130000EA           B        ??examine_app0_11
    640                break;
    641              case 0x11:
    642                TRACEMS1(cinfo, 1, JTRC_THUMB_PALETTE, (int) totallen);
   \                     ??examine_app0_7:
   \   00000200   6F10A0E3           MOV      R1,#+111
   \   00000204   F5FFFFEA           B        ??examine_app0_4
    643                break;
    644              case 0x13:
    645                TRACEMS1(cinfo, 1, JTRC_THUMB_RGB, (int) totallen);
   \                     ??examine_app0_8:
   \   00000208   7010A0E3           MOV      R1,#+112
   \   0000020C   F3FFFFEA           B        ??examine_app0_4
    646                break;
    647              default:
    648                TRACEMS2(cinfo, 1, JTRC_JFIF_EXTENSION,
    649          	       GETJOCTET(data[5]), (int) totallen);
   \                     ??examine_app0_9:
   \   00000210   5B10A0E3           MOV      R1,#+91
   \   00000214   141080E5           STR      R1,[R0, #+20]
   \   00000218   0510D5E5           LDRB     R1,[R5, #+5]
   \   0000021C   000094E5           LDR      R0,[R4, #+0]
   \   00000220   181080E5           STR      R1,[R0, #+24]
   \   00000224   000094E5           LDR      R0,[R4, #+0]
   \   00000228   1C6080E5           STR      R6,[R0, #+28]
   \   0000022C   EEFFFFEA           B        ??examine_app0_10
    650                break;
    651              }
    652            } else {
    653              /* Start of APP0 does not match "JFIF" or "JFXX", or too short */
    654              TRACEMS1(cinfo, 1, JTRC_APP0, (int) totallen);
   \                     ??examine_app0_5:
   \   00000230   4F10A0E3           MOV      R1,#+79
   \   00000234   141080E5           STR      R1,[R0, #+20]
   \   00000238   000094E5           LDR      R0,[R4, #+0]
   \   0000023C   0110A0E3           MOV      R1,#+1
   \   00000240   186080E5           STR      R6,[R0, #+24]
   \   00000244   002094E5           LDR      R2,[R4, #+0]
   \   00000248   0400A0E1           MOV      R0,R4
   \   0000024C   042092E5           LDR      R2,[R2, #+4]
   \                     ??examine_app0_11:
   \   00000250   32FF2FE1           BLX      R2
    655            }
    656          }
   \   00000254   F080BDE8           POP      {R4-R7,PC}       ;; return
    657          
    658          

   \                                 In segment CODE, align 4, keep-with-next
    659          LOCAL(void)
    660          examine_app14 (j_decompress_ptr cinfo, JOCTET FAR * data,
    661          	       unsigned int datalen, INT32 remaining)
    662          /* Examine first few bytes from an APP14.
    663           * Take appropriate action if it is an Adobe marker.
    664           * datalen is # of bytes at data[], remaining is length of rest of marker data.
    665           */
    666          {
   \                     examine_app14:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    667            unsigned int version, flags0, flags1, transform;
    668          
    669            if (datalen >= APP14_DATA_LEN &&
    670                GETJOCTET(data[0]) == 0x41 &&
    671                GETJOCTET(data[1]) == 0x64 &&
    672                GETJOCTET(data[2]) == 0x6F &&
    673                GETJOCTET(data[3]) == 0x62 &&
    674                GETJOCTET(data[4]) == 0x65) {
   \   00000004   0C0052E3           CMP      R2,#+12
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   000094E5           LDR      R0,[R4, #+0]
   \   00000010   2400003A           BCC      ??examine_app14_0
   \   00000014   0050D1E5           LDRB     R5,[R1, #+0]
   \   00000018   410055E3           CMP      R5,#+65
   \   0000001C   0150D105           LDRBEQ   R5,[R1, #+1]
   \   00000020   64005503           CMPEQ    R5,#+100
   \   00000024   0250D105           LDRBEQ   R5,[R1, #+2]
   \   00000028   6F005503           CMPEQ    R5,#+111
   \   0000002C   0350D105           LDRBEQ   R5,[R1, #+3]
   \   00000030   62005503           CMPEQ    R5,#+98
   \   00000034   0450D105           LDRBEQ   R5,[R1, #+4]
   \   00000038   65005503           CMPEQ    R5,#+101
   \   0000003C   1900001A           BNE      ??examine_app14_0
    675              /* Found Adobe APP14 marker */
    676              version = (GETJOCTET(data[5]) << 8) + GETJOCTET(data[6]);
    677              flags0 = (GETJOCTET(data[7]) << 8) + GETJOCTET(data[8]);
   \   00000040   0720D1E5           LDRB     R2,[R1, #+7]
   \   00000044   0830D1E5           LDRB     R3,[R1, #+8]
    678              flags1 = (GETJOCTET(data[9]) << 8) + GETJOCTET(data[10]);
   \   00000048   0A50D1E5           LDRB     R5,[R1, #+10]
    679              transform = GETJOCTET(data[11]);
    680              TRACEMS4(cinfo, 1, JTRC_ADOBE, version, flags0, flags1, transform);
   \   0000004C   05C0D1E5           LDRB     R12,[R1, #+5]
   \   00000050   022483E0           ADD      R2,R3,R2, LSL #+8
   \   00000054   0930D1E5           LDRB     R3,[R1, #+9]
   \   00000058   033485E0           ADD      R3,R5,R3, LSL #+8
   \   0000005C   0B50D1E5           LDRB     R5,[R1, #+11]
   \   00000060   0610D1E5           LDRB     R1,[R1, #+6]
   \   00000064   0C1481E0           ADD      R1,R1,R12, LSL #+8
   \   00000068   1810A0E5           STR      R1,[R0, #+24]!
   \   0000006C   042080E5           STR      R2,[R0, #+4]
   \   00000070   083080E5           STR      R3,[R0, #+8]
   \   00000074   0C5080E5           STR      R5,[R0, #+12]
   \   00000078   000094E5           LDR      R0,[R4, #+0]
   \   0000007C   4E10A0E3           MOV      R1,#+78
   \   00000080   141080E5           STR      R1,[R0, #+20]
   \   00000084   002094E5           LDR      R2,[R4, #+0]
   \   00000088   0110A0E3           MOV      R1,#+1
   \   0000008C   042092E5           LDR      R2,[R2, #+4]
   \   00000090   0400A0E1           MOV      R0,R4
   \   00000094   32FF2FE1           BLX      R2
    681              cinfo->saw_Adobe_marker = TRUE;
   \   00000098   0100A0E3           MOV      R0,#+1
   \   0000009C   200184E5           STR      R0,[R4, #+288]
    682              cinfo->Adobe_transform = (UINT8) transform;
   \   000000A0   2451C4E5           STRB     R5,[R4, #+292]
   \   000000A4   3080BDE8           POP      {R4,R5,PC}
    683            } else {
    684              /* Start of APP14 does not match "Adobe", or too short */
    685              TRACEMS1(cinfo, 1, JTRC_APP14, (int) (datalen + remaining));
   \                     ??examine_app14_0:
   \   000000A8   5010A0E3           MOV      R1,#+80
   \   000000AC   141080E5           STR      R1,[R0, #+20]
   \   000000B0   000094E5           LDR      R0,[R4, #+0]
   \   000000B4   021083E0           ADD      R1,R3,R2
   \   000000B8   181080E5           STR      R1,[R0, #+24]
   \   000000BC   002094E5           LDR      R2,[R4, #+0]
   \   000000C0   0110A0E3           MOV      R1,#+1
   \   000000C4   042092E5           LDR      R2,[R2, #+4]
   \   000000C8   0400A0E1           MOV      R0,R4
   \   000000CC   32FF2FE1           BLX      R2
    686            }
    687          }
   \   000000D0   3080BDE8           POP      {R4,R5,PC}       ;; return
    688          
    689          

   \                                 In segment CODE, align 4, keep-with-next
    690          METHODDEF(boolean)
    691          get_interesting_appn (j_decompress_ptr cinfo)
    692          /* Process an APP0 or APP14 marker without saving it */
    693          {
   \                     get_interesting_appn:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
   \   00000008   0040A0E1           MOV      R4,R0
    694            INT32 length;
    695            JOCTET b[APPN_DATA_LEN];
    696            unsigned int i, numtoread;
    697            INPUT_VARS(cinfo);
   \   0000000C   185094E5           LDR      R5,[R4, #+24]
   \   00000010   006095E5           LDR      R6,[R5, #+0]
   \   00000014   047095E5           LDR      R7,[R5, #+4]
    698          
    699            INPUT_2BYTES(cinfo, length, return FALSE);
   \   00000018   000057E3           CMP      R7,#+0
   \   0000001C   0500001A           BNE      ??get_interesting_appn_0
   \   00000020   0C1095E5           LDR      R1,[R5, #+12]
   \   00000024   31FF2FE1           BLX      R1
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   5000000A           BEQ      ??get_interesting_appn_1
   \   00000030   006095E5           LDR      R6,[R5, #+0]
   \   00000034   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_interesting_appn_0:
   \   00000038   ........           LDRB     R0,[R6], #+1
   \   0000003C   017047E2           SUB      R7,R7,#+1
   \   00000040   000057E3           CMP      R7,#+0
   \   00000044   0084A0E1           LSL      R8,R0,#+8
   \   00000048   0600001A           BNE      ??get_interesting_appn_2
   \   0000004C   0C1095E5           LDR      R1,[R5, #+12]
   \   00000050   0400A0E1           MOV      R0,R4
   \   00000054   31FF2FE1           BLX      R1
   \   00000058   000050E3           CMP      R0,#+0
   \   0000005C   4400000A           BEQ      ??get_interesting_appn_1
   \   00000060   006095E5           LDR      R6,[R5, #+0]
   \   00000064   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_interesting_appn_2:
   \   00000068   ........           LDRB     R0,[R6], #+1
   \   0000006C   017047E2           SUB      R7,R7,#+1
    700            length -= 2;
    701          
    702            /* get the interesting part of the marker data */
    703            if (length >= APPN_DATA_LEN)
   \   00000070   00A0A0E3           MOV      R10,#+0
   \   00000074   080080E0           ADD      R0,R0,R8
   \   00000078   028040E2           SUB      R8,R0,#+2
   \   0000007C   0E0058E3           CMP      R8,#+14
    704              numtoread = APPN_DATA_LEN;
   \   00000080   0E90A0A3           MOVGE    R9,#+14
   \   00000084   110000AA           BGE      ??get_interesting_appn_3
    705            else if (length > 0)
   \   00000088   010058E3           CMP      R8,#+1
   \   0000008C   0090A0B3           MOVLT    R9,#+0
    706              numtoread = (unsigned int) length;
   \   00000090   0890A0A1           MOVGE    R9,R8
   \   00000094   0D0000EA           B        ??get_interesting_appn_3
    707            else
    708              numtoread = 0;
    709            for (i = 0; i < numtoread; i++)
    710              INPUT_BYTE(cinfo, b[i], return FALSE);
   \                     ??get_interesting_appn_4:
   \   00000098   000057E3           CMP      R7,#+0
   \   0000009C   0600001A           BNE      ??get_interesting_appn_5
   \   000000A0   0C1095E5           LDR      R1,[R5, #+12]
   \   000000A4   0400A0E1           MOV      R0,R4
   \   000000A8   31FF2FE1           BLX      R1
   \   000000AC   000050E3           CMP      R0,#+0
   \   000000B0   2F00000A           BEQ      ??get_interesting_appn_1
   \   000000B4   006095E5           LDR      R6,[R5, #+0]
   \   000000B8   047095E5           LDR      R7,[R5, #+4]
   \                     ??get_interesting_appn_5:
   \   000000BC   ........           LDRB     R1,[R6], #+1
   \   000000C0   017047E2           SUB      R7,R7,#+1
   \   000000C4   0D00A0E1           MOV      R0,SP
   \   000000C8   0010CAE7           STRB     R1,[R10, +R0]
   \   000000CC   01A08AE2           ADD      R10,R10,#+1
   \                     ??get_interesting_appn_3:
   \   000000D0   09005AE1           CMP      R10,R9
   \   000000D4   EFFFFF3A           BCC      ??get_interesting_appn_4
    711            length -= numtoread;
    712          
    713            /* process it */
    714            switch (cinfo->unread_marker) {
   \   000000D8   A00194E5           LDR      R0,[R4, #+416]
   \   000000DC   098048E0           SUB      R8,R8,R9
   \   000000E0   E00050E2           SUBS     R0,R0,#+224
   \   000000E4   0200000A           BEQ      ??get_interesting_appn_6
   \   000000E8   0E0050E2           SUBS     R0,R0,#+14
   \   000000EC   0600000A           BEQ      ??get_interesting_appn_7
   \   000000F0   0B0000EA           B        ??get_interesting_appn_8
    715            case M_APP0:
    716              examine_app0(cinfo, (JOCTET FAR *) b, numtoread, length);
   \                     ??get_interesting_appn_6:
   \   000000F4   0830A0E1           MOV      R3,R8
   \   000000F8   0920A0E1           MOV      R2,R9
   \   000000FC   0D10A0E1           MOV      R1,SP
   \   00000100   0400A0E1           MOV      R0,R4
   \   00000104   ........           BL       examine_app0
   \   00000108   0F0000EA           B        ??get_interesting_appn_9
    717              break;
    718            case M_APP14:
    719              examine_app14(cinfo, (JOCTET FAR *) b, numtoread, length);
   \                     ??get_interesting_appn_7:
   \   0000010C   0830A0E1           MOV      R3,R8
   \   00000110   0920A0E1           MOV      R2,R9
   \   00000114   0D10A0E1           MOV      R1,SP
   \   00000118   0400A0E1           MOV      R0,R4
   \   0000011C   ........           BL       examine_app14
   \   00000120   090000EA           B        ??get_interesting_appn_9
    720              break;
    721            default:
    722              /* can't get here unless jpeg_save_markers chooses wrong processor */
    723              ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo->unread_marker);
   \                     ??get_interesting_appn_8:
   \   00000124   000094E5           LDR      R0,[R4, #+0]
   \   00000128   4610A0E3           MOV      R1,#+70
   \   0000012C   141080E5           STR      R1,[R0, #+20]
   \   00000130   000094E5           LDR      R0,[R4, #+0]
   \   00000134   A01194E5           LDR      R1,[R4, #+416]
   \   00000138   181080E5           STR      R1,[R0, #+24]
   \   0000013C   001094E5           LDR      R1,[R4, #+0]
   \   00000140   0400A0E1           MOV      R0,R4
   \   00000144   001091E5           LDR      R1,[R1, #+0]
   \   00000148   31FF2FE1           BLX      R1
    724              break;
    725            }
    726          
    727            /* skip any remaining data -- could be lots */
    728            INPUT_SYNC(cinfo);
   \                     ??get_interesting_appn_9:
   \   0000014C   006085E5           STR      R6,[R5, #+0]
   \   00000150   047085E5           STR      R7,[R5, #+4]
    729            if (length > 0)
   \   00000154   010058E3           CMP      R8,#+1
   \   00000158   040000BA           BLT      ??get_interesting_appn_10
    730              (*cinfo->src->skip_input_data) (cinfo, (long) length);
   \   0000015C   182094E5           LDR      R2,[R4, #+24]
   \   00000160   0810A0E1           MOV      R1,R8
   \   00000164   102092E5           LDR      R2,[R2, #+16]
   \   00000168   0400A0E1           MOV      R0,R4
   \   0000016C   32FF2FE1           BLX      R2
    731          
    732            return TRUE;
   \                     ??get_interesting_appn_10:
   \   00000170   0100A0E3           MOV      R0,#+1
   \                     ??get_interesting_appn_1:
   \   00000174   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   00000178   F087BDE8           POP      {R4-R10,PC}      ;; return
    733          }
    734          
    735          
    736          #ifdef SAVE_MARKERS_SUPPORTED
    737          

   \                                 In segment CODE, align 4, keep-with-next
    738          METHODDEF(boolean)
    739          save_marker (j_decompress_ptr cinfo)
    740          /* Save an APPn or COM marker into the marker list */
    741          {
   \                     save_marker:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
   \   00000008   0040A0E1           MOV      R4,R0
    742            my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
   \   0000000C   B81194E5           LDR      R1,[R4, #+440]
   \   00000010   04108DE5           STR      R1,[SP, #+4]
    743            jpeg_saved_marker_ptr cur_marker = marker->cur_marker;
   \   00000014   0100A0E1           MOV      R0,R1
   \   00000018   A48090E5           LDR      R8,[R0, #+164]
   \   0000001C   0010A0E3           MOV      R1,#+0
   \   00000020   00108DE5           STR      R1,[SP, #+0]
    744            unsigned int bytes_read, data_length;
    745            JOCTET FAR * data;
    746            INT32 length = 0;
    747            INPUT_VARS(cinfo);
   \   00000024   185094E5           LDR      R5,[R4, #+24]
    748          
    749            if (cur_marker == NULL) {
   \   00000028   000058E3           CMP      R8,#+0
   \   0000002C   006095E5           LDR      R6,[R5, #+0]
   \   00000030   047095E5           LDR      R7,[R5, #+4]
   \   00000034   4200001A           BNE      ??save_marker_0
    750              /* begin reading a marker */
    751              INPUT_2BYTES(cinfo, length, return FALSE);
   \   00000038   000057E3           CMP      R7,#+0
   \   0000003C   0600001A           BNE      ??save_marker_1
   \   00000040   0C1095E5           LDR      R1,[R5, #+12]
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   31FF2FE1           BLX      R1
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   F68FBD08           POPEQ    {R1,R2,R4-R11,PC}
   \   00000054   006095E5           LDR      R6,[R5, #+0]
   \   00000058   047095E5           LDR      R7,[R5, #+4]
   \                     ??save_marker_1:
   \   0000005C   ........           LDRB     R1,[R6], #+1
   \   00000060   017047E2           SUB      R7,R7,#+1
   \   00000064   000057E3           CMP      R7,#+0
   \   00000068   0114A0E1           LSL      R1,R1,#+8
   \   0000006C   00108DE5           STR      R1,[SP, #+0]
   \   00000070   0600001A           BNE      ??save_marker_2
   \   00000074   0C1095E5           LDR      R1,[R5, #+12]
   \   00000078   0400A0E1           MOV      R0,R4
   \   0000007C   31FF2FE1           BLX      R1
   \   00000080   000050E3           CMP      R0,#+0
   \   00000084   F68FBD08           POPEQ    {R1,R2,R4-R11,PC}
   \   00000088   006095E5           LDR      R6,[R5, #+0]
   \   0000008C   047095E5           LDR      R7,[R5, #+4]
   \                     ??save_marker_2:
   \   00000090   ........           LDRB     R1,[R6], #+1
   \   00000094   00009DE5           LDR      R0,[SP, #+0]
   \   00000098   017047E2           SUB      R7,R7,#+1
   \   0000009C   000081E0           ADD      R0,R1,R0
    752              length -= 2;
   \   000000A0   020040E2           SUB      R0,R0,#+2
   \   000000A4   00008DE5           STR      R0,[SP, #+0]
    753              if (length >= 0) {		/* watch out for bogus length word */
   \   000000A8   000050E3           CMP      R0,#+0
   \   000000AC   2100004A           BMI      ??save_marker_3
    754                /* figure out how much we want to save */
    755                unsigned int limit;
    756                if (cinfo->unread_marker == (int) M_COM)
   \   000000B0   A00194E5           LDR      R0,[R4, #+416]
    757          	limit = marker->length_limit_COM;
    758                else
    759          	limit = marker->length_limit_APPn[cinfo->unread_marker - (int) M_APP0];
    760                if ((unsigned int) length < limit)
    761          	limit = (unsigned int) length;
    762                /* allocate and initialize the marker item */
    763                cur_marker = (jpeg_saved_marker_ptr)
    764          	(*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
    765          				    SIZEOF(struct jpeg_marker_struct) + limit);
   \   000000B4   043094E5           LDR      R3,[R4, #+4]
   \   000000B8   FE0050E3           CMP      R0,#+254
   \   000000BC   04009D05           LDREQ    R0,[SP, #+4]
   \   000000C0   04109D15           LDRNE    R1,[SP, #+4]
   \   000000C4   60909005           LDREQ    R9,[R0, #+96]
   \   000000C8   043093E5           LDR      R3,[R3, #+4]
   \   000000CC   00018110           ADDNE    R0,R1,R0, LSL #+2
   \   000000D0   1C931015           LDRNE    R9,[R0, #-796]
   \   000000D4   00009DE5           LDR      R0,[SP, #+0]
   \   000000D8   0110A0E3           MOV      R1,#+1
   \   000000DC   090050E1           CMP      R0,R9
   \   000000E0   0090A031           MOVCC    R9,R0
   \   000000E4   142089E2           ADD      R2,R9,#+20
   \   000000E8   0400A0E1           MOV      R0,R4
   \   000000EC   33FF2FE1           BLX      R3
   \   000000F0   0080A0E1           MOV      R8,R0
    766                cur_marker->next = NULL;
   \   000000F4   0000A0E3           MOV      R0,#+0
   \   000000F8   000088E5           STR      R0,[R8, #+0]
    767                cur_marker->marker = (UINT8) cinfo->unread_marker;
   \   000000FC   A00194E5           LDR      R0,[R4, #+416]
    768                cur_marker->original_length = (unsigned int) length;
    769                cur_marker->data_length = limit;
    770                /* data area is just beyond the jpeg_marker_struct */
    771                data = cur_marker->data = (JOCTET FAR *) (cur_marker + 1);
    772                marker->cur_marker = cur_marker;
    773                marker->bytes_read = 0;
   \   00000100   0010A0E3           MOV      R1,#+0
   \   00000104   0400C8E5           STRB     R0,[R8, #+4]
   \   00000108   00009DE5           LDR      R0,[SP, #+0]
    774                bytes_read = 0;
   \   0000010C   00B0A0E3           MOV      R11,#+0
   \   00000110   080088E5           STR      R0,[R8, #+8]
   \   00000114   0C9088E5           STR      R9,[R8, #+12]
   \   00000118   140088E2           ADD      R0,R8,#+20
   \   0000011C   100088E5           STR      R0,[R8, #+16]
   \   00000120   00A0A0E1           MOV      R10,R0
   \   00000124   04009DE5           LDR      R0,[SP, #+4]
   \   00000128   A48080E5           STR      R8,[R0, #+164]
   \   0000012C   04009DE5           LDR      R0,[SP, #+4]
   \   00000130   A81080E5           STR      R1,[R0, #+168]
    775                data_length = limit;
   \   00000134   1C0000EA           B        ??save_marker_4
    776              } else {
    777                /* deal with bogus length word */
    778                bytes_read = data_length = 0;
   \                     ??save_marker_3:
   \   00000138   0090A0E3           MOV      R9,#+0
    779                data = NULL;
   \   0000013C   00A0A0E3           MOV      R10,#+0
   \   00000140   2D0000EA           B        ??save_marker_5
    780              }
    781            } else {
    782              /* resume reading a marker */
    783              bytes_read = marker->bytes_read;
   \                     ??save_marker_0:
   \   00000144   A8B090E5           LDR      R11,[R0, #+168]
    784              data_length = cur_marker->data_length;
    785              data = cur_marker->data + bytes_read;
   \   00000148   100098E5           LDR      R0,[R8, #+16]
   \   0000014C   0C9098E5           LDR      R9,[R8, #+12]
   \   00000150   00A08BE0           ADD      R10,R11,R0
   \   00000154   140000EA           B        ??save_marker_4
    786            }
    787          
    788            while (bytes_read < data_length) {
    789              INPUT_SYNC(cinfo);		/* move the restart point to here */
   \                     ??save_marker_6:
   \   00000158   006085E5           STR      R6,[R5, #+0]
   \   0000015C   047085E5           STR      R7,[R5, #+4]
    790              marker->bytes_read = bytes_read;
   \   00000160   04009DE5           LDR      R0,[SP, #+4]
    791              /* If there's not at least one byte in buffer, suspend */
    792              MAKE_BYTE_AVAIL(cinfo, return FALSE);
   \   00000164   000057E3           CMP      R7,#+0
   \   00000168   A8B080E5           STR      R11,[R0, #+168]
   \   0000016C   0600001A           BNE      ??save_marker_7
   \   00000170   0C1095E5           LDR      R1,[R5, #+12]
   \   00000174   0400A0E1           MOV      R0,R4
   \   00000178   31FF2FE1           BLX      R1
   \   0000017C   000050E3           CMP      R0,#+0
   \   00000180   F68FBD08           POPEQ    {R1,R2,R4-R11,PC}
   \   00000184   006095E5           LDR      R6,[R5, #+0]
   \   00000188   047095E5           LDR      R7,[R5, #+4]
   \                     ??save_marker_7:
   \   0000018C   000057E3           CMP      R7,#+0
   \   00000190   F0FFFF0A           BEQ      ??save_marker_6
    793              /* Copy bytes with reasonable rapidity */
    794              while (bytes_read < data_length && bytes_in_buffer > 0) {
    795                *data++ = *next_input_byte++;
   \   00000194   ........           LDRB     R0,[R6], #+1
    796                bytes_in_buffer--;
   \   00000198   017047E2           SUB      R7,R7,#+1
    797                bytes_read++;
   \   0000019C   01B08BE2           ADD      R11,R11,#+1
   \   000001A0   ........           STRB     R0,[R10], #+1
    798              }
   \   000001A4   09005BE1           CMP      R11,R9
   \   000001A8   F7FFFF3A           BCC      ??save_marker_7
    799            }
   \                     ??save_marker_4:
   \   000001AC   09005BE1           CMP      R11,R9
   \   000001B0   E8FFFF3A           BCC      ??save_marker_6
    800          
    801            /* Done reading what we want to read */
    802            if (cur_marker != NULL) {	/* will be NULL if bogus length word */
   \   000001B4   000058E3           CMP      R8,#+0
   \   000001B8   0F00000A           BEQ      ??save_marker_5
    803              /* Add new marker to end of list */
    804              if (cinfo->marker_list == NULL) {
   \   000001BC   2C0194E5           LDR      R0,[R4, #+300]
   \   000001C0   000050E3           CMP      R0,#+0
    805                cinfo->marker_list = cur_marker;
   \   000001C4   2C818405           STREQ    R8,[R4, #+300]
   \   000001C8   0700000A           BEQ      ??save_marker_8
    806              } else {
    807                jpeg_saved_marker_ptr prev = cinfo->marker_list;
   \   000001CC   001090E5           LDR      R1,[R0, #+0]
   \   000001D0   000051E3           CMP      R1,#+0
   \   000001D4   0300000A           BEQ      ??save_marker_9
    808                while (prev->next != NULL)
    809          	prev = prev->next;
   \                     ??save_marker_10:
   \   000001D8   000090E5           LDR      R0,[R0, #+0]
   \   000001DC   001090E5           LDR      R1,[R0, #+0]
   \   000001E0   000051E3           CMP      R1,#+0
   \   000001E4   FBFFFF1A           BNE      ??save_marker_10
    810                prev->next = cur_marker;
   \                     ??save_marker_9:
   \   000001E8   008080E5           STR      R8,[R0, #+0]
    811              }
    812              /* Reset pointer & calc remaining data length */
    813              data = cur_marker->data;
    814              length = cur_marker->original_length - data_length;
   \                     ??save_marker_8:
   \   000001EC   081098E5           LDR      R1,[R8, #+8]
   \   000001F0   10A098E5           LDR      R10,[R8, #+16]
   \   000001F4   091041E0           SUB      R1,R1,R9
   \   000001F8   00108DE5           STR      R1,[SP, #+0]
    815            }
    816            /* Reset to initial state for next marker */
    817            marker->cur_marker = NULL;
   \                     ??save_marker_5:
   \   000001FC   04009DE5           LDR      R0,[SP, #+4]
   \   00000200   0010A0E3           MOV      R1,#+0
   \   00000204   A41080E5           STR      R1,[R0, #+164]
    818          
    819            /* Process the marker if interesting; else just make a generic trace msg */
    820            switch (cinfo->unread_marker) {
   \   00000208   A00194E5           LDR      R0,[R4, #+416]
   \   0000020C   E00050E2           SUBS     R0,R0,#+224
   \   00000210   0200000A           BEQ      ??save_marker_11
   \   00000214   0E0050E2           SUBS     R0,R0,#+14
   \   00000218   0600000A           BEQ      ??save_marker_12
   \   0000021C   0B0000EA           B        ??save_marker_13
    821            case M_APP0:
    822              examine_app0(cinfo, data, data_length, length);
   \                     ??save_marker_11:
   \   00000220   00309DE5           LDR      R3,[SP, #+0]
   \   00000224   0920A0E1           MOV      R2,R9
   \   00000228   0A10A0E1           MOV      R1,R10
   \   0000022C   0400A0E1           MOV      R0,R4
   \   00000230   ........           BL       examine_app0
   \   00000234   140000EA           B        ??save_marker_14
    823              break;
    824            case M_APP14:
    825              examine_app14(cinfo, data, data_length, length);
   \                     ??save_marker_12:
   \   00000238   00309DE5           LDR      R3,[SP, #+0]
   \   0000023C   0920A0E1           MOV      R2,R9
   \   00000240   0A10A0E1           MOV      R1,R10
   \   00000244   0400A0E1           MOV      R0,R4
   \   00000248   ........           BL       examine_app14
   \   0000024C   0E0000EA           B        ??save_marker_14
    826              break;
    827            default:
    828              TRACEMS2(cinfo, 1, JTRC_MISC_MARKER, cinfo->unread_marker,
    829          	     (int) (data_length + length));
   \                     ??save_marker_13:
   \   00000250   000094E5           LDR      R0,[R4, #+0]
   \   00000254   5D10A0E3           MOV      R1,#+93
   \   00000258   141080E5           STR      R1,[R0, #+20]
   \   0000025C   000094E5           LDR      R0,[R4, #+0]
   \   00000260   A01194E5           LDR      R1,[R4, #+416]
   \   00000264   181080E5           STR      R1,[R0, #+24]
   \   00000268   000094E5           LDR      R0,[R4, #+0]
   \   0000026C   00109DE5           LDR      R1,[SP, #+0]
   \   00000270   091081E0           ADD      R1,R1,R9
   \   00000274   1C1080E5           STR      R1,[R0, #+28]
   \   00000278   002094E5           LDR      R2,[R4, #+0]
   \   0000027C   0110A0E3           MOV      R1,#+1
   \   00000280   042092E5           LDR      R2,[R2, #+4]
   \   00000284   0400A0E1           MOV      R0,R4
   \   00000288   32FF2FE1           BLX      R2
    830              break;
    831            }
    832          
    833            /* skip any remaining data -- could be lots */
    834            INPUT_SYNC(cinfo);		/* do before skip_input_data */
   \                     ??save_marker_14:
   \   0000028C   006085E5           STR      R6,[R5, #+0]
   \   00000290   047085E5           STR      R7,[R5, #+4]
    835            if (length > 0)
   \   00000294   00009DE5           LDR      R0,[SP, #+0]
   \   00000298   010050E3           CMP      R0,#+1
   \   0000029C   040000BA           BLT      ??save_marker_15
    836              (*cinfo->src->skip_input_data) (cinfo, (long) length);
   \   000002A0   182094E5           LDR      R2,[R4, #+24]
   \   000002A4   0010A0E1           MOV      R1,R0
   \   000002A8   102092E5           LDR      R2,[R2, #+16]
   \   000002AC   0400A0E1           MOV      R0,R4
   \   000002B0   32FF2FE1           BLX      R2
    837          
    838            return TRUE;
   \                     ??save_marker_15:
   \   000002B4   0100A0E3           MOV      R0,#+1
   \   000002B8   F68FBDE8           POP      {R1,R2,R4-R11,PC}  ;; return
    839          }
    840          
    841          #endif /* SAVE_MARKERS_SUPPORTED */
    842          
    843          

   \                                 In segment CODE, align 4, keep-with-next
    844          METHODDEF(boolean)
    845          skip_variable (j_decompress_ptr cinfo)
    846          /* Skip over an unknown or uninteresting variable-length marker */
    847          {
   \                     skip_variable:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    848            INT32 length;
    849            INPUT_VARS(cinfo);
   \   00000008   185094E5           LDR      R5,[R4, #+24]
   \   0000000C   006095E5           LDR      R6,[R5, #+0]
   \   00000010   047095E5           LDR      R7,[R5, #+4]
    850          
    851            INPUT_2BYTES(cinfo, length, return FALSE);
   \   00000014   000057E3           CMP      R7,#+0
   \   00000018   0500001A           BNE      ??skip_variable_0
   \   0000001C   0C1095E5           LDR      R1,[R5, #+12]
   \   00000020   31FF2FE1           BLX      R1
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   F081BD08           POPEQ    {R4-R8,PC}
   \   0000002C   006095E5           LDR      R6,[R5, #+0]
   \   00000030   047095E5           LDR      R7,[R5, #+4]
   \                     ??skip_variable_0:
   \   00000034   ........           LDRB     R0,[R6], #+1
   \   00000038   017047E2           SUB      R7,R7,#+1
   \   0000003C   000057E3           CMP      R7,#+0
   \   00000040   0084A0E1           LSL      R8,R0,#+8
   \   00000044   0600001A           BNE      ??skip_variable_1
   \   00000048   0C1095E5           LDR      R1,[R5, #+12]
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   31FF2FE1           BLX      R1
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   F081BD08           POPEQ    {R4-R8,PC}
   \   0000005C   006095E5           LDR      R6,[R5, #+0]
   \   00000060   047095E5           LDR      R7,[R5, #+4]
   \                     ??skip_variable_1:
   \   00000064   ........           LDRB     R0,[R6], #+1
    852            length -= 2;
    853            
    854            TRACEMS2(cinfo, 1, JTRC_MISC_MARKER, cinfo->unread_marker, (int) length);
   \   00000068   5D10A0E3           MOV      R1,#+93
   \   0000006C   080080E0           ADD      R0,R0,R8
   \   00000070   028040E2           SUB      R8,R0,#+2
   \   00000074   000094E5           LDR      R0,[R4, #+0]
   \   00000078   141080E5           STR      R1,[R0, #+20]
   \   0000007C   000094E5           LDR      R0,[R4, #+0]
   \   00000080   A01194E5           LDR      R1,[R4, #+416]
   \   00000084   181080E5           STR      R1,[R0, #+24]
   \   00000088   000094E5           LDR      R0,[R4, #+0]
   \   0000008C   0110A0E3           MOV      R1,#+1
   \   00000090   1C8080E5           STR      R8,[R0, #+28]
   \   00000094   002094E5           LDR      R2,[R4, #+0]
   \   00000098   0400A0E1           MOV      R0,R4
   \   0000009C   042092E5           LDR      R2,[R2, #+4]
   \   000000A0   32FF2FE1           BLX      R2
    855          
    856            INPUT_SYNC(cinfo);		/* do before skip_input_data */
   \   000000A4   006085E5           STR      R6,[R5, #+0]
   \   000000A8   010047E2           SUB      R0,R7,#+1
   \   000000AC   040085E5           STR      R0,[R5, #+4]
    857            if (length > 0)
   \   000000B0   010058E3           CMP      R8,#+1
   \   000000B4   040000BA           BLT      ??skip_variable_2
    858              (*cinfo->src->skip_input_data) (cinfo, (long) length);
   \   000000B8   182094E5           LDR      R2,[R4, #+24]
   \   000000BC   0810A0E1           MOV      R1,R8
   \   000000C0   102092E5           LDR      R2,[R2, #+16]
   \   000000C4   0400A0E1           MOV      R0,R4
   \   000000C8   32FF2FE1           BLX      R2
    859          
    860            return TRUE;
   \                     ??skip_variable_2:
   \   000000CC   0100A0E3           MOV      R0,#+1
   \   000000D0   F081BDE8           POP      {R4-R8,PC}       ;; return
    861          }
    862          
    863          
    864          /*
    865           * Find the next JPEG marker, save it in cinfo->unread_marker.
    866           * Returns FALSE if had to suspend before reaching a marker;
    867           * in that case cinfo->unread_marker is unchanged.
    868           *
    869           * Note that the result might not be a valid marker code,
    870           * but it will never be 0 or FF.
    871           */
    872          

   \                                 In segment CODE, align 4, keep-with-next
    873          LOCAL(boolean)
    874          next_marker (j_decompress_ptr cinfo)
    875          {
   \                     next_marker:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    876            int c;
    877            INPUT_VARS(cinfo);
   \   00000008   185094E5           LDR      R5,[R4, #+24]
   \   0000000C   006095E5           LDR      R6,[R5, #+0]
   \   00000010   047095E5           LDR      R7,[R5, #+4]
   \   00000014   040000EA           B        ??next_marker_0
    878          
    879            for (;;) {
    880              INPUT_BYTE(cinfo, c, return FALSE);
    881              /* Skip any non-FF bytes.
    882               * This may look a bit inefficient, but it will not occur in a valid file.
    883               * We sync after each discarded byte so that a suspending data source
    884               * can discard the byte from its buffer.
    885               */
    886              while (c != 0xFF) {
    887                cinfo->marker->discarded_bytes++;
    888                INPUT_SYNC(cinfo);
    889                INPUT_BYTE(cinfo, c, return FALSE);
    890              }
    891              /* This loop swallows any duplicate FF bytes.  Extra FFs are legal as
    892               * pad bytes, so don't count them in discarded_bytes.  We assume there
    893               * will not be so many consecutive FF bytes as to overflow a suspending
    894               * data source's input buffer.
    895               */
    896              do {
    897                INPUT_BYTE(cinfo, c, return FALSE);
    898              } while (c == 0xFF);
    899              if (c != 0)
    900                break;			/* found a valid marker, exit loop */
    901              /* Reach here if we found a stuffed-zero data sequence (FF/00).
    902               * Discard it and loop back to try again.
    903               */
    904              cinfo->marker->discarded_bytes += 2;
   \                     ??next_marker_1:
   \   00000018   181090E5           LDR      R1,[R0, #+24]
   \   0000001C   021081E2           ADD      R1,R1,#+2
   \   00000020   181080E5           STR      R1,[R0, #+24]
    905              INPUT_SYNC(cinfo);
   \   00000024   006085E5           STR      R6,[R5, #+0]
   \   00000028   047085E5           STR      R7,[R5, #+4]
   \                     ??next_marker_0:
   \   0000002C   000057E3           CMP      R7,#+0
   \   00000030   1400001A           BNE      ??next_marker_2
   \   00000034   0C1095E5           LDR      R1,[R5, #+12]
   \   00000038   0400A0E1           MOV      R0,R4
   \   0000003C   31FF2FE1           BLX      R1
   \   00000040   000050E3           CMP      R0,#+0
   \   00000044   0D00001A           BNE      ??next_marker_3
   \   00000048   F081BDE8           POP      {R4-R8,PC}
   \                     ??next_marker_4:
   \   0000004C   B80194E5           LDR      R0,[R4, #+440]
   \   00000050   000057E3           CMP      R7,#+0
   \   00000054   181090E5           LDR      R1,[R0, #+24]
   \   00000058   011081E2           ADD      R1,R1,#+1
   \   0000005C   181080E5           STR      R1,[R0, #+24]
   \   00000060   006085E5           STR      R6,[R5, #+0]
   \   00000064   047085E5           STR      R7,[R5, #+4]
   \   00000068   0600001A           BNE      ??next_marker_2
   \   0000006C   0C1095E5           LDR      R1,[R5, #+12]
   \   00000070   0400A0E1           MOV      R0,R4
   \   00000074   31FF2FE1           BLX      R1
   \   00000078   000050E3           CMP      R0,#+0
   \   0000007C   F081BD08           POPEQ    {R4-R8,PC}
   \                     ??next_marker_3:
   \   00000080   006095E5           LDR      R6,[R5, #+0]
   \   00000084   047095E5           LDR      R7,[R5, #+4]
   \                     ??next_marker_2:
   \   00000088   ........           LDRB     R8,[R6], #+1
   \   0000008C   017047E2           SUB      R7,R7,#+1
   \   00000090   FF0058E3           CMP      R8,#+255
   \   00000094   ECFFFF1A           BNE      ??next_marker_4
   \                     ??next_marker_5:
   \   00000098   000057E3           CMP      R7,#+0
   \   0000009C   0600001A           BNE      ??next_marker_6
   \   000000A0   0C1095E5           LDR      R1,[R5, #+12]
   \   000000A4   0400A0E1           MOV      R0,R4
   \   000000A8   31FF2FE1           BLX      R1
   \   000000AC   000050E3           CMP      R0,#+0
   \   000000B0   F081BD08           POPEQ    {R4-R8,PC}
   \   000000B4   006095E5           LDR      R6,[R5, #+0]
   \   000000B8   047095E5           LDR      R7,[R5, #+4]
   \                     ??next_marker_6:
   \   000000BC   ........           LDRB     R8,[R6], #+1
   \   000000C0   017047E2           SUB      R7,R7,#+1
   \   000000C4   FF0058E3           CMP      R8,#+255
   \   000000C8   F2FFFF0A           BEQ      ??next_marker_5
   \   000000CC   B80194E5           LDR      R0,[R4, #+440]
   \   000000D0   000058E3           CMP      R8,#+0
   \   000000D4   CFFFFF0A           BEQ      ??next_marker_1
    906            }
    907          
    908            if (cinfo->marker->discarded_bytes != 0) {
   \   000000D8   180090E5           LDR      R0,[R0, #+24]
   \   000000DC   000050E3           CMP      R0,#+0
   \   000000E0   1000000A           BEQ      ??next_marker_7
    909              WARNMS2(cinfo, JWRN_EXTRANEOUS_DATA, cinfo->marker->discarded_bytes, c);
   \   000000E4   000094E5           LDR      R0,[R4, #+0]
   \   000000E8   7710A0E3           MOV      R1,#+119
   \   000000EC   141080E5           STR      R1,[R0, #+20]
   \   000000F0   B81194E5           LDR      R1,[R4, #+440]
   \   000000F4   000094E5           LDR      R0,[R4, #+0]
   \   000000F8   181091E5           LDR      R1,[R1, #+24]
   \   000000FC   181080E5           STR      R1,[R0, #+24]
   \   00000100   000094E5           LDR      R0,[R4, #+0]
   \   00000104   0010E0E3           MVN      R1,#+0
   \   00000108   1C8080E5           STR      R8,[R0, #+28]
   \   0000010C   002094E5           LDR      R2,[R4, #+0]
   \   00000110   0400A0E1           MOV      R0,R4
   \   00000114   042092E5           LDR      R2,[R2, #+4]
   \   00000118   32FF2FE1           BLX      R2
    910              cinfo->marker->discarded_bytes = 0;
   \   0000011C   B80194E5           LDR      R0,[R4, #+440]
   \   00000120   0010A0E3           MOV      R1,#+0
   \   00000124   181080E5           STR      R1,[R0, #+24]
    911            }
    912          
    913            cinfo->unread_marker = c;
   \                     ??next_marker_7:
   \   00000128   A08184E5           STR      R8,[R4, #+416]
    914          
    915            INPUT_SYNC(cinfo);
   \   0000012C   006085E5           STR      R6,[R5, #+0]
   \   00000130   047085E5           STR      R7,[R5, #+4]
    916            return TRUE;
   \   00000134   0100A0E3           MOV      R0,#+1
   \   00000138   F081BDE8           POP      {R4-R8,PC}       ;; return
    917          }
    918          
    919          

   \                                 In segment CODE, align 4, keep-with-next
    920          LOCAL(boolean)
    921          first_marker (j_decompress_ptr cinfo)
    922          /* Like next_marker, but used to obtain the initial SOI marker. */
    923          /* For this marker, we do not allow preceding garbage or fill; otherwise,
    924           * we might well scan an entire input file before realizing it ain't JPEG.
    925           * If an application wants to process non-JFIF files, it must seek to the
    926           * SOI before calling the JPEG library.
    927           */
    928          {
   \                     first_marker:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    929            int c, c2;
    930            INPUT_VARS(cinfo);
   \   00000008   185094E5           LDR      R5,[R4, #+24]
   \   0000000C   007095E5           LDR      R7,[R5, #+0]
   \   00000010   048095E5           LDR      R8,[R5, #+4]
    931          
    932            INPUT_BYTE(cinfo, c, return FALSE);
   \   00000014   000058E3           CMP      R8,#+0
   \   00000018   0500001A           BNE      ??first_marker_0
   \   0000001C   0C1095E5           LDR      R1,[R5, #+12]
   \   00000020   31FF2FE1           BLX      R1
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   F083BD08           POPEQ    {R4-R9,PC}
   \   0000002C   007095E5           LDR      R7,[R5, #+0]
   \   00000030   048095E5           LDR      R8,[R5, #+4]
   \                     ??first_marker_0:
   \   00000034   ........           LDRB     R6,[R7], #+1
   \   00000038   018058E2           SUBS     R8,R8,#+1
    933            INPUT_BYTE(cinfo, c2, return FALSE);
   \   0000003C   0600001A           BNE      ??first_marker_1
   \   00000040   0C1095E5           LDR      R1,[R5, #+12]
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   31FF2FE1           BLX      R1
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   F083BD08           POPEQ    {R4-R9,PC}
   \   00000054   007095E5           LDR      R7,[R5, #+0]
   \   00000058   048095E5           LDR      R8,[R5, #+4]
   \                     ??first_marker_1:
   \   0000005C   ........           LDRB     R9,[R7], #+1
    934            if (c != 0xFF || c2 != (int) M_SOI)
   \   00000060   FF0056E3           CMP      R6,#+255
   \   00000064   D8005903           CMPEQ    R9,#+216
   \   00000068   0A00000A           BEQ      ??first_marker_2
    935              ERREXIT2(cinfo, JERR_NO_SOI, c, c2);
   \   0000006C   000094E5           LDR      R0,[R4, #+0]
   \   00000070   3710A0E3           MOV      R1,#+55
   \   00000074   141080E5           STR      R1,[R0, #+20]
   \   00000078   000094E5           LDR      R0,[R4, #+0]
   \   0000007C   186080E5           STR      R6,[R0, #+24]
   \   00000080   000094E5           LDR      R0,[R4, #+0]
   \   00000084   1C9080E5           STR      R9,[R0, #+28]
   \   00000088   001094E5           LDR      R1,[R4, #+0]
   \   0000008C   0400A0E1           MOV      R0,R4
   \   00000090   001091E5           LDR      R1,[R1, #+0]
   \   00000094   31FF2FE1           BLX      R1
    936          
    937            cinfo->unread_marker = c2;
   \                     ??first_marker_2:
   \   00000098   A09184E5           STR      R9,[R4, #+416]
    938          
    939            INPUT_SYNC(cinfo);
   \   0000009C   007085E5           STR      R7,[R5, #+0]
   \   000000A0   010048E2           SUB      R0,R8,#+1
   \   000000A4   040085E5           STR      R0,[R5, #+4]
    940            return TRUE;
   \   000000A8   0100A0E3           MOV      R0,#+1
   \   000000AC   F083BDE8           POP      {R4-R9,PC}       ;; return
    941          }
    942          
    943          
    944          /*
    945           * Read markers until SOS or EOI.
    946           *
    947           * Returns same codes as are defined for jpeg_consume_input:
    948           * JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
    949           */
    950          

   \                                 In segment CODE, align 4, keep-with-next
    951          METHODDEF(int)
    952          read_markers (j_decompress_ptr cinfo)
    953          {
   \                     read_markers:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    954            /* Outer loop repeats once for each marker. */
    955            for (;;) {
    956              /* Collect the marker proper, unless we already did. */
    957              /* NB: first_marker() enforces the requirement that SOI appear first. */
    958              if (cinfo->unread_marker == 0) {
   \   00000008   A00194E5           LDR      R0,[R4, #+416]
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0900001A           BNE      ??read_markers_1
    959                if (! cinfo->marker->saw_SOI) {
   \                     ??read_markers_2:
   \   00000014   B80194E5           LDR      R0,[R4, #+440]
   \   00000018   0C0090E5           LDR      R0,[R0, #+12]
   \   0000001C   000050E3           CMP      R0,#+0
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   0100001A           BNE      ??read_markers_3
    960          	if (! first_marker(cinfo))
   \   00000028   ........           BL       first_marker
   \   0000002C   000000EA           B        ??read_markers_4
    961          	  return JPEG_SUSPENDED;
    962                } else {
    963          	if (! next_marker(cinfo))
   \                     ??read_markers_3:
   \   00000030   ........           BL       next_marker
   \                     ??read_markers_4:
   \   00000034   000050E3           CMP      R0,#+0
    964          	  return JPEG_SUSPENDED;
   \   00000038   3080BD08           POPEQ    {R4,R5,PC}
    965                }
    966              }
    967              /* At this point cinfo->unread_marker contains the marker code and the
    968               * input point is just past the marker proper, but before any parameters.
    969               * A suspension will cause us to return with this state still true.
    970               */
    971              switch (cinfo->unread_marker) {
   \                     ??read_markers_1:
   \   0000003C   A02194E5           LDR      R2,[R4, #+416]
   \   00000040   B81194E5           LDR      R1,[R4, #+440]
   \   00000044   000094E5           LDR      R0,[R4, #+0]
   \   00000048   0050A0E3           MOV      R5,#+0
   \   0000004C   013042E2           SUB      R3,R2,#+1
   \   00000050   FD0053E3           CMP      R3,#+253
   \   00000054   8B00008A           BHI      ??read_markers_5
   \   00000058   01CF8FE2           ADR      R12,??read_markers_0
   \   0000005C   03C0DCE7           LDRB     R12,[R12, R3]
   \   00000060   0CF18FE0           ADD      PC,PC,R12, LSL #+2
   \                     ??read_markers_0:
   \   00000064   7A888888           DC8      +122,+136,+136,+136
   \   00000068   88888888           DC8      +136,+136,+136,+136
   \   0000006C   88888888           DC8      +136,+136,+136,+136
   \   00000070   88888888           DC8      +136,+136,+136,+136
   \   00000074   88888888           DC8      +136,+136,+136,+136
   \   00000078   88888888           DC8      +136,+136,+136,+136
   \   0000007C   88888888           DC8      +136,+136,+136,+136
   \   00000080   88888888           DC8      +136,+136,+136,+136
   \   00000084   88888888           DC8      +136,+136,+136,+136
   \   00000088   88888888           DC8      +136,+136,+136,+136
   \   0000008C   88888888           DC8      +136,+136,+136,+136
   \   00000090   88888888           DC8      +136,+136,+136,+136
   \   00000094   88888888           DC8      +136,+136,+136,+136
   \   00000098   88888888           DC8      +136,+136,+136,+136
   \   0000009C   88888888           DC8      +136,+136,+136,+136
   \   000000A0   88888888           DC8      +136,+136,+136,+136
   \   000000A4   88888888           DC8      +136,+136,+136,+136
   \   000000A8   88888888           DC8      +136,+136,+136,+136
   \   000000AC   88888888           DC8      +136,+136,+136,+136
   \   000000B0   88888888           DC8      +136,+136,+136,+136
   \   000000B4   88888888           DC8      +136,+136,+136,+136
   \   000000B8   88888888           DC8      +136,+136,+136,+136
   \   000000BC   88888888           DC8      +136,+136,+136,+136
   \   000000C0   88888888           DC8      +136,+136,+136,+136
   \   000000C4   88888888           DC8      +136,+136,+136,+136
   \   000000C8   88888888           DC8      +136,+136,+136,+136
   \   000000CC   88888888           DC8      +136,+136,+136,+136
   \   000000D0   88888888           DC8      +136,+136,+136,+136
   \   000000D4   88888888           DC8      +136,+136,+136,+136
   \   000000D8   88888888           DC8      +136,+136,+136,+136
   \   000000DC   88888888           DC8      +136,+136,+136,+136
   \   000000E0   88888888           DC8      +136,+136,+136,+136
   \   000000E4   88888888           DC8      +136,+136,+136,+136
   \   000000E8   88888888           DC8      +136,+136,+136,+136
   \   000000EC   88888888           DC8      +136,+136,+136,+136
   \   000000F0   88888888           DC8      +136,+136,+136,+136
   \   000000F4   88888888           DC8      +136,+136,+136,+136
   \   000000F8   88888888           DC8      +136,+136,+136,+136
   \   000000FC   88888888           DC8      +136,+136,+136,+136
   \   00000100   88888888           DC8      +136,+136,+136,+136
   \   00000104   88888888           DC8      +136,+136,+136,+136
   \   00000108   88888888           DC8      +136,+136,+136,+136
   \   0000010C   88888888           DC8      +136,+136,+136,+136
   \   00000110   88888888           DC8      +136,+136,+136,+136
   \   00000114   88888888           DC8      +136,+136,+136,+136
   \   00000118   88888888           DC8      +136,+136,+136,+136
   \   0000011C   88888888           DC8      +136,+136,+136,+136
   \   00000120   88888842           DC8      +136,+136,+136,+66
   \   00000124   42445167           DC8      +66,+68,+81,+103
   \   00000128   51515151           DC8      +81,+81,+81,+81
   \   0000012C   474A5164           DC8      +71,+74,+81,+100
   \   00000130   5151517A           DC8      +81,+81,+81,+122
   \   00000134   7A7A7A7A           DC8      +122,+122,+122,+122
   \   00000138   7A7A7A3F           DC8      +122,+122,+122,+63
   \   0000013C   5A536A85           DC8      +90,+83,+106,+133
   \   00000140   6D888870           DC8      +109,+136,+136,+112
   \   00000144   70707070           DC8      +112,+112,+112,+112
   \   00000148   70707070           DC8      +112,+112,+112,+112
   \   0000014C   70707070           DC8      +112,+112,+112,+112
   \   00000150   70707088           DC8      +112,+112,+112,+136
   \   00000154   88888888           DC8      +136,+136,+136,+136
   \   00000158   88888888           DC8      +136,+136,+136,+136
   \   0000015C   88888888           DC8      +136,+136,+136,+136
   \   00000160   88770000           DC8      +136,+119,+0,+0
    972              case M_SOI:
    973                if (! get_soi(cinfo))
   \                     ??read_markers_6:
   \   00000164   0400A0E1           MOV      R0,R4
   \   00000168   ........           BL       get_soi
   \   0000016C   0B0000EA           B        ??read_markers_7
    974          	return JPEG_SUSPENDED;
    975                break;
    976          
    977              case M_SOF0:		/* Baseline */
    978              case M_SOF1:		/* Extended sequential, Huffman */
    979                if (! get_sof(cinfo, FALSE, FALSE))
   \                     ??read_markers_8:
   \   00000170   0020A0E3           MOV      R2,#+0
   \   00000174   060000EA           B        ??read_markers_9
    980          	return JPEG_SUSPENDED;
    981                break;
    982          
    983              case M_SOF2:		/* Progressive, Huffman */
    984                if (! get_sof(cinfo, TRUE, FALSE))
   \                     ??read_markers_10:
   \   00000178   0020A0E3           MOV      R2,#+0
   \   0000017C   0110A0E3           MOV      R1,#+1
   \   00000180   040000EA           B        ??read_markers_11
    985          	return JPEG_SUSPENDED;
    986                break;
    987          
    988              case M_SOF9:		/* Extended sequential, arithmetic */
    989                if (! get_sof(cinfo, FALSE, TRUE))
   \                     ??read_markers_12:
   \   00000184   0120A0E3           MOV      R2,#+1
   \   00000188   0010A0E3           MOV      R1,#+0
   \   0000018C   010000EA           B        ??read_markers_11
    990          	return JPEG_SUSPENDED;
    991                break;
    992          
    993              case M_SOF10:		/* Progressive, arithmetic */
    994                if (! get_sof(cinfo, TRUE, TRUE))
   \                     ??read_markers_13:
   \   00000190   0120A0E3           MOV      R2,#+1
   \                     ??read_markers_9:
   \   00000194   0210A0E1           MOV      R1,R2
   \                     ??read_markers_11:
   \   00000198   0400A0E1           MOV      R0,R4
   \   0000019C   ........           BL       get_sof
   \                     ??read_markers_7:
   \   000001A0   000050E3           CMP      R0,#+0
   \   000001A4   4000001A           BNE      ??read_markers_14
    995          	return JPEG_SUSPENDED;
   \   000001A8   3080BDE8           POP      {R4,R5,PC}
    996                break;
    997          
    998              /* Currently unsupported SOFn types */
    999              case M_SOF3:		/* Lossless, Huffman */
   1000              case M_SOF5:		/* Differential sequential, Huffman */
   1001              case M_SOF6:		/* Differential progressive, Huffman */
   1002              case M_SOF7:		/* Differential lossless, Huffman */
   1003              case M_JPG:			/* Reserved for JPEG extensions */
   1004              case M_SOF11:		/* Lossless, arithmetic */
   1005              case M_SOF13:		/* Differential sequential, arithmetic */
   1006              case M_SOF14:		/* Differential progressive, arithmetic */
   1007              case M_SOF15:		/* Differential lossless, arithmetic */
   1008                ERREXIT1(cinfo, JERR_SOF_UNSUPPORTED, cinfo->unread_marker);
   \                     ??read_markers_15:
   \   000001AC   3E10A0E3           MOV      R1,#+62
   \   000001B0   350000EA           B        ??read_markers_16
   1009                break;
   1010          
   1011              case M_SOS:
   1012                if (! get_sos(cinfo))
   \                     ??read_markers_17:
   \   000001B4   0400A0E1           MOV      R0,R4
   \   000001B8   ........           BL       get_sos
   \   000001BC   000050E3           CMP      R0,#+0
   1013          	return JPEG_SUSPENDED;
   \   000001C0   3080BD08           POPEQ    {R4,R5,PC}
   1014                cinfo->unread_marker = 0;	/* processed the marker */
   \   000001C4   A05184E5           STR      R5,[R4, #+416]
   1015                return JPEG_REACHED_SOS;
   \   000001C8   0100A0E3           MOV      R0,#+1
   \   000001CC   3080BDE8           POP      {R4,R5,PC}
   1016              
   1017              case M_EOI:
   1018                TRACEMS(cinfo, 1, JTRC_EOI);
   \                     ??read_markers_18:
   \   000001D0   5710A0E3           MOV      R1,#+87
   \   000001D4   141080E5           STR      R1,[R0, #+20]
   \   000001D8   002094E5           LDR      R2,[R4, #+0]
   \   000001DC   0110A0E3           MOV      R1,#+1
   \   000001E0   042092E5           LDR      R2,[R2, #+4]
   \   000001E4   0400A0E1           MOV      R0,R4
   \   000001E8   32FF2FE1           BLX      R2
   1019                cinfo->unread_marker = 0;	/* processed the marker */
   \   000001EC   A05184E5           STR      R5,[R4, #+416]
   1020                return JPEG_REACHED_EOI;
   \   000001F0   0200A0E3           MOV      R0,#+2
   \   000001F4   3080BDE8           POP      {R4,R5,PC}
   1021                
   1022              case M_DAC:
   1023                if (! get_dac(cinfo))
   \                     ??read_markers_19:
   \   000001F8   0400A0E1           MOV      R0,R4
   \   000001FC   ........           BL       get_dac
   \   00000200   E6FFFFEA           B        ??read_markers_7
   1024          	return JPEG_SUSPENDED;
   1025                break;
   1026                
   1027              case M_DHT:
   1028                if (! get_dht(cinfo))
   \                     ??read_markers_20:
   \   00000204   0400A0E1           MOV      R0,R4
   \   00000208   ........           BL       get_dht
   \   0000020C   E3FFFFEA           B        ??read_markers_7
   1029          	return JPEG_SUSPENDED;
   1030                break;
   1031                
   1032              case M_DQT:
   1033                if (! get_dqt(cinfo))
   \                     ??read_markers_21:
   \   00000210   0400A0E1           MOV      R0,R4
   \   00000214   ........           BL       get_dqt
   \   00000218   E0FFFFEA           B        ??read_markers_7
   1034          	return JPEG_SUSPENDED;
   1035                break;
   1036                
   1037              case M_DRI:
   1038                if (! get_dri(cinfo))
   \                     ??read_markers_22:
   \   0000021C   0400A0E1           MOV      R0,R4
   \   00000220   ........           BL       get_dri
   \   00000224   DDFFFFEA           B        ??read_markers_7
   1039          	return JPEG_SUSPENDED;
   1040                break;
   1041                
   1042              case M_APP0:
   1043              case M_APP1:
   1044              case M_APP2:
   1045              case M_APP3:
   1046              case M_APP4:
   1047              case M_APP5:
   1048              case M_APP6:
   1049              case M_APP7:
   1050              case M_APP8:
   1051              case M_APP9:
   1052              case M_APP10:
   1053              case M_APP11:
   1054              case M_APP12:
   1055              case M_APP13:
   1056              case M_APP14:
   1057              case M_APP15:
   1058                if (! (*((my_marker_ptr) cinfo->marker)->process_APPn[
   1059          		cinfo->unread_marker - (int) M_APP0]) (cinfo))
   \                     ??read_markers_23:
   \   00000228   0400A0E1           MOV      R0,R4
   \   0000022C   DF30E0E3           MVN      R3,#+223
   \   00000230   022083E0           ADD      R2,R3,R2
   \   00000234   021181E0           ADD      R1,R1,R2, LSL #+2
   \   00000238   201091E5           LDR      R1,[R1, #+32]
   \                     ??read_markers_24:
   \   0000023C   31FF2FE1           BLX      R1
   \   00000240   D6FFFFEA           B        ??read_markers_7
   1060          	return JPEG_SUSPENDED;
   1061                break;
   1062                
   1063              case M_COM:
   1064                if (! (*((my_marker_ptr) cinfo->marker)->process_COM) (cinfo))
   \                     ??read_markers_25:
   \   00000244   1C1091E5           LDR      R1,[R1, #+28]
   \   00000248   0400A0E1           MOV      R0,R4
   \   0000024C   FAFFFFEA           B        ??read_markers_24
   1065          	return JPEG_SUSPENDED;
   1066                break;
   1067          
   1068              case M_RST0:		/* these are all parameterless */
   1069              case M_RST1:
   1070              case M_RST2:
   1071              case M_RST3:
   1072              case M_RST4:
   1073              case M_RST5:
   1074              case M_RST6:
   1075              case M_RST7:
   1076              case M_TEM:
   1077                TRACEMS1(cinfo, 1, JTRC_PARMLESS_MARKER, cinfo->unread_marker);
   \                     ??read_markers_26:
   \   00000250   5E10A0E3           MOV      R1,#+94
   \   00000254   141080E5           STR      R1,[R0, #+20]
   \   00000258   000094E5           LDR      R0,[R4, #+0]
   \   0000025C   A01194E5           LDR      R1,[R4, #+416]
   \   00000260   181080E5           STR      R1,[R0, #+24]
   \   00000264   002094E5           LDR      R2,[R4, #+0]
   \   00000268   0110A0E3           MOV      R1,#+1
   \   0000026C   042092E5           LDR      R2,[R2, #+4]
   \   00000270   0400A0E1           MOV      R0,R4
   \   00000274   32FF2FE1           BLX      R2
   \   00000278   0B0000EA           B        ??read_markers_14
   1078                break;
   1079          
   1080              case M_DNL:			/* Ignore DNL ... perhaps the wrong thing */
   1081                if (! skip_variable(cinfo))
   \                     ??read_markers_27:
   \   0000027C   0400A0E1           MOV      R0,R4
   \   00000280   ........           BL       skip_variable
   \   00000284   C5FFFFEA           B        ??read_markers_7
   1082          	return JPEG_SUSPENDED;
   1083                break;
   1084          
   1085              default:			/* must be DHP, EXP, JPGn, or RESn */
   1086                /* For now, we treat the reserved markers as fatal errors since they are
   1087                 * likely to be used to signal incompatible JPEG Part 3 extensions.
   1088                 * Once the JPEG 3 version-number marker is well defined, this code
   1089                 * ought to change!
   1090                 */
   1091                ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo->unread_marker);
   \                     ??read_markers_5:
   \   00000288   4610A0E3           MOV      R1,#+70
   \                     ??read_markers_16:
   \   0000028C   141080E5           STR      R1,[R0, #+20]
   \   00000290   000094E5           LDR      R0,[R4, #+0]
   \   00000294   A01194E5           LDR      R1,[R4, #+416]
   \   00000298   181080E5           STR      R1,[R0, #+24]
   \   0000029C   001094E5           LDR      R1,[R4, #+0]
   \   000002A0   0400A0E1           MOV      R0,R4
   \   000002A4   001091E5           LDR      R1,[R1, #+0]
   \   000002A8   31FF2FE1           BLX      R1
   1092                break;
   1093              }
   1094              /* Successfully processed marker, so reset state variable */
   1095              cinfo->unread_marker = 0;
   \                     ??read_markers_14:
   \   000002AC   A05184E5           STR      R5,[R4, #+416]
   \   000002B0   57FFFFEA           B        ??read_markers_2
   1096            } /* end loop */
   1097          }
   1098          
   1099          
   1100          /*
   1101           * Read a restart marker, which is expected to appear next in the datastream;
   1102           * if the marker is not there, take appropriate recovery action.
   1103           * Returns FALSE if suspension is required.
   1104           *
   1105           * This is called by the entropy decoder after it has read an appropriate
   1106           * number of MCUs.  cinfo->unread_marker may be nonzero if the entropy decoder
   1107           * has already read a marker from the data source.  Under normal conditions
   1108           * cinfo->unread_marker will be reset to 0 before returning; if not reset,
   1109           * it holds a marker which the decoder will be unable to read past.
   1110           */
   1111          

   \                                 In segment CODE, align 4, keep-with-next
   1112          METHODDEF(boolean)
   1113          read_restart_marker (j_decompress_ptr cinfo)
   1114          {
   \                     read_restart_marker:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1115            /* Obtain a marker unless we already did. */
   1116            /* Note that next_marker will complain if it skips any data. */
   1117            if (cinfo->unread_marker == 0) {
   \   00000008   A00194E5           LDR      R0,[R4, #+416]
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0300001A           BNE      ??read_restart_marker_0
   1118              if (! next_marker(cinfo))
   \   00000014   0400A0E1           MOV      R0,R4
   \   00000018   ........           BL       next_marker
   \   0000001C   000050E3           CMP      R0,#+0
   \   00000020   1080BD08           POPEQ    {R4,PC}
   1119                return FALSE;
   1120            }
   1121          
   1122            if (cinfo->unread_marker ==
   1123                ((int) M_RST0 + cinfo->marker->next_restart_num)) {
   \                     ??read_restart_marker_0:
   \   00000024   B80194E5           LDR      R0,[R4, #+440]
   \   00000028   A01194E5           LDR      R1,[R4, #+416]
   \   0000002C   142090E5           LDR      R2,[R0, #+20]
   \   00000030   D02082E2           ADD      R2,R2,#+208
   \   00000034   020051E1           CMP      R1,R2
   \   00000038   0E00001A           BNE      ??read_restart_marker_1
   1124              /* Normal case --- swallow the marker and let entropy decoder continue */
   1125              TRACEMS1(cinfo, 3, JTRC_RST, cinfo->marker->next_restart_num);
   \   0000003C   000094E5           LDR      R0,[R4, #+0]
   \   00000040   6410A0E3           MOV      R1,#+100
   \   00000044   141080E5           STR      R1,[R0, #+20]
   \   00000048   B81194E5           LDR      R1,[R4, #+440]
   \   0000004C   000094E5           LDR      R0,[R4, #+0]
   \   00000050   141091E5           LDR      R1,[R1, #+20]
   \   00000054   181080E5           STR      R1,[R0, #+24]
   \   00000058   002094E5           LDR      R2,[R4, #+0]
   \   0000005C   0310A0E3           MOV      R1,#+3
   \   00000060   042092E5           LDR      R2,[R2, #+4]
   \   00000064   0400A0E1           MOV      R0,R4
   \   00000068   32FF2FE1           BLX      R2
   1126              cinfo->unread_marker = 0;
   \   0000006C   0000A0E3           MOV      R0,#+0
   \   00000070   A00184E5           STR      R0,[R4, #+416]
   \   00000074   060000EA           B        ??read_restart_marker_2
   1127            } else {
   1128              /* Uh-oh, the restart markers have been messed up. */
   1129              /* Let the data source manager determine how to resync. */
   1130              if (! (*cinfo->src->resync_to_restart) (cinfo,
   1131          					    cinfo->marker->next_restart_num))
   \                     ??read_restart_marker_1:
   \   00000078   182094E5           LDR      R2,[R4, #+24]
   \   0000007C   141090E5           LDR      R1,[R0, #+20]
   \   00000080   142092E5           LDR      R2,[R2, #+20]
   \   00000084   0400A0E1           MOV      R0,R4
   \   00000088   32FF2FE1           BLX      R2
   \   0000008C   000050E3           CMP      R0,#+0
   \   00000090   1080BD08           POPEQ    {R4,PC}
   1132                return FALSE;
   1133            }
   1134          
   1135            /* Update next-restart state */
   1136            cinfo->marker->next_restart_num = (cinfo->marker->next_restart_num + 1) & 7;
   \                     ??read_restart_marker_2:
   \   00000094   B80194E5           LDR      R0,[R4, #+440]
   \   00000098   141090E5           LDR      R1,[R0, #+20]
   \   0000009C   011081E2           ADD      R1,R1,#+1
   \   000000A0   071001E2           AND      R1,R1,#0x7
   \   000000A4   141080E5           STR      R1,[R0, #+20]
   1137          
   1138            return TRUE;
   \   000000A8   0100A0E3           MOV      R0,#+1
   \   000000AC   1080BDE8           POP      {R4,PC}          ;; return
   1139          }
   1140          
   1141          
   1142          /*
   1143           * This is the default resync_to_restart method for data source managers
   1144           * to use if they don't have any better approach.  Some data source managers
   1145           * may be able to back up, or may have additional knowledge about the data
   1146           * which permits a more intelligent recovery strategy; such managers would
   1147           * presumably supply their own resync method.
   1148           *
   1149           * read_restart_marker calls resync_to_restart if it finds a marker other than
   1150           * the restart marker it was expecting.  (This code is *not* used unless
   1151           * a nonzero restart interval has been declared.)  cinfo->unread_marker is
   1152           * the marker code actually found (might be anything, except 0 or FF).
   1153           * The desired restart marker number (0..7) is passed as a parameter.
   1154           * This routine is supposed to apply whatever error recovery strategy seems
   1155           * appropriate in order to position the input stream to the next data segment.
   1156           * Note that cinfo->unread_marker is treated as a marker appearing before
   1157           * the current data-source input point; usually it should be reset to zero
   1158           * before returning.
   1159           * Returns FALSE if suspension is required.
   1160           *
   1161           * This implementation is substantially constrained by wanting to treat the
   1162           * input as a data stream; this means we can't back up.  Therefore, we have
   1163           * only the following actions to work with:
   1164           *   1. Simply discard the marker and let the entropy decoder resume at next
   1165           *      byte of file.
   1166           *   2. Read forward until we find another marker, discarding intervening
   1167           *      data.  (In theory we could look ahead within the current bufferload,
   1168           *      without having to discard data if we don't find the desired marker.
   1169           *      This idea is not implemented here, in part because it makes behavior
   1170           *      dependent on buffer size and chance buffer-boundary positions.)
   1171           *   3. Leave the marker unread (by failing to zero cinfo->unread_marker).
   1172           *      This will cause the entropy decoder to process an empty data segment,
   1173           *      inserting dummy zeroes, and then we will reprocess the marker.
   1174           *
   1175           * #2 is appropriate if we think the desired marker lies ahead, while #3 is
   1176           * appropriate if the found marker is a future restart marker (indicating
   1177           * that we have missed the desired restart marker, probably because it got
   1178           * corrupted).
   1179           * We apply #2 or #3 if the found marker is a restart marker no more than
   1180           * two counts behind or ahead of the expected one.  We also apply #2 if the
   1181           * found marker is not a legal JPEG marker code (it's certainly bogus data).
   1182           * If the found marker is a restart marker more than 2 counts away, we do #1
   1183           * (too much risk that the marker is erroneous; with luck we will be able to
   1184           * resync at some future point).
   1185           * For any valid non-restart JPEG marker, we apply #3.  This keeps us from
   1186           * overrunning the end of a scan.  An implementation limited to single-scan
   1187           * files might find it better to apply #2 for markers other than EOI, since
   1188           * any other marker would have to be bogus data in that case.
   1189           */
   1190          

   \                                 In segment CODE, align 4, keep-with-next
   1191          GLOBAL(boolean)
   1192          jpeg_resync_to_restart (j_decompress_ptr cinfo, int desired)
   1193          {
   \                     jpeg_resync_to_restart:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1194            int marker = cinfo->unread_marker;
   1195            int action = 1;
   1196            
   1197            /* Always put up a warning. */
   1198            WARNMS2(cinfo, JWRN_MUST_RESYNC, marker, desired);
   \   00000008   000094E5           LDR      R0,[R4, #+0]
   \   0000000C   A06194E5           LDR      R6,[R4, #+416]
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   7C10A0E3           MOV      R1,#+124
   \   00000018   141080E5           STR      R1,[R0, #+20]
   \   0000001C   000094E5           LDR      R0,[R4, #+0]
   \   00000020   0010E0E3           MVN      R1,#+0
   \   00000024   186080E5           STR      R6,[R0, #+24]
   \   00000028   000094E5           LDR      R0,[R4, #+0]
   \   0000002C   6370A0E3           MOV      R7,#+99
   \   00000030   1C5080E5           STR      R5,[R0, #+28]
   \   00000034   002094E5           LDR      R2,[R4, #+0]
   \   00000038   0400A0E1           MOV      R0,R4
   \   0000003C   042092E5           LDR      R2,[R2, #+4]
   \   00000040   32FF2FE1           BLX      R2
   \   00000044   000000EA           B        ??jpeg_resync_to_restart_0
   1199            
   1200            /* Outer loop handles repeated decision after scanning forward. */
   1201            for (;;) {
   1202              if (marker < (int) M_SOF0)
   1203                action = 2;		/* invalid marker */
   1204              else if (marker < (int) M_RST0 || marker > (int) M_RST7)
   1205                action = 3;		/* valid non-restart marker */
   1206              else {
   1207                if (marker == ((int) M_RST0 + ((desired+1) & 7)) ||
   1208          	  marker == ((int) M_RST0 + ((desired+2) & 7)))
   1209          	action = 3;		/* one of the next two expected restarts */
   1210                else if (marker == ((int) M_RST0 + ((desired-1) & 7)) ||
   1211          	       marker == ((int) M_RST0 + ((desired-2) & 7)))
   1212          	action = 2;		/* a prior restart, so advance */
   1213                else
   1214          	action = 1;		/* desired restart or too far away */
   1215              }
   1216              TRACEMS2(cinfo, 4, JTRC_RECOVERY_ACTION, marker, action);
   1217              switch (action) {
   1218              case 1:
   1219                /* Discard marker and let entropy decoder resume processing. */
   1220                cinfo->unread_marker = 0;
   1221                return TRUE;
   1222              case 2:
   1223                /* Scan to the next marker, and repeat the decision loop. */
   1224                if (! next_marker(cinfo))
   1225          	return FALSE;
   1226                marker = cinfo->unread_marker;
   \                     ??jpeg_resync_to_restart_1:
   \   00000048   A06194E5           LDR      R6,[R4, #+416]
   \                     ??jpeg_resync_to_restart_0:
   \   0000004C   C00056E3           CMP      R6,#+192
   \   00000050   010000AA           BGE      ??jpeg_resync_to_restart_2
   \                     ??jpeg_resync_to_restart_3:
   \   00000054   0280A0E3           MOV      R8,#+2
   \   00000058   1A0000EA           B        ??jpeg_resync_to_restart_4
   \                     ??jpeg_resync_to_restart_2:
   \   0000005C   D00056E3           CMP      R6,#+208
   \   00000060   010000BA           BLT      ??jpeg_resync_to_restart_5
   \   00000064   D80056E3           CMP      R6,#+216
   \   00000068   010000BA           BLT      ??jpeg_resync_to_restart_6
   \                     ??jpeg_resync_to_restart_5:
   \   0000006C   0380A0E3           MOV      R8,#+3
   \   00000070   140000EA           B        ??jpeg_resync_to_restart_4
   \                     ??jpeg_resync_to_restart_6:
   \   00000074   010085E2           ADD      R0,R5,#+1
   \   00000078   070000E2           AND      R0,R0,#0x7
   \   0000007C   D00080E2           ADD      R0,R0,#+208
   \   00000080   000056E1           CMP      R6,R0
   \   00000084   F8FFFF0A           BEQ      ??jpeg_resync_to_restart_5
   \   00000088   020085E2           ADD      R0,R5,#+2
   \   0000008C   070000E2           AND      R0,R0,#0x7
   \   00000090   D00080E2           ADD      R0,R0,#+208
   \   00000094   000056E1           CMP      R6,R0
   \   00000098   F3FFFF0A           BEQ      ??jpeg_resync_to_restart_5
   \   0000009C   010045E2           SUB      R0,R5,#+1
   \   000000A0   070000E2           AND      R0,R0,#0x7
   \   000000A4   D00080E2           ADD      R0,R0,#+208
   \   000000A8   000056E1           CMP      R6,R0
   \   000000AC   E8FFFF0A           BEQ      ??jpeg_resync_to_restart_3
   \   000000B0   020045E2           SUB      R0,R5,#+2
   \   000000B4   070000E2           AND      R0,R0,#0x7
   \   000000B8   D00080E2           ADD      R0,R0,#+208
   \   000000BC   000056E1           CMP      R6,R0
   \   000000C0   E3FFFF0A           BEQ      ??jpeg_resync_to_restart_3
   \   000000C4   0180A0E3           MOV      R8,#+1
   \                     ??jpeg_resync_to_restart_4:
   \   000000C8   000094E5           LDR      R0,[R4, #+0]
   \   000000CC   0410A0E3           MOV      R1,#+4
   \   000000D0   147080E5           STR      R7,[R0, #+20]
   \   000000D4   000094E5           LDR      R0,[R4, #+0]
   \   000000D8   186080E5           STR      R6,[R0, #+24]
   \   000000DC   000094E5           LDR      R0,[R4, #+0]
   \   000000E0   1C8080E5           STR      R8,[R0, #+28]
   \   000000E4   002094E5           LDR      R2,[R4, #+0]
   \   000000E8   0400A0E1           MOV      R0,R4
   \   000000EC   042092E5           LDR      R2,[R2, #+4]
   \   000000F0   32FF2FE1           BLX      R2
   \   000000F4   018058E2           SUBS     R8,R8,#+1
   \   000000F8   0400000A           BEQ      ??jpeg_resync_to_restart_7
   \   000000FC   018058E2           SUBS     R8,R8,#+1
   \   00000100   0600000A           BEQ      ??jpeg_resync_to_restart_8
   \   00000104   018058E2           SUBS     R8,R8,#+1
   \   00000108   0900000A           BEQ      ??jpeg_resync_to_restart_9
   \   0000010C   CEFFFFEA           B        ??jpeg_resync_to_restart_0
   \                     ??jpeg_resync_to_restart_7:
   \   00000110   0000A0E3           MOV      R0,#+0
   \   00000114   A00184E5           STR      R0,[R4, #+416]
   \   00000118   0100A0E3           MOV      R0,#+1
   \   0000011C   F081BDE8           POP      {R4-R8,PC}
   \                     ??jpeg_resync_to_restart_8:
   \   00000120   0400A0E1           MOV      R0,R4
   \   00000124   ........           BL       next_marker
   \   00000128   000050E3           CMP      R0,#+0
   \   0000012C   C5FFFF1A           BNE      ??jpeg_resync_to_restart_1
   \   00000130   F081BDE8           POP      {R4-R8,PC}
   1227                break;
   1228              case 3:
   1229                /* Return without advancing past this marker. */
   1230                /* Entropy decoder will be forced to process an empty segment. */
   1231                return TRUE;
   \                     ??jpeg_resync_to_restart_9:
   \   00000134   0100A0E3           MOV      R0,#+1
   \   00000138   F081BDE8           POP      {R4-R8,PC}       ;; return
   1232              }
   1233            } /* end loop */
   1234          }
   1235          
   1236          
   1237          /*
   1238           * Reset marker processing state to begin a fresh datastream.
   1239           */
   1240          

   \                                 In segment CODE, align 4, keep-with-next
   1241          METHODDEF(void)
   1242          reset_marker_reader (j_decompress_ptr cinfo)
   1243          {
   1244            my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
   \                     reset_marker_reader:
   \   00000000   B81190E5           LDR      R1,[R0, #+440]
   1245          
   1246            cinfo->comp_info = NULL;		/* until allocated by get_sof */
   \   00000004   0020A0E3           MOV      R2,#+0
   \   00000008   D42080E5           STR      R2,[R0, #+212]
   1247            cinfo->input_scan_number = 0;		/* no SOS seen yet */
   \   0000000C   8C2080E5           STR      R2,[R0, #+140]
   1248            cinfo->unread_marker = 0;		/* no pending marker */
   \   00000010   A02180E5           STR      R2,[R0, #+416]
   1249            marker->pub.saw_SOI = FALSE;		/* set internal state too */
   \   00000014   0C2081E5           STR      R2,[R1, #+12]
   1250            marker->pub.saw_SOF = FALSE;
   \   00000018   102081E5           STR      R2,[R1, #+16]
   1251            marker->pub.discarded_bytes = 0;
   \   0000001C   182081E5           STR      R2,[R1, #+24]
   1252            marker->cur_marker = NULL;
   \   00000020   A42081E5           STR      R2,[R1, #+164]
   1253          }
   \   00000024   1EFF2FE1           BX       LR               ;; return
   1254          
   1255          
   1256          /*
   1257           * Initialize the marker reader module.
   1258           * This is called only once, when the decompression object is created.
   1259           */
   1260          

   \                                 In segment CODE, align 4, keep-with-next
   1261          GLOBAL(void)
   1262          jinit_marker_reader (j_decompress_ptr cinfo)
   1263          {
   \                     jinit_marker_reader:
   \   00000000   10402DE9           PUSH     {R4,LR}
   1264            my_marker_ptr marker;
   1265            int i;
   1266          
   1267            /* Create subobject in permanent pool */
   1268            marker = (my_marker_ptr)
   1269              (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
   1270          				SIZEOF(my_marker_reader));
   \   00000004   AC20A0E3           MOV      R2,#+172
   \   00000008   0010A0E3           MOV      R1,#+0
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   043094E5           LDR      R3,[R4, #+4]
   \   00000014   003093E5           LDR      R3,[R3, #+0]
   \   00000018   33FF2FE1           BLX      R3
   1271            cinfo->marker = (struct jpeg_marker_reader *) marker;
   1272            /* Initialize public method pointers */
   1273            marker->pub.reset_marker_reader = reset_marker_reader;
   \   0000001C   58109FE5           LDR      R1,??jinit_marker_reader_0  ;; reset_marker_reader
   \   00000020   B80184E5           STR      R0,[R4, #+440]
   \   00000024   001080E5           STR      R1,[R0, #+0]
   1274            marker->pub.read_markers = read_markers;
   \   00000028   50109FE5           LDR      R1,??jinit_marker_reader_0+0x4  ;; read_markers
   1275            marker->pub.read_restart_marker = read_restart_marker;
   1276            /* Initialize COM/APPn processing.
   1277             * By default, we examine and then discard APP0 and APP14,
   1278             * but simply discard COM and all other APPn.
   1279             */
   1280            marker->process_COM = skip_variable;
   1281            marker->length_limit_COM = 0;
   \   0000002C   0020A0E3           MOV      R2,#+0
   \   00000030   041080E5           STR      R1,[R0, #+4]
   \   00000034   48109FE5           LDR      R1,??jinit_marker_reader_0+0x8  ;; read_restart_marker
   1282            for (i = 0; i < 16; i++) {
   \   00000038   0030A0E3           MOV      R3,#+0
   \   0000003C   081080E5           STR      R1,[R0, #+8]
   \   00000040   ........           LDR      R1,??DataTable2  ;; skip_variable
   \   00000044   1C1080E5           STR      R1,[R0, #+28]
   \   00000048   602080E5           STR      R2,[R0, #+96]
   1283              marker->process_APPn[i] = skip_variable;
   \                     ??jinit_marker_reader_1:
   \   0000004C   03C180E0           ADD      R12,R0,R3, LSL #+2
   \   00000050   20108CE5           STR      R1,[R12, #+32]
   1284              marker->length_limit_APPn[i] = 0;
   \   00000054   64208CE5           STR      R2,[R12, #+100]
   1285            }
   \   00000058   013083E2           ADD      R3,R3,#+1
   \   0000005C   100053E3           CMP      R3,#+16
   \   00000060   F9FFFFBA           BLT      ??jinit_marker_reader_1
   1286            marker->process_APPn[0] = get_interesting_appn;
   \   00000064   ........           LDR      R1,??DataTable3  ;; get_interesting_appn
   \   00000068   201080E5           STR      R1,[R0, #+32]
   1287            marker->process_APPn[14] = get_interesting_appn;
   \   0000006C   581080E5           STR      R1,[R0, #+88]
   1288            /* Reset marker processing state */
   1289            reset_marker_reader(cinfo);
   \   00000070   0400A0E1           MOV      R0,R4
   \   00000074   ........           BL       reset_marker_reader
   1290          }
   \   00000078   1080BDE8           POP      {R4,PC}          ;; return
   \                     ??jinit_marker_reader_0:
   \   0000007C   ........           DC32     reset_marker_reader
   \   00000080   ........           DC32     read_markers
   \   00000084   ........           DC32     read_restart_marker
   1291          
   1292          
   1293          /*
   1294           * Control saving of COM and APPn markers into marker_list.
   1295           */
   1296          
   1297          #ifdef SAVE_MARKERS_SUPPORTED
   1298          

   \                                 In segment CODE, align 4, keep-with-next
   1299          GLOBAL(void)
   1300          jpeg_save_markers (j_decompress_ptr cinfo, int marker_code,
   1301          		   unsigned int length_limit)
   1302          {
   \                     jpeg_save_markers:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   0030A0E1           MOV      R3,R0
   1303            my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
   1304            long maxlength;
   1305            jpeg_marker_parser_method processor;
   1306          
   1307            /* Length limit mustn't be larger than what we can allocate
   1308             * (should only be a concern in a 16-bit environment).
   1309             */
   1310            maxlength = cinfo->mem->max_alloc_chunk - SIZEOF(struct jpeg_marker_struct);
   \   00000008   04C093E5           LDR      R12,[R3, #+4]
   \   0000000C   B80193E5           LDR      R0,[R3, #+440]
   \   00000010   30C09CE5           LDR      R12,[R12, #+48]
   \   00000014   14C04CE2           SUB      R12,R12,#+20
   1311            if (((long) length_limit) > maxlength)
   \   00000018   02005CE1           CMP      R12,R2
   1312              length_limit = (unsigned int) maxlength;
   \   0000001C   0C20A0B1           MOVLT    R2,R12
   1313          
   1314            /* Choose processor routine to use.
   1315             * APP0/APP14 have special requirements.
   1316             */
   1317            if (length_limit) {
   \   00000020   000052E3           CMP      R2,#+0
   \   00000024   0C00000A           BEQ      ??jpeg_save_markers_0
   1318              processor = save_marker;
   \   00000028   94C09FE5           LDR      R12,??jpeg_save_markers_1  ;; save_marker
   1319              /* If saving APP0/APP14, save at least enough for our internal use. */
   1320              if (marker_code == (int) M_APP0 && length_limit < APP0_DATA_LEN)
   \   0000002C   E00051E3           CMP      R1,#+224
   \   00000030   0300001A           BNE      ??jpeg_save_markers_2
   \   00000034   0E0052E3           CMP      R2,#+14
   \   00000038   1300002A           BCS      ??jpeg_save_markers_3
   1321                length_limit = APP0_DATA_LEN;
   \   0000003C   0E20A0E3           MOV      R2,#+14
   \   00000040   110000EA           B        ??jpeg_save_markers_3
   1322              else if (marker_code == (int) M_APP14 && length_limit < APP14_DATA_LEN)
   \                     ??jpeg_save_markers_2:
   \   00000044   EE0051E3           CMP      R1,#+238
   \   00000048   0700001A           BNE      ??jpeg_save_markers_4
   \   0000004C   0C0052E3           CMP      R2,#+12
   \   00000050   0D00002A           BCS      ??jpeg_save_markers_3
   1323                length_limit = APP14_DATA_LEN;
   \   00000054   0C20A0E3           MOV      R2,#+12
   \   00000058   0B0000EA           B        ??jpeg_save_markers_3
   1324            } else {
   1325              processor = skip_variable;
   \                     ??jpeg_save_markers_0:
   \   0000005C   ........           LDR      R12,??DataTable2  ;; skip_variable
   1326              /* If discarding APP0/APP14, use our regular on-the-fly processor. */
   1327              if (marker_code == (int) M_APP0 || marker_code == (int) M_APP14)
   \   00000060   E00051E3           CMP      R1,#+224
   \   00000064   EE005113           CMPNE    R1,#+238
   1328                processor = get_interesting_appn;
   \   00000068   ........           LDREQ    R12,??DataTable3  ;; get_interesting_appn
   1329            }
   1330          
   1331            if (marker_code == (int) M_COM) {
   \                     ??jpeg_save_markers_4:
   \   0000006C   FE0051E3           CMP      R1,#+254
   1332              marker->process_COM = processor;
   \   00000070   1CC08005           STREQ    R12,[R0, #+28]
   1333              marker->length_limit_COM = length_limit;
   \   00000074   60208005           STREQ    R2,[R0, #+96]
   \   00000078   0080BD08           POPEQ    {PC}
   1334            } else if (marker_code >= (int) M_APP0 && marker_code <= (int) M_APP15) {
   \   0000007C   E00051E3           CMP      R1,#+224
   \   00000080   050000BA           BLT      ??jpeg_save_markers_5
   \   00000084   F00051E3           CMP      R1,#+240
   \   00000088   030000AA           BGE      ??jpeg_save_markers_5
   1335              marker->process_APPn[marker_code - (int) M_APP0] = processor;
   \                     ??jpeg_save_markers_3:
   \   0000008C   010180E0           ADD      R0,R0,R1, LSL #+2
   \   00000090   60C300E5           STR      R12,[R0, #-864]
   1336              marker->length_limit_APPn[marker_code - (int) M_APP0] = length_limit;
   \   00000094   1C2300E5           STR      R2,[R0, #-796]
   \   00000098   0080BDE8           POP      {PC}
   1337            } else
   1338              ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, marker_code);
   \                     ??jpeg_save_markers_5:
   \   0000009C   000093E5           LDR      R0,[R3, #+0]
   \   000000A0   4620A0E3           MOV      R2,#+70
   \   000000A4   142080E5           STR      R2,[R0, #+20]
   \   000000A8   000093E5           LDR      R0,[R3, #+0]
   \   000000AC   181080E5           STR      R1,[R0, #+24]
   \   000000B0   001093E5           LDR      R1,[R3, #+0]
   \   000000B4   0300A0E1           MOV      R0,R3
   \   000000B8   001091E5           LDR      R1,[R1, #+0]
   \   000000BC   31FF2FE1           BLX      R1
   1339          }
   \   000000C0   0080BDE8           POP      {PC}             ;; return
   \                     ??jpeg_save_markers_1:
   \   000000C4   ........           DC32     save_marker
   1340          
   1341          #endif /* SAVE_MARKERS_SUPPORTED */
   1342          
   1343          
   1344          /*
   1345           * Install a special processing method for COM or APPn markers.
   1346           */
   1347          

   \                                 In segment CODE, align 4, keep-with-next
   1348          GLOBAL(void)
   1349          jpeg_set_marker_processor (j_decompress_ptr cinfo, int marker_code,
   1350          			   jpeg_marker_parser_method routine)
   1351          {
   \                     jpeg_set_marker_processor:
   \   00000000   0030A0E1           MOV      R3,R0
   1352            my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
   \   00000004   B80193E5           LDR      R0,[R3, #+440]
   1353          
   1354            if (marker_code == (int) M_COM)
   \   00000008   FE0051E3           CMP      R1,#+254
   1355              marker->process_COM = routine;
   \   0000000C   1C208005           STREQ    R2,[R0, #+28]
   \   00000010   1EFF2F01           BXEQ     LR
   1356            else if (marker_code >= (int) M_APP0 && marker_code <= (int) M_APP15)
   \   00000014   E00051E3           CMP      R1,#+224
   \   00000018   030000BA           BLT      ??jpeg_set_marker_processor_0
   \   0000001C   F00051E3           CMP      R1,#+240
   1357              marker->process_APPn[marker_code - (int) M_APP0] = routine;
   \   00000020   010180B0           ADDLT    R0,R0,R1, LSL #+2
   \   00000024   602300B5           STRLT    R2,[R0, #-864]
   \   00000028   1EFF2FB1           BXLT     LR
   1358            else
   1359              ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, marker_code);
   \                     ??jpeg_set_marker_processor_0:
   \   0000002C   000093E5           LDR      R0,[R3, #+0]
   \   00000030   4620A0E3           MOV      R2,#+70
   \   00000034   142080E5           STR      R2,[R0, #+20]
   \   00000038   000093E5           LDR      R0,[R3, #+0]
   \   0000003C   181080E5           STR      R1,[R0, #+24]
   \   00000040   001093E5           LDR      R1,[R3, #+0]
   \   00000044   0300A0E1           MOV      R0,R3
   \   00000048   001091E5           LDR      R1,[R1, #+0]
   \   0000004C   01F0A0E1           MOV      PC,R1            ;; tailcall
   1360          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     skip_variable

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   ........           DC32     get_interesting_appn

   Maximum stack usage in bytes:

     Function                  CSTACK
     --------                  ------
     examine_app0                 20
     examine_app14                12
     first_marker                 28
     get_dac                      32
     get_dht                     312
     get_dqt                      40
     get_dri                      24
     get_interesting_appn         48
     get_sof                      28
     get_soi                      12
     get_sos                      40
     jinit_marker_reader           8
     jpeg_resync_to_restart       24
     jpeg_save_markers             4
     jpeg_set_marker_processor     4
     next_marker                  24
     read_markers                 12
     read_restart_marker           8
     reset_marker_reader           0
     save_marker                  44
     skip_variable                24


   Segment part sizes:

     Function/Label            Bytes
     --------------            -----
     get_soi                    196
     get_sof                    984
     get_sos                    860
     get_dac                    468
     get_dht                    828
     get_dqt                    712
     get_dri                    304
     examine_app0               600
     examine_app14              212
     get_interesting_appn       380
     save_marker                700
     skip_variable              212
     next_marker                316
     first_marker               176
     read_markers               692
     read_restart_marker        176
     jpeg_resync_to_restart     316
     reset_marker_reader         40
     jinit_marker_reader        136
     jpeg_save_markers          200
     jpeg_set_marker_processor   80
     ??DataTable2                 4
     ??DataTable3                 4
      Others                    108

 
 8 704 bytes in segment CODE
 
 8 596 bytes of CODE memory (+ 108 bytes shared)

Errors: none
Warnings: 1
