##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    19/Jan/2011  13:20:51 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\grabber\jpeg-7\jchuff.c                       #
#    Command line    =  C:\arm\grabber\jpeg-7\jchuff.c -lC                   #
#                       C:\arm\grabber\Release_SGOLD\List\ -o                #
#                       C:\arm\grabber\Release_SGOLD\Obj\ -s9 --no_unroll    #
#                       --no_clustering --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --fpu None --dlib_config "C:\arm2\Embedded           #
#                       Workbench 4.0 Evaluation\ARM\LIB\dl5tpainl8n.h" -I   #
#                       "C:\arm2\Embedded Workbench 4.0                      #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  C:\arm\grabber\Release_SGOLD\List\jchuff.lst         #
#    Object file     =  C:\arm\grabber\Release_SGOLD\Obj\jchuff.r79          #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\grabber\jpeg-7\jchuff.c
      1          /*
                  ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           * jchuff.c
      3           *
      4           * Copyright (C) 1991-1997, Thomas G. Lane.
      5           * Modified 2006-2009 by Guido Vollbeding.
      6           * This file is part of the Independent JPEG Group's software.
      7           * For conditions of distribution and use, see the accompanying README file.
      8           *
      9           * This file contains Huffman entropy encoding routines.
     10           * Both sequential and progressive modes are supported in this single module.
     11           *
     12           * Much of the complexity here has to do with supporting output suspension.
     13           * If the data destination module demands suspension, we want to be able to
     14           * back up to the start of the current MCU.  To do this, we copy state
     15           * variables into local working storage, and update them back to the
     16           * permanent JPEG objects only upon successful completion of an MCU.
     17           *
     18           * We do not support output suspension for the progressive JPEG mode, since
     19           * the library currently does not allow multiple-scan files to be written
     20           * with output suspension.
     21           */
     22          
     23          #define JPEG_INTERNALS
     24          #include "jinclude.h"
     25          #include "jpeglib.h"
     26          
     27          
     28          /* The legal range of a DCT coefficient is
     29           *  -1024 .. +1023  for 8-bit data;
     30           * -16384 .. +16383 for 12-bit data.
     31           * Hence the magnitude should always fit in 10 or 14 bits respectively.
     32           */
     33          
     34          #if BITS_IN_JSAMPLE == 8
     35          #define MAX_COEF_BITS 10
     36          #else
     37          #define MAX_COEF_BITS 14
     38          #endif
     39          
     40          /* Derived data constructed for each Huffman table */
     41          
     42          typedef struct {
     43            unsigned int ehufco[256];	/* code for each symbol */
     44            char ehufsi[256];		/* length of code for each symbol */
     45            /* If no code has been allocated for a symbol S, ehufsi[S] contains 0 */
     46          } c_derived_tbl;
     47          
     48          
     49          /* Expanded entropy encoder object for Huffman encoding.
     50           *
     51           * The savable_state subrecord contains fields that change within an MCU,
     52           * but must not be updated permanently until we complete the MCU.
     53           */
     54          
     55          typedef struct {
     56            INT32 put_buffer;		/* current bit-accumulation buffer */
     57            int put_bits;			/* # of bits now in it */
     58            int last_dc_val[MAX_COMPS_IN_SCAN]; /* last DC coef for each component */
     59          } savable_state;
     60          
     61          /* This macro is to work around compilers with missing or broken
     62           * structure assignment.  You'll need to fix this code if you have
     63           * such a compiler and you change MAX_COMPS_IN_SCAN.
     64           */
     65          
     66          #ifndef NO_STRUCT_ASSIGN
     67          #define ASSIGN_STATE(dest,src)  ((dest) = (src))
     68          #else
     69          #if MAX_COMPS_IN_SCAN == 4
     70          #define ASSIGN_STATE(dest,src)  \
     71          	((dest).put_buffer = (src).put_buffer, \
     72          	 (dest).put_bits = (src).put_bits, \
     73          	 (dest).last_dc_val[0] = (src).last_dc_val[0], \
     74          	 (dest).last_dc_val[1] = (src).last_dc_val[1], \
     75          	 (dest).last_dc_val[2] = (src).last_dc_val[2], \
     76          	 (dest).last_dc_val[3] = (src).last_dc_val[3])
     77          #endif
     78          #endif
     79          
     80          
     81          typedef struct {
     82            struct jpeg_entropy_encoder pub; /* public fields */
     83          
     84            savable_state saved;		/* Bit buffer & DC state at start of MCU */
     85          
     86            /* These fields are NOT loaded into local working state. */
     87            unsigned int restarts_to_go;	/* MCUs left in this restart interval */
     88            int next_restart_num;		/* next restart number to write (0-7) */
     89          
     90            /* Following four fields used only in sequential mode */
     91          
     92            /* Pointers to derived tables (these workspaces have image lifespan) */
     93            c_derived_tbl * dc_derived_tbls[NUM_HUFF_TBLS];
     94            c_derived_tbl * ac_derived_tbls[NUM_HUFF_TBLS];
     95          
     96            /* Statistics tables for optimization */
     97            long * dc_count_ptrs[NUM_HUFF_TBLS];
     98            long * ac_count_ptrs[NUM_HUFF_TBLS];
     99          
    100            /* Following fields used only in progressive mode */
    101          
    102            /* Mode flag: TRUE for optimization, FALSE for actual data output */
    103            boolean gather_statistics;
    104          
    105            /* next_output_byte/free_in_buffer are local copies of cinfo->dest fields.
    106             */
    107            JOCTET * next_output_byte;	/* => next byte to write in buffer */
    108            size_t free_in_buffer;	/* # of byte spaces remaining in buffer */
    109            j_compress_ptr cinfo;		/* link to cinfo (needed for dump_buffer) */
    110          
    111            /* Coding status for AC components */
    112            int ac_tbl_no;		/* the table number of the single component */
    113            unsigned int EOBRUN;		/* run length of EOBs */
    114            unsigned int BE;		/* # of buffered correction bits before MCU */
    115            char * bit_buffer;		/* buffer for correction bits (1 per char) */
    116            /* packing correction bits tightly would save some space but cost time... */
    117          
    118            /* Pointers to derived tables (these workspaces have image lifespan).
    119             * Since any one scan in progressive mode codes only DC or only AC,
    120             * we only need one set of tables, not one for DC and one for AC.
    121             */
    122            c_derived_tbl * derived_tbls[NUM_HUFF_TBLS];
    123          
    124            /* Statistics tables for optimization; again, one set is enough */
    125            long * count_ptrs[NUM_HUFF_TBLS];
    126          } huff_entropy_encoder;
    127          
    128          typedef huff_entropy_encoder * huff_entropy_ptr;
    129          
    130          /* Working state while writing an MCU (sequential mode).
    131           * This struct contains all the fields that are needed by subroutines.
    132           */
    133          
    134          typedef struct {
    135            JOCTET * next_output_byte;	/* => next byte to write in buffer */
    136            size_t free_in_buffer;	/* # of byte spaces remaining in buffer */
    137            savable_state cur;		/* Current bit buffer & DC state */
    138            j_compress_ptr cinfo;		/* dump_buffer needs access to this */
    139          } working_state;
    140          
    141          /* MAX_CORR_BITS is the number of bits the AC refinement correction-bit
    142           * buffer can hold.  Larger sizes may slightly improve compression, but
    143           * 1000 is already well into the realm of overkill.
    144           * The minimum safe size is 64 bits.
    145           */
    146          
    147          #define MAX_CORR_BITS  1000	/* Max # of correction bits I can buffer */
    148          
    149          /* IRIGHT_SHIFT is like RIGHT_SHIFT, but works on int rather than INT32.
    150           * We assume that int right shift is unsigned if INT32 right shift is,
    151           * which should be safe.
    152           */
    153          
    154          #ifdef RIGHT_SHIFT_IS_UNSIGNED
    155          #define ISHIFT_TEMPS	int ishift_temp;
    156          #define IRIGHT_SHIFT(x,shft)  \
    157          	((ishift_temp = (x)) < 0 ? \
    158          	 (ishift_temp >> (shft)) | ((~0) << (16-(shft))) : \
    159          	 (ishift_temp >> (shft)))
    160          #else
    161          #define ISHIFT_TEMPS
    162          #define IRIGHT_SHIFT(x,shft)	((x) >> (shft))
    163          #endif
    164          
    165          
    166          /*
    167           * Compute the derived values for a Huffman table.
    168           * This routine also performs some validation checks on the table.
    169           */
    170          

   \                                 In segment CODE, align 4, keep-with-next
    171          LOCAL(void)
    172          jpeg_make_c_derived_tbl (j_compress_ptr cinfo, boolean isDC, int tblno,
    173          			 c_derived_tbl ** pdtbl)
    174          {
   \                     jpeg_make_c_derived_tbl:
   \   00000000   F24F2DE9           PUSH     {R1,R4-R11,LR}
   \   00000004   42DF4DE2           SUB      SP,SP,#+264
   \   00000008   40DE4DE2           SUB      SP,SP,#+1024
   \   0000000C   0060A0E1           MOV      R6,R0
   \   00000010   0240A0E1           MOV      R4,R2
   \   00000014   0350A0E1           MOV      R5,R3
    175            JHUFF_TBL *htbl;
    176            c_derived_tbl *dtbl;
    177            int p, i, l, lastp, si, maxsymbol;
    178            char huffsize[257];
    179            unsigned int huffcode[257];
    180            unsigned int code;
    181          
    182            /* Note that huffsize[] and huffcode[] are filled in code-length order,
    183             * paralleling the order of the symbols themselves in htbl->huffval[].
    184             */
    185          
    186            /* Find the input Huffman table */
    187            if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
   \   00000018   3480A0E3           MOV      R8,#+52
   \   0000001C   000054E3           CMP      R4,#+0
   \   00000020   0100004A           BMI      ??jpeg_make_c_derived_tbl_0
   \   00000024   040054E3           CMP      R4,#+4
   \   00000028   070000BA           BLT      ??jpeg_make_c_derived_tbl_1
    188              ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
   \                     ??jpeg_make_c_derived_tbl_0:
   \   0000002C   000096E5           LDR      R0,[R6, #+0]
   \   00000030   148080E5           STR      R8,[R0, #+20]
   \   00000034   000096E5           LDR      R0,[R6, #+0]
   \   00000038   184080E5           STR      R4,[R0, #+24]
   \   0000003C   001096E5           LDR      R1,[R6, #+0]
   \   00000040   0600A0E1           MOV      R0,R6
   \   00000044   001091E5           LDR      R1,[R1, #+0]
   \   00000048   31FF2FE1           BLX      R1
    189            htbl =
    190              isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
   \                     ??jpeg_make_c_derived_tbl_1:
   \   0000004C   08159DE5           LDR      R1,[SP, #+1288]
   \   00000050   040186E0           ADD      R0,R6,R4, LSL #+2
   \   00000054   000051E3           CMP      R1,#+0
   \   00000058   74709015           LDRNE    R7,[R0, #+116]
   \   0000005C   84709005           LDREQ    R7,[R0, #+132]
    191            if (htbl == NULL)
   \   00000060   000057E3           CMP      R7,#+0
   \   00000064   0700001A           BNE      ??jpeg_make_c_derived_tbl_2
    192              ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
   \   00000068   000096E5           LDR      R0,[R6, #+0]
   \   0000006C   148080E5           STR      R8,[R0, #+20]
   \   00000070   000096E5           LDR      R0,[R6, #+0]
   \   00000074   184080E5           STR      R4,[R0, #+24]
   \   00000078   001096E5           LDR      R1,[R6, #+0]
   \   0000007C   0600A0E1           MOV      R0,R6
   \   00000080   001091E5           LDR      R1,[R1, #+0]
   \   00000084   31FF2FE1           BLX      R1
    193          
    194            /* Allocate a workspace if we haven't already done so. */
    195            if (*pdtbl == NULL)
   \                     ??jpeg_make_c_derived_tbl_2:
   \   00000088   000095E5           LDR      R0,[R5, #+0]
   \   0000008C   000050E3           CMP      R0,#+0
   \   00000090   0600001A           BNE      ??jpeg_make_c_derived_tbl_3
    196              *pdtbl = (c_derived_tbl *)
    197                (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
    198          				  SIZEOF(c_derived_tbl));
   \   00000094   043096E5           LDR      R3,[R6, #+4]
   \   00000098   502EA0E3           MOV      R2,#+1280
   \   0000009C   003093E5           LDR      R3,[R3, #+0]
   \   000000A0   0110A0E3           MOV      R1,#+1
   \   000000A4   0600A0E1           MOV      R0,R6
   \   000000A8   33FF2FE1           BLX      R3
   \   000000AC   000085E5           STR      R0,[R5, #+0]
    199            dtbl = *pdtbl;
   \                     ??jpeg_make_c_derived_tbl_3:
   \   000000B0   008095E5           LDR      R8,[R5, #+0]
    200            
    201            /* Figure C.1: make table of Huffman code length for each symbol */
    202          
    203            p = 0;
   \   000000B4   0040A0E3           MOV      R4,#+0
    204            for (l = 1; l <= 16; l++) {
   \   000000B8   01A0A0E3           MOV      R10,#+1
   \   000000BC   0990A0E3           MOV      R9,#+9
    205              i = (int) htbl->bits[l];
   \                     ??jpeg_make_c_derived_tbl_4:
   \   000000C0   0750DAE7           LDRB     R5,[R10, +R7]
    206              if (i < 0 || p + i > 256)	/* protect against table overrun */
   \   000000C4   000055E3           CMP      R5,#+0
   \   000000C8   0300004A           BMI      ??jpeg_make_c_derived_tbl_5
   \   000000CC   040085E0           ADD      R0,R5,R4
   \   000000D0   F81089E2           ADD      R1,R9,#+248
   \   000000D4   010050E1           CMP      R0,R1
   \   000000D8   080000BA           BLT      ??jpeg_make_c_derived_tbl_6
    207                ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
   \                     ??jpeg_make_c_derived_tbl_5:
   \   000000DC   000096E5           LDR      R0,[R6, #+0]
   \   000000E0   149080E5           STR      R9,[R0, #+20]
   \   000000E4   001096E5           LDR      R1,[R6, #+0]
   \   000000E8   0600A0E1           MOV      R0,R6
   \   000000EC   001091E5           LDR      R1,[R1, #+0]
   \   000000F0   31FF2FE1           BLX      R1
   \   000000F4   010000EA           B        ??jpeg_make_c_derived_tbl_6
    208              while (i--)
    209                huffsize[p++] = (char) l;
   \                     ??jpeg_make_c_derived_tbl_7:
   \   000000F8   00A0C0E5           STRB     R10,[R0, #+0]
   \   000000FC   014084E2           ADD      R4,R4,#+1
   \                     ??jpeg_make_c_derived_tbl_6:
   \   00000100   0510A0E1           MOV      R1,R5
   \   00000104   015041E2           SUB      R5,R1,#+1
   \   00000108   04008DE2           ADD      R0,SP,#+4
   \   0000010C   400E80E2           ADD      R0,R0,#+1024
   \   00000110   000084E0           ADD      R0,R4,R0
   \   00000114   000051E3           CMP      R1,#+0
   \   00000118   F6FFFF1A           BNE      ??jpeg_make_c_derived_tbl_7
    210            }
   \   0000011C   01A08AE2           ADD      R10,R10,#+1
   \   00000120   11005AE3           CMP      R10,#+17
   \   00000124   E5FFFFBA           BLT      ??jpeg_make_c_derived_tbl_4
    211            huffsize[p] = 0;
   \   00000128   0050A0E3           MOV      R5,#+0
   \   0000012C   0050C0E5           STRB     R5,[R0, #+0]
    212            lastp = p;
    213            
    214            /* Figure C.2: generate the codes themselves */
    215            /* We also validate that the counts represent a legal Huffman code tree. */
    216          
    217            code = 0;
    218            si = huffsize[0];
   \   00000130   04A4DDE5           LDRB     R10,[SP, #+1028]
    219            p = 0;
   \   00000134   00B0A0E3           MOV      R11,#+0
   \   00000138   00005AE3           CMP      R10,#+0
   \   0000013C   1400001A           BNE      ??jpeg_make_c_derived_tbl_8
   \   00000140   180000EA           B        ??jpeg_make_c_derived_tbl_9
    220            while (huffsize[p]) {
    221              while (((int) huffsize[p]) == si) {
    222                huffcode[p++] = code;
   \                     ??jpeg_make_c_derived_tbl_10:
   \   00000144   0D00A0E1           MOV      R0,SP
   \   00000148   0B5180E7           STR      R5,[R0, +R11, LSL #+2]
   \   0000014C   01B08BE2           ADD      R11,R11,#+1
    223                code++;
   \   00000150   015085E2           ADD      R5,R5,#+1
    224              }
   \                     ??jpeg_make_c_derived_tbl_11:
   \   00000154   04008DE2           ADD      R0,SP,#+4
   \   00000158   400E80E2           ADD      R0,R0,#+1024
   \   0000015C   0000DBE7           LDRB     R0,[R11, +R0]
   \   00000160   0A0050E1           CMP      R0,R10
   \   00000164   F6FFFF0A           BEQ      ??jpeg_make_c_derived_tbl_10
    225              /* code is now 1 more than the last code used for codelength si; but
    226               * it must still fit in si bits, since no code is allowed to be all ones.
    227               */
    228              if (((INT32) code) >= (((INT32) 1) << si))
   \   00000168   0100A0E3           MOV      R0,#+1
   \   0000016C   100A55E1           CMP      R5,R0, LSL R10
   \   00000170   050000BA           BLT      ??jpeg_make_c_derived_tbl_12
    229                ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
   \   00000174   000096E5           LDR      R0,[R6, #+0]
   \   00000178   149080E5           STR      R9,[R0, #+20]
   \   0000017C   001096E5           LDR      R1,[R6, #+0]
   \   00000180   0600A0E1           MOV      R0,R6
   \   00000184   001091E5           LDR      R1,[R1, #+0]
   \   00000188   31FF2FE1           BLX      R1
    230              code <<= 1;
   \                     ??jpeg_make_c_derived_tbl_12:
   \   0000018C   8550A0E1           LSL      R5,R5,#+1
    231              si++;
   \   00000190   01A08AE2           ADD      R10,R10,#+1
    232            }
   \                     ??jpeg_make_c_derived_tbl_8:
   \   00000194   04008DE2           ADD      R0,SP,#+4
   \   00000198   400E80E2           ADD      R0,R0,#+1024
   \   0000019C   0000DBE7           LDRB     R0,[R11, +R0]
   \   000001A0   000050E3           CMP      R0,#+0
   \   000001A4   EAFFFF1A           BNE      ??jpeg_make_c_derived_tbl_11
    233            
    234            /* Figure C.3: generate encoding tables */
    235            /* These are code and size indexed by symbol value */
    236          
    237            /* Set all codeless symbols to have code length 0;
    238             * this lets us detect duplicate VAL entries here, and later
    239             * allows emit_bits to detect any attempt to emit such symbols.
    240             */
    241            MEMZERO(dtbl->ehufsi, SIZEOF(dtbl->ehufsi));
   \                     ??jpeg_make_c_derived_tbl_9:
   \   000001A8   402FA0E3           MOV      R2,#+256
   \   000001AC   0010A0E3           MOV      R1,#+0
   \   000001B0   400E88E2           ADD      R0,R8,#+1024
   \   000001B4   BB0000EF           SWI      +187
    242          
    243            /* This is also a convenient place to check for out-of-range
    244             * and duplicated VAL entries.  We allow 0..255 for AC symbols
    245             * but only 0..15 for DC.  (We could constrain them further
    246             * based on data depth and mode, but this seems enough.)
    247             */
    248            maxsymbol = isDC ? 15 : 255;
   \   000001B8   08059DE5           LDR      R0,[SP, #+1288]
    249          
    250            for (p = 0; p < lastp; p++) {
   \   000001BC   00B0A0E3           MOV      R11,#+0
   \   000001C0   000050E3           CMP      R0,#+0
   \   000001C4   0FA0A013           MOVNE    R10,#+15
   \   000001C8   FFA0A003           MOVEQ    R10,#+255
   \   000001CC   010054E3           CMP      R4,#+1
   \   000001D0   1B0000AA           BGE      ??jpeg_make_c_derived_tbl_13
   \   000001D4   43DF8DE2           ADD      SP,SP,#+268
   \   000001D8   40DE8DE2           ADD      SP,SP,#+1024
   \   000001DC   F08FBDE8           POP      {R4-R11,PC}
    251              i = htbl->huffval[p];
   \                     ??jpeg_make_c_derived_tbl_14:
   \   000001E0   07008BE0           ADD      R0,R11,R7
   \   000001E4   1150D0E5           LDRB     R5,[R0, #+17]
    252              if (i < 0 || i > maxsymbol || dtbl->ehufsi[i])
   \   000001E8   000055E3           CMP      R5,#+0
   \   000001EC   0500004A           BMI      ??jpeg_make_c_derived_tbl_15
   \   000001F0   05005AE1           CMP      R10,R5
   \   000001F4   030000BA           BLT      ??jpeg_make_c_derived_tbl_15
   \   000001F8   080085E0           ADD      R0,R5,R8
   \   000001FC   0004D0E5           LDRB     R0,[R0, #+1024]
   \   00000200   000050E3           CMP      R0,#+0
   \   00000204   0500000A           BEQ      ??jpeg_make_c_derived_tbl_16
    253                ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
   \                     ??jpeg_make_c_derived_tbl_15:
   \   00000208   000096E5           LDR      R0,[R6, #+0]
   \   0000020C   149080E5           STR      R9,[R0, #+20]
   \   00000210   001096E5           LDR      R1,[R6, #+0]
   \   00000214   0600A0E1           MOV      R0,R6
   \   00000218   001091E5           LDR      R1,[R1, #+0]
   \   0000021C   31FF2FE1           BLX      R1
    254              dtbl->ehufco[i] = huffcode[p];
   \                     ??jpeg_make_c_derived_tbl_16:
   \   00000220   0D00A0E1           MOV      R0,SP
   \   00000224   0B0190E7           LDR      R0,[R0, +R11, LSL #+2]
    255              dtbl->ehufsi[i] = huffsize[p];
   \   00000228   04108DE2           ADD      R1,SP,#+4
   \   0000022C   050188E7           STR      R0,[R8, +R5, LSL #+2]
   \   00000230   401E81E2           ADD      R1,R1,#+1024
   \   00000234   0110DBE7           LDRB     R1,[R11, +R1]
   \   00000238   080085E0           ADD      R0,R5,R8
    256            }
   \   0000023C   01B08BE2           ADD      R11,R11,#+1
   \   00000240   0014C0E5           STRB     R1,[R0, #+1024]
   \                     ??jpeg_make_c_derived_tbl_13:
   \   00000244   04005BE1           CMP      R11,R4
   \   00000248   E4FFFFBA           BLT      ??jpeg_make_c_derived_tbl_14
    257          }
   \   0000024C   43DF8DE2           ADD      SP,SP,#+268
   \   00000250   40DE8DE2           ADD      SP,SP,#+1024
   \   00000254   F08FBDE8           POP      {R4-R11,PC}      ;; return
    258          
    259          
    260          /* Outputting bytes to the file.
    261           * NB: these must be called only when actually outputting,
    262           * that is, entropy->gather_statistics == FALSE.
    263           */
    264          
    265          /* Emit a byte, taking 'action' if must suspend. */
    266          #define emit_byte_s(state,val,action)  \
    267          	{ *(state)->next_output_byte++ = (JOCTET) (val);  \
    268          	  if (--(state)->free_in_buffer == 0)  \
    269          	    if (! dump_buffer_s(state))  \
    270          	      { action; } }
    271          
    272          /* Emit a byte */
    273          #define emit_byte_e(entropy,val)  \
    274          	{ *(entropy)->next_output_byte++ = (JOCTET) (val);  \
    275          	  if (--(entropy)->free_in_buffer == 0)  \
    276          	    dump_buffer_e(entropy); }
    277          
    278          

   \                                 In segment CODE, align 4, keep-with-next
    279          LOCAL(boolean)
    280          dump_buffer_s (working_state * state)
    281          /* Empty the output buffer; return TRUE if successful, FALSE if must suspend */
    282          {
   \                     dump_buffer_s:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    283            struct jpeg_destination_mgr * dest = state->cinfo->dest;
   \   00000008   200094E5           LDR      R0,[R4, #+32]
   \   0000000C   185090E5           LDR      R5,[R0, #+24]
    284          
    285            if (! (*dest->empty_output_buffer) (state->cinfo))
   \   00000010   0C1095E5           LDR      R1,[R5, #+12]
   \   00000014   31FF2FE1           BLX      R1
   \   00000018   000050E3           CMP      R0,#+0
    286              return FALSE;
   \   0000001C   3080BD08           POPEQ    {R4,R5,PC}
    287            /* After a successful buffer dump, must reset buffer pointers */
    288            state->next_output_byte = dest->next_output_byte;
   \   00000020   000095E5           LDR      R0,[R5, #+0]
   \   00000024   000084E5           STR      R0,[R4, #+0]
    289            state->free_in_buffer = dest->free_in_buffer;
   \   00000028   040095E5           LDR      R0,[R5, #+4]
   \   0000002C   040084E5           STR      R0,[R4, #+4]
    290            return TRUE;
   \   00000030   0100A0E3           MOV      R0,#+1
   \   00000034   3080BDE8           POP      {R4,R5,PC}       ;; return
    291          }
    292          
    293          

   \                                 In segment CODE, align 4, keep-with-next
    294          LOCAL(void)
    295          dump_buffer_e (huff_entropy_ptr entropy)
    296          /* Empty the output buffer; we do not support suspension in this case. */
    297          {
   \                     dump_buffer_e:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    298            struct jpeg_destination_mgr * dest = entropy->cinfo->dest;
   \   00000008   780094E5           LDR      R0,[R4, #+120]
   \   0000000C   185090E5           LDR      R5,[R0, #+24]
    299          
    300            if (! (*dest->empty_output_buffer) (entropy->cinfo))
   \   00000010   0C1095E5           LDR      R1,[R5, #+12]
   \   00000014   31FF2FE1           BLX      R1
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0800001A           BNE      ??dump_buffer_e_0
    301              ERREXIT(entropy->cinfo, JERR_CANT_SUSPEND);
   \   00000020   780094E5           LDR      R0,[R4, #+120]
   \   00000024   1910A0E3           MOV      R1,#+25
   \   00000028   000090E5           LDR      R0,[R0, #+0]
   \   0000002C   141080E5           STR      R1,[R0, #+20]
   \   00000030   781094E5           LDR      R1,[R4, #+120]
   \   00000034   0100A0E1           MOV      R0,R1
   \   00000038   001091E5           LDR      R1,[R1, #+0]
   \   0000003C   001091E5           LDR      R1,[R1, #+0]
   \   00000040   31FF2FE1           BLX      R1
    302            /* After a successful buffer dump, must reset buffer pointers */
    303            entropy->next_output_byte = dest->next_output_byte;
   \                     ??dump_buffer_e_0:
   \   00000044   000095E5           LDR      R0,[R5, #+0]
   \   00000048   700084E5           STR      R0,[R4, #+112]
    304            entropy->free_in_buffer = dest->free_in_buffer;
   \   0000004C   040095E5           LDR      R0,[R5, #+4]
   \   00000050   740084E5           STR      R0,[R4, #+116]
    305          }
   \   00000054   3080BDE8           POP      {R4,R5,PC}       ;; return
    306          
    307          
    308          /* Outputting bits to the file */
    309          
    310          /* Only the right 24 bits of put_buffer are used; the valid bits are
    311           * left-justified in this part.  At most 16 bits can be passed to emit_bits
    312           * in one call, and we never retain more than 7 bits in put_buffer
    313           * between calls, so 24 bits are sufficient.
    314           */
    315          
    316          INLINE

   \                                 In segment CODE, align 4, keep-with-next
    317          LOCAL(boolean)
    318          emit_bits_s (working_state * state, unsigned int code, int size)
    319          /* Emit some bits; return TRUE if successful, FALSE if must suspend */
    320          {
   \                     emit_bits_s:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    321            /* This routine is heavily used, so it's worth coding tightly. */
    322            register INT32 put_buffer = (INT32) code;
    323            register int put_bits = state->cur.put_bits;
   \   00000008   0C5094E5           LDR      R5,[R4, #+12]
   \   0000000C   0160A0E1           MOV      R6,R1
   \   00000010   0270B0E1           MOVS     R7,R2
    324          
    325            /* if size is 0, caller used an invalid Huffman table entry */
    326            if (size == 0)
   \   00000014   0800001A           BNE      ??emit_bits_s_0
    327              ERREXIT(state->cinfo, JERR_HUFF_MISSING_CODE);
   \   00000018   200094E5           LDR      R0,[R4, #+32]
   \   0000001C   2910A0E3           MOV      R1,#+41
   \   00000020   000090E5           LDR      R0,[R0, #+0]
   \   00000024   141080E5           STR      R1,[R0, #+20]
   \   00000028   201094E5           LDR      R1,[R4, #+32]
   \   0000002C   0100A0E1           MOV      R0,R1
   \   00000030   001091E5           LDR      R1,[R1, #+0]
   \   00000034   001091E5           LDR      R1,[R1, #+0]
   \   00000038   31FF2FE1           BLX      R1
    328          
    329            put_buffer &= (((INT32) 1)<<size) - 1; /* mask off any extra bits in code */
    330            
    331            put_bits += size;		/* new number of bits in buffer */
    332            
    333            put_buffer <<= 24 - put_bits; /* align incoming bits */
    334          
    335            put_buffer |= state->cur.put_buffer; /* and merge with old buffer contents */
   \                     ??emit_bits_s_0:
   \   0000003C   082094E5           LDR      R2,[R4, #+8]
   \   00000040   055087E0           ADD      R5,R7,R5
   \   00000044   0100A0E3           MOV      R0,#+1
   \   00000048   1007A0E1           LSL      R0,R0,R7
   \   0000004C   010040E2           SUB      R0,R0,#+1
   \   00000050   060000E0           AND      R0,R0,R6
   \   00000054   0510A0E1           MOV      R1,R5
   \   00000058   181061E2           RSB      R1,R1,#+24
   \   0000005C   106182E1           ORR      R6,R2,R0, LSL R1
   \   00000060   100000EA           B        ??emit_bits_s_1
    336            
    337            while (put_bits >= 8) {
    338              int c = (int) ((put_buffer >> 16) & 0xFF);
    339              
    340              emit_byte_s(state, c, return FALSE);
    341              if (c == 0xFF) {		/* need to stuff a zero byte? */
   \                     ??emit_bits_s_2:
   \   00000064   FF0057E3           CMP      R7,#+255
   \   00000068   0C00001A           BNE      ??emit_bits_s_3
    342                emit_byte_s(state, 0, return FALSE);
   \   0000006C   000094E5           LDR      R0,[R4, #+0]
   \   00000070   011080E2           ADD      R1,R0,#+1
   \   00000074   001084E5           STR      R1,[R4, #+0]
   \   00000078   0010A0E3           MOV      R1,#+0
   \   0000007C   0010C0E5           STRB     R1,[R0, #+0]
   \   00000080   040094E5           LDR      R0,[R4, #+4]
   \   00000084   010050E2           SUBS     R0,R0,#+1
   \   00000088   040084E5           STR      R0,[R4, #+4]
   \   0000008C   0300001A           BNE      ??emit_bits_s_3
   \   00000090   0400A0E1           MOV      R0,R4
   \   00000094   ........           BL       dump_buffer_s
   \   00000098   000050E3           CMP      R0,#+0
   \   0000009C   F080BD08           POPEQ    {R4-R7,PC}
    343              }
    344              put_buffer <<= 8;
   \                     ??emit_bits_s_3:
   \   000000A0   0664A0E1           LSL      R6,R6,#+8
    345              put_bits -= 8;
   \   000000A4   085045E2           SUB      R5,R5,#+8
   \                     ??emit_bits_s_1:
   \   000000A8   080055E3           CMP      R5,#+8
   \   000000AC   0E0000BA           BLT      ??emit_bits_s_4
   \   000000B0   FF00A0E3           MOV      R0,#+255
   \   000000B4   467800E0           AND      R7,R0,R6, ASR #+16
   \   000000B8   000094E5           LDR      R0,[R4, #+0]
   \   000000BC   011080E2           ADD      R1,R0,#+1
   \   000000C0   001084E5           STR      R1,[R4, #+0]
   \   000000C4   0070C0E5           STRB     R7,[R0, #+0]
   \   000000C8   040094E5           LDR      R0,[R4, #+4]
   \   000000CC   010050E2           SUBS     R0,R0,#+1
   \   000000D0   040084E5           STR      R0,[R4, #+4]
   \   000000D4   E2FFFF1A           BNE      ??emit_bits_s_2
   \   000000D8   0400A0E1           MOV      R0,R4
   \   000000DC   ........           BL       dump_buffer_s
   \   000000E0   000050E3           CMP      R0,#+0
   \   000000E4   DEFFFF1A           BNE      ??emit_bits_s_2
   \   000000E8   F080BDE8           POP      {R4-R7,PC}
    346            }
    347          
    348            state->cur.put_buffer = put_buffer; /* update state variables */
   \                     ??emit_bits_s_4:
   \   000000EC   086084E5           STR      R6,[R4, #+8]
    349            state->cur.put_bits = put_bits;
   \   000000F0   0C5084E5           STR      R5,[R4, #+12]
    350          
    351            return TRUE;
   \   000000F4   0100A0E3           MOV      R0,#+1
   \   000000F8   F080BDE8           POP      {R4-R7,PC}       ;; return
    352          }
    353          
    354          
    355          INLINE

   \                                 In segment CODE, align 4, keep-with-next
    356          LOCAL(void)
    357          emit_bits_e (huff_entropy_ptr entropy, unsigned int code, int size)
    358          /* Emit some bits, unless we are in gather mode */
    359          {
   \                     emit_bits_e:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    360            /* This routine is heavily used, so it's worth coding tightly. */
    361            register INT32 put_buffer = (INT32) code;
    362            register int put_bits = entropy->saved.put_bits;
   \   00000008   105094E5           LDR      R5,[R4, #+16]
   \   0000000C   0160A0E1           MOV      R6,R1
   \   00000010   0270B0E1           MOVS     R7,R2
    363          
    364            /* if size is 0, caller used an invalid Huffman table entry */
    365            if (size == 0)
   \   00000014   0800001A           BNE      ??emit_bits_e_0
    366              ERREXIT(entropy->cinfo, JERR_HUFF_MISSING_CODE);
   \   00000018   780094E5           LDR      R0,[R4, #+120]
   \   0000001C   2910A0E3           MOV      R1,#+41
   \   00000020   000090E5           LDR      R0,[R0, #+0]
   \   00000024   141080E5           STR      R1,[R0, #+20]
   \   00000028   781094E5           LDR      R1,[R4, #+120]
   \   0000002C   0100A0E1           MOV      R0,R1
   \   00000030   001091E5           LDR      R1,[R1, #+0]
   \   00000034   001091E5           LDR      R1,[R1, #+0]
   \   00000038   31FF2FE1           BLX      R1
    367          
    368            if (entropy->gather_statistics)
   \                     ??emit_bits_e_0:
   \   0000003C   6C0094E5           LDR      R0,[R4, #+108]
   \   00000040   000050E3           CMP      R0,#+0
   \   00000044   F080BD18           POPNE    {R4-R7,PC}
    369              return;			/* do nothing if we're only getting stats */
    370          
    371            put_buffer &= (((INT32) 1)<<size) - 1; /* mask off any extra bits in code */
    372            
    373            put_bits += size;		/* new number of bits in buffer */
    374          
    375            put_buffer <<= 24 - put_bits; /* align incoming bits */
    376          
    377            /* and merge with old buffer contents */
    378            put_buffer |= entropy->saved.put_buffer;
   \   00000048   0C2094E5           LDR      R2,[R4, #+12]
   \   0000004C   055087E0           ADD      R5,R7,R5
   \   00000050   0100A0E3           MOV      R0,#+1
   \   00000054   1007A0E1           LSL      R0,R0,R7
   \   00000058   010040E2           SUB      R0,R0,#+1
   \   0000005C   060000E0           AND      R0,R0,R6
   \   00000060   0510A0E1           MOV      R1,R5
   \   00000064   181061E2           RSB      R1,R1,#+24
   \   00000068   106182E1           ORR      R6,R2,R0, LSL R1
   \   0000006C   080055E3           CMP      R5,#+8
   \   00000070   1C0000BA           BLT      ??emit_bits_e_1
    379          
    380            while (put_bits >= 8) {
    381              int c = (int) ((put_buffer >> 16) & 0xFF);
   \                     ??emit_bits_e_2:
   \   00000074   FF00A0E3           MOV      R0,#+255
   \   00000078   467800E0           AND      R7,R0,R6, ASR #+16
    382          
    383              emit_byte_e(entropy, c);
   \   0000007C   700094E5           LDR      R0,[R4, #+112]
   \   00000080   011080E2           ADD      R1,R0,#+1
   \   00000084   701084E5           STR      R1,[R4, #+112]
   \   00000088   0070C0E5           STRB     R7,[R0, #+0]
   \   0000008C   740094E5           LDR      R0,[R4, #+116]
   \   00000090   010050E2           SUBS     R0,R0,#+1
   \   00000094   740084E5           STR      R0,[R4, #+116]
   \   00000098   0100001A           BNE      ??emit_bits_e_3
   \   0000009C   0400A0E1           MOV      R0,R4
   \   000000A0   ........           BL       dump_buffer_e
    384              if (c == 0xFF) {		/* need to stuff a zero byte? */
   \                     ??emit_bits_e_3:
   \   000000A4   FF0057E3           CMP      R7,#+255
   \   000000A8   0A00001A           BNE      ??emit_bits_e_4
    385                emit_byte_e(entropy, 0);
   \   000000AC   700094E5           LDR      R0,[R4, #+112]
   \   000000B0   011080E2           ADD      R1,R0,#+1
   \   000000B4   701084E5           STR      R1,[R4, #+112]
   \   000000B8   0010A0E3           MOV      R1,#+0
   \   000000BC   0010C0E5           STRB     R1,[R0, #+0]
   \   000000C0   740094E5           LDR      R0,[R4, #+116]
   \   000000C4   010050E2           SUBS     R0,R0,#+1
   \   000000C8   740084E5           STR      R0,[R4, #+116]
   \   000000CC   0100001A           BNE      ??emit_bits_e_4
   \   000000D0   0400A0E1           MOV      R0,R4
   \   000000D4   ........           BL       dump_buffer_e
    386              }
    387              put_buffer <<= 8;
   \                     ??emit_bits_e_4:
   \   000000D8   0664A0E1           LSL      R6,R6,#+8
    388              put_bits -= 8;
   \   000000DC   085045E2           SUB      R5,R5,#+8
    389            }
   \   000000E0   080055E3           CMP      R5,#+8
   \   000000E4   E2FFFFAA           BGE      ??emit_bits_e_2
    390          
    391            entropy->saved.put_buffer = put_buffer; /* update variables */
   \                     ??emit_bits_e_1:
   \   000000E8   0C6084E5           STR      R6,[R4, #+12]
    392            entropy->saved.put_bits = put_bits;
   \   000000EC   105084E5           STR      R5,[R4, #+16]
    393          }
   \   000000F0   F080BDE8           POP      {R4-R7,PC}       ;; return
    394          
    395          
    396          LOCAL(boolean)
    397          flush_bits_s (working_state * state)
    398          {
    399            if (! emit_bits_s(state, 0x7F, 7)) /* fill any partial byte with ones */
    400              return FALSE;
    401            state->cur.put_buffer = 0;	     /* and reset bit-buffer to empty */
    402            state->cur.put_bits = 0;
    403            return TRUE;
    404          }
    405          
    406          
    407          LOCAL(void)
    408          flush_bits_e (huff_entropy_ptr entropy)
    409          {
    410            emit_bits_e(entropy, 0x7F, 7); /* fill any partial byte with ones */
    411            entropy->saved.put_buffer = 0; /* and reset bit-buffer to empty */
    412            entropy->saved.put_bits = 0;
    413          }
    414          
    415          
    416          /*
    417           * Emit (or just count) a Huffman symbol.
    418           */
    419          
    420          INLINE

   \                                 In segment CODE, align 4, keep-with-next
    421          LOCAL(void)
    422          emit_symbol (huff_entropy_ptr entropy, int tbl_no, int symbol)
    423          {
   \                     emit_symbol:
   \   00000000   0230A0E1           MOV      R3,R2
    424            if (entropy->gather_statistics)
   \   00000004   6C2090E5           LDR      R2,[R0, #+108]
   \   00000008   011180E0           ADD      R1,R0,R1, LSL #+2
   \   0000000C   000052E3           CMP      R2,#+0
   \   00000010   0400000A           BEQ      ??emit_symbol_0
    425              entropy->count_ptrs[tbl_no][symbol]++;
   \   00000014   9C0091E5           LDR      R0,[R1, #+156]
   \   00000018   031190E7           LDR      R1,[R0, +R3, LSL #+2]
   \   0000001C   011081E2           ADD      R1,R1,#+1
   \   00000020   031180E7           STR      R1,[R0, +R3, LSL #+2]
   \   00000024   1EFF2FE1           BX       LR
    426            else {
    427              c_derived_tbl * tbl = entropy->derived_tbls[tbl_no];
   \                     ??emit_symbol_0:
   \   00000028   8C1091E5           LDR      R1,[R1, #+140]
    428              emit_bits_e(entropy, tbl->ehufco[symbol], tbl->ehufsi[symbol]);
   \   0000002C   012083E0           ADD      R2,R3,R1
   \   00000030   0024D2E5           LDRB     R2,[R2, #+1024]
   \   00000034   031191E7           LDR      R1,[R1, +R3, LSL #+2]
   \   00000038   ........           B        emit_bits_e      ;; tailcall
    429            }
    430          }
    431          
    432          
    433          /*
    434           * Emit bits from a correction bit buffer.
    435           */
    436          
    437          LOCAL(void)
    438          emit_buffered_bits (huff_entropy_ptr entropy, char * bufstart,
    439          		    unsigned int nbits)
    440          {
    441            if (entropy->gather_statistics)
    442              return;			/* no real work */
    443          
    444            while (nbits > 0) {
    445              emit_bits_e(entropy, (unsigned int) (*bufstart), 1);
    446              bufstart++;
    447              nbits--;
    448            }
    449          }
    450          
    451          
    452          /*
    453           * Emit any pending EOBRUN symbol.
    454           */
    455          

   \                                 In segment CODE, align 4, keep-with-next
    456          LOCAL(void)
    457          emit_eobrun (huff_entropy_ptr entropy)
    458          {
   \                     emit_eobrun:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    459            register int temp, nbits;
    460          
    461            if (entropy->EOBRUN > 0) {	/* if there is any pending EOBRUN */
   \   00000008   800094E5           LDR      R0,[R4, #+128]
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   F080BD08           POPEQ    {R4-R7,PC}
    462              temp = entropy->EOBRUN;
    463              nbits = 0;
   \   00000014   0050A0E3           MOV      R5,#+0
   \   00000018   000000EA           B        ??emit_eobrun_0
    464              while ((temp >>= 1))
    465                nbits++;
   \                     ??emit_eobrun_1:
   \   0000001C   015085E2           ADD      R5,R5,#+1
   \                     ??emit_eobrun_0:
   \   00000020   C000B0E1           ASRS     R0,R0,#+1
   \   00000024   FCFFFF1A           BNE      ??emit_eobrun_1
    466              /* safety check: shouldn't happen given limited correction-bit buffer */
    467              if (nbits > 14)
   \   00000028   0F0055E3           CMP      R5,#+15
   \   0000002C   080000BA           BLT      ??emit_eobrun_2
    468                ERREXIT(entropy->cinfo, JERR_HUFF_MISSING_CODE);
   \   00000030   780094E5           LDR      R0,[R4, #+120]
   \   00000034   2910A0E3           MOV      R1,#+41
   \   00000038   000090E5           LDR      R0,[R0, #+0]
   \   0000003C   141080E5           STR      R1,[R0, #+20]
   \   00000040   781094E5           LDR      R1,[R4, #+120]
   \   00000044   0100A0E1           MOV      R0,R1
   \   00000048   001091E5           LDR      R1,[R1, #+0]
   \   0000004C   001091E5           LDR      R1,[R1, #+0]
   \   00000050   31FF2FE1           BLX      R1
    469          
    470              emit_symbol(entropy, entropy->ac_tbl_no, nbits << 4);
   \                     ??emit_eobrun_2:
   \   00000054   7C1094E5           LDR      R1,[R4, #+124]
   \   00000058   0522A0E1           LSL      R2,R5,#+4
   \   0000005C   0400A0E1           MOV      R0,R4
   \   00000060   ........           BL       emit_symbol
    471              if (nbits)
   \   00000064   000055E3           CMP      R5,#+0
   \   00000068   0400000A           BEQ      ??emit_eobrun_3
    472                emit_bits_e(entropy, entropy->EOBRUN, nbits);
   \   0000006C   801094E5           LDR      R1,[R4, #+128]
   \   00000070   0520A0E1           MOV      R2,R5
   \   00000074   0400A0E1           MOV      R0,R4
   \   00000078   ........           BL       emit_bits_e
    473          
    474              entropy->EOBRUN = 0;
   \   0000007C   0050A0E3           MOV      R5,#+0
   \                     ??emit_eobrun_3:
   \   00000080   805084E5           STR      R5,[R4, #+128]
    475          
    476              /* Emit any buffered correction bits */
    477              emit_buffered_bits(entropy, entropy->bit_buffer, entropy->BE);
   \   00000084   6C0094E5           LDR      R0,[R4, #+108]
   \   00000088   846094E5           LDR      R6,[R4, #+132]
   \   0000008C   887094E5           LDR      R7,[R4, #+136]
   \   00000090   000050E3           CMP      R0,#+0
   \   00000094   0700001A           BNE      ??emit_eobrun_4
   \   00000098   000056E3           CMP      R6,#+0
   \   0000009C   040000EA           B        ??emit_eobrun_5
   \                     ??emit_eobrun_6:
   \   000000A0   ........           LDRB     R1,[R7], #+1
   \   000000A4   0120A0E3           MOV      R2,#+1
   \   000000A8   0400A0E1           MOV      R0,R4
   \   000000AC   ........           BL       emit_bits_e
   \   000000B0   016056E2           SUBS     R6,R6,#+1
   \                     ??emit_eobrun_5:
   \   000000B4   F9FFFF1A           BNE      ??emit_eobrun_6
    478              entropy->BE = 0;
   \                     ??emit_eobrun_4:
   \   000000B8   845084E5           STR      R5,[R4, #+132]
    479            }
    480          }
   \   000000BC   F080BDE8           POP      {R4-R7,PC}       ;; return
    481          
    482          
    483          /*
    484           * Emit a restart marker & resynchronize predictions.
    485           */
    486          

   \                                 In segment CODE, align 4, keep-with-next
    487          LOCAL(boolean)
    488          emit_restart_s (working_state * state, int restart_num)
    489          {
   \                     emit_restart_s:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    490            int ci;
    491          
    492            if (! flush_bits_s(state))
   \   00000008   0720A0E3           MOV      R2,#+7
   \   0000000C   0160A0E1           MOV      R6,R1
   \   00000010   7F10A0E3           MOV      R1,#+127
   \   00000014   ........           BL       emit_bits_s
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   7080BD08           POPEQ    {R4-R6,PC}
   \   00000020   0050A0E3           MOV      R5,#+0
   \   00000024   085084E5           STR      R5,[R4, #+8]
   \   00000028   0C5084E5           STR      R5,[R4, #+12]
    493              return FALSE;
    494          
    495            emit_byte_s(state, 0xFF, return FALSE);
   \   0000002C   000094E5           LDR      R0,[R4, #+0]
   \   00000030   011080E2           ADD      R1,R0,#+1
   \   00000034   001084E5           STR      R1,[R4, #+0]
   \   00000038   FF10A0E3           MOV      R1,#+255
   \   0000003C   0010C0E5           STRB     R1,[R0, #+0]
   \   00000040   040094E5           LDR      R0,[R4, #+4]
   \   00000044   010040E2           SUB      R0,R0,#+1
   \   00000048   040084E5           STR      R0,[R4, #+4]
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   0300001A           BNE      ??emit_restart_s_0
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   ........           BL       dump_buffer_s
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   7080BD08           POPEQ    {R4-R6,PC}
    496            emit_byte_s(state, JPEG_RST0 + restart_num, return FALSE);
   \                     ??emit_restart_s_0:
   \   00000064   000094E5           LDR      R0,[R4, #+0]
   \   00000068   011080E2           ADD      R1,R0,#+1
   \   0000006C   001084E5           STR      R1,[R4, #+0]
   \   00000070   D01086E2           ADD      R1,R6,#+208
   \   00000074   0010C0E5           STRB     R1,[R0, #+0]
   \   00000078   040094E5           LDR      R0,[R4, #+4]
   \   0000007C   010040E2           SUB      R0,R0,#+1
   \   00000080   040084E5           STR      R0,[R4, #+4]
   \   00000084   000050E3           CMP      R0,#+0
   \   00000088   0300001A           BNE      ??emit_restart_s_1
   \   0000008C   0400A0E1           MOV      R0,R4
   \   00000090   ........           BL       dump_buffer_s
   \   00000094   000050E3           CMP      R0,#+0
   \   00000098   7080BD08           POPEQ    {R4-R6,PC}
    497          
    498            /* Re-initialize DC predictions to 0 */
    499            for (ci = 0; ci < state->cinfo->comps_in_scan; ci++)
   \                     ??emit_restart_s_1:
   \   0000009C   201094E5           LDR      R1,[R4, #+32]
   \   000000A0   0000A0E3           MOV      R0,#+0
   \   000000A4   1C1191E5           LDR      R1,[R1, #+284]
   \   000000A8   010051E3           CMP      R1,#+1
   \   000000AC   040000AA           BGE      ??emit_restart_s_2
   \   000000B0   0100A0E3           MOV      R0,#+1
   \   000000B4   7080BDE8           POP      {R4-R6,PC}
    500              state->cur.last_dc_val[ci] = 0;
   \                     ??emit_restart_s_3:
   \   000000B8   001184E0           ADD      R1,R4,R0, LSL #+2
   \   000000BC   105081E5           STR      R5,[R1, #+16]
   \   000000C0   010080E2           ADD      R0,R0,#+1
   \                     ??emit_restart_s_2:
   \   000000C4   201094E5           LDR      R1,[R4, #+32]
   \   000000C8   1C1191E5           LDR      R1,[R1, #+284]
   \   000000CC   010050E1           CMP      R0,R1
   \   000000D0   F8FFFFBA           BLT      ??emit_restart_s_3
    501          
    502            /* The restart counter is not updated until we successfully write the MCU. */
    503          
    504            return TRUE;
   \   000000D4   0100A0E3           MOV      R0,#+1
   \   000000D8   7080BDE8           POP      {R4-R6,PC}       ;; return
    505          }
    506          
    507          

   \                                 In segment CODE, align 4, keep-with-next
    508          LOCAL(void)
    509          emit_restart_e (huff_entropy_ptr entropy, int restart_num)
    510          {
   \                     emit_restart_e:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    511            int ci;
    512          
    513            emit_eobrun(entropy);
    514          
    515            if (! entropy->gather_statistics) {
   \   00000008   0050A0E3           MOV      R5,#+0
   \   0000000C   0160A0E1           MOV      R6,R1
   \   00000010   ........           BL       emit_eobrun
   \   00000014   6C0094E5           LDR      R0,[R4, #+108]
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   1D00001A           BNE      ??emit_restart_e_0
    516              flush_bits_e(entropy);
   \   00000020   0720A0E3           MOV      R2,#+7
   \   00000024   7F10A0E3           MOV      R1,#+127
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           BL       emit_bits_e
   \   00000030   0C5084E5           STR      R5,[R4, #+12]
   \   00000034   105084E5           STR      R5,[R4, #+16]
    517              emit_byte_e(entropy, 0xFF);
   \   00000038   700094E5           LDR      R0,[R4, #+112]
   \   0000003C   011080E2           ADD      R1,R0,#+1
   \   00000040   701084E5           STR      R1,[R4, #+112]
   \   00000044   FF10A0E3           MOV      R1,#+255
   \   00000048   0010C0E5           STRB     R1,[R0, #+0]
   \   0000004C   740094E5           LDR      R0,[R4, #+116]
   \   00000050   010040E2           SUB      R0,R0,#+1
   \   00000054   740084E5           STR      R0,[R4, #+116]
   \   00000058   000050E3           CMP      R0,#+0
   \   0000005C   0100001A           BNE      ??emit_restart_e_1
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   ........           BL       dump_buffer_e
    518              emit_byte_e(entropy, JPEG_RST0 + restart_num);
   \                     ??emit_restart_e_1:
   \   00000068   700094E5           LDR      R0,[R4, #+112]
   \   0000006C   011080E2           ADD      R1,R0,#+1
   \   00000070   701084E5           STR      R1,[R4, #+112]
   \   00000074   D01086E2           ADD      R1,R6,#+208
   \   00000078   0010C0E5           STRB     R1,[R0, #+0]
   \   0000007C   740094E5           LDR      R0,[R4, #+116]
   \   00000080   010040E2           SUB      R0,R0,#+1
   \   00000084   740084E5           STR      R0,[R4, #+116]
   \   00000088   000050E3           CMP      R0,#+0
   \   0000008C   0100001A           BNE      ??emit_restart_e_0
   \   00000090   0400A0E1           MOV      R0,R4
   \   00000094   ........           BL       dump_buffer_e
    519            }
    520          
    521            if (entropy->cinfo->Ss == 0) {
   \                     ??emit_restart_e_0:
   \   00000098   780094E5           LDR      R0,[R4, #+120]
   \   0000009C   640190E5           LDR      R0,[R0, #+356]
   \   000000A0   000050E3           CMP      R0,#+0
   \   000000A4   0B00001A           BNE      ??emit_restart_e_2
    522              /* Re-initialize DC predictions to 0 */
    523              for (ci = 0; ci < entropy->cinfo->comps_in_scan; ci++)
   \   000000A8   781094E5           LDR      R1,[R4, #+120]
   \   000000AC   1C1191E5           LDR      R1,[R1, #+284]
   \   000000B0   010051E3           CMP      R1,#+1
   \   000000B4   7080BDB8           POPLT    {R4-R6,PC}
   \                     ??emit_restart_e_3:
   \   000000B8   781094E5           LDR      R1,[R4, #+120]
   \   000000BC   1C1191E5           LDR      R1,[R1, #+284]
   \   000000C0   010050E1           CMP      R0,R1
   \   000000C4   7080BDA8           POPGE    {R4-R6,PC}
    524                entropy->saved.last_dc_val[ci] = 0;
   \   000000C8   001184E0           ADD      R1,R4,R0, LSL #+2
   \   000000CC   145081E5           STR      R5,[R1, #+20]
   \   000000D0   010080E2           ADD      R0,R0,#+1
   \   000000D4   F7FFFFEA           B        ??emit_restart_e_3
    525            } else {
    526              /* Re-initialize all AC-related fields to 0 */
    527              entropy->EOBRUN = 0;
   \                     ??emit_restart_e_2:
   \   000000D8   805084E5           STR      R5,[R4, #+128]
    528              entropy->BE = 0;
   \   000000DC   845084E5           STR      R5,[R4, #+132]
    529            }
    530          }
   \   000000E0   7080BDE8           POP      {R4-R6,PC}       ;; return
    531          
    532          
    533          /*
    534           * MCU encoding for DC initial scan (either spectral selection,
    535           * or first pass of successive approximation).
    536           */
    537          

   \                                 In segment CODE, align 4, keep-with-next
    538          METHODDEF(boolean)
    539          encode_mcu_DC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
    540          {
   \                     encode_mcu_DC_first:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    541            huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
    542            register int temp, temp2;
    543            register int nbits;
    544            int blkn, ci;
    545            int Al = cinfo->Al;
    546            JBLOCKROW block;
    547            jpeg_component_info * compptr;
    548            ISHIFT_TEMPS
    549          
    550            entropy->next_output_byte = cinfo->dest->next_output_byte;
   \   00000008   180094E5           LDR      R0,[R4, #+24]
   \   0000000C   945194E5           LDR      R5,[R4, #+404]
   \   00000010   000090E5           LDR      R0,[R0, #+0]
   \   00000014   707194E5           LDR      R7,[R4, #+368]
   \   00000018   700085E5           STR      R0,[R5, #+112]
    551            entropy->free_in_buffer = cinfo->dest->free_in_buffer;
   \   0000001C   180094E5           LDR      R0,[R4, #+24]
   \   00000020   0160A0E1           MOV      R6,R1
   \   00000024   040090E5           LDR      R0,[R0, #+4]
   \   00000028   740085E5           STR      R0,[R5, #+116]
    552          
    553            /* Emit restart marker if needed */
    554            if (cinfo->restart_interval)
   \   0000002C   E80094E5           LDR      R0,[R4, #+232]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0500000A           BEQ      ??encode_mcu_DC_first_0
    555              if (entropy->restarts_to_go == 0)
   \   00000038   240095E5           LDR      R0,[R5, #+36]
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   0200001A           BNE      ??encode_mcu_DC_first_0
    556                emit_restart_e(entropy, entropy->next_restart_num);
   \   00000044   281095E5           LDR      R1,[R5, #+40]
   \   00000048   0500A0E1           MOV      R0,R5
   \   0000004C   ........           BL       emit_restart_e
    557          
    558            /* Encode the MCU data blocks */
    559            for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
   \                     ??encode_mcu_DC_first_0:
   \   00000050   380194E5           LDR      R0,[R4, #+312]
   \   00000054   0080A0E3           MOV      R8,#+0
   \   00000058   010050E3           CMP      R0,#+1
   \   0000005C   280000AA           BGE      ??encode_mcu_DC_first_1
   \   00000060   2A0000EA           B        ??encode_mcu_DC_first_2
    560              block = MCU_data[blkn];
    561              ci = cinfo->MCU_membership[blkn];
   \                     ??encode_mcu_DC_first_3:
   \   00000064   080184E0           ADD      R0,R4,R8, LSL #+2
   \   00000068   3C0190E5           LDR      R0,[R0, #+316]
    562              compptr = cinfo->cur_comp_info[ci];
    563          
    564              /* Compute the DC value after the required point transform by Al.
    565               * This is simply an arithmetic right shift.
    566               */
    567              temp2 = IRIGHT_SHIFT((int) ((*block)[0]), Al);
    568          
    569              /* DC differences are figured on the point-transformed values. */
    570              temp = temp2 - entropy->saved.last_dc_val[ci];
    571              entropy->saved.last_dc_val[ci] = temp2;
    572          
    573              /* Encode the DC coefficient difference per section G.1.2.1 */
    574              temp2 = temp;
    575              if (temp < 0) {
    576                temp = -temp;		/* temp is abs value of input */
    577                /* For a negative input, want temp2 = bitwise complement of abs(input) */
    578                /* This code assumes we are on a two's complement machine */
    579                temp2--;
    580              }
    581              
    582              /* Find the number of bits needed for the magnitude of the coefficient */
    583              nbits = 0;
   \   0000006C   00B0A0E3           MOV      R11,#+0
   \   00000070   001184E0           ADD      R1,R4,R0, LSL #+2
   \   00000074   209191E5           LDR      R9,[R1, #+288]
   \   00000078   081196E7           LDR      R1,[R6, +R8, LSL #+2]
   \   0000007C   000185E0           ADD      R0,R5,R0, LSL #+2
   \   00000080   F010D1E1           LDRSH    R1,[R1, #+0]
   \   00000084   142090E5           LDR      R2,[R0, #+20]
   \   00000088   5117A0E1           ASR      R1,R1,R7
   \   0000008C   022041E0           SUB      R2,R1,R2
   \   00000090   141080E5           STR      R1,[R0, #+20]
   \   00000094   02A0B0E1           MOVS     R10,R2
   \   00000098   00206242           RSBMI    R2,R2,#+0
   \   0000009C   01A04A42           SUBMI    R10,R10,#+1
   \   000000A0   000052E3           CMP      R2,#+0
   \   000000A4   0B00000A           BEQ      ??encode_mcu_DC_first_4
    584              while (temp) {
    585                nbits++;
   \                     ??encode_mcu_DC_first_5:
   \   000000A8   01B08BE2           ADD      R11,R11,#+1
    586                temp >>= 1;
   \   000000AC   C220B0E1           ASRS     R2,R2,#+1
    587              }
   \   000000B0   FCFFFF1A           BNE      ??encode_mcu_DC_first_5
    588              /* Check for out-of-range coefficient values.
    589               * Since we're encoding a difference, the range limit is twice as much.
    590               */
    591              if (nbits > MAX_COEF_BITS+1)
   \   000000B4   0C005BE3           CMP      R11,#+12
   \   000000B8   060000BA           BLT      ??encode_mcu_DC_first_4
    592                ERREXIT(cinfo, JERR_BAD_DCT_COEF);
   \   000000BC   000094E5           LDR      R0,[R4, #+0]
   \   000000C0   0610A0E3           MOV      R1,#+6
   \   000000C4   141080E5           STR      R1,[R0, #+20]
   \   000000C8   001094E5           LDR      R1,[R4, #+0]
   \   000000CC   0400A0E1           MOV      R0,R4
   \   000000D0   001091E5           LDR      R1,[R1, #+0]
   \   000000D4   31FF2FE1           BLX      R1
    593              
    594              /* Count/emit the Huffman-coded symbol for the number of bits */
    595              emit_symbol(entropy, compptr->dc_tbl_no, nbits);
   \                     ??encode_mcu_DC_first_4:
   \   000000D8   141099E5           LDR      R1,[R9, #+20]
   \   000000DC   0B20A0E1           MOV      R2,R11
   \   000000E0   0500A0E1           MOV      R0,R5
   \   000000E4   ........           BL       emit_symbol
    596              
    597              /* Emit that number of bits of the value, if positive, */
    598              /* or the complement of its magnitude, if negative. */
    599              if (nbits)			/* emit_bits rejects calls with size 0 */
   \   000000E8   00005BE3           CMP      R11,#+0
   \   000000EC   0300000A           BEQ      ??encode_mcu_DC_first_6
    600                emit_bits_e(entropy, (unsigned int) temp2, nbits);
   \   000000F0   0B20A0E1           MOV      R2,R11
   \   000000F4   0A10A0E1           MOV      R1,R10
   \   000000F8   0500A0E1           MOV      R0,R5
   \   000000FC   ........           BL       emit_bits_e
    601            }
   \                     ??encode_mcu_DC_first_6:
   \   00000100   018088E2           ADD      R8,R8,#+1
   \                     ??encode_mcu_DC_first_1:
   \   00000104   380194E5           LDR      R0,[R4, #+312]
   \   00000108   000058E1           CMP      R8,R0
   \   0000010C   D4FFFFBA           BLT      ??encode_mcu_DC_first_3
    602          
    603            cinfo->dest->next_output_byte = entropy->next_output_byte;
   \                     ??encode_mcu_DC_first_2:
   \   00000110   180094E5           LDR      R0,[R4, #+24]
   \   00000114   701095E5           LDR      R1,[R5, #+112]
   \   00000118   001080E5           STR      R1,[R0, #+0]
    604            cinfo->dest->free_in_buffer = entropy->free_in_buffer;
   \   0000011C   180094E5           LDR      R0,[R4, #+24]
   \   00000120   741095E5           LDR      R1,[R5, #+116]
   \   00000124   041080E5           STR      R1,[R0, #+4]
    605          
    606            /* Update restart-interval state too */
    607            if (cinfo->restart_interval) {
   \   00000128   E80094E5           LDR      R0,[R4, #+232]
   \   0000012C   000050E3           CMP      R0,#+0
   \   00000130   0C00000A           BEQ      ??encode_mcu_DC_first_7
    608              if (entropy->restarts_to_go == 0) {
   \   00000134   240095E5           LDR      R0,[R5, #+36]
   \   00000138   000050E3           CMP      R0,#+0
   \   0000013C   0600001A           BNE      ??encode_mcu_DC_first_8
    609                entropy->restarts_to_go = cinfo->restart_interval;
   \   00000140   E80094E5           LDR      R0,[R4, #+232]
   \   00000144   240085E5           STR      R0,[R5, #+36]
    610                entropy->next_restart_num++;
   \   00000148   280095E5           LDR      R0,[R5, #+40]
   \   0000014C   010080E2           ADD      R0,R0,#+1
   \   00000150   280085E5           STR      R0,[R5, #+40]
    611                entropy->next_restart_num &= 7;
   \   00000154   070000E2           AND      R0,R0,#0x7
   \   00000158   280085E5           STR      R0,[R5, #+40]
    612              }
    613              entropy->restarts_to_go--;
   \                     ??encode_mcu_DC_first_8:
   \   0000015C   240095E5           LDR      R0,[R5, #+36]
   \   00000160   010040E2           SUB      R0,R0,#+1
   \   00000164   240085E5           STR      R0,[R5, #+36]
    614            }
    615          
    616            return TRUE;
   \                     ??encode_mcu_DC_first_7:
   \   00000168   0100A0E3           MOV      R0,#+1
   \   0000016C   F08FBDE8           POP      {R4-R11,PC}      ;; return
    617          }
    618          
    619          
    620          /*
    621           * MCU encoding for AC initial scan (either spectral selection,
    622           * or first pass of successive approximation).
    623           */
    624          

   \                                 In segment CODE, align 4, keep-with-next
    625          METHODDEF(boolean)
    626          encode_mcu_AC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
    627          {
   \                     encode_mcu_AC_first:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
   \   00000008   0040A0E1           MOV      R4,R0
    628            huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
   \   0000000C   945194E5           LDR      R5,[R4, #+404]
   \   00000010   0170A0E1           MOV      R7,R1
    629            register int temp, temp2;
    630            register int nbits;
    631            register int r, k;
    632            int Se = cinfo->Se;
   \   00000014   681194E5           LDR      R1,[R4, #+360]
   \   00000018   00108DE5           STR      R1,[SP, #+0]
    633            int Al = cinfo->Al;
    634            JBLOCKROW block;
    635          
    636            entropy->next_output_byte = cinfo->dest->next_output_byte;
   \   0000001C   180094E5           LDR      R0,[R4, #+24]
   \   00000020   706194E5           LDR      R6,[R4, #+368]
   \   00000024   000090E5           LDR      R0,[R0, #+0]
   \   00000028   700085E5           STR      R0,[R5, #+112]
    637            entropy->free_in_buffer = cinfo->dest->free_in_buffer;
   \   0000002C   180094E5           LDR      R0,[R4, #+24]
   \   00000030   040090E5           LDR      R0,[R0, #+4]
   \   00000034   740085E5           STR      R0,[R5, #+116]
    638          
    639            /* Emit restart marker if needed */
    640            if (cinfo->restart_interval)
   \   00000038   E80094E5           LDR      R0,[R4, #+232]
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   0500000A           BEQ      ??encode_mcu_AC_first_0
    641              if (entropy->restarts_to_go == 0)
   \   00000044   240095E5           LDR      R0,[R5, #+36]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0200001A           BNE      ??encode_mcu_AC_first_0
    642                emit_restart_e(entropy, entropy->next_restart_num);
   \   00000050   281095E5           LDR      R1,[R5, #+40]
   \   00000054   0500A0E1           MOV      R0,R5
   \   00000058   ........           BL       emit_restart_e
    643          
    644            /* Encode the MCU data block */
    645            block = MCU_data[0];
   \                     ??encode_mcu_AC_first_0:
   \   0000005C   001097E5           LDR      R1,[R7, #+0]
    646          
    647            /* Encode the AC coefficients per section G.1.2.2, fig. G.3 */
    648            
    649            r = 0;			/* r = run length of zeros */
   \   00000060   0070A0E3           MOV      R7,#+0
   \   00000064   04108DE5           STR      R1,[SP, #+4]
    650             
    651            for (k = cinfo->Ss; k <= Se; k++) {
   \   00000068   648194E5           LDR      R8,[R4, #+356]
   \   0000006C   00009DE5           LDR      R0,[SP, #+0]
   \   00000070   080050E1           CMP      R0,R8
   \   00000074   440000BA           BLT      ??encode_mcu_AC_first_1
    652              if ((temp = (*block)[jpeg_natural_order[k]]) == 0) {
   \                     ??encode_mcu_AC_first_2:
   \   00000078   ........           LDR      R0,??DataTable4  ;; jpeg_natural_order
   \   0000007C   04109DE5           LDR      R1,[SP, #+4]
   \   00000080   080190E7           LDR      R0,[R0, +R8, LSL #+2]
   \   00000084   800081E0           ADD      R0,R1,R0, LSL #+1
   \   00000088   F090D0E1           LDRSH    R9,[R0, #+0]
   \   0000008C   000059E3           CMP      R9,#+0
   \   00000090   0100001A           BNE      ??encode_mcu_AC_first_3
    653                r++;
   \                     ??encode_mcu_AC_first_4:
   \   00000094   017087E2           ADD      R7,R7,#+1
    654                continue;
   \   00000098   2C0000EA           B        ??encode_mcu_AC_first_5
    655              }
    656              /* We must apply the point transform by Al.  For AC coefficients this
    657               * is an integer division with rounding towards 0.  To do this portably
    658               * in C, we shift after obtaining the absolute value; so the code is
    659               * interwoven with finding the abs value (temp) and output bits (temp2).
    660               */
    661              if (temp < 0) {
   \                     ??encode_mcu_AC_first_3:
   \   0000009C   0300005A           BPL      ??encode_mcu_AC_first_6
    662                temp = -temp;		/* temp is abs value of input */
    663                temp >>= Al;		/* apply the point transform */
   \   000000A0   000069E2           RSB      R0,R9,#+0
   \   000000A4   5096A0E1           ASR      R9,R0,R6
    664                /* For a negative coef, want temp2 = bitwise complement of abs(coef) */
    665                temp2 = ~temp;
   \   000000A8   09A0E0E1           MVN      R10,R9
   \   000000AC   010000EA           B        ??encode_mcu_AC_first_7
    666              } else {
    667                temp >>= Al;		/* apply the point transform */
   \                     ??encode_mcu_AC_first_6:
   \   000000B0   5996A0E1           ASR      R9,R9,R6
    668                temp2 = temp;
   \   000000B4   09A0A0E1           MOV      R10,R9
    669              }
    670              /* Watch out for case that nonzero coef is zero after point transform */
    671              if (temp == 0) {
   \                     ??encode_mcu_AC_first_7:
   \   000000B8   000059E3           CMP      R9,#+0
   \   000000BC   F4FFFF0A           BEQ      ??encode_mcu_AC_first_4
    672                r++;
    673                continue;
    674              }
    675          
    676              /* Emit any pending EOBRUN */
    677              if (entropy->EOBRUN > 0)
   \   000000C0   800095E5           LDR      R0,[R5, #+128]
   \   000000C4   000050E3           CMP      R0,#+0
   \   000000C8   0700000A           BEQ      ??encode_mcu_AC_first_8
    678                emit_eobrun(entropy);
   \   000000CC   0500A0E1           MOV      R0,R5
   \   000000D0   ........           BL       emit_eobrun
   \   000000D4   040000EA           B        ??encode_mcu_AC_first_8
    679              /* if run length > 15, must emit special run-length-16 codes (0xF0) */
    680              while (r > 15) {
    681                emit_symbol(entropy, entropy->ac_tbl_no, 0xF0);
   \                     ??encode_mcu_AC_first_9:
   \   000000D8   7C1095E5           LDR      R1,[R5, #+124]
   \   000000DC   F020A0E3           MOV      R2,#+240
   \   000000E0   0500A0E1           MOV      R0,R5
   \   000000E4   ........           BL       emit_symbol
    682                r -= 16;
   \   000000E8   107047E2           SUB      R7,R7,#+16
    683              }
   \                     ??encode_mcu_AC_first_8:
   \   000000EC   100057E3           CMP      R7,#+16
   \   000000F0   F8FFFFAA           BGE      ??encode_mcu_AC_first_9
    684          
    685              /* Find the number of bits needed for the magnitude of the coefficient */
    686              nbits = 1;			/* there must be at least one 1 bit */
   \   000000F4   01B0A0E3           MOV      R11,#+1
   \   000000F8   000000EA           B        ??encode_mcu_AC_first_10
    687              while ((temp >>= 1))
    688                nbits++;
   \                     ??encode_mcu_AC_first_11:
   \   000000FC   01B08BE2           ADD      R11,R11,#+1
   \                     ??encode_mcu_AC_first_10:
   \   00000100   C990B0E1           ASRS     R9,R9,#+1
   \   00000104   FCFFFF1A           BNE      ??encode_mcu_AC_first_11
    689              /* Check for out-of-range coefficient values */
    690              if (nbits > MAX_COEF_BITS)
   \   00000108   0B005BE3           CMP      R11,#+11
   \   0000010C   060000BA           BLT      ??encode_mcu_AC_first_12
    691                ERREXIT(cinfo, JERR_BAD_DCT_COEF);
   \   00000110   000094E5           LDR      R0,[R4, #+0]
   \   00000114   0610A0E3           MOV      R1,#+6
   \   00000118   141080E5           STR      R1,[R0, #+20]
   \   0000011C   001094E5           LDR      R1,[R4, #+0]
   \   00000120   0400A0E1           MOV      R0,R4
   \   00000124   001091E5           LDR      R1,[R1, #+0]
   \   00000128   31FF2FE1           BLX      R1
    692          
    693              /* Count/emit Huffman symbol for run length / number of bits */
    694              emit_symbol(entropy, entropy->ac_tbl_no, (r << 4) + nbits);
   \                     ??encode_mcu_AC_first_12:
   \   0000012C   7C1095E5           LDR      R1,[R5, #+124]
   \   00000130   07228BE0           ADD      R2,R11,R7, LSL #+4
   \   00000134   0500A0E1           MOV      R0,R5
   \   00000138   ........           BL       emit_symbol
    695          
    696              /* Emit that number of bits of the value, if positive, */
    697              /* or the complement of its magnitude, if negative. */
    698              emit_bits_e(entropy, (unsigned int) temp2, nbits);
   \   0000013C   0B20A0E1           MOV      R2,R11
   \   00000140   0A10A0E1           MOV      R1,R10
   \   00000144   0500A0E1           MOV      R0,R5
   \   00000148   ........           BL       emit_bits_e
    699          
    700              r = 0;			/* reset zero run length */
   \   0000014C   0070A0E3           MOV      R7,#+0
    701            }
   \                     ??encode_mcu_AC_first_5:
   \   00000150   00009DE5           LDR      R0,[SP, #+0]
   \   00000154   018088E2           ADD      R8,R8,#+1
   \   00000158   080050E1           CMP      R0,R8
   \   0000015C   C5FFFFAA           BGE      ??encode_mcu_AC_first_2
    702          
    703            if (r > 0) {			/* If there are trailing zeroes, */
   \   00000160   010057E3           CMP      R7,#+1
   \   00000164   080000BA           BLT      ??encode_mcu_AC_first_1
    704              entropy->EOBRUN++;		/* count an EOB */
   \   00000168   800095E5           LDR      R0,[R5, #+128]
    705              if (entropy->EOBRUN == 0x7FFF)
   \   0000016C   FF10A0E3           MOV      R1,#+255
   \   00000170   010080E2           ADD      R0,R0,#+1
   \   00000174   800085E5           STR      R0,[R5, #+128]
   \   00000178   7F1C81E3           ORR      R1,R1,#0x7F00
   \   0000017C   010050E1           CMP      R0,R1
   \   00000180   0100001A           BNE      ??encode_mcu_AC_first_1
    706                emit_eobrun(entropy);	/* force it out to avoid overflow */
   \   00000184   0500A0E1           MOV      R0,R5
   \   00000188   ........           BL       emit_eobrun
    707            }
    708          
    709            cinfo->dest->next_output_byte = entropy->next_output_byte;
   \                     ??encode_mcu_AC_first_1:
   \   0000018C   180094E5           LDR      R0,[R4, #+24]
   \   00000190   701095E5           LDR      R1,[R5, #+112]
   \   00000194   001080E5           STR      R1,[R0, #+0]
    710            cinfo->dest->free_in_buffer = entropy->free_in_buffer;
   \   00000198   180094E5           LDR      R0,[R4, #+24]
   \   0000019C   741095E5           LDR      R1,[R5, #+116]
   \   000001A0   041080E5           STR      R1,[R0, #+4]
    711          
    712            /* Update restart-interval state too */
    713            if (cinfo->restart_interval) {
   \   000001A4   E80094E5           LDR      R0,[R4, #+232]
   \   000001A8   000050E3           CMP      R0,#+0
   \   000001AC   0A00000A           BEQ      ??encode_mcu_AC_first_13
    714              if (entropy->restarts_to_go == 0) {
   \   000001B0   241095E5           LDR      R1,[R5, #+36]
   \   000001B4   000051E3           CMP      R1,#+0
   \   000001B8   0400001A           BNE      ??encode_mcu_AC_first_14
    715                entropy->restarts_to_go = cinfo->restart_interval;
   \   000001BC   240085E5           STR      R0,[R5, #+36]
    716                entropy->next_restart_num++;
    717                entropy->next_restart_num &= 7;
   \   000001C0   280095E5           LDR      R0,[R5, #+40]
   \   000001C4   010080E2           ADD      R0,R0,#+1
   \   000001C8   070000E2           AND      R0,R0,#0x7
   \   000001CC   280085E5           STR      R0,[R5, #+40]
    718              }
    719              entropy->restarts_to_go--;
   \                     ??encode_mcu_AC_first_14:
   \   000001D0   240095E5           LDR      R0,[R5, #+36]
   \   000001D4   010040E2           SUB      R0,R0,#+1
   \   000001D8   240085E5           STR      R0,[R5, #+36]
    720            }
    721          
    722            return TRUE;
   \                     ??encode_mcu_AC_first_13:
   \   000001DC   0100A0E3           MOV      R0,#+1
   \   000001E0   F68FBDE8           POP      {R1,R2,R4-R11,PC}  ;; return
    723          }
    724          
    725          
    726          /*
    727           * MCU encoding for DC successive approximation refinement scan.
    728           * Note: we assume such scans can be multi-component, although the spec
    729           * is not very clear on the point.
    730           */
    731          

   \                                 In segment CODE, align 4, keep-with-next
    732          METHODDEF(boolean)
    733          encode_mcu_DC_refine (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
    734          {
   \                     encode_mcu_DC_refine:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0050A0E1           MOV      R5,R0
    735            huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
    736            register int temp;
    737            int blkn;
    738            int Al = cinfo->Al;
    739            JBLOCKROW block;
    740          
    741            entropy->next_output_byte = cinfo->dest->next_output_byte;
   \   00000008   180095E5           LDR      R0,[R5, #+24]
   \   0000000C   944195E5           LDR      R4,[R5, #+404]
   \   00000010   000090E5           LDR      R0,[R0, #+0]
   \   00000014   707195E5           LDR      R7,[R5, #+368]
   \   00000018   700084E5           STR      R0,[R4, #+112]
    742            entropy->free_in_buffer = cinfo->dest->free_in_buffer;
   \   0000001C   180095E5           LDR      R0,[R5, #+24]
   \   00000020   0160A0E1           MOV      R6,R1
   \   00000024   040090E5           LDR      R0,[R0, #+4]
   \   00000028   740084E5           STR      R0,[R4, #+116]
    743          
    744            /* Emit restart marker if needed */
    745            if (cinfo->restart_interval)
   \   0000002C   E80095E5           LDR      R0,[R5, #+232]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0500000A           BEQ      ??encode_mcu_DC_refine_0
    746              if (entropy->restarts_to_go == 0)
   \   00000038   240094E5           LDR      R0,[R4, #+36]
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   0200001A           BNE      ??encode_mcu_DC_refine_0
    747                emit_restart_e(entropy, entropy->next_restart_num);
   \   00000044   281094E5           LDR      R1,[R4, #+40]
   \   00000048   0400A0E1           MOV      R0,R4
   \   0000004C   ........           BL       emit_restart_e
    748          
    749            /* Encode the MCU data blocks */
    750            for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
   \                     ??encode_mcu_DC_refine_0:
   \   00000050   380195E5           LDR      R0,[R5, #+312]
   \   00000054   0080A0E3           MOV      R8,#+0
   \   00000058   010050E3           CMP      R0,#+1
   \   0000005C   070000AA           BGE      ??encode_mcu_DC_refine_1
   \   00000060   090000EA           B        ??encode_mcu_DC_refine_2
    751              block = MCU_data[blkn];
    752          
    753              /* We simply emit the Al'th bit of the DC coefficient value. */
    754              temp = (*block)[0];
    755              emit_bits_e(entropy, (unsigned int) (temp >> Al), 1);
   \                     ??encode_mcu_DC_refine_3:
   \   00000064   080196E7           LDR      R0,[R6, +R8, LSL #+2]
   \   00000068   0120A0E3           MOV      R2,#+1
   \   0000006C   F000D0E1           LDRSH    R0,[R0, #+0]
    756            }
   \   00000070   018088E2           ADD      R8,R8,#+1
   \   00000074   5017A0E1           ASR      R1,R0,R7
   \   00000078   0400A0E1           MOV      R0,R4
   \   0000007C   ........           BL       emit_bits_e
   \                     ??encode_mcu_DC_refine_1:
   \   00000080   380195E5           LDR      R0,[R5, #+312]
   \   00000084   000058E1           CMP      R8,R0
   \   00000088   F5FFFFBA           BLT      ??encode_mcu_DC_refine_3
    757          
    758            cinfo->dest->next_output_byte = entropy->next_output_byte;
   \                     ??encode_mcu_DC_refine_2:
   \   0000008C   180095E5           LDR      R0,[R5, #+24]
   \   00000090   701094E5           LDR      R1,[R4, #+112]
   \   00000094   001080E5           STR      R1,[R0, #+0]
    759            cinfo->dest->free_in_buffer = entropy->free_in_buffer;
   \   00000098   180095E5           LDR      R0,[R5, #+24]
   \   0000009C   741094E5           LDR      R1,[R4, #+116]
   \   000000A0   041080E5           STR      R1,[R0, #+4]
    760          
    761            /* Update restart-interval state too */
    762            if (cinfo->restart_interval) {
   \   000000A4   E80095E5           LDR      R0,[R5, #+232]
   \   000000A8   000050E3           CMP      R0,#+0
   \   000000AC   0A00000A           BEQ      ??encode_mcu_DC_refine_4
    763              if (entropy->restarts_to_go == 0) {
   \   000000B0   241094E5           LDR      R1,[R4, #+36]
   \   000000B4   000051E3           CMP      R1,#+0
   \   000000B8   0400001A           BNE      ??encode_mcu_DC_refine_5
    764                entropy->restarts_to_go = cinfo->restart_interval;
   \   000000BC   240084E5           STR      R0,[R4, #+36]
    765                entropy->next_restart_num++;
    766                entropy->next_restart_num &= 7;
   \   000000C0   280094E5           LDR      R0,[R4, #+40]
   \   000000C4   010080E2           ADD      R0,R0,#+1
   \   000000C8   070000E2           AND      R0,R0,#0x7
   \   000000CC   280084E5           STR      R0,[R4, #+40]
    767              }
    768              entropy->restarts_to_go--;
   \                     ??encode_mcu_DC_refine_5:
   \   000000D0   240094E5           LDR      R0,[R4, #+36]
   \   000000D4   010040E2           SUB      R0,R0,#+1
   \   000000D8   240084E5           STR      R0,[R4, #+36]
    769            }
    770          
    771            return TRUE;
   \                     ??encode_mcu_DC_refine_4:
   \   000000DC   0100A0E3           MOV      R0,#+1
   \   000000E0   F081BDE8           POP      {R4-R8,PC}       ;; return
    772          }
    773          
    774          
    775          /*
    776           * MCU encoding for AC successive approximation refinement scan.
    777           */
    778          

   \                                 In segment CODE, align 4, keep-with-next
    779          METHODDEF(boolean)
    780          encode_mcu_AC_refine (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
    781          {
   \                     encode_mcu_AC_refine:
   \   00000000   F04D2DE9           PUSH     {R4-R8,R10,R11,LR}
   \   00000004   43DF4DE2           SUB      SP,SP,#+268
   \   00000008   0040A0E1           MOV      R4,R0
    782            huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
   \   0000000C   945194E5           LDR      R5,[R4, #+404]
   \   00000010   0170A0E1           MOV      R7,R1
    783            register int temp;
    784            register int r, k;
    785            int EOB;
    786            char *BR_buffer;
    787            unsigned int BR;
    788            int Se = cinfo->Se;
   \   00000014   681194E5           LDR      R1,[R4, #+360]
   \   00000018   00108DE5           STR      R1,[SP, #+0]
    789            int Al = cinfo->Al;
    790            JBLOCKROW block;
    791            int absvalues[DCTSIZE2];
    792          
    793            entropy->next_output_byte = cinfo->dest->next_output_byte;
   \   0000001C   180094E5           LDR      R0,[R4, #+24]
   \   00000020   706194E5           LDR      R6,[R4, #+368]
   \   00000024   000090E5           LDR      R0,[R0, #+0]
   \   00000028   700085E5           STR      R0,[R5, #+112]
    794            entropy->free_in_buffer = cinfo->dest->free_in_buffer;
   \   0000002C   180094E5           LDR      R0,[R4, #+24]
   \   00000030   040090E5           LDR      R0,[R0, #+4]
   \   00000034   740085E5           STR      R0,[R5, #+116]
    795          
    796            /* Emit restart marker if needed */
    797            if (cinfo->restart_interval)
   \   00000038   E80094E5           LDR      R0,[R4, #+232]
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   0500000A           BEQ      ??encode_mcu_AC_refine_0
    798              if (entropy->restarts_to_go == 0)
   \   00000044   240095E5           LDR      R0,[R5, #+36]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0200001A           BNE      ??encode_mcu_AC_refine_0
    799                emit_restart_e(entropy, entropy->next_restart_num);
   \   00000050   281095E5           LDR      R1,[R5, #+40]
   \   00000054   0500A0E1           MOV      R0,R5
   \   00000058   ........           BL       emit_restart_e
    800          
    801            /* Encode the MCU data block */
    802            block = MCU_data[0];
   \                     ??encode_mcu_AC_refine_0:
   \   0000005C   001097E5           LDR      R1,[R7, #+0]
   \   00000060   04108DE5           STR      R1,[SP, #+4]
    803          
    804            /* It is convenient to make a pre-pass to determine the transformed
    805             * coefficients' absolute values and the EOB position.
    806             */
    807            EOB = 0;
   \   00000064   0010A0E3           MOV      R1,#+0
   \   00000068   08108DE5           STR      R1,[SP, #+8]
    808            for (k = cinfo->Ss; k <= Se; k++) {
   \   0000006C   648194E5           LDR      R8,[R4, #+356]
   \   00000070   00109DE5           LDR      R1,[SP, #+0]
   \   00000074   0800A0E1           MOV      R0,R8
   \   00000078   000051E1           CMP      R1,R0
   \   0000007C   0F0000BA           BLT      ??encode_mcu_AC_refine_1
    809              temp = (*block)[jpeg_natural_order[k]];
   \                     ??encode_mcu_AC_refine_2:
   \   00000080   ........           LDR      R1,??DataTable4  ;; jpeg_natural_order
   \   00000084   04209DE5           LDR      R2,[SP, #+4]
   \   00000088   001191E7           LDR      R1,[R1, +R0, LSL #+2]
   \   0000008C   811082E0           ADD      R1,R2,R1, LSL #+1
   \   00000090   F010D1E1           LDRSH    R1,[R1, #+0]
    810              /* We must apply the point transform by Al.  For AC coefficients this
    811               * is an integer division with rounding towards 0.  To do this portably
    812               * in C, we shift after obtaining the absolute value.
    813               */
    814              if (temp < 0)
   \   00000094   000051E3           CMP      R1,#+0
    815                temp = -temp;		/* temp is abs value of input */
   \   00000098   00106142           RSBMI    R1,R1,#+0
    816              temp >>= Al;		/* apply the point transform */
   \   0000009C   51A6A0E1           ASR      R10,R1,R6
    817              absvalues[k] = temp;	/* save abs value for main pass */
   \   000000A0   0C108DE2           ADD      R1,SP,#+12
   \   000000A4   00A181E7           STR      R10,[R1, +R0, LSL #+2]
    818              if (temp == 1)
   \   000000A8   01005AE3           CMP      R10,#+1
    819                EOB = k;			/* EOB = index of last newly-nonzero coef */
   \   000000AC   08008D05           STREQ    R0,[SP, #+8]
    820            }
   \   000000B0   00109DE5           LDR      R1,[SP, #+0]
   \   000000B4   010080E2           ADD      R0,R0,#+1
   \   000000B8   000051E1           CMP      R1,R0
   \   000000BC   EFFFFFAA           BGE      ??encode_mcu_AC_refine_2
    821          
    822            /* Encode the AC coefficients per section G.1.2.3, fig. G.7 */
    823            
    824            r = 0;			/* r = run length of zeros */
    825            BR = 0;			/* BR = count of buffered bits added now */
    826            BR_buffer = entropy->bit_buffer + entropy->BE; /* Append bits to buffer */
   \                     ??encode_mcu_AC_refine_1:
   \   000000C0   840095E5           LDR      R0,[R5, #+132]
   \   000000C4   881095E5           LDR      R1,[R5, #+136]
   \   000000C8   0060A0E3           MOV      R6,#+0
   \   000000CC   017080E0           ADD      R7,R0,R1
    827          
    828            for (k = cinfo->Ss; k <= Se; k++) {
   \   000000D0   00009DE5           LDR      R0,[SP, #+0]
   \   000000D4   00B0A0E3           MOV      R11,#+0
   \   000000D8   080050E1           CMP      R0,R8
   \   000000DC   5C0000BA           BLT      ??encode_mcu_AC_refine_3
    829              if ((temp = absvalues[k]) == 0) {
   \                     ??encode_mcu_AC_refine_4:
   \   000000E0   0C008DE2           ADD      R0,SP,#+12
   \   000000E4   08A190E7           LDR      R10,[R0, +R8, LSL #+2]
   \   000000E8   00005AE3           CMP      R10,#+0
   \   000000EC   0900001A           BNE      ??encode_mcu_AC_refine_5
    830                r++;
   \   000000F0   016086E2           ADD      R6,R6,#+1
    831                continue;
   \   000000F4   3E0000EA           B        ??encode_mcu_AC_refine_6
    832              }
    833          
    834              /* Emit any required ZRLs, but not if they can be folded into EOB */
    835              while (r > 15 && k <= EOB) {
   \                     ??encode_mcu_AC_refine_7:
   \   000000F8   ........           LDRB     R1,[R7], #+1
   \   000000FC   0120A0E3           MOV      R2,#+1
   \   00000100   0500A0E1           MOV      R0,R5
   \   00000104   ........           BL       emit_bits_e
   \   00000108   01B05BE2           SUBS     R11,R11,#+1
   \                     ??encode_mcu_AC_refine_8:
   \   0000010C   F9FFFF1A           BNE      ??encode_mcu_AC_refine_7
    836                /* emit any pending EOBRUN and the BE correction bits */
    837                emit_eobrun(entropy);
    838                /* Emit ZRL */
    839                emit_symbol(entropy, entropy->ac_tbl_no, 0xF0);
    840                r -= 16;
    841                /* Emit buffered correction bits that must be associated with ZRL */
    842                emit_buffered_bits(entropy, BR_buffer, BR);
    843                BR_buffer = entropy->bit_buffer; /* BE bits are gone now */
   \                     ??encode_mcu_AC_refine_9:
   \   00000110   887095E5           LDR      R7,[R5, #+136]
    844                BR = 0;
   \   00000114   00B0A0E3           MOV      R11,#+0
   \                     ??encode_mcu_AC_refine_5:
   \   00000118   100056E3           CMP      R6,#+16
   \   0000011C   08009DA5           LDRGE    R0,[SP, #+8]
   \   00000120   080050A1           CMPGE    R0,R8
   \   00000124   0B0000BA           BLT      ??encode_mcu_AC_refine_10
   \   00000128   0500A0E1           MOV      R0,R5
   \   0000012C   ........           BL       emit_eobrun
   \   00000130   7C1095E5           LDR      R1,[R5, #+124]
   \   00000134   F020A0E3           MOV      R2,#+240
   \   00000138   0500A0E1           MOV      R0,R5
   \   0000013C   ........           BL       emit_symbol
   \   00000140   6C0095E5           LDR      R0,[R5, #+108]
   \   00000144   106046E2           SUB      R6,R6,#+16
   \   00000148   000050E3           CMP      R0,#+0
   \   0000014C   EFFFFF1A           BNE      ??encode_mcu_AC_refine_9
   \   00000150   00005BE3           CMP      R11,#+0
   \   00000154   ECFFFFEA           B        ??encode_mcu_AC_refine_8
    845              }
    846          
    847              /* If the coef was previously nonzero, it only needs a correction bit.
    848               * NOTE: a straight translation of the spec's figure G.7 would suggest
    849               * that we also need to test r > 15.  But if r > 15, we can only get here
    850               * if k > EOB, which implies that this coefficient is not 1.
    851               */
    852              if (temp > 1) {
   \                     ??encode_mcu_AC_refine_10:
   \   00000158   02005AE3           CMP      R10,#+2
   \   0000015C   030000BA           BLT      ??encode_mcu_AC_refine_11
    853                /* The correction bit is the next bit of the absolute value. */
    854                BR_buffer[BR++] = (char) (temp & 1);
   \   00000160   01000AE2           AND      R0,R10,#0x1
   \   00000164   0700CBE7           STRB     R0,[R11, +R7]
   \   00000168   01B08BE2           ADD      R11,R11,#+1
    855                continue;
   \   0000016C   200000EA           B        ??encode_mcu_AC_refine_6
    856              }
    857          
    858              /* Emit any pending EOBRUN and the BE correction bits */
    859              emit_eobrun(entropy);
   \                     ??encode_mcu_AC_refine_11:
   \   00000170   0500A0E1           MOV      R0,R5
   \   00000174   ........           BL       emit_eobrun
    860          
    861              /* Count/emit Huffman symbol for run length / number of bits */
    862              emit_symbol(entropy, entropy->ac_tbl_no, (r << 4) + 1);
   \   00000178   7C1095E5           LDR      R1,[R5, #+124]
   \   0000017C   0100A0E3           MOV      R0,#+1
   \   00000180   062280E0           ADD      R2,R0,R6, LSL #+4
   \   00000184   0500A0E1           MOV      R0,R5
   \   00000188   ........           BL       emit_symbol
    863          
    864              /* Emit output bit for newly-nonzero coef */
    865              temp = ((*block)[jpeg_natural_order[k]] < 0) ? 0 : 1;
   \   0000018C   ........           LDR      R0,??DataTable4  ;; jpeg_natural_order
   \   00000190   04109DE5           LDR      R1,[SP, #+4]
   \   00000194   080190E7           LDR      R0,[R0, +R8, LSL #+2]
    866              emit_bits_e(entropy, (unsigned int) temp, 1);
   \   00000198   0120A0E3           MOV      R2,#+1
   \   0000019C   800081E0           ADD      R0,R1,R0, LSL #+1
   \   000001A0   F000D0E1           LDRSH    R0,[R0, #+0]
   \   000001A4   000050E3           CMP      R0,#+0
   \   000001A8   00A0A043           MOVMI    R10,#+0
   \   000001AC   01A0A053           MOVPL    R10,#+1
   \   000001B0   0A10A0E1           MOV      R1,R10
   \   000001B4   0500A0E1           MOV      R0,R5
   \   000001B8   ........           BL       emit_bits_e
    867          
    868              /* Emit buffered correction bits that must be associated with this code */
    869              emit_buffered_bits(entropy, BR_buffer, BR);
   \   000001BC   6C0095E5           LDR      R0,[R5, #+108]
   \   000001C0   000050E3           CMP      R0,#+0
   \   000001C4   0700001A           BNE      ??encode_mcu_AC_refine_12
   \   000001C8   00005BE3           CMP      R11,#+0
   \   000001CC   040000EA           B        ??encode_mcu_AC_refine_13
   \                     ??encode_mcu_AC_refine_14:
   \   000001D0   ........           LDRB     R1,[R7], #+1
   \   000001D4   0120A0E3           MOV      R2,#+1
   \   000001D8   0500A0E1           MOV      R0,R5
   \   000001DC   ........           BL       emit_bits_e
   \   000001E0   01B05BE2           SUBS     R11,R11,#+1
   \                     ??encode_mcu_AC_refine_13:
   \   000001E4   F9FFFF1A           BNE      ??encode_mcu_AC_refine_14
    870              BR_buffer = entropy->bit_buffer; /* BE bits are gone now */
   \                     ??encode_mcu_AC_refine_12:
   \   000001E8   887095E5           LDR      R7,[R5, #+136]
    871              BR = 0;
   \   000001EC   00B0A0E3           MOV      R11,#+0
    872              r = 0;			/* reset zero run length */
   \   000001F0   0060A0E3           MOV      R6,#+0
    873            }
   \                     ??encode_mcu_AC_refine_6:
   \   000001F4   00009DE5           LDR      R0,[SP, #+0]
   \   000001F8   018088E2           ADD      R8,R8,#+1
   \   000001FC   080050E1           CMP      R0,R8
   \   00000200   B6FFFFAA           BGE      ??encode_mcu_AC_refine_4
    874          
    875            if (r > 0 || BR > 0) {	/* If there are trailing zeroes, */
   \   00000204   010056E3           CMP      R6,#+1
   \   00000208   010000AA           BGE      ??encode_mcu_AC_refine_15
   \   0000020C   00005BE3           CMP      R11,#+0
   \   00000210   0F00000A           BEQ      ??encode_mcu_AC_refine_3
    876              entropy->EOBRUN++;		/* count an EOB */
   \                     ??encode_mcu_AC_refine_15:
   \   00000214   800095E5           LDR      R0,[R5, #+128]
    877              entropy->BE += BR;		/* concat my correction bits to older ones */
    878              /* We force out the EOB if we risk either:
    879               * 1. overflow of the EOB counter;
    880               * 2. overflow of the correction bit buffer during the next MCU.
    881               */
    882              if (entropy->EOBRUN == 0x7FFF || entropy->BE > (MAX_CORR_BITS-DCTSIZE2+1))
   \   00000218   FF20A0E3           MOV      R2,#+255
   \   0000021C   010080E2           ADD      R0,R0,#+1
   \   00000220   800085E5           STR      R0,[R5, #+128]
   \   00000224   841095E5           LDR      R1,[R5, #+132]
   \   00000228   7F2C82E3           ORR      R2,R2,#0x7F00
   \   0000022C   01108BE0           ADD      R1,R11,R1
   \   00000230   841085E5           STR      R1,[R5, #+132]
   \   00000234   020050E1           CMP      R0,R2
   \   00000238   0300000A           BEQ      ??encode_mcu_AC_refine_16
   \   0000023C   AA00A0E3           MOV      R0,#+170
   \   00000240   C00F80E3           ORR      R0,R0,#0x300
   \   00000244   000051E1           CMP      R1,R0
   \   00000248   0100003A           BCC      ??encode_mcu_AC_refine_3
    883                emit_eobrun(entropy);
   \                     ??encode_mcu_AC_refine_16:
   \   0000024C   0500A0E1           MOV      R0,R5
   \   00000250   ........           BL       emit_eobrun
    884            }
    885          
    886            cinfo->dest->next_output_byte = entropy->next_output_byte;
   \                     ??encode_mcu_AC_refine_3:
   \   00000254   180094E5           LDR      R0,[R4, #+24]
   \   00000258   701095E5           LDR      R1,[R5, #+112]
   \   0000025C   001080E5           STR      R1,[R0, #+0]
    887            cinfo->dest->free_in_buffer = entropy->free_in_buffer;
   \   00000260   180094E5           LDR      R0,[R4, #+24]
   \   00000264   741095E5           LDR      R1,[R5, #+116]
   \   00000268   041080E5           STR      R1,[R0, #+4]
    888          
    889            /* Update restart-interval state too */
    890            if (cinfo->restart_interval) {
   \   0000026C   E80094E5           LDR      R0,[R4, #+232]
   \   00000270   000050E3           CMP      R0,#+0
   \   00000274   0A00000A           BEQ      ??encode_mcu_AC_refine_17
    891              if (entropy->restarts_to_go == 0) {
   \   00000278   241095E5           LDR      R1,[R5, #+36]
   \   0000027C   000051E3           CMP      R1,#+0
   \   00000280   0400001A           BNE      ??encode_mcu_AC_refine_18
    892                entropy->restarts_to_go = cinfo->restart_interval;
   \   00000284   240085E5           STR      R0,[R5, #+36]
    893                entropy->next_restart_num++;
    894                entropy->next_restart_num &= 7;
   \   00000288   280095E5           LDR      R0,[R5, #+40]
   \   0000028C   010080E2           ADD      R0,R0,#+1
   \   00000290   070000E2           AND      R0,R0,#0x7
   \   00000294   280085E5           STR      R0,[R5, #+40]
    895              }
    896              entropy->restarts_to_go--;
   \                     ??encode_mcu_AC_refine_18:
   \   00000298   240095E5           LDR      R0,[R5, #+36]
   \   0000029C   010040E2           SUB      R0,R0,#+1
   \   000002A0   240085E5           STR      R0,[R5, #+36]
    897            }
    898          
    899            return TRUE;
   \                     ??encode_mcu_AC_refine_17:
   \   000002A4   0100A0E3           MOV      R0,#+1
   \   000002A8   43DF8DE2           ADD      SP,SP,#+268
   \   000002AC   F08DBDE8           POP      {R4-R8,R10,R11,PC}
    900          }
    901          
    902          
    903          /* Encode a single block's worth of coefficients */
    904          

   \                                 In segment CODE, align 4, keep-with-next
    905          LOCAL(boolean)
    906          encode_one_block (working_state * state, JCOEFPTR block, int last_dc_val,
    907          		  c_derived_tbl *dctbl, c_derived_tbl *actbl)
    908          {
   \                     encode_one_block:
   \   00000000   F24F2DE9           PUSH     {R1,R4-R11,LR}
   \   00000004   28509DE5           LDR      R5,[SP, #+40]
   \   00000008   0040A0E1           MOV      R4,R0
    909            register int temp, temp2;
    910            register int nbits;
    911            register int k, r, i;
    912          
    913            /* Encode the DC coefficient difference per section F.1.2.1 */
    914          
    915            temp = temp2 = block[0] - last_dc_val;
   \   0000000C   F000D1E1           LDRSH    R0,[R1, #+0]
   \   00000010   03A0A0E1           MOV      R10,R3
    916          
    917            if (temp < 0) {
    918              temp = -temp;		/* temp is abs value of input */
    919              /* For a negative input, want temp2 = bitwise complement of abs(input) */
    920              /* This code assumes we are on a two's complement machine */
    921              temp2--;
    922            }
    923          
    924            /* Find the number of bits needed for the magnitude of the coefficient */
    925            nbits = 0;
   \   00000014   0080A0E3           MOV      R8,#+0
   \   00000018   026040E0           SUB      R6,R0,R2
   \   0000001C   0670B0E1           MOVS     R7,R6
   \   00000020   00706742           RSBMI    R7,R7,#+0
   \   00000024   01604642           SUBMI    R6,R6,#+1
   \   00000028   0690A0E3           MOV      R9,#+6
   \   0000002C   000057E3           CMP      R7,#+0
   \   00000030   0C00000A           BEQ      ??encode_one_block_0
    926            while (temp) {
    927              nbits++;
   \                     ??encode_one_block_1:
   \   00000034   018088E2           ADD      R8,R8,#+1
    928              temp >>= 1;
   \   00000038   C770B0E1           ASRS     R7,R7,#+1
    929            }
   \   0000003C   FCFFFF1A           BNE      ??encode_one_block_1
    930            /* Check for out-of-range coefficient values.
    931             * Since we're encoding a difference, the range limit is twice as much.
    932             */
    933            if (nbits > MAX_COEF_BITS+1)
   \   00000040   0C0058E3           CMP      R8,#+12
   \   00000044   070000BA           BLT      ??encode_one_block_0
    934              ERREXIT(state->cinfo, JERR_BAD_DCT_COEF);
   \   00000048   200094E5           LDR      R0,[R4, #+32]
   \   0000004C   000090E5           LDR      R0,[R0, #+0]
   \   00000050   149080E5           STR      R9,[R0, #+20]
   \   00000054   201094E5           LDR      R1,[R4, #+32]
   \   00000058   0100A0E1           MOV      R0,R1
   \   0000005C   001091E5           LDR      R1,[R1, #+0]
   \   00000060   001091E5           LDR      R1,[R1, #+0]
   \   00000064   31FF2FE1           BLX      R1
    935          
    936            /* Emit the Huffman-coded symbol for the number of bits */
    937            if (! emit_bits_s(state, dctbl->ehufco[nbits], dctbl->ehufsi[nbits]))
   \                     ??encode_one_block_0:
   \   00000068   08119AE7           LDR      R1,[R10, +R8, LSL #+2]
   \   0000006C   0A0088E0           ADD      R0,R8,R10
   \   00000070   0024D0E5           LDRB     R2,[R0, #+1024]
   \   00000074   0400A0E1           MOV      R0,R4
   \   00000078   ........           BL       emit_bits_s
   \   0000007C   000050E3           CMP      R0,#+0
   \   00000080   F28FBD08           POPEQ    {R1,R4-R11,PC}
    938              return FALSE;
    939          
    940            /* Emit that number of bits of the value, if positive, */
    941            /* or the complement of its magnitude, if negative. */
    942            if (nbits)			/* emit_bits rejects calls with size 0 */
   \   00000084   000058E3           CMP      R8,#+0
   \   00000088   0500000A           BEQ      ??encode_one_block_2
    943              if (! emit_bits_s(state, (unsigned int) temp2, nbits))
   \   0000008C   0820A0E1           MOV      R2,R8
   \   00000090   0610A0E1           MOV      R1,R6
   \   00000094   0400A0E1           MOV      R0,R4
   \   00000098   ........           BL       emit_bits_s
   \   0000009C   000050E3           CMP      R0,#+0
   \   000000A0   F28FBD08           POPEQ    {R1,R4-R11,PC}
    944                return FALSE;
    945          
    946            /* Encode the AC coefficients per section F.1.2.2 */
    947          
    948            r = 0;			/* r = run length of zeros */
   \                     ??encode_one_block_2:
   \   000000A4   00B0A0E3           MOV      R11,#+0
    949          
    950            for (k = 1; k < DCTSIZE2; k++) {
   \   000000A8   01A0A0E3           MOV      R10,#+1
    951              if ((temp = block[jpeg_natural_order[k]]) == 0) {
   \                     ??encode_one_block_3:
   \   000000AC   ........           LDR      R0,??DataTable4  ;; jpeg_natural_order
   \   000000B0   00109DE5           LDR      R1,[SP, #+0]
   \   000000B4   0A0190E7           LDR      R0,[R0, +R10, LSL #+2]
   \   000000B8   800081E0           ADD      R0,R1,R0, LSL #+1
   \   000000BC   F070D0E1           LDRSH    R7,[R0, #+0]
   \   000000C0   000057E3           CMP      R7,#+0
   \   000000C4   0800001A           BNE      ??encode_one_block_4
    952                r++;
   \   000000C8   01B08BE2           ADD      R11,R11,#+1
   \   000000CC   290000EA           B        ??encode_one_block_5
    953              } else {
    954                /* if run length > 15, must emit special run-length-16 codes (0xF0) */
    955                while (r > 15) {
    956          	if (! emit_bits_s(state, actbl->ehufco[0xF0], actbl->ehufsi[0xF0]))
   \                     ??encode_one_block_6:
   \   000000D0   F024D5E5           LDRB     R2,[R5, #+1264]
   \   000000D4   C01395E5           LDR      R1,[R5, #+960]
   \   000000D8   0400A0E1           MOV      R0,R4
   \   000000DC   ........           BL       emit_bits_s
   \   000000E0   000050E3           CMP      R0,#+0
   \   000000E4   F28FBD08           POPEQ    {R1,R4-R11,PC}
    957          	  return FALSE;
    958          	r -= 16;
   \   000000E8   10B04BE2           SUB      R11,R11,#+16
    959                }
   \                     ??encode_one_block_4:
   \   000000EC   10005BE3           CMP      R11,#+16
   \   000000F0   F6FFFFAA           BGE      ??encode_one_block_6
    960          
    961                temp2 = temp;
   \   000000F4   0760B0E1           MOVS     R6,R7
    962                if (temp < 0) {
    963          	temp = -temp;		/* temp is abs value of input */
   \   000000F8   00706742           RSBMI    R7,R7,#+0
    964          	/* This code assumes we are on a two's complement machine */
    965          	temp2--;
   \   000000FC   01604642           SUBMI    R6,R6,#+1
    966                }
    967          
    968                /* Find the number of bits needed for the magnitude of the coefficient */
    969                nbits = 1;		/* there must be at least one 1 bit */
   \   00000100   0180A0E3           MOV      R8,#+1
   \   00000104   000000EA           B        ??encode_one_block_7
    970                while ((temp >>= 1))
    971          	nbits++;
   \                     ??encode_one_block_8:
   \   00000108   018088E2           ADD      R8,R8,#+1
   \                     ??encode_one_block_7:
   \   0000010C   C770B0E1           ASRS     R7,R7,#+1
   \   00000110   FCFFFF1A           BNE      ??encode_one_block_8
    972                /* Check for out-of-range coefficient values */
    973                if (nbits > MAX_COEF_BITS)
   \   00000114   0B0058E3           CMP      R8,#+11
   \   00000118   070000BA           BLT      ??encode_one_block_9
    974          	ERREXIT(state->cinfo, JERR_BAD_DCT_COEF);
   \   0000011C   200094E5           LDR      R0,[R4, #+32]
   \   00000120   000090E5           LDR      R0,[R0, #+0]
   \   00000124   149080E5           STR      R9,[R0, #+20]
   \   00000128   201094E5           LDR      R1,[R4, #+32]
   \   0000012C   0100A0E1           MOV      R0,R1
   \   00000130   001091E5           LDR      R1,[R1, #+0]
   \   00000134   001091E5           LDR      R1,[R1, #+0]
   \   00000138   31FF2FE1           BLX      R1
    975          
    976                /* Emit Huffman symbol for run length / number of bits */
    977                i = (r << 4) + nbits;
   \                     ??encode_one_block_9:
   \   0000013C   0B0288E0           ADD      R0,R8,R11, LSL #+4
    978                if (! emit_bits_s(state, actbl->ehufco[i], actbl->ehufsi[i]))
   \   00000140   051080E0           ADD      R1,R0,R5
   \   00000144   0024D1E5           LDRB     R2,[R1, #+1024]
   \   00000148   001195E7           LDR      R1,[R5, +R0, LSL #+2]
   \   0000014C   0400A0E1           MOV      R0,R4
   \   00000150   ........           BL       emit_bits_s
   \   00000154   000050E3           CMP      R0,#+0
   \   00000158   F28FBD08           POPEQ    {R1,R4-R11,PC}
    979          	return FALSE;
    980          
    981                /* Emit that number of bits of the value, if positive, */
    982                /* or the complement of its magnitude, if negative. */
    983                if (! emit_bits_s(state, (unsigned int) temp2, nbits))
   \   0000015C   0820A0E1           MOV      R2,R8
   \   00000160   0610A0E1           MOV      R1,R6
   \   00000164   0400A0E1           MOV      R0,R4
   \   00000168   ........           BL       emit_bits_s
   \   0000016C   000050E3           CMP      R0,#+0
   \   00000170   F28FBD08           POPEQ    {R1,R4-R11,PC}
    984          	return FALSE;
    985          
    986                r = 0;
   \   00000174   00B0A0E3           MOV      R11,#+0
    987              }
    988            }
   \                     ??encode_one_block_5:
   \   00000178   01A08AE2           ADD      R10,R10,#+1
   \   0000017C   40005AE3           CMP      R10,#+64
   \   00000180   C9FFFFBA           BLT      ??encode_one_block_3
    989          
    990            /* If the last coef(s) were zero, emit an end-of-block code */
    991            if (r > 0)
   \   00000184   01005BE3           CMP      R11,#+1
   \   00000188   050000BA           BLT      ??encode_one_block_10
    992              if (! emit_bits_s(state, actbl->ehufco[0], actbl->ehufsi[0]))
   \   0000018C   0024D5E5           LDRB     R2,[R5, #+1024]
   \   00000190   001095E5           LDR      R1,[R5, #+0]
   \   00000194   0400A0E1           MOV      R0,R4
   \   00000198   ........           BL       emit_bits_s
   \   0000019C   000050E3           CMP      R0,#+0
   \   000001A0   F28FBD08           POPEQ    {R1,R4-R11,PC}
    993                return FALSE;
    994          
    995            return TRUE;
   \                     ??encode_one_block_10:
   \   000001A4   0100A0E3           MOV      R0,#+1
   \   000001A8   F28FBDE8           POP      {R1,R4-R11,PC}   ;; return
    996          }
    997          
    998          
    999          /*
   1000           * Encode and output one MCU's worth of Huffman-compressed coefficients.
   1001           */
   1002          

   \                                 In segment CODE, align 4, keep-with-next
   1003          METHODDEF(boolean)
   1004          encode_mcu_huff (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
   1005          {
   \                     encode_mcu_huff:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   24D04DE2           SUB      SP,SP,#+36
   \   00000008   0040A0E1           MOV      R4,R0
   1006            huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
   \   0000000C   946194E5           LDR      R6,[R4, #+404]
   \   00000010   0150A0E1           MOV      R5,R1
   1007            working_state state;
   1008            int blkn, ci;
   1009            jpeg_component_info * compptr;
   1010          
   1011            /* Load up working state */
   1012            state.next_output_byte = cinfo->dest->next_output_byte;
   \   00000014   181094E5           LDR      R1,[R4, #+24]
   1013            state.free_in_buffer = cinfo->dest->free_in_buffer;
   1014            ASSIGN_STATE(state.cur, entropy->saved);
   \   00000018   08008DE2           ADD      R0,SP,#+8
   \   0000001C   001091E5           LDR      R1,[R1, #+0]
   \   00000020   00108DE5           STR      R1,[SP, #+0]
   \   00000024   181094E5           LDR      R1,[R4, #+24]
   \   00000028   041091E5           LDR      R1,[R1, #+4]
   \   0000002C   04108DE5           STR      R1,[SP, #+4]
   \   00000030   0C1086E2           ADD      R1,R6,#+12
   \   00000034   8C5191E8           LDM      R1,{R2,R3,R7,R8,R12,LR}
   \   00000038   8C5180E8           STM      R0,{R2,R3,R7,R8,R12,LR}
   1015            state.cinfo = cinfo;
   \   0000003C   20408DE5           STR      R4,[SP, #+32]
   1016          
   1017            /* Emit restart marker if needed */
   1018            if (cinfo->restart_interval) {
   \   00000040   E80094E5           LDR      R0,[R4, #+232]
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0A00000A           BEQ      ??encode_mcu_huff_0
   1019              if (entropy->restarts_to_go == 0)
   \   0000004C   240096E5           LDR      R0,[R6, #+36]
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   0700001A           BNE      ??encode_mcu_huff_0
   1020                if (! emit_restart_s(&state, entropy->next_restart_num))
   \   00000058   281096E5           LDR      R1,[R6, #+40]
   \   0000005C   0D00A0E1           MOV      R0,SP
   \   00000060   ........           BL       emit_restart_s
   \   00000064   000050E3           CMP      R0,#+0
   \   00000068   0200001A           BNE      ??encode_mcu_huff_0
   1021          	return FALSE;
   \                     ??encode_mcu_huff_1:
   \   0000006C   0000A0E3           MOV      R0,#+0
   \   00000070   24D08DE2           ADD      SP,SP,#+36
   \   00000074   F081BDE8           POP      {R4-R8,PC}
   1022            }
   1023          
   1024            /* Encode the MCU data blocks */
   1025            for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
   \                     ??encode_mcu_huff_0:
   \   00000078   0070A0E3           MOV      R7,#+0
   \   0000007C   170000EA           B        ??encode_mcu_huff_2
   1026              ci = cinfo->MCU_membership[blkn];
   \                     ??encode_mcu_huff_3:
   \   00000080   070184E0           ADD      R0,R4,R7, LSL #+2
   \   00000084   3C0190E5           LDR      R0,[R0, #+316]
   1027              compptr = cinfo->cur_comp_info[ci];
   1028              if (! encode_one_block(&state,
   1029          			   MCU_data[blkn][0], state.cur.last_dc_val[ci],
   1030          			   entropy->dc_derived_tbls[compptr->dc_tbl_no],
   1031          			   entropy->ac_derived_tbls[compptr->ac_tbl_no]))
   \   00000088   0D20A0E1           MOV      R2,SP
   \   0000008C   001184E0           ADD      R1,R4,R0, LSL #+2
   \   00000090   201191E5           LDR      R1,[R1, #+288]
   \   00000094   008182E0           ADD      R8,R2,R0, LSL #+2
   \   00000098   180091E5           LDR      R0,[R1, #+24]
   \   0000009C   000186E0           ADD      R0,R6,R0, LSL #+2
   \   000000A0   3C0090E5           LDR      R0,[R0, #+60]
   \   000000A4   01002DE9           PUSH     {R0}
   \   000000A8   102098E5           LDR      R2,[R8, #+16]
   \   000000AC   140091E5           LDR      R0,[R1, #+20]
   \   000000B0   071195E7           LDR      R1,[R5, +R7, LSL #+2]
   \   000000B4   000186E0           ADD      R0,R6,R0, LSL #+2
   \   000000B8   2C3090E5           LDR      R3,[R0, #+44]
   \   000000BC   04008DE2           ADD      R0,SP,#+4
   \   000000C0   ........           BL       encode_one_block
   \   000000C4   000050E3           CMP      R0,#+0
   \   000000C8   04D08DE2           ADD      SP,SP,#+4
   \   000000CC   E6FFFF0A           BEQ      ??encode_mcu_huff_1
   1032                return FALSE;
   1033              /* Update last_dc_val */
   1034              state.cur.last_dc_val[ci] = MCU_data[blkn][0][0];
   \   000000D0   070195E7           LDR      R0,[R5, +R7, LSL #+2]
   1035            }
   \   000000D4   017087E2           ADD      R7,R7,#+1
   \   000000D8   F000D0E1           LDRSH    R0,[R0, #+0]
   \   000000DC   100088E5           STR      R0,[R8, #+16]
   \                     ??encode_mcu_huff_2:
   \   000000E0   380194E5           LDR      R0,[R4, #+312]
   \   000000E4   000057E1           CMP      R7,R0
   \   000000E8   E4FFFFBA           BLT      ??encode_mcu_huff_3
   1036          
   1037            /* Completed MCU, so update state */
   1038            cinfo->dest->next_output_byte = state.next_output_byte;
   \   000000EC   180094E5           LDR      R0,[R4, #+24]
   \   000000F0   00109DE5           LDR      R1,[SP, #+0]
   \   000000F4   001080E5           STR      R1,[R0, #+0]
   1039            cinfo->dest->free_in_buffer = state.free_in_buffer;
   \   000000F8   180094E5           LDR      R0,[R4, #+24]
   \   000000FC   04109DE5           LDR      R1,[SP, #+4]
   \   00000100   041080E5           STR      R1,[R0, #+4]
   1040            ASSIGN_STATE(entropy->saved, state.cur);
   \   00000104   0C0086E2           ADD      R0,R6,#+12
   \   00000108   08108DE2           ADD      R1,SP,#+8
   \   0000010C   AC1191E8           LDM      R1,{R2,R3,R5,R7,R8,R12}
   \   00000110   AC1180E8           STM      R0,{R2,R3,R5,R7,R8,R12}
   1041          
   1042            /* Update restart-interval state too */
   1043            if (cinfo->restart_interval) {
   \   00000114   E80094E5           LDR      R0,[R4, #+232]
   \   00000118   000050E3           CMP      R0,#+0
   \   0000011C   0C00000A           BEQ      ??encode_mcu_huff_4
   1044              if (entropy->restarts_to_go == 0) {
   \   00000120   240096E5           LDR      R0,[R6, #+36]
   \   00000124   000050E3           CMP      R0,#+0
   \   00000128   0600001A           BNE      ??encode_mcu_huff_5
   1045                entropy->restarts_to_go = cinfo->restart_interval;
   \   0000012C   E80094E5           LDR      R0,[R4, #+232]
   \   00000130   240086E5           STR      R0,[R6, #+36]
   1046                entropy->next_restart_num++;
   \   00000134   280096E5           LDR      R0,[R6, #+40]
   \   00000138   010080E2           ADD      R0,R0,#+1
   \   0000013C   280086E5           STR      R0,[R6, #+40]
   1047                entropy->next_restart_num &= 7;
   \   00000140   070000E2           AND      R0,R0,#0x7
   \   00000144   280086E5           STR      R0,[R6, #+40]
   1048              }
   1049              entropy->restarts_to_go--;
   \                     ??encode_mcu_huff_5:
   \   00000148   240096E5           LDR      R0,[R6, #+36]
   \   0000014C   010040E2           SUB      R0,R0,#+1
   \   00000150   240086E5           STR      R0,[R6, #+36]
   1050            }
   1051          
   1052            return TRUE;
   \                     ??encode_mcu_huff_4:
   \   00000154   0100A0E3           MOV      R0,#+1
   \   00000158   24D08DE2           ADD      SP,SP,#+36
   \   0000015C   F081BDE8           POP      {R4-R8,PC}       ;; return
   1053          }
   1054          
   1055          
   1056          /*
   1057           * Finish up at the end of a Huffman-compressed scan.
   1058           */
   1059          

   \                                 In segment CODE, align 4, keep-with-next
   1060          METHODDEF(void)
   1061          finish_pass_huff (j_compress_ptr cinfo)
   1062          {
   \                     finish_pass_huff:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   24D04DE2           SUB      SP,SP,#+36
   \   00000008   0040A0E1           MOV      R4,R0
   1063            huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
   1064            working_state state;
   1065          
   1066            if (cinfo->progressive_mode) {
   \   0000000C   040194E5           LDR      R0,[R4, #+260]
   \   00000010   945194E5           LDR      R5,[R4, #+404]
   \   00000014   0060A0E3           MOV      R6,#+0
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   1500000A           BEQ      ??finish_pass_huff_0
   1067              entropy->next_output_byte = cinfo->dest->next_output_byte;
   \   00000020   180094E5           LDR      R0,[R4, #+24]
   \   00000024   000090E5           LDR      R0,[R0, #+0]
   \   00000028   700085E5           STR      R0,[R5, #+112]
   1068              entropy->free_in_buffer = cinfo->dest->free_in_buffer;
   \   0000002C   180094E5           LDR      R0,[R4, #+24]
   \   00000030   040090E5           LDR      R0,[R0, #+4]
   \   00000034   740085E5           STR      R0,[R5, #+116]
   1069          
   1070              /* Flush out any buffered data */
   1071              emit_eobrun(entropy);
   \   00000038   0500A0E1           MOV      R0,R5
   \   0000003C   ........           BL       emit_eobrun
   1072              flush_bits_e(entropy);
   \   00000040   0720A0E3           MOV      R2,#+7
   \   00000044   7F10A0E3           MOV      R1,#+127
   \   00000048   0500A0E1           MOV      R0,R5
   \   0000004C   ........           BL       emit_bits_e
   \   00000050   0C6085E5           STR      R6,[R5, #+12]
   \   00000054   106085E5           STR      R6,[R5, #+16]
   1073          
   1074              cinfo->dest->next_output_byte = entropy->next_output_byte;
   \   00000058   180094E5           LDR      R0,[R4, #+24]
   \   0000005C   701095E5           LDR      R1,[R5, #+112]
   \   00000060   001080E5           STR      R1,[R0, #+0]
   1075              cinfo->dest->free_in_buffer = entropy->free_in_buffer;
   \   00000064   180094E5           LDR      R0,[R4, #+24]
   \   00000068   741095E5           LDR      R1,[R5, #+116]
   \   0000006C   041080E5           STR      R1,[R0, #+4]
   \   00000070   24D08DE2           ADD      SP,SP,#+36
   \   00000074   F081BDE8           POP      {R4-R8,PC}
   1076            } else {
   1077              /* Load up working state ... flush_bits needs it */
   1078              state.next_output_byte = cinfo->dest->next_output_byte;
   \                     ??finish_pass_huff_0:
   \   00000078   181094E5           LDR      R1,[R4, #+24]
   1079              state.free_in_buffer = cinfo->dest->free_in_buffer;
   1080              ASSIGN_STATE(state.cur, entropy->saved);
   \   0000007C   08008DE2           ADD      R0,SP,#+8
   \   00000080   001091E5           LDR      R1,[R1, #+0]
   \   00000084   00108DE5           STR      R1,[SP, #+0]
   \   00000088   181094E5           LDR      R1,[R4, #+24]
   \   0000008C   041091E5           LDR      R1,[R1, #+4]
   \   00000090   04108DE5           STR      R1,[SP, #+4]
   \   00000094   0C1085E2           ADD      R1,R5,#+12
   \   00000098   8C5191E8           LDM      R1,{R2,R3,R7,R8,R12,LR}
   1081              state.cinfo = cinfo;
   1082          
   1083              /* Flush out the last data */
   1084              if (! flush_bits_s(&state))
   \   0000009C   7F10A0E3           MOV      R1,#+127
   \   000000A0   8C5180E8           STM      R0,{R2,R3,R7,R8,R12,LR}
   \   000000A4   20408DE5           STR      R4,[SP, #+32]
   \   000000A8   0720A0E3           MOV      R2,#+7
   \   000000AC   0D00A0E1           MOV      R0,SP
   \   000000B0   ........           BL       emit_bits_s
   \   000000B4   000050E3           CMP      R0,#+0
   \   000000B8   0700001A           BNE      ??finish_pass_huff_1
   1085                ERREXIT(cinfo, JERR_CANT_SUSPEND);
   \   000000BC   000094E5           LDR      R0,[R4, #+0]
   \   000000C0   1910A0E3           MOV      R1,#+25
   \   000000C4   141080E5           STR      R1,[R0, #+20]
   \   000000C8   001094E5           LDR      R1,[R4, #+0]
   \   000000CC   0400A0E1           MOV      R0,R4
   \   000000D0   001091E5           LDR      R1,[R1, #+0]
   \   000000D4   31FF2FE1           BLX      R1
   \   000000D8   010000EA           B        ??finish_pass_huff_2
   \                     ??finish_pass_huff_1:
   \   000000DC   08608DE5           STR      R6,[SP, #+8]
   \   000000E0   0C608DE5           STR      R6,[SP, #+12]
   1086          
   1087              /* Update state */
   1088              cinfo->dest->next_output_byte = state.next_output_byte;
   \                     ??finish_pass_huff_2:
   \   000000E4   180094E5           LDR      R0,[R4, #+24]
   \   000000E8   00109DE5           LDR      R1,[SP, #+0]
   \   000000EC   001080E5           STR      R1,[R0, #+0]
   1089              cinfo->dest->free_in_buffer = state.free_in_buffer;
   \   000000F0   180094E5           LDR      R0,[R4, #+24]
   \   000000F4   04109DE5           LDR      R1,[SP, #+4]
   \   000000F8   041080E5           STR      R1,[R0, #+4]
   1090              ASSIGN_STATE(entropy->saved, state.cur);
   \   000000FC   0C0085E2           ADD      R0,R5,#+12
   \   00000100   08108DE2           ADD      R1,SP,#+8
   \   00000104   FC0091E8           LDM      R1,{R2-R7}
   \   00000108   FC0080E8           STM      R0,{R2-R7}
   1091            }
   1092          }
   \   0000010C   24D08DE2           ADD      SP,SP,#+36
   \   00000110   F081BDE8           POP      {R4-R8,PC}       ;; return
   1093          
   1094          
   1095          /*
   1096           * Huffman coding optimization.
   1097           *
   1098           * We first scan the supplied data and count the number of uses of each symbol
   1099           * that is to be Huffman-coded. (This process MUST agree with the code above.)
   1100           * Then we build a Huffman coding tree for the observed counts.
   1101           * Symbols which are not needed at all for the particular image are not
   1102           * assigned any code, which saves space in the DHT marker as well as in
   1103           * the compressed data.
   1104           */
   1105          
   1106          
   1107          /* Process a single block's worth of coefficients */
   1108          

   \                                 In segment CODE, align 4, keep-with-next
   1109          LOCAL(void)
   1110          htest_one_block (j_compress_ptr cinfo, JCOEFPTR block, int last_dc_val,
   1111          		 long dc_counts[], long ac_counts[])
   1112          {
   \                     htest_one_block:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   20609DE5           LDR      R6,[SP, #+32]
   \   0000000C   0150A0E1           MOV      R5,R1
   1113            register int temp;
   1114            register int nbits;
   1115            register int k, r;
   1116            
   1117            /* Encode the DC coefficient difference per section F.1.2.1 */
   1118            
   1119            temp = block[0] - last_dc_val;
   \   00000010   F000D5E1           LDRSH    R0,[R5, #+0]
   \   00000014   0390A0E1           MOV      R9,R3
   1120            if (temp < 0)
   1121              temp = -temp;
   1122            
   1123            /* Find the number of bits needed for the magnitude of the coefficient */
   1124            nbits = 0;
   \   00000018   0070A0E3           MOV      R7,#+0
   \   0000001C   020050E0           SUBS     R0,R0,R2
   \   00000020   00006042           RSBMI    R0,R0,#+0
   \   00000024   0680A0E3           MOV      R8,#+6
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   0A00000A           BEQ      ??htest_one_block_0
   1125            while (temp) {
   1126              nbits++;
   \                     ??htest_one_block_1:
   \   00000030   017087E2           ADD      R7,R7,#+1
   1127              temp >>= 1;
   \   00000034   C000B0E1           ASRS     R0,R0,#+1
   1128            }
   \   00000038   FCFFFF1A           BNE      ??htest_one_block_1
   1129            /* Check for out-of-range coefficient values.
   1130             * Since we're encoding a difference, the range limit is twice as much.
   1131             */
   1132            if (nbits > MAX_COEF_BITS+1)
   \   0000003C   0C0057E3           CMP      R7,#+12
   \   00000040   050000BA           BLT      ??htest_one_block_0
   1133              ERREXIT(cinfo, JERR_BAD_DCT_COEF);
   \   00000044   000094E5           LDR      R0,[R4, #+0]
   \   00000048   148080E5           STR      R8,[R0, #+20]
   \   0000004C   001094E5           LDR      R1,[R4, #+0]
   \   00000050   0400A0E1           MOV      R0,R4
   \   00000054   001091E5           LDR      R1,[R1, #+0]
   \   00000058   31FF2FE1           BLX      R1
   1134          
   1135            /* Count the Huffman symbol for the number of bits */
   1136            dc_counts[nbits]++;
   \                     ??htest_one_block_0:
   \   0000005C   070199E7           LDR      R0,[R9, +R7, LSL #+2]
   1137            
   1138            /* Encode the AC coefficients per section F.1.2.2 */
   1139            
   1140            r = 0;			/* r = run length of zeros */
   \   00000060   00A0A0E3           MOV      R10,#+0
   \   00000064   010080E2           ADD      R0,R0,#+1
   \   00000068   070189E7           STR      R0,[R9, +R7, LSL #+2]
   1141            
   1142            for (k = 1; k < DCTSIZE2; k++) {
   \   0000006C   0190A0E3           MOV      R9,#+1
   1143              if ((temp = block[jpeg_natural_order[k]]) == 0) {
   \                     ??htest_one_block_2:
   \   00000070   ........           LDR      R0,??DataTable4  ;; jpeg_natural_order
   \   00000074   090190E7           LDR      R0,[R0, +R9, LSL #+2]
   \   00000078   800085E0           ADD      R0,R5,R0, LSL #+1
   \   0000007C   F000D0E1           LDRSH    R0,[R0, #+0]
   \   00000080   000050E3           CMP      R0,#+0
   \   00000084   0500001A           BNE      ??htest_one_block_3
   1144                r++;
   \   00000088   01A08AE2           ADD      R10,R10,#+1
   \   0000008C   190000EA           B        ??htest_one_block_4
   1145              } else {
   1146                /* if run length > 15, must emit special run-length-16 codes (0xF0) */
   1147                while (r > 15) {
   1148          	ac_counts[0xF0]++;
   \                     ??htest_one_block_5:
   \   00000090   C01396E5           LDR      R1,[R6, #+960]
   1149          	r -= 16;
   \   00000094   10A04AE2           SUB      R10,R10,#+16
   \   00000098   011081E2           ADD      R1,R1,#+1
   \   0000009C   C01386E5           STR      R1,[R6, #+960]
   1150                }
   \                     ??htest_one_block_3:
   \   000000A0   10005AE3           CMP      R10,#+16
   \   000000A4   F9FFFFAA           BGE      ??htest_one_block_5
   1151                
   1152                /* Find the number of bits needed for the magnitude of the coefficient */
   1153                if (temp < 0)
   \   000000A8   000050E3           CMP      R0,#+0
   1154          	temp = -temp;
   \   000000AC   00006042           RSBMI    R0,R0,#+0
   1155                
   1156                /* Find the number of bits needed for the magnitude of the coefficient */
   1157                nbits = 1;		/* there must be at least one 1 bit */
   \   000000B0   0170A0E3           MOV      R7,#+1
   \   000000B4   000000EA           B        ??htest_one_block_6
   1158                while ((temp >>= 1))
   1159          	nbits++;
   \                     ??htest_one_block_7:
   \   000000B8   017087E2           ADD      R7,R7,#+1
   \                     ??htest_one_block_6:
   \   000000BC   C000B0E1           ASRS     R0,R0,#+1
   \   000000C0   FCFFFF1A           BNE      ??htest_one_block_7
   1160                /* Check for out-of-range coefficient values */
   1161                if (nbits > MAX_COEF_BITS)
   \   000000C4   0B0057E3           CMP      R7,#+11
   \   000000C8   050000BA           BLT      ??htest_one_block_8
   1162          	ERREXIT(cinfo, JERR_BAD_DCT_COEF);
   \   000000CC   000094E5           LDR      R0,[R4, #+0]
   \   000000D0   148080E5           STR      R8,[R0, #+20]
   \   000000D4   001094E5           LDR      R1,[R4, #+0]
   \   000000D8   0400A0E1           MOV      R0,R4
   \   000000DC   001091E5           LDR      R1,[R1, #+0]
   \   000000E0   31FF2FE1           BLX      R1
   1163                
   1164                /* Count Huffman symbol for run length / number of bits */
   1165                ac_counts[(r << 4) + nbits]++;
   \                     ??htest_one_block_8:
   \   000000E4   0A0287E0           ADD      R0,R7,R10, LSL #+4
   \   000000E8   001196E7           LDR      R1,[R6, +R0, LSL #+2]
   1166                
   1167                r = 0;
   \   000000EC   00A0A0E3           MOV      R10,#+0
   \   000000F0   011081E2           ADD      R1,R1,#+1
   \   000000F4   001186E7           STR      R1,[R6, +R0, LSL #+2]
   1168              }
   1169            }
   \                     ??htest_one_block_4:
   \   000000F8   019089E2           ADD      R9,R9,#+1
   \   000000FC   400059E3           CMP      R9,#+64
   \   00000100   DAFFFFBA           BLT      ??htest_one_block_2
   1170          
   1171            /* If the last coef(s) were zero, emit an end-of-block code */
   1172            if (r > 0)
   \   00000104   01005AE3           CMP      R10,#+1
   1173              ac_counts[0]++;
   \   00000108   000096A5           LDRGE    R0,[R6, #+0]
   \   0000010C   010080A2           ADDGE    R0,R0,#+1
   \   00000110   000086A5           STRGE    R0,[R6, #+0]
   1174          }
   \   00000114   F087BDE8           POP      {R4-R10,PC}      ;; return
   1175          
   1176          
   1177          /*
   1178           * Trial-encode one MCU's worth of Huffman-compressed coefficients.
   1179           * No data is actually output, so no suspension return is possible.
   1180           */
   1181          

   \                                 In segment CODE, align 4, keep-with-next
   1182          METHODDEF(boolean)
   1183          encode_mcu_gather (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
   1184          {
   \                     encode_mcu_gather:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1185            huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
   1186            int blkn, ci;
   1187            jpeg_component_info * compptr;
   1188          
   1189            /* Take care of restart intervals if needed */
   1190            if (cinfo->restart_interval) {
   \   00000008   E80094E5           LDR      R0,[R4, #+232]
   \   0000000C   946194E5           LDR      R6,[R4, #+404]
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   1200000A           BEQ      ??encode_mcu_gather_0
   1191              if (entropy->restarts_to_go == 0) {
   \   0000001C   240096E5           LDR      R0,[R6, #+36]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0C00001A           BNE      ??encode_mcu_gather_1
   1192                /* Re-initialize DC predictions to 0 */
   1193                for (ci = 0; ci < cinfo->comps_in_scan; ci++)
   \   00000028   1C1194E5           LDR      R1,[R4, #+284]
   \   0000002C   0020A0E3           MOV      R2,#+0
   \   00000030   010051E3           CMP      R1,#+1
   \   00000034   030000AA           BGE      ??encode_mcu_gather_2
   \   00000038   050000EA           B        ??encode_mcu_gather_3
   1194          	entropy->saved.last_dc_val[ci] = 0;
   \                     ??encode_mcu_gather_4:
   \   0000003C   001186E0           ADD      R1,R6,R0, LSL #+2
   \   00000040   142081E5           STR      R2,[R1, #+20]
   \   00000044   010080E2           ADD      R0,R0,#+1
   \                     ??encode_mcu_gather_2:
   \   00000048   1C1194E5           LDR      R1,[R4, #+284]
   \   0000004C   010050E1           CMP      R0,R1
   \   00000050   F9FFFFBA           BLT      ??encode_mcu_gather_4
   1195                /* Update restart state */
   1196                entropy->restarts_to_go = cinfo->restart_interval;
   \                     ??encode_mcu_gather_3:
   \   00000054   E80094E5           LDR      R0,[R4, #+232]
   \   00000058   240086E5           STR      R0,[R6, #+36]
   1197              }
   1198              entropy->restarts_to_go--;
   \                     ??encode_mcu_gather_1:
   \   0000005C   240096E5           LDR      R0,[R6, #+36]
   \   00000060   010040E2           SUB      R0,R0,#+1
   \   00000064   240086E5           STR      R0,[R6, #+36]
   1199            }
   1200          
   1201            for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
   \                     ??encode_mcu_gather_0:
   \   00000068   380194E5           LDR      R0,[R4, #+312]
   \   0000006C   0070A0E3           MOV      R7,#+0
   \   00000070   010050E3           CMP      R0,#+1
   \   00000074   160000AA           BGE      ??encode_mcu_gather_5
   \   00000078   0100A0E3           MOV      R0,#+1
   \   0000007C   F081BDE8           POP      {R4-R8,PC}
   1202              ci = cinfo->MCU_membership[blkn];
   \                     ??encode_mcu_gather_6:
   \   00000080   070184E0           ADD      R0,R4,R7, LSL #+2
   \   00000084   3C0190E5           LDR      R0,[R0, #+316]
   1203              compptr = cinfo->cur_comp_info[ci];
   \   00000088   001184E0           ADD      R1,R4,R0, LSL #+2
   \   0000008C   201191E5           LDR      R1,[R1, #+288]
   1204              htest_one_block(cinfo, MCU_data[blkn][0], entropy->saved.last_dc_val[ci],
   1205          		    entropy->dc_count_ptrs[compptr->dc_tbl_no],
   1206          		    entropy->ac_count_ptrs[compptr->ac_tbl_no]);
   \   00000090   008186E0           ADD      R8,R6,R0, LSL #+2
   \   00000094   180091E5           LDR      R0,[R1, #+24]
   \   00000098   000186E0           ADD      R0,R6,R0, LSL #+2
   \   0000009C   5C0090E5           LDR      R0,[R0, #+92]
   \   000000A0   01002DE9           PUSH     {R0}
   \   000000A4   142098E5           LDR      R2,[R8, #+20]
   \   000000A8   140091E5           LDR      R0,[R1, #+20]
   \   000000AC   071195E7           LDR      R1,[R5, +R7, LSL #+2]
   \   000000B0   000186E0           ADD      R0,R6,R0, LSL #+2
   \   000000B4   4C3090E5           LDR      R3,[R0, #+76]
   \   000000B8   0400A0E1           MOV      R0,R4
   \   000000BC   ........           BL       htest_one_block
   1207              entropy->saved.last_dc_val[ci] = MCU_data[blkn][0][0];
   \   000000C0   070195E7           LDR      R0,[R5, +R7, LSL #+2]
   1208            }
   \   000000C4   017087E2           ADD      R7,R7,#+1
   \   000000C8   F000D0E1           LDRSH    R0,[R0, #+0]
   \   000000CC   140088E5           STR      R0,[R8, #+20]
   \   000000D0   04D08DE2           ADD      SP,SP,#+4
   \                     ??encode_mcu_gather_5:
   \   000000D4   380194E5           LDR      R0,[R4, #+312]
   \   000000D8   000057E1           CMP      R7,R0
   \   000000DC   E7FFFFBA           BLT      ??encode_mcu_gather_6
   1209          
   1210            return TRUE;
   \   000000E0   0100A0E3           MOV      R0,#+1
   \   000000E4   F081BDE8           POP      {R4-R8,PC}       ;; return
   1211          }
   1212          
   1213          
   1214          /*
   1215           * Generate the best Huffman code table for the given counts, fill htbl.
   1216           *
   1217           * The JPEG standard requires that no symbol be assigned a codeword of all
   1218           * one bits (so that padding bits added at the end of a compressed segment
   1219           * can't look like a valid code).  Because of the canonical ordering of
   1220           * codewords, this just means that there must be an unused slot in the
   1221           * longest codeword length category.  Section K.2 of the JPEG spec suggests
   1222           * reserving such a slot by pretending that symbol 256 is a valid symbol
   1223           * with count 1.  In theory that's not optimal; giving it count zero but
   1224           * including it in the symbol set anyway should give a better Huffman code.
   1225           * But the theoretically better code actually seems to come out worse in
   1226           * practice, because it produces more all-ones bytes (which incur stuffed
   1227           * zero bytes in the final file).  In any case the difference is tiny.
   1228           *
   1229           * The JPEG standard requires Huffman codes to be no more than 16 bits long.
   1230           * If some symbols have a very small but nonzero probability, the Huffman tree
   1231           * must be adjusted to meet the code length restriction.  We currently use
   1232           * the adjustment method suggested in JPEG section K.2.  This method is *not*
   1233           * optimal; it may not choose the best possible limited-length code.  But
   1234           * typically only very-low-frequency symbols will be given less-than-optimal
   1235           * lengths, so the code is almost optimal.  Experimental comparisons against
   1236           * an optimal limited-length-code algorithm indicate that the difference is
   1237           * microscopic --- usually less than a hundredth of a percent of total size.
   1238           * So the extra complexity of an optimal algorithm doesn't seem worthwhile.
   1239           */
   1240          

   \                                 In segment CODE, align 4, keep-with-next
   1241          LOCAL(void)
   1242          jpeg_gen_optimal_table (j_compress_ptr cinfo, JHUFF_TBL * htbl, long freq[])
   1243          {
   \                     jpeg_gen_optimal_table:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   2CD04DE2           SUB      SP,SP,#+44
   \   00000008   80DE4DE2           SUB      SP,SP,#+2048
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   0280A0E1           MOV      R8,R2
   1244          #define MAX_CLEN 32		/* assumed maximum initial code length */
   1245            UINT8 bits[MAX_CLEN+1];	/* bits[k] = # of symbols with code length k */
   1246            int codesize[257];		/* codesize[k] = code length of symbol k */
   1247            int others[257];		/* next symbol in current branch of tree */
   1248            int c1, c2;
   1249            int p, i, j;
   1250            long v;
   1251          
   1252            /* This algorithm is explained in section K.2 of the JPEG standard */
   1253          
   1254            MEMZERO(bits, SIZEOF(bits));
   \   00000018   2120A0E3           MOV      R2,#+33
   \   0000001C   0010A0E3           MOV      R1,#+0
   \   00000020   0D00A0E1           MOV      R0,SP
   \   00000024   BB0000EF           SWI      +187
   1255            MEMZERO(codesize, SIZEOF(codesize));
   \   00000028   0420A0E3           MOV      R2,#+4
   \   0000002C   402E82E3           ORR      R2,R2,#0x400
   \   00000030   0010A0E3           MOV      R1,#+0
   \   00000034   28008DE2           ADD      R0,SP,#+40
   \   00000038   400E80E2           ADD      R0,R0,#+1024
   \   0000003C   BB0000EF           SWI      +187
   1256            for (i = 0; i < 257; i++)
   \   00000040   0030A0E3           MOV      R3,#+0
   \   00000044   0160A0E3           MOV      R6,#+1
   \   00000048   406F86E3           ORR      R6,R6,#0x100
   \   0000004C   24008DE2           ADD      R0,SP,#+36
   \   00000050   0310E0E1           MVN      R1,R3
   1257              others[i] = -1;		/* init links to empty */
   \                     ??jpeg_gen_optimal_table_0:
   \   00000054   031180E7           STR      R1,[R0, +R3, LSL #+2]
   \   00000058   013083E2           ADD      R3,R3,#+1
   \   0000005C   060053E1           CMP      R3,R6
   \   00000060   FBFFFFBA           BLT      ??jpeg_gen_optimal_table_0
   1258            
   1259            freq[256] = 1;		/* make sure 256 has a nonzero count */
   \   00000064   0100A0E3           MOV      R0,#+1
   \   00000068   000488E5           STR      R0,[R8, #+1024]
   \   0000006C   AC029FE5           LDR      R0,??jpeg_gen_optimal_table_1  ;; 0x3b9aca00
   \   00000070   320000EA           B        ??jpeg_gen_optimal_table_2
   1260            /* Including the pseudo-symbol 256 in the Huffman procedure guarantees
   1261             * that no real symbol is given code-value of all ones, because 256
   1262             * will be placed last in the largest codeword category.
   1263             */
   1264          
   1265            /* Huffman's basic algorithm to assign optimal code lengths to symbols */
   1266          
   1267            for (;;) {
   1268              /* Find the smallest nonzero frequency, set c1 = its symbol */
   1269              /* In case of ties, take the larger symbol number */
   1270              c1 = -1;
   1271              v = 1000000000L;
   1272              for (i = 0; i <= 256; i++) {
   1273                if (freq[i] && freq[i] <= v) {
   1274          	v = freq[i];
   1275          	c1 = i;
   1276                }
   1277              }
   1278          
   1279              /* Find the next smallest nonzero frequency, set c2 = its symbol */
   1280              /* In case of ties, take the larger symbol number */
   1281              c2 = -1;
   1282              v = 1000000000L;
   1283              for (i = 0; i <= 256; i++) {
   1284                if (freq[i] && freq[i] <= v && i != c1) {
   1285          	v = freq[i];
   1286          	c2 = i;
   1287                }
   1288              }
   1289          
   1290              /* Done if we've merged everything into one frequency */
   1291              if (c2 < 0)
   1292                break;
   1293              
   1294              /* Else merge the two counts/trees */
   1295              freq[c1] += freq[c2];
   \                     ??jpeg_gen_optimal_table_3:
   \   00000074   013198E7           LDR      R3,[R8, +R1, LSL #+2]
   \   00000078   029198E7           LDR      R9,[R8, +R2, LSL #+2]
   \   0000007C   033089E0           ADD      R3,R9,R3
   \   00000080   013188E7           STR      R3,[R8, +R1, LSL #+2]
   1296              freq[c2] = 0;
   \   00000084   027188E7           STR      R7,[R8, +R2, LSL #+2]
   1297          
   1298              /* Increment the codesize of everything in c1's tree branch */
   1299              codesize[c1]++;
   \   00000088   28308DE2           ADD      R3,SP,#+40
   \   0000008C   403E83E2           ADD      R3,R3,#+1024
   \   00000090   013183E0           ADD      R3,R3,R1, LSL #+2
   \   00000094   007093E5           LDR      R7,[R3, #+0]
   \   00000098   017087E2           ADD      R7,R7,#+1
   \   0000009C   007083E5           STR      R7,[R3, #+0]
   \   000000A0   24308DE2           ADD      R3,SP,#+36
   \   000000A4   013193E7           LDR      R3,[R3, +R1, LSL #+2]
   \   000000A8   000053E3           CMP      R3,#+0
   \   000000AC   0B00004A           BMI      ??jpeg_gen_optimal_table_4
   1300              while (others[c1] >= 0) {
   1301                c1 = others[c1];
   \                     ??jpeg_gen_optimal_table_5:
   \   000000B0   24308DE2           ADD      R3,SP,#+36
   \   000000B4   011193E7           LDR      R1,[R3, +R1, LSL #+2]
   1302                codesize[c1]++;
   \   000000B8   28308DE2           ADD      R3,SP,#+40
   \   000000BC   403E83E2           ADD      R3,R3,#+1024
   \   000000C0   013183E0           ADD      R3,R3,R1, LSL #+2
   \   000000C4   007093E5           LDR      R7,[R3, #+0]
   \   000000C8   017087E2           ADD      R7,R7,#+1
   \   000000CC   007083E5           STR      R7,[R3, #+0]
   1303              }
   \   000000D0   24308DE2           ADD      R3,SP,#+36
   \   000000D4   013193E7           LDR      R3,[R3, +R1, LSL #+2]
   \   000000D8   000053E3           CMP      R3,#+0
   \   000000DC   F3FFFF5A           BPL      ??jpeg_gen_optimal_table_5
   1304              
   1305              others[c1] = c2;		/* chain c2 onto c1's tree branch */
   \                     ??jpeg_gen_optimal_table_4:
   \   000000E0   24308DE2           ADD      R3,SP,#+36
   \   000000E4   012183E7           STR      R2,[R3, +R1, LSL #+2]
   1306              
   1307              /* Increment the codesize of everything in c2's tree branch */
   1308              codesize[c2]++;
   \   000000E8   28108DE2           ADD      R1,SP,#+40
   \   000000EC   401E81E2           ADD      R1,R1,#+1024
   \   000000F0   021181E0           ADD      R1,R1,R2, LSL #+2
   \   000000F4   003091E5           LDR      R3,[R1, #+0]
   \   000000F8   013083E2           ADD      R3,R3,#+1
   \   000000FC   003081E5           STR      R3,[R1, #+0]
   \   00000100   24108DE2           ADD      R1,SP,#+36
   \   00000104   021191E7           LDR      R1,[R1, +R2, LSL #+2]
   \   00000108   000051E3           CMP      R1,#+0
   \   0000010C   0B00004A           BMI      ??jpeg_gen_optimal_table_2
   1309              while (others[c2] >= 0) {
   1310                c2 = others[c2];
   \                     ??jpeg_gen_optimal_table_6:
   \   00000110   24108DE2           ADD      R1,SP,#+36
   \   00000114   022191E7           LDR      R2,[R1, +R2, LSL #+2]
   1311                codesize[c2]++;
   \   00000118   28108DE2           ADD      R1,SP,#+40
   \   0000011C   401E81E2           ADD      R1,R1,#+1024
   \   00000120   021181E0           ADD      R1,R1,R2, LSL #+2
   \   00000124   003091E5           LDR      R3,[R1, #+0]
   \   00000128   013083E2           ADD      R3,R3,#+1
   \   0000012C   003081E5           STR      R3,[R1, #+0]
   1312              }
   \   00000130   24108DE2           ADD      R1,SP,#+36
   \   00000134   021191E7           LDR      R1,[R1, +R2, LSL #+2]
   \   00000138   000051E3           CMP      R1,#+0
   \   0000013C   F3FFFF5A           BPL      ??jpeg_gen_optimal_table_6
   \                     ??jpeg_gen_optimal_table_2:
   \   00000140   0010E0E3           MVN      R1,#+0
   \   00000144   0020A0E1           MOV      R2,R0
   \   00000148   0030A0E3           MOV      R3,#+0
   \                     ??jpeg_gen_optimal_table_7:
   \   0000014C   037198E7           LDR      R7,[R8, +R3, LSL #+2]
   \   00000150   000057E3           CMP      R7,#+0
   \   00000154   0200000A           BEQ      ??jpeg_gen_optimal_table_8
   \   00000158   070052E1           CMP      R2,R7
   \   0000015C   0720A0A1           MOVGE    R2,R7
   \   00000160   0310A0A1           MOVGE    R1,R3
   \                     ??jpeg_gen_optimal_table_8:
   \   00000164   013083E2           ADD      R3,R3,#+1
   \   00000168   060053E1           CMP      R3,R6
   \   0000016C   F6FFFFBA           BLT      ??jpeg_gen_optimal_table_7
   \   00000170   0020E0E3           MVN      R2,#+0
   \   00000174   0070A0E1           MOV      R7,R0
   \   00000178   0030A0E3           MOV      R3,#+0
   \                     ??jpeg_gen_optimal_table_9:
   \   0000017C   039198E7           LDR      R9,[R8, +R3, LSL #+2]
   \   00000180   000059E3           CMP      R9,#+0
   \   00000184   0400000A           BEQ      ??jpeg_gen_optimal_table_10
   \   00000188   090057E1           CMP      R7,R9
   \   0000018C   020000BA           BLT      ??jpeg_gen_optimal_table_10
   \   00000190   010053E1           CMP      R3,R1
   \   00000194   0970A011           MOVNE    R7,R9
   \   00000198   0320A011           MOVNE    R2,R3
   \                     ??jpeg_gen_optimal_table_10:
   \   0000019C   013083E2           ADD      R3,R3,#+1
   \   000001A0   060053E1           CMP      R3,R6
   \   000001A4   F4FFFFBA           BLT      ??jpeg_gen_optimal_table_9
   \   000001A8   0070A0E3           MOV      R7,#+0
   \   000001AC   000052E3           CMP      R2,#+0
   \   000001B0   AFFFFF5A           BPL      ??jpeg_gen_optimal_table_3
   1313            }
   1314          
   1315            /* Now count the number of symbols of each code length */
   1316            for (i = 0; i <= 256; i++) {
   \   000001B4   0080A0E3           MOV      R8,#+0
   1317              if (codesize[i]) {
   \                     ??jpeg_gen_optimal_table_11:
   \   000001B8   28008DE2           ADD      R0,SP,#+40
   \   000001BC   400E80E2           ADD      R0,R0,#+1024
   \   000001C0   089180E0           ADD      R9,R0,R8, LSL #+2
   \   000001C4   000099E5           LDR      R0,[R9, #+0]
   \   000001C8   000050E3           CMP      R0,#+0
   \   000001CC   0E00000A           BEQ      ??jpeg_gen_optimal_table_12
   1318                /* The JPEG standard seems to think that this can't happen, */
   1319                /* but I'm paranoid... */
   1320                if (codesize[i] > MAX_CLEN)
   \   000001D0   210050E3           CMP      R0,#+33
   \   000001D4   060000BA           BLT      ??jpeg_gen_optimal_table_13
   1321          	ERREXIT(cinfo, JERR_HUFF_CLEN_OVERFLOW);
   \   000001D8   000094E5           LDR      R0,[R4, #+0]
   \   000001DC   2810A0E3           MOV      R1,#+40
   \   000001E0   141080E5           STR      R1,[R0, #+20]
   \   000001E4   001094E5           LDR      R1,[R4, #+0]
   \   000001E8   0400A0E1           MOV      R0,R4
   \   000001EC   001091E5           LDR      R1,[R1, #+0]
   \   000001F0   31FF2FE1           BLX      R1
   1322          
   1323                bits[codesize[i]]++;
   \                     ??jpeg_gen_optimal_table_13:
   \   000001F4   000099E5           LDR      R0,[R9, #+0]
   \   000001F8   0D10A0E1           MOV      R1,SP
   \   000001FC   010080E0           ADD      R0,R0,R1
   \   00000200   0010D0E5           LDRB     R1,[R0, #+0]
   \   00000204   011081E2           ADD      R1,R1,#+1
   \   00000208   0010C0E5           STRB     R1,[R0, #+0]
   1324              }
   1325            }
   \                     ??jpeg_gen_optimal_table_12:
   \   0000020C   018088E2           ADD      R8,R8,#+1
   \   00000210   060058E1           CMP      R8,R6
   \   00000214   E7FFFFBA           BLT      ??jpeg_gen_optimal_table_11
   1326          
   1327            /* JPEG doesn't allow symbols with code lengths over 16 bits, so if the pure
   1328             * Huffman procedure assigned any such lengths, we must adjust the coding.
   1329             * Here is what the JPEG spec says about how this next bit works:
   1330             * Since symbols are paired for the longest Huffman code, the symbols are
   1331             * removed from this length category two at a time.  The prefix for the pair
   1332             * (which is one bit shorter) is allocated to one of the pair; then,
   1333             * skipping the BITS entry for that prefix length, a code word from the next
   1334             * shortest nonzero BITS entry is converted into a prefix for two code words
   1335             * one bit longer.
   1336             */
   1337            
   1338            for (i = MAX_CLEN; i > 16; i--) {
   \   00000218   2000A0E3           MOV      R0,#+32
   \   0000021C   170000EA           B        ??jpeg_gen_optimal_table_14
   1339              while (bits[i] > 0) {
   1340                j = i - 2;		/* find length of new prefix to be used */
   \                     ??jpeg_gen_optimal_table_15:
   \   00000220   021040E2           SUB      R1,R0,#+2
   \   00000224   0D30A0E1           MOV      R3,SP
   \   00000228   0330D1E7           LDRB     R3,[R1, +R3]
   \   0000022C   000053E3           CMP      R3,#+0
   \   00000230   0400001A           BNE      ??jpeg_gen_optimal_table_16
   1341                while (bits[j] == 0)
   1342          	j--;
   \                     ??jpeg_gen_optimal_table_17:
   \   00000234   011041E2           SUB      R1,R1,#+1
   \   00000238   0D30A0E1           MOV      R3,SP
   \   0000023C   0330D1E7           LDRB     R3,[R1, +R3]
   \   00000240   000053E3           CMP      R3,#+0
   \   00000244   FAFFFF0A           BEQ      ??jpeg_gen_optimal_table_17
   1343                
   1344                bits[i] -= 2;		/* remove two symbols */
   \                     ??jpeg_gen_optimal_table_16:
   \   00000248   0030D2E5           LDRB     R3,[R2, #+0]
   \   0000024C   FE3083E2           ADD      R3,R3,#+254
   \   00000250   0030C2E5           STRB     R3,[R2, #+0]
   1345                bits[i-1]++;		/* one goes in this length */
   \   00000254   013052E5           LDRB     R3,[R2, #-1]
   \   00000258   013083E2           ADD      R3,R3,#+1
   \   0000025C   013042E5           STRB     R3,[R2, #-1]
   1346                bits[j+1] += 2;		/* two new symbols in this length */
   \   00000260   0D20A0E1           MOV      R2,SP
   \   00000264   021081E0           ADD      R1,R1,R2
   \   00000268   0120D1E5           LDRB     R2,[R1, #+1]
   \   0000026C   022082E2           ADD      R2,R2,#+2
   \   00000270   0120C1E5           STRB     R2,[R1, #+1]
   1347                bits[j]--;		/* symbol of this length is now a prefix */
   \   00000274   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000278   012042E2           SUB      R2,R2,#+1
   \   0000027C   0020C1E5           STRB     R2,[R1, #+0]
   1348              }
   \                     ??jpeg_gen_optimal_table_14:
   \   00000280   0D10A0E1           MOV      R1,SP
   \   00000284   012080E0           ADD      R2,R0,R1
   \   00000288   0010D2E5           LDRB     R1,[R2, #+0]
   \   0000028C   000051E3           CMP      R1,#+0
   \   00000290   E2FFFF1A           BNE      ??jpeg_gen_optimal_table_15
   1349            }
   \   00000294   010040E2           SUB      R0,R0,#+1
   \   00000298   110050E3           CMP      R0,#+17
   \   0000029C   F7FFFFAA           BGE      ??jpeg_gen_optimal_table_14
   1350          
   1351            /* Remove the count for the pseudo-symbol 256 from the largest codelength */
   1352            while (bits[i] == 0)		/* find largest codelength still in use */
   \                     ??jpeg_gen_optimal_table_18:
   \   000002A0   0D10A0E1           MOV      R1,SP
   \   000002A4   011080E0           ADD      R1,R0,R1
   \   000002A8   0020D1E5           LDRB     R2,[R1, #+0]
   \   000002AC   000052E3           CMP      R2,#+0
   1353              i--;
   \   000002B0   01004002           SUBEQ    R0,R0,#+1
   \   000002B4   F9FFFF0A           BEQ      ??jpeg_gen_optimal_table_18
   1354            bits[i]--;
   \   000002B8   010042E2           SUB      R0,R2,#+1
   \   000002BC   0000C1E5           STRB     R0,[R1, #+0]
   1355            
   1356            /* Return final symbol counts (only for lengths 0..16) */
   1357            MEMCOPY(htbl->bits, bits, SIZEOF(htbl->bits));
   \   000002C0   1120A0E3           MOV      R2,#+17
   \   000002C4   0D10A0E1           MOV      R1,SP
   \   000002C8   0500A0E1           MOV      R0,R5
   \   000002CC   1E0100EF           SWI      +286
   1358            
   1359            /* Return a list of the symbols sorted by code length */
   1360            /* It's not real clear to me why we don't need to consider the codelength
   1361             * changes made above, but the JPEG spec seems to think this works.
   1362             */
   1363            p = 0;
   \   000002D0   0000A0E3           MOV      R0,#+0
   1364            for (i = 1; i <= MAX_CLEN; i++) {
   \   000002D4   0120A0E3           MOV      R2,#+1
   1365              for (j = 0; j <= 255; j++) {
   \                     ??jpeg_gen_optimal_table_19:
   \   000002D8   0010A0E3           MOV      R1,#+0
   1366                if (codesize[j] == i) {
   \                     ??jpeg_gen_optimal_table_20:
   \   000002DC   28308DE2           ADD      R3,SP,#+40
   \   000002E0   403E83E2           ADD      R3,R3,#+1024
   \   000002E4   013193E7           LDR      R3,[R3, +R1, LSL #+2]
   \   000002E8   020053E1           CMP      R3,R2
   1367          	htbl->huffval[p] = (UINT8) j;
   \   000002EC   05308000           ADDEQ    R3,R0,R5
   \   000002F0   1110C305           STRBEQ   R1,[R3, #+17]
   1368          	p++;
   \   000002F4   01008002           ADDEQ    R0,R0,#+1
   1369                }
   1370              }
   \   000002F8   011081E2           ADD      R1,R1,#+1
   \   000002FC   400F51E3           CMP      R1,#+256
   \   00000300   F5FFFFBA           BLT      ??jpeg_gen_optimal_table_20
   1371            }
   \   00000304   012082E2           ADD      R2,R2,#+1
   \   00000308   210052E3           CMP      R2,#+33
   \   0000030C   F1FFFFBA           BLT      ??jpeg_gen_optimal_table_19
   1372          
   1373            /* Set sent_table FALSE so updated table will be written to JPEG file. */
   1374            htbl->sent_table = FALSE;
   \   00000310   147185E5           STR      R7,[R5, #+276]
   1375          }
   \   00000314   2CD08DE2           ADD      SP,SP,#+44
   \   00000318   80DE8DE2           ADD      SP,SP,#+2048
   \   0000031C   F083BDE8           POP      {R4-R9,PC}       ;; return
   \                     ??jpeg_gen_optimal_table_1:
   \   00000320   00CA9A3B           DC32     0x3b9aca00
   1376          
   1377          
   1378          /*
   1379           * Finish up a statistics-gathering pass and create the new Huffman tables.
   1380           */
   1381          

   \                                 In segment CODE, align 4, keep-with-next
   1382          METHODDEF(void)
   1383          finish_pass_gather (j_compress_ptr cinfo)
   1384          {
   \                     finish_pass_gather:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   30D04DE2           SUB      SP,SP,#+48
   \   00000008   0040A0E1           MOV      R4,R0
   1385            huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
   1386            int ci, dctbl, actbl, tbl;
   1387            jpeg_component_info * compptr;
   1388            JHUFF_TBL **htblptr;
   1389            boolean did_dc[NUM_HUFF_TBLS];
   1390            boolean did_ac[NUM_HUFF_TBLS];
   1391            boolean did[NUM_HUFF_TBLS];
   1392          
   1393            /* It's important not to apply jpeg_gen_optimal_table more than once
   1394             * per table, because it clobbers the input frequency counts!
   1395             */
   1396            if (cinfo->progressive_mode) {
   \   0000000C   040194E5           LDR      R0,[R4, #+260]
   \   00000010   945194E5           LDR      R5,[R4, #+404]
   \   00000014   0160A0E3           MOV      R6,#+1
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   3000000A           BEQ      ??finish_pass_gather_0
   1397              /* Flush out buffered data (all we care about is counting the EOB symbol) */
   1398              emit_eobrun(entropy);
   \   00000020   0500A0E1           MOV      R0,R5
   \   00000024   ........           BL       emit_eobrun
   1399          
   1400              MEMZERO(did, SIZEOF(did));
   \   00000028   1020A0E3           MOV      R2,#+16
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   20008DE2           ADD      R0,SP,#+32
   \   00000034   BB0000EF           SWI      +187
   1401          
   1402              for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
   \   00000038   1C0194E5           LDR      R0,[R4, #+284]
   \   0000003C   0070A0E3           MOV      R7,#+0
   \   00000040   010050E3           CMP      R0,#+1
   \   00000044   0D0000AA           BGE      ??finish_pass_gather_1
   \   00000048   310000EA           B        ??finish_pass_gather_2
   1403                compptr = cinfo->cur_comp_info[ci];
   1404                if (cinfo->Ss == 0) {
   1405          	if (cinfo->Ah != 0)	/* DC refinement needs no table */
   1406          	  continue;
   1407          	tbl = compptr->dc_tbl_no;
   1408                } else {
   1409          	tbl = compptr->ac_tbl_no;
   1410                }
   1411                if (! did[tbl]) {
   1412          	if (cinfo->Ss == 0)
   1413          	  htblptr = & cinfo->dc_huff_tbl_ptrs[tbl];
   1414          	else
   1415          	  htblptr = & cinfo->ac_huff_tbl_ptrs[tbl];
   1416          	if (*htblptr == NULL)
   \                     ??finish_pass_gather_3:
   \   0000004C   000098E5           LDR      R0,[R8, #+0]
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   0200001A           BNE      ??finish_pass_gather_4
   1417          	  *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
   \   00000058   0400A0E1           MOV      R0,R4
   \   0000005C   ........           _BLF     jpeg_alloc_huff_table,??jpeg_alloc_huff_table??rA
   \   00000060   000088E5           STR      R0,[R8, #+0]
   1418          	jpeg_gen_optimal_table(cinfo, *htblptr, entropy->count_ptrs[tbl]);
   \                     ??finish_pass_gather_4:
   \   00000064   001098E5           LDR      R1,[R8, #+0]
   \   00000068   090185E0           ADD      R0,R5,R9, LSL #+2
   \   0000006C   9C2090E5           LDR      R2,[R0, #+156]
   \   00000070   0400A0E1           MOV      R0,R4
   \   00000074   ........           BL       jpeg_gen_optimal_table
   1419          	did[tbl] = TRUE;
   \   00000078   00608AE5           STR      R6,[R10, #+0]
   \                     ??finish_pass_gather_5:
   \   0000007C   017087E2           ADD      R7,R7,#+1
   \                     ??finish_pass_gather_1:
   \   00000080   1C0194E5           LDR      R0,[R4, #+284]
   \   00000084   000057E1           CMP      R7,R0
   \   00000088   510000AA           BGE      ??finish_pass_gather_6
   \   0000008C   641194E5           LDR      R1,[R4, #+356]
   \   00000090   070184E0           ADD      R0,R4,R7, LSL #+2
   \   00000094   200190E5           LDR      R0,[R0, #+288]
   \   00000098   000051E3           CMP      R1,#+0
   \   0000009C   0400001A           BNE      ??finish_pass_gather_7
   \   000000A0   6C1194E5           LDR      R1,[R4, #+364]
   \   000000A4   000051E3           CMP      R1,#+0
   \   000000A8   F3FFFF1A           BNE      ??finish_pass_gather_5
   \   000000AC   149090E5           LDR      R9,[R0, #+20]
   \   000000B0   000000EA           B        ??finish_pass_gather_8
   \                     ??finish_pass_gather_7:
   \   000000B4   189090E5           LDR      R9,[R0, #+24]
   \                     ??finish_pass_gather_8:
   \   000000B8   20008DE2           ADD      R0,SP,#+32
   \   000000BC   09A180E0           ADD      R10,R0,R9, LSL #+2
   \   000000C0   00009AE5           LDR      R0,[R10, #+0]
   \   000000C4   000050E3           CMP      R0,#+0
   \   000000C8   EBFFFF1A           BNE      ??finish_pass_gather_5
   \   000000CC   641194E5           LDR      R1,[R4, #+356]
   \   000000D0   090184E0           ADD      R0,R4,R9, LSL #+2
   \   000000D4   000051E3           CMP      R1,#+0
   \   000000D8   84808012           ADDNE    R8,R0,#+132
   \   000000DC   74808002           ADDEQ    R8,R0,#+116
   \   000000E0   D9FFFFEA           B        ??finish_pass_gather_3
   1420                }
   1421              }
   1422            } else {
   1423              MEMZERO(did_dc, SIZEOF(did_dc));
   \                     ??finish_pass_gather_0:
   \   000000E4   1020A0E3           MOV      R2,#+16
   \   000000E8   0010A0E3           MOV      R1,#+0
   \   000000EC   0D00A0E1           MOV      R0,SP
   \   000000F0   BB0000EF           SWI      +187
   1424              MEMZERO(did_ac, SIZEOF(did_ac));
   \   000000F4   1020A0E3           MOV      R2,#+16
   \   000000F8   0010A0E3           MOV      R1,#+0
   \   000000FC   10008DE2           ADD      R0,SP,#+16
   \   00000100   BB0000EF           SWI      +187
   1425          
   1426              for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
   \   00000104   1C0194E5           LDR      R0,[R4, #+284]
   \   00000108   0070A0E3           MOV      R7,#+0
   \   0000010C   010050E3           CMP      R0,#+1
   \   00000110   2C0000AA           BGE      ??finish_pass_gather_9
   \                     ??finish_pass_gather_2:
   \   00000114   30D08DE2           ADD      SP,SP,#+48
   \   00000118   F08FBDE8           POP      {R4-R11,PC}
   1427                compptr = cinfo->cur_comp_info[ci];
   \                     ??finish_pass_gather_10:
   \   0000011C   070184E0           ADD      R0,R4,R7, LSL #+2
   \   00000120   200190E5           LDR      R0,[R0, #+288]
   1428                dctbl = compptr->dc_tbl_no;
   \   00000124   14A090E5           LDR      R10,[R0, #+20]
   1429                actbl = compptr->ac_tbl_no;
   \   00000128   189090E5           LDR      R9,[R0, #+24]
   1430                if (! did_dc[dctbl]) {
   \   0000012C   0D00A0E1           MOV      R0,SP
   \   00000130   0AB180E0           ADD      R11,R0,R10, LSL #+2
   \   00000134   00009BE5           LDR      R0,[R11, #+0]
   \   00000138   000050E3           CMP      R0,#+0
   \   0000013C   0D00001A           BNE      ??finish_pass_gather_11
   1431          	htblptr = & cinfo->dc_huff_tbl_ptrs[dctbl];
   \   00000140   0A0184E0           ADD      R0,R4,R10, LSL #+2
   \   00000144   748080E2           ADD      R8,R0,#+116
   1432          	if (*htblptr == NULL)
   \   00000148   000098E5           LDR      R0,[R8, #+0]
   \   0000014C   000050E3           CMP      R0,#+0
   \   00000150   0200001A           BNE      ??finish_pass_gather_12
   1433          	  *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
   \   00000154   0400A0E1           MOV      R0,R4
   \   00000158   ........           _BLF     jpeg_alloc_huff_table,??jpeg_alloc_huff_table??rA
   \   0000015C   000088E5           STR      R0,[R8, #+0]
   1434          	jpeg_gen_optimal_table(cinfo, *htblptr, entropy->dc_count_ptrs[dctbl]);
   \                     ??finish_pass_gather_12:
   \   00000160   001098E5           LDR      R1,[R8, #+0]
   \   00000164   0A0185E0           ADD      R0,R5,R10, LSL #+2
   \   00000168   4C2090E5           LDR      R2,[R0, #+76]
   \   0000016C   0400A0E1           MOV      R0,R4
   \   00000170   ........           BL       jpeg_gen_optimal_table
   1435          	did_dc[dctbl] = TRUE;
   \   00000174   00608BE5           STR      R6,[R11, #+0]
   1436                }
   1437                if (! did_ac[actbl]) {
   \                     ??finish_pass_gather_11:
   \   00000178   10008DE2           ADD      R0,SP,#+16
   \   0000017C   09A180E0           ADD      R10,R0,R9, LSL #+2
   \   00000180   00009AE5           LDR      R0,[R10, #+0]
   \   00000184   000050E3           CMP      R0,#+0
   \   00000188   0D00001A           BNE      ??finish_pass_gather_13
   1438          	htblptr = & cinfo->ac_huff_tbl_ptrs[actbl];
   \   0000018C   090184E0           ADD      R0,R4,R9, LSL #+2
   \   00000190   848080E2           ADD      R8,R0,#+132
   1439          	if (*htblptr == NULL)
   \   00000194   000098E5           LDR      R0,[R8, #+0]
   \   00000198   000050E3           CMP      R0,#+0
   \   0000019C   0200001A           BNE      ??finish_pass_gather_14
   1440          	  *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
   \   000001A0   0400A0E1           MOV      R0,R4
   \   000001A4   ........           _BLF     jpeg_alloc_huff_table,??jpeg_alloc_huff_table??rA
   \   000001A8   000088E5           STR      R0,[R8, #+0]
   1441          	jpeg_gen_optimal_table(cinfo, *htblptr, entropy->ac_count_ptrs[actbl]);
   \                     ??finish_pass_gather_14:
   \   000001AC   001098E5           LDR      R1,[R8, #+0]
   \   000001B0   090185E0           ADD      R0,R5,R9, LSL #+2
   \   000001B4   5C2090E5           LDR      R2,[R0, #+92]
   \   000001B8   0400A0E1           MOV      R0,R4
   \   000001BC   ........           BL       jpeg_gen_optimal_table
   1442          	did_ac[actbl] = TRUE;
   \   000001C0   00608AE5           STR      R6,[R10, #+0]
   1443                }
   1444              }
   \                     ??finish_pass_gather_13:
   \   000001C4   017087E2           ADD      R7,R7,#+1
   \                     ??finish_pass_gather_9:
   \   000001C8   1C0194E5           LDR      R0,[R4, #+284]
   \   000001CC   000057E1           CMP      R7,R0
   \   000001D0   D1FFFFBA           BLT      ??finish_pass_gather_10
   1445            }
   1446          }
   \                     ??finish_pass_gather_6:
   \   000001D4   30D08DE2           ADD      SP,SP,#+48       ;; stack cleaning
   \   000001D8   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1447          
   1448          
   1449          /*
   1450           * Initialize for a Huffman-compressed scan.
   1451           * If gather_statistics is TRUE, we do not output anything during the scan,
   1452           * just count the Huffman symbols used and generate Huffman code tables.
   1453           */
   1454          

   \                                 In segment CODE, align 4, keep-with-next
   1455          METHODDEF(void)
   1456          start_pass_huff (j_compress_ptr cinfo, boolean gather_statistics)
   1457          {
   \                     start_pass_huff:
   \   00000000   F24F2DE9           PUSH     {R1,R4-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1458            huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
   \   00000008   945194E5           LDR      R5,[R4, #+404]
   1459            int ci, dctbl, actbl, tbl;
   1460            jpeg_component_info * compptr;
   1461          
   1462            if (gather_statistics)
   \   0000000C   000051E3           CMP      R1,#+0
   1463              entropy->pub.finish_pass = finish_pass_gather;
   \   00000010   0C039F15           LDRNE    R0,??start_pass_huff_0  ;; finish_pass_gather
   1464            else
   1465              entropy->pub.finish_pass = finish_pass_huff;
   1466          
   1467            if (cinfo->progressive_mode) {
   \   00000014   0470A0E3           MOV      R7,#+4
   \   00000018   08039F05           LDREQ    R0,??start_pass_huff_0+0x4  ;; finish_pass_huff
   \   0000001C   407E87E3           ORR      R7,R7,#0x400
   \   00000020   080085E5           STR      R0,[R5, #+8]
   \   00000024   040194E5           LDR      R0,[R4, #+260]
   \   00000028   3480A0E3           MOV      R8,#+52
   \   0000002C   0060A0E3           MOV      R6,#+0
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   6000000A           BEQ      ??start_pass_huff_1
   1468              entropy->cinfo = cinfo;
   \   00000038   784085E5           STR      R4,[R5, #+120]
   1469              entropy->gather_statistics = gather_statistics;
   \   0000003C   00009DE5           LDR      R0,[SP, #+0]
   \   00000040   6C0085E5           STR      R0,[R5, #+108]
   1470          
   1471              /* We assume jcmaster.c already validated the scan parameters. */
   1472          
   1473              /* Select execution routine */
   1474              if (cinfo->Ah == 0) {
   \   00000044   6C0194E5           LDR      R0,[R4, #+364]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   640194E5           LDR      R0,[R4, #+356]
   \   00000050   0400001A           BNE      ??start_pass_huff_2
   1475                if (cinfo->Ss == 0)
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   CC029F15           LDRNE    R0,??start_pass_huff_0+0x8  ;; encode_mcu_AC_first
   1476          	entropy->pub.encode_mcu = encode_mcu_DC_first;
   \   0000005C   CC029F05           LDREQ    R0,??start_pass_huff_0+0xC  ;; encode_mcu_DC_first
   \   00000060   040085E5           STR      R0,[R5, #+4]
   \   00000064   0F0000EA           B        ??start_pass_huff_3
   1477                else
   1478          	entropy->pub.encode_mcu = encode_mcu_AC_first;
   1479              } else {
   1480                if (cinfo->Ss == 0)
   \                     ??start_pass_huff_2:
   \   00000068   000050E3           CMP      R0,#+0
   1481          	entropy->pub.encode_mcu = encode_mcu_DC_refine;
   \   0000006C   C0029F05           LDREQ    R0,??start_pass_huff_0+0x10  ;; encode_mcu_DC_refine
   \   00000070   04008505           STREQ    R0,[R5, #+4]
   \   00000074   0B00000A           BEQ      ??start_pass_huff_3
   1482                else {
   1483          	entropy->pub.encode_mcu = encode_mcu_AC_refine;
   \   00000078   B8029FE5           LDR      R0,??start_pass_huff_0+0x14  ;; encode_mcu_AC_refine
   \   0000007C   040085E5           STR      R0,[R5, #+4]
   1484          	/* AC refinement needs a correction bit buffer */
   1485          	if (entropy->bit_buffer == NULL)
   \   00000080   880095E5           LDR      R0,[R5, #+136]
   \   00000084   000050E3           CMP      R0,#+0
   \   00000088   0600001A           BNE      ??start_pass_huff_3
   1486          	  entropy->bit_buffer = (char *)
   1487          	    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
   1488          					MAX_CORR_BITS * SIZEOF(char));
   \   0000008C   043094E5           LDR      R3,[R4, #+4]
   \   00000090   FA2FA0E3           MOV      R2,#+1000
   \   00000094   003093E5           LDR      R3,[R3, #+0]
   \   00000098   0110A0E3           MOV      R1,#+1
   \   0000009C   0400A0E1           MOV      R0,R4
   \   000000A0   33FF2FE1           BLX      R3
   \   000000A4   880085E5           STR      R0,[R5, #+136]
   1489                }
   1490              }
   1491          
   1492              /* Only DC coefficients may be interleaved, so cinfo->comps_in_scan = 1
   1493               * for AC coefficients.
   1494               */
   1495              for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
   \                     ??start_pass_huff_3:
   \   000000A8   1C0194E5           LDR      R0,[R4, #+284]
   \   000000AC   0090A0E3           MOV      R9,#+0
   \   000000B0   010050E3           CMP      R0,#+1
   \   000000B4   0B0000AA           BGE      ??start_pass_huff_4
   1496                compptr = cinfo->cur_comp_info[ci];
   1497                /* Initialize DC predictions to 0 */
   1498                entropy->saved.last_dc_val[ci] = 0;
   1499                /* Get table index */
   1500                if (cinfo->Ss == 0) {
   1501          	if (cinfo->Ah != 0)	/* DC refinement needs no table */
   1502          	  continue;
   1503          	tbl = compptr->dc_tbl_no;
   1504                } else {
   1505          	entropy->ac_tbl_no = tbl = compptr->ac_tbl_no;
   1506                }
   1507                if (gather_statistics) {
   1508          	/* Check for invalid table index */
   1509          	/* (make_c_derived_tbl does this in the other path) */
   1510          	if (tbl < 0 || tbl >= NUM_HUFF_TBLS)
   1511          	  ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tbl);
   1512          	/* Allocate and zero the statistics tables */
   1513          	/* Note that jpeg_gen_optimal_table expects 257 entries in each table! */
   1514          	if (entropy->count_ptrs[tbl] == NULL)
   1515          	  entropy->count_ptrs[tbl] = (long *)
   1516          	    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
   1517          					257 * SIZEOF(long));
   1518          	MEMZERO(entropy->count_ptrs[tbl], 257 * SIZEOF(long));
   1519                } else {
   1520          	/* Compute derived values for Huffman table */
   1521          	/* We may do this more than once for a table, but it's not expensive */
   1522          	jpeg_make_c_derived_tbl(cinfo, cinfo->Ss == 0, tbl,
   1523          				& entropy->derived_tbls[tbl]);
   1524                }
   1525              }
   1526          
   1527              /* Initialize AC stuff */
   1528              entropy->EOBRUN = 0;
   \                     ??start_pass_huff_5:
   \   000000B8   806085E5           STR      R6,[R5, #+128]
   1529              entropy->BE = 0;
   \   000000BC   846085E5           STR      R6,[R5, #+132]
   1530            } else {
   1531              if (gather_statistics)
   1532                entropy->pub.encode_mcu = encode_mcu_gather;
   1533              else
   1534                entropy->pub.encode_mcu = encode_mcu_huff;
   1535          
   1536              for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
   1537                compptr = cinfo->cur_comp_info[ci];
   1538                dctbl = compptr->dc_tbl_no;
   1539                actbl = compptr->ac_tbl_no;
   1540                if (gather_statistics) {
   1541          	/* Check for invalid table indexes */
   1542          	/* (make_c_derived_tbl does this in the other path) */
   1543          	if (dctbl < 0 || dctbl >= NUM_HUFF_TBLS)
   1544          	  ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, dctbl);
   1545          	if (actbl < 0 || actbl >= NUM_HUFF_TBLS)
   1546          	  ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, actbl);
   1547          	/* Allocate and zero the statistics tables */
   1548          	/* Note that jpeg_gen_optimal_table expects 257 entries in each table! */
   1549          	if (entropy->dc_count_ptrs[dctbl] == NULL)
   1550          	  entropy->dc_count_ptrs[dctbl] = (long *)
   1551          	    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
   1552          					257 * SIZEOF(long));
   1553          	MEMZERO(entropy->dc_count_ptrs[dctbl], 257 * SIZEOF(long));
   1554          	if (entropy->ac_count_ptrs[actbl] == NULL)
   1555          	  entropy->ac_count_ptrs[actbl] = (long *)
   1556          	    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
   1557          					257 * SIZEOF(long));
   1558          	MEMZERO(entropy->ac_count_ptrs[actbl], 257 * SIZEOF(long));
   1559                } else {
   1560          	/* Compute derived values for Huffman tables */
   1561          	/* We may do this more than once for a table, but it's not expensive */
   1562          	jpeg_make_c_derived_tbl(cinfo, TRUE, dctbl,
   1563          				& entropy->dc_derived_tbls[dctbl]);
   1564          	jpeg_make_c_derived_tbl(cinfo, FALSE, actbl,
   1565          				& entropy->ac_derived_tbls[actbl]);
   1566                }
   1567                /* Initialize DC predictions to 0 */
   1568                entropy->saved.last_dc_val[ci] = 0;
   1569              }
   1570            }
   1571          
   1572            /* Initialize bit buffer to empty */
   1573            entropy->saved.put_buffer = 0;
   \                     ??start_pass_huff_6:
   \   000000C0   0C6085E5           STR      R6,[R5, #+12]
   1574            entropy->saved.put_bits = 0;
   \   000000C4   106085E5           STR      R6,[R5, #+16]
   1575          
   1576            /* Initialize restart stuff */
   1577            entropy->restarts_to_go = cinfo->restart_interval;
   \   000000C8   E80094E5           LDR      R0,[R4, #+232]
   \   000000CC   240085E5           STR      R0,[R5, #+36]
   1578            entropy->next_restart_num = 0;
   \   000000D0   286085E5           STR      R6,[R5, #+40]
   1579          }
   \   000000D4   F18FBDE8           POP      {R0,R4-R11,PC}   ;; return
   \                     ??start_pass_huff_7:
   \   000000D8   8C308AE2           ADD      R3,R10,#+140
   \   000000DC   0400A0E1           MOV      R0,R4
   \   000000E0   ........           BL       jpeg_make_c_derived_tbl
   \                     ??start_pass_huff_8:
   \   000000E4   019089E2           ADD      R9,R9,#+1
   \                     ??start_pass_huff_4:
   \   000000E8   1C0194E5           LDR      R0,[R4, #+284]
   \   000000EC   000059E1           CMP      R9,R0
   \   000000F0   F0FFFFAA           BGE      ??start_pass_huff_5
   \   000000F4   090184E0           ADD      R0,R4,R9, LSL #+2
   \   000000F8   200190E5           LDR      R0,[R0, #+288]
   \   000000FC   091185E0           ADD      R1,R5,R9, LSL #+2
   \   00000100   146081E5           STR      R6,[R1, #+20]
   \   00000104   641194E5           LDR      R1,[R4, #+356]
   \   00000108   000051E3           CMP      R1,#+0
   \   0000010C   0400001A           BNE      ??start_pass_huff_9
   \   00000110   6C1194E5           LDR      R1,[R4, #+364]
   \   00000114   000051E3           CMP      R1,#+0
   \   00000118   F1FFFF1A           BNE      ??start_pass_huff_8
   \   0000011C   142090E5           LDR      R2,[R0, #+20]
   \   00000120   010000EA           B        ??start_pass_huff_10
   \                     ??start_pass_huff_9:
   \   00000124   182090E5           LDR      R2,[R0, #+24]
   \   00000128   7C2085E5           STR      R2,[R5, #+124]
   \                     ??start_pass_huff_10:
   \   0000012C   00009DE5           LDR      R0,[SP, #+0]
   \   00000130   02A185E0           ADD      R10,R5,R2, LSL #+2
   \   00000134   000050E3           CMP      R0,#+0
   \   00000138   1A00000A           BEQ      ??start_pass_huff_11
   \   0000013C   000052E3           CMP      R2,#+0
   \   00000140   0100004A           BMI      ??start_pass_huff_12
   \   00000144   040052E3           CMP      R2,#+4
   \   00000148   070000BA           BLT      ??start_pass_huff_13
   \                     ??start_pass_huff_12:
   \   0000014C   000094E5           LDR      R0,[R4, #+0]
   \   00000150   148080E5           STR      R8,[R0, #+20]
   \   00000154   000094E5           LDR      R0,[R4, #+0]
   \   00000158   182080E5           STR      R2,[R0, #+24]
   \   0000015C   001094E5           LDR      R1,[R4, #+0]
   \   00000160   0400A0E1           MOV      R0,R4
   \   00000164   001091E5           LDR      R1,[R1, #+0]
   \   00000168   31FF2FE1           BLX      R1
   \                     ??start_pass_huff_13:
   \   0000016C   9C009AE5           LDR      R0,[R10, #+156]
   \   00000170   000050E3           CMP      R0,#+0
   \   00000174   0600001A           BNE      ??start_pass_huff_14
   \   00000178   043094E5           LDR      R3,[R4, #+4]
   \   0000017C   0720A0E1           MOV      R2,R7
   \   00000180   003093E5           LDR      R3,[R3, #+0]
   \   00000184   0110A0E3           MOV      R1,#+1
   \   00000188   0400A0E1           MOV      R0,R4
   \   0000018C   33FF2FE1           BLX      R3
   \   00000190   9C008AE5           STR      R0,[R10, #+156]
   \                     ??start_pass_huff_14:
   \   00000194   9C009AE5           LDR      R0,[R10, #+156]
   \   00000198   0720A0E1           MOV      R2,R7
   \   0000019C   0010A0E3           MOV      R1,#+0
   \   000001A0   BB0000EF           SWI      +187
   \   000001A4   CEFFFFEA           B        ??start_pass_huff_8
   \                     ??start_pass_huff_11:
   \   000001A8   640194E5           LDR      R0,[R4, #+356]
   \   000001AC   000050E3           CMP      R0,#+0
   \   000001B0   0010A013           MOVNE    R1,#+0
   \   000001B4   0110A003           MOVEQ    R1,#+1
   \   000001B8   C6FFFFEA           B        ??start_pass_huff_7
   \                     ??start_pass_huff_1:
   \   000001BC   00009DE5           LDR      R0,[SP, #+0]
   \   000001C0   0090A0E3           MOV      R9,#+0
   \   000001C4   000050E3           CMP      R0,#+0
   \   000001C8   6C019F15           LDRNE    R0,??start_pass_huff_0+0x18  ;; encode_mcu_gather
   \   000001CC   6C019F05           LDREQ    R0,??start_pass_huff_0+0x1C  ;; encode_mcu_huff
   \   000001D0   040085E5           STR      R0,[R5, #+4]
   \   000001D4   1C0194E5           LDR      R0,[R4, #+284]
   \   000001D8   010050E3           CMP      R0,#+1
   \   000001DC   0F0000AA           BGE      ??start_pass_huff_15
   \   000001E0   B6FFFFEA           B        ??start_pass_huff_6
   \                     ??start_pass_huff_16:
   \   000001E4   0B0185E0           ADD      R0,R5,R11, LSL #+2
   \   000001E8   2C3080E2           ADD      R3,R0,#+44
   \   000001EC   0B20A0E1           MOV      R2,R11
   \   000001F0   0110A0E3           MOV      R1,#+1
   \   000001F4   0400A0E1           MOV      R0,R4
   \   000001F8   ........           BL       jpeg_make_c_derived_tbl
   \   000001FC   0A0185E0           ADD      R0,R5,R10, LSL #+2
   \   00000200   3C3080E2           ADD      R3,R0,#+60
   \   00000204   0A20A0E1           MOV      R2,R10
   \   00000208   0010A0E3           MOV      R1,#+0
   \   0000020C   0400A0E1           MOV      R0,R4
   \   00000210   ........           BL       jpeg_make_c_derived_tbl
   \                     ??start_pass_huff_17:
   \   00000214   090185E0           ADD      R0,R5,R9, LSL #+2
   \   00000218   146080E5           STR      R6,[R0, #+20]
   \   0000021C   019089E2           ADD      R9,R9,#+1
   \                     ??start_pass_huff_15:
   \   00000220   1C0194E5           LDR      R0,[R4, #+284]
   \   00000224   000059E1           CMP      R9,R0
   \   00000228   A4FFFFAA           BGE      ??start_pass_huff_6
   \   0000022C   090184E0           ADD      R0,R4,R9, LSL #+2
   \   00000230   200190E5           LDR      R0,[R0, #+288]
   \   00000234   14B090E5           LDR      R11,[R0, #+20]
   \   00000238   18A090E5           LDR      R10,[R0, #+24]
   \   0000023C   00009DE5           LDR      R0,[SP, #+0]
   \   00000240   000050E3           CMP      R0,#+0
   \   00000244   E6FFFF0A           BEQ      ??start_pass_huff_16
   \   00000248   00005BE3           CMP      R11,#+0
   \   0000024C   0100004A           BMI      ??start_pass_huff_18
   \   00000250   04005BE3           CMP      R11,#+4
   \   00000254   070000BA           BLT      ??start_pass_huff_19
   \                     ??start_pass_huff_18:
   \   00000258   000094E5           LDR      R0,[R4, #+0]
   \   0000025C   148080E5           STR      R8,[R0, #+20]
   \   00000260   000094E5           LDR      R0,[R4, #+0]
   \   00000264   18B080E5           STR      R11,[R0, #+24]
   \   00000268   001094E5           LDR      R1,[R4, #+0]
   \   0000026C   0400A0E1           MOV      R0,R4
   \   00000270   001091E5           LDR      R1,[R1, #+0]
   \   00000274   31FF2FE1           BLX      R1
   \                     ??start_pass_huff_19:
   \   00000278   00005AE3           CMP      R10,#+0
   \   0000027C   0100004A           BMI      ??start_pass_huff_20
   \   00000280   04005AE3           CMP      R10,#+4
   \   00000284   070000BA           BLT      ??start_pass_huff_21
   \                     ??start_pass_huff_20:
   \   00000288   000094E5           LDR      R0,[R4, #+0]
   \   0000028C   148080E5           STR      R8,[R0, #+20]
   \   00000290   000094E5           LDR      R0,[R4, #+0]
   \   00000294   18A080E5           STR      R10,[R0, #+24]
   \   00000298   001094E5           LDR      R1,[R4, #+0]
   \   0000029C   0400A0E1           MOV      R0,R4
   \   000002A0   001091E5           LDR      R1,[R1, #+0]
   \   000002A4   31FF2FE1           BLX      R1
   \                     ??start_pass_huff_21:
   \   000002A8   0BB185E0           ADD      R11,R5,R11, LSL #+2
   \   000002AC   4C009BE5           LDR      R0,[R11, #+76]
   \   000002B0   000050E3           CMP      R0,#+0
   \   000002B4   0600001A           BNE      ??start_pass_huff_22
   \   000002B8   043094E5           LDR      R3,[R4, #+4]
   \   000002BC   0720A0E1           MOV      R2,R7
   \   000002C0   003093E5           LDR      R3,[R3, #+0]
   \   000002C4   0110A0E3           MOV      R1,#+1
   \   000002C8   0400A0E1           MOV      R0,R4
   \   000002CC   33FF2FE1           BLX      R3
   \   000002D0   4C008BE5           STR      R0,[R11, #+76]
   \                     ??start_pass_huff_22:
   \   000002D4   4C009BE5           LDR      R0,[R11, #+76]
   \   000002D8   0720A0E1           MOV      R2,R7
   \   000002DC   0010A0E3           MOV      R1,#+0
   \   000002E0   BB0000EF           SWI      +187
   \   000002E4   0AA185E0           ADD      R10,R5,R10, LSL #+2
   \   000002E8   5C009AE5           LDR      R0,[R10, #+92]
   \   000002EC   000050E3           CMP      R0,#+0
   \   000002F0   0600001A           BNE      ??start_pass_huff_23
   \   000002F4   043094E5           LDR      R3,[R4, #+4]
   \   000002F8   0720A0E1           MOV      R2,R7
   \   000002FC   003093E5           LDR      R3,[R3, #+0]
   \   00000300   0110A0E3           MOV      R1,#+1
   \   00000304   0400A0E1           MOV      R0,R4
   \   00000308   33FF2FE1           BLX      R3
   \   0000030C   5C008AE5           STR      R0,[R10, #+92]
   \                     ??start_pass_huff_23:
   \   00000310   5C009AE5           LDR      R0,[R10, #+92]
   \   00000314   0720A0E1           MOV      R2,R7
   \   00000318   0010A0E3           MOV      R1,#+0
   \   0000031C   BB0000EF           SWI      +187
   \   00000320   BBFFFFEA           B        ??start_pass_huff_17
   \                     ??start_pass_huff_0:
   \   00000324   ........           DC32     finish_pass_gather
   \   00000328   ........           DC32     finish_pass_huff
   \   0000032C   ........           DC32     encode_mcu_AC_first
   \   00000330   ........           DC32     encode_mcu_DC_first
   \   00000334   ........           DC32     encode_mcu_DC_refine
   \   00000338   ........           DC32     encode_mcu_AC_refine
   \   0000033C   ........           DC32     encode_mcu_gather
   \   00000340   ........           DC32     encode_mcu_huff
   1580          
   1581          
   1582          /*
   1583           * Module initialization routine for Huffman entropy encoding.
   1584           */
   1585          

   \                                 In segment CODE, align 4, keep-with-next
   1586          GLOBAL(void)
   1587          jinit_huff_encoder (j_compress_ptr cinfo)
   1588          {
   \                     jinit_huff_encoder:
   \   00000000   10402DE9           PUSH     {R4,LR}
   1589            huff_entropy_ptr entropy;
   1590            int i;
   1591          
   1592            entropy = (huff_entropy_ptr)
   1593              (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
   1594          				SIZEOF(huff_entropy_encoder));
   \   00000004   AC20A0E3           MOV      R2,#+172
   \   00000008   0110A0E3           MOV      R1,#+1
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   043094E5           LDR      R3,[R4, #+4]
   \   00000014   003093E5           LDR      R3,[R3, #+0]
   \   00000018   33FF2FE1           BLX      R3
   1595            cinfo->entropy = (struct jpeg_entropy_encoder *) entropy;
   1596            entropy->pub.start_pass = start_pass_huff;
   \   0000001C   60109FE5           LDR      R1,??jinit_huff_encoder_0  ;; start_pass_huff
   \   00000020   940184E5           STR      R0,[R4, #+404]
   \   00000024   001080E5           STR      R1,[R0, #+0]
   1597          
   1598            if (cinfo->progressive_mode) {
   \   00000028   042194E5           LDR      R2,[R4, #+260]
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   000052E3           CMP      R2,#+0
   \   00000034   0020A0E3           MOV      R2,#+0
   \   00000038   0700000A           BEQ      ??jinit_huff_encoder_1
   1599              /* Mark tables unallocated */
   1600              for (i = 0; i < NUM_HUFF_TBLS; i++) {
   1601                entropy->derived_tbls[i] = NULL;
   \                     ??jinit_huff_encoder_2:
   \   0000003C   023180E0           ADD      R3,R0,R2, LSL #+2
   \   00000040   8C1083E5           STR      R1,[R3, #+140]
   1602                entropy->count_ptrs[i] = NULL;
   \   00000044   9C1083E5           STR      R1,[R3, #+156]
   1603              }
   \   00000048   012082E2           ADD      R2,R2,#+1
   \   0000004C   040052E3           CMP      R2,#+4
   \   00000050   F9FFFFBA           BLT      ??jinit_huff_encoder_2
   1604              entropy->bit_buffer = NULL;	/* needed only in AC refinement scan */
   \   00000054   881080E5           STR      R1,[R0, #+136]
   \   00000058   1080BDE8           POP      {R4,PC}
   1605            } else {
   1606              /* Mark tables unallocated */
   1607              for (i = 0; i < NUM_HUFF_TBLS; i++) {
   1608                entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
   \                     ??jinit_huff_encoder_1:
   \   0000005C   023180E0           ADD      R3,R0,R2, LSL #+2
   \   00000060   3C1083E5           STR      R1,[R3, #+60]
   \   00000064   0040A0E3           MOV      R4,#+0
   \   00000068   2C4083E5           STR      R4,[R3, #+44]
   1609                entropy->dc_count_ptrs[i] = entropy->ac_count_ptrs[i] = NULL;
   \   0000006C   5C1083E5           STR      R1,[R3, #+92]
   \   00000070   4C4083E5           STR      R4,[R3, #+76]
   1610              }
   \   00000074   012082E2           ADD      R2,R2,#+1
   \   00000078   040052E3           CMP      R2,#+4
   \   0000007C   F6FFFFBA           BLT      ??jinit_huff_encoder_1
   1611            }
   1612          }
   \   00000080   1080BDE8           POP      {R4,PC}          ;; return
   \                     ??jinit_huff_encoder_0:
   \   00000084   ........           DC32     start_pass_huff

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   ........           DC32     jpeg_natural_order

   Maximum stack usage in bytes:

     Function                CSTACK
     --------                ------
     dump_buffer_e              12
     dump_buffer_s              12
     emit_bits_e                20
     emit_bits_s                20
     emit_eobrun                20
     emit_restart_e             16
     emit_restart_s             16
     emit_symbol                 4
     encode_mcu_AC_first        44
     encode_mcu_AC_refine      304
     encode_mcu_DC_first        36
     encode_mcu_DC_refine       24
     encode_mcu_gather          28
     encode_mcu_huff            64
     encode_one_block           40
     finish_pass_gather         84
     finish_pass_huff           60
     htest_one_block            32
     jinit_huff_encoder          8
     jpeg_gen_optimal_table   2120
     jpeg_make_c_derived_tbl  1328
     start_pass_huff            40


   Segment part sizes:

     Function/Label          Bytes
     --------------          -----
     jpeg_make_c_derived_tbl  600
     dump_buffer_s             56
     dump_buffer_e             88
     emit_bits_s              252
     emit_bits_e              244
     emit_symbol               60
     emit_eobrun              192
     emit_restart_s           220
     emit_restart_e           228
     encode_mcu_DC_first      368
     encode_mcu_AC_first      484
     encode_mcu_DC_refine     228
     encode_mcu_AC_refine     688
     encode_one_block         428
     encode_mcu_huff          352
     finish_pass_huff         276
     htest_one_block          280
     encode_mcu_gather        232
     jpeg_gen_optimal_table   804
     finish_pass_gather       476
     start_pass_huff          836
     jinit_huff_encoder       136
     ??DataTable4               4
      Others                  100

 
 7 632 bytes in segment CODE
 
 7 532 bytes of CODE memory (+ 100 bytes shared)

Errors: none
Warnings: 1
