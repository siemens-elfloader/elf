##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    19/Jan/2011  13:20:47 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\grabber\jpeg-7\jcarith.c                      #
#    Command line    =  C:\arm\grabber\jpeg-7\jcarith.c -lC                  #
#                       C:\arm\grabber\Release_SGOLD\List\ -o                #
#                       C:\arm\grabber\Release_SGOLD\Obj\ -s9 --no_unroll    #
#                       --no_clustering --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --fpu None --dlib_config "C:\arm2\Embedded           #
#                       Workbench 4.0 Evaluation\ARM\LIB\dl5tpainl8n.h" -I   #
#                       "C:\arm2\Embedded Workbench 4.0                      #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  C:\arm\grabber\Release_SGOLD\List\jcarith.lst        #
#    Object file     =  C:\arm\grabber\Release_SGOLD\Obj\jcarith.r79         #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\grabber\jpeg-7\jcarith.c
      1          
      2          /*
      3           * jcarith.c
      4           *
      5           * Developed 1997 by Guido Vollbeding.
      6           * This file is part of the Independent JPEG Group's software.
      7           * For conditions of distribution and use, see the accompanying README file.
      8           *
      9           * This file contains portable arithmetic entropy encoding routines for JPEG
     10           * (implementing the ISO/IEC IS 10918-1 and CCITT Recommendation ITU-T T.81).
     11           *
     12           * Both sequential and progressive modes are supported in this single module.
     13           *
     14           * Suspension is not currently supported in this module.
     15           */
     16          
     17          #define JPEG_INTERNALS
     18          #include "jinclude.h"
     19          #include "jpeglib.h"
     20          
     21          
     22          /* Expanded entropy encoder object for arithmetic encoding. */
     23          
     24          typedef struct {
     25            struct jpeg_entropy_encoder pub; /* public fields */
     26          
     27            INT32 c; /* C register, base of coding interval, layout as in sec. D.1.3 */
     28            INT32 a;               /* A register, normalized size of coding interval */
     29            INT32 sc;        /* counter for stacked 0xFF values which might overflow */
     30            INT32 zc;          /* counter for pending 0x00 output values which might *
     31                                    * be discarded at the end ("Pacman" termination) */
     32            int ct;  /* bit shift counter, determines when next byte will be written */
     33            int buffer;                /* buffer for most recent output byte != 0xFF */
     34          
     35            int last_dc_val[MAX_COMPS_IN_SCAN]; /* last DC coef for each component */
     36            int dc_context[MAX_COMPS_IN_SCAN]; /* context index for DC conditioning */
     37          
     38            unsigned int restarts_to_go;	/* MCUs left in this restart interval */
     39            int next_restart_num;		/* next restart number to write (0-7) */
     40          
     41            /* Pointers to statistics areas (these workspaces have image lifespan) */
     42            unsigned char * dc_stats[NUM_ARITH_TBLS];
     43            unsigned char * ac_stats[NUM_ARITH_TBLS];
     44          } arith_entropy_encoder;
     45          
     46          typedef arith_entropy_encoder * arith_entropy_ptr;
     47          
     48          /* The following two definitions specify the allocation chunk size
     49           * for the statistics area.
     50           * According to sections F.1.4.4.1.3 and F.1.4.4.2, we need at least
     51           * 49 statistics bins for DC, and 245 statistics bins for AC coding.
     52           * Note that we use one additional AC bin for codings with fixed
     53           * probability (0.5), thus the minimum number for AC is 246.
     54           *
     55           * We use a compact representation with 1 byte per statistics bin,
     56           * thus the numbers directly represent byte sizes.
     57           * This 1 byte per statistics bin contains the meaning of the MPS
     58           * (more probable symbol) in the highest bit (mask 0x80), and the
     59           * index into the probability estimation state machine table
     60           * in the lower bits (mask 0x7F).
     61           */
     62          
     63          #define DC_STAT_BINS 64
     64          #define AC_STAT_BINS 256
     65          
     66          /* NOTE: Uncomment the following #define if you want to use the
     67           * given formula for calculating the AC conditioning parameter Kx
     68           * for spectral selection progressive coding in section G.1.3.2
     69           * of the spec (Kx = Kmin + SRL (8 + Se - Kmin) 4).
     70           * Although the spec and P&M authors claim that this "has proven
     71           * to give good results for 8 bit precision samples", I'm not
     72           * convinced yet that this is really beneficial.
     73           * Early tests gave only very marginal compression enhancements
     74           * (a few - around 5 or so - bytes even for very large files),
     75           * which would turn out rather negative if we'd suppress the
     76           * DAC (Define Arithmetic Conditioning) marker segments for
     77           * the default parameters in the future.
     78           * Note that currently the marker writing module emits 12-byte
     79           * DAC segments for a full-component scan in a color image.
     80           * This is not worth worrying about IMHO. However, since the
     81           * spec defines the default values to be used if the tables
     82           * are omitted (unlike Huffman tables, which are required
     83           * anyway), one might optimize this behaviour in the future,
     84           * and then it would be disadvantageous to use custom tables if
     85           * they don't provide sufficient gain to exceed the DAC size.
     86           *
     87           * On the other hand, I'd consider it as a reasonable result
     88           * that the conditioning has no significant influence on the
     89           * compression performance. This means that the basic
     90           * statistical model is already rather stable.
     91           *
     92           * Thus, at the moment, we use the default conditioning values
     93           * anyway, and do not use the custom formula.
     94           *
     95          #define CALCULATE_SPECTRAL_CONDITIONING
     96           */
     97          
     98          /* IRIGHT_SHIFT is like RIGHT_SHIFT, but works on int rather than INT32.
     99           * We assume that int right shift is unsigned if INT32 right shift is,
    100           * which should be safe.
    101           */
    102          
    103          #ifdef RIGHT_SHIFT_IS_UNSIGNED
    104          #define ISHIFT_TEMPS	int ishift_temp;
    105          #define IRIGHT_SHIFT(x,shft)  \
    106          	((ishift_temp = (x)) < 0 ? \
    107          	 (ishift_temp >> (shft)) | ((~0) << (16-(shft))) : \
    108          	 (ishift_temp >> (shft)))
    109          #else
    110          #define ISHIFT_TEMPS
    111          #define IRIGHT_SHIFT(x,shft)	((x) >> (shft))
    112          #endif
    113          
    114          

   \                                 In segment CODE, align 4, keep-with-next
    115          LOCAL(void)
    116          emit_byte (int val, j_compress_ptr cinfo)
    117          /* Write next output byte; we do not support suspension in this module. */
    118          {
   \                     emit_byte:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0140A0E1           MOV      R4,R1
    119            struct jpeg_destination_mgr * dest = cinfo->dest;
   \   00000008   181094E5           LDR      R1,[R4, #+24]
    120          
    121            *dest->next_output_byte++ = (JOCTET) val;
   \   0000000C   002091E5           LDR      R2,[R1, #+0]
   \   00000010   013082E2           ADD      R3,R2,#+1
   \   00000014   003081E5           STR      R3,[R1, #+0]
   \   00000018   0000C2E5           STRB     R0,[R2, #+0]
    122            if (--dest->free_in_buffer == 0)
   \   0000001C   040091E5           LDR      R0,[R1, #+4]
   \   00000020   010050E2           SUBS     R0,R0,#+1
   \   00000024   040081E5           STR      R0,[R1, #+4]
   \   00000028   1080BD18           POPNE    {R4,PC}
    123              if (! (*dest->empty_output_buffer) (cinfo))
   \   0000002C   0C1091E5           LDR      R1,[R1, #+12]
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   31FF2FE1           BLX      R1
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   1080BD18           POPNE    {R4,PC}
    124                ERREXIT(cinfo, JERR_CANT_SUSPEND);
   \   00000040   000094E5           LDR      R0,[R4, #+0]
   \   00000044   1910A0E3           MOV      R1,#+25
   \   00000048   141080E5           STR      R1,[R0, #+20]
   \   0000004C   001094E5           LDR      R1,[R4, #+0]
   \   00000050   0400A0E1           MOV      R0,R4
   \   00000054   001091E5           LDR      R1,[R1, #+0]
   \   00000058   31FF2FE1           BLX      R1
    125          }
   \   0000005C   1080BDE8           POP      {R4,PC}          ;; return
    126          
    127          
    128          /*
    129           * Finish up at the end of an arithmetic-compressed scan.
    130           */
    131          

   \                                 In segment CODE, align 4, keep-with-next
    132          METHODDEF(void)
    133          finish_pass (j_compress_ptr cinfo)
    134          {
   \                     finish_pass:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    135            arith_entropy_ptr e = (arith_entropy_ptr) cinfo->entropy;
    136            INT32 temp;
    137          
    138            /* Section D.1.8: Termination of encoding */
    139          
    140            /* Find the e->c in the coding interval with the largest
    141             * number of trailing zero bits */
    142            if ((temp = (e->a - 1 + e->c) & 0xFFFF0000L) < e->c)
   \   00000004   FF24A0E3           MOV      R2,#-16777216
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   945194E5           LDR      R5,[R4, #+404]
   \   00000010   0C0095E5           LDR      R0,[R5, #+12]
   \   00000014   101095E5           LDR      R1,[R5, #+16]
   \   00000018   FF2882E3           ORR      R2,R2,#0xFF0000
   \   0000001C   011080E0           ADD      R1,R0,R1
   \   00000020   011041E2           SUB      R1,R1,#+1
   \   00000024   011002E0           AND      R1,R2,R1
   \   00000028   000051E1           CMP      R1,R0
    143              e->c = temp + 0x8000L;
   \   0000002C   801C81B2           ADDLT    R1,R1,#+32768
    144            else
    145              e->c = temp;
   \   00000030   0C1085E5           STR      R1,[R5, #+12]
    146            /* Send remaining bytes to output */
    147            e->c <<= e->ct;
   \   00000034   1C0095E5           LDR      R0,[R5, #+28]
   \   00000038   1100A0E1           LSL      R0,R1,R0
   \   0000003C   0C0085E5           STR      R0,[R5, #+12]
    148            if (e->c & 0xF8000000L) {
   \   00000040   F80410E3           TST      R0,#0xF8000000
   \   00000044   1E00000A           BEQ      ??finish_pass_0
    149              /* One final overflow has to be handled */
    150              if (e->buffer >= 0) {
   \   00000048   200095E5           LDR      R0,[R5, #+32]
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   1400004A           BMI      ??finish_pass_1
    151                if (e->zc)
   \   00000054   180095E5           LDR      R0,[R5, #+24]
   \   00000058   000050E3           CMP      R0,#+0
   \   0000005C   0600000A           BEQ      ??finish_pass_2
    152          	do emit_byte(0x00, cinfo);
   \                     ??finish_pass_3:
   \   00000060   0410A0E1           MOV      R1,R4
   \   00000064   0000A0E3           MOV      R0,#+0
   \   00000068   ........           BL       emit_byte
    153          	while (--e->zc);
   \   0000006C   180095E5           LDR      R0,[R5, #+24]
   \   00000070   010050E2           SUBS     R0,R0,#+1
   \   00000074   180085E5           STR      R0,[R5, #+24]
   \   00000078   F8FFFF1A           BNE      ??finish_pass_3
    154                emit_byte(e->buffer + 1, cinfo);
   \                     ??finish_pass_2:
   \   0000007C   200095E5           LDR      R0,[R5, #+32]
   \   00000080   0410A0E1           MOV      R1,R4
   \   00000084   010080E2           ADD      R0,R0,#+1
   \   00000088   ........           BL       emit_byte
    155                if (e->buffer + 1 == 0xFF)
   \   0000008C   200095E5           LDR      R0,[R5, #+32]
   \   00000090   010080E2           ADD      R0,R0,#+1
   \   00000094   FF0050E3           CMP      R0,#+255
   \   00000098   0200001A           BNE      ??finish_pass_1
    156          	emit_byte(0x00, cinfo);
   \   0000009C   0410A0E1           MOV      R1,R4
   \   000000A0   0000A0E3           MOV      R0,#+0
   \   000000A4   ........           BL       emit_byte
    157              }
    158              e->zc += e->sc;  /* carry-over converts stacked 0xFF bytes to 0x00 */
   \                     ??finish_pass_1:
   \   000000A8   180095E5           LDR      R0,[R5, #+24]
   \   000000AC   141095E5           LDR      R1,[R5, #+20]
   \   000000B0   000081E0           ADD      R0,R1,R0
   \   000000B4   180085E5           STR      R0,[R5, #+24]
    159              e->sc = 0;
   \   000000B8   0000A0E3           MOV      R0,#+0
   \   000000BC   140085E5           STR      R0,[R5, #+20]
   \   000000C0   290000EA           B        ??finish_pass_4
    160            } else {
    161              if (e->buffer == 0)
   \                     ??finish_pass_0:
   \   000000C4   180095E5           LDR      R0,[R5, #+24]
   \   000000C8   201095E5           LDR      R1,[R5, #+32]
   \   000000CC   000051E3           CMP      R1,#+0
    162                ++e->zc;
   \   000000D0   01008002           ADDEQ    R0,R0,#+1
   \   000000D4   18008505           STREQ    R0,[R5, #+24]
   \   000000D8   0C00000A           BEQ      ??finish_pass_5
    163              else if (e->buffer >= 0) {
   \   000000DC   0B00004A           BMI      ??finish_pass_5
    164                if (e->zc)
   \   000000E0   000050E3           CMP      R0,#+0
   \   000000E4   0600000A           BEQ      ??finish_pass_6
    165          	do emit_byte(0x00, cinfo);
   \                     ??finish_pass_7:
   \   000000E8   0410A0E1           MOV      R1,R4
   \   000000EC   0000A0E3           MOV      R0,#+0
   \   000000F0   ........           BL       emit_byte
    166          	while (--e->zc);
   \   000000F4   180095E5           LDR      R0,[R5, #+24]
   \   000000F8   010050E2           SUBS     R0,R0,#+1
   \   000000FC   180085E5           STR      R0,[R5, #+24]
   \   00000100   F8FFFF1A           BNE      ??finish_pass_7
    167                emit_byte(e->buffer, cinfo);
   \                     ??finish_pass_6:
   \   00000104   200095E5           LDR      R0,[R5, #+32]
   \   00000108   0410A0E1           MOV      R1,R4
   \   0000010C   ........           BL       emit_byte
    168              }
    169              if (e->sc) {
   \                     ??finish_pass_5:
   \   00000110   140095E5           LDR      R0,[R5, #+20]
   \   00000114   000050E3           CMP      R0,#+0
   \   00000118   1300000A           BEQ      ??finish_pass_4
    170                if (e->zc)
   \   0000011C   180095E5           LDR      R0,[R5, #+24]
   \   00000120   000050E3           CMP      R0,#+0
   \   00000124   0600000A           BEQ      ??finish_pass_8
    171          	do emit_byte(0x00, cinfo);
   \                     ??finish_pass_9:
   \   00000128   0410A0E1           MOV      R1,R4
   \   0000012C   0000A0E3           MOV      R0,#+0
   \   00000130   ........           BL       emit_byte
    172          	while (--e->zc);
   \   00000134   180095E5           LDR      R0,[R5, #+24]
   \   00000138   010050E2           SUBS     R0,R0,#+1
   \   0000013C   180085E5           STR      R0,[R5, #+24]
   \   00000140   F8FFFF1A           BNE      ??finish_pass_9
    173                do {
    174          	emit_byte(0xFF, cinfo);
   \                     ??finish_pass_8:
   \   00000144   0410A0E1           MOV      R1,R4
   \   00000148   FF00A0E3           MOV      R0,#+255
   \   0000014C   ........           BL       emit_byte
    175          	emit_byte(0x00, cinfo);
   \   00000150   0410A0E1           MOV      R1,R4
   \   00000154   0000A0E3           MOV      R0,#+0
   \   00000158   ........           BL       emit_byte
    176                } while (--e->sc);
   \   0000015C   140095E5           LDR      R0,[R5, #+20]
   \   00000160   010050E2           SUBS     R0,R0,#+1
   \   00000164   140085E5           STR      R0,[R5, #+20]
   \   00000168   F5FFFF1A           BNE      ??finish_pass_8
    177              }
    178            }
    179            /* Output final bytes only if they are not 0x00 */
    180            if (e->c & 0x7FFF800L) {
   \                     ??finish_pass_4:
   \   0000016C   0C0095E5           LDR      R0,[R5, #+12]
   \   00000170   A8109FE5           LDR      R1,??finish_pass_10  ;; 0x7fff800
   \   00000174   000011E1           TST      R1,R0
   \   00000178   3080BD08           POPEQ    {R4,R5,PC}
    181              if (e->zc)  /* output final pending zero bytes */
   \   0000017C   180095E5           LDR      R0,[R5, #+24]
   \   00000180   000050E3           CMP      R0,#+0
   \   00000184   0600000A           BEQ      ??finish_pass_11
    182                do emit_byte(0x00, cinfo);
   \                     ??finish_pass_12:
   \   00000188   0410A0E1           MOV      R1,R4
   \   0000018C   0000A0E3           MOV      R0,#+0
   \   00000190   ........           BL       emit_byte
    183                while (--e->zc);
   \   00000194   180095E5           LDR      R0,[R5, #+24]
   \   00000198   010050E2           SUBS     R0,R0,#+1
   \   0000019C   180085E5           STR      R0,[R5, #+24]
   \   000001A0   F8FFFF1A           BNE      ??finish_pass_12
    184              emit_byte((e->c >> 19) & 0xFF, cinfo);
   \                     ??finish_pass_11:
   \   000001A4   0C0095E5           LDR      R0,[R5, #+12]
   \   000001A8   0410A0E1           MOV      R1,R4
   \   000001AC   FF20A0E3           MOV      R2,#+255
   \   000001B0   C00902E0           AND      R0,R2,R0, ASR #+19
   \   000001B4   ........           BL       emit_byte
    185              if (((e->c >> 19) & 0xFF) == 0xFF)
   \   000001B8   0C0095E5           LDR      R0,[R5, #+12]
   \   000001BC   FF10A0E3           MOV      R1,#+255
   \   000001C0   C00901E0           AND      R0,R1,R0, ASR #+19
   \   000001C4   FF0050E3           CMP      R0,#+255
   \   000001C8   0200001A           BNE      ??finish_pass_13
    186                emit_byte(0x00, cinfo);
   \   000001CC   0410A0E1           MOV      R1,R4
   \   000001D0   0000A0E3           MOV      R0,#+0
   \   000001D4   ........           BL       emit_byte
    187              if (e->c & 0x7F800L) {
   \                     ??finish_pass_13:
   \   000001D8   0C0095E5           LDR      R0,[R5, #+12]
   \   000001DC   401AA0E3           MOV      R1,#+262144
   \   000001E0   FE1B81E3           ORR      R1,R1,#0x3F800
   \   000001E4   000011E1           TST      R1,R0
   \   000001E8   3080BD08           POPEQ    {R4,R5,PC}
    188                emit_byte((e->c >> 11) & 0xFF, cinfo);
   \   000001EC   0410A0E1           MOV      R1,R4
   \   000001F0   FF20A0E3           MOV      R2,#+255
   \   000001F4   C00502E0           AND      R0,R2,R0, ASR #+11
   \   000001F8   ........           BL       emit_byte
    189                if (((e->c >> 11) & 0xFF) == 0xFF)
   \   000001FC   0C0095E5           LDR      R0,[R5, #+12]
   \   00000200   FF10A0E3           MOV      R1,#+255
   \   00000204   C00501E0           AND      R0,R1,R0, ASR #+11
   \   00000208   FF0050E3           CMP      R0,#+255
   \   0000020C   3080BD18           POPNE    {R4,R5,PC}
    190          	emit_byte(0x00, cinfo);
   \   00000210   0410A0E1           MOV      R1,R4
   \   00000214   0000A0E3           MOV      R0,#+0
   \   00000218   ........           BL       emit_byte
    191              }
    192            }
    193          }
   \   0000021C   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??finish_pass_10:
   \   00000220   00F8FF07           DC32     0x7fff800
    194          
    195          
    196          /*
    197           * The core arithmetic encoding routine (common in JPEG and JBIG).
    198           * This needs to go as fast as possible.
    199           * Machine-dependent optimization facilities
    200           * are not utilized in this portable implementation.
    201           * However, this code should be fairly efficient and
    202           * may be a good base for further optimizations anyway.
    203           *
    204           * Parameter 'val' to be encoded may be 0 or 1 (binary decision).
    205           *
    206           * Note: I've added full "Pacman" termination support to the
    207           * byte output routines, which is equivalent to the optional
    208           * Discard_final_zeros procedure (Figure D.15) in the spec.
    209           * Thus, we always produce the shortest possible output
    210           * stream compliant to the spec (no trailing zero bytes,
    211           * except for FF stuffing).
    212           *
    213           * I've also introduced a new scheme for accessing
    214           * the probability estimation state machine table,
    215           * derived from Markus Kuhn's JBIG implementation.
    216           */
    217          

   \                                 In segment CODE, align 4, keep-with-next
    218          LOCAL(void)
    219          arith_encode (j_compress_ptr cinfo, unsigned char *st, int val) 
    220          {
   \                     arith_encode:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
    221            extern const INT32 jaritab[];
    222            register arith_entropy_ptr e = (arith_entropy_ptr) cinfo->entropy;
    223            register unsigned char nl, nm;
    224            register INT32 qe, temp;
    225            register int sv;
    226          
    227            /* Fetch values from our compact representation of Table D.2:
    228             * Qe values and probability estimation state machine
    229             */
    230            sv = *st;
    231            qe = jaritab[sv & 0x7F];	/* => Qe_Value */
   \   00000004   20629FE5           LDR      R6,??arith_encode_0  ;; jaritab
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0000D1E5           LDRB     R0,[R1, #+0]
   \   00000010   945194E5           LDR      R5,[R4, #+404]
   \   00000014   7F3000E2           AND      R3,R0,#0x7F
   \   00000018   036196E7           LDR      R6,[R6, +R3, LSL #+2]
    232            nl = qe & 0xFF; qe >>= 8;	/* Next_Index_LPS + Switch_MPS */
    233            nm = qe & 0xFF; qe >>= 8;	/* Next_Index_MPS */
    234          
    235            /* Encode & estimation procedures per sections D.1.4 & D.1.5 */
    236            e->a -= qe;
   \   0000001C   10E095E5           LDR      LR,[R5, #+16]
   \   00000020   FF3006E2           AND      R3,R6,#0xFF
   \   00000024   4664A0E1           ASR      R6,R6,#+8
   \   00000028   FFC006E2           AND      R12,R6,#0xFF
   \   0000002C   4664A0E1           ASR      R6,R6,#+8
   \   00000030   06E04EE0           SUB      LR,LR,R6
   \   00000034   10E085E5           STR      LR,[R5, #+16]
    237            if (val != (sv >> 7)) {
   \   00000038   C00352E1           CMP      R2,R0, ASR #+7
   \   0000003C   0800000A           BEQ      ??arith_encode_1
    238              /* Encode the less probable symbol */
    239              if (e->a >= qe) {
   \   00000040   06005EE1           CMP      LR,R6
   \   00000044   030000BA           BLT      ??arith_encode_2
    240                /* If the interval size (qe) for the less probable symbol (LPS)
    241                 * is larger than the interval size for the MPS, then exchange
    242                 * the two symbols for coding efficiency, otherwise code the LPS
    243                 * as usual: */
    244                e->c += e->a;
   \   00000048   0C2095E5           LDR      R2,[R5, #+12]
   \   0000004C   02208EE0           ADD      R2,LR,R2
   \   00000050   0C2085E5           STR      R2,[R5, #+12]
    245                e->a = qe;
   \   00000054   106085E5           STR      R6,[R5, #+16]
    246              }
    247              *st = (sv & 0x80) ^ nl;	/* Estimate_after_LPS */
   \                     ??arith_encode_2:
   \   00000058   800000E2           AND      R0,R0,#0x80
   \   0000005C   000023E0           EOR      R0,R3,R0
   \   00000060   090000EA           B        ??arith_encode_3
    248            } else {
    249              /* Encode the more probable symbol */
    250              if (e->a >= 0x8000L)
   \                     ??arith_encode_1:
   \   00000064   800C5EE3           CMP      LR,#+32768
   \   00000068   7080BDA8           POPGE    {R4-R6,PC}
    251                return;  /* A >= 0x8000 -> ready, no renormalization required */
    252              if (e->a < qe) {
   \   0000006C   06005EE1           CMP      LR,R6
   \   00000070   030000AA           BGE      ??arith_encode_4
    253                /* If the interval size (qe) for the less probable symbol (LPS)
    254                 * is larger than the interval size for the MPS, then exchange
    255                 * the two symbols for coding efficiency: */
    256                e->c += e->a;
   \   00000074   0C2095E5           LDR      R2,[R5, #+12]
   \   00000078   02208EE0           ADD      R2,LR,R2
   \   0000007C   0C2085E5           STR      R2,[R5, #+12]
    257                e->a = qe;
   \   00000080   106085E5           STR      R6,[R5, #+16]
    258              }
    259              *st = (sv & 0x80) ^ nm;	/* Estimate_after_MPS */
   \                     ??arith_encode_4:
   \   00000084   800000E2           AND      R0,R0,#0x80
   \   00000088   00002CE0           EOR      R0,R12,R0
   \                     ??arith_encode_3:
   \   0000008C   0000C1E5           STRB     R0,[R1, #+0]
    260            }
    261          
    262            /* Renormalization & data output per section D.1.6 */
    263            do {
    264              e->a <<= 1;
   \                     ??arith_encode_5:
   \   00000090   100095E5           LDR      R0,[R5, #+16]
   \   00000094   8000A0E1           LSL      R0,R0,#+1
   \   00000098   100085E5           STR      R0,[R5, #+16]
    265              e->c <<= 1;
   \   0000009C   0C0095E5           LDR      R0,[R5, #+12]
   \   000000A0   8000A0E1           LSL      R0,R0,#+1
   \   000000A4   0C0085E5           STR      R0,[R5, #+12]
    266              if (--e->ct == 0) {
   \   000000A8   1C1095E5           LDR      R1,[R5, #+28]
   \   000000AC   011051E2           SUBS     R1,R1,#+1
   \   000000B0   1C1085E5           STR      R1,[R5, #+28]
   \   000000B4   5800001A           BNE      ??arith_encode_6
    267                /* Another byte is ready for output */
    268                temp = e->c >> 19;
    269                if (temp > 0xFF) {
   \   000000B8   201095E5           LDR      R1,[R5, #+32]
   \   000000BC   C069A0E1           ASR      R6,R0,#+19
   \   000000C0   180095E5           LDR      R0,[R5, #+24]
   \   000000C4   400F56E3           CMP      R6,#+256
   \   000000C8   1C0000BA           BLT      ??arith_encode_7
    270          	/* Handle overflow over all stacked 0xFF bytes */
    271          	if (e->buffer >= 0) {
   \   000000CC   000051E3           CMP      R1,#+0
   \   000000D0   1300004A           BMI      ??arith_encode_8
    272          	  if (e->zc)
   \   000000D4   000050E3           CMP      R0,#+0
   \   000000D8   0600000A           BEQ      ??arith_encode_9
    273          	    do emit_byte(0x00, cinfo);
   \                     ??arith_encode_10:
   \   000000DC   0410A0E1           MOV      R1,R4
   \   000000E0   0000A0E3           MOV      R0,#+0
   \   000000E4   ........           BL       emit_byte
    274          	    while (--e->zc);
   \   000000E8   180095E5           LDR      R0,[R5, #+24]
   \   000000EC   010050E2           SUBS     R0,R0,#+1
   \   000000F0   180085E5           STR      R0,[R5, #+24]
   \   000000F4   F8FFFF1A           BNE      ??arith_encode_10
    275          	  emit_byte(e->buffer + 1, cinfo);
   \                     ??arith_encode_9:
   \   000000F8   200095E5           LDR      R0,[R5, #+32]
   \   000000FC   0410A0E1           MOV      R1,R4
   \   00000100   010080E2           ADD      R0,R0,#+1
   \   00000104   ........           BL       emit_byte
    276          	  if (e->buffer + 1 == 0xFF)
   \   00000108   200095E5           LDR      R0,[R5, #+32]
   \   0000010C   010080E2           ADD      R0,R0,#+1
   \   00000110   FF0050E3           CMP      R0,#+255
   \   00000114   0200001A           BNE      ??arith_encode_8
    277          	    emit_byte(0x00, cinfo);
   \   00000118   0410A0E1           MOV      R1,R4
   \   0000011C   0000A0E3           MOV      R0,#+0
   \   00000120   ........           BL       emit_byte
    278          	}
    279          	e->zc += e->sc;  /* carry-over converts stacked 0xFF bytes to 0x00 */
   \                     ??arith_encode_8:
   \   00000124   180095E5           LDR      R0,[R5, #+24]
   \   00000128   141095E5           LDR      R1,[R5, #+20]
   \   0000012C   000081E0           ADD      R0,R1,R0
   \   00000130   180085E5           STR      R0,[R5, #+24]
    280          	e->sc = 0;
   \   00000134   0000A0E3           MOV      R0,#+0
   \   00000138   140085E5           STR      R0,[R5, #+20]
    281          	/* Note: The 3 spacer bits in the C register guarantee
    282          	 * that the new buffer byte can't be 0xFF here
    283          	 * (see page 160 in the P&M JPEG book). */
    284          	e->buffer = temp & 0xFF;  /* new output byte, might overflow later */
   \   0000013C   2D0000EA           B        ??arith_encode_11
    285                } else if (temp == 0xFF) {
   \                     ??arith_encode_7:
   \   00000140   FF0056E3           CMP      R6,#+255
   \   00000144   0300001A           BNE      ??arith_encode_12
    286          	++e->sc;  /* stack 0xFF byte (which might overflow later) */
   \   00000148   140095E5           LDR      R0,[R5, #+20]
   \   0000014C   010080E2           ADD      R0,R0,#+1
   \   00000150   140085E5           STR      R0,[R5, #+20]
   \   00000154   290000EA           B        ??arith_encode_13
    287                } else {
    288          	/* Output all stacked 0xFF bytes, they will not overflow any more */
    289          	if (e->buffer == 0)
   \                     ??arith_encode_12:
   \   00000158   000051E3           CMP      R1,#+0
    290          	  ++e->zc;
   \   0000015C   01008002           ADDEQ    R0,R0,#+1
   \   00000160   18008505           STREQ    R0,[R5, #+24]
   \   00000164   0C00000A           BEQ      ??arith_encode_14
    291          	else if (e->buffer >= 0) {
   \   00000168   0B00004A           BMI      ??arith_encode_14
    292          	  if (e->zc)
   \   0000016C   000050E3           CMP      R0,#+0
   \   00000170   0600000A           BEQ      ??arith_encode_15
    293          	    do emit_byte(0x00, cinfo);
   \                     ??arith_encode_16:
   \   00000174   0410A0E1           MOV      R1,R4
   \   00000178   0000A0E3           MOV      R0,#+0
   \   0000017C   ........           BL       emit_byte
    294          	    while (--e->zc);
   \   00000180   180095E5           LDR      R0,[R5, #+24]
   \   00000184   010050E2           SUBS     R0,R0,#+1
   \   00000188   180085E5           STR      R0,[R5, #+24]
   \   0000018C   F8FFFF1A           BNE      ??arith_encode_16
    295          	  emit_byte(e->buffer, cinfo);
   \                     ??arith_encode_15:
   \   00000190   200095E5           LDR      R0,[R5, #+32]
   \   00000194   0410A0E1           MOV      R1,R4
   \   00000198   ........           BL       emit_byte
    296          	}
    297          	if (e->sc) {
   \                     ??arith_encode_14:
   \   0000019C   140095E5           LDR      R0,[R5, #+20]
   \   000001A0   000050E3           CMP      R0,#+0
   \   000001A4   1300000A           BEQ      ??arith_encode_11
    298          	  if (e->zc)
   \   000001A8   180095E5           LDR      R0,[R5, #+24]
   \   000001AC   000050E3           CMP      R0,#+0
   \   000001B0   0600000A           BEQ      ??arith_encode_17
    299          	    do emit_byte(0x00, cinfo);
   \                     ??arith_encode_18:
   \   000001B4   0410A0E1           MOV      R1,R4
   \   000001B8   0000A0E3           MOV      R0,#+0
   \   000001BC   ........           BL       emit_byte
    300          	    while (--e->zc);
   \   000001C0   180095E5           LDR      R0,[R5, #+24]
   \   000001C4   010050E2           SUBS     R0,R0,#+1
   \   000001C8   180085E5           STR      R0,[R5, #+24]
   \   000001CC   F8FFFF1A           BNE      ??arith_encode_18
    301          	  do {
    302          	    emit_byte(0xFF, cinfo);
   \                     ??arith_encode_17:
   \   000001D0   0410A0E1           MOV      R1,R4
   \   000001D4   FF00A0E3           MOV      R0,#+255
   \   000001D8   ........           BL       emit_byte
    303          	    emit_byte(0x00, cinfo);
   \   000001DC   0410A0E1           MOV      R1,R4
   \   000001E0   0000A0E3           MOV      R0,#+0
   \   000001E4   ........           BL       emit_byte
    304          	  } while (--e->sc);
   \   000001E8   140095E5           LDR      R0,[R5, #+20]
   \   000001EC   010050E2           SUBS     R0,R0,#+1
   \   000001F0   140085E5           STR      R0,[R5, #+20]
   \   000001F4   F5FFFF1A           BNE      ??arith_encode_17
    305          	}
    306          	e->buffer = temp & 0xFF;  /* new output byte (can still overflow) */
   \                     ??arith_encode_11:
   \   000001F8   FF0006E2           AND      R0,R6,#0xFF
   \   000001FC   200085E5           STR      R0,[R5, #+32]
    307                }
    308                e->c &= 0x7FFFFL;
   \                     ??arith_encode_13:
   \   00000200   0C0095E5           LDR      R0,[R5, #+12]
   \   00000204   8006A0E1           LSL      R0,R0,#+13
   \   00000208   A006A0E1           LSR      R0,R0,#+13
   \   0000020C   0C0085E5           STR      R0,[R5, #+12]
    309                e->ct += 8;
   \   00000210   1C0095E5           LDR      R0,[R5, #+28]
   \   00000214   080080E2           ADD      R0,R0,#+8
   \   00000218   1C0085E5           STR      R0,[R5, #+28]
    310              }
    311            } while (e->a < 0x8000L);
   \                     ??arith_encode_6:
   \   0000021C   100095E5           LDR      R0,[R5, #+16]
   \   00000220   800C50E3           CMP      R0,#+32768
   \   00000224   99FFFFBA           BLT      ??arith_encode_5
   \   00000228   7080BDE8           POP      {R4-R6,PC}       ;; return
   \                     ??arith_encode_0:
   \   0000022C   ........           DC32     jaritab
    312          }
    313          
    314          
    315          /*
    316           * Emit a restart marker & resynchronize predictions.
    317           */
    318          

   \                                 In segment CODE, align 4, keep-with-next
    319          LOCAL(void)
    320          emit_restart (j_compress_ptr cinfo, int restart_num)
    321          {
   \                     emit_restart:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0050A0E1           MOV      R5,R0
    322            arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
   \   00000008   944195E5           LDR      R4,[R5, #+404]
   \   0000000C   0160A0E1           MOV      R6,R1
    323            int ci;
    324            jpeg_component_info * compptr;
    325          
    326            finish_pass(cinfo);
   \   00000010   ........           BL       finish_pass
    327          
    328            emit_byte(0xFF, cinfo);
   \   00000014   0510A0E1           MOV      R1,R5
   \   00000018   FF00A0E3           MOV      R0,#+255
   \   0000001C   ........           BL       emit_byte
    329            emit_byte(JPEG_RST0 + restart_num, cinfo);
   \   00000020   0510A0E1           MOV      R1,R5
   \   00000024   D00086E2           ADD      R0,R6,#+208
   \   00000028   ........           BL       emit_byte
    330          
    331            for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
   \   0000002C   1C0195E5           LDR      R0,[R5, #+284]
   \   00000030   0070A0E3           MOV      R7,#+0
   \   00000034   0060A0E3           MOV      R6,#+0
   \   00000038   010050E3           CMP      R0,#+1
   \   0000003C   200000AA           BGE      ??emit_restart_0
   \   00000040   220000EA           B        ??emit_restart_1
    332              compptr = cinfo->cur_comp_info[ci];
   \                     ??emit_restart_2:
   \   00000044   070185E0           ADD      R0,R5,R7, LSL #+2
   \   00000048   208190E5           LDR      R8,[R0, #+288]
    333              /* Re-initialize statistics areas */
    334              if (cinfo->progressive_mode == 0 || (cinfo->Ss == 0 && cinfo->Ah == 0)) {
   \   0000004C   040195E5           LDR      R0,[R5, #+260]
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   0400000A           BEQ      ??emit_restart_3
   \   00000058   640195E5           LDR      R0,[R5, #+356]
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   6C019505           LDREQ    R0,[R5, #+364]
   \   00000064   00005003           CMPEQ    R0,#+0
   \   00000068   0800001A           BNE      ??emit_restart_4
    335                MEMZERO(entropy->dc_stats[compptr->dc_tbl_no], DC_STAT_BINS);
   \                     ??emit_restart_3:
   \   0000006C   140098E5           LDR      R0,[R8, #+20]
   \   00000070   4020A0E3           MOV      R2,#+64
   \   00000074   000184E0           ADD      R0,R4,R0, LSL #+2
   \   00000078   4C0090E5           LDR      R0,[R0, #+76]
   \   0000007C   0010A0E3           MOV      R1,#+0
   \   00000080   BB0000EF           SWI      +187
    336                /* Reset DC predictions to 0 */
    337                entropy->last_dc_val[ci] = 0;
   \   00000084   070184E0           ADD      R0,R4,R7, LSL #+2
   \   00000088   246080E5           STR      R6,[R0, #+36]
    338                entropy->dc_context[ci] = 0;
   \   0000008C   346080E5           STR      R6,[R0, #+52]
    339              }
    340              if (cinfo->progressive_mode == 0 || cinfo->Ss) {
   \                     ??emit_restart_4:
   \   00000090   040195E5           LDR      R0,[R5, #+260]
   \   00000094   000050E3           CMP      R0,#+0
   \   00000098   0200000A           BEQ      ??emit_restart_5
   \   0000009C   640195E5           LDR      R0,[R5, #+356]
   \   000000A0   000050E3           CMP      R0,#+0
   \   000000A4   0500000A           BEQ      ??emit_restart_6
    341                MEMZERO(entropy->ac_stats[compptr->ac_tbl_no], AC_STAT_BINS);
   \                     ??emit_restart_5:
   \   000000A8   180098E5           LDR      R0,[R8, #+24]
   \   000000AC   402FA0E3           MOV      R2,#+256
   \   000000B0   0010A0E3           MOV      R1,#+0
   \   000000B4   000184E0           ADD      R0,R4,R0, LSL #+2
   \   000000B8   8C0090E5           LDR      R0,[R0, #+140]
   \   000000BC   BB0000EF           SWI      +187
    342              }
    343            }
   \                     ??emit_restart_6:
   \   000000C0   017087E2           ADD      R7,R7,#+1
   \                     ??emit_restart_0:
   \   000000C4   1C0195E5           LDR      R0,[R5, #+284]
   \   000000C8   000057E1           CMP      R7,R0
   \   000000CC   DCFFFFBA           BLT      ??emit_restart_2
    344          
    345            /* Reset arithmetic encoding variables */
    346            entropy->c = 0;
   \                     ??emit_restart_1:
   \   000000D0   0C6084E5           STR      R6,[R4, #+12]
    347            entropy->a = 0x10000L;
   \   000000D4   400BA0E3           MOV      R0,#+65536
   \   000000D8   100084E5           STR      R0,[R4, #+16]
    348            entropy->sc = 0;
   \   000000DC   146084E5           STR      R6,[R4, #+20]
    349            entropy->zc = 0;
   \   000000E0   186084E5           STR      R6,[R4, #+24]
    350            entropy->ct = 11;
   \   000000E4   0B00A0E3           MOV      R0,#+11
   \   000000E8   1C0084E5           STR      R0,[R4, #+28]
    351            entropy->buffer = -1;  /* empty */
   \   000000EC   0600E0E1           MVN      R0,R6
   \   000000F0   200084E5           STR      R0,[R4, #+32]
    352          }
   \   000000F4   F081BDE8           POP      {R4-R8,PC}       ;; return
    353          
    354          
    355          /*
    356           * MCU encoding for DC initial scan (either spectral selection,
    357           * or first pass of successive approximation).
    358           */
    359          

   \                                 In segment CODE, align 4, keep-with-next
    360          METHODDEF(boolean)
    361          encode_mcu_DC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
    362          {
   \                     encode_mcu_DC_first:
   \   00000000   F24F2DE9           PUSH     {R1,R4-R11,LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
   \   00000008   0040A0E1           MOV      R4,R0
    363            arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
    364            JBLOCKROW block;
    365            unsigned char *st;
    366            int blkn, ci, tbl;
    367            int v, v2, m;
    368            ISHIFT_TEMPS
    369          
    370            /* Emit restart marker if needed */
    371            if (cinfo->restart_interval) {
   \   0000000C   E80094E5           LDR      R0,[R4, #+232]
   \   00000010   945194E5           LDR      R5,[R4, #+404]
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0F00000A           BEQ      ??encode_mcu_DC_first_0
    372              if (entropy->restarts_to_go == 0) {
   \   0000001C   440095E5           LDR      R0,[R5, #+68]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0900001A           BNE      ??encode_mcu_DC_first_1
    373                emit_restart(cinfo, entropy->next_restart_num);
   \   00000028   481095E5           LDR      R1,[R5, #+72]
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           BL       emit_restart
    374                entropy->restarts_to_go = cinfo->restart_interval;
   \   00000034   E80094E5           LDR      R0,[R4, #+232]
   \   00000038   440085E5           STR      R0,[R5, #+68]
    375                entropy->next_restart_num++;
   \   0000003C   480095E5           LDR      R0,[R5, #+72]
   \   00000040   010080E2           ADD      R0,R0,#+1
   \   00000044   480085E5           STR      R0,[R5, #+72]
    376                entropy->next_restart_num &= 7;
   \   00000048   070000E2           AND      R0,R0,#0x7
   \   0000004C   480085E5           STR      R0,[R5, #+72]
    377              }
    378              entropy->restarts_to_go--;
   \                     ??encode_mcu_DC_first_1:
   \   00000050   440095E5           LDR      R0,[R5, #+68]
   \   00000054   010040E2           SUB      R0,R0,#+1
   \   00000058   440085E5           STR      R0,[R5, #+68]
    379            }
    380          
    381            /* Encode the MCU data blocks */
    382            for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
   \                     ??encode_mcu_DC_first_0:
   \   0000005C   380194E5           LDR      R0,[R4, #+312]
   \   00000060   0060A0E3           MOV      R6,#+0
   \   00000064   010050E3           CMP      R0,#+1
   \   00000068   080000AA           BGE      ??encode_mcu_DC_first_2
    383              block = MCU_data[blkn];
    384              ci = cinfo->MCU_membership[blkn];
    385              tbl = cinfo->cur_comp_info[ci]->dc_tbl_no;
    386          
    387              /* Compute the DC value after the required point transform by Al.
    388               * This is simply an arithmetic right shift.
    389               */
    390              m = IRIGHT_SHIFT((int) ((*block)[0]), cinfo->Al);
    391          
    392              /* Sections F.1.4.1 & F.1.4.4.1: Encoding of DC coefficients */
    393          
    394              /* Table F.4: Point to statistics bin S0 for DC coefficient coding */
    395              st = entropy->dc_stats[tbl] + entropy->dc_context[ci];
    396          
    397              /* Figure F.4: Encode_DC_DIFF */
    398              if ((v = m - entropy->last_dc_val[ci]) == 0) {
    399                arith_encode(cinfo, st, 0);
    400                entropy->dc_context[ci] = 0;	/* zero diff category */
    401              } else {
    402                entropy->last_dc_val[ci] = m;
    403                arith_encode(cinfo, st, 1);
    404                /* Figure F.6: Encoding nonzero value v */
    405                /* Figure F.7: Encoding the sign of v */
    406                if (v > 0) {
    407          	arith_encode(cinfo, st + 1, 0);	/* Table F.4: SS = S0 + 1 */
    408          	st += 2;			/* Table F.4: SP = S0 + 2 */
    409          	entropy->dc_context[ci] = 4;	/* small positive diff category */
    410                } else {
    411          	v = -v;
    412          	arith_encode(cinfo, st + 1, 1);	/* Table F.4: SS = S0 + 1 */
    413          	st += 3;			/* Table F.4: SN = S0 + 3 */
    414          	entropy->dc_context[ci] = 8;	/* small negative diff category */
    415                }
    416                /* Figure F.8: Encoding the magnitude category of v */
    417                m = 0;
    418                if (v -= 1) {
    419          	arith_encode(cinfo, st, 1);
    420          	m = 1;
    421          	v2 = v;
    422          	st = entropy->dc_stats[tbl] + 20; /* Table F.4: X1 = 20 */
    423          	while (v2 >>= 1) {
    424          	  arith_encode(cinfo, st, 1);
    425          	  m <<= 1;
    426          	  st += 1;
    427          	}
    428                }
    429                arith_encode(cinfo, st, 0);
    430                /* Section F.1.4.4.1.2: Establish dc_context conditioning category */
    431                if (m < (int) (((INT32) 1 << cinfo->arith_dc_L[tbl]) >> 1))
    432          	entropy->dc_context[ci] = 0;	/* zero diff category */
    433                else if (m > (int) (((INT32) 1 << cinfo->arith_dc_U[tbl]) >> 1))
    434          	entropy->dc_context[ci] += 8;	/* large diff category */
    435                /* Figure F.9: Encoding the magnitude bit pattern of v */
    436                st += 14;
    437                while (m >>= 1)
    438          	arith_encode(cinfo, st, (m & v) ? 1 : 0);
    439              }
    440            }
    441          
    442            return TRUE;
   \                     ??encode_mcu_DC_first_3:
   \   0000006C   0100A0E3           MOV      R0,#+1
   \   00000070   FE8FBDE8           POP      {R1-R11,PC}      ;; return
   \                     ??encode_mcu_DC_first_4:
   \   00000074   0020A0E3           MOV      R2,#+0
   \   00000078   0A10A0E1           MOV      R1,R10
   \   0000007C   0400A0E1           MOV      R0,R4
   \   00000080   ........           BL       arith_encode
   \   00000084   0000A0E3           MOV      R0,#+0
   \   00000088   340087E5           STR      R0,[R7, #+52]
   \                     ??encode_mcu_DC_first_5:
   \   0000008C   016086E2           ADD      R6,R6,#+1
   \                     ??encode_mcu_DC_first_2:
   \   00000090   380194E5           LDR      R0,[R4, #+312]
   \   00000094   000056E1           CMP      R6,R0
   \   00000098   F3FFFFAA           BGE      ??encode_mcu_DC_first_3
   \   0000009C   060184E0           ADD      R0,R4,R6, LSL #+2
   \   000000A0   3C0190E5           LDR      R0,[R0, #+316]
   \   000000A4   002184E0           ADD      R2,R4,R0, LSL #+2
   \   000000A8   202192E5           LDR      R2,[R2, #+288]
   \   000000AC   007185E0           ADD      R7,R5,R0, LSL #+2
   \   000000B0   142092E5           LDR      R2,[R2, #+20]
   \   000000B4   00208DE5           STR      R2,[SP, #+0]
   \   000000B8   08109DE5           LDR      R1,[SP, #+8]
   \   000000BC   702194E5           LDR      R2,[R4, #+368]
   \   000000C0   061191E7           LDR      R1,[R1, +R6, LSL #+2]
   \   000000C4   F010D1E1           LDRSH    R1,[R1, #+0]
   \   000000C8   5192A0E1           ASR      R9,R1,R2
   \   000000CC   00109DE5           LDR      R1,[SP, #+0]
   \   000000D0   011185E0           ADD      R1,R5,R1, LSL #+2
   \   000000D4   04108DE5           STR      R1,[SP, #+4]
   \   000000D8   340097E5           LDR      R0,[R7, #+52]
   \   000000DC   4C1091E5           LDR      R1,[R1, #+76]
   \   000000E0   01A080E0           ADD      R10,R0,R1
   \   000000E4   240097E5           LDR      R0,[R7, #+36]
   \   000000E8   008059E0           SUBS     R8,R9,R0
   \   000000EC   E0FFFF0A           BEQ      ??encode_mcu_DC_first_4
   \   000000F0   249087E5           STR      R9,[R7, #+36]
   \   000000F4   0120A0E3           MOV      R2,#+1
   \   000000F8   0A10A0E1           MOV      R1,R10
   \   000000FC   0400A0E1           MOV      R0,R4
   \   00000100   ........           BL       arith_encode
   \   00000104   010058E3           CMP      R8,#+1
   \   00000108   060000BA           BLT      ??encode_mcu_DC_first_6
   \   0000010C   0020A0E3           MOV      R2,#+0
   \   00000110   01108AE2           ADD      R1,R10,#+1
   \   00000114   0400A0E1           MOV      R0,R4
   \   00000118   ........           BL       arith_encode
   \   0000011C   02A08AE2           ADD      R10,R10,#+2
   \   00000120   0400A0E3           MOV      R0,#+4
   \   00000124   060000EA           B        ??encode_mcu_DC_first_7
   \                     ??encode_mcu_DC_first_6:
   \   00000128   008068E2           RSB      R8,R8,#+0
   \   0000012C   0120A0E3           MOV      R2,#+1
   \   00000130   01108AE2           ADD      R1,R10,#+1
   \   00000134   0400A0E1           MOV      R0,R4
   \   00000138   ........           BL       arith_encode
   \   0000013C   03A08AE2           ADD      R10,R10,#+3
   \   00000140   0800A0E3           MOV      R0,#+8
   \                     ??encode_mcu_DC_first_7:
   \   00000144   340087E5           STR      R0,[R7, #+52]
   \   00000148   0090A0E3           MOV      R9,#+0
   \   0000014C   018058E2           SUBS     R8,R8,#+1
   \   00000150   1100000A           BEQ      ??encode_mcu_DC_first_8
   \   00000154   0120A0E3           MOV      R2,#+1
   \   00000158   0A10A0E1           MOV      R1,R10
   \   0000015C   0400A0E1           MOV      R0,R4
   \   00000160   ........           BL       arith_encode
   \   00000164   04009DE5           LDR      R0,[SP, #+4]
   \   00000168   0190A0E3           MOV      R9,#+1
   \   0000016C   4C0090E5           LDR      R0,[R0, #+76]
   \   00000170   08B0A0E1           MOV      R11,R8
   \   00000174   14A080E2           ADD      R10,R0,#+20
   \   00000178   050000EA           B        ??encode_mcu_DC_first_9
   \                     ??encode_mcu_DC_first_10:
   \   0000017C   0120A0E3           MOV      R2,#+1
   \   00000180   0A10A0E1           MOV      R1,R10
   \   00000184   0400A0E1           MOV      R0,R4
   \   00000188   ........           BL       arith_encode
   \   0000018C   8990A0E1           LSL      R9,R9,#+1
   \   00000190   01A08AE2           ADD      R10,R10,#+1
   \                     ??encode_mcu_DC_first_9:
   \   00000194   CBB0B0E1           ASRS     R11,R11,#+1
   \   00000198   F7FFFF1A           BNE      ??encode_mcu_DC_first_10
   \                     ??encode_mcu_DC_first_8:
   \   0000019C   0020A0E3           MOV      R2,#+0
   \   000001A0   0A10A0E1           MOV      R1,R10
   \   000001A4   0400A0E1           MOV      R0,R4
   \   000001A8   ........           BL       arith_encode
   \   000001AC   00109DE5           LDR      R1,[SP, #+0]
   \   000001B0   0100A0E3           MOV      R0,#+1
   \   000001B4   041081E0           ADD      R1,R1,R4
   \   000001B8   D419D1E1           LDRSB    R1,[R1, #+148]
   \   000001BC   1011A0E1           LSL      R1,R0,R1
   \   000001C0   C10059E1           CMP      R9,R1, ASR #+1
   \   000001C4   0000A0B3           MOVLT    R0,#+0
   \   000001C8   070000BA           BLT      ??encode_mcu_DC_first_11
   \   000001CC   00109DE5           LDR      R1,[SP, #+0]
   \   000001D0   041081E0           ADD      R1,R1,R4
   \   000001D4   D41AD1E1           LDRSB    R1,[R1, #+164]
   \   000001D8   1001A0E1           LSL      R0,R0,R1
   \   000001DC   C00059E1           CMP      R9,R0, ASR #+1
   \   000001E0   020000DA           BLE      ??encode_mcu_DC_first_12
   \   000001E4   340097E5           LDR      R0,[R7, #+52]
   \   000001E8   080080E2           ADD      R0,R0,#+8
   \                     ??encode_mcu_DC_first_11:
   \   000001EC   340087E5           STR      R0,[R7, #+52]
   \                     ??encode_mcu_DC_first_12:
   \   000001F0   0EA08AE2           ADD      R10,R10,#+14
   \   000001F4   020000EA           B        ??encode_mcu_DC_first_13
   \                     ??encode_mcu_DC_first_14:
   \   000001F8   0A10A0E1           MOV      R1,R10
   \   000001FC   0400A0E1           MOV      R0,R4
   \   00000200   ........           BL       arith_encode
   \                     ??encode_mcu_DC_first_13:
   \   00000204   C990B0E1           ASRS     R9,R9,#+1
   \   00000208   9FFFFF0A           BEQ      ??encode_mcu_DC_first_5
   \   0000020C   090018E1           TST      R8,R9
   \   00000210   0020A003           MOVEQ    R2,#+0
   \   00000214   0120A013           MOVNE    R2,#+1
   \   00000218   F6FFFFEA           B        ??encode_mcu_DC_first_14
    443          }
    444          
    445          
    446          /*
    447           * MCU encoding for AC initial scan (either spectral selection,
    448           * or first pass of successive approximation).
    449           */
    450          

   \                                 In segment CODE, align 4, keep-with-next
    451          METHODDEF(boolean)
    452          encode_mcu_AC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
    453          {
   \                     encode_mcu_AC_first:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
   \   00000008   0040A0E1           MOV      R4,R0
    454            arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
    455            JBLOCKROW block;
    456            unsigned char *st;
    457            int tbl, k, ke;
    458            int v, v2, m;
    459          
    460            /* Emit restart marker if needed */
    461            if (cinfo->restart_interval) {
   \   0000000C   E80094E5           LDR      R0,[R4, #+232]
   \   00000010   948194E5           LDR      R8,[R4, #+404]
   \   00000014   0150A0E1           MOV      R5,R1
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0F00000A           BEQ      ??encode_mcu_AC_first_0
    462              if (entropy->restarts_to_go == 0) {
   \   00000020   440098E5           LDR      R0,[R8, #+68]
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   0900001A           BNE      ??encode_mcu_AC_first_1
    463                emit_restart(cinfo, entropy->next_restart_num);
   \   0000002C   481098E5           LDR      R1,[R8, #+72]
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   ........           BL       emit_restart
    464                entropy->restarts_to_go = cinfo->restart_interval;
   \   00000038   E80094E5           LDR      R0,[R4, #+232]
   \   0000003C   440088E5           STR      R0,[R8, #+68]
    465                entropy->next_restart_num++;
   \   00000040   480098E5           LDR      R0,[R8, #+72]
   \   00000044   010080E2           ADD      R0,R0,#+1
   \   00000048   480088E5           STR      R0,[R8, #+72]
    466                entropy->next_restart_num &= 7;
   \   0000004C   070000E2           AND      R0,R0,#0x7
   \   00000050   480088E5           STR      R0,[R8, #+72]
    467              }
    468              entropy->restarts_to_go--;
   \                     ??encode_mcu_AC_first_1:
   \   00000054   440098E5           LDR      R0,[R8, #+68]
   \   00000058   010040E2           SUB      R0,R0,#+1
   \   0000005C   440088E5           STR      R0,[R8, #+68]
    469            }
    470          
    471            /* Encode the MCU data block */
    472            block = MCU_data[0];
   \                     ??encode_mcu_AC_first_0:
   \   00000060   001095E5           LDR      R1,[R5, #+0]
   \   00000064   04108DE5           STR      R1,[SP, #+4]
    473            tbl = cinfo->cur_comp_info[0]->ac_tbl_no;
   \   00000068   201194E5           LDR      R1,[R4, #+288]
   \   0000006C   181091E5           LDR      R1,[R1, #+24]
   \   00000070   08108DE5           STR      R1,[SP, #+8]
    474          
    475            /* Sections F.1.4.2 & F.1.4.4.2: Encoding of AC coefficients */
    476          
    477            /* Establish EOB (end-of-block) index */
    478            for (ke = cinfo->Se + 1; ke > 1; ke--)
   \   00000074   680194E5           LDR      R0,[R4, #+360]
   \   00000078   015080E2           ADD      R5,R0,#+1
   \   0000007C   030000EA           B        ??encode_mcu_AC_first_2
    479              /* We must apply the point transform by Al.  For AC coefficients this
    480               * is an integer division with rounding towards 0.  To do this portably
    481               * in C, we shift after obtaining the absolute value.
    482               */
    483              if ((v = (*block)[jpeg_natural_order[ke - 1]]) >= 0) {
    484                if (v >>= cinfo->Al) break;
   \                     ??encode_mcu_AC_first_3:
   \   00000080   700194E5           LDR      R0,[R4, #+368]
   \   00000084   5700B0E1           ASRS     R0,R7,R0
   \   00000088   0E00001A           BNE      ??encode_mcu_AC_first_4
    485              } else {
   \                     ??encode_mcu_AC_first_5:
   \   0000008C   015045E2           SUB      R5,R5,#+1
   \                     ??encode_mcu_AC_first_2:
   \   00000090   020055E3           CMP      R5,#+2
   \   00000094   0B0000BA           BLT      ??encode_mcu_AC_first_4
   \   00000098   ........           LDR      R0,??DataTable4  ;; jpeg_natural_order
   \   0000009C   04109DE5           LDR      R1,[SP, #+4]
   \   000000A0   050180E0           ADD      R0,R0,R5, LSL #+2
   \   000000A4   040010E5           LDR      R0,[R0, #-4]
   \   000000A8   800081E0           ADD      R0,R1,R0, LSL #+1
   \   000000AC   F070D0E1           LDRSH    R7,[R0, #+0]
   \   000000B0   000057E3           CMP      R7,#+0
   \   000000B4   F1FFFF5A           BPL      ??encode_mcu_AC_first_3
    486                v = -v;
    487                if (v >>= cinfo->Al) break;
   \   000000B8   701194E5           LDR      R1,[R4, #+368]
   \   000000BC   000067E2           RSB      R0,R7,#+0
   \   000000C0   5001B0E1           ASRS     R0,R0,R1
   \   000000C4   F0FFFF0A           BEQ      ??encode_mcu_AC_first_5
    488              }
    489          
    490            /* Figure F.5: Encode_AC_Coefficients */
    491            for (k = cinfo->Ss; k < ke; k++) {
   \                     ??encode_mcu_AC_first_4:
   \   000000C8   646194E5           LDR      R6,[R4, #+356]
   \   000000CC   08109DE5           LDR      R1,[SP, #+8]
   \   000000D0   050056E1           CMP      R6,R5
   \   000000D4   011188E0           ADD      R1,R8,R1, LSL #+2
   \   000000D8   00108DE5           STR      R1,[SP, #+0]
   \   000000DC   660000AA           BGE      ??encode_mcu_AC_first_6
    492              st = entropy->ac_stats[tbl] + 3 * (k - 1);
   \                     ??encode_mcu_AC_first_7:
   \   000000E0   00109DE5           LDR      R1,[SP, #+0]
   \   000000E4   860086E0           ADD      R0,R6,R6, LSL #+1
   \   000000E8   8C1091E5           LDR      R1,[R1, #+140]
    493              arith_encode(cinfo, st, 0);		/* EOB decision */
   \   000000EC   0020A0E3           MOV      R2,#+0
   \   000000F0   010080E0           ADD      R0,R0,R1
   \   000000F4   039040E2           SUB      R9,R0,#+3
   \   000000F8   0910A0E1           MOV      R1,R9
   \   000000FC   0400A0E1           MOV      R0,R4
   \   00000100   ........           BL       arith_encode
    494              entropy->ac_stats[tbl][245] = 0;
   \   00000104   00009DE5           LDR      R0,[SP, #+0]
   \   00000108   0010A0E3           MOV      R1,#+0
   \   0000010C   8C0090E5           LDR      R0,[R0, #+140]
   \   00000110   F510C0E5           STRB     R1,[R0, #+245]
   \   00000114   050000EA           B        ??encode_mcu_AC_first_8
    495              for (;;) {
    496                if ((v = (*block)[jpeg_natural_order[k]]) >= 0) {
    497          	if (v >>= cinfo->Al) {
    498          	  arith_encode(cinfo, st + 1, 1);
    499          	  arith_encode(cinfo, entropy->ac_stats[tbl] + 245, 0);
    500          	  break;
    501          	}
    502                } else {
    503          	v = -v;
    504          	if (v >>= cinfo->Al) {
    505          	  arith_encode(cinfo, st + 1, 1);
    506          	  arith_encode(cinfo, entropy->ac_stats[tbl] + 245, 1);
    507          	  break;
    508          	}
    509                }
    510                arith_encode(cinfo, st + 1, 0); st += 3; k++;
   \                     ??encode_mcu_AC_first_9:
   \   00000118   0020A0E3           MOV      R2,#+0
   \   0000011C   011089E2           ADD      R1,R9,#+1
   \   00000120   0400A0E1           MOV      R0,R4
   \   00000124   ........           BL       arith_encode
   \   00000128   039089E2           ADD      R9,R9,#+3
   \   0000012C   0860A0E1           MOV      R6,R8
   \                     ??encode_mcu_AC_first_8:
   \   00000130   ........           LDR      R0,??DataTable4  ;; jpeg_natural_order
   \   00000134   04109DE5           LDR      R1,[SP, #+4]
   \   00000138   060190E7           LDR      R0,[R0, +R6, LSL #+2]
   \   0000013C   018086E2           ADD      R8,R6,#+1
   \   00000140   800081E0           ADD      R0,R1,R0, LSL #+1
   \   00000144   F000D0E1           LDRSH    R0,[R0, #+0]
   \   00000148   000050E3           CMP      R0,#+0
   \   0000014C   0800004A           BMI      ??encode_mcu_AC_first_10
   \   00000150   701194E5           LDR      R1,[R4, #+368]
   \   00000154   5071B0E1           ASRS     R7,R0,R1
   \   00000158   EEFFFF0A           BEQ      ??encode_mcu_AC_first_9
   \   0000015C   0120A0E3           MOV      R2,#+1
   \   00000160   011089E2           ADD      R1,R9,#+1
   \   00000164   0400A0E1           MOV      R0,R4
   \   00000168   ........           BL       arith_encode
   \   0000016C   0020A0E3           MOV      R2,#+0
   \   00000170   080000EA           B        ??encode_mcu_AC_first_11
   \                     ??encode_mcu_AC_first_10:
   \   00000174   701194E5           LDR      R1,[R4, #+368]
   \   00000178   000060E2           RSB      R0,R0,#+0
   \   0000017C   5071B0E1           ASRS     R7,R0,R1
   \   00000180   E4FFFF0A           BEQ      ??encode_mcu_AC_first_9
   \   00000184   0120A0E3           MOV      R2,#+1
   \   00000188   011089E2           ADD      R1,R9,#+1
   \   0000018C   0400A0E1           MOV      R0,R4
   \   00000190   ........           BL       arith_encode
   \   00000194   0120A0E3           MOV      R2,#+1
   \                     ??encode_mcu_AC_first_11:
   \   00000198   00009DE5           LDR      R0,[SP, #+0]
    511              }
    512              st += 2;
   \   0000019C   02B089E2           ADD      R11,R9,#+2
   \   000001A0   8C0090E5           LDR      R0,[R0, #+140]
    513              /* Figure F.8: Encoding the magnitude category of v */
    514              m = 0;
   \   000001A4   00A0A0E3           MOV      R10,#+0
   \   000001A8   F51080E2           ADD      R1,R0,#+245
   \   000001AC   0400A0E1           MOV      R0,R4
   \   000001B0   ........           BL       arith_encode
    515              if (v -= 1) {
   \   000001B4   017057E2           SUBS     R7,R7,#+1
   \   000001B8   1D00000A           BEQ      ??encode_mcu_AC_first_12
    516                arith_encode(cinfo, st, 1);
   \   000001BC   0120A0E3           MOV      R2,#+1
   \   000001C0   0B10A0E1           MOV      R1,R11
   \   000001C4   0400A0E1           MOV      R0,R4
   \   000001C8   ........           BL       arith_encode
    517                m = 1;
   \   000001CC   01A0A0E3           MOV      R10,#+1
    518                v2 = v;
    519                if (v2 >>= 1) {
   \   000001D0   C790B0E1           ASRS     R9,R7,#+1
   \   000001D4   1600000A           BEQ      ??encode_mcu_AC_first_12
    520          	arith_encode(cinfo, st, 1);
   \   000001D8   0120A0E3           MOV      R2,#+1
   \   000001DC   0B10A0E1           MOV      R1,R11
   \   000001E0   0400A0E1           MOV      R0,R4
   \   000001E4   ........           BL       arith_encode
    521          	m <<= 1;
    522          	st = entropy->ac_stats[tbl] +
    523          	     (k <= cinfo->arith_ac_K[tbl] ? 189 : 217);
   \   000001E8   08009DE5           LDR      R0,[SP, #+8]
   \   000001EC   00109DE5           LDR      R1,[SP, #+0]
   \   000001F0   040080E0           ADD      R0,R0,R4
   \   000001F4   B400D0E5           LDRB     R0,[R0, #+180]
   \   000001F8   8C1091E5           LDR      R1,[R1, #+140]
   \   000001FC   02A0A0E3           MOV      R10,#+2
   \   00000200   060050E1           CMP      R0,R6
   \   00000204   BD00A0A3           MOVGE    R0,#+189
   \   00000208   D900A0B3           MOVLT    R0,#+217
   \   0000020C   01B080E0           ADD      R11,R0,R1
   \   00000210   050000EA           B        ??encode_mcu_AC_first_13
    524          	while (v2 >>= 1) {
    525          	  arith_encode(cinfo, st, 1);
   \                     ??encode_mcu_AC_first_14:
   \   00000214   0120A0E3           MOV      R2,#+1
   \   00000218   0B10A0E1           MOV      R1,R11
   \   0000021C   0400A0E1           MOV      R0,R4
   \   00000220   ........           BL       arith_encode
    526          	  m <<= 1;
   \   00000224   8AA0A0E1           LSL      R10,R10,#+1
    527          	  st += 1;
   \   00000228   01B08BE2           ADD      R11,R11,#+1
    528          	}
   \                     ??encode_mcu_AC_first_13:
   \   0000022C   C990B0E1           ASRS     R9,R9,#+1
   \   00000230   F7FFFF1A           BNE      ??encode_mcu_AC_first_14
    529                }
    530              }
    531              arith_encode(cinfo, st, 0);
   \                     ??encode_mcu_AC_first_12:
   \   00000234   0020A0E3           MOV      R2,#+0
   \   00000238   0B10A0E1           MOV      R1,R11
   \   0000023C   0400A0E1           MOV      R0,R4
   \   00000240   ........           BL       arith_encode
    532              /* Figure F.9: Encoding the magnitude bit pattern of v */
    533              st += 14;
   \   00000244   0E608BE2           ADD      R6,R11,#+14
   \   00000248   020000EA           B        ??encode_mcu_AC_first_15
    534              while (m >>= 1)
    535                arith_encode(cinfo, st, (m & v) ? 1 : 0);
   \                     ??encode_mcu_AC_first_16:
   \   0000024C   0610A0E1           MOV      R1,R6
   \   00000250   0400A0E1           MOV      R0,R4
   \   00000254   ........           BL       arith_encode
   \                     ??encode_mcu_AC_first_15:
   \   00000258   CAA0B0E1           ASRS     R10,R10,#+1
   \   0000025C   0300000A           BEQ      ??encode_mcu_AC_first_17
   \   00000260   0A0017E1           TST      R7,R10
   \   00000264   0020A003           MOVEQ    R2,#+0
   \   00000268   0120A013           MOVNE    R2,#+1
   \   0000026C   F6FFFFEA           B        ??encode_mcu_AC_first_16
    536            }
   \                     ??encode_mcu_AC_first_17:
   \   00000270   0860A0E1           MOV      R6,R8
   \   00000274   050056E1           CMP      R6,R5
   \   00000278   98FFFFBA           BLT      ??encode_mcu_AC_first_7
    537            /* Encode EOB decision only if k <= cinfo->Se */
    538            if (k <= cinfo->Se) {
   \                     ??encode_mcu_AC_first_6:
   \   0000027C   680194E5           LDR      R0,[R4, #+360]
   \   00000280   060050E1           CMP      R0,R6
   \   00000284   070000BA           BLT      ??encode_mcu_AC_first_18
    539              st = entropy->ac_stats[tbl] + 3 * (k - 1);
    540              arith_encode(cinfo, st, 1);
   \   00000288   00109DE5           LDR      R1,[SP, #+0]
   \   0000028C   0120A0E3           MOV      R2,#+1
   \   00000290   8C1091E5           LDR      R1,[R1, #+140]
   \   00000294   860086E0           ADD      R0,R6,R6, LSL #+1
   \   00000298   010080E0           ADD      R0,R0,R1
   \   0000029C   031040E2           SUB      R1,R0,#+3
   \   000002A0   0400A0E1           MOV      R0,R4
   \   000002A4   ........           BL       arith_encode
    541            }
    542          
    543            return TRUE;
   \                     ??encode_mcu_AC_first_18:
   \   000002A8   0100A0E3           MOV      R0,#+1
   \   000002AC   FE8FBDE8           POP      {R1-R11,PC}      ;; return
    544          }
    545          
    546          
    547          /*
    548           * MCU encoding for DC successive approximation refinement scan.
    549           */
    550          

   \                                 In segment CODE, align 4, keep-with-next
    551          METHODDEF(boolean)
    552          encode_mcu_DC_refine (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
    553          {
   \                     encode_mcu_DC_refine:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040A0E1           MOV      R4,R0
    554            arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
    555            unsigned char st[4];
    556            int Al, blkn;
    557          
    558            /* Emit restart marker if needed */
    559            if (cinfo->restart_interval) {
   \   0000000C   E80094E5           LDR      R0,[R4, #+232]
   \   00000010   946194E5           LDR      R6,[R4, #+404]
   \   00000014   0150A0E1           MOV      R5,R1
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0E00000A           BEQ      ??encode_mcu_DC_refine_0
    560              if (entropy->restarts_to_go == 0) {
   \   00000020   440096E5           LDR      R0,[R6, #+68]
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   0800001A           BNE      ??encode_mcu_DC_refine_1
    561                emit_restart(cinfo, entropy->next_restart_num);
   \   0000002C   481096E5           LDR      R1,[R6, #+72]
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   ........           BL       emit_restart
    562                entropy->restarts_to_go = cinfo->restart_interval;
   \   00000038   E80094E5           LDR      R0,[R4, #+232]
   \   0000003C   440086E5           STR      R0,[R6, #+68]
    563                entropy->next_restart_num++;
    564                entropy->next_restart_num &= 7;
   \   00000040   480096E5           LDR      R0,[R6, #+72]
   \   00000044   010080E2           ADD      R0,R0,#+1
   \   00000048   070000E2           AND      R0,R0,#0x7
   \   0000004C   480086E5           STR      R0,[R6, #+72]
    565              }
    566              entropy->restarts_to_go--;
   \                     ??encode_mcu_DC_refine_1:
   \   00000050   440096E5           LDR      R0,[R6, #+68]
   \   00000054   010040E2           SUB      R0,R0,#+1
   \   00000058   440086E5           STR      R0,[R6, #+68]
    567            }
    568          
    569            Al = cinfo->Al;
    570          
    571            /* Encode the MCU data blocks */
    572            for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
   \                     ??encode_mcu_DC_refine_0:
   \   0000005C   380194E5           LDR      R0,[R4, #+312]
   \   00000060   706194E5           LDR      R6,[R4, #+368]
   \   00000064   0070A0E3           MOV      R7,#+0
   \   00000068   010050E3           CMP      R0,#+1
   \   0000006C   0B0000AA           BGE      ??encode_mcu_DC_refine_2
   \   00000070   0100A0E3           MOV      R0,#+1
   \   00000074   F280BDE8           POP      {R1,R4-R7,PC}
    573              st[0] = 0;	/* use fixed probability estimation */
   \                     ??encode_mcu_DC_refine_3:
   \   00000078   0010A0E3           MOV      R1,#+0
   \   0000007C   0010CDE5           STRB     R1,[SP, #+0]
    574              /* We simply emit the Al'th bit of the DC coefficient value. */
    575              arith_encode(cinfo, st, (MCU_data[blkn][0][0] >> Al) & 1);
   \   00000080   070195E7           LDR      R0,[R5, +R7, LSL #+2]
   \   00000084   0110A0E3           MOV      R1,#+1
   \   00000088   F000D0E1           LDRSH    R0,[R0, #+0]
    576            }
   \   0000008C   017087E2           ADD      R7,R7,#+1
   \   00000090   502601E0           AND      R2,R1,R0, ASR R6
   \   00000094   0D10A0E1           MOV      R1,SP
   \   00000098   0400A0E1           MOV      R0,R4
   \   0000009C   ........           BL       arith_encode
   \                     ??encode_mcu_DC_refine_2:
   \   000000A0   380194E5           LDR      R0,[R4, #+312]
   \   000000A4   000057E1           CMP      R7,R0
   \   000000A8   F2FFFFBA           BLT      ??encode_mcu_DC_refine_3
    577          
    578            return TRUE;
   \   000000AC   0100A0E3           MOV      R0,#+1
   \   000000B0   F280BDE8           POP      {R1,R4-R7,PC}    ;; return
    579          }
    580          
    581          
    582          /*
    583           * MCU encoding for AC successive approximation refinement scan.
    584           */
    585          

   \                                 In segment CODE, align 4, keep-with-next
    586          METHODDEF(boolean)
    587          encode_mcu_AC_refine (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
    588          {
   \                     encode_mcu_AC_refine:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    589            arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
    590            JBLOCKROW block;
    591            unsigned char *st;
    592            int tbl, k, ke, kex;
    593            int v;
    594          
    595            /* Emit restart marker if needed */
    596            if (cinfo->restart_interval) {
   \   00000008   E80094E5           LDR      R0,[R4, #+232]
   \   0000000C   949194E5           LDR      R9,[R4, #+404]
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0F00000A           BEQ      ??encode_mcu_AC_refine_0
    597              if (entropy->restarts_to_go == 0) {
   \   0000001C   440099E5           LDR      R0,[R9, #+68]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0900001A           BNE      ??encode_mcu_AC_refine_1
    598                emit_restart(cinfo, entropy->next_restart_num);
   \   00000028   481099E5           LDR      R1,[R9, #+72]
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           BL       emit_restart
    599                entropy->restarts_to_go = cinfo->restart_interval;
   \   00000034   E80094E5           LDR      R0,[R4, #+232]
   \   00000038   440089E5           STR      R0,[R9, #+68]
    600                entropy->next_restart_num++;
   \   0000003C   480099E5           LDR      R0,[R9, #+72]
   \   00000040   010080E2           ADD      R0,R0,#+1
   \   00000044   480089E5           STR      R0,[R9, #+72]
    601                entropy->next_restart_num &= 7;
   \   00000048   070000E2           AND      R0,R0,#0x7
   \   0000004C   480089E5           STR      R0,[R9, #+72]
    602              }
    603              entropy->restarts_to_go--;
   \                     ??encode_mcu_AC_refine_1:
   \   00000050   440099E5           LDR      R0,[R9, #+68]
   \   00000054   010040E2           SUB      R0,R0,#+1
   \   00000058   440089E5           STR      R0,[R9, #+68]
    604            }
    605          
    606            /* Encode the MCU data block */
    607            block = MCU_data[0];
    608            tbl = cinfo->cur_comp_info[0]->ac_tbl_no;
   \                     ??encode_mcu_AC_refine_0:
   \   0000005C   200194E5           LDR      R0,[R4, #+288]
    609          
    610            /* Section G.1.3.3: Encoding of AC coefficients */
    611          
    612            /* Establish EOB (end-of-block) index */
    613            for (ke = cinfo->Se + 1; ke > 1; ke--)
   \   00000060   681194E5           LDR      R1,[R4, #+360]
   \   00000064   005095E5           LDR      R5,[R5, #+0]
   \   00000068   180090E5           LDR      R0,[R0, #+24]
   \   0000006C   ........           LDR      R7,??DataTable4  ;; jpeg_natural_order
   \   00000070   016081E2           ADD      R6,R1,#+1
   \   00000074   020000EA           B        ??encode_mcu_AC_refine_2
    614              /* We must apply the point transform by Al.  For AC coefficients this
    615               * is an integer division with rounding towards 0.  To do this portably
    616               * in C, we shift after obtaining the absolute value.
    617               */
    618              if ((v = (*block)[jpeg_natural_order[ke - 1]]) >= 0) {
    619                if (v >>= cinfo->Al) break;
   \                     ??encode_mcu_AC_refine_3:
   \   00000078   5112B0E1           ASRS     R1,R1,R2
   \   0000007C   0C00001A           BNE      ??encode_mcu_AC_refine_4
    620              } else {
   \                     ??encode_mcu_AC_refine_5:
   \   00000080   016046E2           SUB      R6,R6,#+1
   \                     ??encode_mcu_AC_refine_2:
   \   00000084   020056E3           CMP      R6,#+2
   \   00000088   090000BA           BLT      ??encode_mcu_AC_refine_4
   \   0000008C   702194E5           LDR      R2,[R4, #+368]
   \   00000090   061187E0           ADD      R1,R7,R6, LSL #+2
   \   00000094   041011E5           LDR      R1,[R1, #-4]
   \   00000098   811085E0           ADD      R1,R5,R1, LSL #+1
   \   0000009C   F010D1E1           LDRSH    R1,[R1, #+0]
   \   000000A0   000051E3           CMP      R1,#+0
   \   000000A4   F3FFFF5A           BPL      ??encode_mcu_AC_refine_3
    621                v = -v;
    622                if (v >>= cinfo->Al) break;
   \   000000A8   001061E2           RSB      R1,R1,#+0
   \   000000AC   5112B0E1           ASRS     R1,R1,R2
   \   000000B0   F2FFFF0A           BEQ      ??encode_mcu_AC_refine_5
    623              }
    624          
    625            /* Establish EOBx (previous stage end-of-block) index */
    626            for (kex = ke; kex > 1; kex--)
   \                     ??encode_mcu_AC_refine_4:
   \   000000B4   0680A0E1           MOV      R8,R6
   \   000000B8   020000EA           B        ??encode_mcu_AC_refine_6
    627              if ((v = (*block)[jpeg_natural_order[kex - 1]]) >= 0) {
    628                if (v >>= cinfo->Ah) break;
   \                     ??encode_mcu_AC_refine_7:
   \   000000BC   5112B0E1           ASRS     R1,R1,R2
   \   000000C0   0C00001A           BNE      ??encode_mcu_AC_refine_8
    629              } else {
   \                     ??encode_mcu_AC_refine_9:
   \   000000C4   018048E2           SUB      R8,R8,#+1
   \                     ??encode_mcu_AC_refine_6:
   \   000000C8   020058E3           CMP      R8,#+2
   \   000000CC   090000BA           BLT      ??encode_mcu_AC_refine_8
   \   000000D0   6C2194E5           LDR      R2,[R4, #+364]
   \   000000D4   081187E0           ADD      R1,R7,R8, LSL #+2
   \   000000D8   041011E5           LDR      R1,[R1, #-4]
   \   000000DC   811085E0           ADD      R1,R5,R1, LSL #+1
   \   000000E0   F010D1E1           LDRSH    R1,[R1, #+0]
   \   000000E4   000051E3           CMP      R1,#+0
   \   000000E8   F3FFFF5A           BPL      ??encode_mcu_AC_refine_7
    630                v = -v;
    631                if (v >>= cinfo->Ah) break;
   \   000000EC   001061E2           RSB      R1,R1,#+0
   \   000000F0   5112B0E1           ASRS     R1,R1,R2
   \   000000F4   F2FFFF0A           BEQ      ??encode_mcu_AC_refine_9
    632              }
    633          
    634            /* Figure G.10: Encode_AC_Coefficients_SA */
    635            for (k = cinfo->Ss; k < ke; k++) {
   \                     ??encode_mcu_AC_refine_8:
   \   000000F8   64B194E5           LDR      R11,[R4, #+356]
   \   000000FC   009189E0           ADD      R9,R9,R0, LSL #+2
   \   00000100   06005BE1           CMP      R11,R6
   \   00000104   380000AA           BGE      ??encode_mcu_AC_refine_10
    636              st = entropy->ac_stats[tbl] + 3 * (k - 1);
   \                     ??encode_mcu_AC_refine_11:
   \   00000108   8C1099E5           LDR      R1,[R9, #+140]
   \   0000010C   8B008BE0           ADD      R0,R11,R11, LSL #+1
   \   00000110   010080E0           ADD      R0,R0,R1
   \   00000114   03A040E2           SUB      R10,R0,#+3
    637              if (k >= kex)
   \   00000118   08005BE1           CMP      R11,R8
   \   0000011C   030000BA           BLT      ??encode_mcu_AC_refine_12
    638                arith_encode(cinfo, st, 0);	/* EOB decision */
   \   00000120   0020A0E3           MOV      R2,#+0
   \   00000124   0A10A0E1           MOV      R1,R10
   \   00000128   0400A0E1           MOV      R0,R4
   \   0000012C   ........           BL       arith_encode
    639              entropy->ac_stats[tbl][245] = 0;
   \                     ??encode_mcu_AC_refine_12:
   \   00000130   8C0099E5           LDR      R0,[R9, #+140]
   \   00000134   0010A0E3           MOV      R1,#+0
   \   00000138   F510C0E5           STRB     R1,[R0, #+245]
   \   0000013C   040000EA           B        ??encode_mcu_AC_refine_13
    640              for (;;) {
    641                if ((v = (*block)[jpeg_natural_order[k]]) >= 0) {
    642          	if (v >>= cinfo->Al) {
    643          	  if (v >> 1)		/* previously nonzero coef */
    644          	    arith_encode(cinfo, st + 2, (v & 1));
    645          	  else {		/* newly nonzero coef */
    646          	    arith_encode(cinfo, st + 1, 1);
    647          	    arith_encode(cinfo, entropy->ac_stats[tbl] + 245, 0);
    648          	  }
    649          	  break;
    650          	}
    651                } else {
    652          	v = -v;
    653          	if (v >>= cinfo->Al) {
    654          	  if (v >> 1)		/* previously nonzero coef */
    655          	    arith_encode(cinfo, st + 2, (v & 1));
    656          	  else {		/* newly nonzero coef */
    657          	    arith_encode(cinfo, st + 1, 1);
    658          	    arith_encode(cinfo, entropy->ac_stats[tbl] + 245, 1);
    659          	  }
    660          	  break;
    661          	}
    662                }
    663                arith_encode(cinfo, st + 1, 0); st += 3; k++;
   \                     ??encode_mcu_AC_refine_14:
   \   00000140   0020A0E3           MOV      R2,#+0
   \   00000144   01108AE2           ADD      R1,R10,#+1
   \   00000148   0400A0E1           MOV      R0,R4
   \   0000014C   ........           BL       arith_encode
   \   00000150   03A08AE2           ADD      R10,R10,#+3
   \                     ??encode_mcu_AC_refine_13:
   \   00000154   0B0197E7           LDR      R0,[R7, +R11, LSL #+2]
   \   00000158   701194E5           LDR      R1,[R4, #+368]
   \   0000015C   800085E0           ADD      R0,R5,R0, LSL #+1
   \   00000160   F000D0E1           LDRSH    R0,[R0, #+0]
   \   00000164   01B08BE2           ADD      R11,R11,#+1
   \   00000168   000050E3           CMP      R0,#+0
   \   0000016C   0C00004A           BMI      ??encode_mcu_AC_refine_15
   \   00000170   5011B0E1           ASRS     R1,R0,R1
   \   00000174   F1FFFF0A           BEQ      ??encode_mcu_AC_refine_14
   \   00000178   C100B0E1           ASRS     R0,R1,#+1
   \   0000017C   01200112           ANDNE    R2,R1,#0x1
   \   00000180   02108A12           ADDNE    R1,R10,#+2
   \   00000184   1400001A           BNE      ??encode_mcu_AC_refine_16
   \   00000188   0120A0E3           MOV      R2,#+1
   \   0000018C   01108AE2           ADD      R1,R10,#+1
   \   00000190   0400A0E1           MOV      R0,R4
   \   00000194   ........           BL       arith_encode
   \   00000198   8C0099E5           LDR      R0,[R9, #+140]
   \   0000019C   0020A0E3           MOV      R2,#+0
   \   000001A0   0C0000EA           B        ??encode_mcu_AC_refine_17
   \                     ??encode_mcu_AC_refine_15:
   \   000001A4   000060E2           RSB      R0,R0,#+0
   \   000001A8   5011B0E1           ASRS     R1,R0,R1
   \   000001AC   E3FFFF0A           BEQ      ??encode_mcu_AC_refine_14
   \   000001B0   C100B0E1           ASRS     R0,R1,#+1
   \   000001B4   01200112           ANDNE    R2,R1,#0x1
   \   000001B8   02108A12           ADDNE    R1,R10,#+2
   \   000001BC   0600001A           BNE      ??encode_mcu_AC_refine_16
   \   000001C0   0120A0E3           MOV      R2,#+1
   \   000001C4   01108AE2           ADD      R1,R10,#+1
   \   000001C8   0400A0E1           MOV      R0,R4
   \   000001CC   ........           BL       arith_encode
   \   000001D0   8C0099E5           LDR      R0,[R9, #+140]
   \   000001D4   0120A0E3           MOV      R2,#+1
   \                     ??encode_mcu_AC_refine_17:
   \   000001D8   F51080E2           ADD      R1,R0,#+245
   \                     ??encode_mcu_AC_refine_16:
   \   000001DC   0400A0E1           MOV      R0,R4
   \   000001E0   ........           BL       arith_encode
    664              }
    665            }
   \   000001E4   06005BE1           CMP      R11,R6
   \   000001E8   C6FFFFBA           BLT      ??encode_mcu_AC_refine_11
    666            /* Encode EOB decision only if k <= cinfo->Se */
    667            if (k <= cinfo->Se) {
   \                     ??encode_mcu_AC_refine_10:
   \   000001EC   680194E5           LDR      R0,[R4, #+360]
   \   000001F0   0B0050E1           CMP      R0,R11
   \   000001F4   060000BA           BLT      ??encode_mcu_AC_refine_18
    668              st = entropy->ac_stats[tbl] + 3 * (k - 1);
    669              arith_encode(cinfo, st, 1);
   \   000001F8   8C1099E5           LDR      R1,[R9, #+140]
   \   000001FC   0120A0E3           MOV      R2,#+1
   \   00000200   8B008BE0           ADD      R0,R11,R11, LSL #+1
   \   00000204   010080E0           ADD      R0,R0,R1
   \   00000208   031040E2           SUB      R1,R0,#+3
   \   0000020C   0400A0E1           MOV      R0,R4
   \   00000210   ........           BL       arith_encode
    670            }
    671          
    672            return TRUE;
   \                     ??encode_mcu_AC_refine_18:
   \   00000214   0100A0E3           MOV      R0,#+1
   \   00000218   F08FBDE8           POP      {R4-R11,PC}      ;; return
    673          }
    674          
    675          
    676          /*
    677           * Encode and output one MCU's worth of arithmetic-compressed coefficients.
    678           */
    679          

   \                                 In segment CODE, align 4, keep-with-next
    680          METHODDEF(boolean)
    681          encode_mcu (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
    682          {
   \                     encode_mcu:
   \   00000000   F24F2DE9           PUSH     {R1,R4-R11,LR}
   \   00000004   18D04DE2           SUB      SP,SP,#+24
   \   00000008   0040A0E1           MOV      R4,R0
    683            arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
   \   0000000C   941194E5           LDR      R1,[R4, #+404]
   \   00000010   00108DE5           STR      R1,[SP, #+0]
    684            jpeg_component_info * compptr;
    685            JBLOCKROW block;
    686            unsigned char *st;
    687            int blkn, ci, tbl, k, ke;
    688            int v, v2, m;
    689          
    690            /* Emit restart marker if needed */
    691            if (cinfo->restart_interval) {
   \   00000014   E80094E5           LDR      R0,[R4, #+232]
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   1400000A           BEQ      ??encode_mcu_0
    692              if (entropy->restarts_to_go == 0) {
   \   00000020   440091E5           LDR      R0,[R1, #+68]
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   0D00001A           BNE      ??encode_mcu_1
    693                emit_restart(cinfo, entropy->next_restart_num);
   \   0000002C   481091E5           LDR      R1,[R1, #+72]
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   ........           BL       emit_restart
    694                entropy->restarts_to_go = cinfo->restart_interval;
   \   00000038   00009DE5           LDR      R0,[SP, #+0]
   \   0000003C   E81094E5           LDR      R1,[R4, #+232]
   \   00000040   441080E5           STR      R1,[R0, #+68]
    695                entropy->next_restart_num++;
   \   00000044   00009DE5           LDR      R0,[SP, #+0]
   \   00000048   481090E5           LDR      R1,[R0, #+72]
   \   0000004C   011081E2           ADD      R1,R1,#+1
   \   00000050   481080E5           STR      R1,[R0, #+72]
    696                entropy->next_restart_num &= 7;
   \   00000054   00009DE5           LDR      R0,[SP, #+0]
   \   00000058   481090E5           LDR      R1,[R0, #+72]
   \   0000005C   071001E2           AND      R1,R1,#0x7
   \   00000060   481080E5           STR      R1,[R0, #+72]
    697              }
    698              entropy->restarts_to_go--;
   \                     ??encode_mcu_1:
   \   00000064   00009DE5           LDR      R0,[SP, #+0]
   \   00000068   441090E5           LDR      R1,[R0, #+68]
   \   0000006C   011041E2           SUB      R1,R1,#+1
   \   00000070   441080E5           STR      R1,[R0, #+68]
    699            }
    700          
    701            /* Encode the MCU data blocks */
    702            for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
   \                     ??encode_mcu_0:
   \   00000074   0010A0E3           MOV      R1,#+0
   \   00000078   08108DE5           STR      R1,[SP, #+8]
   \   0000007C   380194E5           LDR      R0,[R4, #+312]
   \   00000080   010050E3           CMP      R0,#+1
   \   00000084   0F0000AA           BGE      ??encode_mcu_2
    703              block = MCU_data[blkn];
    704              ci = cinfo->MCU_membership[blkn];
    705              compptr = cinfo->cur_comp_info[ci];
    706          
    707              /* Sections F.1.4.1 & F.1.4.4.1: Encoding of DC coefficients */
    708          
    709              tbl = compptr->dc_tbl_no;
    710          
    711              /* Table F.4: Point to statistics bin S0 for DC coefficient coding */
    712              st = entropy->dc_stats[tbl] + entropy->dc_context[ci];
    713          
    714              /* Figure F.4: Encode_DC_DIFF */
    715              if ((v = (*block)[0] - entropy->last_dc_val[ci]) == 0) {
    716                arith_encode(cinfo, st, 0);
    717                entropy->dc_context[ci] = 0;	/* zero diff category */
    718              } else {
    719                entropy->last_dc_val[ci] = (*block)[0];
    720                arith_encode(cinfo, st, 1);
    721                /* Figure F.6: Encoding nonzero value v */
    722                /* Figure F.7: Encoding the sign of v */
    723                if (v > 0) {
    724          	arith_encode(cinfo, st + 1, 0);	/* Table F.4: SS = S0 + 1 */
    725          	st += 2;			/* Table F.4: SP = S0 + 2 */
    726          	entropy->dc_context[ci] = 4;	/* small positive diff category */
    727                } else {
    728          	v = -v;
    729          	arith_encode(cinfo, st + 1, 1);	/* Table F.4: SS = S0 + 1 */
    730          	st += 3;			/* Table F.4: SN = S0 + 3 */
    731          	entropy->dc_context[ci] = 8;	/* small negative diff category */
    732                }
    733                /* Figure F.8: Encoding the magnitude category of v */
    734                m = 0;
    735                if (v -= 1) {
    736          	arith_encode(cinfo, st, 1);
    737          	m = 1;
    738          	v2 = v;
    739          	st = entropy->dc_stats[tbl] + 20; /* Table F.4: X1 = 20 */
    740          	while (v2 >>= 1) {
    741          	  arith_encode(cinfo, st, 1);
    742          	  m <<= 1;
    743          	  st += 1;
    744          	}
    745                }
    746                arith_encode(cinfo, st, 0);
    747                /* Section F.1.4.4.1.2: Establish dc_context conditioning category */
    748                if (m < (int) (((INT32) 1 << cinfo->arith_dc_L[tbl]) >> 1))
    749          	entropy->dc_context[ci] = 0;	/* zero diff category */
    750                else if (m > (int) (((INT32) 1 << cinfo->arith_dc_U[tbl]) >> 1))
    751          	entropy->dc_context[ci] += 8;	/* large diff category */
    752                /* Figure F.9: Encoding the magnitude bit pattern of v */
    753                st += 14;
    754                while (m >>= 1)
    755          	arith_encode(cinfo, st, (m & v) ? 1 : 0);
    756              }
    757          
    758              /* Sections F.1.4.2 & F.1.4.4.2: Encoding of AC coefficients */
    759          
    760              tbl = compptr->ac_tbl_no;
    761          
    762              /* Establish EOB (end-of-block) index */
    763              for (ke = DCTSIZE2; ke > 1; ke--)
    764                if ((*block)[jpeg_natural_order[ke - 1]]) break;
    765          
    766              /* Figure F.5: Encode_AC_Coefficients */
    767              for (k = 1; k < ke; k++) {
    768                st = entropy->ac_stats[tbl] + 3 * (k - 1);
    769                arith_encode(cinfo, st, 0);	/* EOB decision */
    770                while ((v = (*block)[jpeg_natural_order[k]]) == 0) {
    771          	arith_encode(cinfo, st + 1, 0); st += 3; k++;
    772                }
    773                arith_encode(cinfo, st + 1, 1);
    774                /* Figure F.6: Encoding nonzero value v */
    775                /* Figure F.7: Encoding the sign of v */
    776                entropy->ac_stats[tbl][245] = 0;
    777                if (v > 0) {
    778          	arith_encode(cinfo, entropy->ac_stats[tbl] + 245, 0);
    779                } else {
    780          	v = -v;
    781          	arith_encode(cinfo, entropy->ac_stats[tbl] + 245, 1);
    782                }
    783                st += 2;
    784                /* Figure F.8: Encoding the magnitude category of v */
    785                m = 0;
    786                if (v -= 1) {
    787          	arith_encode(cinfo, st, 1);
    788          	m = 1;
    789          	v2 = v;
    790          	if (v2 >>= 1) {
    791          	  arith_encode(cinfo, st, 1);
    792          	  m <<= 1;
    793          	  st = entropy->ac_stats[tbl] +
    794          	       (k <= cinfo->arith_ac_K[tbl] ? 189 : 217);
    795          	  while (v2 >>= 1) {
    796          	    arith_encode(cinfo, st, 1);
    797          	    m <<= 1;
    798          	    st += 1;
    799          	  }
    800          	}
    801                }
    802                arith_encode(cinfo, st, 0);
    803                /* Figure F.9: Encoding the magnitude bit pattern of v */
    804                st += 14;
    805                while (m >>= 1)
    806          	arith_encode(cinfo, st, (m & v) ? 1 : 0);
    807              }
    808              /* Encode EOB decision only if k < DCTSIZE2 */
    809              if (k < DCTSIZE2) {
    810                st = entropy->ac_stats[tbl] + 3 * (k - 1);
    811                arith_encode(cinfo, st, 1);
    812              }
    813            }
    814          
    815            return TRUE;
   \                     ??encode_mcu_3:
   \   00000088   0100A0E3           MOV      R0,#+1
   \   0000008C   1CD08DE2           ADD      SP,SP,#+28
   \   00000090   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??encode_mcu_4:
   \   00000094   40005AE3           CMP      R10,#+64
   \   00000098   070000AA           BGE      ??encode_mcu_5
   \                     ??encode_mcu_6:
   \   0000009C   04109DE5           LDR      R1,[SP, #+4]
   \   000000A0   0120A0E3           MOV      R2,#+1
   \   000000A4   8C1091E5           LDR      R1,[R1, #+140]
   \   000000A8   8A008AE0           ADD      R0,R10,R10, LSL #+1
   \   000000AC   010080E0           ADD      R0,R0,R1
   \   000000B0   031040E2           SUB      R1,R0,#+3
   \   000000B4   0400A0E1           MOV      R0,R4
   \   000000B8   ........           BL       arith_encode
   \                     ??encode_mcu_5:
   \   000000BC   08109DE5           LDR      R1,[SP, #+8]
   \   000000C0   011081E2           ADD      R1,R1,#+1
   \   000000C4   08108DE5           STR      R1,[SP, #+8]
   \                     ??encode_mcu_2:
   \   000000C8   08009DE5           LDR      R0,[SP, #+8]
   \   000000CC   381194E5           LDR      R1,[R4, #+312]
   \   000000D0   010050E1           CMP      R0,R1
   \   000000D4   EBFFFFAA           BGE      ??encode_mcu_3
   \   000000D8   18209DE5           LDR      R2,[SP, #+24]
   \   000000DC   0010A0E1           MOV      R1,R0
   \   000000E0   011192E7           LDR      R1,[R2, +R1, LSL #+2]
   \   000000E4   000184E0           ADD      R0,R4,R0, LSL #+2
   \   000000E8   0C108DE5           STR      R1,[SP, #+12]
   \   000000EC   3C0190E5           LDR      R0,[R0, #+316]
   \   000000F0   002184E0           ADD      R2,R4,R0, LSL #+2
   \   000000F4   202192E5           LDR      R2,[R2, #+288]
   \   000000F8   10208DE5           STR      R2,[SP, #+16]
   \   000000FC   148092E5           LDR      R8,[R2, #+20]
   \   00000100   00109DE5           LDR      R1,[SP, #+0]
   \   00000104   009181E0           ADD      R9,R1,R0, LSL #+2
   \   00000108   340099E5           LDR      R0,[R9, #+52]
   \   0000010C   08A181E0           ADD      R10,R1,R8, LSL #+2
   \   00000110   4C109AE5           LDR      R1,[R10, #+76]
   \   00000114   017080E0           ADD      R7,R0,R1
   \   00000118   0C009DE5           LDR      R0,[SP, #+12]
   \   0000011C   241099E5           LDR      R1,[R9, #+36]
   \   00000120   F000D0E1           LDRSH    R0,[R0, #+0]
   \   00000124   015050E0           SUBS     R5,R0,R1
   \   00000128   1C00001A           BNE      ??encode_mcu_7
   \   0000012C   0020A0E3           MOV      R2,#+0
   \   00000130   0710A0E1           MOV      R1,R7
   \   00000134   0400A0E1           MOV      R0,R4
   \   00000138   ........           BL       arith_encode
   \   0000013C   0000A0E3           MOV      R0,#+0
   \   00000140   340089E5           STR      R0,[R9, #+52]
   \                     ??encode_mcu_8:
   \   00000144   10109DE5           LDR      R1,[SP, #+16]
   \   00000148   4080A0E3           MOV      R8,#+64
   \   0000014C   181091E5           LDR      R1,[R1, #+24]
   \   00000150   14108DE5           STR      R1,[SP, #+20]
   \                     ??encode_mcu_9:
   \   00000154   ........           LDR      R0,??DataTable4  ;; jpeg_natural_order
   \   00000158   0C109DE5           LDR      R1,[SP, #+12]
   \   0000015C   080180E0           ADD      R0,R0,R8, LSL #+2
   \   00000160   040010E5           LDR      R0,[R0, #-4]
   \   00000164   800081E0           ADD      R0,R1,R0, LSL #+1
   \   00000168   F000D0E1           LDRSH    R0,[R0, #+0]
   \   0000016C   000050E3           CMP      R0,#+0
   \   00000170   0200001A           BNE      ??encode_mcu_10
   \   00000174   018048E2           SUB      R8,R8,#+1
   \   00000178   020058E3           CMP      R8,#+2
   \   0000017C   F4FFFFAA           BGE      ??encode_mcu_9
   \                     ??encode_mcu_10:
   \   00000180   14109DE5           LDR      R1,[SP, #+20]
   \   00000184   00209DE5           LDR      R2,[SP, #+0]
   \   00000188   01A0A0E3           MOV      R10,#+1
   \   0000018C   011182E0           ADD      R1,R2,R1, LSL #+2
   \   00000190   04108DE5           STR      R1,[SP, #+4]
   \   00000194   020058E3           CMP      R8,#+2
   \   00000198   4B0000AA           BGE      ??encode_mcu_11
   \   0000019C   BEFFFFEA           B        ??encode_mcu_6
   \                     ??encode_mcu_7:
   \   000001A0   0C009DE5           LDR      R0,[SP, #+12]
   \   000001A4   0120A0E3           MOV      R2,#+1
   \   000001A8   F000D0E1           LDRSH    R0,[R0, #+0]
   \   000001AC   0710A0E1           MOV      R1,R7
   \   000001B0   240089E5           STR      R0,[R9, #+36]
   \   000001B4   0400A0E1           MOV      R0,R4
   \   000001B8   ........           BL       arith_encode
   \   000001BC   010055E3           CMP      R5,#+1
   \   000001C0   060000BA           BLT      ??encode_mcu_12
   \   000001C4   0020A0E3           MOV      R2,#+0
   \   000001C8   011087E2           ADD      R1,R7,#+1
   \   000001CC   0400A0E1           MOV      R0,R4
   \   000001D0   ........           BL       arith_encode
   \   000001D4   02B087E2           ADD      R11,R7,#+2
   \   000001D8   0400A0E3           MOV      R0,#+4
   \   000001DC   060000EA           B        ??encode_mcu_13
   \                     ??encode_mcu_12:
   \   000001E0   005065E2           RSB      R5,R5,#+0
   \   000001E4   0120A0E3           MOV      R2,#+1
   \   000001E8   011087E2           ADD      R1,R7,#+1
   \   000001EC   0400A0E1           MOV      R0,R4
   \   000001F0   ........           BL       arith_encode
   \   000001F4   03B087E2           ADD      R11,R7,#+3
   \   000001F8   0800A0E3           MOV      R0,#+8
   \                     ??encode_mcu_13:
   \   000001FC   340089E5           STR      R0,[R9, #+52]
   \   00000200   0060A0E3           MOV      R6,#+0
   \   00000204   015055E2           SUBS     R5,R5,#+1
   \   00000208   1000000A           BEQ      ??encode_mcu_14
   \   0000020C   0120A0E3           MOV      R2,#+1
   \   00000210   0B10A0E1           MOV      R1,R11
   \   00000214   0400A0E1           MOV      R0,R4
   \   00000218   ........           BL       arith_encode
   \   0000021C   4C009AE5           LDR      R0,[R10, #+76]
   \   00000220   0160A0E3           MOV      R6,#+1
   \   00000224   0570A0E1           MOV      R7,R5
   \   00000228   14B080E2           ADD      R11,R0,#+20
   \   0000022C   050000EA           B        ??encode_mcu_15
   \                     ??encode_mcu_16:
   \   00000230   0120A0E3           MOV      R2,#+1
   \   00000234   0B10A0E1           MOV      R1,R11
   \   00000238   0400A0E1           MOV      R0,R4
   \   0000023C   ........           BL       arith_encode
   \   00000240   8660A0E1           LSL      R6,R6,#+1
   \   00000244   01B08BE2           ADD      R11,R11,#+1
   \                     ??encode_mcu_15:
   \   00000248   C770B0E1           ASRS     R7,R7,#+1
   \   0000024C   F7FFFF1A           BNE      ??encode_mcu_16
   \                     ??encode_mcu_14:
   \   00000250   0020A0E3           MOV      R2,#+0
   \   00000254   0B10A0E1           MOV      R1,R11
   \   00000258   0400A0E1           MOV      R0,R4
   \   0000025C   ........           BL       arith_encode
   \   00000260   041088E0           ADD      R1,R8,R4
   \   00000264   D419D1E1           LDRSB    R1,[R1, #+148]
   \   00000268   0100A0E3           MOV      R0,#+1
   \   0000026C   1011A0E1           LSL      R1,R0,R1
   \   00000270   C10056E1           CMP      R6,R1, ASR #+1
   \   00000274   0000A0B3           MOVLT    R0,#+0
   \   00000278   060000BA           BLT      ??encode_mcu_17
   \   0000027C   041088E0           ADD      R1,R8,R4
   \   00000280   D41AD1E1           LDRSB    R1,[R1, #+164]
   \   00000284   1001A0E1           LSL      R0,R0,R1
   \   00000288   C00056E1           CMP      R6,R0, ASR #+1
   \   0000028C   020000DA           BLE      ??encode_mcu_18
   \   00000290   340099E5           LDR      R0,[R9, #+52]
   \   00000294   080080E2           ADD      R0,R0,#+8
   \                     ??encode_mcu_17:
   \   00000298   340089E5           STR      R0,[R9, #+52]
   \                     ??encode_mcu_18:
   \   0000029C   0E708BE2           ADD      R7,R11,#+14
   \   000002A0   020000EA           B        ??encode_mcu_19
   \                     ??encode_mcu_20:
   \   000002A4   0710A0E1           MOV      R1,R7
   \   000002A8   0400A0E1           MOV      R0,R4
   \   000002AC   ........           BL       arith_encode
   \                     ??encode_mcu_19:
   \   000002B0   C660B0E1           ASRS     R6,R6,#+1
   \   000002B4   A2FFFF0A           BEQ      ??encode_mcu_8
   \   000002B8   060015E1           TST      R5,R6
   \   000002BC   0020A003           MOVEQ    R2,#+0
   \   000002C0   0120A013           MOVNE    R2,#+1
   \   000002C4   F6FFFFEA           B        ??encode_mcu_20
   \                     ??encode_mcu_21:
   \   000002C8   09A0A0E1           MOV      R10,R9
   \                     ??encode_mcu_11:
   \   000002CC   08005AE1           CMP      R10,R8
   \   000002D0   6FFFFFAA           BGE      ??encode_mcu_4
   \   000002D4   04109DE5           LDR      R1,[SP, #+4]
   \   000002D8   8A008AE0           ADD      R0,R10,R10, LSL #+1
   \   000002DC   8C1091E5           LDR      R1,[R1, #+140]
   \   000002E0   0020A0E3           MOV      R2,#+0
   \   000002E4   010080E0           ADD      R0,R0,R1
   \   000002E8   036040E2           SUB      R6,R0,#+3
   \   000002EC   0610A0E1           MOV      R1,R6
   \   000002F0   0400A0E1           MOV      R0,R4
   \   000002F4   ........           BL       arith_encode
   \   000002F8   050000EA           B        ??encode_mcu_22
   \                     ??encode_mcu_23:
   \   000002FC   0020A0E3           MOV      R2,#+0
   \   00000300   011086E2           ADD      R1,R6,#+1
   \   00000304   0400A0E1           MOV      R0,R4
   \   00000308   ........           BL       arith_encode
   \   0000030C   036086E2           ADD      R6,R6,#+3
   \   00000310   09A0A0E1           MOV      R10,R9
   \                     ??encode_mcu_22:
   \   00000314   ........           LDR      R0,??DataTable4  ;; jpeg_natural_order
   \   00000318   0C109DE5           LDR      R1,[SP, #+12]
   \   0000031C   0A0190E7           LDR      R0,[R0, +R10, LSL #+2]
   \   00000320   01908AE2           ADD      R9,R10,#+1
   \   00000324   800081E0           ADD      R0,R1,R0, LSL #+1
   \   00000328   F050D0E1           LDRSH    R5,[R0, #+0]
   \   0000032C   000055E3           CMP      R5,#+0
   \   00000330   F1FFFF0A           BEQ      ??encode_mcu_23
   \   00000334   0120A0E3           MOV      R2,#+1
   \   00000338   011086E2           ADD      R1,R6,#+1
   \   0000033C   0400A0E1           MOV      R0,R4
   \   00000340   ........           BL       arith_encode
   \   00000344   04009DE5           LDR      R0,[SP, #+4]
   \   00000348   0010A0E3           MOV      R1,#+0
   \   0000034C   8C0090E5           LDR      R0,[R0, #+140]
   \   00000350   010055E3           CMP      R5,#+1
   \   00000354   F510C0E5           STRB     R1,[R0, #+245]
   \   00000358   04009DE5           LDR      R0,[SP, #+4]
   \   0000035C   0020A0A3           MOVGE    R2,#+0
   \   00000360   8C0090E5           LDR      R0,[R0, #+140]
   \   00000364   005065B2           RSBLT    R5,R5,#+0
   \   00000368   0120A0B3           MOVLT    R2,#+1
   \   0000036C   F51080E2           ADD      R1,R0,#+245
   \   00000370   0400A0E1           MOV      R0,R4
   \   00000374   ........           BL       arith_encode
   \   00000378   02B086E2           ADD      R11,R6,#+2
   \   0000037C   0060A0E3           MOV      R6,#+0
   \   00000380   015055E2           SUBS     R5,R5,#+1
   \   00000384   1D00000A           BEQ      ??encode_mcu_24
   \   00000388   0120A0E3           MOV      R2,#+1
   \   0000038C   0B10A0E1           MOV      R1,R11
   \   00000390   0400A0E1           MOV      R0,R4
   \   00000394   ........           BL       arith_encode
   \   00000398   0160A0E3           MOV      R6,#+1
   \   0000039C   C570B0E1           ASRS     R7,R5,#+1
   \   000003A0   1600000A           BEQ      ??encode_mcu_24
   \   000003A4   0120A0E3           MOV      R2,#+1
   \   000003A8   0B10A0E1           MOV      R1,R11
   \   000003AC   0400A0E1           MOV      R0,R4
   \   000003B0   ........           BL       arith_encode
   \   000003B4   14009DE5           LDR      R0,[SP, #+20]
   \   000003B8   04109DE5           LDR      R1,[SP, #+4]
   \   000003BC   040080E0           ADD      R0,R0,R4
   \   000003C0   B400D0E5           LDRB     R0,[R0, #+180]
   \   000003C4   8C1091E5           LDR      R1,[R1, #+140]
   \   000003C8   0260A0E3           MOV      R6,#+2
   \   000003CC   0A0050E1           CMP      R0,R10
   \   000003D0   BD00A0A3           MOVGE    R0,#+189
   \   000003D4   D900A0B3           MOVLT    R0,#+217
   \   000003D8   01B080E0           ADD      R11,R0,R1
   \   000003DC   050000EA           B        ??encode_mcu_25
   \                     ??encode_mcu_26:
   \   000003E0   0120A0E3           MOV      R2,#+1
   \   000003E4   0B10A0E1           MOV      R1,R11
   \   000003E8   0400A0E1           MOV      R0,R4
   \   000003EC   ........           BL       arith_encode
   \   000003F0   8660A0E1           LSL      R6,R6,#+1
   \   000003F4   01B08BE2           ADD      R11,R11,#+1
   \                     ??encode_mcu_25:
   \   000003F8   C770B0E1           ASRS     R7,R7,#+1
   \   000003FC   F7FFFF1A           BNE      ??encode_mcu_26
   \                     ??encode_mcu_24:
   \   00000400   0020A0E3           MOV      R2,#+0
   \   00000404   0B10A0E1           MOV      R1,R11
   \   00000408   0400A0E1           MOV      R0,R4
   \   0000040C   ........           BL       arith_encode
   \   00000410   0E708BE2           ADD      R7,R11,#+14
   \   00000414   020000EA           B        ??encode_mcu_27
   \                     ??encode_mcu_28:
   \   00000418   0710A0E1           MOV      R1,R7
   \   0000041C   0400A0E1           MOV      R0,R4
   \   00000420   ........           BL       arith_encode
   \                     ??encode_mcu_27:
   \   00000424   C660B0E1           ASRS     R6,R6,#+1
   \   00000428   A6FFFF0A           BEQ      ??encode_mcu_21
   \   0000042C   060015E1           TST      R5,R6
   \   00000430   0020A003           MOVEQ    R2,#+0
   \   00000434   0120A013           MOVNE    R2,#+1
   \   00000438   F6FFFFEA           B        ??encode_mcu_28
    816          }
    817          
    818          
    819          /*
    820           * Initialize for an arithmetic-compressed scan.
    821           */
    822          

   \                                 In segment CODE, align 4, keep-with-next
    823          METHODDEF(void)
    824          start_pass (j_compress_ptr cinfo, boolean gather_statistics)
    825          {
   \                     start_pass:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    826            arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
   \   00000008   945194E5           LDR      R5,[R4, #+404]
    827            int ci, tbl;
    828            jpeg_component_info * compptr;
    829          
    830            if (gather_statistics)
   \   0000000C   000051E3           CMP      R1,#+0
   \   00000010   0600000A           BEQ      ??start_pass_0
    831              /* Make sure to avoid that in the master control logic!
    832               * We are fully adaptive here and need no extra
    833               * statistics gathering pass!
    834               */
    835              ERREXIT(cinfo, JERR_NOT_COMPILED);
   \   00000014   000094E5           LDR      R0,[R4, #+0]
   \   00000018   3110A0E3           MOV      R1,#+49
   \   0000001C   141080E5           STR      R1,[R0, #+20]
   \   00000020   001094E5           LDR      R1,[R4, #+0]
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   001091E5           LDR      R1,[R1, #+0]
   \   0000002C   31FF2FE1           BLX      R1
    836          
    837            /* We assume jcmaster.c already validated the progressive scan parameters. */
    838          
    839            /* Select execution routines */
    840            if (cinfo->progressive_mode) {
   \                     ??start_pass_0:
   \   00000030   040194E5           LDR      R0,[R4, #+260]
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   0B00000A           BEQ      ??start_pass_1
    841              if (cinfo->Ah == 0) {
   \   0000003C   6C0194E5           LDR      R0,[R4, #+364]
   \   00000040   000050E3           CMP      R0,#+0
   \   00000044   640194E5           LDR      R0,[R4, #+356]
   \   00000048   0300001A           BNE      ??start_pass_2
    842                if (cinfo->Ss == 0)
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   A8019F15           LDRNE    R0,??start_pass_3  ;; encode_mcu_AC_first
    843          	entropy->pub.encode_mcu = encode_mcu_DC_first;
   \   00000054   A8019F05           LDREQ    R0,??start_pass_3+0x4  ;; encode_mcu_DC_first
   \   00000058   040000EA           B        ??start_pass_4
    844                else
    845          	entropy->pub.encode_mcu = encode_mcu_AC_first;
    846              } else {
    847                if (cinfo->Ss == 0)
   \                     ??start_pass_2:
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   A0019F15           LDRNE    R0,??start_pass_3+0x8  ;; encode_mcu_AC_refine
    848          	entropy->pub.encode_mcu = encode_mcu_DC_refine;
   \   00000064   A0019F05           LDREQ    R0,??start_pass_3+0xC  ;; encode_mcu_DC_refine
   \   00000068   000000EA           B        ??start_pass_4
    849                else
    850          	entropy->pub.encode_mcu = encode_mcu_AC_refine;
    851              }
    852            } else
    853              entropy->pub.encode_mcu = encode_mcu;
   \                     ??start_pass_1:
   \   0000006C   9C019FE5           LDR      R0,??start_pass_3+0x10  ;; encode_mcu
    854          
    855            for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
   \                     ??start_pass_4:
   \   00000070   0070A0E3           MOV      R7,#+0
   \   00000074   040085E5           STR      R0,[R5, #+4]
   \   00000078   1C0194E5           LDR      R0,[R4, #+284]
   \   0000007C   0060A0E3           MOV      R6,#+0
   \   00000080   010050E3           CMP      R0,#+1
   \   00000084   3290A0E3           MOV      R9,#+50
   \   00000088   4C0000AA           BGE      ??start_pass_5
   \   0000008C   4E0000EA           B        ??start_pass_6
    856              compptr = cinfo->cur_comp_info[ci];
   \                     ??start_pass_7:
   \   00000090   070184E0           ADD      R0,R4,R7, LSL #+2
   \   00000094   208190E5           LDR      R8,[R0, #+288]
    857              /* Allocate & initialize requested statistics areas */
    858              if (cinfo->progressive_mode == 0 || (cinfo->Ss == 0 && cinfo->Ah == 0)) {
   \   00000098   040194E5           LDR      R0,[R4, #+260]
   \   0000009C   000050E3           CMP      R0,#+0
   \   000000A0   0400000A           BEQ      ??start_pass_8
   \   000000A4   640194E5           LDR      R0,[R4, #+356]
   \   000000A8   000050E3           CMP      R0,#+0
   \   000000AC   6C019405           LDREQ    R0,[R4, #+364]
   \   000000B0   00005003           CMPEQ    R0,#+0
   \   000000B4   1E00001A           BNE      ??start_pass_9
    859                tbl = compptr->dc_tbl_no;
   \                     ??start_pass_8:
   \   000000B8   14A098E5           LDR      R10,[R8, #+20]
    860                if (tbl < 0 || tbl >= NUM_ARITH_TBLS)
   \   000000BC   00005AE3           CMP      R10,#+0
   \   000000C0   0100004A           BMI      ??start_pass_10
   \   000000C4   10005AE3           CMP      R10,#+16
   \   000000C8   070000BA           BLT      ??start_pass_11
    861          	ERREXIT1(cinfo, JERR_NO_ARITH_TABLE, tbl);
   \                     ??start_pass_10:
   \   000000CC   000094E5           LDR      R0,[R4, #+0]
   \   000000D0   149080E5           STR      R9,[R0, #+20]
   \   000000D4   000094E5           LDR      R0,[R4, #+0]
   \   000000D8   18A080E5           STR      R10,[R0, #+24]
   \   000000DC   001094E5           LDR      R1,[R4, #+0]
   \   000000E0   0400A0E1           MOV      R0,R4
   \   000000E4   001091E5           LDR      R1,[R1, #+0]
   \   000000E8   31FF2FE1           BLX      R1
    862                if (entropy->dc_stats[tbl] == NULL)
   \                     ??start_pass_11:
   \   000000EC   0AA185E0           ADD      R10,R5,R10, LSL #+2
   \   000000F0   4C009AE5           LDR      R0,[R10, #+76]
   \   000000F4   000050E3           CMP      R0,#+0
   \   000000F8   0600001A           BNE      ??start_pass_12
    863          	entropy->dc_stats[tbl] = (unsigned char *) (*cinfo->mem->alloc_small)
    864          	  ((j_common_ptr) cinfo, JPOOL_IMAGE, DC_STAT_BINS);
   \   000000FC   043094E5           LDR      R3,[R4, #+4]
   \   00000100   4020A0E3           MOV      R2,#+64
   \   00000104   003093E5           LDR      R3,[R3, #+0]
   \   00000108   0110A0E3           MOV      R1,#+1
   \   0000010C   0400A0E1           MOV      R0,R4
   \   00000110   33FF2FE1           BLX      R3
   \   00000114   4C008AE5           STR      R0,[R10, #+76]
    865                MEMZERO(entropy->dc_stats[tbl], DC_STAT_BINS);
   \                     ??start_pass_12:
   \   00000118   4C009AE5           LDR      R0,[R10, #+76]
   \   0000011C   4020A0E3           MOV      R2,#+64
   \   00000120   0010A0E3           MOV      R1,#+0
   \   00000124   BB0000EF           SWI      +187
    866                /* Initialize DC predictions to 0 */
    867                entropy->last_dc_val[ci] = 0;
   \   00000128   070185E0           ADD      R0,R5,R7, LSL #+2
   \   0000012C   246080E5           STR      R6,[R0, #+36]
    868                entropy->dc_context[ci] = 0;
   \   00000130   346080E5           STR      R6,[R0, #+52]
    869              }
    870              if (cinfo->progressive_mode == 0 || cinfo->Ss) {
   \                     ??start_pass_9:
   \   00000134   040194E5           LDR      R0,[R4, #+260]
   \   00000138   000050E3           CMP      R0,#+0
   \   0000013C   0200000A           BEQ      ??start_pass_13
   \   00000140   640194E5           LDR      R0,[R4, #+356]
   \   00000144   000050E3           CMP      R0,#+0
   \   00000148   1B00000A           BEQ      ??start_pass_14
    871                tbl = compptr->ac_tbl_no;
   \                     ??start_pass_13:
   \   0000014C   18A098E5           LDR      R10,[R8, #+24]
    872                if (tbl < 0 || tbl >= NUM_ARITH_TBLS)
   \   00000150   00005AE3           CMP      R10,#+0
   \   00000154   0100004A           BMI      ??start_pass_15
   \   00000158   10005AE3           CMP      R10,#+16
   \   0000015C   070000BA           BLT      ??start_pass_16
    873          	ERREXIT1(cinfo, JERR_NO_ARITH_TABLE, tbl);
   \                     ??start_pass_15:
   \   00000160   000094E5           LDR      R0,[R4, #+0]
   \   00000164   149080E5           STR      R9,[R0, #+20]
   \   00000168   000094E5           LDR      R0,[R4, #+0]
   \   0000016C   18A080E5           STR      R10,[R0, #+24]
   \   00000170   001094E5           LDR      R1,[R4, #+0]
   \   00000174   0400A0E1           MOV      R0,R4
   \   00000178   001091E5           LDR      R1,[R1, #+0]
   \   0000017C   31FF2FE1           BLX      R1
    874                if (entropy->ac_stats[tbl] == NULL)
   \                     ??start_pass_16:
   \   00000180   0A8185E0           ADD      R8,R5,R10, LSL #+2
   \   00000184   8C0098E5           LDR      R0,[R8, #+140]
   \   00000188   000050E3           CMP      R0,#+0
   \   0000018C   0600001A           BNE      ??start_pass_17
    875          	entropy->ac_stats[tbl] = (unsigned char *) (*cinfo->mem->alloc_small)
    876          	  ((j_common_ptr) cinfo, JPOOL_IMAGE, AC_STAT_BINS);
   \   00000190   043094E5           LDR      R3,[R4, #+4]
   \   00000194   402FA0E3           MOV      R2,#+256
   \   00000198   003093E5           LDR      R3,[R3, #+0]
   \   0000019C   0110A0E3           MOV      R1,#+1
   \   000001A0   0400A0E1           MOV      R0,R4
   \   000001A4   33FF2FE1           BLX      R3
   \   000001A8   8C0088E5           STR      R0,[R8, #+140]
    877                MEMZERO(entropy->ac_stats[tbl], AC_STAT_BINS);
   \                     ??start_pass_17:
   \   000001AC   8C0098E5           LDR      R0,[R8, #+140]
   \   000001B0   402FA0E3           MOV      R2,#+256
   \   000001B4   0010A0E3           MOV      R1,#+0
   \   000001B8   BB0000EF           SWI      +187
    878          #ifdef CALCULATE_SPECTRAL_CONDITIONING
    879                if (cinfo->progressive_mode)
    880          	/* Section G.1.3.2: Set appropriate arithmetic conditioning value Kx */
    881          	cinfo->arith_ac_K[tbl] = cinfo->Ss + ((8 + cinfo->Se - cinfo->Ss) >> 4);
    882          #endif
    883              }
    884            }
   \                     ??start_pass_14:
   \   000001BC   017087E2           ADD      R7,R7,#+1
   \                     ??start_pass_5:
   \   000001C0   1C0194E5           LDR      R0,[R4, #+284]
   \   000001C4   000057E1           CMP      R7,R0
   \   000001C8   B0FFFFBA           BLT      ??start_pass_7
    885          
    886            /* Initialize arithmetic encoding variables */
    887            entropy->c = 0;
   \                     ??start_pass_6:
   \   000001CC   0C6085E5           STR      R6,[R5, #+12]
    888            entropy->a = 0x10000L;
   \   000001D0   400BA0E3           MOV      R0,#+65536
   \   000001D4   100085E5           STR      R0,[R5, #+16]
    889            entropy->sc = 0;
   \   000001D8   146085E5           STR      R6,[R5, #+20]
    890            entropy->zc = 0;
   \   000001DC   186085E5           STR      R6,[R5, #+24]
    891            entropy->ct = 11;
   \   000001E0   0B00A0E3           MOV      R0,#+11
   \   000001E4   1C0085E5           STR      R0,[R5, #+28]
    892            entropy->buffer = -1;  /* empty */
   \   000001E8   0600E0E1           MVN      R0,R6
   \   000001EC   200085E5           STR      R0,[R5, #+32]
    893          
    894            /* Initialize restart stuff */
    895            entropy->restarts_to_go = cinfo->restart_interval;
   \   000001F0   E80094E5           LDR      R0,[R4, #+232]
   \   000001F4   440085E5           STR      R0,[R5, #+68]
    896            entropy->next_restart_num = 0;
   \   000001F8   486085E5           STR      R6,[R5, #+72]
    897          }
   \   000001FC   F087BDE8           POP      {R4-R10,PC}      ;; return
   \                     ??start_pass_3:
   \   00000200   ........           DC32     encode_mcu_AC_first
   \   00000204   ........           DC32     encode_mcu_DC_first
   \   00000208   ........           DC32     encode_mcu_AC_refine
   \   0000020C   ........           DC32     encode_mcu_DC_refine
   \   00000210   ........           DC32     encode_mcu
    898          
    899          
    900          /*
    901           * Module initialization routine for arithmetic entropy encoding.
    902           */
    903          

   \                                 In segment CODE, align 4, keep-with-next
    904          GLOBAL(void)
    905          jinit_arith_encoder (j_compress_ptr cinfo)
    906          {
   \                     jinit_arith_encoder:
   \   00000000   10402DE9           PUSH     {R4,LR}
    907            arith_entropy_ptr entropy;
    908            int i;
    909          
    910            entropy = (arith_entropy_ptr)
    911              (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
    912          				SIZEOF(arith_entropy_encoder));
   \   00000004   CC20A0E3           MOV      R2,#+204
   \   00000008   0110A0E3           MOV      R1,#+1
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   043094E5           LDR      R3,[R4, #+4]
   \   00000014   003093E5           LDR      R3,[R3, #+0]
   \   00000018   33FF2FE1           BLX      R3
    913            cinfo->entropy = (struct jpeg_entropy_encoder *) entropy;
    914            entropy->pub.start_pass = start_pass;
   \   0000001C   30109FE5           LDR      R1,??jinit_arith_encoder_0  ;; start_pass
   \   00000020   940184E5           STR      R0,[R4, #+404]
   \   00000024   001080E5           STR      R1,[R0, #+0]
    915            entropy->pub.finish_pass = finish_pass;
   \   00000028   28109FE5           LDR      R1,??jinit_arith_encoder_0+0x4  ;; finish_pass
    916          
    917            /* Mark tables unallocated */
    918            for (i = 0; i < NUM_ARITH_TBLS; i++) {
   \   0000002C   0030A0E3           MOV      R3,#+0
   \   00000030   081080E5           STR      R1,[R0, #+8]
   \   00000034   0010A0E3           MOV      R1,#+0
    919              entropy->dc_stats[i] = NULL;
   \                     ??jinit_arith_encoder_1:
   \   00000038   012180E0           ADD      R2,R0,R1, LSL #+2
   \   0000003C   4C3082E5           STR      R3,[R2, #+76]
    920              entropy->ac_stats[i] = NULL;
   \   00000040   8C3082E5           STR      R3,[R2, #+140]
    921            }
   \   00000044   011081E2           ADD      R1,R1,#+1
   \   00000048   100051E3           CMP      R1,#+16
   \   0000004C   F9FFFFBA           BLT      ??jinit_arith_encoder_1
    922          }
   \   00000050   1080BDE8           POP      {R4,PC}          ;; return
   \                     ??jinit_arith_encoder_0:
   \   00000054   ........           DC32     start_pass
   \   00000058   ........           DC32     finish_pass

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   ........           DC32     jpeg_natural_order

   Maximum stack usage in bytes:

     Function             CSTACK
     --------             ------
     arith_encode            16
     emit_byte                8
     emit_restart            24
     encode_mcu              64
     encode_mcu_AC_first     48
     encode_mcu_AC_refine    36
     encode_mcu_DC_first     48
     encode_mcu_DC_refine    24
     finish_pass             12
     jinit_arith_encoder      8
     start_pass              32


   Segment part sizes:

     Function/Label       Bytes
     --------------       -----
     emit_byte              96
     finish_pass           548
     arith_encode          560
     emit_restart          248
     encode_mcu_DC_first   540
     encode_mcu_AC_first   688
     encode_mcu_DC_refine  180
     encode_mcu_AC_refine  540
     encode_mcu           1084
     start_pass            532
     jinit_arith_encoder    92
     ??DataTable4            4
      Others                44

 
 5 156 bytes in segment CODE
 
 5 112 bytes of CODE memory (+ 44 bytes shared)

Errors: none
Warnings: none
