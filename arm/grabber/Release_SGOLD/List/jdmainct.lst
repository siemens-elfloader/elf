##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    19/Jan/2011  13:21:06 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\grabber\jpeg-7\jdmainct.c                     #
#    Command line    =  C:\arm\grabber\jpeg-7\jdmainct.c -lC                 #
#                       C:\arm\grabber\Release_SGOLD\List\ -o                #
#                       C:\arm\grabber\Release_SGOLD\Obj\ -s9 --no_unroll    #
#                       --no_clustering --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --fpu None --dlib_config "C:\arm2\Embedded           #
#                       Workbench 4.0 Evaluation\ARM\LIB\dl5tpainl8n.h" -I   #
#                       "C:\arm2\Embedded Workbench 4.0                      #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  C:\arm\grabber\Release_SGOLD\List\jdmainct.lst       #
#    Object file     =  C:\arm\grabber\Release_SGOLD\Obj\jdmainct.r79        #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\grabber\jpeg-7\jdmainct.c
      1          /*
                  ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           * jdmainct.c
      3           *
      4           * Copyright (C) 1994-1996, Thomas G. Lane.
      5           * This file is part of the Independent JPEG Group's software.
      6           * For conditions of distribution and use, see the accompanying README file.
      7           *
      8           * This file contains the main buffer controller for decompression.
      9           * The main buffer lies between the JPEG decompressor proper and the
     10           * post-processor; it holds downsampled data in the JPEG colorspace.
     11           *
     12           * Note that this code is bypassed in raw-data mode, since the application
     13           * supplies the equivalent of the main buffer in that case.
     14           */
     15          
     16          #define JPEG_INTERNALS
     17          #include "jinclude.h"
     18          #include "jpeglib.h"
     19          
     20          
     21          /*
     22           * In the current system design, the main buffer need never be a full-image
     23           * buffer; any full-height buffers will be found inside the coefficient or
     24           * postprocessing controllers.  Nonetheless, the main controller is not
     25           * trivial.  Its responsibility is to provide context rows for upsampling/
     26           * rescaling, and doing this in an efficient fashion is a bit tricky.
     27           *
     28           * Postprocessor input data is counted in "row groups".  A row group
     29           * is defined to be (v_samp_factor * DCT_scaled_size / min_DCT_scaled_size)
     30           * sample rows of each component.  (We require DCT_scaled_size values to be
     31           * chosen such that these numbers are integers.  In practice DCT_scaled_size
     32           * values will likely be powers of two, so we actually have the stronger
     33           * condition that DCT_scaled_size / min_DCT_scaled_size is an integer.)
     34           * Upsampling will typically produce max_v_samp_factor pixel rows from each
     35           * row group (times any additional scale factor that the upsampler is
     36           * applying).
     37           *
     38           * The coefficient controller will deliver data to us one iMCU row at a time;
     39           * each iMCU row contains v_samp_factor * DCT_scaled_size sample rows, or
     40           * exactly min_DCT_scaled_size row groups.  (This amount of data corresponds
     41           * to one row of MCUs when the image is fully interleaved.)  Note that the
     42           * number of sample rows varies across components, but the number of row
     43           * groups does not.  Some garbage sample rows may be included in the last iMCU
     44           * row at the bottom of the image.
     45           *
     46           * Depending on the vertical scaling algorithm used, the upsampler may need
     47           * access to the sample row(s) above and below its current input row group.
     48           * The upsampler is required to set need_context_rows TRUE at global selection
     49           * time if so.  When need_context_rows is FALSE, this controller can simply
     50           * obtain one iMCU row at a time from the coefficient controller and dole it
     51           * out as row groups to the postprocessor.
     52           *
     53           * When need_context_rows is TRUE, this controller guarantees that the buffer
     54           * passed to postprocessing contains at least one row group's worth of samples
     55           * above and below the row group(s) being processed.  Note that the context
     56           * rows "above" the first passed row group appear at negative row offsets in
     57           * the passed buffer.  At the top and bottom of the image, the required
     58           * context rows are manufactured by duplicating the first or last real sample
     59           * row; this avoids having special cases in the upsampling inner loops.
     60           *
     61           * The amount of context is fixed at one row group just because that's a
     62           * convenient number for this controller to work with.  The existing
     63           * upsamplers really only need one sample row of context.  An upsampler
     64           * supporting arbitrary output rescaling might wish for more than one row
     65           * group of context when shrinking the image; tough, we don't handle that.
     66           * (This is justified by the assumption that downsizing will be handled mostly
     67           * by adjusting the DCT_scaled_size values, so that the actual scale factor at
     68           * the upsample step needn't be much less than one.)
     69           *
     70           * To provide the desired context, we have to retain the last two row groups
     71           * of one iMCU row while reading in the next iMCU row.  (The last row group
     72           * can't be processed until we have another row group for its below-context,
     73           * and so we have to save the next-to-last group too for its above-context.)
     74           * We could do this most simply by copying data around in our buffer, but
     75           * that'd be very slow.  We can avoid copying any data by creating a rather
     76           * strange pointer structure.  Here's how it works.  We allocate a workspace
     77           * consisting of M+2 row groups (where M = min_DCT_scaled_size is the number
     78           * of row groups per iMCU row).  We create two sets of redundant pointers to
     79           * the workspace.  Labeling the physical row groups 0 to M+1, the synthesized
     80           * pointer lists look like this:
     81           *                   M+1                          M-1
     82           * master pointer --> 0         master pointer --> 0
     83           *                    1                            1
     84           *                   ...                          ...
     85           *                   M-3                          M-3
     86           *                   M-2                           M
     87           *                   M-1                          M+1
     88           *                    M                           M-2
     89           *                   M+1                          M-1
     90           *                    0                            0
     91           * We read alternate iMCU rows using each master pointer; thus the last two
     92           * row groups of the previous iMCU row remain un-overwritten in the workspace.
     93           * The pointer lists are set up so that the required context rows appear to
     94           * be adjacent to the proper places when we pass the pointer lists to the
     95           * upsampler.
     96           *
     97           * The above pictures describe the normal state of the pointer lists.
     98           * At top and bottom of the image, we diddle the pointer lists to duplicate
     99           * the first or last sample row as necessary (this is cheaper than copying
    100           * sample rows around).
    101           *
    102           * This scheme breaks down if M < 2, ie, min_DCT_scaled_size is 1.  In that
    103           * situation each iMCU row provides only one row group so the buffering logic
    104           * must be different (eg, we must read two iMCU rows before we can emit the
    105           * first row group).  For now, we simply do not support providing context
    106           * rows when min_DCT_scaled_size is 1.  That combination seems unlikely to
    107           * be worth providing --- if someone wants a 1/8th-size preview, they probably
    108           * want it quick and dirty, so a context-free upsampler is sufficient.
    109           */
    110          
    111          
    112          /* Private buffer controller object */
    113          
    114          typedef struct {
    115            struct jpeg_d_main_controller pub; /* public fields */
    116          
    117            /* Pointer to allocated workspace (M or M+2 row groups). */
    118            JSAMPARRAY buffer[MAX_COMPONENTS];
    119          
    120            boolean buffer_full;		/* Have we gotten an iMCU row from decoder? */
    121            JDIMENSION rowgroup_ctr;	/* counts row groups output to postprocessor */
    122          
    123            /* Remaining fields are only used in the context case. */
    124          
    125            /* These are the master pointers to the funny-order pointer lists. */
    126            JSAMPIMAGE xbuffer[2];	/* pointers to weird pointer lists */
    127          
    128            int whichptr;			/* indicates which pointer set is now in use */
    129            int context_state;		/* process_data state machine status */
    130            JDIMENSION rowgroups_avail;	/* row groups available to postprocessor */
    131            JDIMENSION iMCU_row_ctr;	/* counts iMCU rows to detect image top/bot */
    132          } my_main_controller;
    133          
    134          typedef my_main_controller * my_main_ptr;
    135          
    136          /* context_state values: */
    137          #define CTX_PREPARE_FOR_IMCU	0	/* need to prepare for MCU row */
    138          #define CTX_PROCESS_IMCU	1	/* feeding iMCU to postprocessor */
    139          #define CTX_POSTPONED_ROW	2	/* feeding postponed row group */
    140          
    141          
    142          /* Forward declarations */
    143          METHODDEF(void) process_data_simple_main
    144          	JPP((j_decompress_ptr cinfo, JSAMPARRAY output_buf,
    145          	     JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail));
    146          METHODDEF(void) process_data_context_main
    147          	JPP((j_decompress_ptr cinfo, JSAMPARRAY output_buf,
    148          	     JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail));
    149          #ifdef QUANT_2PASS_SUPPORTED
    150          METHODDEF(void) process_data_crank_post
    151          	JPP((j_decompress_ptr cinfo, JSAMPARRAY output_buf,
    152          	     JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail));
    153          #endif
    154          
    155          

   \                                 In segment CODE, align 4, keep-with-next
    156          LOCAL(void)
    157          alloc_funny_pointers (j_decompress_ptr cinfo)
    158          /* Allocate space for the funny pointer lists.
    159           * This is done only once, not once per pass.
    160           */
    161          {
   \                     alloc_funny_pointers:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    162            my_main_ptr main = (my_main_ptr) cinfo->main;
   \   00000008   A85194E5           LDR      R5,[R4, #+424]
    163            int ci, rgroup;
    164            int M = cinfo->min_DCT_v_scaled_size;
    165            jpeg_component_info *compptr;
    166            JSAMPARRAY xbuf;
    167          
    168            /* Get top-level space for component array pointers.
    169             * We alloc both arrays with one call to save a few cycles.
    170             */
    171            main->xbuffer[0] = (JSAMPIMAGE)
    172              (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
    173          				cinfo->num_components * 2 * SIZEOF(JSAMPARRAY));
   \   0000000C   240094E5           LDR      R0,[R4, #+36]
   \   00000010   043094E5           LDR      R3,[R4, #+4]
   \   00000014   3C6194E5           LDR      R6,[R4, #+316]
   \   00000018   003093E5           LDR      R3,[R3, #+0]
   \   0000001C   8021A0E1           LSL      R2,R0,#+3
   \   00000020   0110A0E3           MOV      R1,#+1
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   33FF2FE1           BLX      R3
   \   0000002C   380085E5           STR      R0,[R5, #+56]
    174            main->xbuffer[1] = main->xbuffer[0] + cinfo->num_components;
   \   00000030   240094E5           LDR      R0,[R4, #+36]
   \   00000034   381095E5           LDR      R1,[R5, #+56]
    175          
    176            for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
   \   00000038   0070A0E3           MOV      R7,#+0
   \   0000003C   000181E0           ADD      R0,R1,R0, LSL #+2
   \   00000040   3C0085E5           STR      R0,[R5, #+60]
   \   00000044   240094E5           LDR      R0,[R4, #+36]
   \   00000048   D48094E5           LDR      R8,[R4, #+212]
   \   0000004C   010050E3           CMP      R0,#+1
   \   00000050   160000AA           BGE      ??alloc_funny_pointers_0
   \   00000054   F087BDE8           POP      {R4-R10,PC}
    177                 ci++, compptr++) {
    178              rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
    179                cinfo->min_DCT_v_scaled_size; /* height of a row group of component */
   \                     ??alloc_funny_pointers_1:
   \   00000058   0C0098E5           LDR      R0,[R8, #+12]
   \   0000005C   281098E5           LDR      R1,[R8, #+40]
    180              /* Get space for pointer lists --- M+4 row groups in each list.
    181               * We alloc both pointer lists with one call to save a few cycles.
    182               */
    183              xbuf = (JSAMPARRAY)
    184                (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
    185          				  2 * (rgroup * (M + 4)) * SIZEOF(JSAMPROW));
   \   00000060   043094E5           LDR      R3,[R4, #+4]
   \   00000064   910000E0           MUL      R0,R1,R0
   \   00000068   3C1194E5           LDR      R1,[R4, #+316]
   \   0000006C   003093E5           LDR      R3,[R3, #+0]
   \   00000070   ........           _BLF     ??div32_a,??rA??div32_a
   \   00000074   01A0A0E1           MOV      R10,R1
   \   00000078   040086E2           ADD      R0,R6,#+4
   \   0000007C   900A09E0           MUL      R9,R0,R10
   \   00000080   0110A0E3           MOV      R1,#+1
   \   00000084   8921A0E1           LSL      R2,R9,#+3
   \   00000088   0400A0E1           MOV      R0,R4
   \   0000008C   33FF2FE1           BLX      R3
    186              xbuf += rgroup;		/* want one row group at negative offsets */
    187              main->xbuffer[0][ci] = xbuf;
   \   00000090   381095E5           LDR      R1,[R5, #+56]
   \   00000094   0A0180E0           ADD      R0,R0,R10, LSL #+2
   \   00000098   070181E7           STR      R0,[R1, +R7, LSL #+2]
    188              xbuf += rgroup * (M + 4);
    189              main->xbuffer[1][ci] = xbuf;
   \   0000009C   3C1095E5           LDR      R1,[R5, #+60]
   \   000000A0   090180E0           ADD      R0,R0,R9, LSL #+2
   \   000000A4   070181E7           STR      R0,[R1, +R7, LSL #+2]
    190            }
   \   000000A8   017087E2           ADD      R7,R7,#+1
   \   000000AC   588088E2           ADD      R8,R8,#+88
   \                     ??alloc_funny_pointers_0:
   \   000000B0   240094E5           LDR      R0,[R4, #+36]
   \   000000B4   000057E1           CMP      R7,R0
   \   000000B8   E6FFFFBA           BLT      ??alloc_funny_pointers_1
    191          }
   \   000000BC   F087BDE8           POP      {R4-R10,PC}      ;; return
    192          
    193          

   \                                 In segment CODE, align 4, keep-with-next
    194          LOCAL(void)
    195          make_funny_pointers (j_decompress_ptr cinfo)
    196          /* Create the funny pointer lists discussed in the comments above.
    197           * The actual workspace is already allocated (in main->buffer),
    198           * and the space for the pointer lists is allocated too.
    199           * This routine just fills in the curiously ordered lists.
    200           * This will be repeated at the beginning of each pass.
    201           */
    202          {
   \                     make_funny_pointers:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0020A0E1           MOV      R2,R0
    203            my_main_ptr main = (my_main_ptr) cinfo->main;
    204            int ci, i, rgroup;
    205            int M = cinfo->min_DCT_v_scaled_size;
    206            jpeg_component_info *compptr;
    207            JSAMPARRAY buf, xbuf0, xbuf1;
    208          
    209            for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
   \   00000008   240092E5           LDR      R0,[R2, #+36]
   \   0000000C   A83192E5           LDR      R3,[R2, #+424]
   \   00000010   3C4192E5           LDR      R4,[R2, #+316]
   \   00000014   D46092E5           LDR      R6,[R2, #+212]
   \   00000018   0050A0E3           MOV      R5,#+0
   \   0000001C   010050E3           CMP      R0,#+1
   \   00000020   080000AA           BGE      ??make_funny_pointers_0
    210                 ci++, compptr++) {
    211              rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
    212                cinfo->min_DCT_v_scaled_size; /* height of a row group of component */
    213              xbuf0 = main->xbuffer[0][ci];
    214              xbuf1 = main->xbuffer[1][ci];
    215              /* First copy the workspace pointers as-is */
    216              buf = main->buffer[ci];
    217              for (i = 0; i < rgroup * (M + 2); i++) {
    218                xbuf0[i] = xbuf1[i] = buf[i];
    219              }
    220              /* In the second list, put the last four row groups in swapped order */
    221              for (i = 0; i < rgroup * 2; i++) {
    222                xbuf1[rgroup*(M-2) + i] = buf[rgroup*M + i];
    223                xbuf1[rgroup*M + i] = buf[rgroup*(M-2) + i];
    224              }
    225              /* The wraparound pointers at top and bottom will be filled later
    226               * (see set_wraparound_pointers, below).  Initially we want the "above"
    227               * pointers to duplicate the first actual data line.  This only needs
    228               * to happen in xbuffer[0].
    229               */
    230              for (i = 0; i < rgroup; i++) {
    231                xbuf0[i - rgroup] = xbuf0[0];
    232              }
    233            }
    234          }
   \   00000024   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??make_funny_pointers_1:
   \   00000028   009090E5           LDR      R9,[R0, #+0]
   \   0000002C   018047E0           SUB      R8,R7,R1
   \   00000030   089180E7           STR      R9,[R0, +R8, LSL #+2]
   \   00000034   017087E2           ADD      R7,R7,#+1
   \                     ??make_funny_pointers_2:
   \   00000038   010057E1           CMP      R7,R1
   \   0000003C   F9FFFFBA           BLT      ??make_funny_pointers_1
   \                     ??make_funny_pointers_3:
   \   00000040   015085E2           ADD      R5,R5,#+1
   \   00000044   586086E2           ADD      R6,R6,#+88
   \                     ??make_funny_pointers_0:
   \   00000048   240092E5           LDR      R0,[R2, #+36]
   \   0000004C   000055E1           CMP      R5,R0
   \   00000050   F08FBDA8           POPGE    {R4-R11,PC}
   \   00000054   0C0096E5           LDR      R0,[R6, #+12]
   \   00000058   281096E5           LDR      R1,[R6, #+40]
   \   0000005C   3C7093E5           LDR      R7,[R3, #+60]
   \   00000060   910000E0           MUL      R0,R1,R0
   \   00000064   3C1192E5           LDR      R1,[R2, #+316]
   \   00000068   029084E2           ADD      R9,R4,#+2
   \   0000006C   ........           _BLF     ??div32_a,??rA??div32_a
   \   00000070   380093E5           LDR      R0,[R3, #+56]
   \   00000074   05C197E7           LDR      R12,[R7, +R5, LSL #+2]
   \   00000078   050190E7           LDR      R0,[R0, +R5, LSL #+2]
   \   0000007C   990108E0           MUL      R8,R9,R1
   \   00000080   057183E0           ADD      R7,R3,R5, LSL #+2
   \   00000084   08E097E5           LDR      LR,[R7, #+8]
   \   00000088   0070A0E3           MOV      R7,#+0
   \   0000008C   010058E3           CMP      R8,#+1
   \   00000090   060000AA           BGE      ??make_funny_pointers_4
   \   00000094   070000EA           B        ??make_funny_pointers_5
   \                     ??make_funny_pointers_6:
   \   00000098   07A19EE7           LDR      R10,[LR, +R7, LSL #+2]
   \   0000009C   07918CE0           ADD      R9,R12,R7, LSL #+2
   \   000000A0   00A089E5           STR      R10,[R9, #+0]
   \   000000A4   0A90A0E1           MOV      R9,R10
   \   000000A8   079180E7           STR      R9,[R0, +R7, LSL #+2]
   \   000000AC   017087E2           ADD      R7,R7,#+1
   \                     ??make_funny_pointers_4:
   \   000000B0   080057E1           CMP      R7,R8
   \   000000B4   F7FFFFBA           BLT      ??make_funny_pointers_6
   \                     ??make_funny_pointers_5:
   \   000000B8   0070A0E3           MOV      R7,#+0
   \   000000BC   8180A0E1           LSL      R8,R1,#+1
   \   000000C0   010058E3           CMP      R8,#+1
   \   000000C4   080000AA           BGE      ??make_funny_pointers_7
   \   000000C8   090000EA           B        ??make_funny_pointers_8
   \                     ??make_funny_pointers_9:
   \   000000CC   02A044E2           SUB      R10,R4,#+2
   \   000000D0   9A7129E0           MLA      R9,R10,R1,R7
   \   000000D4   94712AE0           MLA      R10,R4,R1,R7
   \   000000D8   017087E2           ADD      R7,R7,#+1
   \   000000DC   0AB19EE7           LDR      R11,[LR, +R10, LSL #+2]
   \   000000E0   09B18CE7           STR      R11,[R12, +R9, LSL #+2]
   \   000000E4   09919EE7           LDR      R9,[LR, +R9, LSL #+2]
   \   000000E8   0A918CE7           STR      R9,[R12, +R10, LSL #+2]
   \                     ??make_funny_pointers_7:
   \   000000EC   080057E1           CMP      R7,R8
   \   000000F0   F5FFFFBA           BLT      ??make_funny_pointers_9
   \                     ??make_funny_pointers_8:
   \   000000F4   0070A0E3           MOV      R7,#+0
   \   000000F8   010051E3           CMP      R1,#+1
   \   000000FC   CDFFFFAA           BGE      ??make_funny_pointers_2
   \   00000100   CEFFFFEA           B        ??make_funny_pointers_3
    235          
    236          

   \                                 In segment CODE, align 4, keep-with-next
    237          LOCAL(void)
    238          set_wraparound_pointers (j_decompress_ptr cinfo)
    239          /* Set up the "wraparound" pointers at top and bottom of the pointer lists.
    240           * This changes the pointer list state from top-of-image to the normal state.
    241           */
    242          {
   \                     set_wraparound_pointers:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0020A0E1           MOV      R2,R0
    243            my_main_ptr main = (my_main_ptr) cinfo->main;
    244            int ci, i, rgroup;
    245            int M = cinfo->min_DCT_v_scaled_size;
    246            jpeg_component_info *compptr;
    247            JSAMPARRAY xbuf0, xbuf1;
    248          
    249            for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
   \   00000008   240092E5           LDR      R0,[R2, #+36]
   \   0000000C   A83192E5           LDR      R3,[R2, #+424]
   \   00000010   3C4192E5           LDR      R4,[R2, #+316]
   \   00000014   D46092E5           LDR      R6,[R2, #+212]
   \   00000018   0050A0E3           MOV      R5,#+0
   \   0000001C   010050E3           CMP      R0,#+1
   \   00000020   120000AA           BGE      ??set_wraparound_pointers_0
    250                 ci++, compptr++) {
    251              rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
    252                cinfo->min_DCT_v_scaled_size; /* height of a row group of component */
    253              xbuf0 = main->xbuffer[0][ci];
    254              xbuf1 = main->xbuffer[1][ci];
    255              for (i = 0; i < rgroup; i++) {
    256                xbuf0[i - rgroup] = xbuf0[rgroup*(M+1) + i];
    257                xbuf1[i - rgroup] = xbuf1[rgroup*(M+1) + i];
    258                xbuf0[rgroup*(M+2) + i] = xbuf0[i];
    259                xbuf1[rgroup*(M+2) + i] = xbuf1[i];
    260              }
    261            }
    262          }
   \   00000024   F083BDE8           POP      {R4-R9,PC}       ;; return
   \                     ??set_wraparound_pointers_1:
   \   00000028   018084E2           ADD      R8,R4,#+1
   \   0000002C   980127E0           MLA      R7,R8,R1,R0
   \   00000030   018040E0           SUB      R8,R0,R1
   \   00000034   07919CE7           LDR      R9,[R12, +R7, LSL #+2]
   \   00000038   08918CE7           STR      R9,[R12, +R8, LSL #+2]
   \   0000003C   07719EE7           LDR      R7,[LR, +R7, LSL #+2]
   \   00000040   08718EE7           STR      R7,[LR, +R8, LSL #+2]
   \   00000044   028084E2           ADD      R8,R4,#+2
   \   00000048   980127E0           MLA      R7,R8,R1,R0
   \   0000004C   00819CE7           LDR      R8,[R12, +R0, LSL #+2]
   \   00000050   07818CE7           STR      R8,[R12, +R7, LSL #+2]
   \   00000054   00819EE7           LDR      R8,[LR, +R0, LSL #+2]
   \   00000058   010080E2           ADD      R0,R0,#+1
   \   0000005C   07818EE7           STR      R8,[LR, +R7, LSL #+2]
   \                     ??set_wraparound_pointers_2:
   \   00000060   010050E1           CMP      R0,R1
   \   00000064   EFFFFFBA           BLT      ??set_wraparound_pointers_1
   \                     ??set_wraparound_pointers_3:
   \   00000068   015085E2           ADD      R5,R5,#+1
   \   0000006C   586086E2           ADD      R6,R6,#+88
   \                     ??set_wraparound_pointers_0:
   \   00000070   240092E5           LDR      R0,[R2, #+36]
   \   00000074   000055E1           CMP      R5,R0
   \   00000078   F083BDA8           POPGE    {R4-R9,PC}
   \   0000007C   0C0096E5           LDR      R0,[R6, #+12]
   \   00000080   281096E5           LDR      R1,[R6, #+40]
   \   00000084   910000E0           MUL      R0,R1,R0
   \   00000088   3C1192E5           LDR      R1,[R2, #+316]
   \   0000008C   ........           _BLF     ??div32_a,??rA??div32_a
   \   00000090   380093E5           LDR      R0,[R3, #+56]
   \   00000094   010051E3           CMP      R1,#+1
   \   00000098   05C190E7           LDR      R12,[R0, +R5, LSL #+2]
   \   0000009C   3C0093E5           LDR      R0,[R3, #+60]
   \   000000A0   05E190E7           LDR      LR,[R0, +R5, LSL #+2]
   \   000000A4   0000A0E3           MOV      R0,#+0
   \   000000A8   ECFFFFAA           BGE      ??set_wraparound_pointers_2
   \   000000AC   EDFFFFEA           B        ??set_wraparound_pointers_3
    263          
    264          

   \                                 In segment CODE, align 4, keep-with-next
    265          LOCAL(void)
    266          set_bottom_pointers (j_decompress_ptr cinfo)
    267          /* Change the pointer lists to duplicate the last sample row at the bottom
    268           * of the image.  whichptr indicates which xbuffer holds the final iMCU row.
    269           * Also sets rowgroups_avail to indicate number of nondummy row groups in row.
    270           */
    271          {
   \                     set_bottom_pointers:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0020A0E1           MOV      R2,R0
    272            my_main_ptr main = (my_main_ptr) cinfo->main;
    273            int ci, i, rgroup, iMCUheight, rows_left;
    274            jpeg_component_info *compptr;
    275            JSAMPARRAY xbuf;
    276          
    277            for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
   \   00000008   240092E5           LDR      R0,[R2, #+36]
   \   0000000C   A83192E5           LDR      R3,[R2, #+424]
   \   00000010   D45092E5           LDR      R5,[R2, #+212]
   \   00000014   0040A0E3           MOV      R4,#+0
   \   00000018   010050E3           CMP      R0,#+1
   \   0000001C   090000AA           BGE      ??set_bottom_pointers_0
    278                 ci++, compptr++) {
    279              /* Count sample rows in one iMCU row and in one row group */
    280              iMCUheight = compptr->v_samp_factor * compptr->DCT_v_scaled_size;
    281              rgroup = iMCUheight / cinfo->min_DCT_v_scaled_size;
    282              /* Count nondummy sample rows remaining for this component */
    283              rows_left = (int) (compptr->downsampled_height % (JDIMENSION) iMCUheight);
    284              if (rows_left == 0) rows_left = iMCUheight;
    285              /* Count nondummy row groups.  Should get same answer for each component,
    286               * so we need only do it once.
    287               */
    288              if (ci == 0) {
    289                main->rowgroups_avail = (JDIMENSION) ((rows_left-1) / rgroup + 1);
    290              }
    291              /* Duplicate the last real sample row rgroup*2 times; this pads out the
    292               * last partial rowgroup and ensures at least one full rowgroup of context.
    293               */
    294              xbuf = main->xbuffer[main->whichptr][ci];
    295              for (i = 0; i < rgroup * 2; i++) {
    296                xbuf[rows_left + i] = xbuf[rows_left-1];
    297              }
    298            }
    299          }
   \   00000020   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??set_bottom_pointers_1:
   \   00000024   06C180E0           ADD      R12,R0,R6, LSL #+2
   \   00000028   04C01CE5           LDR      R12,[R12, #-4]
   \   0000002C   068081E0           ADD      R8,R1,R6
   \   00000030   08C180E7           STR      R12,[R0, +R8, LSL #+2]
   \   00000034   011081E2           ADD      R1,R1,#+1
   \                     ??set_bottom_pointers_2:
   \   00000038   070051E1           CMP      R1,R7
   \   0000003C   F8FFFFBA           BLT      ??set_bottom_pointers_1
   \                     ??set_bottom_pointers_3:
   \   00000040   014084E2           ADD      R4,R4,#+1
   \   00000044   585085E2           ADD      R5,R5,#+88
   \                     ??set_bottom_pointers_0:
   \   00000048   240092E5           LDR      R0,[R2, #+36]
   \   0000004C   000054E1           CMP      R4,R0
   \   00000050   F081BDA8           POPGE    {R4-R8,PC}
   \   00000054   0C0095E5           LDR      R0,[R5, #+12]
   \   00000058   281095E5           LDR      R1,[R5, #+40]
   \   0000005C   910008E0           MUL      R8,R1,R0
   \   00000060   3C1192E5           LDR      R1,[R2, #+316]
   \   00000064   0800A0E1           MOV      R0,R8
   \   00000068   ........           _BLF     ??div32_a,??rA??div32_a
   \   0000006C   300095E5           LDR      R0,[R5, #+48]
   \   00000070   0170A0E1           MOV      R7,R1
   \   00000074   0810A0E1           MOV      R1,R8
   \   00000078   ........           _BLF     ??divu32_a,??rA??divu32_a
   \   0000007C   0060B0E1           MOVS     R6,R0
   \   00000080   0860A001           MOVEQ    R6,R8
   \   00000084   000054E3           CMP      R4,#+0
   \   00000088   0400001A           BNE      ??set_bottom_pointers_4
   \   0000008C   010046E2           SUB      R0,R6,#+1
   \   00000090   0710A0E1           MOV      R1,R7
   \   00000094   ........           _BLF     ??div32_a,??rA??div32_a
   \   00000098   010081E2           ADD      R0,R1,#+1
   \   0000009C   480083E5           STR      R0,[R3, #+72]
   \                     ??set_bottom_pointers_4:
   \   000000A0   400093E5           LDR      R0,[R3, #+64]
   \   000000A4   0010A0E3           MOV      R1,#+0
   \   000000A8   000183E0           ADD      R0,R3,R0, LSL #+2
   \   000000AC   380090E5           LDR      R0,[R0, #+56]
   \   000000B0   8770A0E1           LSL      R7,R7,#+1
   \   000000B4   040190E7           LDR      R0,[R0, +R4, LSL #+2]
   \   000000B8   010057E3           CMP      R7,#+1
   \   000000BC   DDFFFFAA           BGE      ??set_bottom_pointers_2
   \   000000C0   DEFFFFEA           B        ??set_bottom_pointers_3
    300          
    301          
    302          /*
    303           * Initialize for a processing pass.
    304           */
    305          

   \                                 In segment CODE, align 4, keep-with-next
    306          METHODDEF(void)
    307          start_pass_main (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
    308          {
   \                     start_pass_main:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0020A0E1           MOV      R2,R0
    309            my_main_ptr main = (my_main_ptr) cinfo->main;
   \   00000008   A84192E5           LDR      R4,[R2, #+424]
    310          
    311            switch (pass_mode) {
   \   0000000C   000051E3           CMP      R1,#+0
   \   00000010   0200000A           BEQ      ??start_pass_main_0
   \   00000014   021051E2           SUBS     R1,R1,#+2
   \   00000018   1400000A           BEQ      ??start_pass_main_1
   \   0000001C   160000EA           B        ??start_pass_main_2
    312            case JBUF_PASS_THRU:
    313              if (cinfo->upsample->need_context_rows) {
   \                     ??start_pass_main_0:
   \   00000020   C40192E5           LDR      R0,[R2, #+452]
   \   00000024   0050A0E3           MOV      R5,#+0
   \   00000028   080090E5           LDR      R0,[R0, #+8]
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   0900000A           BEQ      ??start_pass_main_3
    314                main->pub.process_data = process_data_context_main;
   \   00000034   60009FE5           LDR      R0,??start_pass_main_4  ;; process_data_context_main
   \   00000038   040084E5           STR      R0,[R4, #+4]
    315                make_funny_pointers(cinfo); /* Create the xbuffer[] lists */
   \   0000003C   0200A0E1           MOV      R0,R2
   \   00000040   ........           BL       make_funny_pointers
    316                main->whichptr = 0;	/* Read first iMCU row into xbuffer[0] */
   \   00000044   405084E5           STR      R5,[R4, #+64]
    317                main->context_state = CTX_PREPARE_FOR_IMCU;
   \   00000048   445084E5           STR      R5,[R4, #+68]
    318                main->iMCU_row_ctr = 0;
   \   0000004C   4C5084E5           STR      R5,[R4, #+76]
   \   00000050   305084E5           STR      R5,[R4, #+48]
   \   00000054   345084E5           STR      R5,[R4, #+52]
   \   00000058   3080BDE8           POP      {R4,R5,PC}
    319              } else {
    320                /* Simple case with no context needed */
    321                main->pub.process_data = process_data_simple_main;
   \                     ??start_pass_main_3:
   \   0000005C   3C009FE5           LDR      R0,??start_pass_main_4+0x4  ;; process_data_simple_main
   \   00000060   040084E5           STR      R0,[R4, #+4]
    322              }
    323              main->buffer_full = FALSE;	/* Mark buffer empty */
   \   00000064   305084E5           STR      R5,[R4, #+48]
    324              main->rowgroup_ctr = 0;
   \   00000068   345084E5           STR      R5,[R4, #+52]
   \   0000006C   3080BDE8           POP      {R4,R5,PC}
    325              break;
    326          #ifdef QUANT_2PASS_SUPPORTED
    327            case JBUF_CRANK_DEST:
    328              /* For last pass of 2-pass quantization, just crank the postprocessor */
    329              main->pub.process_data = process_data_crank_post;
   \                     ??start_pass_main_1:
   \   00000070   2C009FE5           LDR      R0,??start_pass_main_4+0x8  ;; process_data_crank_post
   \   00000074   040084E5           STR      R0,[R4, #+4]
   \   00000078   3080BDE8           POP      {R4,R5,PC}
    330              break;
    331          #endif
    332            default:
    333              ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
   \                     ??start_pass_main_2:
   \   0000007C   000092E5           LDR      R0,[R2, #+0]
   \   00000080   0310A0E3           MOV      R1,#+3
   \   00000084   141080E5           STR      R1,[R0, #+20]
   \   00000088   001092E5           LDR      R1,[R2, #+0]
   \   0000008C   0200A0E1           MOV      R0,R2
   \   00000090   001091E5           LDR      R1,[R1, #+0]
   \   00000094   31FF2FE1           BLX      R1
    334              break;
    335            }
    336          }
   \   00000098   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??start_pass_main_4:
   \   0000009C   ........           DC32     process_data_context_main
   \   000000A0   ........           DC32     process_data_simple_main
   \   000000A4   ........           DC32     process_data_crank_post
    337          
    338          
    339          /*
    340           * Process some data.
    341           * This handles the simple case where no context is required.
    342           */
    343          

   \                                 In segment CODE, align 4, keep-with-next
    344          METHODDEF(void)
    345          process_data_simple_main (j_decompress_ptr cinfo,
    346          			  JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
    347          			  JDIMENSION out_rows_avail)
    348          {
   \                     process_data_simple_main:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0050A0E1           MOV      R5,R0
    349            my_main_ptr main = (my_main_ptr) cinfo->main;
   \   00000008   A84195E5           LDR      R4,[R5, #+424]
   \   0000000C   0160A0E1           MOV      R6,R1
    350            JDIMENSION rowgroups_avail;
    351          
    352            /* Read input data if we haven't filled the main buffer yet */
    353            if (! main->buffer_full) {
   \   00000010   300094E5           LDR      R0,[R4, #+48]
   \   00000014   0270A0E1           MOV      R7,R2
   \   00000018   0380A0E1           MOV      R8,R3
   \   0000001C   000050E3           CMP      R0,#+0
   \   00000020   0800001A           BNE      ??process_data_simple_main_0
    354              if (! (*cinfo->coef->decompress_data) (cinfo, main->buffer))
   \   00000024   AC2195E5           LDR      R2,[R5, #+428]
   \   00000028   081084E2           ADD      R1,R4,#+8
   \   0000002C   0C2092E5           LDR      R2,[R2, #+12]
   \   00000030   0500A0E1           MOV      R0,R5
   \   00000034   32FF2FE1           BLX      R2
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   F083BD08           POPEQ    {R4-R9,PC}
    355                return;			/* suspension forced, can do nothing more */
    356              main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
   \   00000040   0100A0E3           MOV      R0,#+1
   \   00000044   300084E5           STR      R0,[R4, #+48]
    357            }
    358          
    359            /* There are always min_DCT_scaled_size row groups in an iMCU row. */
    360            rowgroups_avail = (JDIMENSION) cinfo->min_DCT_v_scaled_size;
   \                     ??process_data_simple_main_0:
   \   00000048   3C9195E5           LDR      R9,[R5, #+316]
    361            /* Note: at the bottom of the image, we may pass extra garbage row groups
    362             * to the postprocessor.  The postprocessor has to check for bottom
    363             * of image anyway (at row resolution), so no point in us doing it too.
    364             */
    365          
    366            /* Feed the postprocessor */
    367            (*cinfo->post->post_process_data) (cinfo, main->buffer,
    368          				     &main->rowgroup_ctr, rowgroups_avail,
    369          				     output_buf, out_row_ctr, out_rows_avail);
   \   0000004C   00012DE9           PUSH     {R8}
   \   00000050   80002DE9           PUSH     {R7}
   \   00000054   40002DE9           PUSH     {R6}
   \   00000058   0500A0E1           MOV      R0,R5
   \   0000005C   B05195E5           LDR      R5,[R5, #+432]
   \   00000060   0930A0E1           MOV      R3,R9
   \   00000064   045095E5           LDR      R5,[R5, #+4]
   \   00000068   342084E2           ADD      R2,R4,#+52
   \   0000006C   081084E2           ADD      R1,R4,#+8
   \   00000070   35FF2FE1           BLX      R5
    370          
    371            /* Has postprocessor consumed all the data yet? If so, mark buffer empty */
    372            if (main->rowgroup_ctr >= rowgroups_avail) {
   \   00000074   340094E5           LDR      R0,[R4, #+52]
   \   00000078   0CD08DE2           ADD      SP,SP,#+12
   \   0000007C   090050E1           CMP      R0,R9
    373              main->buffer_full = FALSE;
   \   00000080   0000A023           MOVCS    R0,#+0
   \   00000084   30008425           STRCS    R0,[R4, #+48]
    374              main->rowgroup_ctr = 0;
   \   00000088   34008425           STRCS    R0,[R4, #+52]
   \   0000008C   F083BDE8           POP      {R4-R9,PC}       ;; return
    375            }
    376          }
    377          
    378          
    379          /*
    380           * Process some data.
    381           * This handles the case where context rows must be provided.
    382           */
    383          

   \                                 In segment CODE, align 4, keep-with-next
    384          METHODDEF(void)
    385          process_data_context_main (j_decompress_ptr cinfo,
    386          			   JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
    387          			   JDIMENSION out_rows_avail)
    388          {
   \                     process_data_context_main:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    389            my_main_ptr main = (my_main_ptr) cinfo->main;
   \   00000008   A88194E5           LDR      R8,[R4, #+424]
   \   0000000C   0150A0E1           MOV      R5,R1
    390          
    391            /* Read input data if we haven't filled the main buffer yet */
    392            if (! main->buffer_full) {
   \   00000010   300098E5           LDR      R0,[R8, #+48]
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   0370A0E1           MOV      R7,R3
   \   0000001C   0190A0E3           MOV      R9,#+1
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0C00001A           BNE      ??process_data_context_main_0
    393              if (! (*cinfo->coef->decompress_data) (cinfo,
    394          					   main->xbuffer[main->whichptr]))
   \   00000028   400098E5           LDR      R0,[R8, #+64]
   \   0000002C   AC2194E5           LDR      R2,[R4, #+428]
   \   00000030   000188E0           ADD      R0,R8,R0, LSL #+2
   \   00000034   381090E5           LDR      R1,[R0, #+56]
   \   00000038   0C2092E5           LDR      R2,[R2, #+12]
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   32FF2FE1           BLX      R2
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   F087BD08           POPEQ    {R4-R10,PC}
    395                return;			/* suspension forced, can do nothing more */
    396              main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
   \   0000004C   309088E5           STR      R9,[R8, #+48]
    397              main->iMCU_row_ctr++;	/* count rows received */
   \   00000050   4C0098E5           LDR      R0,[R8, #+76]
   \   00000054   010080E2           ADD      R0,R0,#+1
   \   00000058   4C0088E5           STR      R0,[R8, #+76]
    398            }
    399          
    400            /* Postprocessor typically will not swallow all the input data it is handed
    401             * in one call (due to filling the output buffer first).  Must be prepared
    402             * to exit and restart.  This switch lets us keep track of how far we got.
    403             * Note that each case falls through to the next on successful completion.
    404             */
    405            switch (main->context_state) {
   \                     ??process_data_context_main_0:
   \   0000005C   440098E5           LDR      R0,[R8, #+68]
   \   00000060   00A0A0E3           MOV      R10,#+0
   \   00000064   000050E3           CMP      R0,#+0
   \   00000068   1B00000A           BEQ      ??process_data_context_main_1
   \   0000006C   010050E2           SUBS     R0,R0,#+1
   \   00000070   2400000A           BEQ      ??process_data_context_main_2
   \   00000074   010050E2           SUBS     R0,R0,#+1
   \   00000078   F087BD18           POPNE    {R4-R10,PC}
    406            case CTX_POSTPONED_ROW:
    407              /* Call postprocessor using previously set pointers for postponed row */
    408              (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],
    409          			&main->rowgroup_ctr, main->rowgroups_avail,
    410          			output_buf, out_row_ctr, out_rows_avail);
   \   0000007C   0700A0E1           MOV      R0,R7
   \   00000080   01002DE9           PUSH     {R0}
   \   00000084   342088E2           ADD      R2,R8,#+52
   \   00000088   0600A0E1           MOV      R0,R6
   \   0000008C   01002DE9           PUSH     {R0}
   \   00000090   0500A0E1           MOV      R0,R5
   \   00000094   01002DE9           PUSH     {R0}
   \   00000098   B0C194E5           LDR      R12,[R4, #+432]
   \   0000009C   483098E5           LDR      R3,[R8, #+72]
   \   000000A0   04C09CE5           LDR      R12,[R12, #+4]
   \   000000A4   400098E5           LDR      R0,[R8, #+64]
   \   000000A8   000188E0           ADD      R0,R8,R0, LSL #+2
   \   000000AC   381090E5           LDR      R1,[R0, #+56]
   \   000000B0   0400A0E1           MOV      R0,R4
   \   000000B4   3CFF2FE1           BLX      R12
    411              if (main->rowgroup_ctr < main->rowgroups_avail)
   \   000000B8   340098E5           LDR      R0,[R8, #+52]
   \   000000BC   481098E5           LDR      R1,[R8, #+72]
   \   000000C0   0CD08DE2           ADD      SP,SP,#+12
   \   000000C4   010050E1           CMP      R0,R1
   \   000000C8   F087BD38           POPCC    {R4-R10,PC}
    412                return;			/* Need to suspend */
    413              main->context_state = CTX_PREPARE_FOR_IMCU;
   \   000000CC   44A088E5           STR      R10,[R8, #+68]
    414              if (*out_row_ctr >= out_rows_avail)
   \   000000D0   000096E5           LDR      R0,[R6, #+0]
   \   000000D4   070050E1           CMP      R0,R7
   \   000000D8   F087BD28           POPCS    {R4-R10,PC}
    415                return;			/* Postprocessor exactly filled output buf */
    416              /*FALLTHROUGH*/
    417            case CTX_PREPARE_FOR_IMCU:
    418              /* Prepare to process first M-1 row groups of this iMCU row */
    419              main->rowgroup_ctr = 0;
   \                     ??process_data_context_main_1:
   \   000000DC   34A088E5           STR      R10,[R8, #+52]
    420              main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_v_scaled_size - 1);
   \   000000E0   3C0194E5           LDR      R0,[R4, #+316]
   \   000000E4   010040E2           SUB      R0,R0,#+1
   \   000000E8   480088E5           STR      R0,[R8, #+72]
    421              /* Check for bottom of image: if so, tweak pointers to "duplicate"
    422               * the last sample row, and adjust rowgroups_avail to ignore padding rows.
    423               */
    424              if (main->iMCU_row_ctr == cinfo->total_iMCU_rows)
   \   000000EC   4C0098E5           LDR      R0,[R8, #+76]
   \   000000F0   401194E5           LDR      R1,[R4, #+320]
   \   000000F4   010050E1           CMP      R0,R1
   \   000000F8   0100001A           BNE      ??process_data_context_main_3
    425                set_bottom_pointers(cinfo);
   \   000000FC   0400A0E1           MOV      R0,R4
   \   00000100   ........           BL       set_bottom_pointers
    426              main->context_state = CTX_PROCESS_IMCU;
   \                     ??process_data_context_main_3:
   \   00000104   449088E5           STR      R9,[R8, #+68]
    427              /*FALLTHROUGH*/
    428            case CTX_PROCESS_IMCU:
    429              /* Call postprocessor using previously set pointers */
    430              (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],
    431          			&main->rowgroup_ctr, main->rowgroups_avail,
    432          			output_buf, out_row_ctr, out_rows_avail);
   \                     ??process_data_context_main_2:
   \   00000108   80002DE9           PUSH     {R7}
   \   0000010C   40002DE9           PUSH     {R6}
   \   00000110   20002DE9           PUSH     {R5}
   \   00000114   400098E5           LDR      R0,[R8, #+64]
   \   00000118   483098E5           LDR      R3,[R8, #+72]
   \   0000011C   B05194E5           LDR      R5,[R4, #+432]
   \   00000120   342088E2           ADD      R2,R8,#+52
   \   00000124   045095E5           LDR      R5,[R5, #+4]
   \   00000128   000188E0           ADD      R0,R8,R0, LSL #+2
   \   0000012C   381090E5           LDR      R1,[R0, #+56]
   \   00000130   0400A0E1           MOV      R0,R4
   \   00000134   35FF2FE1           BLX      R5
    433              if (main->rowgroup_ctr < main->rowgroups_avail)
   \   00000138   340098E5           LDR      R0,[R8, #+52]
   \   0000013C   481098E5           LDR      R1,[R8, #+72]
   \   00000140   0CD08DE2           ADD      SP,SP,#+12
   \   00000144   010050E1           CMP      R0,R1
   \   00000148   F087BD38           POPCC    {R4-R10,PC}
    434                return;			/* Need to suspend */
    435              /* After the first iMCU, change wraparound pointers to normal state */
    436              if (main->iMCU_row_ctr == 1)
   \   0000014C   4C0098E5           LDR      R0,[R8, #+76]
   \   00000150   010050E3           CMP      R0,#+1
   \   00000154   0100001A           BNE      ??process_data_context_main_4
    437                set_wraparound_pointers(cinfo);
   \   00000158   0400A0E1           MOV      R0,R4
   \   0000015C   ........           BL       set_wraparound_pointers
    438              /* Prepare to load new iMCU row using other xbuffer list */
    439              main->whichptr ^= 1;	/* 0=>1 or 1=>0 */
   \                     ??process_data_context_main_4:
   \   00000160   400098E5           LDR      R0,[R8, #+64]
   \   00000164   010020E2           EOR      R0,R0,#0x1
   \   00000168   400088E5           STR      R0,[R8, #+64]
    440              main->buffer_full = FALSE;
   \   0000016C   30A088E5           STR      R10,[R8, #+48]
    441              /* Still need to process last row group of this iMCU row, */
    442              /* which is saved at index M+1 of the other xbuffer */
    443              main->rowgroup_ctr = (JDIMENSION) (cinfo->min_DCT_v_scaled_size + 1);
   \   00000170   3C0194E5           LDR      R0,[R4, #+316]
   \   00000174   010080E2           ADD      R0,R0,#+1
   \   00000178   340088E5           STR      R0,[R8, #+52]
    444              main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_v_scaled_size + 2);
   \   0000017C   3C0194E5           LDR      R0,[R4, #+316]
   \   00000180   020080E2           ADD      R0,R0,#+2
   \   00000184   480088E5           STR      R0,[R8, #+72]
    445              main->context_state = CTX_POSTPONED_ROW;
   \   00000188   0200A0E3           MOV      R0,#+2
   \   0000018C   440088E5           STR      R0,[R8, #+68]
   \   00000190   F087BDE8           POP      {R4-R10,PC}      ;; return
    446            }
    447          }
    448          
    449          
    450          /*
    451           * Process some data.
    452           * Final pass of two-pass quantization: just call the postprocessor.
    453           * Source data will be the postprocessor controller's internal buffer.
    454           */
    455          
    456          #ifdef QUANT_2PASS_SUPPORTED
    457          

   \                                 In segment CODE, align 4, keep-with-next
    458          METHODDEF(void)
    459          process_data_crank_post (j_decompress_ptr cinfo,
    460          			 JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
    461          			 JDIMENSION out_rows_avail)
    462          {
   \                     process_data_crank_post:
   \   00000000   00402DE9           PUSH     {LR}
    463            (*cinfo->post->post_process_data) (cinfo, (JSAMPIMAGE) NULL,
    464          				     (JDIMENSION *) NULL, (JDIMENSION) 0,
    465          				     output_buf, out_row_ctr, out_rows_avail);
   \   00000004   08002DE9           PUSH     {R3}
   \   00000008   04002DE9           PUSH     {R2}
   \   0000000C   02002DE9           PUSH     {R1}
   \   00000010   B0C190E5           LDR      R12,[R0, #+432]
   \   00000014   0030A0E3           MOV      R3,#+0
   \   00000018   04C09CE5           LDR      R12,[R12, #+4]
   \   0000001C   0020A0E3           MOV      R2,#+0
   \   00000020   0210A0E1           MOV      R1,R2
   \   00000024   3CFF2FE1           BLX      R12
    466          }
   \   00000028   0780BDE8           POP      {R0-R2,PC}       ;; return
    467          
    468          #endif /* QUANT_2PASS_SUPPORTED */
    469          
    470          
    471          /*
    472           * Initialize main buffer controller.
    473           */
    474          

   \                                 In segment CODE, align 4, keep-with-next
    475          GLOBAL(void)
    476          jinit_d_main_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
    477          {
   \                     jinit_d_main_controller:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    478            my_main_ptr main;
    479            int ci, rgroup, ngroups;
    480            jpeg_component_info *compptr;
    481          
    482            main = (my_main_ptr)
    483              (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
    484          				SIZEOF(my_main_controller));
   \   00000008   043094E5           LDR      R3,[R4, #+4]
   \   0000000C   0160A0E1           MOV      R6,R1
   \   00000010   003093E5           LDR      R3,[R3, #+0]
   \   00000014   5020A0E3           MOV      R2,#+80
   \   00000018   0110A0E3           MOV      R1,#+1
   \   0000001C   33FF2FE1           BLX      R3
   \   00000020   0050A0E1           MOV      R5,R0
    485            cinfo->main = (struct jpeg_d_main_controller *) main;
    486            main->pub.start_pass = start_pass_main;
   \   00000024   E0009FE5           LDR      R0,??jinit_d_main_controller_0  ;; start_pass_main
   \   00000028   A85184E5           STR      R5,[R4, #+424]
   \   0000002C   000085E5           STR      R0,[R5, #+0]
    487          
    488            if (need_full_buffer)		/* shouldn't happen */
   \   00000030   000056E3           CMP      R6,#+0
   \   00000034   0600000A           BEQ      ??jinit_d_main_controller_1
    489              ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
   \   00000038   000094E5           LDR      R0,[R4, #+0]
   \   0000003C   0310A0E3           MOV      R1,#+3
   \   00000040   141080E5           STR      R1,[R0, #+20]
   \   00000044   001094E5           LDR      R1,[R4, #+0]
   \   00000048   0400A0E1           MOV      R0,R4
   \   0000004C   001091E5           LDR      R1,[R1, #+0]
   \   00000050   31FF2FE1           BLX      R1
    490          
    491            /* Allocate the workspace.
    492             * ngroups is the number of row groups we need.
    493             */
    494            if (cinfo->upsample->need_context_rows) {
   \                     ??jinit_d_main_controller_1:
   \   00000054   C40194E5           LDR      R0,[R4, #+452]
   \   00000058   3C6194E5           LDR      R6,[R4, #+316]
   \   0000005C   080090E5           LDR      R0,[R0, #+8]
   \   00000060   000050E3           CMP      R0,#+0
   \   00000064   0C00000A           BEQ      ??jinit_d_main_controller_2
    495              if (cinfo->min_DCT_v_scaled_size < 2) /* unsupported, see comments above */
   \   00000068   020056E3           CMP      R6,#+2
   \   0000006C   060000AA           BGE      ??jinit_d_main_controller_3
    496                ERREXIT(cinfo, JERR_NOTIMPL);
   \   00000070   000094E5           LDR      R0,[R4, #+0]
   \   00000074   3010A0E3           MOV      R1,#+48
   \   00000078   141080E5           STR      R1,[R0, #+20]
   \   0000007C   001094E5           LDR      R1,[R4, #+0]
   \   00000080   0400A0E1           MOV      R0,R4
   \   00000084   001091E5           LDR      R1,[R1, #+0]
   \   00000088   31FF2FE1           BLX      R1
    497              alloc_funny_pointers(cinfo); /* Alloc space for xbuffer[] lists */
   \                     ??jinit_d_main_controller_3:
   \   0000008C   0400A0E1           MOV      R0,R4
   \   00000090   ........           BL       alloc_funny_pointers
    498              ngroups = cinfo->min_DCT_v_scaled_size + 2;
   \   00000094   3C0194E5           LDR      R0,[R4, #+316]
   \   00000098   026080E2           ADD      R6,R0,#+2
    499            } else {
    500              ngroups = cinfo->min_DCT_v_scaled_size;
    501            }
    502          
    503            for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
   \                     ??jinit_d_main_controller_2:
   \   0000009C   240094E5           LDR      R0,[R4, #+36]
   \   000000A0   D48094E5           LDR      R8,[R4, #+212]
   \   000000A4   0070A0E3           MOV      R7,#+0
   \   000000A8   010050E3           CMP      R0,#+1
   \   000000AC   120000AA           BGE      ??jinit_d_main_controller_4
   \   000000B0   F081BDE8           POP      {R4-R8,PC}
    504                 ci++, compptr++) {
    505              rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
    506                cinfo->min_DCT_v_scaled_size; /* height of a row group of component */
    507              main->buffer[ci] = (*cinfo->mem->alloc_sarray)
    508          			((j_common_ptr) cinfo, JPOOL_IMAGE,
    509          			 compptr->width_in_blocks * compptr->DCT_h_scaled_size,
    510          			 (JDIMENSION) (rgroup * ngroups));
   \                     ??jinit_d_main_controller_5:
   \   000000B4   0C0098E5           LDR      R0,[R8, #+12]
   \   000000B8   281098E5           LDR      R1,[R8, #+40]
   \   000000BC   910000E0           MUL      R0,R1,R0
   \   000000C0   3C1194E5           LDR      R1,[R4, #+316]
   \   000000C4   ........           _BLF     ??div32_a,??rA??div32_a
   \   000000C8   1C0098E5           LDR      R0,[R8, #+28]
   \   000000CC   04C094E5           LDR      R12,[R4, #+4]
   \   000000D0   960103E0           MUL      R3,R6,R1
   \   000000D4   241098E5           LDR      R1,[R8, #+36]
   \   000000D8   08C09CE5           LDR      R12,[R12, #+8]
   \   000000DC   910002E0           MUL      R2,R1,R0
   \   000000E0   0110A0E3           MOV      R1,#+1
   \   000000E4   0400A0E1           MOV      R0,R4
   \   000000E8   3CFF2FE1           BLX      R12
   \   000000EC   071185E0           ADD      R1,R5,R7, LSL #+2
   \   000000F0   080081E5           STR      R0,[R1, #+8]
    511            }
   \   000000F4   017087E2           ADD      R7,R7,#+1
   \   000000F8   588088E2           ADD      R8,R8,#+88
   \                     ??jinit_d_main_controller_4:
   \   000000FC   240094E5           LDR      R0,[R4, #+36]
   \   00000100   000057E1           CMP      R7,R0
   \   00000104   EAFFFFBA           BLT      ??jinit_d_main_controller_5
    512          }
   \   00000108   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??jinit_d_main_controller_0:
   \   0000010C   ........           DC32     start_pass_main

   Maximum stack usage in bytes:

     Function                  CSTACK
     --------                  ------
     alloc_funny_pointers         32
     jinit_d_main_controller      24
     make_funny_pointers          36
     process_data_context_main    44
     process_data_crank_post      16
     process_data_simple_main     40
     set_bottom_pointers          24
     set_wraparound_pointers      28
     start_pass_main              12


   Segment part sizes:

     Function/Label            Bytes
     --------------            -----
     alloc_funny_pointers       192
     make_funny_pointers        260
     set_wraparound_pointers    176
     set_bottom_pointers        196
     start_pass_main            168
     process_data_simple_main   144
     process_data_context_main  404
     process_data_crank_post     44
     jinit_d_main_controller    272
      Others                     60

 
 1 916 bytes in segment CODE
 
 1 856 bytes of CODE memory (+ 60 bytes shared)

Errors: none
Warnings: 1
