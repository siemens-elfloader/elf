##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    19/Jan/2011  13:20:37 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\grabber\zlib\gzio.c                           #
#    Command line    =  C:\arm\grabber\zlib\gzio.c -lC                       #
#                       C:\arm\grabber\Release_SGOLD\List\ -o                #
#                       C:\arm\grabber\Release_SGOLD\Obj\ -s9 --no_unroll    #
#                       --no_clustering --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --fpu None --dlib_config "C:\arm2\Embedded           #
#                       Workbench 4.0 Evaluation\ARM\LIB\dl5tpainl8n.h" -I   #
#                       "C:\arm2\Embedded Workbench 4.0                      #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  C:\arm\grabber\Release_SGOLD\List\gzio.lst           #
#    Object file     =  C:\arm\grabber\Release_SGOLD\Obj\gzio.r79            #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\grabber\zlib\gzio.c
      1          /* gzio.c -- IO on .gz files
      2           * Copyright (C) 1995-2002 Jean-loup Gailly.
      3           * For conditions of distribution and use, see copyright notice in zlib.h
      4           *
      5           * Compile this file with -DNO_DEFLATE to avoid the compression code.
      6           */
      7          
      8          /* @(#) $Id$ */
      9          
     10          #include <swilib.h>
     11          
     12          #include "zutil.h"

  typedef unsigned char  Byte;  /* 8 bits */
                         ^
"C:\arm\grabber\zlib\zconf.h",214  Warning[Pe301]: typedef name has already
          been declared (with same type)

  typedef unsigned int   uInt;  /* 16 bits or more */
                         ^
"C:\arm\grabber\zlib\zconf.h",216  Warning[Pe301]: typedef name has already
          been declared (with same type)

  typedef unsigned long  uLong; /* 32 bits or more */
                         ^
"C:\arm\grabber\zlib\zconf.h",217  Warning[Pe301]: typedef name has already
          been declared (with same type)

     typedef Byte  FAR Bytef;
                       ^
"C:\arm\grabber\zlib\zconf.h",223  Warning[Pe301]: typedef name has already
          been declared (with same type)

  typedef char  FAR charf;
                    ^
"C:\arm\grabber\zlib\zconf.h",225  Warning[Pe301]: typedef name has already
          been declared (with same type)

  typedef int   FAR intf;
                    ^
"C:\arm\grabber\zlib\zconf.h",226  Warning[Pe301]: typedef name has already
          been declared (with same type)

  typedef uInt  FAR uIntf;
                    ^
"C:\arm\grabber\zlib\zconf.h",227  Warning[Pe301]: typedef name has already
          been declared (with same type)

  typedef uLong FAR uLongf;
                    ^
"C:\arm\grabber\zlib\zconf.h",228  Warning[Pe301]: typedef name has already
          been declared (with same type)

     typedef void FAR *voidpf;
                       ^
"C:\arm\grabber\zlib\zconf.h",231  Warning[Pe301]: typedef name has already
          been declared (with same type)

     typedef void     *voidp;
                       ^
"C:\arm\grabber\zlib\zconf.h",232  Warning[Pe301]: typedef name has already
          been declared (with same type)

  #define ZLIB_VERSION "1.1.4"
          ^
"C:\arm\grabber\zlib\zlib.h",40  Warning[Pe047]: incompatible redefinition of
          macro "ZLIB_VERSION" (declared at line 10 of "C:\arm2\Embedded
          Workbench 4.0 Evaluation\ARM\INC\zlib.h")

  typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
                   ^
"C:\arm\grabber\zlib\zlib.h",63  Warning[Pe301]: typedef name has already been
          declared (with same type)

  typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
                   ^
"C:\arm\grabber\zlib\zlib.h",64  Warning[Pe301]: typedef name has already been
          declared (with same type)

  typedef struct z_stream_s {
                 ^
"C:\arm\grabber\zlib\zlib.h",68  Error[Pe101]: "z_stream_s" has already been
          declared in the current scope

  } z_stream;
    ^
"C:\arm\grabber\zlib\zlib.h",87  Error[Pe101]: "z_stream" has already been
          declared in the current scope

  typedef z_stream FAR *z_streamp;
                        ^
"C:\arm\grabber\zlib\zlib.h",89  Error[Pe101]: "z_streamp" has already been
          declared in the current scope

  #define Z_ASCII    1
          ^
"C:\arm\grabber\zlib\zlib.h",157  Warning[Pe047]: incompatible redefinition of
          macro "Z_ASCII" (declared at line 102 of "C:\arm2\Embedded Workbench
          4.0 Evaluation\ARM\INC\zlib.h")

  ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
                      ^
"C:\arm\grabber\zlib\zlib.h",201  Error[Pe147]: declaration is incompatible
          with "int deflate(z_streamp, int)" (declared at line 120 of
          "C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\zlib.h")

  ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
                      ^
"C:\arm\grabber\zlib\zlib.h",279  Error[Pe147]: declaration is incompatible
          with "int deflateEnd(z_streamp)" (declared at line 123 of
          "C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\zlib.h")

  ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
                      ^
"C:\arm\grabber\zlib\zlib.h",314  Error[Pe147]: declaration is incompatible
          with "int inflate(z_streamp, int)" (declared at line 126 of
          "C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\zlib.h")

  ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
                      ^
"C:\arm\grabber\zlib\zlib.h",383  Error[Pe147]: declaration is incompatible
          with "int inflateEnd(z_streamp)" (declared at line 129 of
          "C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\zlib.h")

  ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
                      ^
"C:\arm\grabber\zlib\zlib.h",444  Error[Pe147]: declaration is incompatible
          with "int deflateSetDictionary(z_streamp, Byte const *, uInt)"
          (declared at line 132 of "C:\arm2\Embedded Workbench 4.0
          Evaluation\ARM\INC\zlib.h")

  ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
                      ^
"C:\arm\grabber\zlib\zlib.h",480  Error[Pe147]: declaration is incompatible
          with "int deflateCopy(z_streamp, z_streamp)" (declared at line 136
          of "C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\zlib.h")

  ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
                      ^
"C:\arm\grabber\zlib\zlib.h",498  Error[Pe147]: declaration is incompatible
          with "int deflateReset(z_streamp)" (declared at line 139 of
          "C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\zlib.h")

  ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
                      ^
"C:\arm\grabber\zlib\zlib.h",509  Error[Pe147]: declaration is incompatible
          with "int deflateParams(z_streamp, int, int)" (declared at line 142
          of "C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\zlib.h")

  ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
                      ^
"C:\arm\grabber\zlib\zlib.h",553  Error[Pe147]: declaration is incompatible
          with "int inflateSetDictionary(z_streamp, Byte const *)" (declared
          at line 165 of "C:\arm2\Embedded Workbench 4.0
          Evaluation\ARM\INC\zlib.h")

  ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
                      ^
"C:\arm\grabber\zlib\zlib.h",587  Error[Pe147]: declaration is incompatible
          with "int inflateReset(z_streamp)" (declared at line 172 of
          "C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\zlib.h")

  typedef voidp gzFile;
                ^
"C:\arm\grabber\zlib\zlib.h",657  Warning[Pe301]: typedef name has already
          been declared (with same type)

  ZEXTERN int ZEXPORT    gzwrite OF((gzFile file, 
                         ^
"C:\arm\grabber\zlib\zlib.h",704  Error[Pe147]: declaration is incompatible
          with "int gzwrite(voidp, voidpc, unsigned int)" (declared at line
          222 of "C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\zlib.h")

  ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
                      ^
"C:\arm\grabber\zlib\zlib.h",860  Error[Pe147]: declaration is incompatible
          with "int deflateInit_(z_streamp, int, char const *, int)" (declared
          at line 285 of "C:\arm2\Embedded Workbench 4.0
          Evaluation\ARM\INC\zlib.h")

  ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
                      ^
"C:\arm\grabber\zlib\zlib.h",862  Error[Pe147]: declaration is incompatible
          with "int inflateInit_(z_streamp, char const *, int)" (declared at
          line 287 of "C:\arm2\Embedded Workbench 4.0
          Evaluation\ARM\INC\zlib.h")

  ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
                      ^
"C:\arm\grabber\zlib\zlib.h",864  Error[Pe147]: declaration is incompatible
          with "int deflateInit2_(z_streamp, int, int, int, int, int, char
          const *, int)" (declared at line 289 of "C:\arm2\Embedded Workbench
          4.0 Evaluation\ARM\INC\zlib.h")

  ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
                      ^
"C:\arm\grabber\zlib\zlib.h",868  Error[Pe147]: declaration is incompatible
          with "int inflateInit2_(z_streamp, int, char const *, int)"
          (declared at line 2590 of "C:\arm2\Embedded Workbench 4.0
          Evaluation\ARM\INC\swilib.h")

  ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
                                 ^
"C:\arm\grabber\zlib\zlib.h",886  Error[Pe147]: declaration is incompatible
          with "int inflateSyncPoint(z_streamp)" (declared at line 318 of
          "C:\arm2\Embedded Workbench 4.0 Evaluation\ARM\INC\zlib.h")
     13          
     14          
     15          
     16          int ftell(int fp)
     17          {
     18            return(lseek(fp,0,S_CUR,0,0));
     19          }
     20          
     21          
     22          
     23          
     24          
     25          
     26          
     27          struct internal_state {int dummy;}; /* for buggy compilers */
                        ^
Error[Pe101]: "internal_state" has already been declared in the current scope
     28          
     29          #ifndef Z_BUFSIZE
     30          #  ifdef MAXSEG_64K
     31          #    define Z_BUFSIZE 4096 /* minimize memory usage for 16-bit DOS */
     32          #  else
     33          #    define Z_BUFSIZE 16384
     34          #  endif
     35          #endif
     36          #ifndef Z_PRINTF_BUFSIZE
     37          #  define Z_PRINTF_BUFSIZE 4096
     38          #endif
     39          
     40          #define ALLOC(size) malloc(size)
     41          #define TRYFREE(p) {if (p) mfree(p);}
     42          
     43          static int gz_magic[2] = {0x1f, 0x8b}; /* gzip magic header */
     44          
     45          /* gzip flag byte */
     46          #define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */
     47          #define HEAD_CRC     0x02 /* bit 1 set: header CRC present */
     48          #define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
     49          #define ORIG_NAME    0x08 /* bit 3 set: original file name present */
     50          #define COMMENT      0x10 /* bit 4 set: file comment present */
     51          #define RESERVED     0xE0 /* bits 5..7: reserved */
     52          
     53          typedef struct gz_stream {
     54              z_stream stream;
     55              int      z_err;   /* error code for last stream operation */
     56              int      z_eof;   /* set if end of input file */
     57              int     file;   /* .gz file */
     58              Byte     *inbuf;  /* input buffer */
     59              Byte     *outbuf; /* output buffer */
     60              uLong    crc;     /* crc32 of uncompressed data */
     61              char     *msg;    /* error message */
     62              char     *path;   /* path name for debugging only */
     63              int      transparent; /* 1 if input file is not a .gz file */
     64              char     mode;    /* 'w' or 'r' */
     65              long     startpos; /* start of compressed data in file (header skipped) */
     66          } gz_stream;
     67          
     68          
     69          local gzFile gz_open      OF((const char *path, const char *mode, int  fd));
     70          local int do_flush        OF((gzFile file, int flush));
     71          local int    get_byte     OF((gz_stream *s));
     72          local void   check_header OF((gz_stream *s));
     73          local int    destroy      OF((gz_stream *s));
     74          local void   putLong      OF((int file, uLong x));
     75          local uLong  getLong      OF((gz_stream *s));
     76          
     77          /* ===========================================================================
     78               Opens a gzip (.gz) file for reading or writing. The mode parameter
     79             is as in fopen ("rb" or "wb"). The file is given either by file descriptor
     80             or path name (if fd == -1).
     81               gz_open return NULL if the file could not be opened or if there was
     82             insufficient memory to allocate the (de)compression state; errno
     83             can be checked to distinguish the two cases (if errno is zero, the
     84             zlib error is Z_MEM_ERROR).
     85          */
     86          local gzFile gz_open (path, mode, fd)
     87              const char *path;
     88              const char *mode;
     89              int  fd;
     90          {
     91              int err;
     92              int level = Z_DEFAULT_COMPRESSION; /* compression level */
     93              int strategy = Z_DEFAULT_STRATEGY; /* compression strategy */
     94              char *p = (char*)mode;
     95              gz_stream *s;
     96              char fmode[80]; /* copy of mode, without the compression level */
     97              char *m = fmode;
     98          
     99              if (!path || !mode) return Z_NULL;
    100          
    101              s = (gz_stream *)ALLOC(sizeof(gz_stream));
    102              if (!s) return Z_NULL;
    103          
    104              s->stream.zalloc = (alloc_func)0;
    105              s->stream.zfree = (free_func)0;
    106              s->stream.opaque = (voidpf)0;
    107              s->stream.next_in = s->inbuf = Z_NULL;
    108              s->stream.next_out = s->outbuf = Z_NULL;
    109              s->stream.avail_in = s->stream.avail_out = 0;
    110              s->file = NULL;
    111              s->z_err = Z_OK;
    112              s->z_eof = 0;
    113              s->crc = crc32(0L, Z_NULL, 0);
    114              s->msg = NULL;
    115              s->transparent = 0;
    116          
    117              s->path = (char*)ALLOC(strlen(path)+1);
    118              if (s->path == NULL) {
    119                  return destroy(s), (gzFile)Z_NULL;
    120              }
    121              strcpy(s->path, path); /* do this early for debugging */
    122          
    123              s->mode = '\0';
    124              do {
    125                  if (*p == 'r') s->mode = 'r';
    126                  if (*p == 'w' || *p == 'a') s->mode = 'w';
    127                  if (*p >= '0' && *p <= '9') {
    128          	    level = *p - '0';
    129          	} else if (*p == 'f') {
    130          	  strategy = Z_FILTERED;
    131          	} else if (*p == 'h') {
    132          	  strategy = Z_HUFFMAN_ONLY;
    133          	} else {
    134          	    *m++ = *p; /* copy the mode */
    135          	}
    136              } while (*p++ && m != fmode + sizeof(fmode));
    137              if (s->mode == '\0') return destroy(s), (gzFile)Z_NULL;
    138              
    139              if (s->mode == 'w') {
    140          #ifdef NO_DEFLATE
    141                  err = Z_STREAM_ERROR;
    142          #else
    143                  err = deflateInit2(&(s->stream), level,
    144                                     Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL, strategy);
    145                  /* windowBits is passed < 0 to suppress zlib header */
    146          
    147                  s->stream.next_out = s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);
    148          #endif
    149                  if (err != Z_OK || s->outbuf == Z_NULL) {
    150                      return destroy(s), (gzFile)Z_NULL;
    151                  }
    152              } else {
    153                  s->stream.next_in  = s->inbuf = (Byte*)ALLOC(Z_BUFSIZE);
    154          
    155                  err = inflateInit2(&(s->stream), -MAX_WBITS);
    156                  /* windowBits is passed < 0 to tell that there is no zlib header.
    157                   * Note that in this case inflate *requires* an extra "dummy" byte
    158                   * after the compressed stream in order to complete decompression and
    159                   * return Z_STREAM_END. Here the gzip CRC32 ensures that 4 bytes are
    160                   * present after the compressed stream.
    161                   */
    162                  if (err != Z_OK || s->inbuf == Z_NULL) {
    163                      return destroy(s), (gzFile)Z_NULL;
    164                  }
    165              }
    166              s->stream.avail_out = Z_BUFSIZE;
    167          
    168              //errno = 0;
    169              //s->file = fd=0 ? F_OPEN(path, fmode) : (FILE*)fdopen(fd, fmode);
    170              s->file = fopenA(path,A_ReadWrite+A_BIN,P_READ+P_WRITE,0);
                               ^
Warning[Pe223]: function "fopenA" declared implicitly
    171          
    172              if (s->file == -1)
    173              {
    174                  return destroy(s),(gzFile)Z_NULL;
    175              }
    176              if (s->mode == 'w')
    177              {
    178                  /* Write a very simple .gz header:
    179                   */
    180                char b_f[16];
    181                sprintf(b_f,"%c%c%c%c%c%c%c%c%c%c", gz_magic[0], gz_magic[1],Z_DEFLATED, 0 /*flags*/, 0,0,0,0 /*time*/, 0 /*xflags*/, OS_CODE);
    182                fwrite(s->file,b_f,10,0);
    183                  
    184          	s->startpos = 10L;
    185          	/* We use 10L instead of ftell(s->file) to because ftell causes an
    186                   * fflush on some systems. This version of the library doesn't use
    187                   * startpos anyway in write mode, so this initialization is not
    188                   * necessary.
    189                   */
    190              }
    191              else 
    192              {
    193          	check_header(s); /* skip the .gz header */
    194          	s->startpos = (ftell(s->file) - s->stream.avail_in);
    195              }
    196              
    197              return (gzFile)s;
    198          }
    199          
    200          /* ===========================================================================
    201               Opens a gzip (.gz) file for reading or writing.
    202          */
    203          gzFile ZEXPORT gzopen (path, mode)
    204              const char *path;
    205              const char *mode;
    206          {
    207              return gz_open (path, mode, -1);
    208          }
    209          
    210          /* ===========================================================================
    211               Associate a gzFile with the file descriptor fd. fd is not dup'ed here
    212             to mimic the behavio(u)r of fdopen.
    213          */
    214          gzFile ZEXPORT gzdopen (fd, mode)
    215              int fd;
    216              const char *mode;
    217          {
    218              char name[20];
    219          
    220              if (fd < 0) return (gzFile)Z_NULL;
    221              sprintf(name, "<fd:%d>", fd); /* for debugging */
    222          
    223              return gz_open (name, mode, fd);
    224          }
    225          
    226          /* ===========================================================================
    227           * Update the compression level and strategy
    228           */
    229          int ZEXPORT gzsetparams (file, level, strategy)
    230              gzFile file;
    231              int level;
    232              int strategy;
    233          {
    234              gz_stream *s = (gz_stream*)file;
    235          
    236              if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;
    237          
    238              /* Make room to allow flushing */
    239              if (s->stream.avail_out == 0)
    240              {
    241          
    242          	s->stream.next_out = s->outbuf;
    243          	if(fwrite(s->file,s->outbuf,Z_BUFSIZE,0) != Z_BUFSIZE)
    244                  {
    245          	    s->z_err = Z_ERRNO;
    246          	}
    247          	s->stream.avail_out = Z_BUFSIZE;
    248              }
    249          
    250              return deflateParams (&(s->stream), level, strategy);
    251          }
    252          
    253          /* ===========================================================================
    254               Read a byte from a gz_stream; update next_in and avail_in. Return EOF
    255             for end of file.
    256             IN assertion: the stream s has been sucessfully opened for reading.
    257          */
    258          local int get_byte(s)
    259              gz_stream *s;
    260          {
    261              if (s->z_eof) return NULL;
    262              if (s->stream.avail_in == 0)
    263              {
    264          	//errno = 0;
    265          	s->stream.avail_in = (uInt)fread(s->file,s->inbuf,Z_BUFSIZE,0); // JL 03/24/2002 - silenced a warning about typeconversion
    266          	if (s->stream.avail_in == 0)
    267                  {
    268          	    s->z_eof = 1;
    269          	    if(s->file==-1) s->z_err = Z_ERRNO;
    270          	    return NULL;
    271          	}
    272          	s->stream.next_in = s->inbuf;
    273              }
    274              s->stream.avail_in--;
    275              return *(s->stream.next_in)++;
    276          }
    277          
    278          /* ===========================================================================
    279                Check the gzip header of a gz_stream opened for reading. Set the stream
    280              mode to transparent if the gzip magic header is not present; set s->err
    281              to Z_DATA_ERROR if the magic header is present but the rest of the header
    282              is incorrect.
    283              IN assertion: the stream s has already been created sucessfully;
    284                 s->stream.avail_in is zero for the first time, but may be non-zero
    285                 for concatenated .gz files.
    286          */
    287          local void check_header(s)
    288              gz_stream *s;
    289          {
    290              int method; /* method byte */
    291              int flags;  /* flags byte */
    292              uInt len;
    293              int c;
    294          
    295              /* Check the gzip magic header */
    296              for (len = 0; len < 2; len++)
    297              {
    298          	c = get_byte(s);
    299          	if (c != gz_magic[len])
    300                  {
    301          	    if (len != 0) s->stream.avail_in++, s->stream.next_in--;
    302          	    if (c != NULL)
    303                      {
    304          		s->stream.avail_in++, s->stream.next_in--;
    305          		s->transparent = 1;
    306          	    }
    307          	    s->z_err = s->stream.avail_in != 0 ? Z_OK : Z_STREAM_END;
    308          	    return;
    309          	}
    310              }
    311              method = get_byte(s);
    312              flags = get_byte(s);
    313              if (method != Z_DEFLATED || (flags & RESERVED) != 0) 
    314              {
    315          	s->z_err = Z_DATA_ERROR;
    316          	return;
    317              }
    318          
    319              /* Discard time, xflags and OS code: */
    320              for (len = 0; len < 6; len++) (void)get_byte(s);
    321          
    322              if ((flags & EXTRA_FIELD) != 0) { /* skip the extra field */
    323          	len  =  (uInt)get_byte(s);
    324          	len += ((uInt)get_byte(s))<<8;
    325          	/* len is garbage if EOF but the loop below will quit anyway */
    326          	while (len-- != 0 && get_byte(s) != NULL) ;
    327              }
    328              if ((flags & ORIG_NAME) != 0) { /* skip the original file name */
    329          	while ((c = get_byte(s)) != 0 && c != NULL) ;
    330              }
    331              if ((flags & COMMENT) != 0) {   /* skip the .gz file comment */
    332          	while ((c = get_byte(s)) != 0 && c != NULL) ;
    333              }
    334              if ((flags & HEAD_CRC) != 0) {  /* skip the header crc */
    335          	for (len = 0; len < 2; len++) (void)get_byte(s);
    336              }
    337              s->z_err = s->z_eof ? Z_DATA_ERROR : Z_OK;
    338          }
    339          
    340           /* ===========================================================================
    341           * Cleanup then free the given gz_stream. Return a zlib error code.
    342             Try freeing in the reverse order of allocations.
    343           */
    344          local int destroy (s)
    345              gz_stream *s;
    346          {
    347              int err = Z_OK;
    348          
    349              if (!s) return Z_STREAM_ERROR;
    350          
    351              TRYFREE(s->msg);
    352          
    353              if (s->stream.state != NULL)
    354              {
    355          	if (s->mode == 'w')
    356                  {
    357          #ifdef NO_DEFLATE
    358          	    err = Z_STREAM_ERROR;
    359          #else
    360          	    err = deflateEnd(&(s->stream));
    361          #endif
    362          	} else if (s->mode == 'r') 
    363                  {
    364          	    err = inflateEnd(&(s->stream));
    365          	}
    366              }
    367              /*
    368              if (s->file != -1 && fclose(s->file,0))
    369              {
    370          #ifdef ESPIPE
    371          	if (errno != ESPIPE) // fclose is broken for pipes in HP/UX 
    372          #endif
    373          	    err = Z_ERRNO;
    374              }
    375              if (s->z_err < 0) err = s->z_err;*/
    376              fclose(s->file,0);
    377              
    378              TRYFREE(s->inbuf);
    379              TRYFREE(s->outbuf);
    380              TRYFREE(s->path);
    381              TRYFREE(s);
    382              return err;
    383          }
    384          
    385          /* ===========================================================================
    386               Reads the given number of uncompressed bytes from the compressed file.
    387             gzread returns the number of bytes actually read (0 for end of file).
    388          */
    389          int ZEXPORT gzread (file, buf, len)
    390              gzFile file;
    391              voidp buf;
    392              unsigned len;
    393          {
    394              gz_stream *s = (gz_stream*)file;
    395              Bytef *start = (Bytef*)buf; /* starting point for crc computation */
    396              Byte  *next_out; /* == stream.next_out but not forced far (for MSDOS) */
    397          
    398              if (s == NULL || s->mode != 'r') return Z_STREAM_ERROR;
    399          
    400              if (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO) return -1;
    401              if (s->z_err == Z_STREAM_END) return 0;  /* EOF */
    402          
    403              next_out = (Byte*)buf;
    404              s->stream.next_out = (Bytef*)buf;
    405              s->stream.avail_out = len;
    406          
    407              while (s->stream.avail_out != 0)
    408              {
    409          
    410          	if (s->transparent)
    411                  {
    412          	    /* Copy first the lookahead bytes: */
    413          	    uInt n = s->stream.avail_in;
    414          	    if (n > s->stream.avail_out) n = s->stream.avail_out;
    415          	    if (n > 0) {
    416          		zmemcpy(s->stream.next_out, s->stream.next_in, n);
    417          		next_out += n;
    418          		s->stream.next_out = next_out;
    419          		s->stream.next_in   += n;
    420          		s->stream.avail_out -= n;
    421          		s->stream.avail_in  -= n;
    422          	    }
    423          	    if (s->stream.avail_out > 0)
    424                      {
    425          		s->stream.avail_out -= (uInt)fread(s->file,next_out,s->stream.avail_out,0); //что-то стремное
    426          			// JL 03/24/2002 - silenced a warning about typeconversion
    427          	    }
    428          	    len -= s->stream.avail_out;
    429          	    s->stream.total_in  += (uLong)len;
    430          	    s->stream.total_out += (uLong)len;
    431                      if (len == 0) s->z_eof = 1;
    432          	    return (int)len;
    433          	}
    434                  if (s->stream.avail_in == 0 && !s->z_eof) {
    435          
    436                      //errno = 0;
    437                      s->stream.avail_in = (uInt)fread(s->file,s->inbuf,Z_BUFSIZE,0);
    438          			// JL 03/24/2002 - silenced a warning about typeconversion
    439                      if (s->stream.avail_in == 0)
    440                      {
    441                          s->z_eof = 1;
    442          		if (s->file==-1) 
    443                          {
    444          		    s->z_err = Z_ERRNO;
    445          		    break;
    446          		}
    447                      }
    448                      s->stream.next_in = s->inbuf;
    449                  }
    450                  s->z_err = inflate(&(s->stream), Z_NO_FLUSH);
    451          
    452          	if (s->z_err == Z_STREAM_END) {
    453          	    /* Check CRC and original size */
    454          	    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));
    455          	    start = s->stream.next_out;
    456          
    457          	    if (getLong(s) != s->crc) {
    458          		s->z_err = Z_DATA_ERROR;
    459          	    } else {
    460          	        (void)getLong(s);
    461                          /* The uncompressed length returned by above getlong() may
    462                           * be different from s->stream.total_out) in case of
    463          		 * concatenated .gz files. Check for such files:
    464          		 */
    465          		check_header(s);
    466          		if (s->z_err == Z_OK) {
    467          		    uLong total_in = s->stream.total_in;
    468          		    uLong total_out = s->stream.total_out;
    469          
    470          		    inflateReset(&(s->stream));
    471          		    s->stream.total_in = total_in;
    472          		    s->stream.total_out = total_out;
    473          		    s->crc = crc32(0L, Z_NULL, 0);
    474          		}
    475          	    }
    476          	}
    477          	if (s->z_err != Z_OK || s->z_eof) break;
    478              }
    479              s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));
    480          
    481              return (int)(len - s->stream.avail_out);
    482          }
    483          
    484          
    485          /* ===========================================================================
    486                Reads one byte from the compressed file. gzgetc returns this byte
    487             or -1 in case of end of file or error.
    488          */
    489          int ZEXPORT gzgetc(file)
    490              gzFile file;
    491          {
    492              unsigned char c;
    493          
    494              return gzread(file, &c, 1) == 1 ? c : -1;
    495          }
    496          
    497          
    498          /* ===========================================================================
    499                Reads bytes from the compressed file until len-1 characters are
    500             read, or a newline character is read and transferred to buf, or an
    501             end-of-file condition is encountered.  The string is then terminated
    502             with a null character.
    503                gzgets returns buf, or Z_NULL in case of error.
    504          
    505                The current implementation is not optimized at all.
    506          */
    507          char * ZEXPORT gzgets(file, buf, len)
    508              gzFile file;
    509              char *buf;
    510              int len;
    511          {
    512              char *b = buf;
    513              if (buf == Z_NULL || len <= 0) return Z_NULL;
    514          
    515              while (--len > 0 && gzread(file, buf, 1) == 1 && *buf++ != '\n') ;
    516              *buf = '\0';
    517              return b == buf && len > 0 ? Z_NULL : b;
    518          }
    519          
    520          
    521          #ifndef NO_DEFLATE
    522          /* ===========================================================================
    523               Writes the given number of uncompressed bytes into the compressed file.
    524             gzwrite returns the number of bytes actually written (0 in case of error).
    525          */
    526          int ZEXPORT gzwrite (file, buf, len)
    527              gzFile file;
    528              const voidp buf;
    529              unsigned len;
    530          {
    531              gz_stream *s = (gz_stream*)file;
    532          
    533              if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;
    534          
    535              s->stream.next_in = (Bytef*)buf;
    536              s->stream.avail_in = len;
    537          
    538              while (s->stream.avail_in != 0)
    539              {
    540                  if (s->stream.avail_out == 0)
    541                  {
    542          
    543                      s->stream.next_out = s->outbuf;
    544                      if (fwrite(s->file,s->outbuf,Z_BUFSIZE,0) != Z_BUFSIZE) 
    545                      {
    546                          s->z_err = Z_ERRNO;
    547                          break;
    548                      }
    549                      s->stream.avail_out = Z_BUFSIZE;
    550                  }
    551                  s->z_err = deflate(&(s->stream), Z_NO_FLUSH);
    552                  if (s->z_err != Z_OK) break;
    553              }
    554              s->crc = crc32(s->crc, (const Bytef *)buf, len);
    555          
    556              return (int)(len - s->stream.avail_in);
    557          }
    558          
    559          /* ===========================================================================
    560               Converts, formats, and writes the args to the compressed file under
    561             control of the format string, as in fprintf. gzprintf returns the number of
    562             uncompressed bytes actually written (0 in case of error).
    563          */
    564          #ifdef STDC
    565          #include <stdarg.h>
    566          
    567          int ZEXPORTVA gzprintf (gzFile file, const char *format, /* args */ ...)
    568          {
    569              char buf[Z_PRINTF_BUFSIZE];
    570              va_list va;
    571              int len;
    572          
    573              va_start(va, format);
    574          #ifdef HAS_vsnprintf
    575              (void)vsnprintf(buf, sizeof(buf), format, va);
    576          #else
    577              (void)sprintf(buf, format, va); //???
    578          #endif
    579              va_end(va);
    580              len = (int)strlen(buf); /* some *sprintf don't return the nb of bytes written */
    581          	// JL 03/24/2002 - silenced a warning about typeconversion
    582              if (len <= 0) return 0;
    583          
    584              return gzwrite(file, buf, (unsigned)len);
    585          }
    586          #else /* not ANSI C */
    587          
    588          int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
    589          	               a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)
    590              gzFile file;
    591              const char *format;
    592              int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
    593          	a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;
    594          {
    595              char buf[Z_PRINTF_BUFSIZE];
    596              int len;
    597          
    598          #ifdef HAS_snprintf
    599              snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,
    600          	     a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
    601          #else
    602              sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,
    603          	    a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
    604          #endif
    605              len = strlen(buf); /* old sprintf doesn't return the nb of bytes written */
    606              if (len <= 0) return 0;
    607          
    608              return gzwrite(file, buf, len);
    609          }
    610          #endif
    611          
    612          /* ===========================================================================
    613                Writes c, converted to an unsigned char, into the compressed file.
    614             gzputc returns the value that was written, or -1 in case of error.
    615          */
    616          int ZEXPORT gzputc(file, c)
    617              gzFile file;
    618              int c;
    619          {
    620              unsigned char cc = (unsigned char) c; /* required for big endian systems */
    621          
    622              return gzwrite(file, &cc, 1) == 1 ? (int)cc : -1;
    623          }
    624          
    625          
    626          /* ===========================================================================
    627                Writes the given null-terminated string to the compressed file, excluding
    628             the terminating null character.
    629                gzputs returns the number of characters written, or -1 in case of error.
    630          */
    631          int ZEXPORT gzputs(file, s)
    632              gzFile file;
    633              const char *s;
    634          {
    635              return gzwrite(file, (char*)s, (unsigned)strlen(s));
    636          }
    637          
    638          
    639          /* ===========================================================================
    640               Flushes all pending output into the compressed file. The parameter
    641             flush is as in the deflate() function.
    642          */
    643          local int do_flush (file, flush)
    644              gzFile file;
    645              int flush;
    646          {
    647              uInt len;
    648              int done = 0;
    649              gz_stream *s = (gz_stream*)file;
    650          
    651              if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;
    652          
    653              s->stream.avail_in = 0; /* should be zero already anyway */
    654          
    655              for (;;)
    656              {
    657                  len = Z_BUFSIZE - s->stream.avail_out;
    658          
    659                  if (len != 0) {
    660                      if ((uInt)fwrite(s->file,s->outbuf, len,0) != len)
    661                      {
    662                          s->z_err = Z_ERRNO;
    663                          return Z_ERRNO;
    664                      }
    665                      s->stream.next_out = s->outbuf;
    666                      s->stream.avail_out = Z_BUFSIZE;
    667                  }
    668                  if (done) break;
    669                  s->z_err = deflate(&(s->stream), flush);
    670          
    671          	/* Ignore the second of two consecutive flushes: */
    672          	if (len == 0 && s->z_err == Z_BUF_ERROR) s->z_err = Z_OK;
    673          
    674                  /* deflate has finished flushing only when it hasn't used up
    675                   * all the available space in the output buffer: 
    676                   */
    677                  done = (s->stream.avail_out != 0 || s->z_err == Z_STREAM_END);
    678           
    679                  if (s->z_err != Z_OK && s->z_err != Z_STREAM_END) break;
    680              }
    681              return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;
    682          }
    683          
    684          int ZEXPORT gzflush (file, flush)
    685               gzFile file;
    686               int flush;
    687          {
    688              gz_stream *s = (gz_stream*)file;
    689              int err = do_flush (file, flush);
    690          
    691              if (err) return err;
    692              //fflush(s->file); //???
    693              return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;
    694          }
    695          #endif /* NO_DEFLATE */
    696          
    697          /* ===========================================================================
    698                Sets the starting position for the next gzread or gzwrite on the given
    699             compressed file. The offset represents a number of bytes in the
    700                gzseek returns the resulting offset location as measured in bytes from
    701             the beginning of the uncompressed stream, or -1 in case of error.
    702                SEEK_END is not implemented, returns error.
    703                In this version of the library, gzseek can be extremely slow.
    704          */
    705          z_off_t ZEXPORT gzseek (file, offset, whence)
    706              gzFile file;
    707              z_off_t offset;
    708              int whence;
    709          {
    710              gz_stream *s = (gz_stream*)file;
    711          
    712              if (s == NULL || whence == SEEK_END ||
    713          	s->z_err == Z_ERRNO || s->z_err == Z_DATA_ERROR) {
    714          	return -1L;
    715              }
    716              
    717              if (s->mode == 'w') {
    718          #ifdef NO_DEFLATE
    719          	return -1L;
    720          #else
    721          	if (whence == SEEK_SET) {
    722          	    offset -= s->stream.total_in;
    723          	}
    724          	if (offset < 0) return -1L;
    725          
    726          	/* At this point, offset is the number of zero bytes to write. */
    727          	if (s->inbuf == Z_NULL) {
    728          	    s->inbuf = (Byte*)ALLOC(Z_BUFSIZE); /* for seeking */
    729          	    zmemzero(s->inbuf, Z_BUFSIZE);
    730          	}
    731          	while (offset > 0)  {
    732          	    uInt size = Z_BUFSIZE;
    733          	    if (offset < Z_BUFSIZE) size = (uInt)offset;
    734          
    735          	    size = gzwrite(file, s->inbuf, size);
    736          	    if (size == 0) return -1L;
    737          
    738          	    offset -= size;
    739          	}
    740          	return (z_off_t)s->stream.total_in;
    741          #endif
    742              }
    743              /* Rest of function is for reading only */
    744          
    745              /* compute absolute position */
    746              if (whence == SEEK_CUR) {
    747          	offset += s->stream.total_out;
    748              }
    749              if (offset < 0) return -1L;
    750          
    751              if (s->transparent) {
    752          	/* map to fseek */
    753          	s->stream.avail_in = 0;
    754          	s->stream.next_in = s->inbuf;
    755                  if (lseek(s->file, offset, S_SET,0,0) < 0) return -1L;
                                                               ^
Warning[Pe186]: pointless comparison of unsigned integer with zero
    756          
    757          	s->stream.total_in = s->stream.total_out = (uLong)offset;
    758          	return offset;
    759              }
    760          
    761              /* For a negative seek, rewind and use positive seek */
    762              if ((uLong)offset >= s->stream.total_out) {
    763          	offset -= s->stream.total_out;
    764              } else if (gzrewind(file) < 0) {
    765          	return -1L;
    766              }
    767              /* offset is now the number of bytes to skip. */
    768          
    769              if (offset != 0 && s->outbuf == Z_NULL) {
    770          	s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);
    771              }
    772              while (offset > 0)  {
    773          	int size = Z_BUFSIZE;
    774          	if (offset < Z_BUFSIZE) size = (int)offset;
    775          
    776          	size = gzread(file, s->outbuf, (uInt)size);
    777          	if (size <= 0) return -1L;
    778          	offset -= size;
    779              }
    780              return (z_off_t)s->stream.total_out;
    781          }
    782          
    783          /* ===========================================================================
    784               Rewinds input file. 
    785          */
    786          int ZEXPORT gzrewind (file)
    787              gzFile file;
    788          {
    789              gz_stream *s = (gz_stream*)file;
    790              
    791              if (s == NULL || s->mode != 'r') return -1;
    792          
    793              s->z_err = Z_OK;
    794              s->z_eof = 0;
    795              s->stream.avail_in = 0;
    796              s->stream.next_in = s->inbuf;
    797              s->crc = crc32(0L, Z_NULL, 0);
    798          	
    799              if (s->startpos == 0) /* not a compressed file */
    800              { 
    801          	//rewind(s->file); //???
    802                lseek(s->file,0,S_SET,0,0);
    803          	return 0;
    804              }
    805          
    806              (void) inflateReset(&s->stream);
    807              return lseek(s->file, s->startpos, S_SET,0,0);
    808          }
    809          
    810          /* ===========================================================================
    811               Returns the starting position for the next gzread or gzwrite on the
    812             given compressed file. This position represents a number of bytes in the
    813             uncompressed data stream.
    814          */
    815          z_off_t ZEXPORT gztell (file)
    816              gzFile file;
    817          {
    818              return gzseek(file, 0L, SEEK_CUR);
    819          }
    820          
    821          /* ===========================================================================
    822               Returns 1 when EOF has previously been detected reading the given
    823             input stream, otherwise zero.
    824          */
    825          int ZEXPORT gzeof (file)
    826              gzFile file;
    827          {
    828              gz_stream *s = (gz_stream*)file;
    829              
    830              return (s == NULL || s->mode != 'r') ? 0 : s->z_eof;
    831          }
    832          
    833          /* ===========================================================================
    834             Outputs a long in LSB order to the given file
    835          */
    836          void fputc(char c,int fp) //вроде норм)
    837          {
    838            fwrite(fp,&c,1,0);
    839          }
    840          
    841          local void putLong (file, x)
    842              int file;
    843              uLong x;
    844          {
    845              int n;
    846              for (n = 0; n < 4; n++) {
    847                  fputc((int)(x & 0xff), file);
    848                  x >>= 8;
    849              }
    850          }
    851          
    852          /* ===========================================================================
    853             Reads a long in LSB order from the given gz_stream. Sets z_err in case
    854             of error.
    855          */
    856          local uLong getLong (s)
    857              gz_stream *s;
    858          {
    859              uLong x = (uLong)get_byte(s);
    860              int c;
    861          
    862              x += ((uLong)get_byte(s))<<8;
    863              x += ((uLong)get_byte(s))<<16;
    864              c = get_byte(s);
    865              if (c == NULL) s->z_err = Z_DATA_ERROR;
    866              x += ((uLong)c)<<24;
    867              return x;
    868          }
    869          
    870          /* ===========================================================================
    871               Flushes all pending output if necessary, closes the compressed file
    872             and deallocates all the (de)compression state.
    873          */
    874          int ZEXPORT gzclose (file)
    875              gzFile file;
    876          {
    877              int err;
    878              gz_stream *s = (gz_stream*)file;
    879          
    880              if (s == NULL) return Z_STREAM_ERROR;
    881          
    882              if (s->mode == 'w') {
    883          #ifdef NO_DEFLATE
    884          	return Z_STREAM_ERROR;
    885          #else
    886                  err = do_flush (file, Z_FINISH);
    887                  if (err != Z_OK) return destroy((gz_stream*)file);
    888          
    889                  putLong (s->file, s->crc);
    890                  putLong (s->file, s->stream.total_in);
    891          #endif
    892              }
    893              return destroy((gz_stream*)file);
    894          }
    895          
    896          /* ===========================================================================
    897               Returns the error message for the last error which occured on the
    898             given compressed file. errnum is set to zlib error number. If an
    899             error occured in the file system and not in the compression library,
    900             errnum is set to Z_ERRNO and the application may consult errno
    901             to get the exact error code.
    902          */
    903          const char*  ZEXPORT gzerror (file, errnum)
    904              gzFile file;
    905              int *errnum;
    906          {
    907              char *m;
    908              gz_stream *s = (gz_stream*)file;
    909          
    910              if (s == NULL) {
    911                  *errnum = Z_STREAM_ERROR;
    912                  return (const char*)ERR_MSG(Z_STREAM_ERROR);
    913              }
    914              *errnum = s->z_err;
    915              if (*errnum == Z_OK) return (const char*)"";
    916          
    917              m =  (char*)(*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg);
    918          
    919              if (m == NULL || *m == '\0') m = (char*)ERR_MSG(s->z_err);
    920          
    921              TRYFREE(s->msg);
    922              s->msg = (char*)ALLOC(strlen(s->path) + strlen(m) + 3);
    923              strcpy(s->msg, s->path);
    924              strcat(s->msg, ": ");
    925              strcat(s->msg, m);
    926              return (const char*)s->msg;
    927          }

Errors: 20
Warnings: 17
