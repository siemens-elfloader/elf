##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    19/Jan/2011  13:20:58 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\grabber\jpeg-7\jdapimin.c                     #
#    Command line    =  C:\arm\grabber\jpeg-7\jdapimin.c -lC                 #
#                       C:\arm\grabber\Release_SGOLD\List\ -o                #
#                       C:\arm\grabber\Release_SGOLD\Obj\ -s9 --no_unroll    #
#                       --no_clustering --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --fpu None --dlib_config "C:\arm2\Embedded           #
#                       Workbench 4.0 Evaluation\ARM\LIB\dl5tpainl8n.h" -I   #
#                       "C:\arm2\Embedded Workbench 4.0                      #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  C:\arm\grabber\Release_SGOLD\List\jdapimin.lst       #
#    Object file     =  C:\arm\grabber\Release_SGOLD\Obj\jdapimin.r79        #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\grabber\jpeg-7\jdapimin.c
      1          /*
                  ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           * jdapimin.c
      3           *
      4           * Copyright (C) 1994-1998, Thomas G. Lane.
      5           * Modified 2009 by Guido Vollbeding.
      6           * This file is part of the Independent JPEG Group's software.
      7           * For conditions of distribution and use, see the accompanying README file.
      8           *
      9           * This file contains application interface code for the decompression half
     10           * of the JPEG library.  These are the "minimum" API routines that may be
     11           * needed in either the normal full-decompression case or the
     12           * transcoding-only case.
     13           *
     14           * Most of the routines intended to be called directly by an application
     15           * are in this file or in jdapistd.c.  But also see jcomapi.c for routines
     16           * shared by compression and decompression, and jdtrans.c for the transcoding
     17           * case.
     18           */
     19          
     20          #define JPEG_INTERNALS
     21          #include "jinclude.h"
     22          #include "jpeglib.h"
     23          
     24          
     25          /*
     26           * Initialization of a JPEG decompression object.
     27           * The error manager must already be set up (in case memory manager fails).
     28           */
     29          

   \                                 In segment CODE, align 4, keep-with-next
     30          GLOBAL(void)
     31          jpeg_CreateDecompress (j_decompress_ptr cinfo, int version, size_t structsize)
     32          {
   \                     jpeg_CreateDecompress:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0260A0E1           MOV      R6,R2
     33            int i;
     34          
     35            /* Guard against version mismatches between library and caller. */
     36            cinfo->mem = NULL;		/* so jpeg_destroy knows mem mgr not called */
   \   0000000C   0050A0E3           MOV      R5,#+0
   \   00000010   045084E5           STR      R5,[R4, #+4]
     37            if (version != JPEG_LIB_VERSION)
   \   00000014   460051E3           CMP      R1,#+70
   \   00000018   0B00000A           BEQ      ??jpeg_CreateDecompress_0
     38              ERREXIT2(cinfo, JERR_BAD_LIB_VERSION, JPEG_LIB_VERSION, version);
   \   0000001C   000094E5           LDR      R0,[R4, #+0]
   \   00000020   0D20A0E3           MOV      R2,#+13
   \   00000024   142080E5           STR      R2,[R0, #+20]
   \   00000028   000094E5           LDR      R0,[R4, #+0]
   \   0000002C   4620A0E3           MOV      R2,#+70
   \   00000030   182080E5           STR      R2,[R0, #+24]
   \   00000034   000094E5           LDR      R0,[R4, #+0]
   \   00000038   1C1080E5           STR      R1,[R0, #+28]
   \   0000003C   001094E5           LDR      R1,[R4, #+0]
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   001091E5           LDR      R1,[R1, #+0]
   \   00000048   31FF2FE1           BLX      R1
     39            if (structsize != SIZEOF(struct jpeg_decompress_struct))
   \                     ??jpeg_CreateDecompress_0:
   \   0000004C   740F56E3           CMP      R6,#+464
   \   00000050   0B00000A           BEQ      ??jpeg_CreateDecompress_1
     40              ERREXIT2(cinfo, JERR_BAD_STRUCT_SIZE, 
     41          	     (int) SIZEOF(struct jpeg_decompress_struct), (int) structsize);
   \   00000054   000094E5           LDR      R0,[R4, #+0]
   \   00000058   1610A0E3           MOV      R1,#+22
   \   0000005C   141080E5           STR      R1,[R0, #+20]
   \   00000060   000094E5           LDR      R0,[R4, #+0]
   \   00000064   741FA0E3           MOV      R1,#+464
   \   00000068   181080E5           STR      R1,[R0, #+24]
   \   0000006C   000094E5           LDR      R0,[R4, #+0]
   \   00000070   1C6080E5           STR      R6,[R0, #+28]
   \   00000074   001094E5           LDR      R1,[R4, #+0]
   \   00000078   0400A0E1           MOV      R0,R4
   \   0000007C   001091E5           LDR      R1,[R1, #+0]
   \   00000080   31FF2FE1           BLX      R1
     42          
     43            /* For debugging purposes, we zero the whole master structure.
     44             * But the application has already set the err pointer, and may have set
     45             * client_data, so we have to save and restore those fields.
     46             * Note: if application hasn't set client_data, tools like Purify may
     47             * complain here.
     48             */
     49            {
     50              struct jpeg_error_mgr * err = cinfo->err;
   \                     ??jpeg_CreateDecompress_1:
   \   00000084   006094E5           LDR      R6,[R4, #+0]
     51              void * client_data = cinfo->client_data; /* ignore Purify complaint here */
   \   00000088   0C7094E5           LDR      R7,[R4, #+12]
     52              MEMZERO(cinfo, SIZEOF(struct jpeg_decompress_struct));
   \   0000008C   742FA0E3           MOV      R2,#+464
   \   00000090   0010A0E3           MOV      R1,#+0
   \   00000094   0400A0E1           MOV      R0,R4
   \   00000098   BB0000EF           SWI      +187
     53              cinfo->err = err;
   \   0000009C   006084E5           STR      R6,[R4, #+0]
     54              cinfo->client_data = client_data;
   \   000000A0   0C7084E5           STR      R7,[R4, #+12]
     55            }
     56            cinfo->is_decompressor = TRUE;
   \   000000A4   0100A0E3           MOV      R0,#+1
   \   000000A8   100084E5           STR      R0,[R4, #+16]
     57          
     58            /* Initialize a memory manager instance for this object */
     59            jinit_memory_mgr((j_common_ptr) cinfo);
   \   000000AC   0400A0E1           MOV      R0,R4
   \   000000B0   ........           _BLF     jinit_memory_mgr,??jinit_memory_mgr??rA
     60          
     61            /* Zero out pointers to permanent structures. */
     62            cinfo->progress = NULL;
   \   000000B4   085084E5           STR      R5,[R4, #+8]
     63            cinfo->src = NULL;
   \   000000B8   185084E5           STR      R5,[R4, #+24]
     64          
     65            for (i = 0; i < NUM_QUANT_TBLS; i++)
   \   000000BC   0500A0E1           MOV      R0,R5
     66              cinfo->quant_tbl_ptrs[i] = NULL;
   \                     ??jpeg_CreateDecompress_2:
   \   000000C0   001184E0           ADD      R1,R4,R0, LSL #+2
   \   000000C4   A05081E5           STR      R5,[R1, #+160]
   \   000000C8   010080E2           ADD      R0,R0,#+1
   \   000000CC   040050E3           CMP      R0,#+4
   \   000000D0   FAFFFFBA           BLT      ??jpeg_CreateDecompress_2
     67          
     68            for (i = 0; i < NUM_HUFF_TBLS; i++) {
   \   000000D4   0000A0E3           MOV      R0,#+0
     69              cinfo->dc_huff_tbl_ptrs[i] = NULL;
   \                     ??jpeg_CreateDecompress_3:
   \   000000D8   001184E0           ADD      R1,R4,R0, LSL #+2
   \   000000DC   B05081E5           STR      R5,[R1, #+176]
     70              cinfo->ac_huff_tbl_ptrs[i] = NULL;
   \   000000E0   C05081E5           STR      R5,[R1, #+192]
     71            }
   \   000000E4   010080E2           ADD      R0,R0,#+1
   \   000000E8   040050E3           CMP      R0,#+4
   \   000000EC   F9FFFFBA           BLT      ??jpeg_CreateDecompress_3
     72          
     73            /* Initialize marker processor so application can override methods
     74             * for COM, APPn markers before calling jpeg_read_header.
     75             */
     76            cinfo->marker_list = NULL;
   \   000000F0   2C5184E5           STR      R5,[R4, #+300]
     77            jinit_marker_reader(cinfo);
   \   000000F4   0400A0E1           MOV      R0,R4
   \   000000F8   ........           _BLF     jinit_marker_reader,??jinit_marker_reader??rA
     78          
     79            /* And initialize the overall input controller. */
     80            jinit_input_controller(cinfo);
   \   000000FC   0400A0E1           MOV      R0,R4
   \   00000100   ........           _BLF     jinit_input_controller,??jinit_input_controller??rA
     81          
     82            /* OK, I'm ready */
     83            cinfo->global_state = DSTATE_START;
   \   00000104   C800A0E3           MOV      R0,#+200
   \   00000108   140084E5           STR      R0,[R4, #+20]
     84          }
   \   0000010C   F080BDE8           POP      {R4-R7,PC}       ;; return
     85          
     86          
     87          /*
     88           * Destruction of a JPEG decompression object
     89           */
     90          

   \                                 In segment CODE, align 4, keep-with-next
     91          GLOBAL(void)
     92          jpeg_destroy_decompress (j_decompress_ptr cinfo)
     93          {
     94            jpeg_destroy((j_common_ptr) cinfo); /* use common routine */
   \                     jpeg_destroy_decompress:
   \   00000000   ........           _BF      jpeg_destroy,??jpeg_destroy??rA  ;; tailcall
     95          }
     96          
     97          
     98          /*
     99           * Abort processing of a JPEG decompression operation,
    100           * but don't destroy the object itself.
    101           */
    102          

   \                                 In segment CODE, align 4, keep-with-next
    103          GLOBAL(void)
    104          jpeg_abort_decompress (j_decompress_ptr cinfo)
    105          {
    106            jpeg_abort((j_common_ptr) cinfo); /* use common routine */
   \                     jpeg_abort_decompress:
   \   00000000   ........           _BF      jpeg_abort,??jpeg_abort??rA  ;; tailcall
    107          }
    108          
    109          
    110          /*
    111           * Set default decompression parameters.
    112           */
    113          

   \                                 In segment CODE, align 4, keep-with-next
    114          LOCAL(void)
    115          default_decompress_parms (j_decompress_ptr cinfo)
    116          {
   \                     default_decompress_parms:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   248094E5           LDR      R8,[R4, #+36]
   \   0000000C   2411D4E5           LDRB     R1,[R4, #+292]
   \   00000010   202194E5           LDR      R2,[R4, #+288]
   \   00000014   000094E5           LDR      R0,[R4, #+0]
   \   00000018   0250A0E3           MOV      R5,#+2
   \   0000001C   0160A0E3           MOV      R6,#+1
   \   00000020   7430A0E3           MOV      R3,#+116
   \   00000024   0070A0E3           MOV      R7,#+0
   \   00000028   018058E2           SUBS     R8,R8,#+1
   \   0000002C   0400000A           BEQ      ??default_decompress_parms_0
   \   00000030   028058E2           SUBS     R8,R8,#+2
   \   00000034   0500000A           BEQ      ??default_decompress_parms_1
   \   00000038   018058E2           SUBS     R8,R8,#+1
   \   0000003C   3100000A           BEQ      ??default_decompress_parms_2
   \   00000040   450000EA           B        ??default_decompress_parms_3
    117            /* Guess the input colorspace, and set output colorspace accordingly. */
    118            /* (Wish JPEG committee had provided a real way to specify this...) */
    119            /* Note application may override our guesses. */
    120            switch (cinfo->num_components) {
    121            case 1:
    122              cinfo->jpeg_color_space = JCS_GRAYSCALE;
   \                     ??default_decompress_parms_0:
   \   00000044   0180A0E3           MOV      R8,#+1
    123              cinfo->out_color_space = JCS_GRAYSCALE;
   \   00000048   0690A0E1           MOV      R9,R6
   \   0000004C   440000EA           B        ??default_decompress_parms_4
    124              break;
    125              
    126            case 3:
    127              if (cinfo->saw_JFIF_marker) {
   \                     ??default_decompress_parms_1:
   \   00000050   149194E5           LDR      R9,[R4, #+276]
   \   00000054   0380A0E3           MOV      R8,#+3
   \   00000058   000059E3           CMP      R9,#+0
   \   0000005C   2700001A           BNE      ??default_decompress_parms_5
    128                cinfo->jpeg_color_space = JCS_YCbCr; /* JFIF implies YCbCr */
    129              } else if (cinfo->saw_Adobe_marker) {
   \   00000060   000052E3           CMP      R2,#+0
   \   00000064   0C00000A           BEQ      ??default_decompress_parms_6
    130                switch (cinfo->Adobe_transform) {
   \   00000068   000051E3           CMP      R1,#+0
   \   0000006C   0200000A           BEQ      ??default_decompress_parms_7
   \   00000070   011051E2           SUBS     R1,R1,#+1
   \   00000074   2100000A           BEQ      ??default_decompress_parms_5
   \   00000078   010000EA           B        ??default_decompress_parms_8
    131                case 0:
    132          	cinfo->jpeg_color_space = JCS_RGB;
   \                     ??default_decompress_parms_7:
   \   0000007C   0280A0E3           MOV      R8,#+2
   \   00000080   1E0000EA           B        ??default_decompress_parms_5
    133          	break;
    134                case 1:
    135          	cinfo->jpeg_color_space = JCS_YCbCr;
    136          	break;
    137                default:
    138          	WARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);
   \                     ??default_decompress_parms_8:
   \   00000084   143080E5           STR      R3,[R0, #+20]
   \   00000088   2411D4E5           LDRB     R1,[R4, #+292]
   \   0000008C   000094E5           LDR      R0,[R4, #+0]
   \   00000090   181080E5           STR      R1,[R0, #+24]
   \   00000094   001066E2           RSB      R1,R6,#+0
   \   00000098   140000EA           B        ??default_decompress_parms_9
    139          	cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */
    140          	break;
    141                }
    142              } else {
    143                /* Saw no special markers, try to guess from the component IDs */
    144                int cid0 = cinfo->comp_info[0].component_id;
   \                     ??default_decompress_parms_6:
   \   0000009C   D41094E5           LDR      R1,[R4, #+212]
   \   000000A0   002091E5           LDR      R2,[R1, #+0]
    145                int cid1 = cinfo->comp_info[1].component_id;
   \   000000A4   583091E5           LDR      R3,[R1, #+88]
    146                int cid2 = cinfo->comp_info[2].component_id;
   \   000000A8   B01091E5           LDR      R1,[R1, #+176]
    147          
    148                if (cid0 == 1 && cid1 == 2 && cid2 == 3)
   \   000000AC   010052E3           CMP      R2,#+1
   \   000000B0   0300001A           BNE      ??default_decompress_parms_10
   \   000000B4   020053E3           CMP      R3,#+2
   \   000000B8   03005103           CMPEQ    R1,#+3
   \   000000BC   0400001A           BNE      ??default_decompress_parms_11
   \   000000C0   0E0000EA           B        ??default_decompress_parms_5
    149          	cinfo->jpeg_color_space = JCS_YCbCr; /* assume JFIF w/out marker */
    150                else if (cid0 == 82 && cid1 == 71 && cid2 == 66)
   \                     ??default_decompress_parms_10:
   \   000000C4   520052E3           CMP      R2,#+82
   \   000000C8   47005303           CMPEQ    R3,#+71
   \   000000CC   42005103           CMPEQ    R1,#+66
   \   000000D0   E9FFFF0A           BEQ      ??default_decompress_parms_7
    151          	cinfo->jpeg_color_space = JCS_RGB; /* ASCII 'R', 'G', 'B' */
    152                else {
    153          	TRACEMS3(cinfo, 1, JTRC_UNKNOWN_IDS, cid0, cid1, cid2);
   \                     ??default_decompress_parms_11:
   \   000000D4   1820A0E5           STR      R2,[R0, #+24]!
   \   000000D8   043080E5           STR      R3,[R0, #+4]
   \   000000DC   081080E5           STR      R1,[R0, #+8]
   \   000000E0   000094E5           LDR      R0,[R4, #+0]
   \   000000E4   7110A0E3           MOV      R1,#+113
   \   000000E8   141080E5           STR      R1,[R0, #+20]
   \   000000EC   0110A0E3           MOV      R1,#+1
   \                     ??default_decompress_parms_9:
   \   000000F0   002094E5           LDR      R2,[R4, #+0]
   \   000000F4   0400A0E1           MOV      R0,R4
   \   000000F8   042092E5           LDR      R2,[R2, #+4]
   \   000000FC   32FF2FE1           BLX      R2
    154          	cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */
    155                }
    156              }
    157              /* Always guess RGB is proper output colorspace. */
    158              cinfo->out_color_space = JCS_RGB;
   \                     ??default_decompress_parms_5:
   \   00000100   0290A0E3           MOV      R9,#+2
   \   00000104   160000EA           B        ??default_decompress_parms_4
    159              break;
    160              
    161            case 4:
    162              if (cinfo->saw_Adobe_marker) {
   \                     ??default_decompress_parms_2:
   \   00000108   0490A0E3           MOV      R9,#+4
   \   0000010C   000052E3           CMP      R2,#+0
    163                switch (cinfo->Adobe_transform) {
   \   00000110   00005113           CMPNE    R1,#+0
   \   00000114   0200000A           BEQ      ??default_decompress_parms_12
   \   00000118   021051E2           SUBS     R1,R1,#+2
   \   0000011C   0200000A           BEQ      ??default_decompress_parms_13
   \   00000120   030000EA           B        ??default_decompress_parms_14
    164                case 0:
    165          	cinfo->jpeg_color_space = JCS_CMYK;
   \                     ??default_decompress_parms_12:
   \   00000124   0480A0E3           MOV      R8,#+4
   \   00000128   0D0000EA           B        ??default_decompress_parms_4
    166          	break;
    167                case 2:
    168          	cinfo->jpeg_color_space = JCS_YCCK;
   \                     ??default_decompress_parms_13:
   \   0000012C   0580A0E3           MOV      R8,#+5
   \   00000130   0B0000EA           B        ??default_decompress_parms_4
    169          	break;
    170                default:
    171          	WARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);
   \                     ??default_decompress_parms_14:
   \   00000134   143080E5           STR      R3,[R0, #+20]
   \   00000138   2411D4E5           LDRB     R1,[R4, #+292]
   \   0000013C   000094E5           LDR      R0,[R4, #+0]
   \   00000140   181080E5           STR      R1,[R0, #+24]
   \   00000144   002094E5           LDR      R2,[R4, #+0]
   \   00000148   001066E2           RSB      R1,R6,#+0
   \   0000014C   042092E5           LDR      R2,[R2, #+4]
   \   00000150   0400A0E1           MOV      R0,R4
   \   00000154   32FF2FE1           BLX      R2
    172          	cinfo->jpeg_color_space = JCS_YCCK; /* assume it's YCCK */
   \   00000158   F3FFFFEA           B        ??default_decompress_parms_13
    173          	break;
    174                }
    175              } else {
    176                /* No special markers, assume straight CMYK. */
    177                cinfo->jpeg_color_space = JCS_CMYK;
    178              }
    179              cinfo->out_color_space = JCS_CMYK;
    180              break;
    181              
    182            default:
    183              cinfo->jpeg_color_space = JCS_UNKNOWN;
   \                     ??default_decompress_parms_3:
   \   0000015C   0080A0E3           MOV      R8,#+0
    184              cinfo->out_color_space = JCS_UNKNOWN;
   \   00000160   0790A0E1           MOV      R9,R7
   \                     ??default_decompress_parms_4:
   \   00000164   2990C4E5           STRB     R9,[R4, #+41]
   \   00000168   2880C4E5           STRB     R8,[R4, #+40]
    185              break;
    186            }
    187          
    188            /* Set defaults for other decompression parameters. */
    189            cinfo->scale_num = DCTSIZE;		/* 1:1 scaling */
   \   0000016C   0800A0E3           MOV      R0,#+8
   \   00000170   2C0084E5           STR      R0,[R4, #+44]
    190            cinfo->scale_denom = DCTSIZE;
   \   00000174   300084E5           STR      R0,[R4, #+48]
    191            cinfo->output_gamma = 1.0;
   \   00000178   0000A0E3           MOV      R0,#+0
   \   0000017C   C015A0E3           MOV      R1,#+805306368
   \   00000180   FF1681E3           ORR      R1,R1,#0xFF00000
   \   00000184   340084E5           STR      R0,[R4, #+52]
   \   00000188   381084E5           STR      R1,[R4, #+56]
    192            cinfo->buffered_image = FALSE;
   \   0000018C   3C7084E5           STR      R7,[R4, #+60]
    193            cinfo->raw_data_out = FALSE;
   \   00000190   407084E5           STR      R7,[R4, #+64]
    194            cinfo->dct_method = JDCT_DEFAULT;
   \   00000194   4470C4E5           STRB     R7,[R4, #+68]
    195            cinfo->do_fancy_upsampling = TRUE;
   \   00000198   486084E5           STR      R6,[R4, #+72]
    196            cinfo->do_block_smoothing = TRUE;
   \   0000019C   4C6084E5           STR      R6,[R4, #+76]
    197            cinfo->quantize_colors = FALSE;
   \   000001A0   507084E5           STR      R7,[R4, #+80]
    198            /* We set these in case application only sets quantize_colors. */
    199            cinfo->dither_mode = JDITHER_FS;
   \   000001A4   5450C4E5           STRB     R5,[R4, #+84]
    200          #ifdef QUANT_2PASS_SUPPORTED
    201            cinfo->two_pass_quantize = TRUE;
   \   000001A8   586084E5           STR      R6,[R4, #+88]
    202          #else
    203            cinfo->two_pass_quantize = FALSE;
    204          #endif
    205            cinfo->desired_number_of_colors = 256;
   \   000001AC   400FA0E3           MOV      R0,#+256
   \   000001B0   5C0084E5           STR      R0,[R4, #+92]
    206            cinfo->colormap = NULL;
   \   000001B4   847084E5           STR      R7,[R4, #+132]
    207            /* Initialize for no mode change in buffered-image mode. */
    208            cinfo->enable_1pass_quant = FALSE;
   \   000001B8   607084E5           STR      R7,[R4, #+96]
    209            cinfo->enable_external_quant = FALSE;
   \   000001BC   647084E5           STR      R7,[R4, #+100]
    210            cinfo->enable_2pass_quant = FALSE;
   \   000001C0   687084E5           STR      R7,[R4, #+104]
    211          }
   \   000001C4   F083BDE8           POP      {R4-R9,PC}       ;; return
    212          
    213          
    214          /*
    215           * Decompression startup: read start of JPEG datastream to see what's there.
    216           * Need only initialize JPEG object and supply a data source before calling.
    217           *
    218           * This routine will read as far as the first SOS marker (ie, actual start of
    219           * compressed data), and will save all tables and parameters in the JPEG
    220           * object.  It will also initialize the decompression parameters to default
    221           * values, and finally return JPEG_HEADER_OK.  On return, the application may
    222           * adjust the decompression parameters and then call jpeg_start_decompress.
    223           * (Or, if the application only wanted to determine the image parameters,
    224           * the data need not be decompressed.  In that case, call jpeg_abort or
    225           * jpeg_destroy to release any temporary space.)
    226           * If an abbreviated (tables only) datastream is presented, the routine will
    227           * return JPEG_HEADER_TABLES_ONLY upon reaching EOI.  The application may then
    228           * re-use the JPEG object to read the abbreviated image datastream(s).
    229           * It is unnecessary (but OK) to call jpeg_abort in this case.
    230           * The JPEG_SUSPENDED return code only occurs if the data source module
    231           * requests suspension of the decompressor.  In this case the application
    232           * should load more source data and then re-call jpeg_read_header to resume
    233           * processing.
    234           * If a non-suspending data source is used and require_image is TRUE, then the
    235           * return code need not be inspected since only JPEG_HEADER_OK is possible.
    236           *
    237           * This routine is now just a front end to jpeg_consume_input, with some
    238           * extra error checking.
    239           */
    240          

   \                                 In segment CODE, align 4, keep-with-next
    241          GLOBAL(int)
    242          jpeg_read_header (j_decompress_ptr cinfo, boolean require_image)
    243          {
   \                     jpeg_read_header:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    244            int retcode;
    245          
    246            if (cinfo->global_state != DSTATE_START &&
    247                cinfo->global_state != DSTATE_INHEADER)
   \   00000008   140094E5           LDR      R0,[R4, #+20]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   C80050E3           CMP      R0,#+200
   \   00000014   C9005013           CMPNE    R0,#+201
   \   00000018   0900000A           BEQ      ??jpeg_read_header_0
    248              ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
   \   0000001C   000094E5           LDR      R0,[R4, #+0]
   \   00000020   1510A0E3           MOV      R1,#+21
   \   00000024   141080E5           STR      R1,[R0, #+20]
   \   00000028   000094E5           LDR      R0,[R4, #+0]
   \   0000002C   141094E5           LDR      R1,[R4, #+20]
   \   00000030   181080E5           STR      R1,[R0, #+24]
   \   00000034   001094E5           LDR      R1,[R4, #+0]
   \   00000038   0400A0E1           MOV      R0,R4
   \   0000003C   001091E5           LDR      R1,[R1, #+0]
   \   00000040   31FF2FE1           BLX      R1
    249          
    250            retcode = jpeg_consume_input(cinfo);
   \                     ??jpeg_read_header_0:
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           BL       jpeg_consume_input
    251          
    252            switch (retcode) {
   \   0000004C   011050E2           SUBS     R1,R0,#+1
   \   00000050   0200000A           BEQ      ??jpeg_read_header_1
   \   00000054   011051E2           SUBS     R1,R1,#+1
   \   00000058   0200000A           BEQ      ??jpeg_read_header_2
   \   0000005C   3080BDE8           POP      {R4,R5,PC}
    253            case JPEG_REACHED_SOS:
    254              retcode = JPEG_HEADER_OK;
   \                     ??jpeg_read_header_1:
   \   00000060   0100A0E3           MOV      R0,#+1
   \   00000064   3080BDE8           POP      {R4,R5,PC}
    255              break;
    256            case JPEG_REACHED_EOI:
    257              if (require_image)		/* Complain if application wanted an image */
   \                     ??jpeg_read_header_2:
   \   00000068   000055E3           CMP      R5,#+0
   \   0000006C   0600000A           BEQ      ??jpeg_read_header_3
    258                ERREXIT(cinfo, JERR_NO_IMAGE);
   \   00000070   000094E5           LDR      R0,[R4, #+0]
   \   00000074   3510A0E3           MOV      R1,#+53
   \   00000078   141080E5           STR      R1,[R0, #+20]
   \   0000007C   001094E5           LDR      R1,[R4, #+0]
   \   00000080   0400A0E1           MOV      R0,R4
   \   00000084   001091E5           LDR      R1,[R1, #+0]
   \   00000088   31FF2FE1           BLX      R1
    259              /* Reset to start state; it would be safer to require the application to
    260               * call jpeg_abort, but we can't change it now for compatibility reasons.
    261               * A side effect is to free any temporary memory (there shouldn't be any).
    262               */
    263              jpeg_abort((j_common_ptr) cinfo); /* sets state = DSTATE_START */
   \                     ??jpeg_read_header_3:
   \   0000008C   0400A0E1           MOV      R0,R4
   \   00000090   ........           _BLF     jpeg_abort,??jpeg_abort??rA
    264              retcode = JPEG_HEADER_TABLES_ONLY;
   \   00000094   0200A0E3           MOV      R0,#+2
    265              break;
    266            case JPEG_SUSPENDED:
    267              /* no work */
    268              break;
    269            }
    270          
    271            return retcode;
   \   00000098   3080BDE8           POP      {R4,R5,PC}       ;; return
    272          }
    273          
    274          
    275          /*
    276           * Consume data in advance of what the decompressor requires.
    277           * This can be called at any time once the decompressor object has
    278           * been created and a data source has been set up.
    279           *
    280           * This routine is essentially a state machine that handles a couple
    281           * of critical state-transition actions, namely initial setup and
    282           * transition from header scanning to ready-for-start_decompress.
    283           * All the actual input is done via the input controller's consume_input
    284           * method.
    285           */
    286          

   \                                 In segment CODE, align 4, keep-with-next
    287          GLOBAL(int)
    288          jpeg_consume_input (j_decompress_ptr cinfo)
    289          {
   \                     jpeg_consume_input:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    290            int retcode = JPEG_SUSPENDED;
    291          
    292            /* NB: every possible DSTATE value should be listed in this switch */
    293            switch (cinfo->global_state) {
   \   00000008   140094E5           LDR      R0,[R4, #+20]
   \   0000000C   B41194E5           LDR      R1,[R4, #+436]
   \   00000010   0050A0E3           MOV      R5,#+0
   \   00000014   C80040E2           SUB      R0,R0,#+200
   \   00000018   0A0050E3           CMP      R0,#+10
   \   0000001C   2200008A           BHI      ??jpeg_consume_input_1
   \   00000020   012F8FE2           ADR      R2,??jpeg_consume_input_0
   \   00000024   0020D2E7           LDRB     R2,[R2, R0]
   \   00000028   02F18FE0           ADD      PC,PC,R2, LSL #+2
   \                     ??jpeg_consume_input_0:
   \   0000002C   020B171A           DC8      +2,+11,+23,+26
   \   00000030   1A1A1A1A           DC8      +26,+26,+26,+26
   \   00000034   1A1F1A00           DC8      +26,+31,+26,+0
    294            case DSTATE_START:
    295              /* Start-of-datastream actions: reset appropriate modules */
    296              (*cinfo->inputctl->reset_input_controller) (cinfo);
   \                     ??jpeg_consume_input_2:
   \   00000038   041091E5           LDR      R1,[R1, #+4]
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   31FF2FE1           BLX      R1
    297              /* Initialize application's data source module */
    298              (*cinfo->src->init_source) (cinfo);
   \   00000044   181094E5           LDR      R1,[R4, #+24]
   \   00000048   0400A0E1           MOV      R0,R4
   \   0000004C   081091E5           LDR      R1,[R1, #+8]
   \   00000050   31FF2FE1           BLX      R1
    299              cinfo->global_state = DSTATE_INHEADER;
   \   00000054   C900A0E3           MOV      R0,#+201
   \   00000058   140084E5           STR      R0,[R4, #+20]
    300              /*FALLTHROUGH*/
    301            case DSTATE_INHEADER:
    302              retcode = (*cinfo->inputctl->consume_input) (cinfo);
   \                     ??jpeg_consume_input_3:
   \   0000005C   B41194E5           LDR      R1,[R4, #+436]
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   001091E5           LDR      R1,[R1, #+0]
   \   00000068   31FF2FE1           BLX      R1
   \   0000006C   0050A0E1           MOV      R5,R0
    303              if (retcode == JPEG_REACHED_SOS) { /* Found SOS, prepare to decompress */
   \   00000070   010055E3           CMP      R5,#+1
   \   00000074   1600001A           BNE      ??jpeg_consume_input_4
    304                /* Set up default parameters based on header data */
    305                default_decompress_parms(cinfo);
   \   00000078   0400A0E1           MOV      R0,R4
   \   0000007C   ........           BL       default_decompress_parms
    306                /* Set global state: ready for start_decompress */
    307                cinfo->global_state = DSTATE_READY;
   \   00000080   CA00A0E3           MOV      R0,#+202
   \   00000084   140084E5           STR      R0,[R4, #+20]
   \   00000088   000000EA           B        ??jpeg_consume_input_5
    308              }
    309              break;
    310            case DSTATE_READY:
    311              /* Can't advance past first SOS until start_decompress is called */
    312              retcode = JPEG_REACHED_SOS;
   \                     ??jpeg_consume_input_6:
   \   0000008C   0150A0E3           MOV      R5,#+1
   \                     ??jpeg_consume_input_5:
   \   00000090   0500A0E1           MOV      R0,R5
   \   00000094   3080BDE8           POP      {R4,R5,PC}
    313              break;
    314            case DSTATE_PRELOAD:
    315            case DSTATE_PRESCAN:
    316            case DSTATE_SCANNING:
    317            case DSTATE_RAW_OK:
    318            case DSTATE_BUFIMAGE:
    319            case DSTATE_BUFPOST:
    320            case DSTATE_STOPPING:
    321              retcode = (*cinfo->inputctl->consume_input) (cinfo);
   \                     ??jpeg_consume_input_7:
   \   00000098   001091E5           LDR      R1,[R1, #+0]
   \   0000009C   0400A0E1           MOV      R0,R4
   \   000000A0   31FF2FE1           BLX      R1
   \   000000A4   0050A0E1           MOV      R5,R0
   \   000000A8   F8FFFFEA           B        ??jpeg_consume_input_5
    322              break;
    323            default:
    324              ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
   \                     ??jpeg_consume_input_1:
   \   000000AC   000094E5           LDR      R0,[R4, #+0]
   \   000000B0   1510A0E3           MOV      R1,#+21
   \   000000B4   141080E5           STR      R1,[R0, #+20]
   \   000000B8   000094E5           LDR      R0,[R4, #+0]
   \   000000BC   141094E5           LDR      R1,[R4, #+20]
   \   000000C0   181080E5           STR      R1,[R0, #+24]
   \   000000C4   001094E5           LDR      R1,[R4, #+0]
   \   000000C8   0400A0E1           MOV      R0,R4
   \   000000CC   001091E5           LDR      R1,[R1, #+0]
   \   000000D0   31FF2FE1           BLX      R1
    325            }
    326            return retcode;
   \                     ??jpeg_consume_input_4:
   \   000000D4   0500A0E1           MOV      R0,R5
   \   000000D8   3080BDE8           POP      {R4,R5,PC}       ;; return
    327          }
    328          
    329          
    330          /*
    331           * Have we finished reading the input file?
    332           */
    333          

   \                                 In segment CODE, align 4, keep-with-next
    334          GLOBAL(boolean)
    335          jpeg_input_complete (j_decompress_ptr cinfo)
    336          {
   \                     jpeg_input_complete:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    337            /* Check for valid jpeg object */
    338            if (cinfo->global_state < DSTATE_START ||
    339                cinfo->global_state > DSTATE_STOPPING)
   \   00000008   140094E5           LDR      R0,[R4, #+20]
   \   0000000C   C80050E3           CMP      R0,#+200
   \   00000010   010000BA           BLT      ??jpeg_input_complete_0
   \   00000014   D30050E3           CMP      R0,#+211
   \   00000018   090000BA           BLT      ??jpeg_input_complete_1
    340              ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
   \                     ??jpeg_input_complete_0:
   \   0000001C   000094E5           LDR      R0,[R4, #+0]
   \   00000020   1510A0E3           MOV      R1,#+21
   \   00000024   141080E5           STR      R1,[R0, #+20]
   \   00000028   000094E5           LDR      R0,[R4, #+0]
   \   0000002C   141094E5           LDR      R1,[R4, #+20]
   \   00000030   181080E5           STR      R1,[R0, #+24]
   \   00000034   001094E5           LDR      R1,[R4, #+0]
   \   00000038   0400A0E1           MOV      R0,R4
   \   0000003C   001091E5           LDR      R1,[R1, #+0]
   \   00000040   31FF2FE1           BLX      R1
    341            return cinfo->inputctl->eoi_reached;
   \                     ??jpeg_input_complete_1:
   \   00000044   B40194E5           LDR      R0,[R4, #+436]
   \   00000048   140090E5           LDR      R0,[R0, #+20]
   \   0000004C   1080BDE8           POP      {R4,PC}          ;; return
    342          }
    343          
    344          
    345          /*
    346           * Is there more than one scan?
    347           */
    348          

   \                                 In segment CODE, align 4, keep-with-next
    349          GLOBAL(boolean)
    350          jpeg_has_multiple_scans (j_decompress_ptr cinfo)
    351          {
   \                     jpeg_has_multiple_scans:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    352            /* Only valid after jpeg_read_header completes */
    353            if (cinfo->global_state < DSTATE_READY ||
    354                cinfo->global_state > DSTATE_STOPPING)
   \   00000008   140094E5           LDR      R0,[R4, #+20]
   \   0000000C   CA0050E3           CMP      R0,#+202
   \   00000010   010000BA           BLT      ??jpeg_has_multiple_scans_0
   \   00000014   D30050E3           CMP      R0,#+211
   \   00000018   090000BA           BLT      ??jpeg_has_multiple_scans_1
    355              ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
   \                     ??jpeg_has_multiple_scans_0:
   \   0000001C   000094E5           LDR      R0,[R4, #+0]
   \   00000020   1510A0E3           MOV      R1,#+21
   \   00000024   141080E5           STR      R1,[R0, #+20]
   \   00000028   000094E5           LDR      R0,[R4, #+0]
   \   0000002C   141094E5           LDR      R1,[R4, #+20]
   \   00000030   181080E5           STR      R1,[R0, #+24]
   \   00000034   001094E5           LDR      R1,[R4, #+0]
   \   00000038   0400A0E1           MOV      R0,R4
   \   0000003C   001091E5           LDR      R1,[R1, #+0]
   \   00000040   31FF2FE1           BLX      R1
    356            return cinfo->inputctl->has_multiple_scans;
   \                     ??jpeg_has_multiple_scans_1:
   \   00000044   B40194E5           LDR      R0,[R4, #+436]
   \   00000048   100090E5           LDR      R0,[R0, #+16]
   \   0000004C   1080BDE8           POP      {R4,PC}          ;; return
    357          }
    358          
    359          
    360          /*
    361           * Finish JPEG decompression.
    362           *
    363           * This will normally just verify the file trailer and release temp storage.
    364           *
    365           * Returns FALSE if suspended.  The return value need be inspected only if
    366           * a suspending data source is used.
    367           */
    368          

   \                                 In segment CODE, align 4, keep-with-next
    369          GLOBAL(boolean)
    370          jpeg_finish_decompress (j_decompress_ptr cinfo)
    371          {
   \                     jpeg_finish_decompress:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    372            if ((cinfo->global_state == DSTATE_SCANNING ||
    373                 cinfo->global_state == DSTATE_RAW_OK) && ! cinfo->buffered_image) {
   \   00000008   140094E5           LDR      R0,[R4, #+20]
   \   0000000C   001094E5           LDR      R1,[R4, #+0]
   \   00000010   CD0050E3           CMP      R0,#+205
   \   00000014   CE005013           CMPNE    R0,#+206
   \   00000018   3C209405           LDREQ    R2,[R4, #+60]
   \   0000001C   D250A0E3           MOV      R5,#+210
   \   00000020   00005203           CMPEQ    R2,#+0
   \   00000024   0F00001A           BNE      ??jpeg_finish_decompress_0
    374              /* Terminate final pass of non-buffered mode */
    375              if (cinfo->output_scanline < cinfo->output_height)
   \   00000028   880094E5           LDR      R0,[R4, #+136]
   \   0000002C   702094E5           LDR      R2,[R4, #+112]
   \   00000030   020050E1           CMP      R0,R2
   \   00000034   0500002A           BCS      ??jpeg_finish_decompress_1
    376                ERREXIT(cinfo, JERR_TOO_LITTLE_DATA);
   \   00000038   4500A0E3           MOV      R0,#+69
   \   0000003C   140081E5           STR      R0,[R1, #+20]
   \   00000040   001094E5           LDR      R1,[R4, #+0]
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   001091E5           LDR      R1,[R1, #+0]
   \   0000004C   31FF2FE1           BLX      R1
    377              (*cinfo->master->finish_output_pass) (cinfo);
   \                     ??jpeg_finish_decompress_1:
   \   00000050   A41194E5           LDR      R1,[R4, #+420]
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   041091E5           LDR      R1,[R1, #+4]
   \   0000005C   31FF2FE1           BLX      R1
    378              cinfo->global_state = DSTATE_STOPPING;
   \                     ??jpeg_finish_decompress_2:
   \   00000060   145084E5           STR      R5,[R4, #+20]
   \   00000064   0C0000EA           B        ??jpeg_finish_decompress_3
    379            } else if (cinfo->global_state == DSTATE_BUFIMAGE) {
   \                     ??jpeg_finish_decompress_0:
   \   00000068   CF0050E3           CMP      R0,#+207
   \   0000006C   FBFFFF0A           BEQ      ??jpeg_finish_decompress_2
    380              /* Finishing after a buffered-image operation */
    381              cinfo->global_state = DSTATE_STOPPING;
    382            } else if (cinfo->global_state != DSTATE_STOPPING) {
   \   00000070   D20050E3           CMP      R0,#+210
   \   00000074   0800000A           BEQ      ??jpeg_finish_decompress_3
    383              /* STOPPING = repeat call after a suspension, anything else is error */
    384              ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
   \   00000078   1500A0E3           MOV      R0,#+21
   \   0000007C   140081E5           STR      R0,[R1, #+20]
   \   00000080   000094E5           LDR      R0,[R4, #+0]
   \   00000084   141094E5           LDR      R1,[R4, #+20]
   \   00000088   181080E5           STR      R1,[R0, #+24]
   \   0000008C   001094E5           LDR      R1,[R4, #+0]
   \   00000090   0400A0E1           MOV      R0,R4
   \   00000094   001091E5           LDR      R1,[R1, #+0]
   \   00000098   31FF2FE1           BLX      R1
    385            }
    386            /* Read until EOI */
    387            while (! cinfo->inputctl->eoi_reached) {
   \                     ??jpeg_finish_decompress_3:
   \   0000009C   B41194E5           LDR      R1,[R4, #+436]
   \   000000A0   140091E5           LDR      R0,[R1, #+20]
   \   000000A4   000050E3           CMP      R0,#+0
   \   000000A8   0400A0E1           MOV      R0,R4
   \   000000AC   0400001A           BNE      ??jpeg_finish_decompress_4
    388              if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)
   \   000000B0   001091E5           LDR      R1,[R1, #+0]
   \   000000B4   31FF2FE1           BLX      R1
   \   000000B8   000050E3           CMP      R0,#+0
   \   000000BC   F6FFFF1A           BNE      ??jpeg_finish_decompress_3
    389                return FALSE;		/* Suspend, come back later */
   \   000000C0   3080BDE8           POP      {R4,R5,PC}
    390            }
    391            /* Do final cleanup */
    392            (*cinfo->src->term_source) (cinfo);
   \                     ??jpeg_finish_decompress_4:
   \   000000C4   181094E5           LDR      R1,[R4, #+24]
   \   000000C8   181091E5           LDR      R1,[R1, #+24]
   \   000000CC   31FF2FE1           BLX      R1
    393            /* We can use jpeg_abort to release memory and reset global_state */
    394            jpeg_abort((j_common_ptr) cinfo);
   \   000000D0   0400A0E1           MOV      R0,R4
   \   000000D4   ........           _BLF     jpeg_abort,??jpeg_abort??rA
    395            return TRUE;
   \   000000D8   0100A0E3           MOV      R0,#+1
   \   000000DC   3080BDE8           POP      {R4,R5,PC}       ;; return
    396          }

   Maximum stack usage in bytes:

     Function                 CSTACK
     --------                 ------
     default_decompress_parms    28
     jpeg_CreateDecompress       20
     jpeg_abort_decompress        4
     jpeg_consume_input          12
     jpeg_destroy_decompress      4
     jpeg_finish_decompress      12
     jpeg_has_multiple_scans      8
     jpeg_input_complete          8
     jpeg_read_header            12


   Segment part sizes:

     Function/Label           Bytes
     --------------           -----
     jpeg_CreateDecompress     272
     jpeg_destroy_decompress     4
     jpeg_abort_decompress       4
     default_decompress_parms  456
     jpeg_read_header          156
     jpeg_consume_input        220
     jpeg_input_complete        80
     jpeg_has_multiple_scans    80
     jpeg_finish_decompress    224
      Others                    96

 
 1 592 bytes in segment CODE
 
 1 496 bytes of CODE memory (+ 96 bytes shared)

Errors: none
Warnings: 1
