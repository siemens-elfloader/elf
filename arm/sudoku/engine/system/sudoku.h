//(с)Dimadze
//sudoku.h - Библиотека игровых ф-ий, структур, констант, переменных для игры SuDoKu 2.0

typedef struct {    // Карта SuDoKu в представлении игры
  char name[32];    // Имя карты 
  char level;       // Уровень сложности, 'L' - лёгкий, 'M' - средний, 'H' - тяжёлый, '?' - не указано (Под '?' может быть любой символ)
  char x, y;        // Положение курсора, т.е. его координаты 
  char gcell[9][9]; // Карта игровых ячеек (изменяется в реальном времени, т.е. в игре)
  char rcell[9][9]; // Карта правильных ячеек (по ней проверяется решение)
  char preview;     // Кол-во "подсматриваний"
  char warn;        // 0x00 - без предупреждений, 0x01 - уровень сложности неизвестен, 0x02 - имя карты неизвестно, 0x03 - уровень сложности неизвестен, имя карты неизвестно
  char error;       // 0x00 - без ошибок, 0x01 - ошибка открытия фаила, 0x02 - ошибка ID фаила, 0x03 - неизвестная версия фаила, 0x04 - ошибка структуры фаила/составления карты 
  int  sec;         // Время игры для данной карты в секундах
}SUDOKUMAP;

// SUDOKUMAP->gcell[][]:
// 0x01-0x09 - скрытые ячейки, отрисовываютя пустой ячейкой (Default)
// 0x11-0x19 - открытые ячейки, изменять можно, они отрисовываютя красной ячейкой (Default)
// 0x21-0x29 - открытые ячейки, изменять нельзя, они заведомо верные, они отрисовываютя синей ячейкой (Default)
// 0x31-0x39 - открытые ячейки, изменять можно, служат для пометки, как абсолютно правильных (Ну по мнению пользователя), они отрисовываютя зеленой ячейкой (Default) (Предложено prold'ом из team-sc.ru)
// Остальные байты в ячейках - заведомо ложные, при их обнаружении в структуру SUDOKUMAP передаётся ошибка 0x04

typedef struct {          // Cтруктура рекордов
  char recs;              // Кол-во сохранений
  char timedate[3][16+1]; // Время и дата 3 рекордов (14:16 17.01.2010)
  char level[3];          // Уровни сложности 3 рекордов
  int  sec[3];            // Секунды проведенных рекордных 5 игр до момента завершения
  int  points[3];         // Игровые очки 3 рекордных игр
  char error;             // 0x00 - без ошибок, 0x01 - ошибка открытия фаила, 0x02 - неверный размер фаила, 0x03 - ошибка ID фаила 
}SUDOKUREC;

typedef struct {        // Cтруктура ошибок запуска
  char png_file;        // Отсутствуют png - фаилы. Отражает их кол-во
  char hlp_file;        // Отсутствует hlp - фаил
  char sedit_file;      // Отсутствует эльф редактор 
  char ext_file;        // Ошибка запуска фаила карт SuDoKu, 0x64 - фаил и не загружался!
}ERRORSTRUCT;


char CheckSUDOKUMAP(SUDOKUMAP *sdm) //Проверка правильности составления карты SuDoKu, 0x04 - ошибка, 0 - всё круто!))
{ 
 int t=0;
 for (char i=1;i<10;i++) for (int k=0;k<9;k++) //Проверка по рядам (горизонталь); проверяет, нет ли повторений цифр.
  {
   int a=0;
   for (int j=0;j<9;j++) if (sdm->rcell[k][j]==i) a++;
   if  (a>1) {t=1; goto ERROR;} // Ошибка! Функция возвращает 0x04
  }
 
 for (char i=1;i<10;i++) for (int k=0;k<9;k++) //Проверка по столбцам (вертикаль); проверяет, нет ли повторений цифр.
  {
   int a=0;
   for (int j=0;j<9;j++) if (sdm->rcell[j][k]==i) a++;
   if  (a>1) {t=1; goto ERROR;} // Ошибка! Функция возвращает 0x04
  }

 // #1#2#3
 // #4#5#6 - разбивка на маленькие квадраты
 // #7#8#9

//--------
 for (char i=1;i<10;i++) //Проверка в #1 маленьком квадрате; проверяет, нет ли повторений цифр.
  {
    int a=0;
    for (int k=0;k<3;k++) for (int j=0;j<3;j++) if (sdm->rcell[k][j]==i) a++;
    if  (a>1) {t=1; goto ERROR;} // Ошибка! Функция возвращает 0x04
  }
 
 for (char i=1;i<10;i++) //Проверка в #2 маленьком квадрате; проверяет, нет ли повторений цифр.
  {
    int a=0;
    for (int k=0;k<3;k++) for (int j=3;j<6;j++) if (sdm->rcell[k][j]==i) a++;
    if  (a>1) {t=1; goto ERROR;} // Ошибка! Функция возвращает 0x04
  }
 
 for (char i=1;i<10;i++) //Проверка в #3 маленьком квадрате; проверяет, нет ли повторений цифр.
  {
    int a=0;
    for (int k=0;k<3;k++) for (int j=6;j<9;j++) if (sdm->rcell[k][j]==i) a++;
    if  (a>1) {t=1; goto ERROR;} // Ошибка! Функция возвращает 0x04
  }
//--------
 for (char i=1;i<10;i++) //Проверка в #4 маленьком квадрате; проверяет, нет ли повторений цифр.
  {
    int a=0;
    for (int k=3;k<6;k++) for (int j=0;j<3;j++) if (sdm->rcell[k][j]==i) a++;
    if  (a>1) {t=1; goto ERROR;} // Ошибка! Функция возвращает 0x04
  }
 
 for (char i=1;i<10;i++) //Проверка в #5 маленьком квадрате; проверяет, нет ли повторений цифр.
  {
    int a=0;
    for (int k=3;k<6;k++) for (int j=3;j<6;j++) if (sdm->rcell[k][j]==i) a++;
    if  (a>1) {t=1; goto ERROR;} // Ошибка! Функция возвращает 0x04
  }
 
 for (char i=1;i<10;i++) //Проверка в #6 маленьком квадрате; проверяет, нет ли повторений цифр.
  {
    int a=0;
    for (int k=3;k<6;k++) for (int j=6;j<9;j++) if (sdm->rcell[k][j]==i) a++;
    if  (a>1) {t=1; goto ERROR;} // Ошибка! Функция возвращает 0x04
  }
//--------
 for (char i=1;i<10;i++) //Проверка в #7 маленьком квадрате; проверяет, нет ли повторений цифр.
  {
    int a=0;
    for (int k=6;k<9;k++) for (int j=0;j<3;j++) if (sdm->rcell[k][j]==i) a++;
    if  (a>1) {t=1; goto ERROR;} // Ошибка! Функция возвращает 0x04
  }
 
 for (char i=1;i<10;i++) //Проверка в #8 маленьком квадрате; проверяет, нет ли повторений цифр.
  {
    int a=0;
    for (int k=6;k<9;k++) for (int j=3;j<6;j++) if (sdm->rcell[k][j]==i) a++;
    if  (a>1) {t=1; goto ERROR;} // Ошибка! Функция возвращает 0x04
  }
 
 for (char i=1;i<10;i++) //Проверка в #9 маленьком квадрате; проверяет, нет ли повторений цифр.
  {
    int a=0;
    for (int k=6;k<9;k++) for (int j=6;j<9;j++) if (sdm->rcell[k][j]==i) a++;
    if  (a>1) {t=1; goto ERROR;} // Ошибка! Функция возвращает 0x04
  }
//-------- 
 
ERROR: //Если сразу ошибка, то исполнение кода переходит сюда ...
  
 if (t==1) return 0x04; else return 0;
}


SUDOKUMAP *ClearSUDOKUMAP(SUDOKUMAP *sdm)
{
 sdm->name[0] = 0;
 sdm->level = '?';
 sdm->x = 4; sdm->y = 4;
 for (int i=0;i<9;i++) for (int j=0;j<9;j++) sdm->gcell[i][j] = 0;
 for (int i=0;i<9;i++) for (int j=0;j<9;j++) sdm->rcell[i][j] = 0; 
 sdm->preview = 0;
 sdm->warn    = 0;
 sdm->error   = 0;
 sdm->sec     = 0;
 return sdm;
}

void MemFreeOfSUDOKUMAP(SUDOKUMAP *sdm) // Очистка памяти от SUDOKUMAP
{
 mfree(sdm);
}

void MemFreeOfERRORSTRUCT(ERRORSTRUCT *errs) // Очистка памяти от ERRORSTRUCT
{
 mfree(errs);
};
