##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    13/Jan/2011  22:52:21 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\mss3\string_works.c                           #
#    Command line    =  C:\arm\mss3\string_works.c -D NEWSGOLD -D ELKA -D    #
#                       LANG_EN -D NO_CS -lC C:\arm\mss3\Release_ELKA_EN\Lis #
#                       t\ -o C:\arm\mss3\Release_ELKA_EN\Obj\ -s9           #
#                       --no_unroll --cpu_mode arm --endian little --cpu     #
#                       ARM926EJ-S --stack_align 4 --interwork -e --fpu      #
#                       None --dlib_config "C:\arm2\Embedded Workbench 4.0   #
#                       Evaluation\ARM\LIB\dl5tpainl8n.h" -I                 #
#                       "C:\arm2\Embedded Workbench 4.0                      #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  C:\arm\mss3\Release_ELKA_EN\List\string_works.lst    #
#    Object file     =  C:\arm\mss3\Release_ELKA_EN\Obj\string_works.r79     #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\mss3\string_works.c
      1          #include "../inc/swilib.h"
      2          #include "string_works.h"
      3          
      4          

   \                                 In segment CODE, align 4, keep-with-next
      5          int char16to8(int c) //unicode2win1251
      6          {
      7            if (c<0x400) return (c);
   \                     char16to8:
   \   00000000   400E50E3           CMP      R0,#+1024
   \   00000004   1EFF2FB1           BXLT     LR
      8            c-=0x400;
   \   00000008   FF10E0E3           MVN      R1,#+255
   \   0000000C   C01FC1E3           BIC      R1,R1,#0x300
   \   00000010   000081E0           ADD      R0,R1,R0
      9            if (c<16)
   \   00000014   100050E3           CMP      R0,#+16
   \   00000018   090000AA           BGE      ??char16to8_0
     10            {
     11              if (c==1) c=0;
   \   0000001C   010050E3           CMP      R0,#+1
   \   00000020   0000A003           MOVEQ    R0,#+0
   \   00000024   1400000A           BEQ      ??char16to8_1
     12              else if (c==4) c=2;
   \   00000028   040050E3           CMP      R0,#+4
   \   0000002C   0200A003           MOVEQ    R0,#+2
   \   00000030   1100000A           BEQ      ??char16to8_1
     13              else if (c==6) c=10;
   \   00000034   060050E3           CMP      R0,#+6
   \   00000038   1EFF2F11           BXNE     LR
   \   0000003C   0A00A0E3           MOV      R0,#+10
   \   00000040   0D0000EA           B        ??char16to8_1
     14              else return (c);
     15            }
     16            else if (c>79)
   \                     ??char16to8_0:
   \   00000044   500050E3           CMP      R0,#+80
   \   00000048   0D0000BA           BLT      ??char16to8_2
     17            {
     18              if (c==0x51) c=16;
   \   0000004C   510050E3           CMP      R0,#+81
   \   00000050   1000A003           MOVEQ    R0,#+16
   \   00000054   0800000A           BEQ      ??char16to8_1
     19              else if (c==0x54) c=18;
   \   00000058   540050E3           CMP      R0,#+84
   \   0000005C   1200A003           MOVEQ    R0,#+18
   \   00000060   0500000A           BEQ      ??char16to8_1
     20              else if (c==0x56) c=11;
   \   00000064   560050E3           CMP      R0,#+86
   \   00000068   0B00A003           MOVEQ    R0,#+11
   \   0000006C   0200000A           BEQ      ??char16to8_1
     21              else if (c==0x57) c=23;
   \   00000070   570050E3           CMP      R0,#+87
   \   00000074   1EFF2F11           BXNE     LR
   \   00000078   1700A0E3           MOV      R0,#+23
   \                     ??char16to8_1:
   \   0000007C   A80080E2           ADD      R0,R0,#+168
   \   00000080   1EFF2FE1           BX       LR
     22              else return (c);
     23            }
     24            else c+=8;
   \                     ??char16to8_2:
   \   00000084   080080E2           ADD      R0,R0,#+8
     25            c+=168;
     26            return (c);
   \                     ??char16to8_3:
   \   00000088   FBFFFFEA           B        ??char16to8_1
     27          }
     28          
     29          #ifdef LANG_CN
     30          
     31          typedef struct
     32          {
     33            unsigned short u;
     34            unsigned short a;
     35          } TUNICODE2ANSI;
     36          
     37          const TUNICODE2ANSI u2a[]=
     38          {
     39            0x2014,'―',
     40            0x2018,'‘',
     41            0x201C,'“',
     42            0x201D,'”',
     43            0x2103,'℃',
     44            0x3001,'、',
     45            0x3002,'。',
     46            0xFF01,'！',
     47            0xFF08,'（',
     48            0xFF09,'）',
     49            0xFF0C,'，',
     50            0xFF1A,'：',
     51            0xFF1B,'；',
     52            0xFF1F,'？',
     53            0xFF5E,'～',
     54            0xFFE5,'￥',
     55            0,0
     56          };
     57          
     58          int unicode2ansi(int c) //
     59          {
     60            int i;
     61            const TUNICODE2ANSI *p=u2a;
     62            if(c>=0x400 && c<0x1000)
     63            {
     64              int d;
     65              c-=0x400;
     66              c+=0xA791;
     67              d=c>>8;
     68              c=(c<<24)>>16;
     69              return (c|d);
     70            }
     71            else
     72            {
     73              while((i=p->u))
     74              {
     75                if(c==i)
     76          	return p->a;
     77                p++;
     78              }
     79              return 0x2020;
     80            }
     81          }
     82          #ifdef NEWSGOLD
     83          #define CODEMAP_ADDR 0xA1568200  //-0xA157A24F
     84          #else
     85          #define CODEMAP_ADDR 0xA0FA0200
     86          #endif
     87          
     88          void ws2ascii(WSHDR *ws, char *s, int maxlen)
     89          {
     90            unsigned short *codemap=(unsigned short *)(CODEMAP_ADDR+32004);
     91            int i,j=0;
     92            unsigned short temp;
     93            for(i=1; i<=ws->wsbody[0]; i++)
     94            {
     95              temp=ws->wsbody[i];
     96              if(temp < 256)
     97                s[j++] = (unsigned char)temp;
     98              else if(temp >= 0x4E00 && temp <= 0x9FA5)
     99              {
    100                s[j++] = (unsigned char)(codemap[temp-0x4E00]>>8);
    101                s[j++] = (unsigned char)((codemap[temp-0x4E00]<<8)>>8);
    102              }
    103              else if(temp>=0x400)
    104              {
    105                temp=unicode2ansi(temp);
    106                s[j++]=temp>>8;
    107                s[j++]=(temp<<8)>>8;
    108              }
    109              else
    110              {
    111                s[j++]=' ';
    112              }
    113              if(maxlen != 0 && j >= maxlen)
    114                break;
    115            }
    116            s[j] = 0;
    117          }
    118          
    119          void ascii2ws(WSHDR *ws, const char *s, int maxlen)
    120          {
    121            unsigned short *codemap=(unsigned short *)(CODEMAP_ADDR);
    122            char *p=(char *)s;
    123            unsigned char uc,uc2;
    124            ws->wsbody[0] = 0;
    125            while((uc=*p++) && (maxlen == 0 || p-s<=maxlen))
    126            {
    127              if(uc <= 128)
    128                wsAppendChar(ws,uc);
    129              else
    130              {
    131                uc2=*p++;
    132                if(uc2 < 128)
    133                  wsAppendChar(ws, uc2);
    134                else
    135                  wsAppendChar(ws, codemap[(uc-129)*127+(uc2-128)]);
    136              }
    137            }
    138          }
    139          
    140          #else
    141          

   \                                 In segment DATA_C, align 4, align-sorted
    142          const unsigned short win2unicode[128]=
   \                     win2unicode:
   \   00000000   020403041A20       DC16 1026, 1027, 8218, 1107, 8222, 8230, 8224, 8225, 8364, 8240, 1033
   \              53041E202620
   \              20202120AC20
   \              30200904    
   \   00000016   39200A040C04       DC16 8249, 1034, 1036, 1035, 1039, 1106, 8216, 8217, 8220, 8221, 8226
   \              0B040F045204
   \              182019201C20
   \              1D202220    
   \   0000002C   132014202000       DC16 8211, 8212, 32, 8482, 1113, 8250, 1114, 1116, 1115, 1119, 160
   \              222159043A20
   \              5A045C045B04
   \              5F04A000    
   \   00000042   0E045E040804       DC16 1038, 1118, 1032, 164, 1168, 166, 167, 1025, 169, 1028, 171, 172
   \              A4009004A600
   \              A7000104A900
   \              0404AB00AC00
   \   0000005A   AD00AE000704       DC16 173, 174, 1031, 176, 177, 1030, 1110, 1169, 181, 182, 183, 1105
   \              B000B1000604
   \              56049104B500
   \              B600B7005104
   \   00000072   16215404BB00       DC16 8470, 1108, 187, 1112, 1029, 1109, 1111, 1040, 1041, 1042, 1043
   \              580405045504
   \              570410041104
   \              12041304    
   \   00000088   140415041604       DC16 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054
   \              170418041904
   \              1A041B041C04
   \              1D041E04    
   \   0000009E   1F0420042104       DC16 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065
   \              220423042404
   \              250426042704
   \              28042904    
   \   000000B4   2A042B042C04       DC16 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076
   \              2D042E042F04
   \              300431043204
   \              33043404    
   \   000000CA   350436043704       DC16 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087
   \              380439043A04
   \              3B043C043D04
   \              3E043F04    
   \   000000E0   400441044204       DC16 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098
   \              430444044504
   \              460447044804
   \              49044A04    
   \   000000F6   4B044C044D04       DC16 1099, 1100, 1101, 1102, 1103
   \              4E044F04    
    143          {
    144            0x0402,0x0403,0x201A,0x0453,0x201E,0x2026,0x2020,0x2021,
    145            0x20AC,0x2030,0x0409,0x2039,0x040A,0x040C,0x040B,0x040F,
    146            0x0452,0x2018,0x2019,0x201C,0x201D,0x2022,0x2013,0x2014,
    147            0x0020,0x2122,0x0459,0x203A,0x045A,0x045C,0x045B,0x045F,
    148            0x00A0,0x040E,0x045E,0x0408,0x00A4,0x0490,0x00A6,0x00A7,
    149            0x0401,0x00A9,0x0404,0x00AB,0x00AC,0x00AD,0x00AE,0x0407,
    150            0x00B0,0x00B1,0x0406,0x0456,0x0491,0x00B5,0x00B6,0x00B7,
    151            0x0451,0x2116,0x0454,0x00BB,0x0458,0x0405,0x0455,0x0457,
    152            0x0410,0x0411,0x0412,0x0413,0x0414,0x0415,0x0416,0x0417,
    153            0x0418,0x0419,0x041A,0x041B,0x041C,0x041D,0x041E,0x041F,
    154            0x0420,0x0421,0x0422,0x0423,0x0424,0x0425,0x0426,0x0427,
    155            0x0428,0x0429,0x042A,0x042B,0x042C,0x042D,0x042E,0x042F,
    156            0x0430,0x0431,0x0432,0x0433,0x0434,0x0435,0x0436,0x0437,
    157            0x0438,0x0439,0x043A,0x043B,0x043C,0x043D,0x043E,0x043F,
    158            0x0440,0x0441,0x0442,0x0443,0x0444,0x0445,0x0446,0x0447,
    159            0x0448,0x0449,0x044A,0x044B,0x044C,0x044D,0x044E,0x044F
    160          };
    161          

   \                                 In segment CODE, align 4, keep-with-next
    162          unsigned int char8to16(int c)
    163          {
    164            if (c>=128)
   \                     char8to16:
   \   00000000   800050E3           CMP      R0,#+128
   \   00000004   1EFF2FB1           BXLT     LR
    165            {
    166              return(win2unicode[c-128]);
   \   00000008   0C209FE5           LDR      R2,??char8to16_0  ;; win2unicode
   \   0000000C   FF10E0E3           MVN      R1,#+255
   \   00000010   800082E0           ADD      R0,R2,R0, LSL #+1
   \   00000014   B00091E1           LDRH     R0,[R1, +R0]
    167            }
    168            return(c);
   \   00000018   1EFF2FE1           BX       LR               ;; return
   \                     ??char8to16_0:
   \   0000001C   ........           DC32     win2unicode
    169          }
    170          
    171          #endif

   \                                 In segment CODE, align 4, keep-with-next
    172          void ws_2ascii(WSHDR *ws, char *str, int maxlen)
    173          {
   \                     ws_2ascii:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    174          #ifdef LANG_CN
    175            ws2ascii(ws, str, maxlen);
    176          #else
    177            unsigned short *p=ws->wsbody+1;
   \   00000008   000094E5           LDR      R0,[R4, #+0]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   028080E2           ADD      R8,R0,#+2
    178            int i=0;
   \   00000018   0070A0E3           MOV      R7,#+0
   \   0000001C   040000EA           B        ??ws_2ascii_0
    179            while((i<maxlen)&&(i<ws->wsbody[0]))
    180            {
    181              str[i]=char16to8(p[i]);
   \                     ??ws_2ascii_1:
   \   00000020   870088E0           ADD      R0,R8,R7, LSL #+1
   \   00000024   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000028   ........           BL       char16to8
   \   0000002C   0500C7E7           STRB     R0,[R7, +R5]
    182              i++;
   \   00000030   017087E2           ADD      R7,R7,#+1
    183            }
   \                     ??ws_2ascii_0:
   \   00000034   060057E1           CMP      R7,R6
   \   00000038   030000AA           BGE      ??ws_2ascii_2
   \   0000003C   000094E5           LDR      R0,[R4, #+0]
   \   00000040   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000044   000057E1           CMP      R7,R0
   \   00000048   F4FFFFBA           BLT      ??ws_2ascii_1
    184            str[i]=0;
   \                     ??ws_2ascii_2:
   \   0000004C   0000A0E3           MOV      R0,#+0
   \   00000050   0500C7E7           STRB     R0,[R7, +R5]
    185          #endif
    186          }
   \   00000054   F081BDE8           POP      {R4-R8,PC}       ;; return
    187          

   \                                 In segment CODE, align 4, keep-with-next
    188          void ascii_2ws(WSHDR *ws, const char *s, int maxlen)
    189          {
   \                     ascii_2ws:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    190          #ifdef LANG_CN
    191            ascii2ws(ws, s, maxlen);
    192          #else
    193            char c;
    194            CutWSTR(ws,0);
   \   0000000C   0010A0E3           MOV      R1,#+0
   \   00000010   260100EF           SWI      +294
   \   00000014   030000EA           B        ??ascii_2ws_0
    195            while((c=*s++))
    196            {
    197              wsAppendChar(ws,char8to16(c));
   \                     ??ascii_2ws_1:
   \   00000018   ........           BL       char8to16
   \   0000001C   0010A0E1           MOV      R1,R0
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   1C0000EF           SWI      +28
    198            }
   \                     ??ascii_2ws_0:
   \   00000028   ........           LDRB     R1,[R5], #+1
   \   0000002C   0100B0E1           MOVS     R0,R1
   \   00000030   F8FFFF1A           BNE      ??ascii_2ws_1
    199          #endif
    200          }
   \   00000034   3080BDE8           POP      {R4,R5,PC}       ;; return
    201          
    202          #define wslen(ARG) (ARG->wsbody[0])
    203          

   \                                 In segment CODE, align 4, keep-with-next
    204          int wstrcmp_nocase(WSHDR *ws1, WSHDR *ws2)
    205          {
   \                     wstrcmp_nocase:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
    206            int l1=wslen(ws1);
   \   00000004   004090E5           LDR      R4,[R0, #+0]
    207            int l2=wslen(ws2);
   \   00000008   006091E5           LDR      R6,[R1, #+0]
   \   0000000C   B050D4E1           LDRH     R5,[R4, #+0]
   \   00000010   B070D6E1           LDRH     R7,[R6, #+0]
    208            int pos=1;
   \   00000014   0180A0E3           MOV      R8,#+1
   \   00000018   000000EA           B        ??wstrcmp_nocase_0
    209            int cs, ds;
    210            while((pos<=l1)&&(pos<=l2))
    211            {
    212              cs=ws1->wsbody[pos];
    213              ds=ws2->wsbody[pos];
    214              if(cs<0x1000 && ds<0x1000)
    215              {
    216              	cs=char16to8(cs);
    217              	ds=char16to8(ds);
    218              	if(cs&0x40) cs&=0xDF;
    219              	if(ds&0x40) ds&=0xDF;
    220              }
    221              cs-=ds;
    222              if (cs) return cs;
    223              pos++;
   \                     ??wstrcmp_nocase_1:
   \   0000001C   018088E2           ADD      R8,R8,#+1
   \                     ??wstrcmp_nocase_0:
   \   00000020   080055E1           CMP      R5,R8
   \   00000024   080057A1           CMPGE    R7,R8
   \   00000028   130000BA           BLT      ??wstrcmp_nocase_2
   \   0000002C   880084E0           ADD      R0,R4,R8, LSL #+1
   \   00000030   B090D0E1           LDRH     R9,[R0, #+0]
   \   00000034   880086E0           ADD      R0,R6,R8, LSL #+1
   \   00000038   B0A0D0E1           LDRH     R10,[R0, #+0]
   \   0000003C   400D59E3           CMP      R9,#+4096
   \   00000040   400D5AB3           CMPLT    R10,#+4096
   \   00000044   090000AA           BGE      ??wstrcmp_nocase_3
   \   00000048   0900A0E1           MOV      R0,R9
   \   0000004C   ........           BL       char16to8
   \   00000050   0090A0E1           MOV      R9,R0
   \   00000054   0A00A0E1           MOV      R0,R10
   \   00000058   ........           BL       char16to8
   \   0000005C   00A0A0E1           MOV      R10,R0
   \   00000060   400019E3           TST      R9,#0x40
   \   00000064   DF900912           ANDNE    R9,R9,#0xDF
   \   00000068   40001AE3           TST      R10,#0x40
   \   0000006C   DFA00A12           ANDNE    R10,R10,#0xDF
   \                     ??wstrcmp_nocase_3:
   \   00000070   0A0059E0           SUBS     R0,R9,R10
   \   00000074   E8FFFF0A           BEQ      ??wstrcmp_nocase_1
   \   00000078   F087BDE8           POP      {R4-R10,PC}
    224            }
    225            return(l1-l2);
   \                     ??wstrcmp_nocase_2:
   \   0000007C   070045E0           SUB      R0,R5,R7
   \   00000080   F087BDE8           POP      {R4-R10,PC}      ;; return
    226          }
    227          

   \                                 In segment CODE, align 4, keep-with-next
    228          int wstrncmp_nocase(WSHDR *ws1, WSHDR *ws2, int n)
    229          {
   \                     wstrncmp_nocase:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
    230            int l1=wslen(ws1);
   \   00000004   004090E5           LDR      R4,[R0, #+0]
    231            int l2=wslen(ws2);
   \   00000008   006091E5           LDR      R6,[R1, #+0]
   \   0000000C   B050D4E1           LDRH     R5,[R4, #+0]
   \   00000010   B070D6E1           LDRH     R7,[R6, #+0]
    232            int pos=1;
   \   00000014   0190A0E3           MOV      R9,#+1
    233            int cs, ds;
    234            n++;
   \   00000018   018082E2           ADD      R8,R2,#+1
   \   0000001C   000000EA           B        ??wstrncmp_nocase_0
    235            while((pos<=l1)&&(pos<=l2)&&(pos<=n))
    236            {
    237              cs=ws1->wsbody[pos];
    238              ds=ws2->wsbody[pos];
    239              if(cs<0x1000 && ds<0x1000)
    240              {
    241              	cs=char16to8(cs);
    242              	ds=char16to8(ds);
    243              	if(cs&0x40) cs&=0xDF;
    244              	if(ds&0x40) ds&=0xDF;
    245              }
    246              cs-=ds;
    247              if (cs) return cs;
    248              pos++;
   \                     ??wstrncmp_nocase_1:
   \   00000020   019089E2           ADD      R9,R9,#+1
   \                     ??wstrncmp_nocase_0:
   \   00000024   090055E1           CMP      R5,R9
   \   00000028   090057A1           CMPGE    R7,R9
   \   0000002C   090058A1           CMPGE    R8,R9
   \   00000030   130000BA           BLT      ??wstrncmp_nocase_2
   \   00000034   890084E0           ADD      R0,R4,R9, LSL #+1
   \   00000038   B0A0D0E1           LDRH     R10,[R0, #+0]
   \   0000003C   890086E0           ADD      R0,R6,R9, LSL #+1
   \   00000040   B0B0D0E1           LDRH     R11,[R0, #+0]
   \   00000044   400D5AE3           CMP      R10,#+4096
   \   00000048   400D5BB3           CMPLT    R11,#+4096
   \   0000004C   090000AA           BGE      ??wstrncmp_nocase_3
   \   00000050   0A00A0E1           MOV      R0,R10
   \   00000054   ........           BL       char16to8
   \   00000058   00A0A0E1           MOV      R10,R0
   \   0000005C   0B00A0E1           MOV      R0,R11
   \   00000060   ........           BL       char16to8
   \   00000064   00B0A0E1           MOV      R11,R0
   \   00000068   40001AE3           TST      R10,#0x40
   \   0000006C   DFA00A12           ANDNE    R10,R10,#0xDF
   \   00000070   40001BE3           TST      R11,#0x40
   \   00000074   DFB00B12           ANDNE    R11,R11,#0xDF
   \                     ??wstrncmp_nocase_3:
   \   00000078   0B005AE0           SUBS     R0,R10,R11
   \   0000007C   E7FFFF0A           BEQ      ??wstrncmp_nocase_1
   \   00000080   F08FBDE8           POP      {R4-R11,PC}
    249            }
    250            return 0;
   \                     ??wstrncmp_nocase_2:
   \   00000084   0000A0E3           MOV      R0,#+0
   \   00000088   F08FBDE8           POP      {R4-R11,PC}      ;; return
    251          }
    252          

   \                                 In segment CODE, align 4, keep-with-next
    253          void wsInsert(WSHDR *ws, WSHDR *txt, int pos, int max) //start form 0;
    254          {
   \                     wsInsert:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   0370A0E1           MOV      R7,R3
    255            unsigned short *st;
    256            int cplen;	
    257            if((!ws)||(!txt)||(!wstrlen(txt)))
   \   00000014   000054E3           CMP      R4,#+0
   \   00000018   00005513           CMPNE    R5,#+0
   \   0000001C   F083BD08           POPEQ    {R4-R9,PC}
   \   00000020   0500A0E1           MOV      R0,R5
   \   00000024   230100EF           SWI      +291
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   F083BD08           POPEQ    {R4-R9,PC}
    258              return;
    259            if(pos>(ws->wsbody[0]))
   \   00000030   000094E5           LDR      R0,[R4, #+0]
   \   00000034   B010D0E1           LDRH     R1,[R0, #+0]
   \   00000038   060051E1           CMP      R1,R6
   \   0000003C   F083BDB8           POPLT    {R4-R9,PC}
    260              return;
    261            if((pos+(txt->wsbody[0]))>=max)
   \   00000040   001095E5           LDR      R1,[R5, #+0]
   \   00000044   068047E0           SUB      R8,R7,R6
   \   00000048   B020D1E1           LDRH     R2,[R1, #+0]
   \   0000004C   062082E0           ADD      R2,R2,R6
   \   00000050   070052E1           CMP      R2,R7
   \   00000054   070000BA           BLT      ??wsInsert_0
    262            {
    263              CutWSTR(ws, pos);
   \   00000058   0610A0E1           MOV      R1,R6
   \   0000005C   0400A0E1           MOV      R0,R4
   \   00000060   260100EF           SWI      +294
    264              wstrncat(ws, txt, max-pos); 
   \   00000064   0820A0E1           MOV      R2,R8
   \   00000068   0510A0E1           MOV      R1,R5
   \   0000006C   0400A0E1           MOV      R0,R4
   \   00000070   220100EF           SWI      +290
    265              return;
   \   00000074   F083BDE8           POP      {R4-R9,PC}
    266            }
    267            if(ws->wsbody[0]+txt->wsbody[0] >= max)
   \                     ??wsInsert_0:
   \   00000078   B020D0E1           LDRH     R2,[R0, #+0]
   \   0000007C   B030D1E1           LDRH     R3,[R1, #+0]
   \   00000080   022083E0           ADD      R2,R3,R2
   \   00000084   070052E1           CMP      R2,R7
    268              cplen=max-(pos+txt->wsbody[0]);
    269            else
    270              cplen=ws->wsbody[0]-pos;
   \   00000088   B000D0B1           LDRHLT   R0,[R0, #+0]
   \   0000008C   037048A0           SUBGE    R7,R8,R3
   \   00000090   067040B0           SUBLT    R7,R0,R6
    271            st=malloc(cplen*sizeof(unsigned short));
   \   00000094   8700A0E1           LSL      R0,R7,#+1
   \   00000098   140000EF           SWI      +20
   \   0000009C   0080A0E1           MOV      R8,R0
    272            memcpy(st, ws->wsbody+pos+1, cplen*sizeof(unsigned short));
   \   000000A0   000094E5           LDR      R0,[R4, #+0]
   \   000000A4   8790A0E1           LSL      R9,R7,#+1
   \   000000A8   0920A0E1           MOV      R2,R9
   \   000000AC   860080E0           ADD      R0,R0,R6, LSL #+1
   \   000000B0   021080E2           ADD      R1,R0,#+2
   \   000000B4   0800A0E1           MOV      R0,R8
   \   000000B8   1E0100EF           SWI      +286
    273            memcpy(ws->wsbody+pos+1, txt->wsbody+1, (txt->wsbody[0])*sizeof(unsigned short));
   \   000000BC   000095E5           LDR      R0,[R5, #+0]
   \   000000C0   B010D0E1           LDRH     R1,[R0, #+0]
   \   000000C4   8120A0E1           LSL      R2,R1,#+1
   \   000000C8   021080E2           ADD      R1,R0,#+2
   \   000000CC   000094E5           LDR      R0,[R4, #+0]
   \   000000D0   860080E0           ADD      R0,R0,R6, LSL #+1
   \   000000D4   020080E2           ADD      R0,R0,#+2
   \   000000D8   1E0100EF           SWI      +286
    274            memcpy(ws->wsbody+1+pos+(txt->wsbody[0]), st, cplen*sizeof(unsigned short));
   \   000000DC   000095E5           LDR      R0,[R5, #+0]
   \   000000E0   003094E5           LDR      R3,[R4, #+0]
   \   000000E4   B000D0E1           LDRH     R0,[R0, #+0]
   \   000000E8   0920A0E1           MOV      R2,R9
   \   000000EC   0810A0E1           MOV      R1,R8
   \   000000F0   863083E0           ADD      R3,R3,R6, LSL #+1
   \   000000F4   800083E0           ADD      R0,R3,R0, LSL #+1
   \   000000F8   020080E2           ADD      R0,R0,#+2
   \   000000FC   1E0100EF           SWI      +286
    275            ws->wsbody[0]=pos+(txt->wsbody[0])+cplen;
   \   00000100   001095E5           LDR      R1,[R5, #+0]
   \   00000104   000094E5           LDR      R0,[R4, #+0]
   \   00000108   B010D1E1           LDRH     R1,[R1, #+0]
   \   0000010C   061081E0           ADD      R1,R1,R6
   \   00000110   011087E0           ADD      R1,R7,R1
   \   00000114   B010C0E1           STRH     R1,[R0, #+0]
    276            mfree(st);
   \   00000118   0800A0E1           MOV      R0,R8
   \   0000011C   150000EF           SWI      +21
    277          }
   \   00000120   F083BDE8           POP      {R4-R9,PC}       ;; return
    278          

   \                                 In segment CODE, align 4, keep-with-next
    279          int num_2ws(WSHDR *ws, const char *num, int maxlen)
    280          {
   \                     num_2ws:
   \   00000000   30002DE9           PUSH     {R4,R5}
    281            int i=0, c;
    282            const char *p=num;
    283            unsigned short *ps=ws->wsbody+1;
   \   00000004   004090E5           LDR      R4,[R0, #+0]
   \   00000008   0030A0E3           MOV      R3,#+0
   \   0000000C   01C0A0E1           MOV      R12,R1
   \   00000010   025084E2           ADD      R5,R4,#+2
    284            int max2;
    285            if( !ws || !num || !maxlen)
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   1400000A           BEQ      ??num_2ws_0
   \   0000001C   000051E3           CMP      R1,#+0
   \   00000020   00005213           CMPNE    R2,#+0
    286              return 0;
   \   00000024   0000A003           MOVEQ    R0,#+0
   \   00000028   1000000A           BEQ      ??num_2ws_0
   \   0000002C   B001D0E1           LDRH     R0,[R0, #+16]
   \   00000030   000052E1           CMP      R2,R0
   \   00000034   030000BA           BLT      ??num_2ws_1
   \   00000038   0020A0E1           MOV      R2,R0
   \   0000003C   010000EA           B        ??num_2ws_1
    287            max2=(maxlen < ws->maxlen)?maxlen:ws->maxlen;
    288            while(i<max2 && (c=*p++))
    289            {
    290              ps[i++]=c;
   \                     ??num_2ws_2:
   \   00000040   B010C0E1           STRH     R1,[R0, #+0]
   \   00000044   013083E2           ADD      R3,R3,#+1
    291            }
   \                     ??num_2ws_1:
   \   00000048   830085E0           ADD      R0,R5,R3, LSL #+1
   \   0000004C   020053E1           CMP      R3,R2
   \   00000050   020000AA           BGE      ??num_2ws_3
   \   00000054   ........           LDRB     R1,[R12], #+1
   \   00000058   000051E3           CMP      R1,#+0
   \   0000005C   F7FFFF1A           BNE      ??num_2ws_2
    292            ps[i]=0;
   \                     ??num_2ws_3:
   \   00000060   0010A0E3           MOV      R1,#+0
   \   00000064   B010C0E1           STRH     R1,[R0, #+0]
    293            return (ws->wsbody[0]=i);
   \   00000068   B030C4E1           STRH     R3,[R4, #+0]
   \   0000006C   B000D4E1           LDRH     R0,[R4, #+0]
   \                     ??num_2ws_0:
   \   00000070   3000BDE8           POP      {R4,R5}
   \   00000074   1EFF2FE1           BX       LR               ;; return
    294          }
    295          

   \                                 In segment CODE, align 4, keep-with-next
    296          int ws_2num(WSHDR *ws, char *num, int maxlen)
    297          {
   \                     ws_2num:
   \   00000000   10002DE9           PUSH     {R4}
    298            int i=0, c;
    299            int max2;
    300            unsigned short *ps=ws->wsbody+1;
   \   00000004   00C090E5           LDR      R12,[R0, #+0]
   \   00000008   0030A0E3           MOV      R3,#+0
    301            if( !ws || !num || !maxlen)
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   02408CE2           ADD      R4,R12,#+2
   \   00000014   1100000A           BEQ      ??ws_2num_0
   \   00000018   000051E3           CMP      R1,#+0
   \   0000001C   00005213           CMPNE    R2,#+0
   \   00000020   0D00000A           BEQ      ??ws_2num_1
    302              return 0;
    303            max2=(ws->wsbody[0] < maxlen)?ws->wsbody[0]:maxlen;
   \   00000024   B000DCE1           LDRH     R0,[R12, #+0]
   \   00000028   020050E1           CMP      R0,R2
   \   0000002C   030000AA           BGE      ??ws_2num_2
   \   00000030   0020A0E1           MOV      R2,R0
   \   00000034   010000EA           B        ??ws_2num_2
    304            while(i<max2 && (c=*ps++))
    305            {
    306              num[i++]=c;
   \                     ??ws_2num_3:
   \   00000038   0100C3E7           STRB     R0,[R3, +R1]
   \   0000003C   013083E2           ADD      R3,R3,#+1
    307            }
   \                     ??ws_2num_2:
   \   00000040   020053E1           CMP      R3,R2
   \   00000044   020000AA           BGE      ??ws_2num_4
   \   00000048   ........           LDRH     R0,[R4], #+2
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   F8FFFF1A           BNE      ??ws_2num_3
    308            num[i]=0;
   \                     ??ws_2num_4:
   \   00000054   0000A0E3           MOV      R0,#+0
   \   00000058   0100C3E7           STRB     R0,[R3, +R1]
    309            return i;
   \                     ??ws_2num_1:
   \   0000005C   0300A0E1           MOV      R0,R3
   \                     ??ws_2num_0:
   \   00000060   1000BDE8           POP      {R4}
   \   00000064   1EFF2FE1           BX       LR               ;; return
    310          }
    311          

   \                                 In segment CODE, align 4, keep-with-next
    312          int str2int(const char *str)
    313          {
   \                     str2int:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    314            int i, r=0, c, len, n;
   \   00000008   0050A0E3           MOV      R5,#+0
    315            if(!str || !(len=strlen(str)))
   \   0000000C   1800000A           BEQ      ??str2int_0
   \   00000010   1B0000EF           SWI      +27
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   1500000A           BEQ      ??str2int_0
    316              return 0;
    317            if(len>10) len=10;
   \   0000001C   0B0050E3           CMP      R0,#+11
   \   00000020   0A00A0A3           MOVGE    R0,#+10
    318            len--;
   \   00000024   010040E2           SUB      R0,R0,#+1
    319            for(i=len;i>=0;i--)
   \   00000028   0010A0E1           MOV      R1,R0
   \   0000002C   0AC0A0E3           MOV      R12,#+10
   \   00000030   080000EA           B        ??str2int_1
    320            {
    321              c=str[i];
    322              if(c<'0' || c>'9')
    323                break;
    324              n=len-i;
   \                     ??str2int_2:
   \   00000034   012040E0           SUB      R2,R0,R1
    325              c-='0';
   \   00000038   303043E2           SUB      R3,R3,#+48
   \   0000003C   000052E3           CMP      R2,#+0
   \   00000040   0200000A           BEQ      ??str2int_3
    326              while(n)
    327              {
    328                c*=10;
   \                     ??str2int_4:
   \   00000044   9C0303E0           MUL      R3,R12,R3
    329                n--;
   \   00000048   012052E2           SUBS     R2,R2,#+1
    330              }
   \   0000004C   FCFFFF1A           BNE      ??str2int_4
    331              r+=c;
   \                     ??str2int_3:
   \   00000050   055083E0           ADD      R5,R3,R5
   \   00000054   011041E2           SUB      R1,R1,#+1
   \                     ??str2int_1:
   \   00000058   000051E3           CMP      R1,#+0
   \   0000005C   0400004A           BMI      ??str2int_0
   \   00000060   0430D1E7           LDRB     R3,[R1, +R4]
   \   00000064   300053E3           CMP      R3,#+48
   \   00000068   010000BA           BLT      ??str2int_0
   \   0000006C   3A0053E3           CMP      R3,#+58
   \   00000070   EFFFFFBA           BLT      ??str2int_2
    332            }
    333            return r;
   \                     ??str2int_0:
   \   00000074   0500A0E1           MOV      R0,R5
   \   00000078   3080BDE8           POP      {R4,R5,PC}       ;; return
    334          }
    335          #ifdef MM
    336          char *GotoCurChar(unsigned char *p, int c)
    337          {
    338            int i;
    339            while((i=*p++))
    340            {
    341              if(i==c) return p;
    342            }
    343            return 0;
    344          }
    345          
    346          int IsHaveBigChar(unsigned char *p, int len)
    347          {
    348            int c;
    349            unsigned char *pp=p;
    350            while((pp-p<len) && (c=*p++))
    351            {
    352              if(c>0x80) return 1;
    353            }
    354            return 0;
    355          }
    356          
    357          void NmlUtf8P_2SieUtf8P(char *utf8s)
    358          {
    359            char *p;
    360            char *p1;
    361            char *p2=utf8s;
    362            while((p=GotoCurChar(p2, '\\')) || (p=GotoCurChar(p2, '/')))
    363            {
    364              if(*p==0x1F) continue;
    365              if(!(p1=GotoCurChar(p, '\\')))
    366              {
    367                if(!(p1=GotoCurChar(p, '/')))
    368          	 p1=p+strlen(p);
    369              }
    370              if(IsHaveBigChar(p, p1-p))
    371              {
    372                //后移
    373                p1=p+strlen(p);
    374                while(p1>p)
    375                {
    376          	*(p1+1)=*p1;
    377          	p1--;
    378                }
    379                *p=0x1F;
    380              }
    381              p2=p;
    382            }
    383          }
    384          
    385          void SieUtf8P_2NmlUtf8P(char *s)
    386          {
    387            //直接清理掉0x1F就行
    388            char *p=s;
    389            int c;
    390            char *p1;
    391            while((c=*p))
    392            {
    393              if(c==0x1F)
    394              {
    395                p1=p;
    396                while(*p1)
    397                {
    398          	*p1=*(p1+1);
    399          	p1++;
    400                }
    401              }
    402              p++;
    403            }
    404          }
    405          #endif

   \                                 In segment CODE, align 4, keep-with-next
    406          int IsWsSmall(WSHDR *ws)
    407          {
    408            int i;
    409            if(!ws) return 0;
   \                     IsWsSmall:
   \   00000000   000050E3           CMP      R0,#+0
   \   00000004   0100001A           BNE      ??IsWsSmall_0
   \                     ??IsWsSmall_1:
   \   00000008   0000A0E3           MOV      R0,#+0
   \   0000000C   1EFF2FE1           BX       LR
    410            for(i=0;i<ws->wsbody[0];i++)
   \                     ??IsWsSmall_0:
   \   00000010   000090E5           LDR      R0,[R0, #+0]
   \   00000014   0010A0E3           MOV      R1,#+0
   \   00000018   040000EA           B        ??IsWsSmall_2
    411            {
    412              if(ws->wsbody[i+1]>0x80) return 0;
   \                     ??IsWsSmall_3:
   \   0000001C   812080E0           ADD      R2,R0,R1, LSL #+1
   \   00000020   B220D2E1           LDRH     R2,[R2, #+2]
   \   00000024   810052E3           CMP      R2,#+129
   \   00000028   F6FFFF2A           BCS      ??IsWsSmall_1
    413            }
   \   0000002C   011081E2           ADD      R1,R1,#+1
   \                     ??IsWsSmall_2:
   \   00000030   B020D0E1           LDRH     R2,[R0, #+0]
   \   00000034   020051E1           CMP      R1,R2
   \   00000038   F7FFFFBA           BLT      ??IsWsSmall_3
    414            return 1;
   \   0000003C   0100A0E3           MOV      R0,#+1
   \   00000040   1EFF2FE1           BX       LR               ;; return
    415          }
    416          

   Maximum stack usage in bytes:

     Function        CSTACK
     --------        ------
     IsWsSmall           0
     ascii_2ws          12
     char16to8           0
     char8to16           0
     num_2ws             8
     str2int            12
     wsInsert           28
     ws_2ascii          24
     ws_2num             4
     wstrcmp_nocase     32
     wstrncmp_nocase    36


   Segment part sizes:

     Function/Label  Bytes
     --------------  -----
     char16to8        140
     win2unicode      256
     char8to16         32
     ws_2ascii         88
     ascii_2ws         56
     wstrcmp_nocase   132
     wstrncmp_nocase  140
     wsInsert         292
     num_2ws          120
     ws_2num          104
     str2int          124
     IsWsSmall         68
      Others           44

 
 1 340 bytes in segment CODE
   256 bytes in segment DATA_C
 
 1 296 bytes of CODE  memory (+ 44 bytes shared)
   256 bytes of CONST memory

Errors: none
Warnings: none
