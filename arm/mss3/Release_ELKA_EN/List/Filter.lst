##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    13/Jan/2011  22:52:11 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\mss3\Filter.c                                 #
#    Command line    =  C:\arm\mss3\Filter.c -D NEWSGOLD -D ELKA -D LANG_EN  #
#                       -D NO_CS -lC C:\arm\mss3\Release_ELKA_EN\List\ -o    #
#                       C:\arm\mss3\Release_ELKA_EN\Obj\ -s9 --no_unroll     #
#                       --cpu_mode arm --endian little --cpu ARM926EJ-S      #
#                       --stack_align 4 --interwork -e --fpu None            #
#                       --dlib_config "C:\arm2\Embedded Workbench 4.0        #
#                       Evaluation\ARM\LIB\dl5tpainl8n.h" -I                 #
#                       "C:\arm2\Embedded Workbench 4.0                      #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  C:\arm\mss3\Release_ELKA_EN\List\Filter.lst          #
#    Object file     =  C:\arm\mss3\Release_ELKA_EN\Obj\Filter.r79           #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\mss3\Filter.c
      1          #include "..\inc\swilib.h"
      2          #include "config_data.h"
      3          #include "sms_dat.h"
      4          #include "Filter.h"
      5          
      6          #define FILTER_ALL	0
      7          #define FILTER_NEW	1
      8          #define FILTER_DAT	2
      9          #define FILTER_FILE	3
     10          #define FILTER_NUM	4
     11          #define FILTER_STR	5
     12          

   \                                 In segment CODE, align 4, keep-with-next
     13          SMS_DATA *GetDatFileByNSD(int n, int isfile)
     14          {
     15            int i=0;
     16            SMS_DATA *sdl=sdltop;
   \                     GetDatFileByNSD:
   \   00000000   ........           LDR      R2,??DataTable5  ;; sdltop
   \   00000004   0030A0E3           MOV      R3,#+0
   \   00000008   000000EA           B        ??GetDatFileByNSD_0
     17            while(sdl)
     18            {
     19              if(sdl->isfile==isfile)
     20              {
     21                if(i==n) return sdl;
     22                i++;
   \                     ??GetDatFileByNSD_1:
   \   0000000C   013083E2           ADD      R3,R3,#+1
     23              }
     24              sdl=sdl->next;
   \                     ??GetDatFileByNSD_0:
   \   00000010   002092E5           LDR      R2,[R2, #+0]
   \   00000014   000052E3           CMP      R2,#+0
   \   00000018   0600000A           BEQ      ??GetDatFileByNSD_2
   \   0000001C   14C092E5           LDR      R12,[R2, #+20]
   \   00000020   01005CE1           CMP      R12,R1
   \   00000024   F9FFFF1A           BNE      ??GetDatFileByNSD_0
   \   00000028   000053E1           CMP      R3,R0
   \   0000002C   F6FFFF1A           BNE      ??GetDatFileByNSD_1
   \   00000030   0200A0E1           MOV      R0,R2
   \   00000034   1EFF2FE1           BX       LR
     25            }
     26            return 0;
   \                     ??GetDatFileByNSD_2:
   \   00000038   0000A0E3           MOV      R0,#+0
   \   0000003C   1EFF2FE1           BX       LR               ;; return
     27          }
     28          

   \                                 In segment CODE, align 4, keep-with-next
     29          int GetDatFileSDLCount(int isfile)
     30          {
     31            int i=0;
     32            SMS_DATA *sdl=sdltop;
   \                     GetDatFileSDLCount:
   \   00000000   ........           LDR      R2,??DataTable5  ;; sdltop
   \   00000004   0010A0E3           MOV      R1,#+0
   \   00000008   002092E5           LDR      R2,[R2, #+0]
   \   0000000C   000052E3           CMP      R2,#+0
   \   00000010   0500000A           BEQ      ??GetDatFileSDLCount_0
     33            while(sdl)
     34            {
     35              if(sdl->isfile==isfile)
   \                     ??GetDatFileSDLCount_1:
   \   00000014   143092E5           LDR      R3,[R2, #+20]
     36              {
     37                i++;
     38              }
     39              sdl=sdl->next;
   \   00000018   002092E5           LDR      R2,[R2, #+0]
   \   0000001C   000053E1           CMP      R3,R0
   \   00000020   01108102           ADDEQ    R1,R1,#+1
     40            }
   \   00000024   000052E3           CMP      R2,#+0
   \   00000028   F9FFFF1A           BNE      ??GetDatFileSDLCount_1
     41            return i;
   \                     ??GetDatFileSDLCount_0:
   \   0000002C   0100A0E1           MOV      R0,R1
   \   00000030   1EFF2FE1           BX       LR               ;; return
     42          }
     43          

   \                                 In segment CODE, align 4, keep-with-next
     44          SMS_DATA *GetNumSD(int n, const char *num)
     45          {
   \                     GetNumSD:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
     46            int i=0, len, len2, lx;
     47            const char *p2, *pt;
     48            const char *p=num;
     49            SMS_DATA *sdl=sdltop;
   \   00000008   ........           LDR      R0,??DataTable5  ;; sdltop
   \   0000000C   0170B0E1           MOVS     R7,R1
   \   00000010   008090E5           LDR      R8,[R0, #+0]
   \   00000014   0060A0E3           MOV      R6,#+0
     50            if(!p) return 0;
   \   00000018   0100001A           BNE      ??GetNumSD_0
   \                     ??GetNumSD_1:
   \   0000001C   0000A0E3           MOV      R0,#+0
   \   00000020   F087BDE8           POP      {R4-R10,PC}      ;; return
     51            if(*p=='+') p++;
   \                     ??GetNumSD_0:
   \   00000024   0000D7E5           LDRB     R0,[R7, #+0]
   \   00000028   2B0050E3           CMP      R0,#+43
   \   0000002C   01708702           ADDEQ    R7,R7,#+1
     52            len=strlen(p);
   \   00000030   0700A0E1           MOV      R0,R7
   \   00000034   1B0000EF           SWI      +27
   \   00000038   0090A0E1           MOV      R9,R0
   \   0000003C   0D0000EA           B        ??GetNumSD_2
     53            while(sdl)
     54            {
     55              len2=strlen((p2=sdl->Number));
     56              if(len2>len)
     57              {
     58                if((lx=len2-len)>3)
     59                {
     60          	sdl=sdl->next;
     61          	continue;
     62                }
     63                p2+=lx;
     64              }
     65              else
     66              {
     67                if((lx=len-len2)>3)
   \                     ??GetNumSD_3:
   \   00000040   000049E0           SUB      R0,R9,R0
   \   00000044   040050E3           CMP      R0,#+4
   \   00000048   090000AA           BGE      ??GetNumSD_4
     68                {
     69          	sdl=sdl->next;
     70          	continue;
     71                }
     72                pt=p+lx;
   \   0000004C   075080E0           ADD      R5,R0,R7
     73              }
     74              if(!strcmp(pt, p2))
   \                     ??GetNumSD_5:
   \   00000050   0A10A0E1           MOV      R1,R10
   \   00000054   0500A0E1           MOV      R0,R5
   \   00000058   190000EF           SWI      +25
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   0300001A           BNE      ??GetNumSD_4
     75              {
     76                if(i==n) return sdl;
   \   00000064   040056E1           CMP      R6,R4
   \   00000068   0800A001           MOVEQ    R0,R8
   \   0000006C   F087BD08           POPEQ    {R4-R10,PC}
     77                i++;
   \   00000070   016086E2           ADD      R6,R6,#+1
     78              }
   \                     ??GetNumSD_4:
   \   00000074   008098E5           LDR      R8,[R8, #+0]
   \                     ??GetNumSD_2:
   \   00000078   000058E3           CMP      R8,#+0
   \   0000007C   E6FFFF0A           BEQ      ??GetNumSD_1
   \   00000080   24A088E2           ADD      R10,R8,#+36
   \   00000084   0A00A0E1           MOV      R0,R10
   \   00000088   1B0000EF           SWI      +27
   \   0000008C   000059E1           CMP      R9,R0
   \   00000090   EAFFFFAA           BGE      ??GetNumSD_3
   \   00000094   090040E0           SUB      R0,R0,R9
   \   00000098   040050E3           CMP      R0,#+4
   \   0000009C   F4FFFFAA           BGE      ??GetNumSD_4
   \   000000A0   0AA080E0           ADD      R10,R0,R10
   \   000000A4   E9FFFFEA           B        ??GetNumSD_5
     79              sdl=sdl->next;
     80            }
     81            return 0;
     82          }
     83          

   \                                 In segment CODE, align 4, keep-with-next
     84          int GetNumSDCount(const char *num)
     85          {
   \                     GetNumSDCount:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0060B0E1           MOVS     R6,R0
     86            int i=0, len, len2, lx;
     87            const char *p2, *pt;
     88            const char *p=num;
     89            SMS_DATA *sdl=sdltop;
   \   00000008   ........           LDR      R0,??DataTable5  ;; sdltop
   \   0000000C   0050A0E3           MOV      R5,#+0
   \   00000010   007090E5           LDR      R7,[R0, #+0]
     90            if(!p) return 0;
   \   00000014   0700000A           BEQ      ??GetNumSDCount_0
     91            if(*p=='+') p++;
   \   00000018   0000D6E5           LDRB     R0,[R6, #+0]
   \   0000001C   2B0050E3           CMP      R0,#+43
   \   00000020   01608602           ADDEQ    R6,R6,#+1
     92            len=strlen(p);
   \   00000024   0600A0E1           MOV      R0,R6
   \   00000028   1B0000EF           SWI      +27
   \   0000002C   0080A0E1           MOV      R8,R0
   \   00000030   000057E3           CMP      R7,#+0
   \   00000034   0D00001A           BNE      ??GetNumSDCount_1
     93            while(sdl)
     94            {
     95              len2=strlen((p2=sdl->Number));
     96              if(len2>len)
     97              {
     98                if((lx=len2-len)>3)
     99                {
    100          	sdl=sdl->next;
    101          	continue;
    102                }
    103                p2+=lx;
    104              }
    105              else
    106              {
    107                if((lx=len-len2)>3)
    108                {
    109          	sdl=sdl->next;
    110          	continue;
    111                }
    112                pt=p+lx;
    113              }
    114              if(!strcmp(pt, p2))
    115              {
    116                i++;
    117              }
    118              sdl=sdl->next;
    119            }
    120            return i;
   \                     ??GetNumSDCount_0:
   \   00000038   0500A0E1           MOV      R0,R5
   \   0000003C   F083BDE8           POP      {R4-R9,PC}       ;; return
   \                     ??GetNumSDCount_2:
   \   00000040   000048E0           SUB      R0,R8,R0
   \   00000044   040050E3           CMP      R0,#+4
   \   00000048   050000AA           BGE      ??GetNumSDCount_3
   \   0000004C   064080E0           ADD      R4,R0,R6
   \                     ??GetNumSDCount_4:
   \   00000050   0910A0E1           MOV      R1,R9
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   190000EF           SWI      +25
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   01508502           ADDEQ    R5,R5,#+1
   \                     ??GetNumSDCount_3:
   \   00000064   007097E5           LDR      R7,[R7, #+0]
   \   00000068   000057E3           CMP      R7,#+0
   \   0000006C   F1FFFF0A           BEQ      ??GetNumSDCount_0
   \                     ??GetNumSDCount_1:
   \   00000070   249087E2           ADD      R9,R7,#+36
   \   00000074   0900A0E1           MOV      R0,R9
   \   00000078   1B0000EF           SWI      +27
   \   0000007C   000058E1           CMP      R8,R0
   \   00000080   EEFFFFAA           BGE      ??GetNumSDCount_2
   \   00000084   080040E0           SUB      R0,R0,R8
   \   00000088   040050E3           CMP      R0,#+4
   \   0000008C   F4FFFFAA           BGE      ??GetNumSDCount_3
   \   00000090   099080E0           ADD      R9,R0,R9
   \   00000094   EDFFFFEA           B        ??GetNumSDCount_4
    121          }
    122          

   \                                 In segment CODE, align 4, keep-with-next
    123          int w_charcmp_nocase(unsigned short *t1, unsigned short *t2, int len)
    124          {
   \                     w_charcmp_nocase:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
    125            int pos=0, cs, ds;
   \   00000010   0070A0E3           MOV      R7,#+0
   \   00000014   000000EA           B        ??w_charcmp_nocase_0
    126            while(pos<len)
    127            {
    128              cs=t1[pos];
    129              ds=t2[pos];
    130              if(cs<0x1000 && ds<0x1000)
    131              {
    132                extern int char16to8(int c);
    133                cs=char16to8(cs);
    134                ds=char16to8(ds);
    135                if(cs&0x40) cs&=0xDF;
    136                if(ds&0x40) ds&=0xDF;
    137              }
    138              cs-=ds;
    139              if(cs) return cs;
    140              pos++;
   \                     ??w_charcmp_nocase_1:
   \   00000018   017087E2           ADD      R7,R7,#+1
   \                     ??w_charcmp_nocase_0:
   \   0000001C   060057E1           CMP      R7,R6
   \   00000020   130000AA           BGE      ??w_charcmp_nocase_2
   \   00000024   870084E0           ADD      R0,R4,R7, LSL #+1
   \   00000028   B080D0E1           LDRH     R8,[R0, #+0]
   \   0000002C   870085E0           ADD      R0,R5,R7, LSL #+1
   \   00000030   B090D0E1           LDRH     R9,[R0, #+0]
   \   00000034   400D58E3           CMP      R8,#+4096
   \   00000038   400D59B3           CMPLT    R9,#+4096
   \   0000003C   090000AA           BGE      ??w_charcmp_nocase_3
   \   00000040   0800A0E1           MOV      R0,R8
   \   00000044   ........           _BLF     char16to8,??char16to8??rA
   \   00000048   0080A0E1           MOV      R8,R0
   \   0000004C   0900A0E1           MOV      R0,R9
   \   00000050   ........           _BLF     char16to8,??char16to8??rA
   \   00000054   0090A0E1           MOV      R9,R0
   \   00000058   400018E3           TST      R8,#0x40
   \   0000005C   DF800812           ANDNE    R8,R8,#0xDF
   \   00000060   400019E3           TST      R9,#0x40
   \   00000064   DF900912           ANDNE    R9,R9,#0xDF
   \                     ??w_charcmp_nocase_3:
   \   00000068   090058E0           SUBS     R0,R8,R9
   \   0000006C   E9FFFF0A           BEQ      ??w_charcmp_nocase_1
   \   00000070   F083BDE8           POP      {R4-R9,PC}
    141            }
    142            return 0;
   \                     ??w_charcmp_nocase_2:
   \   00000074   0000A0E3           MOV      R0,#+0
   \   00000078   F083BDE8           POP      {R4-R9,PC}       ;; return
    143          }
    144          

   \                                 In segment CODE, align 4, keep-with-next
    145          unsigned short *wstrstr(WSHDR *wstr, WSHDR *ws)
    146          {
   \                     wstrstr:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
    147            int len, len2, i=0;
   \   00000004   0060A0E3           MOV      R6,#+0
    148            unsigned short *p, *p2;
    149            if(!wstr || !ws || !(len=ws->wsbody[0])) return 0;
   \   00000008   000050E3           CMP      R0,#+0
   \   0000000C   F083BD08           POPEQ    {R4-R9,PC}
   \   00000010   000051E3           CMP      R1,#+0
   \   00000014   0300000A           BEQ      ??wstrstr_0
   \   00000018   001091E5           LDR      R1,[R1, #+0]
   \   0000001C   B040D1E1           LDRH     R4,[R1, #+0]
   \   00000020   000054E3           CMP      R4,#+0
   \   00000024   0100001A           BNE      ??wstrstr_1
   \                     ??wstrstr_0:
   \   00000028   0000A0E3           MOV      R0,#+0
   \   0000002C   F083BDE8           POP      {R4-R9,PC}
    150            if((len2=wstr->wsbody[0])<len) return 0;
   \                     ??wstrstr_1:
   \   00000030   000090E5           LDR      R0,[R0, #+0]
   \   00000034   B050D0E1           LDRH     R5,[R0, #+0]
   \   00000038   040055E1           CMP      R5,R4
   \   0000003C   F9FFFFBA           BLT      ??wstrstr_0
    151            p=ws->wsbody+1;
   \   00000040   027081E2           ADD      R7,R1,#+2
    152            p2=wstr->wsbody+1;
   \   00000044   028080E2           ADD      R8,R0,#+2
   \   00000048   000000EA           B        ??wstrstr_2
    153            while(len2-i>=len)
    154            {
    155              if(!w_charcmp_nocase(p, p2+i, len))
    156                return (p2+i);
    157              i++;
   \                     ??wstrstr_3:
   \   0000004C   016086E2           ADD      R6,R6,#+1
   \                     ??wstrstr_2:
   \   00000050   060045E0           SUB      R0,R5,R6
   \   00000054   040050E1           CMP      R0,R4
   \   00000058   F2FFFFBA           BLT      ??wstrstr_0
   \   0000005C   869088E0           ADD      R9,R8,R6, LSL #+1
   \   00000060   0420A0E1           MOV      R2,R4
   \   00000064   0910A0E1           MOV      R1,R9
   \   00000068   0700A0E1           MOV      R0,R7
   \   0000006C   ........           BL       w_charcmp_nocase
   \   00000070   000050E3           CMP      R0,#+0
   \   00000074   F4FFFF1A           BNE      ??wstrstr_3
   \   00000078   0900A0E1           MOV      R0,R9
   \   0000007C   F083BDE8           POP      {R4-R9,PC}       ;; return
    158            }
    159            return 0;
    160          }
    161          

   \                                 In segment CODE, align 4, keep-with-next
    162          SMS_DATA *GetStrSD(int n, const char *utf8_str)
    163          {
   \                     GetStrSD:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   94D04DE2           SUB      SP,SP,#+148
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
    164            int i=0;
    165            WSHDR *ws, wsn;
    166            unsigned short wsb[64];
    167            ws=CreateLocalWS(&wsn, wsb, 64);
   \   00000010   4020A0E3           MOV      R2,#+64
   \   00000014   0D10A0E1           MOV      R1,SP
   \   00000018   80008DE2           ADD      R0,SP,#+128
   \   0000001C   270100EF           SWI      +295
   \   00000020   0070A0E1           MOV      R7,R0
    168            utf8_2ws(ws, utf8_str, 64);
   \   00000024   4020A0E3           MOV      R2,#+64
   \   00000028   0510A0E1           MOV      R1,R5
   \   0000002C   E30100EF           SWI      +483
    169            SMS_DATA *sdl=sdltop;
   \   00000030   ........           LDR      R0,??DataTable5  ;; sdltop
   \   00000034   0060A0E3           MOV      R6,#+0
   \   00000038   005090E5           LDR      R5,[R0, #+0]
   \   0000003C   010000EA           B        ??GetStrSD_0
    170            while(sdl)
    171            {
    172              if(wstrstr(sdl->SMS_TEXT, ws))
    173              {
    174                if(i==n) return sdl;
    175                i++;
   \                     ??GetStrSD_1:
   \   00000040   016086E2           ADD      R6,R6,#+1
    176              }
    177              sdl=sdl->next;
   \                     ??GetStrSD_2:
   \   00000044   005095E5           LDR      R5,[R5, #+0]
   \                     ??GetStrSD_0:
   \   00000048   000055E3           CMP      R5,#+0
   \   0000004C   0900000A           BEQ      ??GetStrSD_3
   \   00000050   640095E5           LDR      R0,[R5, #+100]
   \   00000054   0710A0E1           MOV      R1,R7
   \   00000058   ........           BL       wstrstr
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   F7FFFF0A           BEQ      ??GetStrSD_2
   \   00000064   040056E1           CMP      R6,R4
   \   00000068   F4FFFF1A           BNE      ??GetStrSD_1
   \   0000006C   0500A0E1           MOV      R0,R5
   \   00000070   94D08DE2           ADD      SP,SP,#+148
   \   00000074   F080BDE8           POP      {R4-R7,PC}
    178            }
    179            return 0;
   \                     ??GetStrSD_3:
   \   00000078   0000A0E3           MOV      R0,#+0
   \   0000007C   94D08DE2           ADD      SP,SP,#+148
   \   00000080   F080BDE8           POP      {R4-R7,PC}       ;; return
    180          }
    181          

   \                                 In segment CODE, align 4, keep-with-next
    182          int GetStrSDCount(const char *utf8_str)
    183          {
   \                     GetStrSDCount:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   94D04DE2           SUB      SP,SP,#+148
   \   00000008   0040A0E1           MOV      R4,R0
    184            int i=0;
    185            WSHDR *ws, wsn;
    186            unsigned short wsb[64];
    187            ws=CreateLocalWS(&wsn, wsb, 64);
   \   0000000C   4020A0E3           MOV      R2,#+64
   \   00000010   0D10A0E1           MOV      R1,SP
   \   00000014   80008DE2           ADD      R0,SP,#+128
   \   00000018   270100EF           SWI      +295
   \   0000001C   0060A0E1           MOV      R6,R0
    188            utf8_2ws(ws, utf8_str, 64);
   \   00000020   4020A0E3           MOV      R2,#+64
   \   00000024   0410A0E1           MOV      R1,R4
   \   00000028   E30100EF           SWI      +483
    189            SMS_DATA *sdl=sdltop;
   \   0000002C   ........           LDR      R0,??DataTable5  ;; sdltop
   \   00000030   0050A0E3           MOV      R5,#+0
   \   00000034   004090E5           LDR      R4,[R0, #+0]
   \   00000038   000054E3           CMP      R4,#+0
   \   0000003C   0700000A           BEQ      ??GetStrSDCount_0
    190            while(sdl)
    191            {
    192              if(wstrstr(sdl->SMS_TEXT, ws))
   \                     ??GetStrSDCount_1:
   \   00000040   640094E5           LDR      R0,[R4, #+100]
   \   00000044   0610A0E1           MOV      R1,R6
   \   00000048   ........           BL       wstrstr
    193                i++;
    194              sdl=sdl->next;
   \   0000004C   004094E5           LDR      R4,[R4, #+0]
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   01508512           ADDNE    R5,R5,#+1
    195            }
   \   00000058   000054E3           CMP      R4,#+0
   \   0000005C   F7FFFF1A           BNE      ??GetStrSDCount_1
    196            return i;
   \                     ??GetStrSDCount_0:
   \   00000060   0500A0E1           MOV      R0,R5
   \   00000064   94D08DE2           ADD      SP,SP,#+148
   \   00000068   7080BDE8           POP      {R4-R6,PC}       ;; return
    197          }
    198          

   \                                 In segment CODE, align 4, keep-with-next
    199          SMS_DATA *FilterFindSDL(int n)
    200          {
    201            //GetCPUClock();
    202            switch(CFG_FILTEROP)
   \                     FilterFindSDL:
   \   00000000   ........           LDR      R2,??DataTable12  ;; CFG_FILTEROP
   \   00000004   ........           LDR      R1,??DataTable13  ;; CFG_STRORNUM
   \   00000008   00402DE9           PUSH     {LR}
   \   0000000C   002092E5           LDR      R2,[R2, #+0]
   \   00000010   050052E3           CMP      R2,#+5
   \   00000014   1400008A           BHI      ??FilterFindSDL_1
   \   00000018   013F8FE2           ADR      R3,??FilterFindSDL_0
   \   0000001C   0230D3E7           LDRB     R3,[R3, R2]
   \   00000020   03F18FE0           ADD      PC,PC,R3, LSL #+2
   \                     ??FilterFindSDL_0:
   \   00000024   0104070A           DC8      +1,+4,+7,+10
   \   00000028   0D0F0000           DC8      +13,+15,+0,+0
    203            {
    204            case FILTER_ALL:
    205              return (getSMSDataByType(n, 0));
   \                     ??FilterFindSDL_2:
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   ........           _BLF     getSMSDataByType,??getSMSDataByType??rA
   \   00000034   0080BDE8           POP      {PC}
    206            case FILTER_NEW:
    207              return (getSMSDataByType(n, TYPE_IN_N));
   \                     ??FilterFindSDL_3:
   \   00000038   0310A0E3           MOV      R1,#+3
   \   0000003C   ........           _BLF     getSMSDataByType,??getSMSDataByType??rA
   \   00000040   0080BDE8           POP      {PC}
    208            case FILTER_DAT:
    209              return (GetDatFileByNSD(n, 0));
   \                     ??FilterFindSDL_4:
   \   00000044   0010A0E3           MOV      R1,#+0
   \   00000048   ........           BL       GetDatFileByNSD
   \   0000004C   0080BDE8           POP      {PC}
    210            case FILTER_FILE:
    211              return (GetDatFileByNSD(n, 1));
   \                     ??FilterFindSDL_5:
   \   00000050   0110A0E3           MOV      R1,#+1
   \   00000054   ........           BL       GetDatFileByNSD
   \   00000058   0080BDE8           POP      {PC}
    212            case FILTER_NUM:
    213              return (GetNumSD(n, CFG_STRORNUM));
   \                     ??FilterFindSDL_6:
   \   0000005C   ........           BL       GetNumSD
   \   00000060   0080BDE8           POP      {PC}
    214            case FILTER_STR:
    215              return (GetStrSD(n, CFG_STRORNUM));
   \                     ??FilterFindSDL_7:
   \   00000064   ........           BL       GetStrSD
   \   00000068   0080BDE8           POP      {PC}
    216            default:
    217              return 0;
   \                     ??FilterFindSDL_1:
   \   0000006C   0000A0E3           MOV      R0,#+0
   \   00000070   0080BDE8           POP      {PC}             ;; return
    218            }
    219          }
    220          

   \                                 In segment CODE, align 4, keep-with-next
    221          int FilterGetCountSDL(void)
    222          {
    223            //GetCPUClock();
    224            switch(CFG_FILTEROP)
   \                     FilterGetCountSDL:
   \   00000000   ........           LDR      R1,??DataTable12  ;; CFG_FILTEROP
   \   00000004   ........           LDR      R0,??DataTable13  ;; CFG_STRORNUM
   \   00000008   00402DE9           PUSH     {LR}
   \   0000000C   001091E5           LDR      R1,[R1, #+0]
   \   00000010   050051E3           CMP      R1,#+5
   \   00000014   1400008A           BHI      ??FilterGetCountSDL_1
   \   00000018   012F8FE2           ADR      R2,??FilterGetCountSDL_0
   \   0000001C   0120D2E7           LDRB     R2,[R2, R1]
   \   00000020   02F18FE0           ADD      PC,PC,R2, LSL #+2
   \                     ??FilterGetCountSDL_0:
   \   00000024   0104070A           DC8      +1,+4,+7,+10
   \   00000028   0D0F0000           DC8      +13,+15,+0,+0
    225            {
    226            case FILTER_ALL:
    227              return (getCountByType(0));
   \                     ??FilterGetCountSDL_2:
   \   0000002C   0000A0E3           MOV      R0,#+0
   \   00000030   ........           _BLF     getCountByType,??getCountByType??rA
   \   00000034   0080BDE8           POP      {PC}
    228            case FILTER_NEW:
    229              return (getCountByType(TYPE_IN_N));
   \                     ??FilterGetCountSDL_3:
   \   00000038   0300A0E3           MOV      R0,#+3
   \   0000003C   ........           _BLF     getCountByType,??getCountByType??rA
   \   00000040   0080BDE8           POP      {PC}
    230            case FILTER_DAT:
    231              return (GetDatFileSDLCount(0));
   \                     ??FilterGetCountSDL_4:
   \   00000044   0000A0E3           MOV      R0,#+0
   \   00000048   ........           BL       GetDatFileSDLCount
   \   0000004C   0080BDE8           POP      {PC}
    232            case FILTER_FILE:
    233              return (GetDatFileSDLCount(1));
   \                     ??FilterGetCountSDL_5:
   \   00000050   0100A0E3           MOV      R0,#+1
   \   00000054   ........           BL       GetDatFileSDLCount
   \   00000058   0080BDE8           POP      {PC}
    234            case FILTER_NUM:
    235              return (GetNumSDCount(CFG_STRORNUM));
   \                     ??FilterGetCountSDL_6:
   \   0000005C   ........           BL       GetNumSDCount
   \   00000060   0080BDE8           POP      {PC}
    236            case FILTER_STR:
    237              return (GetStrSDCount(CFG_STRORNUM));
   \                     ??FilterGetCountSDL_7:
   \   00000064   ........           BL       GetStrSDCount
   \   00000068   0080BDE8           POP      {PC}
    238            default:
    239              return 0;
   \                     ??FilterGetCountSDL_1:
   \   0000006C   0000A0E3           MOV      R0,#+0
   \   00000070   0080BDE8           POP      {PC}             ;; return
    240            }
    241          }
    242          

   \                                 In segment CODE, align 4, keep-with-next
    243          SMS_DATA *GetNextNumSDL(SMS_DATA *sdl, const char *num)
    244          {
   \                     GetNextNumSDL:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    245            if(!sdl) return 0;
   \   0000000C   000054E3           CMP      R4,#+0
   \   00000010   0100001A           BNE      ??GetNextNumSDL_0
   \                     ??GetNextNumSDL_1:
   \   00000014   0000A0E3           MOV      R0,#+0
   \   00000018   F081BDE8           POP      {R4-R8,PC}
    246            int len, len2, lx;
    247            const char *p2, *pt;
    248            const char *p=num;
    249            if(!p) return 0;
   \                     ??GetNextNumSDL_0:
   \   0000001C   000055E3           CMP      R5,#+0
   \   00000020   FBFFFF0A           BEQ      ??GetNextNumSDL_1
    250            if(*p=='+') p++;
   \   00000024   0000D5E5           LDRB     R0,[R5, #+0]
   \   00000028   2B0050E3           CMP      R0,#+43
   \   0000002C   01508502           ADDEQ    R5,R5,#+1
    251            len=strlen(p);
   \   00000030   0500A0E1           MOV      R0,R5
   \   00000034   1B0000EF           SWI      +27
   \   00000038   0070A0E1           MOV      R7,R0
    252            sdl=sdl->next;
    253            while(sdl)
    254            {
    255              len2=strlen((p2=sdl->Number));
    256              if(len2>len)
    257              {
    258                if((lx=len2-len)>3)
    259                {
    260          	sdl=sdl->next;
   \                     ??GetNextNumSDL_2:
   \   0000003C   004094E5           LDR      R4,[R4, #+0]
    261          	continue;
    262                }
   \   00000040   000054E3           CMP      R4,#+0
   \   00000044   F2FFFF0A           BEQ      ??GetNextNumSDL_1
   \   00000048   248084E2           ADD      R8,R4,#+36
   \   0000004C   0800A0E1           MOV      R0,R8
   \   00000050   1B0000EF           SWI      +27
   \   00000054   000057E1           CMP      R7,R0
   \   00000058   040000AA           BGE      ??GetNextNumSDL_3
   \   0000005C   070040E0           SUB      R0,R0,R7
   \   00000060   040050E3           CMP      R0,#+4
   \   00000064   F4FFFFAA           BGE      ??GetNextNumSDL_2
    263                p2+=lx;
   \   00000068   088080E0           ADD      R8,R0,R8
   \   0000006C   030000EA           B        ??GetNextNumSDL_4
    264              }
    265              else
    266              {
    267                if((lx=len-len2)>3)
   \                     ??GetNextNumSDL_3:
   \   00000070   000047E0           SUB      R0,R7,R0
   \   00000074   040050E3           CMP      R0,#+4
   \   00000078   EFFFFFAA           BGE      ??GetNextNumSDL_2
    268                {
    269          	sdl=sdl->next;
    270          	continue;
    271                }
    272                pt=p+lx;
   \   0000007C   056080E0           ADD      R6,R0,R5
    273              }
    274              if(!strcmp(pt, p2))
   \                     ??GetNextNumSDL_4:
   \   00000080   0810A0E1           MOV      R1,R8
   \   00000084   0600A0E1           MOV      R0,R6
   \   00000088   190000EF           SWI      +25
   \   0000008C   000050E3           CMP      R0,#+0
   \   00000090   E9FFFF1A           BNE      ??GetNextNumSDL_2
    275                return sdl;
   \   00000094   0400A0E1           MOV      R0,R4
   \   00000098   F081BDE8           POP      {R4-R8,PC}       ;; return
    276              sdl=sdl->next;
    277            }
    278            return 0;
    279          }
    280          

   \                                 In segment CODE, align 4, keep-with-next
    281          SMS_DATA *GetNextStrSDL(SMS_DATA *sdl, const char *utf8_str)
    282          {
   \                     GetNextStrSDL:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   94D04DE2           SUB      SP,SP,#+148
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
    283            if(!sdl) return 0;
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   0200001A           BNE      ??GetNextStrSDL_0
   \                     ??GetNextStrSDL_1:
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   94D08DE2           ADD      SP,SP,#+148
   \   00000020   7080BDE8           POP      {R4-R6,PC}
    284            WSHDR *ws, wsn;
    285            unsigned short wsb[64];
    286            ws=CreateLocalWS(&wsn, wsb, 64);
   \                     ??GetNextStrSDL_0:
   \   00000024   4020A0E3           MOV      R2,#+64
   \   00000028   0D10A0E1           MOV      R1,SP
   \   0000002C   80008DE2           ADD      R0,SP,#+128
   \   00000030   270100EF           SWI      +295
   \   00000034   0060A0E1           MOV      R6,R0
    287            utf8_2ws(ws, utf8_str, 64);
   \   00000038   4020A0E3           MOV      R2,#+64
   \   0000003C   0510A0E1           MOV      R1,R5
   \   00000040   E30100EF           SWI      +483
    288            sdl=sdl->next;
    289            while(sdl)
    290            {
    291              if(wstrstr(sdl->SMS_TEXT, ws))
    292              {
    293                return sdl;
    294              }
    295              sdl=sdl->next;
   \                     ??GetNextStrSDL_2:
   \   00000044   004094E5           LDR      R4,[R4, #+0]
   \   00000048   000054E3           CMP      R4,#+0
   \   0000004C   F1FFFF0A           BEQ      ??GetNextStrSDL_1
   \   00000050   640094E5           LDR      R0,[R4, #+100]
   \   00000054   0610A0E1           MOV      R1,R6
   \   00000058   ........           BL       wstrstr
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   F7FFFF0A           BEQ      ??GetNextStrSDL_2
   \   00000064   0400A0E1           MOV      R0,R4
   \   00000068   94D08DE2           ADD      SP,SP,#+148
   \   0000006C   7080BDE8           POP      {R4-R6,PC}       ;; return
    296            }
    297            return 0;
    298          }
    299          

   \                                 In segment CODE, align 4, keep-with-next
    300          SMS_DATA *FindNextFilterSDL(SMS_DATA *sdl)
    301          {
   \                     FindNextFilterSDL:
   \   00000000   00402DE9           PUSH     {LR}
    302            if(!sdl) return 0;
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0100001A           BNE      ??FindNextFilterSDL_1
   \                     ??FindNextFilterSDL_2:
   \   0000000C   0000A0E3           MOV      R0,#+0
   \   00000010   0080BDE8           POP      {PC}
    303            //GetCPUClock();
    304            switch(CFG_FILTEROP)
   \                     ??FindNextFilterSDL_1:
   \   00000014   ........           LDR      R3,??DataTable12  ;; CFG_FILTEROP
   \   00000018   002090E5           LDR      R2,[R0, #+0]
   \   0000001C   003093E5           LDR      R3,[R3, #+0]
   \   00000020   ........           LDR      R1,??DataTable13  ;; CFG_STRORNUM
   \   00000024   050053E3           CMP      R3,#+5
   \   00000028   F7FFFF8A           BHI      ??FindNextFilterSDL_2
   \   0000002C   01CF8FE2           ADR      R12,??FindNextFilterSDL_0
   \   00000030   D3C09CE1           LDRSB    R12,[R12, R3]
   \   00000034   0CF18FE0           ADD      PC,PC,R12, LSL #+2
   \                     ??FindNextFilterSDL_0:
   \   00000038   01040710           DC8      +1,+4,+7,+16
   \   0000003C   181A0000           DC8      +24,+26,+0,+0
    305            {
    306            case FILTER_ALL:
    307              return (FindNextByType(sdl, 0));
   \                     ??FindNextFilterSDL_3:
   \   00000040   0010A0E3           MOV      R1,#+0
   \   00000044   ........           _BLF     FindNextByType,??FindNextByType??rA
   \   00000048   0080BDE8           POP      {PC}
    308            case FILTER_NEW:
    309              return (FindNextByType(sdl, TYPE_IN_N));
   \                     ??FindNextFilterSDL_4:
   \   0000004C   0310A0E3           MOV      R1,#+3
   \   00000050   ........           _BLF     FindNextByType,??FindNextByType??rA
   \   00000054   0080BDE8           POP      {PC}
    310            case FILTER_DAT:
    311              sdl=sdl->next;
   \                     ??FindNextFilterSDL_5:
   \   00000058   0200A0E1           MOV      R0,R2
   \   0000005C   000000EA           B        ??FindNextFilterSDL_6
    312              while(sdl)
    313              {
    314                if(!sdl->isfile) return sdl;
    315                sdl=sdl->next;
   \                     ??FindNextFilterSDL_7:
   \   00000060   000090E5           LDR      R0,[R0, #+0]
   \                     ??FindNextFilterSDL_6:
   \   00000064   000050E3           CMP      R0,#+0
   \   00000068   0080BD08           POPEQ    {PC}
   \   0000006C   141090E5           LDR      R1,[R0, #+20]
   \   00000070   000051E3           CMP      R1,#+0
   \   00000074   F9FFFF1A           BNE      ??FindNextFilterSDL_7
   \   00000078   0080BDE8           POP      {PC}
    316              }
    317              return 0;
    318            case FILTER_FILE:
    319              sdl=sdl->next;
   \                     ??FindNextFilterSDL_8:
   \   0000007C   0200A0E1           MOV      R0,R2
    320              while(sdl)
   \                     ??FindNextFilterSDL_9:
   \   00000080   000050E3           CMP      R0,#+0
   \   00000084   0080BD08           POPEQ    {PC}
    321              {
    322                if(sdl->isfile) return sdl;
   \   00000088   141090E5           LDR      R1,[R0, #+20]
   \   0000008C   000051E3           CMP      R1,#+0
   \   00000090   0080BD18           POPNE    {PC}
    323                sdl=sdl->next;
   \   00000094   000090E5           LDR      R0,[R0, #+0]
   \   00000098   F8FFFFEA           B        ??FindNextFilterSDL_9
    324              }
    325              return 0;
    326            case FILTER_NUM:
    327              return (GetNextNumSDL(sdl, CFG_STRORNUM));
   \                     ??FindNextFilterSDL_10:
   \   0000009C   ........           BL       GetNextNumSDL
   \   000000A0   0080BDE8           POP      {PC}
    328            case FILTER_STR:
    329              return (GetNextStrSDL(sdl, CFG_STRORNUM));
   \                     ??FindNextFilterSDL_11:
   \   000000A4   ........           BL       GetNextStrSDL
   \   000000A8   0080BDE8           POP      {PC}             ;; return
    330            default:
    331              return 0;
    332            }
    333          }
    334          
    335          

   \                                 In segment CODE, align 4, keep-with-next
    336          SMS_DATA *GetPrevNumSDL(SMS_DATA *sdl, const char *num)
    337          {
   \                     GetPrevNumSDL:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    338            if(!sdl) return 0;
   \   0000000C   000054E3           CMP      R4,#+0
   \   00000010   0100001A           BNE      ??GetPrevNumSDL_0
   \                     ??GetPrevNumSDL_1:
   \   00000014   0000A0E3           MOV      R0,#+0
   \   00000018   F081BDE8           POP      {R4-R8,PC}
    339            int len, len2, lx;
    340            const char *p2, *pt;
    341            const char *p=num;
    342            if(!p) return 0;
   \                     ??GetPrevNumSDL_0:
   \   0000001C   000055E3           CMP      R5,#+0
   \   00000020   FBFFFF0A           BEQ      ??GetPrevNumSDL_1
    343            if(*p=='+') p++;
   \   00000024   0000D5E5           LDRB     R0,[R5, #+0]
   \   00000028   2B0050E3           CMP      R0,#+43
   \   0000002C   01508502           ADDEQ    R5,R5,#+1
    344            len=strlen(p);
   \   00000030   0500A0E1           MOV      R0,R5
   \   00000034   1B0000EF           SWI      +27
   \   00000038   0070A0E1           MOV      R7,R0
    345            sdl=sdl->prev;
    346            while(sdl)
    347            {
    348              len2=strlen((p2=sdl->Number));
    349              if(len2>len)
    350              {
    351                if((lx=len2-len)>3)
    352                {
    353          	sdl=sdl->prev;
   \                     ??GetPrevNumSDL_2:
   \   0000003C   044094E5           LDR      R4,[R4, #+4]
    354          	continue;
    355                }
   \   00000040   000054E3           CMP      R4,#+0
   \   00000044   F2FFFF0A           BEQ      ??GetPrevNumSDL_1
   \   00000048   248084E2           ADD      R8,R4,#+36
   \   0000004C   0800A0E1           MOV      R0,R8
   \   00000050   1B0000EF           SWI      +27
   \   00000054   000057E1           CMP      R7,R0
   \   00000058   040000AA           BGE      ??GetPrevNumSDL_3
   \   0000005C   070040E0           SUB      R0,R0,R7
   \   00000060   040050E3           CMP      R0,#+4
   \   00000064   F4FFFFAA           BGE      ??GetPrevNumSDL_2
    356                p2+=lx;
   \   00000068   088080E0           ADD      R8,R0,R8
   \   0000006C   030000EA           B        ??GetPrevNumSDL_4
    357              }
    358              else
    359              {
    360                if((lx=len-len2)>3)
   \                     ??GetPrevNumSDL_3:
   \   00000070   000047E0           SUB      R0,R7,R0
   \   00000074   040050E3           CMP      R0,#+4
   \   00000078   EFFFFFAA           BGE      ??GetPrevNumSDL_2
    361                {
    362          	sdl=sdl->prev;
    363          	continue;
    364                }
    365                pt=p+lx;
   \   0000007C   056080E0           ADD      R6,R0,R5
    366              }
    367              if(!strcmp(pt, p2))
   \                     ??GetPrevNumSDL_4:
   \   00000080   0810A0E1           MOV      R1,R8
   \   00000084   0600A0E1           MOV      R0,R6
   \   00000088   190000EF           SWI      +25
   \   0000008C   000050E3           CMP      R0,#+0
   \   00000090   E9FFFF1A           BNE      ??GetPrevNumSDL_2
    368                return sdl;
   \   00000094   0400A0E1           MOV      R0,R4
   \   00000098   F081BDE8           POP      {R4-R8,PC}       ;; return
    369              sdl=sdl->prev;
    370            }
    371            return 0;
    372          }
    373          

   \                                 In segment CODE, align 4, keep-with-next
    374          SMS_DATA *GetPrevStrSDL(SMS_DATA *sdl, const char *utf8_str)
    375          {
   \                     GetPrevStrSDL:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   94D04DE2           SUB      SP,SP,#+148
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
    376            if(!sdl) return 0;
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   0200001A           BNE      ??GetPrevStrSDL_0
   \                     ??GetPrevStrSDL_1:
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   94D08DE2           ADD      SP,SP,#+148
   \   00000020   7080BDE8           POP      {R4-R6,PC}
    377            WSHDR *ws, wsn;
    378            unsigned short wsb[64];
    379            ws=CreateLocalWS(&wsn, wsb, 64);
   \                     ??GetPrevStrSDL_0:
   \   00000024   4020A0E3           MOV      R2,#+64
   \   00000028   0D10A0E1           MOV      R1,SP
   \   0000002C   80008DE2           ADD      R0,SP,#+128
   \   00000030   270100EF           SWI      +295
   \   00000034   0060A0E1           MOV      R6,R0
    380            utf8_2ws(ws, utf8_str, 64);
   \   00000038   4020A0E3           MOV      R2,#+64
   \   0000003C   0510A0E1           MOV      R1,R5
   \   00000040   E30100EF           SWI      +483
    381            sdl=sdl->prev;
    382            while(sdl)
    383            {
    384              if(wstrstr(sdl->SMS_TEXT, ws))
    385                return sdl;
    386              sdl=sdl->prev;
   \                     ??GetPrevStrSDL_2:
   \   00000044   044094E5           LDR      R4,[R4, #+4]
   \   00000048   000054E3           CMP      R4,#+0
   \   0000004C   F1FFFF0A           BEQ      ??GetPrevStrSDL_1
   \   00000050   640094E5           LDR      R0,[R4, #+100]
   \   00000054   0610A0E1           MOV      R1,R6
   \   00000058   ........           BL       wstrstr
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   F7FFFF0A           BEQ      ??GetPrevStrSDL_2
   \   00000064   0400A0E1           MOV      R0,R4
   \   00000068   94D08DE2           ADD      SP,SP,#+148
   \   0000006C   7080BDE8           POP      {R4-R6,PC}       ;; return
    387            }
    388            return 0;
    389          }
    390          

   \                                 In segment CODE, align 4, keep-with-next
    391          SMS_DATA *FindPrevFilterSDL(SMS_DATA *sdl)
    392          {
   \                     FindPrevFilterSDL:
   \   00000000   00402DE9           PUSH     {LR}
    393            if(!sdl) return 0;
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0100001A           BNE      ??FindPrevFilterSDL_1
   \                     ??FindPrevFilterSDL_2:
   \   0000000C   0000A0E3           MOV      R0,#+0
   \   00000010   0080BDE8           POP      {PC}
    394            //GetCPUClock();
    395            switch(CFG_FILTEROP)
   \                     ??FindPrevFilterSDL_1:
   \   00000014   ........           LDR      R3,??DataTable12  ;; CFG_FILTEROP
   \   00000018   042090E5           LDR      R2,[R0, #+4]
   \   0000001C   003093E5           LDR      R3,[R3, #+0]
   \   00000020   ........           LDR      R1,??DataTable13  ;; CFG_STRORNUM
   \   00000024   050053E3           CMP      R3,#+5
   \   00000028   F7FFFF8A           BHI      ??FindPrevFilterSDL_2
   \   0000002C   01CF8FE2           ADR      R12,??FindPrevFilterSDL_0
   \   00000030   D3C09CE1           LDRSB    R12,[R12, R3]
   \   00000034   0CF18FE0           ADD      PC,PC,R12, LSL #+2
   \                     ??FindPrevFilterSDL_0:
   \   00000038   01040710           DC8      +1,+4,+7,+16
   \   0000003C   181A0000           DC8      +24,+26,+0,+0
    396            {
    397            case FILTER_ALL:
    398              return (FindPrevByType(sdl, 0));
   \                     ??FindPrevFilterSDL_3:
   \   00000040   0010A0E3           MOV      R1,#+0
   \   00000044   ........           _BLF     FindPrevByType,??FindPrevByType??rA
   \   00000048   0080BDE8           POP      {PC}
    399            case FILTER_NEW:
    400              return (FindPrevByType(sdl, TYPE_IN_N));
   \                     ??FindPrevFilterSDL_4:
   \   0000004C   0310A0E3           MOV      R1,#+3
   \   00000050   ........           _BLF     FindPrevByType,??FindPrevByType??rA
   \   00000054   0080BDE8           POP      {PC}
    401            case FILTER_DAT:
    402              sdl=sdl->prev;
   \                     ??FindPrevFilterSDL_5:
   \   00000058   0200A0E1           MOV      R0,R2
   \   0000005C   000000EA           B        ??FindPrevFilterSDL_6
    403              while(sdl)
    404              {
    405                if(!sdl->isfile) return sdl;
    406                sdl=sdl->prev;
   \                     ??FindPrevFilterSDL_7:
   \   00000060   040090E5           LDR      R0,[R0, #+4]
   \                     ??FindPrevFilterSDL_6:
   \   00000064   000050E3           CMP      R0,#+0
   \   00000068   0080BD08           POPEQ    {PC}
   \   0000006C   141090E5           LDR      R1,[R0, #+20]
   \   00000070   000051E3           CMP      R1,#+0
   \   00000074   F9FFFF1A           BNE      ??FindPrevFilterSDL_7
   \   00000078   0080BDE8           POP      {PC}
    407              }
    408              return 0;
    409            case FILTER_FILE:
    410              sdl=sdl->prev;
   \                     ??FindPrevFilterSDL_8:
   \   0000007C   0200A0E1           MOV      R0,R2
    411              while(sdl)
   \                     ??FindPrevFilterSDL_9:
   \   00000080   000050E3           CMP      R0,#+0
   \   00000084   0080BD08           POPEQ    {PC}
    412              {
    413                if(sdl->isfile) return sdl;
   \   00000088   141090E5           LDR      R1,[R0, #+20]
   \   0000008C   000051E3           CMP      R1,#+0
   \   00000090   0080BD18           POPNE    {PC}
    414                sdl=sdl->prev;
   \   00000094   040090E5           LDR      R0,[R0, #+4]
   \   00000098   F8FFFFEA           B        ??FindPrevFilterSDL_9
    415              }
    416              return 0;
    417            case FILTER_NUM:
    418              return (GetPrevNumSDL(sdl, CFG_STRORNUM));
   \                     ??FindPrevFilterSDL_10:
   \   0000009C   ........           BL       GetPrevNumSDL
   \   000000A0   0080BDE8           POP      {PC}
    419            case FILTER_STR:
    420              return (GetPrevStrSDL(sdl, CFG_STRORNUM));
   \                     ??FindPrevFilterSDL_11:
   \   000000A4   ........           BL       GetPrevStrSDL
   \   000000A8   0080BDE8           POP      {PC}             ;; return
    421            default:
    422              return 0;
    423            }
    424          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     sdltop

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   ........           DC32     CFG_FILTEROP

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   ........           DC32     CFG_STRORNUM
    425          

   Maximum stack usage in bytes:

     Function           CSTACK
     --------           ------
     FilterFindSDL          4
     FilterGetCountSDL      4
     FindNextFilterSDL      4
     FindPrevFilterSDL      4
     GetDatFileByNSD        0
     GetDatFileSDLCount     0
     GetNextNumSDL         24
     GetNextStrSDL        164
     GetNumSD              32
     GetNumSDCount         28
     GetPrevNumSDL         24
     GetPrevStrSDL        164
     GetStrSD             168
     GetStrSDCount        164
     w_charcmp_nocase      28
     wstrstr               28


   Segment part sizes:

     Function/Label     Bytes
     --------------     -----
     GetDatFileByNSD      64
     GetDatFileSDLCount   52
     GetNumSD            168
     GetNumSDCount       152
     w_charcmp_nocase    124
     wstrstr             128
     GetStrSD            132
     GetStrSDCount       108
     FilterFindSDL       116
     FilterGetCountSDL   116
     GetNextNumSDL       156
     GetNextStrSDL       112
     FindNextFilterSDL   172
     GetPrevNumSDL       156
     GetPrevStrSDL       112
     FindPrevFilterSDL   172
     ??DataTable5          4
     ??DataTable12         4
     ??DataTable13         4
      Others             124

 
 2 176 bytes in segment CODE
 
 2 052 bytes of CODE memory (+ 124 bytes shared)

Errors: none
Warnings: none
