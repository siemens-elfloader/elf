##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    13/Jan/2011  22:52:13 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\mss3\adrList.c                                #
#    Command line    =  C:\arm\mss3\adrList.c -D NEWSGOLD -D ELKA -D         #
#                       LANG_EN -D NO_CS -lC C:\arm\mss3\Release_ELKA_EN\Lis #
#                       t\ -o C:\arm\mss3\Release_ELKA_EN\Obj\ -s9           #
#                       --no_unroll --cpu_mode arm --endian little --cpu     #
#                       ARM926EJ-S --stack_align 4 --interwork -e --fpu      #
#                       None --dlib_config "C:\arm2\Embedded Workbench 4.0   #
#                       Evaluation\ARM\LIB\dl5tpainl8n.h" -I                 #
#                       "C:\arm2\Embedded Workbench 4.0                      #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  C:\arm\mss3\Release_ELKA_EN\List\adrList.lst         #
#    Object file     =  C:\arm\mss3\Release_ELKA_EN\Obj\adrList.r79          #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\mss3\adrList.c
      1          #include "..\inc\swilib.h"
      2          #include "sms_dat.h"
      3          #include "adrList.h"
      4          #include "rect_patcher.h"
      5          #include "language.h"
      6          #include "edGui.h"
      7          #include "createMenu.h"
      8          #include "numList.h"
      9          #include "config_data.h"
     10          #include "string_works.h"
     11          
     12          #pragma swi_number=0x44
     13          __swi __arm void TempLightOn(int x, int y);
     14          

   \                                 In segment DATA_Z, align 4, align-sorted
     15          volatile CLIST *cltop=0;
   \                     cltop:
   \   00000000                      DS8 4
     16          int cl_n;
   \                     cl_n:
   \   00000004                      DS8 4
     17          

   \                                 In segment CODE, align 4, keep-with-next
     18          void FreeCLIST(void)
     19          {
   \                     FreeCLIST:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
     20          	LockSched();
   \   00000004   460100EF           SWI      +326
     21          	CLIST *cl0=(CLIST*)cltop;
   \   00000008   ........           LDR      R0,??DataTable6  ;; cltop
     22          	cltop=0;
   \   0000000C   0010A0E3           MOV      R1,#+0
   \   00000010   004090E5           LDR      R4,[R0, #+0]
   \   00000014   001080E5           STR      R1,[R0, #+0]
     23          	UnlockSched();
   \   00000018   470100EF           SWI      +327
   \   0000001C   000054E3           CMP      R4,#+0
   \   00000020   3080BD08           POPEQ    {R4,R5,PC}
     24          	while(cl0)
     25          	{
     26          		CLIST *p;
     27          		if(cl0->name) FreeWS(cl0->name);
   \                     ??FreeCLIST_0:
   \   00000024   040094E5           LDR      R0,[R4, #+4]
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   0000000A           BEQ      ??FreeCLIST_1
   \   00000030   290100EF           SWI      +297
     28          		for(int i=0;i<NUMBERS_MAX;i++) 
   \                     ??FreeCLIST_1:
   \   00000034   0050A0E3           MOV      R5,#+0
     29          		{
     30          			if(cl0->num[i])
   \                     ??FreeCLIST_2:
   \   00000038   050184E0           ADD      R0,R4,R5, LSL #+2
   \   0000003C   081090E5           LDR      R1,[R0, #+8]
   \   00000040   000051E3           CMP      R1,#+0
   \   00000044   0100000A           BEQ      ??FreeCLIST_3
     31          				mfree(cl0->num[i]);
   \   00000048   0100A0E1           MOV      R0,R1
   \   0000004C   150000EF           SWI      +21
     32          		}
   \                     ??FreeCLIST_3:
   \   00000050   015085E2           ADD      R5,R5,#+1
   \   00000054   050055E3           CMP      R5,#+5
   \   00000058   F6FFFFBA           BLT      ??FreeCLIST_2
     33          		if(cl0->sms_melody_filepath) mfree(cl0->sms_melody_filepath);
   \   0000005C   1C0094E5           LDR      R0,[R4, #+28]
   \   00000060   000050E3           CMP      R0,#+0
   \   00000064   0000000A           BEQ      ??FreeCLIST_4
   \   00000068   150000EF           SWI      +21
     34          		p=cl0;
   \                     ??FreeCLIST_4:
   \   0000006C   0400A0E1           MOV      R0,R4
     35          		cl0=(CLIST*)(cl0->next);
   \   00000070   004094E5           LDR      R4,[R4, #+0]
     36          		mfree(p);
   \   00000074   150000EF           SWI      +21
     37          	}
   \   00000078   000054E3           CMP      R4,#+0
   \   0000007C   E8FFFF1A           BNE      ??FreeCLIST_0
     38          }
   \   00000080   3080BDE8           POP      {R4,R5,PC}       ;; return
     39          

   \                                 In segment CODE, align 4, keep-with-next
     40          void ConstructListN(void)
     41          {
     42            if(!cltop) ConstructList();
   \                     ConstructListN:
   \   00000000   ........           LDR      R0,??DataTable6  ;; cltop
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0080BD18           POPNE    {PC}
   \   00000014   ........           BL       ConstructList
     43          }
   \   00000018   0080BDE8           POP      {PC}             ;; return
     44          

   \                                 In segment CODE, align 4, keep-with-next
     45          void ConstructList(void)
     46          {
   \                     ConstructList:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
     47            int fin;
     48            unsigned int ul;
     49            char recname[128];
     50            char s_ab_main[128];
     51            char s_ab_entry[128];
     52            
     53            AB_UNPRES ur;
     54            void *buffer;
     55          #pragma pack(1)
     56            struct {
     57          #ifdef NEWSGOLD
     58              long dummy1;
     59              short dummy2;
     60              char bitmap[MAX_RECORDS/8];
     61          #else
     62              long dummy1;
     63              char bitmap[MAX_RECORDS/8];
     64          #endif
     65            } ABmain;
     66          #pragma pack()
     67          
     68            unsigned int rec=0;
     69            int fsz;
     70            int x, xl;
     71            CLIST contact;
     72            
     73            FreeCLIST();
     74            cl_n=0;
   \   00000004   ........           LDR      R7,??DataTable6  ;; cltop
     75            strcpy(s_ab_main, CFG_SYSTEM_FOLDER);
   \   00000008   38859FE5           LDR      R8,??ConstructList_0  ;; CFG_SYSTEM_FOLDER
   \   0000000C   38D04DE2           SUB      SP,SP,#+56
   \   00000010   40DE4DE2           SUB      SP,SP,#+1024
   \   00000014   0050A0E3           MOV      R5,#+0
   \   00000018   ........           BL       FreeCLIST
   \   0000001C   045087E5           STR      R5,[R7, #+4]
   \   00000020   0810A0E1           MOV      R1,R8
   \   00000024   CE0F8DE2           ADD      R0,SP,#+824
   \   00000028   1A0000EF           SWI      +26
     76            if((xl=strlen(s_ab_main))>0)
   \   0000002C   CE0F8DE2           ADD      R0,SP,#+824
   \   00000030   1B0000EF           SWI      +27
   \   00000034   010050E3           CMP      R0,#+1
     77              x=s_ab_main[xl-1];
   \   00000038   CE1F8DA2           ADDGE    R1,SP,#+824
   \   0000003C   010080A0           ADDGE    R0,R0,R1
   \   00000040   014050A5           LDRBGE   R4,[R0, #-1]
   \   00000044   0060A0E3           MOV      R6,#+0
     78            if((x!='\\')&&(x!='/'))
   \   00000048   F49F8FE2           ADR      R9,??ConstructList_1  ;; "\\"
   \   0000004C   5C0054E3           CMP      R4,#+92
   \   00000050   2F005413           CMPNE    R4,#+47
   \   00000054   0200000A           BEQ      ??ConstructList_2
     79              strcat(s_ab_main, "\\");
   \   00000058   0910A0E1           MOV      R1,R9
   \   0000005C   CE0F8DE2           ADD      R0,SP,#+824
   \   00000060   170000EF           SWI      +23
     80            strcat(s_ab_main, "apo\\addr\\main");
   \                     ??ConstructList_2:
   \   00000064   E0A49FE5           LDR      R10,??ConstructList_0+0x4  ;; `?<Constant "apo\\\\addr\\\\main">`
   \   00000068   CE0F8DE2           ADD      R0,SP,#+824
   \   0000006C   0A10A0E1           MOV      R1,R10
   \   00000070   170000EF           SWI      +23
     81            strcpy(s_ab_entry, CFG_SYSTEM_FOLDER);
   \   00000074   0810A0E1           MOV      R1,R8
   \   00000078   EE0F8DE2           ADD      R0,SP,#+952
   \   0000007C   1A0000EF           SWI      +26
     82            if((xl=strlen(s_ab_entry))>0)
   \   00000080   EE0F8DE2           ADD      R0,SP,#+952
   \   00000084   1B0000EF           SWI      +27
   \   00000088   010050E3           CMP      R0,#+1
     83              x=s_ab_entry[xl-1];
   \   0000008C   EE1F8DA2           ADDGE    R1,SP,#+952
   \   00000090   010080A0           ADDGE    R0,R0,R1
   \   00000094   014050A5           LDRBGE   R4,[R0, #-1]
     84            if((x!='\\')&&(x!='/'))
   \   00000098   5C0054E3           CMP      R4,#+92
   \   0000009C   2F005413           CMPNE    R4,#+47
   \   000000A0   0200000A           BEQ      ??ConstructList_3
     85              strcat(s_ab_entry, "\\");
   \   000000A4   0910A0E1           MOV      R1,R9
   \   000000A8   EE0F8DE2           ADD      R0,SP,#+952
   \   000000AC   170000EF           SWI      +23
     86          #ifdef NEWSGOLD
     87            strcat(s_ab_entry, "apo\\addr\\data\\%02d\\%02d\\%02d");
   \                     ??ConstructList_3:
   \   000000B0   10108AE2           ADD      R1,R10,#+16
   \   000000B4   EE0F8DE2           ADD      R0,SP,#+952
   \   000000B8   170000EF           SWI      +23
     88          #else
     89            strcat(s_ab_entry, "apo\\addr\\%02x\\%02x");
     90          #endif
     91            zeromem(&contact,sizeof(contact));
   \   000000BC   2010A0E3           MOV      R1,#+32
   \   000000C0   04008DE2           ADD      R0,SP,#+4
   \   000000C4   1D0100EF           SWI      +285
     92            if ((buffer=malloc(65536)))
   \   000000C8   400BA0E3           MOV      R0,#+65536
   \   000000CC   140000EF           SWI      +20
   \   000000D0   0040B0E1           MOVS     R4,R0
   \   000000D4   0701000A           BEQ      ??ConstructList_4
     93            {
     94              zeromem(&ABmain,sizeof(ABmain));
   \   000000D8   7790A0E3           MOV      R9,#+119
   \   000000DC   809F89E3           ORR      R9,R9,#0x200
   \   000000E0   0910A0E1           MOV      R1,R9
   \   000000E4   40008DE2           ADD      R0,SP,#+64
   \   000000E8   1D0100EF           SWI      +285
     95              if ((fin=fopen(s_ab_main, A_ReadOnly+A_BIN, P_READ, &ul))!=-1)
   \   000000EC   0D30A0E1           MOV      R3,SP
   \   000000F0   8020A0E3           MOV      R2,#+128
   \   000000F4   801CA0E3           MOV      R1,#+32768
   \   000000F8   CE0F8DE2           ADD      R0,SP,#+824
   \   000000FC   0A0000EF           SWI      +10
   \   00000100   0080A0E1           MOV      R8,R0
   \   00000104   010078E3           CMN      R8,#+1
   \   00000108   F800000A           BEQ      ??ConstructList_5
     96              {
     97          #ifdef ELKA
     98                if (fread(fin,&ABmain,sizeof(ABmain),&ul)>=194)
   \   0000010C   0D30A0E1           MOV      R3,SP
   \   00000110   0920A0E1           MOV      R2,R9
   \   00000114   40108DE2           ADD      R1,SP,#+64
   \   00000118   0B0000EF           SWI      +11
   \   0000011C   C20050E3           CMP      R0,#+194
   \   00000120   0D10A0E1           MOV      R1,SP
   \   00000124   0800A0E1           MOV      R0,R8
   \   00000128   EF0000BA           BLT      ??ConstructList_6
     99          #else
    100          	if (fread(fin,&ABmain,sizeof(ABmain),&ul)==sizeof(ABmain))
    101          #endif
    102          	{
    103          	  fclose(fin,&ul);
   \   0000012C   0D0000EF           SWI      +13
   \   00000130   280000EA           B        ??ConstructList_7
    104          	  do
    105          	  {
    106          #ifdef NEWSGOLD
    107          	    if (ABmain.bitmap[rec>>3]&(0x80>>(rec&7)))
    108          #else
    109          	      if (ABmain.bitmap[rec>>3]&(1<<(rec&7)))
    110          #endif
    111          	      {
    112          #ifdef NEWSGOLD
    113          		unsigned int rl1;
    114          		unsigned int rl2;
    115          		unsigned int rl3;
    116          		rl1=rec/LEVEL1_RN;
    117          		rl2=(rec%LEVEL1_RN)/LEVEL2_RN;
    118          		rl3=rec%LEVEL2_RN;
    119          		snprintf(recname, 128, s_ab_entry, rl1, rl2, rl3);
    120          #else
    121          		unsigned int rl1=rec/LEVEL1_RN;
    122          		unsigned int r12=rec%LEVEL1_RN;
    123          		snprintf(recname, 128, s_ab_entry, rl1, r12);
    124          #endif
    125          		if ((fin=fopen(recname,A_ReadOnly+A_BIN,P_READ,&ul))!=-1)
    126          		{
    127          		  zeromem(&ur,sizeof(AB_UNPRES));
    128          		  fsz=lseek(fin,0,S_END,&ul,&ul);
    129          		  lseek(fin,0,S_SET,&ul,&ul);
    130          		  fread(fin,buffer,fsz,&ul);
    131          		  fclose(fin,&ul);
    132          #ifdef NEWSGOLD
    133          		  UnpackABentry(&ur,((char *)buffer+8),fsz,0x28);
    134          #else
    135          		  UnpackABentry(&ur,((char *)buffer+4),fsz-4,0x28);
    136          #endif
    137          		  int i=0;
    138          		  zeromem(&contact,sizeof(contact));
    139          		  while(i<ur.number_of_records)
    140          		  {
    141          		    AB_UNPRES_ITEM *r=ur.record_list+i;
    142          		    if (r->no_data!=1)
    143          		    {
    144          		      switch(GetTypeOfAB_UNPRES_ITEM(r->item_type))
    145          		      {
    146          		      case 0x05:
    147          #ifdef NEWSGOLD
    148          			if (
    149          			    r->item_type==LAST_NAME||
    150          			      r->item_type==FIRST_NAME||
    151          				r->item_type==DISPLAY_NAME
    152          				  )
    153          #else
    154          			  if (
    155          			      r->item_type==LAST_NAME||
    156          				r->item_type==FIRST_NAME||
    157          				  r->item_type==COMPANY_NAME
    158          				    )
    159          #endif
    160          			  {
    161          			    if (r->data)
    162          			    {
    163          			      if (!contact.name)
    164          			      {
    165          				cl_n++;
    166          				wstrcpy(contact.name=AllocWS(150),(WSHDR *)(r->data));
    167          			      }
    168          			      else
    169          			      {
    170          				wsAppendChar(contact.name,',');
    171          				wsAppendChar(contact.name,' ');
    172          				wstrcat(contact.name, (WSHDR*)(r->data));
    173          			      }
    174          			      contact.next = (void*)1;
    175          			    }
    176          			  }
    177          			else if(r->item_type==SMS_MELODY)
    178          			{
    179          			  if(r->data)
    180          			  {
    181          			    if(!contact.sms_melody_filepath)
    182          			      contact.sms_melody_filepath=malloc(128);
    183          			    ws_2str(r->data, contact.sms_melody_filepath, 127);
    184          			  }
    185          			}
    186          			break;
    187          		      case 0x01:
    188          			{
    189          			  PKT_NUM *p=(PKT_NUM*)r->data;
    190          			  unsigned int n=r->item_type;
    191          			  int j;
    192          			  unsigned int c;
    193          			  char *nump;
    194          			  //WSHDR *ws0;
    195          #ifdef NEWSGOLD
    196          			  if (n!=106) n-=0x62;
    197          			  else n=4;
    198          			  if (n<5)
    199          #else
    200          			    switch(r->item_type)
    201          			    {
    202          			    case PHONE_NUMBER:
    203          			      n=0;    break;
    204          			    case PHONE_OFFICE:
    205          			      n=1;    break;
    206          			    case PHONE_MOBILE:
    207          			      n=2;    break;
    208          			    case PHONE_FAX:
    209          			      n=3;    break;
    210          			    case PHONE_FAX2:
    211          			      n=4;    break;
    212          			    default:
    213          			      continue;
    214          			    }
    215          #endif
    216          			  {
    217          			    if (p)
    218          			    {
    219          			      unsigned int c1;
    220          			      int m;
    221          			      nump=contact.num[n]=malloc(50);
    222          			      j=0;
    223          			      m=0;
    224          			      if (p->format==0x91)
    225          				*nump++='+';
    226          			      while(j<p->data_size)
    227          			      {
    228          				if (m&1) {c1=c>>4; j++;}
    229          				else c1=(c=p->data[j])&0x0F;
    230          				if (c1==0x0F) break;
    231          
    232          				if (c1==0xA) c1='*';
    233          				else if (c1==0xB) c1='#';
    234          				else if (c1==0xC) c1='+';
    235          				else if (c1==0xD) c1='?';
    236          				else c1+='0';
    237          				*nump++=c1;
    238          				//wsAppendChar(ws0,c1);
    239          				m++;
    240          			      }
    241          			      *nump=0;
    242          			      contact.next = (void*)1;
    243          			    }
    244          			  }
    245          			  break;
    246          			}
    247          		      }
    248          		    }
    249          		    i++;
    250          		  }
    251          		  if (!contact.next)
   \                     ??ConstructList_8:
   \   00000134   04009DE5           LDR      R0,[SP, #+4]
   \   00000138   000050E3           CMP      R0,#+0
   \   0000013C   0D00001A           BNE      ??ConstructList_9
    252          		  {
    253          		    if(contact.name) FreeWS(contact.name);
   \   00000140   08009DE5           LDR      R0,[SP, #+8]
   \   00000144   000050E3           CMP      R0,#+0
   \   00000148   0000000A           BEQ      ??ConstructList_10
   \   0000014C   290100EF           SWI      +297
    254          		    for(int i=0;i<NUMBERS_MAX;i++)
   \                     ??ConstructList_10:
   \   00000150   0080A0E3           MOV      R8,#+0
   \                     ??ConstructList_11:
   \   00000154   04008DE2           ADD      R0,SP,#+4
   \   00000158   080180E0           ADD      R0,R0,R8, LSL #+2
   \   0000015C   080090E5           LDR      R0,[R0, #+8]
   \   00000160   000050E3           CMP      R0,#+0
   \   00000164   0000000A           BEQ      ??ConstructList_12
    255          		    {
    256          		      if(contact.num[i])
    257          			mfree(contact.num[i]);
   \   00000168   150000EF           SWI      +21
    258          		    }
   \                     ??ConstructList_12:
   \   0000016C   018088E2           ADD      R8,R8,#+1
   \   00000170   050058E3           CMP      R8,#+5
   \   00000174   F6FFFFBA           BLT      ??ConstructList_11
    259          		  }
    260          		  FreeUnpackABentry(&ur,mfree_adr());
   \                     ??ConstructList_9:
   \   00000178   158000EF           SWI      +32789
   \   0000017C   0010A0E1           MOV      R1,R0
   \   00000180   24008DE2           ADD      R0,SP,#+36
   \   00000184   6E0100EF           SWI      +366
    261          		  /**/ //排序加入链表
    262          		  LockSched();
   \   00000188   460100EF           SWI      +326
    263          		  if (contact.next)
   \   0000018C   04009DE5           LDR      R0,[SP, #+4]
   \   00000190   000050E3           CMP      R0,#+0
   \   00000194   0900000A           BEQ      ??ConstructList_13
    264          		  {
    265          		    //int n=0;
    266          		    CLIST *p=malloc(sizeof(contact));
   \   00000198   2000A0E3           MOV      R0,#+32
   \   0000019C   140000EF           SWI      +20
   \   000001A0   0080A0E1           MOV      R8,R0
    267          		    //CLIST *t;
    268          		    //CLIST *b=(CLIST *)(&cltop);
    269          		    contact.next=0;
   \   000001A4   04508DE5           STR      R5,[SP, #+4]
    270          		    memcpy(p,&contact,sizeof(contact));
   \   000001A8   2020A0E3           MOV      R2,#+32
   \   000001AC   04108DE2           ADD      R1,SP,#+4
   \   000001B0   1E0100EF           SWI      +286
    271          		    p->next=(CLIST *)cltop;
   \   000001B4   000097E5           LDR      R0,[R7, #+0]
   \   000001B8   000088E5           STR      R0,[R8, #+0]
    272          		    cltop=p;
   \   000001BC   008087E5           STR      R8,[R7, #+0]
    273          		  }
    274          		  UnlockSched();
   \                     ??ConstructList_13:
   \   000001C0   470100EF           SWI      +327
    275          		}
    276          	      }
    277          	    rec++;
   \                     ??ConstructList_14:
   \   000001C4   016086E2           ADD      R6,R6,#+1
    278          	  }
    279          	  while(rec<MAX_RECORDS);
   \   000001C8   8800A0E3           MOV      R0,#+136
   \   000001CC   4C0D80E3           ORR      R0,R0,#0x1300
   \   000001D0   000056E1           CMP      R6,R0
   \   000001D4   C500002A           BCS      ??ConstructList_5
   \                     ??ConstructList_7:
   \   000001D8   46008DE2           ADD      R0,SP,#+70
   \   000001DC   A601D0E7           LDRB     R0,[R0, +R6, LSR #+3]
   \   000001E0   8010A0E3           MOV      R1,#+128
   \   000001E4   072006E2           AND      R2,R6,#0x7
   \   000001E8   310210E1           TST      R0,R1, LSR R2
   \   000001EC   F4FFFF0A           BEQ      ??ConstructList_14
   \   000001F0   58039FE5           LDR      R0,??ConstructList_0+0x8  ;; 0xffffffffc7ce0c7d
   \   000001F4   901682E0           UMULL    R1,R2,R0,R6
   \   000001F8   54039FE5           LDR      R0,??ConstructList_0+0xC  ;; 0x37e3fa85
   \   000001FC   A222A0E1           LSR      R2,R2,#+5
   \   00000200   2910A0E3           MOV      R1,#+41
   \   00000204   910202E0           MUL      R2,R1,R2
   \   00000208   022046E0           SUB      R2,R6,R2
   \   0000020C   04002DE9           PUSH     {R2}
   \   00000210   901682E0           UMULL    R1,R2,R0,R6
   \   00000214   34039FE5           LDR      R0,??ConstructList_0+0x8  ;; 0xffffffffc7ce0c7d
   \   00000218   062092E0           ADDS     R2,R2,R6
   \   0000021C   6220A0E1           RRX      R2,R2
   \   00000220   2225A0E1           LSR      R2,R2,#+10
   \   00000224   691EE0E3           MVN      R1,#+1680
   \   00000228   910202E0           MUL      R2,R1,R2
   \   0000022C   022086E0           ADD      R2,R6,R2, LSL #+0
   \   00000230   901283E0           UMULL    R1,R3,R0,R2
   \   00000234   18039FE5           LDR      R0,??ConstructList_0+0xC  ;; 0x37e3fa85
   \   00000238   A332A0E1           LSR      R3,R3,#+5
   \   0000023C   08002DE9           PUSH     {R3}
   \   00000240   F02F8DE2           ADD      R2,SP,#+960
   \   00000244   901683E0           UMULL    R1,R3,R0,R6
   \   00000248   8010A0E3           MOV      R1,#+128
   \   0000024C   063093E0           ADDS     R3,R3,R6
   \   00000250   6330A0E1           RRX      R3,R3
   \   00000254   2335A0E1           LSR      R3,R3,#+10
   \   00000258   B00F8DE2           ADD      R0,SP,#+704
   \   0000025C   1B0100EF           SWI      +283
   \   00000260   08308DE2           ADD      R3,SP,#+8
   \   00000264   8020A0E3           MOV      R2,#+128
   \   00000268   801CA0E3           MOV      R1,#+32768
   \   0000026C   B00F8DE2           ADD      R0,SP,#+704
   \   00000270   0A0000EF           SWI      +10
   \   00000274   0080A0E1           MOV      R8,R0
   \   00000278   010078E3           CMN      R8,#+1
   \   0000027C   08D08DE2           ADD      SP,SP,#+8
   \   00000280   CFFFFF0A           BEQ      ??ConstructList_14
   \   00000284   1C10A0E3           MOV      R1,#+28
   \   00000288   24008DE2           ADD      R0,SP,#+36
   \   0000028C   1D0100EF           SWI      +285
   \   00000290   0D00A0E1           MOV      R0,SP
   \   00000294   01002DE9           PUSH     {R0}
   \   00000298   04308DE2           ADD      R3,SP,#+4
   \   0000029C   0220A0E3           MOV      R2,#+2
   \   000002A0   0010A0E3           MOV      R1,#+0
   \   000002A4   0800A0E1           MOV      R0,R8
   \   000002A8   0F0000EF           SWI      +15
   \   000002AC   0090A0E1           MOV      R9,R0
   \   000002B0   04008DE2           ADD      R0,SP,#+4
   \   000002B4   01002DE9           PUSH     {R0}
   \   000002B8   08308DE2           ADD      R3,SP,#+8
   \   000002BC   0520A0E1           MOV      R2,R5
   \   000002C0   0210A0E1           MOV      R1,R2
   \   000002C4   0800A0E1           MOV      R0,R8
   \   000002C8   0F0000EF           SWI      +15
   \   000002CC   08308DE2           ADD      R3,SP,#+8
   \   000002D0   0920A0E1           MOV      R2,R9
   \   000002D4   0410A0E1           MOV      R1,R4
   \   000002D8   0800A0E1           MOV      R0,R8
   \   000002DC   0B0000EF           SWI      +11
   \   000002E0   08108DE2           ADD      R1,SP,#+8
   \   000002E4   0800A0E1           MOV      R0,R8
   \   000002E8   0D0000EF           SWI      +13
   \   000002EC   2830A0E3           MOV      R3,#+40
   \   000002F0   0920A0E1           MOV      R2,R9
   \   000002F4   081084E2           ADD      R1,R4,#+8
   \   000002F8   2C008DE2           ADD      R0,SP,#+44
   \   000002FC   6D0100EF           SWI      +365
   \   00000300   2010A0E3           MOV      R1,#+32
   \   00000304   0C008DE2           ADD      R0,SP,#+12
   \   00000308   1D0100EF           SWI      +285
   \   0000030C   FE02DDE1           LDRSH    R0,[SP, #+46]
   \   00000310   0580A0E1           MOV      R8,R5
   \   00000314   08D08DE2           ADD      SP,SP,#+8
   \   00000318   010050E3           CMP      R0,#+1
   \   0000031C   040000AA           BGE      ??ConstructList_15
   \   00000320   83FFFFEA           B        ??ConstructList_8
   \                     ??ConstructList_16:
   \   00000324   0050C0E5           STRB     R5,[R0, #+0]
   \                     ??ConstructList_17:
   \   00000328   0110A0E3           MOV      R1,#+1
   \   0000032C   04108DE5           STR      R1,[SP, #+4]
   \                     ??ConstructList_18:
   \   00000330   018088E2           ADD      R8,R8,#+1
   \                     ??ConstructList_15:
   \   00000334   F602DDE1           LDRSH    R0,[SP, #+38]
   \   00000338   000058E1           CMP      R8,R0
   \   0000033C   7CFFFFAA           BGE      ??ConstructList_8
   \   00000340   30109DE5           LDR      R1,[SP, #+48]
   \   00000344   0C00A0E3           MOV      R0,#+12
   \   00000348   901829E0           MLA      R9,R0,R8,R1
   \   0000034C   0200D9E5           LDRB     R0,[R9, #+2]
   \   00000350   010050E3           CMP      R0,#+1
   \   00000354   F5FFFF0A           BEQ      ??ConstructList_18
   \   00000358   0300D9E5           LDRB     R0,[R9, #+3]
   \   0000035C   6F0100EF           SWI      +367
   \   00000360   010050E2           SUBS     R0,R0,#+1
   \   00000364   2E00000A           BEQ      ??ConstructList_19
   \   00000368   040050E2           SUBS     R0,R0,#+4
   \   0000036C   EFFFFF1A           BNE      ??ConstructList_18
   \   00000370   0300D9E5           LDRB     R0,[R9, #+3]
   \   00000374   081099E5           LDR      R1,[R9, #+8]
   \   00000378   230050E3           CMP      R0,#+35
   \   0000037C   24005013           CMPNE    R0,#+36
   \   00000380   60005013           CMPNE    R0,#+96
   \   00000384   1600001A           BNE      ??ConstructList_20
   \   00000388   000051E3           CMP      R1,#+0
   \   0000038C   E7FFFF0A           BEQ      ??ConstructList_18
   \   00000390   08009DE5           LDR      R0,[SP, #+8]
   \   00000394   000050E3           CMP      R0,#+0
   \   00000398   0800001A           BNE      ??ConstructList_21
   \   0000039C   040097E5           LDR      R0,[R7, #+4]
   \   000003A0   010080E2           ADD      R0,R0,#+1
   \   000003A4   040087E5           STR      R0,[R7, #+4]
   \   000003A8   9600A0E3           MOV      R0,#+150
   \   000003AC   250100EF           SWI      +293
   \   000003B0   08008DE5           STR      R0,[SP, #+8]
   \   000003B4   081099E5           LDR      R1,[R9, #+8]
   \   000003B8   1F0100EF           SWI      +287
   \   000003BC   D9FFFFEA           B        ??ConstructList_17
   \                     ??ConstructList_21:
   \   000003C0   2C10A0E3           MOV      R1,#+44
   \   000003C4   1C0000EF           SWI      +28
   \   000003C8   08009DE5           LDR      R0,[SP, #+8]
   \   000003CC   2010A0E3           MOV      R1,#+32
   \   000003D0   1C0000EF           SWI      +28
   \   000003D4   081099E5           LDR      R1,[R9, #+8]
   \   000003D8   08009DE5           LDR      R0,[SP, #+8]
   \   000003DC   210100EF           SWI      +289
   \   000003E0   D0FFFFEA           B        ??ConstructList_17
   \                     ??ConstructList_20:
   \   000003E4   680050E3           CMP      R0,#+104
   \   000003E8   D0FFFF1A           BNE      ??ConstructList_18
   \   000003EC   000051E3           CMP      R1,#+0
   \   000003F0   CEFFFF0A           BEQ      ??ConstructList_18
   \   000003F4   20009DE5           LDR      R0,[SP, #+32]
   \   000003F8   000050E3           CMP      R0,#+0
   \   000003FC   0200001A           BNE      ??ConstructList_22
   \   00000400   8000A0E3           MOV      R0,#+128
   \   00000404   140000EF           SWI      +20
   \   00000408   20008DE5           STR      R0,[SP, #+32]
   \                     ??ConstructList_22:
   \   0000040C   20109DE5           LDR      R1,[SP, #+32]
   \   00000410   080099E5           LDR      R0,[R9, #+8]
   \   00000414   7F20A0E3           MOV      R2,#+127
   \   00000418   A30000EF           SWI      +163
   \   0000041C   C3FFFFEA           B        ??ConstructList_18
   \                     ??ConstructList_1:
   \   00000420   5C000000           DC8      "\\",+0,+0
   \                     ??ConstructList_19:
   \   00000424   0300D9E5           LDRB     R0,[R9, #+3]
   \   00000428   08B099E5           LDR      R11,[R9, #+8]
   \   0000042C   6A0050E3           CMP      R0,#+106
   \   00000430   0300000A           BEQ      ??ConstructList_23
   \   00000434   620040E2           SUB      R0,R0,#+98
   \   00000438   050050E3           CMP      R0,#+5
   \   0000043C   BBFFFF2A           BCS      ??ConstructList_18
   \   00000440   000000EA           B        ??ConstructList_24
   \                     ??ConstructList_23:
   \   00000444   0400A0E3           MOV      R0,#+4
   \                     ??ConstructList_24:
   \   00000448   00005BE3           CMP      R11,#+0
   \   0000044C   B7FFFF0A           BEQ      ??ConstructList_18
   \   00000450   04108DE2           ADD      R1,SP,#+4
   \   00000454   009181E0           ADD      R9,R1,R0, LSL #+2
   \   00000458   3200A0E3           MOV      R0,#+50
   \   0000045C   140000EF           SWI      +20
   \   00000460   080089E5           STR      R0,[R9, #+8]
   \   00000464   0130DBE5           LDRB     R3,[R11, #+1]
   \   00000468   0020A0E3           MOV      R2,#+0
   \   0000046C   0210A0E1           MOV      R1,R2
   \   00000470   910053E3           CMP      R3,#+145
   \   00000474   0400001A           BNE      ??ConstructList_25
   \   00000478   2B30A0E3           MOV      R3,#+43
   \   0000047C   ........           STRB     R3,[R0], #+1
   \   00000480   010000EA           B        ??ConstructList_25
   \                     ??ConstructList_26:
   \   00000484   ........           STRB     R3,[R0], #+1
   \   00000488   011081E2           ADD      R1,R1,#+1
   \                     ??ConstructList_25:
   \   0000048C   0230DBE5           LDRB     R3,[R11, #+2]
   \   00000490   030052E1           CMP      R2,R3
   \   00000494   A2FFFFAA           BGE      ??ConstructList_16
   \   00000498   010011E3           TST      R1,#0x1
   \   0000049C   0B308200           ADDEQ    R3,R2,R11
   \   000004A0   05A0D305           LDRBEQ   R10,[R3, #+5]
   \   000004A4   01208212           ADDNE    R2,R2,#+1
   \   000004A8   2A32A011           LSRNE    R3,R10,#+4
   \   000004AC   0F300A02           ANDEQ    R3,R10,#0xF
   \   000004B0   0F0053E3           CMP      R3,#+15
   \   000004B4   9AFFFF0A           BEQ      ??ConstructList_16
   \   000004B8   0A0053E3           CMP      R3,#+10
   \   000004BC   2A30A003           MOVEQ    R3,#+42
   \   000004C0   EFFFFF0A           BEQ      ??ConstructList_26
   \   000004C4   0B0053E3           CMP      R3,#+11
   \   000004C8   2330A003           MOVEQ    R3,#+35
   \   000004CC   ECFFFF0A           BEQ      ??ConstructList_26
   \   000004D0   0C0053E3           CMP      R3,#+12
   \   000004D4   2B30A003           MOVEQ    R3,#+43
   \   000004D8   E9FFFF0A           BEQ      ??ConstructList_26
   \   000004DC   0D0053E3           CMP      R3,#+13
   \   000004E0   30308312           ADDNE    R3,R3,#+48
   \   000004E4   3F30A003           MOVEQ    R3,#+63
   \   000004E8   E5FFFFEA           B        ??ConstructList_26
    280          	}
    281          	else
    282          	{
    283          	  fclose(fin,&ul);
   \                     ??ConstructList_6:
   \   000004EC   0D0000EF           SWI      +13
    284          	}
    285              }
    286              mfree(buffer);
   \                     ??ConstructList_5:
   \   000004F0   0400A0E1           MOV      R0,R4
   \   000004F4   150000EF           SWI      +21
    287            }
    288            if (contact.next)
   \                     ??ConstructList_4:
   \   000004F8   04009DE5           LDR      R0,[SP, #+4]
   \   000004FC   000050E3           CMP      R0,#+0
   \   00000500   0D00000A           BEQ      ??ConstructList_27
    289            {
    290              if(contact.name) FreeWS(contact.name);
   \   00000504   08009DE5           LDR      R0,[SP, #+8]
   \   00000508   000050E3           CMP      R0,#+0
   \   0000050C   0000000A           BEQ      ??ConstructList_28
   \   00000510   290100EF           SWI      +297
    291              for(int i=0;i<NUMBERS_MAX;i++) 
   \                     ??ConstructList_28:
   \   00000514   0040A0E3           MOV      R4,#+0
   \                     ??ConstructList_29:
   \   00000518   04008DE2           ADD      R0,SP,#+4
   \   0000051C   040180E0           ADD      R0,R0,R4, LSL #+2
   \   00000520   080090E5           LDR      R0,[R0, #+8]
   \   00000524   000050E3           CMP      R0,#+0
   \   00000528   0000000A           BEQ      ??ConstructList_30
    292              {
    293                if(contact.num[i])
    294          	mfree(contact.num[i]);
   \   0000052C   150000EF           SWI      +21
    295              }
   \                     ??ConstructList_30:
   \   00000530   014084E2           ADD      R4,R4,#+1
   \   00000534   050054E3           CMP      R4,#+5
   \   00000538   F6FFFFBA           BLT      ??ConstructList_29
    296            }
    297          }
   \                     ??ConstructList_27:
   \   0000053C   38D08DE2           ADD      SP,SP,#+56
   \   00000540   40DE8DE2           ADD      SP,SP,#+1024
   \   00000544   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??ConstructList_0:
   \   00000548   ........           DC32     CFG_SYSTEM_FOLDER
   \   0000054C   ........           DC32     `?<Constant "apo\\\\addr\\\\main">`
   \   00000550   7D0CCEC7           DC32     0xffffffffc7ce0c7d
   \   00000554   85FAE337           DC32     0x37e3fa85
    298          
    299          

   \                                 In segment CODE, align 4, keep-with-next
    300          CLIST *GetClistItem(int n)
    301          {
    302          	int i=0;
    303          	CLIST *cl0=(CLIST *)cltop;
   \                     GetClistItem:
   \   00000000   ........           LDR      R1,??DataTable6  ;; cltop
   \   00000004   0020A0E3           MOV      R2,#+0
   \   00000008   001091E5           LDR      R1,[R1, #+0]
   \   0000000C   010000EA           B        ??GetClistItem_0
    304          	while(cl0)
    305          	{
    306          		if(i==n)
    307          			return cl0;
    308          		cl0=cl0->next;
   \                     ??GetClistItem_1:
   \   00000010   001091E5           LDR      R1,[R1, #+0]
    309          		i++;
   \   00000014   012082E2           ADD      R2,R2,#+1
   \                     ??GetClistItem_0:
   \   00000018   000051E3           CMP      R1,#+0
   \   0000001C   0300000A           BEQ      ??GetClistItem_2
   \   00000020   000052E1           CMP      R2,R0
   \   00000024   F9FFFF1A           BNE      ??GetClistItem_1
   \   00000028   0100A0E1           MOV      R0,R1
   \   0000002C   1EFF2FE1           BX       LR
    310          	}
    311          	return 0;
   \                     ??GetClistItem_2:
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   1EFF2FE1           BX       LR               ;; return
    312          }
    313          

   \                                 In segment CODE, align 4, keep-with-next
    314          int SearchInCList(WSHDR *searchstr)
    315          {
   \                     SearchInCList:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    316          	int i=0;
    317          	CLIST *cl=(CLIST *)cltop;
   \   00000008   ........           LDR      R0,??DataTable6  ;; cltop
   \   0000000C   0050A0E3           MOV      R5,#+0
   \   00000010   006090E5           LDR      R6,[R0, #+0]
   \   00000014   010000EA           B        ??SearchInCList_0
    318          	while(cl)
    319          	{
    320          		if(cl->name)
    321          			if(!wstrncmp_nocase(cl->name, searchstr, wslen(searchstr)))
    322          				return i;
    323          		cl=cl->next;
   \                     ??SearchInCList_1:
   \   00000018   006096E5           LDR      R6,[R6, #+0]
    324          		i++;
   \   0000001C   015085E2           ADD      R5,R5,#+1
   \                     ??SearchInCList_0:
   \   00000020   000056E3           CMP      R6,#+0
   \   00000024   0A00000A           BEQ      ??SearchInCList_2
   \   00000028   040096E5           LDR      R0,[R6, #+4]
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   F8FFFF0A           BEQ      ??SearchInCList_1
   \   00000034   001094E5           LDR      R1,[R4, #+0]
   \   00000038   B020D1E1           LDRH     R2,[R1, #+0]
   \   0000003C   0410A0E1           MOV      R1,R4
   \   00000040   ........           _BLF     wstrncmp_nocase,??wstrncmp_nocase??rA
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   F2FFFF1A           BNE      ??SearchInCList_1
   \   0000004C   0500A0E1           MOV      R0,R5
   \   00000050   7080BDE8           POP      {R4-R6,PC}
    325          	}
    326          	return -1;
   \                     ??SearchInCList_2:
   \   00000054   0000E0E3           MVN      R0,#+0
   \   00000058   7080BDE8           POP      {R4-R6,PC}       ;; return
    327          }
    328          #define MAX(A, B) ((A>B)?A:B)
    329          #define MIN(A, B) ((A<B)?A:B)

   \                                 In segment CODE, align 4, keep-with-next
    330          int findNameByNum(WSHDR *name_to, char *num)
    331          {
   \                     findNameByNum:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    332          	CLIST *cl=(CLIST *)cltop;
   \   00000008   ........           LDR      R0,??DataTable6  ;; cltop
   \   0000000C   0150B0E1           MOVS     R5,R1
   \   00000010   006090E5           LDR      R6,[R0, #+0]
    333          	int i, la, lb, ld;
    334          	char *p1;
    335          	char *pp;
    336          	if((!num)||(!name_to)||(strlen(num)<=3))
   \   00000014   00005413           CMPNE    R4,#+0
   \   00000018   0300000A           BEQ      ??findNameByNum_0
   \   0000001C   0500A0E1           MOV      R0,R5
   \   00000020   1B0000EF           SWI      +27
   \   00000024   040050E3           CMP      R0,#+4
   \   00000028   0500002A           BCS      ??findNameByNum_1
    337          		return 0;
   \                     ??findNameByNum_0:
   \   0000002C   0000A0E3           MOV      R0,#+0
   \   00000030   F087BDE8           POP      {R4-R10,PC}
    338          	while(cl)
    339          	{
    340          		i=0;
    341          		for(;i<NUMBERS_MAX;i++)
   \                     ??findNameByNum_2:
   \   00000034   017087E2           ADD      R7,R7,#+1
   \   00000038   050057E3           CMP      R7,#+5
   \   0000003C   030000BA           BLT      ??findNameByNum_3
    342          		{
    343          			if(cl->num[i])
    344          			{
    345          				//号码查找比较,根据短的比较长的后面部分
    346          				p1=cl->num[i];
    347          				if(*p1=='+')
    348          					p1++;
    349          				pp=num;
    350          				if(*pp=='+')
    351          					pp++;
    352          				la=strlen(pp);
    353          				lb=strlen(p1);
    354          				if(MAX(la, lb)-MIN(la, lb) > 3)
    355          					continue;
    356          				if(la>lb)
    357          				{
    358          					ld=lb;
    359          					pp+=la-lb;
    360          				}
    361          				else
    362          				{
    363          					ld=la;
    364          					p1+=lb-la;
    365          				}
    366          				if(!strncmp(pp, p1, ld))
    367          				{
    368          					if(cl->name)
    369          					{
    370          						wstrcpy(name_to, cl->name);
    371          						return 1;
    372          					}
    373          				}
    374          			}
    375          		}
    376          		cl=cl->next;
   \   00000040   006096E5           LDR      R6,[R6, #+0]
   \                     ??findNameByNum_1:
   \   00000044   000056E3           CMP      R6,#+0
   \   00000048   F7FFFF0A           BEQ      ??findNameByNum_0
   \   0000004C   0070A0E3           MOV      R7,#+0
   \                     ??findNameByNum_3:
   \   00000050   070186E0           ADD      R0,R6,R7, LSL #+2
   \   00000054   081090E5           LDR      R1,[R0, #+8]
   \   00000058   000051E3           CMP      R1,#+0
   \   0000005C   F4FFFF0A           BEQ      ??findNameByNum_2
   \   00000060   0180A0E1           MOV      R8,R1
   \   00000064   0000D8E5           LDRB     R0,[R8, #+0]
   \   00000068   0590A0E1           MOV      R9,R5
   \   0000006C   2B0050E3           CMP      R0,#+43
   \   00000070   0000D9E5           LDRB     R0,[R9, #+0]
   \   00000074   01808802           ADDEQ    R8,R8,#+1
   \   00000078   2B0050E3           CMP      R0,#+43
   \   0000007C   01908902           ADDEQ    R9,R9,#+1
   \   00000080   0900A0E1           MOV      R0,R9
   \   00000084   1B0000EF           SWI      +27
   \   00000088   00A0A0E1           MOV      R10,R0
   \   0000008C   0800A0E1           MOV      R0,R8
   \   00000090   1B0000EF           SWI      +27
   \   00000094   0A0050E1           CMP      R0,R10
   \   00000098   0A0000AA           BGE      ??findNameByNum_4
   \   0000009C   0A10A0E1           MOV      R1,R10
   \                     ??findNameByNum_5:
   \   000000A0   0020A0E1           MOV      R2,R0
   \                     ??findNameByNum_6:
   \   000000A4   021041E0           SUB      R1,R1,R2
   \   000000A8   040051E3           CMP      R1,#+4
   \   000000AC   E0FFFFAA           BGE      ??findNameByNum_2
   \   000000B0   0A0050E1           CMP      R0,R10
   \   000000B4   080000AA           BGE      ??findNameByNum_7
   \   000000B8   0020A0E1           MOV      R2,R0
   \   000000BC   00004AE0           SUB      R0,R10,R0
   \   000000C0   099080E0           ADD      R9,R0,R9
   \   000000C4   070000EA           B        ??findNameByNum_8
   \                     ??findNameByNum_4:
   \   000000C8   0010A0E1           MOV      R1,R0
   \   000000CC   00005AE1           CMP      R10,R0
   \   000000D0   F2FFFFAA           BGE      ??findNameByNum_5
   \   000000D4   0A20A0E1           MOV      R2,R10
   \   000000D8   F1FFFFEA           B        ??findNameByNum_6
   \                     ??findNameByNum_7:
   \   000000DC   0A20A0E1           MOV      R2,R10
   \   000000E0   0A0040E0           SUB      R0,R0,R10
   \   000000E4   088080E0           ADD      R8,R0,R8
   \                     ??findNameByNum_8:
   \   000000E8   0810A0E1           MOV      R1,R8
   \   000000EC   0900A0E1           MOV      R0,R9
   \   000000F0   150100EF           SWI      +277
   \   000000F4   000050E3           CMP      R0,#+0
   \   000000F8   CDFFFF1A           BNE      ??findNameByNum_2
   \   000000FC   040096E5           LDR      R0,[R6, #+4]
   \   00000100   000050E3           CMP      R0,#+0
   \   00000104   CAFFFF0A           BEQ      ??findNameByNum_2
   \   00000108   0010A0E1           MOV      R1,R0
   \   0000010C   0400A0E1           MOV      R0,R4
   \   00000110   1F0100EF           SWI      +287
   \   00000114   0100A0E3           MOV      R0,#+1
   \   00000118   F087BDE8           POP      {R4-R10,PC}      ;; return
    377          	}
    378          	return 0;
    379          }
    380          
    381          

   \                                 In segment CODE, align 4, keep-with-next
    382          CLIST *FindClByNum(const char *num)
    383          {
   \                     FindClByNum:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    384            CLIST *cl=(CLIST *)cltop;
   \   00000008   ........           LDR      R0,??DataTable6  ;; cltop
   \   0000000C   005090E5           LDR      R5,[R0, #+0]
    385            int i, la, lb, ld;
    386            const char *p1;
    387            const char *pp;
    388            if((!num)||(strlen(num)<=3))
   \   00000010   0300000A           BEQ      ??FindClByNum_0
   \   00000014   0400A0E1           MOV      R0,R4
   \   00000018   1B0000EF           SWI      +27
   \   0000001C   040050E3           CMP      R0,#+4
   \   00000020   0500002A           BCS      ??FindClByNum_1
    389              return 0;
   \                     ??FindClByNum_0:
   \   00000024   0000A0E3           MOV      R0,#+0
   \   00000028   F083BDE8           POP      {R4-R9,PC}
    390            while(cl)
    391            {
    392              i=0;
    393              for(;i<NUMBERS_MAX;i++)
   \                     ??FindClByNum_2:
   \   0000002C   016086E2           ADD      R6,R6,#+1
   \   00000030   050056E3           CMP      R6,#+5
   \   00000034   030000BA           BLT      ??FindClByNum_3
    394              {
    395                if(cl->num[i])
    396                {
    397          	//号码查找比较,根据短的比较长的后面部分
    398          	p1=cl->num[i];
    399          	if(*p1=='+')
    400          	  p1++;
    401          	pp=num;
    402          	if(*pp=='+')
    403          	  pp++;
    404          	la=strlen(pp);
    405          	lb=strlen(p1);
    406          	if(MAX(la, lb)-MIN(la, lb) > 3)
    407          	  continue;
    408          	if(la>lb)
    409          	{
    410          	  ld=lb;
    411          	  pp+=la-lb;
    412          	}
    413          	else
    414          	{
    415          	  ld=la;
    416          	  p1+=lb-la;
    417          	}
    418          	if(!strncmp(pp, p1, ld))
    419          	{
    420          	  return cl;
    421          	}
    422                }
    423              }
    424              cl=cl->next;
   \   00000038   005095E5           LDR      R5,[R5, #+0]
   \                     ??FindClByNum_1:
   \   0000003C   000055E3           CMP      R5,#+0
   \   00000040   F7FFFF0A           BEQ      ??FindClByNum_0
   \   00000044   0060A0E3           MOV      R6,#+0
   \                     ??FindClByNum_3:
   \   00000048   060185E0           ADD      R0,R5,R6, LSL #+2
   \   0000004C   081090E5           LDR      R1,[R0, #+8]
   \   00000050   000051E3           CMP      R1,#+0
   \   00000054   F4FFFF0A           BEQ      ??FindClByNum_2
   \   00000058   0170A0E1           MOV      R7,R1
   \   0000005C   0000D7E5           LDRB     R0,[R7, #+0]
   \   00000060   0480A0E1           MOV      R8,R4
   \   00000064   2B0050E3           CMP      R0,#+43
   \   00000068   0000D8E5           LDRB     R0,[R8, #+0]
   \   0000006C   01708702           ADDEQ    R7,R7,#+1
   \   00000070   2B0050E3           CMP      R0,#+43
   \   00000074   01808802           ADDEQ    R8,R8,#+1
   \   00000078   0800A0E1           MOV      R0,R8
   \   0000007C   1B0000EF           SWI      +27
   \   00000080   0090A0E1           MOV      R9,R0
   \   00000084   0700A0E1           MOV      R0,R7
   \   00000088   1B0000EF           SWI      +27
   \   0000008C   090050E1           CMP      R0,R9
   \   00000090   0A0000AA           BGE      ??FindClByNum_4
   \   00000094   0910A0E1           MOV      R1,R9
   \                     ??FindClByNum_5:
   \   00000098   0020A0E1           MOV      R2,R0
   \                     ??FindClByNum_6:
   \   0000009C   021041E0           SUB      R1,R1,R2
   \   000000A0   040051E3           CMP      R1,#+4
   \   000000A4   E0FFFFAA           BGE      ??FindClByNum_2
   \   000000A8   090050E1           CMP      R0,R9
   \   000000AC   080000AA           BGE      ??FindClByNum_7
   \   000000B0   0020A0E1           MOV      R2,R0
   \   000000B4   000049E0           SUB      R0,R9,R0
   \   000000B8   088080E0           ADD      R8,R0,R8
   \   000000BC   070000EA           B        ??FindClByNum_8
   \                     ??FindClByNum_4:
   \   000000C0   0010A0E1           MOV      R1,R0
   \   000000C4   000059E1           CMP      R9,R0
   \   000000C8   F2FFFFAA           BGE      ??FindClByNum_5
   \   000000CC   0920A0E1           MOV      R2,R9
   \   000000D0   F1FFFFEA           B        ??FindClByNum_6
   \                     ??FindClByNum_7:
   \   000000D4   0920A0E1           MOV      R2,R9
   \   000000D8   090040E0           SUB      R0,R0,R9
   \   000000DC   077080E0           ADD      R7,R0,R7
   \                     ??FindClByNum_8:
   \   000000E0   0710A0E1           MOV      R1,R7
   \   000000E4   0800A0E1           MOV      R0,R8
   \   000000E8   150100EF           SWI      +277
   \   000000EC   000050E3           CMP      R0,#+0
   \   000000F0   CDFFFF1A           BNE      ??FindClByNum_2
   \   000000F4   0500A0E1           MOV      R0,R5
   \   000000F8   F083BDE8           POP      {R4-R9,PC}       ;; return
    425            }
    426            return 0;
    427          }
    428          

   \                                 In segment CODE, align 4, keep-with-next
    429          int getNumCount(CLIST *cl)
    430          {
    431          	int i=0;
   \                     getNumCount:
   \   00000000   0010A0E3           MOV      R1,#+0
    432          	int j=0;
   \   00000004   0020A0E3           MOV      R2,#+0
    433          	for(;j<NUMBERS_MAX;j++)
    434          	{
    435          		if(cl->num[j])
   \                     ??getNumCount_0:
   \   00000008   023180E0           ADD      R3,R0,R2, LSL #+2
   \   0000000C   083093E5           LDR      R3,[R3, #+8]
    436          			i++;
    437          	}
   \   00000010   012082E2           ADD      R2,R2,#+1
   \   00000014   000053E3           CMP      R3,#+0
   \   00000018   01108112           ADDNE    R1,R1,#+1
   \   0000001C   050052E3           CMP      R2,#+5
   \   00000020   F8FFFFBA           BLT      ??getNumCount_0
    438          	return i;
   \   00000024   0100A0E1           MOV      R0,R1
   \   00000028   1EFF2FE1           BX       LR               ;; return
    439          }
    440          

   \                                 In segment CODE, align 4, keep-with-next
    441          char *getNumFromCL(CLIST *cl, int n)
    442          {
   \                     getNumFromCL:
   \   00000000   10002DE9           PUSH     {R4}
    443          	int i=0, j=0;
   \   00000004   0020A0E3           MOV      R2,#+0
   \   00000008   0030A0E3           MOV      R3,#+0
    444          	for(;j<NUMBERS_MAX;j++)
    445          	{
    446          		if(cl->num[j]!=0)
   \                     ??getNumFromCL_0:
   \   0000000C   03C180E0           ADD      R12,R0,R3, LSL #+2
   \   00000010   08409CE5           LDR      R4,[R12, #+8]
   \   00000014   000054E3           CMP      R4,#+0
   \   00000018   0300000A           BEQ      ??getNumFromCL_1
    447          		{
    448          			if(i==n)
   \   0000001C   010052E1           CMP      R2,R1
    449          				return cl->num[j];
   \   00000020   0400A001           MOVEQ    R0,R4
   \   00000024   0400000A           BEQ      ??getNumFromCL_2
    450          			else
    451          				i++;
   \   00000028   012082E2           ADD      R2,R2,#+1
    452          		}
    453          	}
   \                     ??getNumFromCL_1:
   \   0000002C   013083E2           ADD      R3,R3,#+1
   \   00000030   050053E3           CMP      R3,#+5
   \   00000034   F4FFFFBA           BLT      ??getNumFromCL_0
    454          	return 0;
   \   00000038   0000A0E3           MOV      R0,#+0
   \                     ??getNumFromCL_2:
   \   0000003C   1000BDE8           POP      {R4}
   \   00000040   1EFF2FE1           BX       LR               ;; return
    455          }
    456          

   \                                 In segment CODE, align 4, keep-with-next
    457          char *getPrefNumFromCL(CLIST *cl)
    458          {
    459          	int i=NUMBERS_MAX-1;
   \                     getPrefNumFromCL:
   \   00000000   0410A0E3           MOV      R1,#+4
    460          	for(;i>=0;i--)
    461          	{
    462          		if(cl->num[i]!=0)
   \                     ??getPrefNumFromCL_0:
   \   00000004   012180E0           ADD      R2,R0,R1, LSL #+2
   \   00000008   083092E5           LDR      R3,[R2, #+8]
   \   0000000C   000053E3           CMP      R3,#+0
    463          			return cl->num[i];
   \   00000010   0300A011           MOVNE    R0,R3
   \   00000014   1EFF2F11           BXNE     LR
    464          	}
   \   00000018   011051E2           SUBS     R1,R1,#+1
   \   0000001C   F8FFFF5A           BPL      ??getPrefNumFromCL_0
    465          	return 0;
   \   00000020   0000A0E3           MOV      R0,#+0
   \   00000024   1EFF2FE1           BX       LR               ;; return
    466          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   ........           DC32     cltop

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   5C00               DC8 "\\"

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "apo\\\\addr\\\\main">`:
   \   00000000   61706F5C6164       DC8 "apo\\addr\\main"
   \              64725C6D6169
   \              6E00        
   \   0000000E   0000               DC8 0, 0
   \   00000010   61706F5C6164       DC8 "apo\\addr\\data\\%02d\\%02d\\%02d"
   \              64725C646174
   \              615C25303264
   \              5C253032645C
   \              2530326400  
   \   0000002D   000000             DC8 0, 0, 0

   Maximum stack usage in bytes:

     Function         CSTACK
     --------         ------
     ConstructList     1124
     ConstructListN       4
     FindClByNum         28
     FreeCLIST           12
     GetClistItem         0
     SearchInCList       16
     findNameByNum       32
     getNumCount          0
     getNumFromCL         4
     getPrefNumFromCL     0


   Segment part sizes:

     Function/Label                Bytes
     --------------                -----
     cltop                            8
     FreeCLIST                      132
     ConstructListN                  28
     ConstructList                 1368
     GetClistItem                    56
     SearchInCList                   92
     findNameByNum                  284
     FindClByNum                    252
     getNumCount                     44
     getNumFromCL                    68
     getPrefNumFromCL                40
     ??DataTable6                     4
     ?<Constant "\\">                 2
     ?<Constant "apo\\addr\\main">   48
      Others                         64

 
 2 420 bytes in segment CODE
    50 bytes in segment DATA_C
     8 bytes in segment DATA_Z
    12 bytes in segment INITTAB
 
 2 368 bytes of CODE  memory (+ 64 bytes shared)
    50 bytes of CONST memory
     8 bytes of DATA  memory

Errors: none
Warnings: none
