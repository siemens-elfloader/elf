##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    25/Jan/2011  13:22:01 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\flamee_m\main.c                               #
#    Command line    =  C:\arm\flamee_m\main.c -D NEWSGOLD -D ELKA -lC       #
#                       C:\arm\flamee_m\Release_ELKA\List\ -lA               #
#                       C:\arm\flamee_m\Release_ELKA\List\ -o                #
#                       C:\arm\flamee_m\Release_ELKA\Obj\ -s9 --no_unroll    #
#                       --cpu_mode arm --endian little --cpu ARM926EJ-S      #
#                       --stack_align 4 --interwork -e --fpu None -I         #
#                       "C:\arm2\Embedded Workbench 4.0                      #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  C:\arm\flamee_m\Release_ELKA\List\main.lst           #
#    Object file     =  C:\arm\flamee_m\Release_ELKA\Obj\main.r79            #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\flamee_m\main.c
      1          #include "..\inc\swilib.h"
      2          #define DEBUG
      3          // попытка сделать эффект горящего пламени
      4          // автор начала Feanor
      5          // далее уже пытаюсь развивать я (Z80)
      6          // этот эльф не является заставкой или там для чего то подобного
      7          // просто мне интересно вот и занимаюсь

   \                                 In segment DATA_C, align 4, align-sorted
      8          const int minus11=-11;
   \                     minus11:
   \   00000000   F5FFFFFF           DC32 -11

   \                                 In segment DATA_Z, align 4, align-sorted
      9          unsigned short maincsm_name_body[140];
   \                     maincsm_name_body:
   \   00000000                      DS8 280

   \                                 In segment DATA_Z, align 4, align-sorted
     10          unsigned int MAINCSM_ID = 0;
   \                     MAINCSM_ID:
   \   00000000                      DS8 4

   \                                 In segment DATA_Z, align 4, align-sorted
     11          unsigned int MAINGUI_ID = 0;
   \                     MAINGUI_ID:
   \   00000000                      DS8 4
     12          #ifdef ELKA
     13          #define width 240
     14          #define height 320
     15          #else
     16          #define width 132
     17          #define height 176
     18          #endif
     19          
     20          

   \                                 In segment DATA_I, align 4, align-sorted
     21          int maxx=200;
   \                     maxx:
   \   00000000                      DS8 4
   \   00000004                      REQUIRE `?<Initializer for maxx>`
     22          typedef struct
     23          {
     24            CSM_RAM csm;
     25            int gui_id;
     26          }MAIN_CSM;
     27          typedef struct
     28          {
     29            GUI gui;
     30            WSHDR *ws1;
     31            WSHDR *ws2;
     32            int i1;
     33          }MAIN_GUI;
     34          

   \                                 In segment DATA_Z, align 4, align-sorted
     35            short screen[width*height];
   \                     screen:
   \   00000000                      DS8 153600

   \                                 In segment DATA_Z, align 4, align-sorted
     36            short screen2[width*height];
   \                     screen2:
   \   00000000                      DS8 153600

   \                                 In segment DATA_Z, align 4, align-sorted
     37            int Rc=0;
   \                     Rc:
   \   00000000                      DS8 4
     38            int Gc=0;
   \                     Gc:
   \   00000004                      DS8 4
     39            int Bc=0;
   \                     Bc:
   \   00000008                      DS8 4
     40            int countpallet=0;
   \                     countpallet:
   \   0000000C                      DS8 4
     41            int palletka[256];
   \                     palletka:
   \   00000010                      DS8 1024
     42            

   \                                 In segment CODE, align 4, keep-with-next
     43          int rgb2bitmap16 (R,G,B)  // (c) mirr
     44          {
     45            return ((B>>3)+((G>>2)<<5)+((R>>3)<<11));
   \                     rgb2bitmap16:
   \   00000000   4111A0E1           ASR      R1,R1,#+2
   \   00000004   8112A0E1           LSL      R1,R1,#+5
   \   00000008   C21181E0           ADD      R1,R1,R2, ASR #+3
   \   0000000C   C001A0E1           ASR      R0,R0,#+3
   \   00000010   800581E0           ADD      R0,R1,R0, LSL #+11
   \   00000014   1EFF2FE1           BX       LR               ;; return
     46          }
     47          
     48          /////////////////////////////// создадим палитру

   \                                 In segment CODE, align 4, keep-with-next
     49          void createpallet ()
     50          
     51          {
     52          for (int i=1; i<255; i++)
   \                     createpallet:
   \   00000000   FC009FE5           LDR      R0,??createpallet_0  ;; Rc
   \   00000004   70002DE9           PUSH     {R4-R6}
   \   00000008   0110A0E3           MOV      R1,#+1
   \   0000000C   FF30A0E3           MOV      R3,#+255
   \   00000010   FF3C83E3           ORR      R3,R3,#0xFF00
     53          {
     54            palletka[i]=65535;
   \                     ??createpallet_1:
   \   00000014   012180E0           ADD      R2,R0,R1, LSL #+2
   \   00000018   103082E5           STR      R3,[R2, #+16]
     55          }
   \   0000001C   011081E2           ADD      R1,R1,#+1
   \   00000020   FF0051E3           CMP      R1,#+255
   \   00000024   FAFFFFBA           BLT      ??createpallet_1
     56          
     57          int ix=0;
   \   00000028   0020A0E3           MOV      R2,#+0
     58           for (int i=1; i<85; i++)  // с черного в красный
   \   0000002C   0130A0E3           MOV      R3,#+1
     59          {
     60              Rc= ix;
     61          
     62          
     63            countpallet++;
     64          palletka [countpallet]= rgb2bitmap16 ( Rc, Gc,Bc)+1;
   \                     ??createpallet_2:
   \   00000030   085090E5           LDR      R5,[R0, #+8]
   \   00000034   0C1090E5           LDR      R1,[R0, #+12]
   \   00000038   C5C1A0E1           ASR      R12,R5,#+3
   \   0000003C   045090E5           LDR      R5,[R0, #+4]
   \   00000040   002080E5           STR      R2,[R0, #+0]
   \   00000044   014081E2           ADD      R4,R1,#+1
   \   00000048   0C4080E5           STR      R4,[R0, #+12]
   \   0000004C   0210A0E1           MOV      R1,R2
   \   00000050   C111A0E1           ASR      R1,R1,#+3
   \   00000054   8115A0E1           LSL      R1,R1,#+11
   \   00000058   044180E0           ADD      R4,R0,R4, LSL #+2
   \   0000005C   4551A0E1           ASR      R5,R5,#+2
   \   00000060   85528CE0           ADD      R5,R12,R5, LSL #+5
   \   00000064   055081E0           ADD      R5,R1,R5
   \   00000068   015085E2           ADD      R5,R5,#+1
   \   0000006C   105084E5           STR      R5,[R4, #+16]
     65          ix++;
     66          ix++;
     67          ix++;
   \   00000070   032082E2           ADD      R2,R2,#+3
     68          
     69          }
   \   00000074   013083E2           ADD      R3,R3,#+1
   \   00000078   550053E3           CMP      R3,#+85
   \   0000007C   EBFFFFBA           BLT      ??createpallet_2
     70          
     71          ix=0;
   \   00000080   0030A0E3           MOV      R3,#+0
     72           for (int i=1; i<85; i++)  // с красного в желтый
   \   00000084   0140A0E3           MOV      R4,#+1
     73          {
     74              Gc= ix;
     75          
     76          
     77            countpallet++;
   \                     ??createpallet_3:
   \   00000088   0C2090E5           LDR      R2,[R0, #+12]
   \   0000008C   043080E5           STR      R3,[R0, #+4]
   \   00000090   015082E2           ADD      R5,R2,#+1
   \   00000094   0C5080E5           STR      R5,[R0, #+12]
     78          palletka [countpallet]= rgb2bitmap16 (Rc,Gc,Bc);
   \   00000098   0320A0E1           MOV      R2,R3
   \   0000009C   4221A0E1           ASR      R2,R2,#+2
   \   000000A0   8222A0E1           LSL      R2,R2,#+5
   \   000000A4   055180E0           ADD      R5,R0,R5, LSL #+2
   \   000000A8   0C6081E0           ADD      R6,R1,R12
   \   000000AC   066082E0           ADD      R6,R2,R6
   \   000000B0   106085E5           STR      R6,[R5, #+16]
     79          ix++;
     80          ix++;
     81          ix++;
   \   000000B4   033083E2           ADD      R3,R3,#+3
     82          
     83          
     84          }
   \   000000B8   014084E2           ADD      R4,R4,#+1
   \   000000BC   550054E3           CMP      R4,#+85
   \   000000C0   F0FFFFBA           BLT      ??createpallet_3
     85          ix=0;
   \   000000C4   0030A0E3           MOV      R3,#+0
     86          
     87           for (int i=1; i<85; i++)  // с желтого в белый
   \   000000C8   0140A0E3           MOV      R4,#+1
     88          {
     89          Bc=ix;
     90          countpallet++;
   \                     ??createpallet_4:
   \   000000CC   0C5090E5           LDR      R5,[R0, #+12]
   \   000000D0   083080E5           STR      R3,[R0, #+8]
   \   000000D4   015085E2           ADD      R5,R5,#+1
   \   000000D8   0C5080E5           STR      R5,[R0, #+12]
     91          palletka [countpallet]= rgb2bitmap16 (Rc,Gc,Bc);
   \   000000DC   055180E0           ADD      R5,R0,R5, LSL #+2
   \   000000E0   016082E0           ADD      R6,R2,R1
   \   000000E4   C36186E0           ADD      R6,R6,R3, ASR #+3
   \   000000E8   106085E5           STR      R6,[R5, #+16]
     92          ix++;
     93          ix++;
     94          ix++;
   \   000000EC   033083E2           ADD      R3,R3,#+3
     95          
     96          }
   \   000000F0   014084E2           ADD      R4,R4,#+1
   \   000000F4   550054E3           CMP      R4,#+85
   \   000000F8   F3FFFFBA           BLT      ??createpallet_4
     97          
     98          
     99          }
   \   000000FC   7000BDE8           POP      {R4-R6}
   \   00000100   1EFF2FE1           BX       LR               ;; return
   \                     ??createpallet_0:
   \   00000104   ........           DC32     Rc
    100          
    101          
    102          

   \                                 In segment CODE, align 4, keep-with-next
    103          void filtr ()  // отфильтруем через палитру
    104          {
    105          int  indexcolor;
    106          int indexx;
    107          
    108            for (int i=0; i<width*height; i++)
   \                     filtr:
   \   00000000   30309FE5           LDR      R3,??filtr_0     ;; Rc
   \   00000004   0000A0E3           MOV      R0,#+0
    109            {
    110              indexx= screen[i];
    111              indexcolor= palletka [indexx];
    112              screen2 [i]=indexcolor;
   \                     ??filtr_1:
   \   00000008   ........           LDR      R2,??DataTable5  ;; screen
   \   0000000C   ........           LDR      R1,??DataTable8  ;; screen2
   \   00000010   802082E0           ADD      R2,R2,R0, LSL #+1
   \   00000014   F020D2E1           LDRSH    R2,[R2, #+0]
   \   00000018   801081E0           ADD      R1,R1,R0, LSL #+1
    113            }
   \   0000001C   010080E2           ADD      R0,R0,#+1
   \   00000020   022183E0           ADD      R2,R3,R2, LSL #+2
   \   00000024   102092E5           LDR      R2,[R2, #+16]
   \   00000028   4B0B50E3           CMP      R0,#+76800
   \   0000002C   B020C1E1           STRH     R2,[R1, #+0]
   \   00000030   F4FFFFBA           BLT      ??filtr_1
    114          }
   \   00000034   1EFF2FE1           BX       LR               ;; return
   \                     ??filtr_0:
   \   00000038   ........           DC32     Rc
    115          
    116          //================================================================

   \                                 In segment DATA_Z, align 4, align-sorted
    117          unsigned int randseed;
   \                     randseed:
   \   00000000                      DS8 4
    118          #define random randint
    119          #define randomize Randomize

   \                                 In segment CODE, align 4, keep-with-next
    120          unsigned int randint( int max )
    121          {
    122            randseed *=0x08088405;
    123            randseed++;
   \                     randint:
   \   00000000   ........           LDR      R2,??DataTable3  ;; randseed
   \   00000004   14309FE5           LDR      R3,??randint_0   ;; 0x8088405
   \   00000008   0010A0E1           MOV      R1,R0
   \   0000000C   000092E5           LDR      R0,[R2, #+0]
   \   00000010   930000E0           MUL      R0,R3,R0
   \   00000014   010080E2           ADD      R0,R0,#+1
   \   00000018   000082E5           STR      R0,[R2, #+0]
    124            return (  (randseed % max)  );
   \   0000001C   ........           _BF      ??divu32_a,??rA??divu32_a
   \                     ??randint_0:
   \   00000020   05840808           DC32     0x8088405
    125          }

   \                                 In segment CODE, align 4, keep-with-next
    126          void Randomize(){ // Вызываем при старте для случайной последовательности
   \                     Randomize:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
    127            TDate date;
    128            TTime time;
    129            GetDateTime(&date,&time);
   \   00000008   0D10A0E1           MOV      R1,SP
   \   0000000C   08008DE2           ADD      R0,SP,#+8
   \   00000010   B40000EF           SWI      +180
    130            //rndindex = (unsigned char)time.param;
    131            randseed=(time.min | (time.sec<<5));
   \   00000014   0110DDE5           LDRB     R1,[SP, #+1]
   \   00000018   0220DDE5           LDRB     R2,[SP, #+2]
   \   0000001C   ........           LDR      R0,??DataTable3  ;; randseed
   \   00000020   821281E1           ORR      R1,R1,R2, LSL #+5
   \   00000024   001080E5           STR      R1,[R0, #+0]
    132          }
   \   00000028   0F80BDE8           POP      {R0-R3,PC}       ;; return
    133          //================================================================
    134          
    135            IMGHDR img; 
    136            GBSTMR timer;

   \                                 In segment CODE, align 4, keep-with-next
    137          void timer_proc(void){DirectRedrawGUI(); GBS_StartTimerProc(&timer,15,timer_proc);}
   \                     timer_proc:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   3F0100EF           SWI      +319
   \   00000008   0C209FE5           LDR      R2,??timer_proc_0  ;; timer_proc
   \   0000000C   ........           LDR      R0,??DataTable9  ;; timer
   \   00000010   0F10A0E3           MOV      R1,#+15
   \   00000014   4D0000EF           SWI      +77
   \   00000018   0080BDE8           POP      {PC}             ;; return
   \                     ??timer_proc_0:
   \   0000001C   ........           DC32     timer_proc
    138          inline void SetPix(int x,int y,int cl)
    139          {  
    140            if(x<0 || x>width-1 || y<1 || y>height) return;
    141            //cl--;
    142            if (cl<0) cl=0;
    143            else screen[x+y*width] =cl;
    144          }
    145          inline short GetPix(int x,int y)
    146          {  
    147            return screen[x+y*width];
    148          }
    149          

   \                                 In segment CODE, align 4, keep-with-next
    150          inline void Init()
    151          {
    152            for (int i=1; i!=width-1; i++)
   \                     Init:
   \   00000000   0100A0E3           MOV      R0,#+1
    153            {
    154              SetPix(i,height-1,randint(255));
   \                     ??Init_0:
   \   00000004   64109FE5           LDR      R1,??Init_1      ;; randseed
   \   00000008   64309FE5           LDR      R3,??Init_1+0x4  ;; 0x8088405
   \   0000000C   002091E5           LDR      R2,[R1, #+0]
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   930202E0           MUL      R2,R3,R2
   \   00000018   58309FE5           LDR      R3,??Init_1+0x8  ;; 0xffffffff80808081
   \   0000001C   012082E2           ADD      R2,R2,#+1
   \   00000020   002081E5           STR      R2,[R1, #+0]
   \   00000024   93C281E0           UMULL    R12,R1,R3,R2
   \   00000028   FFC0A0E3           MOV      R12,#+255
   \   0000002C   A113A0E1           LSR      R1,R1,#+7
   \   00000030   9C0101E0           MUL      R1,R12,R1
   \   00000034   011042E0           SUB      R1,R2,R1
   \   00000038   0800004A           BMI      ??Init_2
   \   0000003C   F00050E3           CMP      R0,#+240
   \   00000040   060000AA           BGE      ??Init_2
   \   00000044   000051E3           CMP      R1,#+0
   \   00000048   0400004A           BMI      ??Init_2
   \   0000004C   28309FE5           LDR      R3,??Init_1+0xC  ;; screen
   \   00000050   942BA0E3           MOV      R2,#+151552
   \   00000054   622E82E3           ORR      R2,R2,#0x620
   \   00000058   803083E0           ADD      R3,R3,R0, LSL #+1
   \   0000005C   B31082E1           STRH     R1,[R2, +R3]
    155            }
   \                     ??Init_2:
   \   00000060   010080E2           ADD      R0,R0,#+1
   \   00000064   EF0050E3           CMP      R0,#+239
   \   00000068   E5FFFF1A           BNE      ??Init_0
    156          }
   \   0000006C   1EFF2FE1           BX       LR               ;; return
   \                     ??Init_1:
   \   00000070   ........           DC32     randseed
   \   00000074   05840808           DC32     0x8088405
   \   00000078   81808080           DC32     0xffffffff80808081
   \   0000007C   ........           DC32     screen

   \                                 In segment DATA_Z, align 4, align-sorted
   \                     img:
   \   00000000                      DS8 12
    157          int clor=0;
   \                     clor:
   \   0000000C                      DS8 4

   \                                 In segment DATA_Z, align 4, align-sorted
   \                     timer:
   \   00000000                      DS8 16

   \                                 In segment CODE, align 4, keep-with-next
    158          void OnRedraw(MAIN_GUI *data)
    159          {  
   \                     OnRedraw:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   2CD04DE2           SUB      SP,SP,#+44
    160            Init();
   \   00000008   ........           _BLF     Init,??Init??rA
    161          int ypos=height-2;
    162            for(int x=0; x!=width; x++)
   \   0000000C   ........           LDR      R0,??DataTable5  ;; screen
   \   00000010   0010A0E3           MOV      R1,#+0
   \                     ??OnRedraw_0:
   \   00000014   DE20A0E3           MOV      R2,#+222
   \   00000018   402F82E3           ORR      R2,R2,#0x100
   \   0000001C   483BA0E3           MOV      R3,#+73728
   \   00000020   A23E83E3           ORR      R3,R3,#0xA20
   \   00000024   013083E0           ADD      R3,R3,R1
   \   00000028   833080E0           ADD      R3,R0,R3, LSL #+1
   \   0000002C   033082E0           ADD      R3,R2,R3
   \   00000030   4020A0E3           MOV      R2,#+64
   \   00000034   952B82E3           ORR      R2,R2,#0x25400
   \   00000038   814080E0           ADD      R4,R0,R1, LSL #+1
   \   0000003C   042082E0           ADD      R2,R2,R4
   \   00000040   F040D3E1           LDRSH    R4,[R3, #+0]
   \   00000044   F0C0D2E1           LDRSH    R12,[R2, #+0]
   \   00000048   04408CE0           ADD      R4,R12,R4
   \   0000004C   F2C0D3E1           LDRSH    R12,[R3, #+2]
   \   00000050   F430D3E1           LDRSH    R3,[R3, #+4]
   \   00000054   04408CE0           ADD      R4,R12,R4
   \   00000058   043083E0           ADD      R3,R3,R4
   \   0000005C   C340A0E1           ASR      R4,R3,#+1
   \   00000060   243F83E0           ADD      R3,R3,R4, LSR #+30
    163            {
    164                  clor=((GetPix(x-1,ypos+1)+GetPix(x,ypos)+GetPix(x,ypos+1)+GetPix(x+1,ypos+1))/4);
    165                  if (clor==GetPix(x,ypos)) clor=0;
   \   00000064   F040D2E1           LDRSH    R4,[R2, #+0]
   \   00000068   4331A0E1           ASR      R3,R3,#+2
   \   0000006C   040053E1           CMP      R3,R4
   \   00000070   0030A003           MOVEQ    R3,#+0
    166                  SetPix(x,ypos,clor);
   \   00000074   000051E3           CMP      R1,#+0
   \   00000078   0300004A           BMI      ??OnRedraw_1
   \   0000007C   F00051E3           CMP      R1,#+240
   \   00000080   010000AA           BGE      ??OnRedraw_1
   \   00000084   000053E3           CMP      R3,#+0
   \   00000088   B030C251           STRHPL   R3,[R2, #+0]
    167                }
   \                     ??OnRedraw_1:
   \   0000008C   011081E2           ADD      R1,R1,#+1
   \   00000090   F00051E3           CMP      R1,#+240
   \   00000094   DEFFFF1A           BNE      ??OnRedraw_0
    168            for(int y=height-3; y!=1; y--)
   \   00000098   3D10A0E3           MOV      R1,#+61
   \   0000009C   401F81E3           ORR      R1,R1,#0x100
    169                {
    170            for(int x=0; x!=width; x++)
   \                     ??OnRedraw_2:
   \   000000A0   0020A0E3           MOV      R2,#+0
   \                     ??OnRedraw_3:
   \   000000A4   F030A0E3           MOV      R3,#+240
   \   000000A8   932124E0           MLA      R4,R3,R1,R2
   \   000000AC   843080E0           ADD      R3,R0,R4, LSL #+1
   \   000000B0   F0E0D3E1           LDRSH    LR,[R3, #+0]
   \   000000B4   BE40A0E3           MOV      R4,#+190
   \   000000B8   C04F84E3           ORR      R4,R4,#0x300
   \   000000BC   03C084E0           ADD      R12,R4,R3
   \   000000C0   F040DCE1           LDRSH    R4,[R12, #+0]
   \   000000C4   04408EE0           ADD      R4,LR,R4
   \   000000C8   F2E0DCE1           LDRSH    LR,[R12, #+2]
   \   000000CC   F4C0DCE1           LDRSH    R12,[R12, #+4]
   \   000000D0   04408EE0           ADD      R4,LR,R4
   \   000000D4   04C08CE0           ADD      R12,R12,R4
   \   000000D8   CC40A0E1           ASR      R4,R12,#+1
   \   000000DC   244F8CE0           ADD      R4,R12,R4, LSR #+30
   \   000000E0   44C1A0E1           ASR      R12,R4,#+2
    171            {
    172               clor=((GetPix(x-1,y+2)+GetPix(x,y)+GetPix(x,y+2)+GetPix(x+1,y+2))/4);
    173                  if (clor==GetPix(x,y)) clor=0;
   \   000000E4   F040D3E1           LDRSH    R4,[R3, #+0]
   \   000000E8   04005CE1           CMP      R12,R4
   \   000000EC   0100000A           BEQ      ??OnRedraw_4
    174                  if (clor<0) clor=0;
   \   000000F0   00005CE3           CMP      R12,#+0
   \   000000F4   0000005A           BPL      ??OnRedraw_5
   \                     ??OnRedraw_4:
   \   000000F8   00C0A0E3           MOV      R12,#+0
   \                     ??OnRedraw_5:
   \   000000FC   ........           LDR      R4,??DataTable7  ;; img
    175                  SetPix(x,y,clor);
   \   00000100   000052E3           CMP      R2,#+0
   \   00000104   0CC084E5           STR      R12,[R4, #+12]
   \   00000108   0900004A           BMI      ??OnRedraw_6
   \   0000010C   F00052E3           CMP      R2,#+240
   \   00000110   070000AA           BGE      ??OnRedraw_6
   \   00000114   010051E3           CMP      R1,#+1
   \   00000118   050000BA           BLT      ??OnRedraw_6
   \   0000011C   41E0A0E3           MOV      LR,#+65
   \   00000120   40EF8EE3           ORR      LR,LR,#0x100
   \   00000124   0E0051E1           CMP      R1,LR
   \   00000128   010000AA           BGE      ??OnRedraw_6
   \   0000012C   00005CE3           CMP      R12,#+0
   \   00000130   B0C0C351           STRHPL   R12,[R3, #+0]
    176                }
   \                     ??OnRedraw_6:
   \   00000134   012082E2           ADD      R2,R2,#+1
   \   00000138   F00052E3           CMP      R2,#+240
   \   0000013C   D8FFFF1A           BNE      ??OnRedraw_3
    177            } 
   \   00000140   011041E2           SUB      R1,R1,#+1
   \   00000144   010051E3           CMP      R1,#+1
   \   00000148   D4FFFF1A           BNE      ??OnRedraw_2
    178            
    179            filtr ();
   \   0000014C   ........           BL       filtr
    180            
    181            
    182            RECT rc;
    183            DRWOBJ drwobj;
    184            StoreXYWHtoRECT(&rc,0,0,img.w,img.h);
   \   00000150   B200D4E1           LDRH     R0,[R4, #+2]
   \   00000154   0020A0E3           MOV      R2,#+0
   \   00000158   0010A0E3           MOV      R1,#+0
   \   0000015C   01002DE9           PUSH     {R0}
   \   00000160   B030D4E1           LDRH     R3,[R4, #+0]
   \   00000164   04008DE2           ADD      R0,SP,#+4
   \   00000168   330100EF           SWI      +307
    185            SetPropTo_Obj5(&drwobj,&rc,0,&img);
   \   0000016C   0430A0E1           MOV      R3,R4
   \   00000170   0020A0E3           MOV      R2,#+0
   \   00000174   04108DE2           ADD      R1,SP,#+4
   \   00000178   0C008DE2           ADD      R0,SP,#+12
   \   0000017C   510100EF           SWI      +337
    186            DrawObject(&drwobj);
   \   00000180   0C008DE2           ADD      R0,SP,#+12
   \   00000184   2A0100EF           SWI      +298
    187          }
   \   00000188   30D08DE2           ADD      SP,SP,#+48
   \   0000018C   1080BDE8           POP      {R4,PC}          ;; return

   \                                 In segment CODE, align 4, keep-with-next
    188          void onCreate(MAIN_GUI *data, void *(*malloc_adr)(int))
    189          {
   \                     onCreate:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    190            createpallet ();
   \   00000008   ........           BL       createpallet
    191          #ifdef ELKA
    192            DisableIconBar(1);
   \   0000000C   0100A0E3           MOV      R0,#+1
   \   00000010   3B0200EF           SWI      +571
    193          #endif
    194            Init();
   \   00000014   ........           _BLF     Init,??Init??rA
    195            data->gui.state=1;
   \   00000018   0100A0E3           MOV      R0,#+1
   \   0000001C   0C00C4E5           STRB     R0,[R4, #+12]
    196            img.bpnum=8;
   \   00000020   ........           LDR      R0,??DataTable7  ;; img
   \   00000024   0810A0E3           MOV      R1,#+8
   \   00000028   041080E5           STR      R1,[R0, #+4]
    197            img.w=width;
   \   0000002C   F010A0E3           MOV      R1,#+240
   \   00000030   B010C0E1           STRH     R1,[R0, #+0]
    198            img.h=height;
   \   00000034   501FA0E3           MOV      R1,#+320
   \   00000038   B210C0E1           STRH     R1,[R0, #+2]
    199            img.bitmap=(void*)screen2;
   \   0000003C   ........           LDR      R1,??DataTable8  ;; screen2
   \   00000040   081080E5           STR      R1,[R0, #+8]
    200            timer_proc();
   \   00000044   1040BDE8           POP      {R4,LR}          ;; Pop
   \   00000048   ........           B        timer_proc       ;; tailcall
    201          }

   \                                 In segment CODE, align 4, keep-with-next
    202          void onClose(MAIN_GUI *data, void (*mfree_adr)(void *))
    203          {
   \                     onClose:
   \   00000000   00402DE9           PUSH     {LR}
    204            data->gui.state=0;
   \   00000004   0010A0E3           MOV      R1,#+0
   \   00000008   0C10C0E5           STRB     R1,[R0, #+12]
    205            GBS_StopTimer(&timer);
   \   0000000C   ........           LDR      R0,??DataTable9  ;; timer
   \   00000010   440100EF           SWI      +324
    206          }
   \   00000014   0080BDE8           POP      {PC}             ;; return

   \                                 In segment CODE, align 4, keep-with-next
    207          void onFocus(MAIN_GUI *data, void *(*malloc_adr)(int), void (*mfree_adr)(void *))
    208          {
   \                     onFocus:
   \   00000000   00402DE9           PUSH     {LR}
    209            data->gui.state=2;
   \   00000004   0210A0E3           MOV      R1,#+2
   \   00000008   0C10C0E5           STRB     R1,[R0, #+12]
    210            DisableIDLETMR();
   \   0000000C   7F0100EF           SWI      +383
    211          }
   \   00000010   0080BDE8           POP      {PC}             ;; return

   \                                 In segment CODE, align 4, keep-with-next
    212          void onUnfocus(MAIN_GUI *data, void (*mfree_adr)(void *))
    213          {
    214            if (data->gui.state!=2) return;
   \                     onUnfocus:
   \   00000000   0C10D0E5           LDRB     R1,[R0, #+12]
   \   00000004   020051E3           CMP      R1,#+2
    215            data->gui.state=1;
   \   00000008   0110A003           MOVEQ    R1,#+1
   \   0000000C   0C10C005           STRBEQ   R1,[R0, #+12]
    216          }
   \   00000010   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
    217          int OnKey(MAIN_GUI *data, GUI_MSG *msg)
    218          {
    219            if (msg->gbsmsg->msg==KEY_DOWN)
   \                     OnKey:
   \   00000000   040091E5           LDR      R0,[R1, #+4]
   \   00000004   9320A0E3           MOV      R2,#+147
   \   00000008   041090E5           LDR      R1,[R0, #+4]
   \   0000000C   402F82E3           ORR      R2,R2,#0x100
   \   00000010   020051E1           CMP      R1,R2
   \   00000014   0F00001A           BNE      ??OnKey_0
    220            {
    221              switch(msg->gbsmsg->submess)
   \   00000018   40109FE5           LDR      R1,??OnKey_1     ;; maxx
   \   0000001C   080090E5           LDR      R0,[R0, #+8]
   \   00000020   002091E5           LDR      R2,[R1, #+0]
   \   00000024   040050E2           SUBS     R0,R0,#+4
   \   00000028   0400000A           BEQ      ??OnKey_2
   \   0000002C   2E0050E2           SUBS     R0,R0,#+46
   \   00000030   0400000A           BEQ      ??OnKey_3
   \   00000034   060050E2           SUBS     R0,R0,#+6
   \   00000038   0400000A           BEQ      ??OnKey_4
   \   0000003C   050000EA           B        ??OnKey_0
    222              {
    223              case  RIGHT_SOFT : return(1);
   \                     ??OnKey_2:
   \   00000040   0100A0E3           MOV      R0,#+1
   \   00000044   1EFF2FE1           BX       LR
    224              case '2':maxx+=10;break;
   \                     ??OnKey_3:
   \   00000048   0A0082E2           ADD      R0,R2,#+10
   \   0000004C   000000EA           B        ??OnKey_5
    225              case '8':maxx-=10;break;
   \                     ??OnKey_4:
   \   00000050   0A0042E2           SUB      R0,R2,#+10
   \                     ??OnKey_5:
   \   00000054   000081E5           STR      R0,[R1, #+0]
    226              }
    227            }
    228            return(0);
   \                     ??OnKey_0:
   \   00000058   0000A0E3           MOV      R0,#+0
   \   0000005C   1EFF2FE1           BX       LR               ;; return
   \                     ??OnKey_1:
   \   00000060   ........           DC32     maxx
    229          }
    230          extern void kill_data(void *p, void (*func_p)(void *));

   \                                 In segment CODE, align 4, keep-with-next
    231          void onDestroy(MAIN_GUI *data, void (*mfree_adr)(void *))
    232          {
    233          kill_data(data,mfree_adr);
   \                     onDestroy:
   \   00000000   ........           _BF      kill_data,??kill_data??rA  ;; tailcall
    234          }
    235          

   \                                 In segment CODE, align 4, keep-with-next
    236          int method8(void){return(0);}
   \                     method8:
   \   00000000   0000A0E3           MOV      R0,#+0
   \   00000004   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
    237          int method9(void){return(0);}
   \                     method9:
   \   00000000   0000A0E3           MOV      R0,#+0
   \   00000004   1EFF2FE1           BX       LR               ;; return

   \                                 In segment DATA_C, align 4, align-sorted
    238          const void * const gui_methods[11]={
   \                     gui_methods:
   \   00000000   ............       DC32 OnRedraw, onCreate, onClose, onFocus, onUnfocus, OnKey, 0H
   \              ............
   \              ............
   \              ............
   \              00000000    
   \   0000001C   ............       DC32 onDestroy, method8, method9, 0H
   \              ............
   \              00000000    
    239            (void *)OnRedraw,	
    240            (void *)onCreate,	
    241            (void *)onClose,	
    242            (void *)onFocus,	
    243            (void *)onUnfocus,
    244            (void *)OnKey,	
    245            0,
    246            #ifdef NEWSGOLD
    247            (void *)onDestroy,
    248            #else
    249            (void *)kill_data,	
    250            #endif
    251            (void *)method8,
    252            (void *)method9,
    253            0
    254          };
    255          
    256          const RECT Canvas={0,0,width-1,height-1};
   \                     Canvas:
   \   0000002C   00000000EF00       DC16 0, 0, 239, 319
   \              3F01        

   \                                 In segment CODE, align 4, keep-with-next
    257          void maincsm_oncreate(CSM_RAM *data)
    258          {
   \                     maincsm_oncreate:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    259            MAIN_GUI *main_gui=malloc(sizeof(MAIN_GUI));
   \   00000008   4000A0E3           MOV      R0,#+64
   \   0000000C   140000EF           SWI      +20
   \   00000010   0050A0E1           MOV      R5,R0
    260            MAIN_CSM*csm=(MAIN_CSM*)data;
    261            zeromem(main_gui,sizeof(MAIN_GUI));
   \   00000014   4010A0E3           MOV      R1,#+64
   \   00000018   1D0100EF           SWI      +285
    262            main_gui->gui.canvas=(void *)(&Canvas);
   \   0000001C   40009FE5           LDR      R0,??maincsm_oncreate_0  ;; gui_methods
   \   00000020   2C1080E2           ADD      R1,R0,#+44
   \   00000024   001085E5           STR      R1,[R5, #+0]
    263            main_gui->gui.flag30=2;
   \   00000028   0210A0E3           MOV      R1,#+2
   \   0000002C   301085E5           STR      R1,[R5, #+48]
    264            main_gui->gui.methods=(void *)gui_methods;
   \   00000030   040085E5           STR      R0,[R5, #+4]
    265            main_gui->gui.item_ll.data_mfree=(void (*)(void *))mfree_adr();
   \   00000034   158000EF           SWI      +32789
   \   00000038   200085E5           STR      R0,[R5, #+32]
    266            csm->csm.state=0;
   \   0000003C   0000A0E3           MOV      R0,#+0
   \   00000040   100084E5           STR      R0,[R4, #+16]
    267            csm->csm.unk1=0;
   \   00000044   140084E5           STR      R0,[R4, #+20]
    268            csm->gui_id=CreateGUI(main_gui);
   \   00000048   0500A0E1           MOV      R0,R5
   \   0000004C   370100EF           SWI      +311
   \   00000050   280084E5           STR      R0,[R4, #+40]
    269            MAINGUI_ID=csm->gui_id;
   \   00000054   0C009FE5           LDR      R0,??maincsm_oncreate_0+0x4  ;; MAINGUI_ID
   \   00000058   281094E5           LDR      R1,[R4, #+40]
   \   0000005C   001080E5           STR      R1,[R0, #+0]
    270          }
   \   00000060   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??maincsm_oncreate_0:
   \   00000064   ........           DC32     gui_methods
   \   00000068   ........           DC32     MAINGUI_ID
    271          

   \                                 In segment CODE, align 4, keep-with-next
    272          void ElfKiller(void)
    273          {
   \                     ElfKiller:
   \   00000000   00402DE9           PUSH     {LR}
    274            extern void kill_data(void *p, void (*func_p)(void *));
    275            extern void *ELF_BEGIN;
    276            kill_data(&ELF_BEGIN,(void (*)(void *))mfree_adr());
   \   00000004   158000EF           SWI      +32789
   \   00000008   0010A0E1           MOV      R1,R0
   \   0000000C   04009FE5           LDR      R0,??ElfKiller_0  ;; ELF_BEGIN
   \   00000010   0040BDE8           POP      {LR}             ;; Pop
   \   00000014   ........           _BF      kill_data,??kill_data??rA  ;; tailcall
   \                     ??ElfKiller_0:
   \   00000018   ........           DC32     ELF_BEGIN
    277          }

   \                                 In segment CODE, align 4, keep-with-next
    278          void maincsm_onclose(CSM_RAM *csm)
    279          {
    280            SUBPROC((void *)ElfKiller);
   \                     maincsm_onclose:
   \   00000000   08009FE5           LDR      R0,??maincsm_onclose_0  ;; ElfKiller
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   710100EF           SWI      +369
    281          }
   \   0000000C   0080BDE8           POP      {PC}             ;; return
   \                     ??maincsm_onclose_0:
   \   00000010   ........           DC32     ElfKiller

   \                                 In segment CODE, align 4, keep-with-next
    282          int maincsm_onmessage(CSM_RAM *data, GBS_MSG *msg)
    283          {
    284            MAIN_CSM *csm=(MAIN_CSM*)data;
    285            if ((msg->msg==MSG_GUI_DESTROYED)&&((int)msg->data0==csm->gui_id))
   \                     maincsm_onmessage:
   \   00000000   042091E5           LDR      R2,[R1, #+4]
   \   00000004   0E30A0E3           MOV      R3,#+14
   \   00000008   643C83E3           ORR      R3,R3,#0x6400
   \   0000000C   030052E1           CMP      R2,R3
   \   00000010   0400001A           BNE      ??maincsm_onmessage_0
   \   00000014   0C1091E5           LDR      R1,[R1, #+12]
   \   00000018   282090E5           LDR      R2,[R0, #+40]
   \   0000001C   020051E1           CMP      R1,R2
    286            {
    287              csm->csm.state=-3;
   \   00000020   0210E003           MVNEQ    R1,#+2
   \   00000024   10108005           STREQ    R1,[R0, #+16]
    288            }
    289            return(1);
   \                     ??maincsm_onmessage_0:
   \   00000028   0100A0E3           MOV      R0,#+1
   \   0000002C   1EFF2FE1           BX       LR               ;; return
    290          }
    291          const struct
    292          {
    293            CSM_DESC maincsm;
    294            WSHDR maincsm_name;

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "Flame">`:
   \   00000000   466C616D6500       DC8 "Flame"
   \   00000006   0000               DC8 0, 0
    295          }MAINCSM =
   \                     MAINCSM:
   \   00000008   ............       DC32 maincsm_onmessage, maincsm_oncreate, 0, 0, 0, 0, maincsm_onclose
   \              ....00000000
   \              000000000000
   \              000000000000
   \              ........    
   \   00000024   2C0000000100       DC32 44, 1, minus11, maincsm_name_body, 55AACCCCH, 3333AA55H, 0
   \              0000........
   \              ........CCCC
   \              AA5555AA3333
   \              00000000    
   \   00000040   8B00               DC16 139
   \   00000042   0000               DC8 0, 0
    296          {
    297            {
    298            maincsm_onmessage,
    299            maincsm_oncreate,
    300          #ifdef NEWSGOLD
    301            0,
    302            0,
    303            0,
    304            0,
    305          #endif
    306            maincsm_onclose,
    307            sizeof(MAIN_CSM),
    308            1,
    309            &minus11
    310            },
    311            {
    312              maincsm_name_body,
    313              NAMECSM_MAGIC1,
    314              NAMECSM_MAGIC2,
    315              0x0,
    316              139
    317            }
    318          };

   \                                 In segment CODE, align 4, keep-with-next
    319          void UpdateCSMname(void)
    320          {
   \                     UpdateCSMname:
   \   00000000   10402DE9           PUSH     {R4,LR}
    321            WSHDR *ws=AllocWS(256);
   \   00000004   400FA0E3           MOV      R0,#+256
   \   00000008   250100EF           SWI      +293
   \   0000000C   0040A0E1           MOV      R4,R0
    322            wsprintf((WSHDR *)(&MAINCSM.maincsm_name),"Flame");
   \   00000010   14009FE5           LDR      R0,??UpdateCSMname_0  ;; `?<Constant "Flame">`
   \   00000014   0010A0E1           MOV      R1,R0
   \   00000018   300080E2           ADD      R0,R0,#+48
   \   0000001C   240100EF           SWI      +292
    323            FreeWS(ws);
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   290100EF           SWI      +297
    324          }
   \   00000028   1080BDE8           POP      {R4,PC}          ;; return
   \                     ??UpdateCSMname_0:
   \   0000002C   ........           DC32     `?<Constant "Flame">`

   \                                 In segment CODE, align 4, keep-with-next
    325          int main(char *exename, char *fname)
    326          {
    327            
    328          
    329            
    330            
    331            char dummy[sizeof(MAIN_CSM)];
    332            MAINCSM_ID = CreateCSM(&MAINCSM.maincsm,dummy,0);
   \                     main:
   \   00000000   2C009FE5           LDR      R0,??main_0      ;; `?<Constant "Flame">` + 8
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   2CD04DE2           SUB      SP,SP,#+44
   \   0000000C   0020A0E3           MOV      R2,#+0
   \   00000010   0D10A0E1           MOV      R1,SP
   \   00000014   070100EF           SWI      +263
   \   00000018   18109FE5           LDR      R1,??main_0+0x4  ;; MAINCSM_ID
   \   0000001C   000081E5           STR      R0,[R1, #+0]
    333            UpdateCSMname();
   \   00000020   ........           BL       UpdateCSMname
    334            Randomize();
   \   00000024   ........           BL       Randomize
    335            return 0;
   \   00000028   0000A0E3           MOV      R0,#+0
   \   0000002C   2CD08DE2           ADD      SP,SP,#+44
   \   00000030   0080BDE8           POP      {PC}             ;; return
   \                     ??main_0:
   \   00000034   ........           DC32     `?<Constant "Flame">` + 8
   \   00000038   ........           DC32     MAINCSM_ID
    336          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   ........           DC32     randseed

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     screen

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   ........           DC32     img

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   ........           DC32     screen2

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   ........           DC32     timer

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for maxx>`:
   \   00000000   C8000000           DC32 200

   Maximum stack usage in bytes:

     Function          CSTACK
     --------          ------
     ElfKiller             4
     Init                  0
     OnKey                 0
     OnRedraw             56
     Randomize            20
     UpdateCSMname         8
     createpallet         12
     filtr                 0
     main                 48
     maincsm_onclose       4
     maincsm_oncreate     12
     maincsm_onmessage     0
     method8               0
     method9               0
     onClose               4
     onCreate              8
     onDestroy             4
     onFocus               4
     onUnfocus             0
     randint               4
     rgb2bitmap16          0
     timer_proc            4


   Segment part sizes:

     Function/Label          Bytes
     --------------          -----
     minus11                      4
     maincsm_name_body          280
     MAINCSM_ID                   4
     MAINGUI_ID                   4
     maxx                         4
     screen                  153600
     screen2                 153600
     Rc                        1040
     rgb2bitmap16                24
     createpallet               264
     filtr                       60
     randseed                     4
     randint                     36
     Randomize                   44
     timer_proc                  32
     Init                       128
     img                         16
     timer                       16
     OnRedraw                   400
     onCreate                    76
     onClose                     24
     onFocus                     20
     onUnfocus                   20
     OnKey                      100
     onDestroy                    4
     method8                      8
     method9                      8
     gui_methods                 52
     maincsm_oncreate           108
     ElfKiller                   28
     maincsm_onclose             20
     maincsm_onmessage           48
     ?<Constant "Flame">         68
     UpdateCSMname               48
     main                        60
     ??DataTable3                 4
     ??DataTable5                 4
     ??DataTable7                 4
     ??DataTable8                 4
     ??DataTable9                 4
     ?<Initializer for maxx>      4
      Others                    144

 
   1 700 bytes in segment CODE
     124 bytes in segment DATA_C
       4 bytes in segment DATA_I
       4 bytes in segment DATA_ID
 308 564 bytes in segment DATA_Z
      24 bytes in segment INITTAB
 
   1 452 bytes of CODE  memory (+ 272 bytes shared)
     128 bytes of CONST memory
 308 568 bytes of DATA  memory

Errors: none
Warnings: none
