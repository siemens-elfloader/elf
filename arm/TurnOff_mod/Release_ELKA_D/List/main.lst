##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    16/Mar/2011  01:13:34 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\TurnOff_mod\main.c                            #
#    Command line    =  C:\arm\TurnOff_mod\main.c -D NEWSGOLD -D ELKA -D     #
#                       DAEMON -lC C:\arm\TurnOff_mod\Release_ELKA_D\List\   #
#                       -o C:\arm\TurnOff_mod\Release_ELKA_D\Obj\ -s9        #
#                       --no_unroll --cpu_mode arm --endian little --cpu     #
#                       ARM926EJ-S --stack_align 4 --interwork -e --fpu      #
#                       None --dlib_config "C:\arm2\Embedded Workbench 4.0   #
#                       Evaluation\ARM\LIB\dl5tpainl8n.h" -I                 #
#                       "C:\arm2\Embedded Workbench 4.0                      #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  C:\arm\TurnOff_mod\Release_ELKA_D\List\main.lst      #
#    Object file     =  C:\arm\TurnOff_mod\Release_ELKA_D\Obj\main.r79       #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\TurnOff_mod\main.c
      1          #include "..\inc\swilib.h"
      2          #include "..\inc\cfg_items.h"
      3          #include "conf_loader.h"
      4          
      5          #ifdef DAEMON
      6          typedef struct
      7          {
      8            CSM_RAM csm;
      9          }MAIN_CSM;
     10          #endif
     11          
     12          extern void kill_data(void *p, void (*func_p)(void *));
     13          

   \                                 In segment DATA_C, align 4, align-sorted
     14          const int minus11=-11;
   \                     minus11:
   \   00000000   F5FFFFFF           DC32 -11
     15          int MAINCSM_ID=0;
     16          
     17          
     18          extern const char ICONS_SD[128];
     19          extern const char ICONS_RB[128];
     20          extern const char ICONS_SR[128];
     21          
     22          extern const int SND_ENA;
     23          extern const unsigned int VOLUME;
     24          extern const char SND_SD[128];
     25          extern const char SND_RB[128];
     26          extern const char SND_SR[128];
     27          
     28          extern const unsigned int CLOSE_BTN;
     29          extern const int MODE;
     30          
     31          extern const int WHAT_DO;
     32          extern const unsigned int PROFILE;
     33          
     34          #ifdef DAEMON
     35          extern const unsigned int CALL_BTN;
     36          #endif
     37          int mode;
     38          //  0 - ждущий режим
     39          //  1 - выключение
     40          //  2 - перезагрузка
     41          
     42          typedef struct
     43          {
     44            CSM_RAM csm;
     45            int gui_id;
     46          }MAIN_CSM_GUI;
     47          
     48          typedef struct
     49          {
     50            GUI gui;
     51            WSHDR *ws1;
     52            WSHDR *ws2;
     53            int i1;
     54          }MAIN_GUI;
     55          
     56          //int PLAY_ID;

   \                                 In segment CODE, align 4, keep-with-next
     57          void Play(const char *fname)
     58          {
   \                     Play:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   D0D04DE2           SUB      SP,SP,#+208
   \   00000008   0060A0E1           MOV      R6,R0
     59            if ((!IsCalling())&&SND_ENA)
   \   0000000C   6E0000EF           SWI      +110
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   4100001A           BNE      ??Play_0
   \   00000018   ........           LDR      R0,??DataTable5  ;; SND_ENA
   \   0000001C   000090E5           LDR      R0,[R0, #+0]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   3D00000A           BEQ      ??Play_0
     60            {
     61              FSTATS fstats;
     62              unsigned int err;
     63              if (GetFileStats(fname,&fstats,&err)!=-1)
   \   00000028   0D20A0E1           MOV      R2,SP
   \   0000002C   A8108DE2           ADD      R1,SP,#+168
   \   00000030   0600A0E1           MOV      R0,R6
   \   00000034   840000EF           SWI      +132
   \   00000038   010070E3           CMN      R0,#+1
   \   0000003C   3700000A           BEQ      ??Play_0
     64              {
     65                PLAYFILE_OPT _sfo1;
     66                WSHDR* sndPath=AllocWS(128);
   \   00000040   8000A0E3           MOV      R0,#+128
   \   00000044   250100EF           SWI      +293
   \   00000048   0040A0E1           MOV      R4,R0
     67                WSHDR* sndFName=AllocWS(128);
   \   0000004C   8000A0E3           MOV      R0,#+128
   \   00000050   250100EF           SWI      +293
   \   00000054   0050A0E1           MOV      R5,R0
     68                char s[128];
     69                const char *p=strrchr(fname,'\\')+1;
   \   00000058   5C10A0E3           MOV      R1,#+92
   \   0000005C   0600A0E1           MOV      R0,R6
   \   00000060   170100EF           SWI      +279
   \   00000064   017080E2           ADD      R7,R0,#+1
     70                str_2ws(sndFName,p,128);
   \   00000068   8020A0E3           MOV      R2,#+128
   \   0000006C   0710A0E1           MOV      R1,R7
   \   00000070   0500A0E1           MOV      R0,R5
   \   00000074   6C0100EF           SWI      +364
     71                strncpy(s,fname,p-fname);
   \   00000078   067047E0           SUB      R7,R7,R6
   \   0000007C   0720A0E1           MOV      R2,R7
   \   00000080   0610A0E1           MOV      R1,R6
   \   00000084   28008DE2           ADD      R0,SP,#+40
   \   00000088   160100EF           SWI      +278
     72                s[p-fname]='\0';
   \   0000008C   0060A0E3           MOV      R6,#+0
   \   00000090   28008DE2           ADD      R0,SP,#+40
   \   00000094   0060C7E7           STRB     R6,[R7, +R0]
     73                str_2ws(sndPath,s,128);
   \   00000098   8020A0E3           MOV      R2,#+128
   \   0000009C   28108DE2           ADD      R1,SP,#+40
   \   000000A0   0400A0E1           MOV      R0,R4
   \   000000A4   6C0100EF           SWI      +364
     74                
     75                zeromem(&_sfo1,sizeof(PLAYFILE_OPT));
   \   000000A8   2410A0E3           MOV      R1,#+36
   \   000000AC   04008DE2           ADD      R0,SP,#+4
   \   000000B0   1D0100EF           SWI      +285
     76                _sfo1.repeat_num=1;
     77                _sfo1.time_between_play=0;
     78                _sfo1.play_first=0;
     79                _sfo1.volume=VOLUME;
   \   000000B4   6C209FE5           LDR      R2,??Play_1      ;; VOLUME
   \   000000B8   0100A0E3           MOV      R0,#+1
   \   000000BC   B400CDE1           STRH     R0,[SP, #+4]
   \   000000C0   08608DE5           STR      R6,[SP, #+8]
   \   000000C4   0C608DE5           STR      R6,[SP, #+12]
   \   000000C8   002092E5           LDR      R2,[R2, #+0]
     80          #ifdef NEWSGOLD
     81                _sfo1.unk6=1;
     82                _sfo1.unk7=1;
     83                _sfo1.unk9=2;
   \   000000CC   0210A0E3           MOV      R1,#+2
   \   000000D0   10208DE5           STR      R2,[SP, #+16]
   \   000000D4   18008DE5           STR      R0,[SP, #+24]
   \   000000D8   1C008DE5           STR      R0,[SP, #+28]
   \   000000DC   24108DE5           STR      R1,[SP, #+36]
     84                /*PLAY_ID=*/PlayFile(0x10, sndPath, sndFName, MMI_CEPID, MSG_PLAYFILE_REPORT, &_sfo1);
   \   000000E0   04008DE2           ADD      R0,SP,#+4
   \   000000E4   01002DE9           PUSH     {R0}
   \   000000E8   0930A0E3           MOV      R3,#+9
   \   000000EC   423C83E3           ORR      R3,R3,#0x4200
   \   000000F0   0520A0E1           MOV      R2,R5
   \   000000F4   BC00A0E3           MOV      R0,#+188
   \   000000F8   700C80E3           ORR      R0,R0,#0x7000
   \   000000FC   01002DE9           PUSH     {R0}
   \   00000100   0410A0E1           MOV      R1,R4
   \   00000104   1000A0E3           MOV      R0,#+16
   \   00000108   4A0000EF           SWI      +74
     85          #else
     86          #ifdef X75
     87                _sfo1.unk4=0x80000000;
     88                _sfo1.unk5=1;
     89                /*PLAY_ID=*/PlayFile(0xC, sndPath, sndFName, 0,MMI_CEPID, MSG_PLAYFILE_REPORT, &_sfo1);
     90          #else
     91                _sfo1.unk5=1;
     92                /*PLAY_ID=*/PlayFile(0xC, sndPath, sndFName, MMI_CEPID, MSG_PLAYFILE_REPORT, &_sfo1);
     93          #endif
     94          #endif
     95                FreeWS(sndPath);
   \   0000010C   0400A0E1           MOV      R0,R4
   \   00000110   290100EF           SWI      +297
     96                FreeWS(sndFName);
   \   00000114   0500A0E1           MOV      R0,R5
   \   00000118   290100EF           SWI      +297
   \   0000011C   08D08DE2           ADD      SP,SP,#+8
     97              }
     98            }
     99          }
   \                     ??Play_0:
   \   00000120   D0D08DE2           ADD      SP,SP,#+208      ;; stack cleaning
   \   00000124   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??Play_1:
   \   00000128   ........           DC32     VOLUME
    100          IMGHDR screen={0,0,8,""};
    101          
    102          

   \                                 In segment CODE, align 4, keep-with-next
    103          void DrwImg(IMGHDR *img, int x, int y, char *pen, char *brush)
    104          {
   \                     DrwImg:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   2CD04DE2           SUB      SP,SP,#+44
   \   00000008   3C609DE5           LDR      R6,[SP, #+60]
   \   0000000C   0040A0E1           MOV      R4,R0
    105            RECT rc;
    106            DRWOBJ drwobj;
    107            StoreXYWHtoRECT(&rc,x,y,img->w,img->h);
   \   00000010   B200D4E1           LDRH     R0,[R4, #+2]
   \   00000014   0350A0E1           MOV      R5,R3
   \   00000018   01002DE9           PUSH     {R0}
   \   0000001C   B030D4E1           LDRH     R3,[R4, #+0]
   \   00000020   04008DE2           ADD      R0,SP,#+4
   \   00000024   330100EF           SWI      +307
    108            SetPropTo_Obj5(&drwobj,&rc,0,img);
   \   00000028   0430A0E1           MOV      R3,R4
   \   0000002C   0020A0E3           MOV      R2,#+0
   \   00000030   04108DE2           ADD      R1,SP,#+4
   \   00000034   0C008DE2           ADD      R0,SP,#+12
   \   00000038   510100EF           SWI      +337
    109            SetColor(&drwobj,pen,brush);
   \   0000003C   0620A0E1           MOV      R2,R6
   \   00000040   0510A0E1           MOV      R1,R5
   \   00000044   0C008DE2           ADD      R0,SP,#+12
   \   00000048   4B0100EF           SWI      +331
    110            DrawObject(&drwobj);
   \   0000004C   0C008DE2           ADD      R0,SP,#+12
   \   00000050   2A0100EF           SWI      +298
    111          }
   \   00000054   30D08DE2           ADD      SP,SP,#+48
   \   00000058   7080BDE8           POP      {R4-R6,PC}       ;; return
    112          

   \                                 In segment CODE, align 4, keep-with-next
    113          void DoScreen()
    114          {
   \                     DoScreen:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
    115              int ScrH=ScreenH();
    116              int ScrW=ScreenW();
    117              char *ms=RamScreenBuffer();
    118              screen.w=ScrW;
   \   00000004   ........           LDR      R7,??DataTable2  ;; screen
   \   00000008   898100EF           SWI      +33161
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   888100EF           SWI      +33160
   \   00000014   0050A0E1           MOV      R5,R0
   \   00000018   E08000EF           SWI      +32992
   \   0000001C   0060A0E1           MOV      R6,R0
    119              screen.h=ScrH;
    120              screen.bitmap=malloc(ScrW*ScrH*2);
   \   00000020   940500E0           MUL      R0,R4,R5
   \   00000024   B050C7E1           STRH     R5,[R7, #+0]
   \   00000028   B240C7E1           STRH     R4,[R7, #+2]
   \   0000002C   8040A0E1           LSL      R4,R0,#+1
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   140000EF           SWI      +20
   \   00000038   080087E5           STR      R0,[R7, #+8]
    121              memcpy(screen.bitmap, ms, ScrW*ScrH*2);
   \   0000003C   0420A0E1           MOV      R2,R4
   \   00000040   0610A0E1           MOV      R1,R6
   \   00000044   1E0100EF           SWI      +286
    122          }
   \   00000048   F080BDE8           POP      {R4-R7,PC}       ;; return

   \                                 In segment CODE, align 4, keep-with-next
    123          void method0(MAIN_GUI *data)
    124          {
   \                     method0:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
    125           /* DrawRoundedFrame(0,0, ScreenW()-1, ScreenH()-1, 0, 0, 0,
    126          			GetPaletteAdrByColorIndex(23),
    127          			GetPaletteAdrByColorIndex(23));
    128            */
    129             int x, y;
    130             DrwImg(&screen, 0, 0, NULL, NULL);
   \   00000008   ........           LDR      R4,??DataTable2  ;; screen
   \   0000000C   0000A0E3           MOV      R0,#+0
   \   00000010   01002DE9           PUSH     {R0}
   \   00000014   0030A0E3           MOV      R3,#+0
   \   00000018   0020A0E1           MOV      R2,R0
   \   0000001C   0010A0E1           MOV      R1,R0
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           BL       DrwImg
    131             switch(mode)
   \   00000028   100094E5           LDR      R0,[R4, #+16]
   \   0000002C   04D08DE2           ADD      SP,SP,#+4
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0400000A           BEQ      ??method0_0
   \   00000038   010050E2           SUBS     R0,R0,#+1
   \   0000003C   0400000A           BEQ      ??method0_1
   \   00000040   010050E2           SUBS     R0,R0,#+1
   \   00000044   1800000A           BEQ      ??method0_2
   \   00000048   7780BDE8           POP      {R0-R2,R4-R6,PC}
    132              {
    133              case 0:
    134                {
    135                  x= ScreenW()/2 - GetImgWidth((int)ICONS_SR)/2;
   \                     ??method0_0:
   \   0000004C   60509FE5           LDR      R5,??method0_3   ;; ICONS_SR
   \   00000050   000000EA           B        ??method0_4
    136                  y = (ScreenH()-YDISP)/2 - GetImgHeight((int)ICONS_SR)/2;
    137                  DrawImg(x, y, (int)ICONS_SR);
    138                }
    139                break;
    140              case 1:
    141                {
    142                  x= ScreenW()/2 - GetImgWidth((int)ICONS_SD)/2;
   \                     ??method0_1:
   \   00000054   5C509FE5           LDR      R5,??method0_3+0x4  ;; ICONS_SD
   \                     ??method0_4:
   \   00000058   888100EF           SWI      +33160
   \   0000005C   0040A0E1           MOV      R4,R0
   \   00000060   0500A0E1           MOV      R0,R5
   \   00000064   220000EF           SWI      +34
   \   00000068   A41F84E0           ADD      R1,R4,R4, LSR #+31
   \   0000006C   C110A0E1           ASR      R1,R1,#+1
   \   00000070   A00F80E0           ADD      R0,R0,R0, LSR #+31
   \   00000074   C04041E0           SUB      R4,R1,R0, ASR #+1
    143                  y = (ScreenH()-YDISP)/2 - GetImgHeight((int)ICONS_SD)/2;
   \   00000078   898100EF           SWI      +33161
   \   0000007C   0060A0E1           MOV      R6,R0
   \   00000080   0500A0E1           MOV      R0,R5
   \   00000084   210000EF           SWI      +33
   \   00000088   181046E2           SUB      R1,R6,#+24
   \   0000008C   A11F81E0           ADD      R1,R1,R1, LSR #+31
   \   00000090   C110A0E1           ASR      R1,R1,#+1
   \   00000094   A00F80E0           ADD      R0,R0,R0, LSR #+31
   \   00000098   C01041E0           SUB      R1,R1,R0, ASR #+1
    144                  DrawImg(x, y, (int)ICONS_SD);
   \   0000009C   0520A0E1           MOV      R2,R5
   \   000000A0   0400A0E1           MOV      R0,R4
   \   000000A4   230000EF           SWI      +35
   \   000000A8   7780BDE8           POP      {R0-R2,R4-R6,PC}
    145                }
    146                break;
    147              case 2:
    148                {
    149                  x= ScreenW()/2 - GetImgWidth((int)ICONS_RB)/2;
   \                     ??method0_2:
   \   000000AC   08509FE5           LDR      R5,??method0_3+0x8  ;; ICONS_RB
   \   000000B0   E8FFFFEA           B        ??method0_4
   \                     ??method0_3:
   \   000000B4   ........           DC32     ICONS_SR
   \   000000B8   ........           DC32     ICONS_SD
   \   000000BC   ........           DC32     ICONS_RB
    150                  y = (ScreenH()-YDISP)/2 - GetImgHeight((int)ICONS_RB)/2;
    151                  DrawImg(x, y, (int)ICONS_RB);
    152                }
    153                break;
    154              }  
    155          }
    156          

   \                                 In segment CODE, align 4, keep-with-next
    157          void method1(MAIN_GUI *data, void *(*malloc_adr)(int))
    158          {
   \                     method1:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    159          #ifdef ELKA
    160            DisableIconBar(1);
   \   00000008   0100A0E3           MOV      R0,#+1
   \   0000000C   3B0200EF           SWI      +571
    161          #endif
    162            data->ws1=AllocWS(256);
   \   00000010   400FA0E3           MOV      R0,#+256
   \   00000014   250100EF           SWI      +293
   \   00000018   340084E5           STR      R0,[R4, #+52]
    163            data->ws2=AllocWS(256);
   \   0000001C   400FA0E3           MOV      R0,#+256
   \   00000020   250100EF           SWI      +293
   \   00000024   380084E5           STR      R0,[R4, #+56]
    164            data->gui.state=1;
   \   00000028   0100A0E3           MOV      R0,#+1
   \   0000002C   0C00C4E5           STRB     R0,[R4, #+12]
    165          }
   \   00000030   1080BDE8           POP      {R4,PC}          ;; return
    166          

   \                                 In segment CODE, align 4, keep-with-next
    167          void method2(MAIN_GUI *data, void (*mfree_adr)(void *))
    168          {
   \                     method2:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    169          #ifdef ELKA
    170            DisableIconBar(0);
   \   00000008   0000A0E3           MOV      R0,#+0
   \   0000000C   3B0200EF           SWI      +571
    171          #endif
    172            mfree(screen.bitmap);
   \   00000010   20009FE5           LDR      R0,??method2_0   ;; screen + 8
   \   00000014   000090E5           LDR      R0,[R0, #+0]
   \   00000018   150000EF           SWI      +21
    173            FreeWS(data->ws1);
   \   0000001C   340094E5           LDR      R0,[R4, #+52]
   \   00000020   290100EF           SWI      +297
    174            FreeWS(data->ws2);
   \   00000024   380094E5           LDR      R0,[R4, #+56]
   \   00000028   290100EF           SWI      +297
    175            data->gui.state=0;
   \   0000002C   0000A0E3           MOV      R0,#+0
   \   00000030   0C00C4E5           STRB     R0,[R4, #+12]
    176          }
   \   00000034   1080BDE8           POP      {R4,PC}          ;; return
   \                     ??method2_0:
   \   00000038   ........           DC32     screen + 8
    177          

   \                                 In segment CODE, align 4, keep-with-next
    178          void method3(MAIN_GUI *data, void *(*malloc_adr)(int), void (*mfree_adr)(void *))
    179          {
    180            data->gui.state=2;
   \                     method3:
   \   00000000   0210A0E3           MOV      R1,#+2
   \   00000004   0C10C0E5           STRB     R1,[R0, #+12]
    181          }
   \   00000008   1EFF2FE1           BX       LR               ;; return
    182          

   \                                 In segment CODE, align 4, keep-with-next
    183          void method4(MAIN_GUI *data, void (*mfree_adr)(void *))
    184          {
    185            if (data->gui.state!=2) return;
   \                     method4:
   \   00000000   0C10D0E5           LDRB     R1,[R0, #+12]
   \   00000004   020051E3           CMP      R1,#+2
    186            data->gui.state=1;
   \   00000008   0110A003           MOVEQ    R1,#+1
   \   0000000C   0C10C005           STRBEQ   R1,[R0, #+12]
    187          }
   \   00000010   1EFF2FE1           BX       LR               ;; return
    188          

   \                                 In segment CODE, align 4, keep-with-next
    189          void DoIt(void)
    190          {
   \                     DoIt:
   \   00000000   10402DE9           PUSH     {R4,LR}
    191            switch(mode)
   \   00000004   ........           LDR      R4,??DataTable4  ;; screen
   \   00000008   100094E5           LDR      R0,[R4, #+16]
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0400000A           BEQ      ??DoIt_0
   \   00000014   010050E2           SUBS     R0,R0,#+1
   \   00000018   0E00000A           BEQ      ??DoIt_1
   \   0000001C   010050E2           SUBS     R0,R0,#+1
   \   00000020   0E00000A           BEQ      ??DoIt_2
   \   00000024   0E0000EA           B        ??DoIt_3
    192              {
    193                case 0:
    194                  if (WHAT_DO) KbdLock();
   \                     ??DoIt_0:
   \   00000028   48009FE5           LDR      R0,??DoIt_4      ;; WHAT_DO
   \   0000002C   000090E5           LDR      R0,[R0, #+0]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0100000A           BEQ      ??DoIt_5
   \   00000038   A90000EF           SWI      +169
   \   0000003C   080000EA           B        ??DoIt_3
    195                    else
    196                      SetProfile(PROFILE-1);
   \                     ??DoIt_5:
   \   00000040   34009FE5           LDR      R0,??DoIt_4+0x4  ;; PROFILE
   \   00000044   000090E5           LDR      R0,[R0, #+0]
   \   00000048   010040E2           SUB      R0,R0,#+1
   \   0000004C   FF0000E2           AND      R0,R0,#0xFF
   \   00000050   B70000EF           SWI      +183
   \   00000054   020000EA           B        ??DoIt_3
    197                break;
    198                case 1:
    199                  SwitchPhoneOff();
   \                     ??DoIt_1:
   \   00000058   090000EF           SWI      +9
   \   0000005C   000000EA           B        ??DoIt_3
    200                break;
    201                case 2:
    202                  RebootPhone();
   \                     ??DoIt_2:
   \   00000060   930000EF           SWI      +147
    203                break;
    204               }
    205            CloseCSM(MAINCSM_ID);
   \                     ??DoIt_3:
   \   00000064   0C0094E5           LDR      R0,[R4, #+12]
   \   00000068   FC0100EF           SWI      +508
    206            MAINCSM_ID=0;
   \   0000006C   0000A0E3           MOV      R0,#+0
   \   00000070   0C0084E5           STR      R0,[R4, #+12]
    207          }
   \   00000074   1080BDE8           POP      {R4,PC}          ;; return
   \                     ??DoIt_4:
   \   00000078   ........           DC32     WHAT_DO
   \   0000007C   ........           DC32     PROFILE
    208          

   \                                 In segment CODE, align 4, keep-with-next
    209          double GetWavkaLength(const char *fname) //тиков
    210          {
   \                     GetWavkaLength:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
    211            int f;
    212            unsigned int ul;
    213            
    214            int DataLength;//4
    215            int BytePerSec;//28  
    216            
    217          
    218            if ((f=fopen(fname,A_ReadOnly+A_BIN,P_READ,&ul))!=-1)
   \   00000008   0D30A0E1           MOV      R3,SP
   \   0000000C   8020A0E3           MOV      R2,#+128
   \   00000010   801CA0E3           MOV      R1,#+32768
   \   00000014   0A0000EF           SWI      +10
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   010074E3           CMN      R4,#+1
   \   00000020   3200000A           BEQ      ??GetWavkaLength_0
    219            {
    220              lseek(f,4,S_SET,&ul,&ul);
   \   00000024   0D00A0E1           MOV      R0,SP
   \   00000028   01002DE9           PUSH     {R0}
   \   0000002C   04308DE2           ADD      R3,SP,#+4
   \   00000030   0020A0E3           MOV      R2,#+0
   \   00000034   0410A0E3           MOV      R1,#+4
   \   00000038   0400A0E1           MOV      R0,R4
   \   0000003C   0F0000EF           SWI      +15
    221              fread(f,&DataLength,sizeof(DataLength),&ul);
   \   00000040   04308DE2           ADD      R3,SP,#+4
   \   00000044   0420A0E3           MOV      R2,#+4
   \   00000048   08108DE2           ADD      R1,SP,#+8
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   0B0000EF           SWI      +11
    222              
    223              lseek(f,28,S_SET,&ul,&ul);
   \   00000054   04008DE2           ADD      R0,SP,#+4
   \   00000058   01002DE9           PUSH     {R0}
   \   0000005C   08308DE2           ADD      R3,SP,#+8
   \   00000060   0020A0E3           MOV      R2,#+0
   \   00000064   1C10A0E3           MOV      R1,#+28
   \   00000068   0400A0E1           MOV      R0,R4
   \   0000006C   0F0000EF           SWI      +15
    224              fread(f,&BytePerSec,sizeof(BytePerSec),&ul);
   \   00000070   08308DE2           ADD      R3,SP,#+8
   \   00000074   0420A0E3           MOV      R2,#+4
   \   00000078   10108DE2           ADD      R1,SP,#+16
   \   0000007C   0400A0E1           MOV      R0,R4
   \   00000080   0B0000EF           SWI      +11
    225              
    226              fclose(f,&ul);
   \   00000084   08108DE2           ADD      R1,SP,#+8
   \   00000088   0400A0E1           MOV      R0,R4
   \   0000008C   0D0000EF           SWI      +13
    227              
    228              return (((((double)DataLength/(double)BytePerSec)*(double)1000)*0.216)+50);
   \   00000090   0C009DE5           LDR      R0,[SP, #+12]
   \   00000094   ........           _BLF     __longToDouble,??__longToDouble??rA
   \   00000098   0040A0E1           MOV      R4,R0
   \   0000009C   10009DE5           LDR      R0,[SP, #+16]
   \   000000A0   0150A0E1           MOV      R5,R1
   \   000000A4   ........           _BLF     __longToDouble,??__longToDouble??rA
   \   000000A8   0020A0E1           MOV      R2,R0
   \   000000AC   0130A0E1           MOV      R3,R1
   \   000000B0   0400A0E1           MOV      R0,R4
   \   000000B4   0510A0E1           MOV      R1,R5
   \   000000B8   ........           _BLF     __dDiv,??__dDiv??rA
   \   000000BC   3C309FE5           LDR      R3,??GetWavkaLength_1  ;; 0x408f4000
   \   000000C0   0020A0E3           MOV      R2,#+0
   \   000000C4   ........           _BLF     __dMul,??__dMul??rA
   \   000000C8   34309FE5           LDR      R3,??GetWavkaLength_1+0x4  ;; 0x3fcba5e3
   \   000000CC   34209FE5           LDR      R2,??GetWavkaLength_1+0x8  ;; 0x53f7ced9
   \   000000D0   ........           _BLF     __dMul,??__dMul??rA
   \   000000D4   0020A0E3           MOV      R2,#+0
   \   000000D8   4034A0E3           MOV      R3,#+1073741824
   \   000000DC   493883E3           ORR      R3,R3,#0x490000
   \   000000E0   ........           _BLF     __dAdd,??__dAdd??rA
   \   000000E4   08D08DE2           ADD      SP,SP,#+8
   \   000000E8   0CD08DE2           ADD      SP,SP,#+12
   \   000000EC   3080BDE8           POP      {R4,R5,PC}
    229            }
    230              else
    231                return 0;
   \                     ??GetWavkaLength_0:
   \   000000F0   0000A0E3           MOV      R0,#+0
   \   000000F4   0010A0E3           MOV      R1,#+0
   \   000000F8   0CD08DE2           ADD      SP,SP,#+12
   \   000000FC   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??GetWavkaLength_1:
   \   00000100   00408F40           DC32     0x408f4000
   \   00000104   E3A5CB3F           DC32     0x3fcba5e3
   \   00000108   D9CEF753           DC32     0x53f7ced9
    232          }

   \                                 In segment DATA_I, align 4, align-sorted
   \                     screen:
   \   00000000                      DS8 12
   \   0000000C                      REQUIRE `?<Initializer for screen>`
   \                     MAINCSM_ID:
   \   0000000C                      DS8 4
   \   00000010                      REQUIRE `?<Initializer for MAINCSM_ID>`
   \                     mode:
   \   00000010                      DS8 4
   \   00000014                      REQUIRE `?<Initializer for mode>`
    233          
    234          GBSTMR mytmr;
   \                     mytmr:
   \   00000014                      DS8 16
   \   00000024                      REQUIRE `?<Initializer for mytmr>`
    235          

   \                                 In segment CODE, align 4, keep-with-next
    236          int method5(MAIN_GUI *data, GUI_MSG *msg)
    237          {
   \                     method5:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    238            DirectRedrawGUI();
   \   00000008   3F0100EF           SWI      +319
    239          
    240            if (msg->gbsmsg->msg==KEY_DOWN)
   \   0000000C   040095E5           LDR      R0,[R5, #+4]
   \   00000010   9320A0E3           MOV      R2,#+147
   \   00000014   041090E5           LDR      R1,[R0, #+4]
   \   00000018   402F82E3           ORR      R2,R2,#0x100
   \   0000001C   020051E1           CMP      R1,R2
   \   00000020   3F00001A           BNE      ??method5_0
    241            {
    242              if (msg->gbsmsg->submess==CLOSE_BTN)
   \   00000024   00119FE5           LDR      R1,??method5_1   ;; CLOSE_BTN
   \   00000028   080090E5           LDR      R0,[R0, #+8]
   \   0000002C   001091E5           LDR      R1,[R1, #+0]
   \   00000030   ........           LDR      R4,??DataTable4  ;; screen
   \   00000034   0060A0E3           MOV      R6,#+0
   \   00000038   010050E1           CMP      R0,R1
   \   0000003C   0200001A           BNE      ??method5_2
    243              {
    244                  CloseCSM(MAINCSM_ID); //Происходит вызов GeneralFunc для тек. GUI -> закрытие GUI
   \   00000040   0C0094E5           LDR      R0,[R4, #+12]
   \   00000044   FC0100EF           SWI      +508
    245                  MAINCSM_ID=0;
   \   00000048   0C6084E5           STR      R6,[R4, #+12]
    246              }
    247            
    248              switch(msg->gbsmsg->submess)
   \                     ??method5_2:
   \   0000004C   041095E5           LDR      R1,[R5, #+4]
   \   00000050   100094E5           LDR      R0,[R4, #+16]
   \   00000054   081091E5           LDR      R1,[R1, #+8]
   \   00000058   1A1051E2           SUBS     R1,R1,#+26
   \   0000005C   1400000A           BEQ      ??method5_3
   \   00000060   211051E2           SUBS     R1,R1,#+33
   \   00000064   0400000A           BEQ      ??method5_4
   \   00000068   011041E2           SUB      R1,R1,#+1
   \   0000006C   010051E3           CMP      R1,#+1
   \   00000070   0700009A           BLS      ??method5_5
   \   00000074   021051E2           SUBS     R1,R1,#+2
   \   00000078   2900001A           BNE      ??method5_0
    249              {
    250              case RIGHT_BUTTON:
    251              case UP_BUTTON: 
    252                {
    253                  mode++;
   \                     ??method5_4:
   \   0000007C   010080E2           ADD      R0,R0,#+1
   \   00000080   100084E5           STR      R0,[R4, #+16]
    254                  if (mode==3) mode=0;
   \   00000084   030050E3           CMP      R0,#+3
   \   00000088   2500001A           BNE      ??method5_0
   \   0000008C   106084E5           STR      R6,[R4, #+16]
   \   00000090   050000EA           B        ??method5_6
    255                }
    256                break;
    257              case LEFT_BUTTON:
    258              case DOWN_BUTTON:
    259                  mode--;
   \                     ??method5_5:
   \   00000094   010040E2           SUB      R0,R0,#+1
   \   00000098   100084E5           STR      R0,[R4, #+16]
    260                  if (mode==-1) mode=2;
   \   0000009C   010070E3           CMN      R0,#+1
   \   000000A0   1F00001A           BNE      ??method5_0
   \   000000A4   0200A0E3           MOV      R0,#+2
   \   000000A8   100084E5           STR      R0,[R4, #+16]
   \                     ??method5_6:
   \   000000AC   0000A0E3           MOV      R0,#+0
   \   000000B0   7080BDE8           POP      {R4-R6,PC}
    261                break;
    262               case ENTER_BUTTON:
    263                 switch(mode)
   \                     ??method5_3:
   \   000000B4   74509FE5           LDR      R5,??method5_1+0x4  ;; DoIt
   \   000000B8   000050E3           CMP      R0,#+0
   \   000000BC   0400000A           BEQ      ??method5_7
   \   000000C0   010050E2           SUBS     R0,R0,#+1
   \   000000C4   0400000A           BEQ      ??method5_8
   \   000000C8   010050E2           SUBS     R0,R0,#+1
   \   000000CC   0400000A           BEQ      ??method5_9
   \   000000D0   F5FFFFEA           B        ??method5_6
    264                  {
    265                    case 0:
    266                      Play(SND_SR);
   \                     ??method5_7:
   \   000000D4   58609FE5           LDR      R6,??method5_1+0x8  ;; SND_SR
   \   000000D8   020000EA           B        ??method5_10
    267                      if (SND_ENA) GBS_StartTimerProc(&mytmr,(int)GetWavkaLength(SND_SR),DoIt); else DoIt();
    268                    break;
    269                    case 1:
    270                      Play(SND_SD);
   \                     ??method5_8:
   \   000000DC   54609FE5           LDR      R6,??method5_1+0xC  ;; SND_SD
   \   000000E0   000000EA           B        ??method5_10
    271                      if (SND_ENA) GBS_StartTimerProc(&mytmr,(int)GetWavkaLength(SND_SD),DoIt); else DoIt();
    272                    break;
    273                    case 2:
    274                      Play(SND_RB);
   \                     ??method5_9:
   \   000000E4   50609FE5           LDR      R6,??method5_1+0x10  ;; SND_RB
   \                     ??method5_10:
   \   000000E8   0600A0E1           MOV      R0,R6
   \   000000EC   ........           BL       Play
    275                      if (SND_ENA) GBS_StartTimerProc(&mytmr,(int)GetWavkaLength(SND_RB),DoIt); else DoIt();
   \   000000F0   ........           LDR      R0,??DataTable5  ;; SND_ENA
   \   000000F4   000090E5           LDR      R0,[R0, #+0]
   \   000000F8   000050E3           CMP      R0,#+0
   \   000000FC   0700000A           BEQ      ??method5_11
   \   00000100   0600A0E1           MOV      R0,R6
   \   00000104   ........           BL       GetWavkaLength
   \   00000108   ........           _BLF     __doubleToLong,??__doubleToLong??rA
   \   0000010C   0010A0E1           MOV      R1,R0
   \   00000110   0520A0E1           MOV      R2,R5
   \   00000114   140084E2           ADD      R0,R4,#+20
   \   00000118   4D0000EF           SWI      +77
   \   0000011C   E2FFFFEA           B        ??method5_6
   \                     ??method5_11:
   \   00000120   ........           BL       DoIt
    276                    break;
    277                  }
    278                break;     
    279              }
    280            }
    281          
    282            return(0);
   \                     ??method5_0:
   \   00000124   0000A0E3           MOV      R0,#+0
   \   00000128   7080BDE8           POP      {R4-R6,PC}       ;; return
   \                     ??method5_1:
   \   0000012C   ........           DC32     CLOSE_BTN
   \   00000130   ........           DC32     DoIt
   \   00000134   ........           DC32     SND_SR
   \   00000138   ........           DC32     SND_SD
   \   0000013C   ........           DC32     SND_RB
    283          }
    284          

   \                                 In segment CODE, align 4, keep-with-next
    285          void method7(MAIN_GUI *data, void (*mfree_adr)(void *))
    286          {
    287            kill_data(data, mfree_adr);
   \                     method7:
   \   00000000   ........           _BF      kill_data,??kill_data??rA  ;; tailcall
    288          }
    289          

   \                                 In segment CODE, align 4, keep-with-next
    290          int method8(void){return(0);}
   \                     method8:
   \   00000000   0000A0E3           MOV      R0,#+0
   \   00000004   1EFF2FE1           BX       LR               ;; return
    291          

   \                                 In segment CODE, align 4, keep-with-next
    292          int method9(void){return(0);}
   \                     method9:
   \   00000000   0000A0E3           MOV      R0,#+0
   \   00000004   1EFF2FE1           BX       LR               ;; return
    293          

   \                                 In segment DATA_C, align 4, align-sorted
    294          const void * const gui_methods[11]={
    295            (void *)method0,	//Redraw
    296            (void *)method1,	//Create
    297            (void *)method2,	//Close
    298            (void *)method3,	//Focus
    299            (void *)method4,	//Unfocus
    300            (void *)method5,	//OnKey
    301            0,
    302            (void *)method7,	//Destroy
    303            (void *)method8,
    304            (void *)method9,
    305            0
    306          };
    307          
    308          const RECT Canvas={0, 0, 0, 0};
   \                     Canvas:
   \   00000000   000000000000       DC16 0, 0, 0, 0
   \              0000        
   \                     gui_methods:
   \   00000008   ............       DC32 method0, method1, method2, method3, method4, method5, 0H, method7
   \              ............
   \              ............
   \              ............
   \              00000000....
   \              ....        
   \   00000028   ............       DC32 method8, method9, 0H
   \              ....00000000
    309          
    310          #pragma inline
    311          void patch_rect(RECT*rc,int x,int y, int x2, int y2)
    312          {
    313            rc->x=x;
    314            rc->y=y;
    315            rc->x2=x2;
    316            rc->y2=y2;
    317          }
    318          

   \                                 In segment CODE, align 4, keep-with-next
    319          void maincsm_oncreate_GUI(CSM_RAM *data)
    320          {
   \                     maincsm_oncreate_GUI:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    321            DoScreen();
   \   00000008   ........           BL       DoScreen
    322            MAIN_GUI *main_gui=malloc(sizeof(MAIN_GUI));
   \   0000000C   4000A0E3           MOV      R0,#+64
   \   00000010   140000EF           SWI      +20
   \   00000014   0050A0E1           MOV      R5,R0
    323            MAIN_CSM_GUI*csm=(MAIN_CSM_GUI*)data;
    324            zeromem(main_gui,sizeof(MAIN_GUI));
   \   00000018   4010A0E3           MOV      R1,#+64
   \   0000001C   1D0100EF           SWI      +285
    325            patch_rect((RECT*)&Canvas,0,YDISP,ScreenW()-1,ScreenH()-1);
   \   00000020   898100EF           SWI      +33161
   \   00000024   0060A0E1           MOV      R6,R0
   \   00000028   888100EF           SWI      +33160
   \   0000002C   48209FE5           LDR      R2,??maincsm_oncreate_GUI_0  ;; Canvas
   \   00000030   011046E2           SUB      R1,R6,#+1
   \   00000034   010040E2           SUB      R0,R0,#+1
   \   00000038   0060A0E3           MOV      R6,#+0
   \   0000003C   B060C2E1           STRH     R6,[R2, #+0]
   \   00000040   1830A0E3           MOV      R3,#+24
   \   00000044   B230C2E1           STRH     R3,[R2, #+2]
   \   00000048   B400C2E1           STRH     R0,[R2, #+4]
   \   0000004C   B610C2E1           STRH     R1,[R2, #+6]
    326            main_gui->gui.canvas=(void *)(&Canvas);
   \   00000050   002085E5           STR      R2,[R5, #+0]
    327            //main_gui->gui.flag30=2;
    328            main_gui->gui.methods=(void *)gui_methods;
   \   00000054   080082E2           ADD      R0,R2,#+8
   \   00000058   040085E5           STR      R0,[R5, #+4]
    329            main_gui->gui.item_ll.data_mfree=(void (*)(void *))mfree_adr();
   \   0000005C   158000EF           SWI      +32789
   \   00000060   200085E5           STR      R0,[R5, #+32]
    330            csm->csm.state=0;
   \   00000064   106084E5           STR      R6,[R4, #+16]
    331            csm->csm.unk1=0;
   \   00000068   146084E5           STR      R6,[R4, #+20]
    332            csm->gui_id=CreateGUI(main_gui);
   \   0000006C   0500A0E1           MOV      R0,R5
   \   00000070   370100EF           SWI      +311
   \   00000074   280084E5           STR      R0,[R4, #+40]
    333          }
   \   00000078   7080BDE8           POP      {R4-R6,PC}       ;; return
   \                     ??maincsm_oncreate_GUI_0:
   \   0000007C   ........           DC32     Canvas
    334          
    335          #ifndef DAEMON
    336          static void ELF_KILLER(void)
    337          {
    338            extern void *ELF_BEGIN;
    339            kill_data(&ELF_BEGIN,(void (*)(void *))mfree_adr());
    340          }
    341          #endif

   \                                 In segment CODE, align 4, keep-with-next
    342          void maincsm_onclose_GUI(CSM_RAM *csm)
    343          {
    344          #ifndef DAEMON
    345            SUBPROC((void *)ELF_KILLER);
    346          #endif
    347          }
   \                     maincsm_onclose_GUI:
   \   00000000   1EFF2FE1           BX       LR               ;; return
    348          

   \                                 In segment CODE, align 4, keep-with-next
    349          int maincsm_onmessage_GUI(CSM_RAM *data, GBS_MSG *msg)
    350          {
    351            MAIN_CSM_GUI *csm=(MAIN_CSM_GUI*)data;
    352            if ((msg->msg==MSG_GUI_DESTROYED)&&((int)msg->data0==csm->gui_id))
   \                     maincsm_onmessage_GUI:
   \   00000000   042091E5           LDR      R2,[R1, #+4]
   \   00000004   0E30A0E3           MOV      R3,#+14
   \   00000008   643C83E3           ORR      R3,R3,#0x6400
   \   0000000C   030052E1           CMP      R2,R3
   \   00000010   0400001A           BNE      ??maincsm_onmessage_GUI_0
   \   00000014   0C1091E5           LDR      R1,[R1, #+12]
   \   00000018   282090E5           LDR      R2,[R0, #+40]
   \   0000001C   020051E1           CMP      R1,R2
    353            {
    354              csm->csm.state=-3;
   \   00000020   0210E003           MVNEQ    R1,#+2
   \   00000024   10108005           STREQ    R1,[R0, #+16]
    355            } 
    356            
    357            return(1);
   \                     ??maincsm_onmessage_GUI_0:
   \   00000028   0100A0E3           MOV      R0,#+1
   \   0000002C   1EFF2FE1           BX       LR               ;; return
    358          }
    359          
    360          unsigned short maincsm_name_body[140];
    361          
    362          const struct
    363          {
    364            CSM_DESC maincsm;
    365            WSHDR maincsm_name_GUI;

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "TurnOff">`:
   \   00000000   5475726E4F66       DC8 "TurnOff"
   \              6600        
    366          }MAINCSM =
   \                     MAINCSM:
   \   00000008   ............       DC32 maincsm_onmessage_GUI, maincsm_oncreate_GUI, 0, 0, 0, 0
   \              ....00000000
   \              000000000000
   \              000000000000
   \   00000020   ........2C00       DC32 maincsm_onclose_GUI, 44, 1, minus11, maincsm_name_body, 55AACCCCH
   \              000001000000
   \              ............
   \              ....CCCCAA55
   \   00000038   55AA33330000       DC32 3333AA55H, 0
   \              0000        
   \   00000040   8B00               DC16 139
   \   00000042   0000               DC8 0, 0
    367          {
    368            {
    369              maincsm_onmessage_GUI,
    370              maincsm_oncreate_GUI,
    371          #ifdef NEWSGOLD
    372          0,
    373          0,
    374          0,
    375          0,
    376          #endif
    377          maincsm_onclose_GUI,
    378          sizeof(MAIN_CSM_GUI),
    379          1,
    380          &minus11
    381            },
    382            {
    383              maincsm_name_body,
    384              NAMECSM_MAGIC1,
    385              NAMECSM_MAGIC2,
    386              0x0,
    387              139
    388            }
    389          };
    390          
    391          #ifdef DAEMON

   \                                 In segment CODE, align 4, keep-with-next
    392          void Check()
    393          {
   \                     Check:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   2CD04DE2           SUB      SP,SP,#+44
    394            LockSched();
   \   00000008   460100EF           SWI      +326
    395            char dummy[sizeof(MAIN_CSM_GUI)];
    396            MAINCSM_ID=CreateCSM(&MAINCSM.maincsm,dummy,2);
   \   0000000C   1C009FE5           LDR      R0,??Check_0     ;; `?<Constant "TurnOff">` + 8
   \   00000010   0220A0E3           MOV      R2,#+2
   \   00000014   0D10A0E1           MOV      R1,SP
   \   00000018   070100EF           SWI      +263
   \   0000001C   ........           LDR      R1,??DataTable7  ;; screen + 12
   \   00000020   000081E5           STR      R0,[R1, #+0]
    397            UnlockSched();
   \   00000024   470100EF           SWI      +327
    398          }
   \   00000028   2CD08DE2           ADD      SP,SP,#+44
   \   0000002C   0080BDE8           POP      {PC}             ;; return
   \                     ??Check_0:
   \   00000030   ........           DC32     `?<Constant "TurnOff">` + 8
    399          
    400          #pragma inline=forced
    401          int toupper(int c)
    402          {
    403            if ((c>='a')&&(c<='z')) c+='A'-'a';
    404            return(c);
    405          }
    406          #pragma inline
    407          int strcmp_nocase(const char *s1,const char *s2)
    408          {
    409            int i;
    410            int c;
    411            while(!(i=(c=toupper(*s1++))-toupper(*s2++))) if (!c) break;
    412            return(i);
    413          }
    414          

   \                                 In segment CODE, align 4, keep-with-next
    415          int maincsm_onmessage(CSM_RAM* data,GBS_MSG* msg)
    416          {
   \                     maincsm_onmessage:
   \   00000000   00402DE9           PUSH     {LR}
    417            if(msg->msg == MSG_RECONFIGURE_REQ) // Перечитывание конфига по сообщению
   \   00000004   040091E5           LDR      R0,[R1, #+4]
   \   00000008   AF20A0E3           MOV      R2,#+175
   \   0000000C   DE2C82E3           ORR      R2,R2,#0xDE00
   \   00000010   020050E1           CMP      R0,R2
   \   00000014   1600001A           BNE      ??maincsm_onmessage_0
    418            {
    419              extern const char *successed_config_filename;
    420              if (strcmp_nocase(successed_config_filename,(char *)msg->data0)==0)
   \   00000018   0C0091E5           LDR      R0,[R1, #+12]
   \   0000001C   58109FE5           LDR      R1,??maincsm_onmessage_1  ;; successed_config_filename
   \   00000020   001091E5           LDR      R1,[R1, #+0]
   \                     ??maincsm_onmessage_2:
   \   00000024   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000028   610052E3           CMP      R2,#+97
   \   0000002C   010000BA           BLT      ??maincsm_onmessage_3
   \   00000030   7B0052E3           CMP      R2,#+123
   \   00000034   202042B2           SUBLT    R2,R2,#+32
   \                     ??maincsm_onmessage_3:
   \   00000038   0030D0E5           LDRB     R3,[R0, #+0]
   \   0000003C   011081E2           ADD      R1,R1,#+1
   \   00000040   610053E3           CMP      R3,#+97
   \   00000044   010000BA           BLT      ??maincsm_onmessage_4
   \   00000048   7B0053E3           CMP      R3,#+123
   \   0000004C   203043B2           SUBLT    R3,R3,#+32
   \                     ??maincsm_onmessage_4:
   \   00000050   010080E2           ADD      R0,R0,#+1
   \   00000054   033052E0           SUBS     R3,R2,R3
   \   00000058   0500001A           BNE      ??maincsm_onmessage_0
   \   0000005C   000052E3           CMP      R2,#+0
   \   00000060   EFFFFF1A           BNE      ??maincsm_onmessage_2
    421              {
    422                InitConfig();
   \   00000064   ........           _BLF     InitConfig,??InitConfig??rA
    423                ShowMSG(1,(int)"TurnOff config updated!");
   \   00000068   10109FE5           LDR      R1,??maincsm_onmessage_1+0x4  ;; `?<Constant "TurnOff config updated!">`
   \   0000006C   0100A0E3           MOV      R0,#+1
   \   00000070   480100EF           SWI      +328
    424              }
    425            }
    426          
    427            /*if (msg->msg==MSG_PLAYFILE_REPORT)
    428              {
    429                //DoIt();
    430                ShowMSG(1, (int)PLAY_ID);
    431                if ((msg->submess>>16)==PLAY_ID) 
    432                { 
    433                  if (((msg->submess&0xFFFF)==7)||((msg->submess&0xFFFF)==5)) DoIt();
    434                }
    435                  else
    436                    PLAY_ID=0;
    437              }  */
    438            
    439            return(1);
   \                     ??maincsm_onmessage_0:
   \   00000074   0100A0E3           MOV      R0,#+1
   \   00000078   0080BDE8           POP      {PC}             ;; return
   \                     ??maincsm_onmessage_1:
   \   0000007C   ........           DC32     successed_config_filename
   \   00000080   ........           DC32     `?<Constant "TurnOff config updated!">`
    440          }  
    441          

   \                                 In segment CODE, align 4, keep-with-next
    442          int my_keyhook(int key, int m)
    443          {
   \                     my_keyhook:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    444            extern const int MODE_KBD;
    445            void *icsm=FindCSMbyID(CSM_root()->idle_id);
   \   0000000C   068100EF           SWI      +33030
   \   00000010   040090E5           LDR      R0,[R0, #+4]
   \   00000014   080100EF           SWI      +264
    446            if ((IsGuiOnTop(((int *)icsm)[DISPLACE_OF_IDLEGUI_ID/4]))&&IsUnlocked()&&(m==MODE_KBD+0x193))
   \   00000018   2C0090E5           LDR      R0,[R0, #+44]
   \   0000001C   350100EF           SWI      +309
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   3080BD08           POPEQ    {R4,R5,PC}
   \   00000028   430000EF           SWI      +67
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   3080BD08           POPEQ    {R4,R5,PC}
   \   00000034   40009FE5           LDR      R0,??my_keyhook_0  ;; MODE_KBD
   \   00000038   9310A0E3           MOV      R1,#+147
   \   0000003C   000090E5           LDR      R0,[R0, #+0]
   \   00000040   401F81E3           ORR      R1,R1,#0x100
   \   00000044   000081E0           ADD      R0,R1,R0
   \   00000048   000055E1           CMP      R5,R0
   \   0000004C   0800001A           BNE      ??my_keyhook_1
    447               if (key==CALL_BTN) 
   \   00000050   28009FE5           LDR      R0,??my_keyhook_0+0x4  ;; CALL_BTN
   \   00000054   000090E5           LDR      R0,[R0, #+0]
   \   00000058   000054E1           CMP      R4,R0
   \   0000005C   0400001A           BNE      ??my_keyhook_1
    448                 {
    449                   mode=MODE;
   \   00000060   1C109FE5           LDR      R1,??my_keyhook_0+0x8  ;; MODE
   \   00000064   1C009FE5           LDR      R0,??my_keyhook_0+0xC  ;; screen + 16
   \   00000068   001091E5           LDR      R1,[R1, #+0]
   \   0000006C   001080E5           STR      R1,[R0, #+0]
    450                   Check();
   \   00000070   ........           BL       Check
    451                 }
    452            
    453            return 0;
   \                     ??my_keyhook_1:
   \   00000074   0000A0E3           MOV      R0,#+0
   \   00000078   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??my_keyhook_0:
   \   0000007C   ........           DC32     MODE_KBD
   \   00000080   ........           DC32     CALL_BTN
   \   00000084   ........           DC32     MODE
   \   00000088   ........           DC32     screen + 16
    454          }
    455          

   \                                 In segment CODE, align 4, keep-with-next
    456          static void maincsm_oncreate(CSM_RAM *data)
    457          {
    458          
    459          }
   \                     maincsm_oncreate:
   \   00000000   1EFF2FE1           BX       LR               ;; return
    460          

   \                                 In segment CODE, align 4, keep-with-next
    461          static void Killer(void)
    462          {
   \                     Killer:
   \   00000000   ........           LDR      R0,??DataTable7  ;; screen + 12
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0000000A           BEQ      ??Killer_0
    463            extern void *ELF_BEGIN;
    464            if (MAINCSM_ID) CloseCSM(MAINCSM_ID);
   \   00000014   FC0100EF           SWI      +508
    465            RemoveKeybMsgHook((void *)my_keyhook);  
   \                     ??Killer_0:
   \   00000018   ........           LDR      R0,??DataTable9  ;; my_keyhook
   \   0000001C   2D0100EF           SWI      +301
    466            kill_data(&ELF_BEGIN,(void (*)(void *))mfree_adr());
   \   00000020   158000EF           SWI      +32789
   \   00000024   0010A0E1           MOV      R1,R0
   \   00000028   04009FE5           LDR      R0,??Killer_1    ;; ELF_BEGIN
   \   0000002C   0040BDE8           POP      {LR}             ;; Pop
   \   00000030   ........           _BF      kill_data,??kill_data??rA  ;; tailcall
   \                     ??Killer_1:
   \   00000034   ........           DC32     ELF_BEGIN
    467          }
    468          

   \                                 In segment CODE, align 4, keep-with-next
    469          static void maincsm_onclose(CSM_RAM *csm)
    470          {
    471            SUBPROC((void *)Killer);
   \                     maincsm_onclose:
   \   00000000   08009FE5           LDR      R0,??maincsm_onclose_0  ;; Killer
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   710100EF           SWI      +369
    472          }
   \   0000000C   0080BDE8           POP      {PC}             ;; return
   \                     ??maincsm_onclose_0:
   \   00000010   ........           DC32     Killer
    473          

   \                                 In segment DATA_Z, align 4, align-sorted
    474          static unsigned short maincsm_name_body[140];
   \                     maincsm_name_body:
   \   00000000                      DS8 280
    475          
    476          static const struct
    477          {
    478            CSM_DESC maincsm;
    479            WSHDR maincsm_name;

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "TurnOff_d">`:
   \   00000000   5475726E4F66       DC8 "TurnOff_d"
   \              665F6400    
   \   0000000A   0000               DC8 0, 0
   \   0000000C   ............       DC32 maincsm_onmessage, maincsm_oncreate, 0, 0, 0, 0, maincsm_onclose
   \              ....00000000
   \              000000000000
   \              000000000000
   \              ........    
   \   00000028   280000000100       DC32 40, 1, minus11, maincsm_name_body, 55AACCCCH, 3333AA55H, 0
   \              0000........
   \              ........CCCC
   \              AA5555AA3333
   \              00000000    
   \   00000044   8B00               DC16 139
   \   00000046   0000               DC8 0, 0
    480          }MAINCSM_d =
    481          {
    482            {
    483            maincsm_onmessage,
    484            maincsm_oncreate,
    485          #ifdef NEWSGOLD
    486            0,
    487            0,
    488            0,
    489            0,
    490          #endif
    491            maincsm_onclose,
    492            sizeof(MAIN_CSM),
    493            1,
    494            &minus11
    495            },
    496            {
    497              maincsm_name_body,
    498              NAMECSM_MAGIC1,
    499              NAMECSM_MAGIC2,
    500              0x0,
    501              139
    502            }
    503          };
    504          
    505          static void UpdateCSMname(void)
    506          {
    507            wsprintf((WSHDR *)(&MAINCSM_d.maincsm_name),"TurnOff_d");
    508          }
    509          #endif
    510          

   \                                 In segment CODE, align 4, keep-with-next
    511          void UpdateCSMname_GUI(void)
    512          {
    513            wsprintf((WSHDR *)(&MAINCSM.maincsm_name_GUI),"TurnOff");
   \                     UpdateCSMname_GUI:
   \   00000000   10009FE5           LDR      R0,??UpdateCSMname_GUI_0  ;; `?<Constant "TurnOff">`
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   0010A0E1           MOV      R1,R0
   \   0000000C   300080E2           ADD      R0,R0,#+48
   \   00000010   240100EF           SWI      +292
    514          }
   \   00000014   0080BDE8           POP      {PC}             ;; return
   \                     ??UpdateCSMname_GUI_0:
   \   00000018   ........           DC32     `?<Constant "TurnOff">`
    515          

   \                                 In segment CODE, align 4, keep-with-next
    516          int main()
    517          {
   \                     main:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
    518            LockSched();
    519            InitConfig();  
    520            
    521          #ifdef DAEMON
    522            CSM_RAM *save_cmpc;
    523            char dummy[sizeof(MAIN_CSM)];
    524            UpdateCSMname();
   \   00000004   70409FE5           LDR      R4,??main_0      ;; `?<Constant "TurnOff_d">`
   \   00000008   28D04DE2           SUB      SP,SP,#+40
   \   0000000C   460100EF           SWI      +326
   \   00000010   ........           _BLF     InitConfig,??InitConfig??rA
   \   00000014   0410A0E1           MOV      R1,R4
   \   00000018   340084E2           ADD      R0,R4,#+52
   \   0000001C   240100EF           SWI      +292
    525            
    526            #ifdef NEWSGOLD
    527              save_cmpc=CSM_root()->csm_q->current_msg_processing_csm;
   \   00000020   068100EF           SWI      +33030
   \   00000024   080090E5           LDR      R0,[R0, #+8]
   \   00000028   045090E5           LDR      R5,[R0, #+4]
    528              CSM_root()->csm_q->current_msg_processing_csm=CSM_root()->csm_q->csm.first;
   \   0000002C   068100EF           SWI      +33030
   \   00000030   0060A0E1           MOV      R6,R0
   \   00000034   068100EF           SWI      +33030
   \   00000038   080090E5           LDR      R0,[R0, #+8]
   \   0000003C   081096E5           LDR      R1,[R6, #+8]
   \   00000040   080090E5           LDR      R0,[R0, #+8]
    529              CreateCSM(&MAINCSM_d.maincsm,dummy,0);
   \   00000044   0020A0E3           MOV      R2,#+0
   \   00000048   040081E5           STR      R0,[R1, #+4]
   \   0000004C   0D10A0E1           MOV      R1,SP
   \   00000050   0C0084E2           ADD      R0,R4,#+12
   \   00000054   070100EF           SWI      +263
    530              CSM_root()->csm_q->current_msg_processing_csm=save_cmpc;
   \   00000058   068100EF           SWI      +33030
   \   0000005C   080090E5           LDR      R0,[R0, #+8]
   \   00000060   045080E5           STR      R5,[R0, #+4]
    531              AddKeybMsgHook((void *)my_keyhook);
   \   00000064   ........           LDR      R0,??DataTable9  ;; my_keyhook
   \   00000068   2B0100EF           SWI      +299
    532            #else
    533                if (!AddKeybMsgHook_end((void *)my_keyhook)) 
    534                {
    535                  ShowMSG(1, (int) "TurnOff_d. Невозможно зарегистрировать обработчик!"); 
    536                  SUBPROC((void *)Killer);
    537                }
    538                else
    539                {
    540                  save_cmpc=CSM_root()->csm_q->current_msg_processing_csm;
    541                  CSM_root()->csm_q->current_msg_processing_csm=CSM_root()->csm_q->csm.first;
    542                  CreateCSM(&MAINCSM_d.maincsm,dummy,0);
    543                  CSM_root()->csm_q->current_msg_processing_csm=save_cmpc;
    544                }
    545            #endif
    546              
    547          #else  
    548            mode=MODE;      
    549            char dummy[sizeof(MAIN_CSM_GUI)];
    550            UpdateCSMname_GUI();
    551            MAINCSM_ID=CreateCSM(&MAINCSM.maincsm,dummy,0);
    552          #endif  
    553            
    554            UnlockSched();
   \   0000006C   470100EF           SWI      +327
    555            return 0;
   \   00000070   0000A0E3           MOV      R0,#+0
   \   00000074   28D08DE2           ADD      SP,SP,#+40
   \   00000078   7080BDE8           POP      {R4-R6,PC}       ;; return
   \                     ??main_0:
   \   0000007C   ........           DC32     `?<Constant "TurnOff_d">`
    556          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     screen

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   ........           DC32     screen

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     SND_ENA

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   ........           DC32     screen + 12

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   ........           DC32     my_keyhook

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for screen>`:
   \   00000000   00000000           DC16 0, 0
   \   00000004   08000000....       DC32 8, `?<Constant "">`
   \              ....        
   \                     `?<Initializer for MAINCSM_ID>`:
   \   0000000C   00000000           DC32 0
   \                     `?<Initializer for mode>`:
   \   00000010   00000000           DC8 0, 0, 0, 0
   \                     `?<Initializer for mytmr>`:
   \   00000014   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    

   \                                 In segment DATA_C, align 1, align-sorted
   \                     `?<Constant "">`:
   \   00000000   00                 DC8 ""

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "TurnOff config updated!">`:
   \   00000000   5475726E4F66       DC8 "TurnOff config updated!"
   \              6620636F6E66
   \              696720757064
   \              617465642100

   Maximum stack usage in bytes:

     Function              CSTACK
     --------              ------
     Check                    48
     DoIt                      8
     DoScreen                 20
     DrwImg                   64
     GetWavkaLength           32
     Killer                    4
     Play                    236
     UpdateCSMname_GUI         4
     main                     56
     maincsm_onclose           4
     maincsm_onclose_GUI       0
     maincsm_oncreate          0
     maincsm_oncreate_GUI     16
     maincsm_onmessage         4
     maincsm_onmessage_GUI     0
     method0                  32
     method1                   8
     method2                   8
     method3                   0
     method4                   0
     method5                  16
     method7                   4
     method8                   0
     method9                   0
     my_keyhook               12


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     minus11                           4
     Play                            300
     DrwImg                           92
     DoScreen                         76
     method0                         192
     method1                          52
     method2                          60
     method3                          12
     method4                          20
     DoIt                            128
     GetWavkaLength                  268
     screen                           36
     method5                         320
     method7                           4
     method8                           8
     method9                           8
     Canvas                           52
     maincsm_oncreate_GUI            128
     maincsm_onclose_GUI               4
     maincsm_onmessage_GUI            48
     ?<Constant "TurnOff">            68
     Check                            52
     maincsm_onmessage               132
     my_keyhook                      140
     maincsm_oncreate                  4
     Killer                           56
     maincsm_onclose                  20
     maincsm_name_body               280
     ?<Constant "TurnOff_d">          72
     UpdateCSMname_GUI                28
     main                            128
     ??DataTable2                      4
     ??DataTable4                      4
     ??DataTable5                      4
     ??DataTable7                      4
     ??DataTable9                      4
     ?<Initializer for screen>        36
     ?<Constant "">                    1
     ?<Constant "TurnOff config updated!">
                                      24
      Others                         208

 
 2 484 bytes in segment CODE
   221 bytes in segment DATA_C
    36 bytes in segment DATA_I
    36 bytes in segment DATA_ID
   280 bytes in segment DATA_Z
    24 bytes in segment INITTAB
 
 2 300 bytes of CODE  memory (+ 208 bytes shared)
   257 bytes of CONST memory
   316 bytes of DATA  memory

Errors: none
Warnings: none
