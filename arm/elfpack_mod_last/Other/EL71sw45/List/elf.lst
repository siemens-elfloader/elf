##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    21/Dec/2010  19:11:43 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\elfpack_mod_last\main\elf.c                   #
#    Command line    =  C:\arm\elfpack_mod_last\main\elf.c -D NEWSGOLD -D    #
#                       ELKA -lCN C:\arm\elfpack_mod_last\Other\EL71sw45\Lis #
#                       t\ -lb C:\arm\elfpack_mod_last\Other\EL71sw45\List\  #
#                       -o C:\arm\elfpack_mod_last\Other\EL71sw45\Obj\ -s9   #
#                       --no_unroll --cpu_mode thumb --endian little --cpu   #
#                       ARM926EJ-S --stack_align 4 --interwork -e --fpu      #
#                       None -I "C:\arm2\Embedded Workbench 4.0              #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  C:\arm\elfpack_mod_last\Other\EL71sw45\List\elf.lst  #
#    Object file     =  C:\arm\elfpack_mod_last\Other\EL71sw45\Obj\elf.r79   #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\elfpack_mod_last\main\elf.c
      1          #define MAX_PHNUM	10	//максимальное количество програмных сегментов
      2          
      3          #include "..\..\inc\swilib.h"
      4          
      5          
      6          typedef unsigned long  Elf32_Addr;	//Unsigned program address 4
      7          typedef unsigned short Elf32_Half;	//Unsigned medium integer  2
      8          typedef unsigned long  Elf32_Off; 	//Unsigned file offset     4
      9          typedef          long  Elf32_Sword; 	//Signed large integer     4
     10          typedef unsigned long  Elf32_Word; 	//Unsigned large integer   4
     11          
     12          //ELF Header
     13          //e_ident[] Identification Indexes
     14          #define EI_MAG0    0  //File identification
     15          #define EI_MAG1    1  //File identification
     16          #define EI_MAG2    2  //File identification
     17          #define EI_MAG3    3  //File identification
     18          #define EI_CLASS   4  //File class
     19          #define EI_DATA    5  //Data encoding
     20          #define EI_VERSION 6  //File version
     21          #define EI_PAD     7  //Start of padding bytes
     22          #define EI_NIDENT  16 //Size of e_ident[]
     23          
     24          typedef struct{
     25            unsigned char e_ident[EI_NIDENT]; //The initial bytes mark the file as an object file and provide machine-independent data with which to decode and interpret the fileТs contents.
     26            Elf32_Half e_type;      //This member identifies the object file type.
     27            Elf32_Half e_machine;   //This memberТs value specifies the required architecture for an individual file.
     28            Elf32_Word e_version;   //This member identifies the object file version.
     29            Elf32_Addr e_entry;     //This member gives the virtual address to which the system first transfers control, thus starting the process. If the file has no associated entry point, this member holds zero.
     30            Elf32_Off  e_phoff;     //This member holds the program header tableТs file offset in bytes. If the file has no program header table, this member holds zero.
     31            Elf32_Off  e_shoff;     //This member holds the section header tableТs file offset in bytes. If the file has no section header table, this member holds zero.
     32            Elf32_Word e_flags;     //This member holds processor-specific flags associated with the file. Flag names take the form EF_machine_flag.
     33            Elf32_Half e_ehsize;    //This member holds the ELF headerТs size in bytes.
     34            Elf32_Half e_phentsize; //This member holds the size in bytes of one entry in the fileТs program header table; all entries are the same size.
     35            Elf32_Half e_phnum;     //This member holds the number of entries in the program header table. Thus the product of e_phentsize and e_phnum gives the tableТs size in bytes. If a file has no program header table, e_phnum holds the value zero.
     36            Elf32_Half e_shentsize; //This member holds a section headerТs size in bytes. A section header is one entry in the section header table; all entries are the same size.
     37            Elf32_Half e_shnum;     //shnumЧThis member holds the number of entries in the section header table. Thus the product of e_shentsize and e_shnum gives the section header tableТs size in bytes. If a file has no section header table, e_shnum holds the value zero.
     38            Elf32_Half e_shstrndx;  //This member holds the section header table index of the entry associated with the section name string table. If the file has no section name string table, this member holds the value SHN_UNDEF.
     39          } Elf32_Ehdr;
     40          
     41          //E_typeЧThis member identifies the object file type.
     42          #define ET_NONE   0        //No file type
     43          #define ET_REL    1        //Re-locatable file
     44          #define ET_EXEC   2        //Executable file
     45          #define ET_DYN    3        //Shared object file
     46          #define ET_CORE   4        //Core file
     47          #define ET_LOPROC 0xFF00   //Processor-specific
     48          #define ET_HIPROC 0xFFFF   //Processor-specific
     49          
     50          //E_machineЧThis memberТs value specifies the required architecture for an individual file.
     51          #define EM_NONE        0  //No machine
     52          #define EM_M32         1  //AT&T WE 32100
     53          #define EM_SPARC       2  //SPARC
     54          #define EM_386         3  //Intel Architecture
     55          #define EM_68K         4  //Motorola 68000
     56          #define EM_88K         5  //Motorola 88000
     57          #define EM_860         7  //Intel 80860
     58          #define EM_MIPS        8  //MIPS RS3000 Big-Endian
     59          #define EM_MIPS_RS4_BE 10 //MIPS RS4000 Big-Endian
     60          #define EM_ARM         40 //ARM/Thumb Architecture
     61          
     62          //E_versionЧThis member identifies the object file version.
     63          #define EV_NONE    0 //Invalid version
     64          #define EV_CURRENT 1 //Current version
     65          
     66          //EI_MAG0 0 to EI_MAG3ЧA fileТs first 4 bytes hold a magic number, identifying the file as an ELF object file. Name Value Meaning
     67          #define ELFMAG0  0x7f //e_ident[EI_MAG0]
     68          #define ELFMAG1 'E'   //e_ident[EI_MAG1]
     69          #define ELFMAG2 'L'   //e_ident[EI_MAG2]
     70          #define ELFMAG3 'F'   //e_ident[EI_MAG3]
     71          
     72          //EI_CLASSЧThe next byte, e_ident[EI_CLASS], identifies the fileТs class, or capacity. Name Value Meaning
     73          #define ELFCLASSNONE 0 //Invalid class
     74          #define ELFCLASS32   1 //32-bit objects
     75          #define ELFCLASS64   2 //64-bit objects
     76          
     77          //EI_DATAЧByte e_ident[EI_DATA]specifies the data encoding of all data1 in the object file. The following encodings are currently defined. Name Value Meaning
     78          #define ELFDATANONE 0 //Invalid data encoding
     79          #define ELFDATA2LSB 1 //See Data encodings ELFDATA2LSB, below
     80          #define ELFDATA2MSB 2 //See Data encodings ELFDATA2MSB, below
     81          
     82          //Sections
     83          //Section Header
     84          typedef struct{
     85            Elf32_Word sh_name;      //This member specifies the name of the section. Its value is an index into the section header string table section [see section 3.4, String Table below], giving the location of a null-terminated string.
     86            Elf32_Word sh_type;      //typeЧThis member categorizes the sectionТs contents and semantics. Section types and their descriptions appear in Figure 3-9 below.
     87            Elf32_Word sh_flags;     //Sections support 1-bit flags that describe miscellaneous attributes. Flag definitions appear in Figure 3-11, below.
     88            Elf32_Addr sh_addr;      //If the section will appear in the memory image of a process, this member gives the address at which the sectionТs first byte should reside. Otherwise, the member contains 0.
     89            Elf32_Off  sh_offset;    //This memberТs value gives the byte offset from the beginning of the file to the first byte in the section. One section type, SHT_NOBITS described in Figure 3-9 below, occupies no space in the file, and its sh_offset member locates the conceptual placement in the file.
     90            Elf32_Word sh_size;      //This member gives the sectionТs size in bytes. Unless the section type is SHT_NOBITS, the section occupies sh_size bytes in the file. A section of type SHT_NOBITS may have a non-zero size, but it occupies no space in the file.
     91            Elf32_Word sh_link;      //This member holds a section header table index link, whose interpretation depends on the section type. Figure 3-12 below describes the values.
     92            Elf32_Word sh_info;      //This member holds extra information, whose interpretation depends on the section type. Figure 3-12 below describes the values.
     93            Elf32_Word sh_addralign; //Some sections have address alignment constraints. For example, if a section holds a doubleword, the system must ensure double-word alignment for the entire section. That is, the value of sh_addr must be congruent to 0, modulo the value of sh_addralign. Currently, only 0 and positive integral powers of two are allowed. Values 0 and 1 mean the section has no alignment constraints.
     94            Elf32_Word sh_entsize;   //Some sections hold a table of fixed-size entries, such as a symbol table. For such a section, this member gives the size in bytes of each entry. The member contains 0 if the section does not hold a table of fixedsize entries. A section headerТs sh_type member specifies the sectionТs semantics.
     95          } Elf32_Shdr;
     96          
     97          //Special Section Indexes
     98          #define SHN_UNDEF     0     //This value marks an undefined, missing, irrelevant, or otherwise meaningless section reference. For example, a symbol УdefinedФ relative to section number SHN_UNDEF is an undefined symbol.
     99          #define SHN_LORESERVE 0xff00 //This value specifies the lower bound of the range of reserved indexes.
    100          #define SHN_LOPROC    0xff00 //Values in this range are reserved for processor-specific semantics.
    101          #define SHN_HIPROC    0xff1f //Values in this range are reserved for processor-specific semantics.
    102          #define SHN_ABS       0xfff1 //This value specifies absolute values for the corresponding reference. For example, symbols defined relative to section number SHN_ABS have absolute values and are not affected by relocation.
    103          #define SHN_COMMON    0xfff2 //Symbols defined relative to this section are common symbols, such as FORTRAN COMMON or unallocated C external variables.
    104          #define SHN_HIRESERVE 0xffff //This value specifies the upper bound of the range of reserved indexes. The system reserves indexes between SHN_LORESERVE and SHN_HIRESERVE, inclusive; the values do not refer to the section header table. That is, the section header table does not contain entries for the reserved indexes.
    105          
    106          //sh_type
    107          #define SHT_NULL     0  //This value marks a section header that does not have an associated section. Other members of the section header have undefined values
    108          #define SHT_PROGBITS 1  //The section holds information defined by the program, whose format and meaning are determined solely by the program.
    109          #define SHT_SYMTAB   2  //The section holds a symbol table.
    110          #define SHT_STRTAB   3  //The section holds a string table.
    111          #define SHT_RELA     4  //The section holds relocation entries with explicit addends, such as type Elf32_Rela for the 32-bit class of object files. An object file may have multiple relocation sections. See Relocation below for details.
    112          #define SHT_HASH     5  //The section holds a symbol hash table.
    113          #define SHT_DYNAMIC  6  //The section holds information for dynamic linking.
    114          #define SHT_NOTE     7  //This section holds information that marks the file in some way.
    115          #define SHT_NOBITS   8  //A section of this type occupies no space in the file but otherwise resembles SHT_PROGBITS. Although this section contains no bytes, the sh_offset member contains the conceptual file offset.
    116          #define SHT_REL      9  //The section holds relocation entries without explicit addends, such as type Elf32_Rel for the 32-bit class of object files. An object file may have multiple relocation sections. See Relocation below for details.
    117          #define SHT_SHLIB    10 //This section type is reserved but has unspecified semantics.
    118          #define SHT_DYNSYM   11 //The section holds a symbol table.
    119          #define SHT_LOPROC   0x70000000
    120          #define SHT_HIPROC   0x7fffffff //Values in this inclusive range are reserved for processor-specific semantics.
    121          #define SHT_LOUSER   0x80000000
    122          #define SHT_HIUSER   0xffffffff //Values in this inclusive range are reserved for application programs. Types between SHT_LOUSER and SHT_HIUSER may be used by an application,without conflicting with current or future system-defined section types.
    123          
    124          //Section Attribute Flags, sh_flags
    125          #define SHF_WRITE     1          //The section contains data that should be writable during process execution
    126          #define SHF_ALLOC     2          //The section occupies memory during process execution. Some control sections do not reside in the memory image of an object file; this attribute is off for those sections
    127          #define SHF_EXECINSTR 4          //The section contains executable machine instructions.
    128          #define SHF_MASKPROC  0xf0000000 //Bits in this mask are reserved for processor-specific semantics.
    129          
    130          //Program
    131          //Program Header
    132          typedef struct{
    133            Elf32_Word p_type;   //This member tells what kind of segment this array element describes or how to interpret the array element's information. Type values and their meanings are given in Figure 3-21, below.
    134            Elf32_Off p_offset;  //This member gives the offset from the start of the file at which the first byte of the segment resides.
    135            Elf32_Addr p_vaddr;  //This member gives the virtual address at which the first byte of the segment resides in memory.
    136            Elf32_Addr p_paddr;  //On systems for which physical addressing is relevant, this member is reserved for the segment's physical address. This member requires operating system specific information.
    137            Elf32_Word p_filesz; //This member gives the number of bytes in the file image of the segment; it may be zero.
    138            Elf32_Word p_memsz;  //This member gives the number of bytes in the memory image of the segment; it may be zero.
    139            Elf32_Word p_flags;  //This member gives flags relevant to the segment. Defined flag values are given in Figure 3-22, below.
    140            Elf32_Word p_align;  //Loadable process segments must have congruent values for p_vaddr and p_offset, modulo the page size. This member gives the value to which the segments are aligned in memory and in the file. Values 0 and 1 mean that no alignment is required. Otherwise, p_align should be a positive, integral power of 2, and p_vaddr should equal p_offset, modulo p_align.
    141          } Elf32_Phdr;
    142          
    143          //Defined program header flags
    144          #define PF_X 1 //The segment may be executed.
    145          #define PF_W 2 //The segment may be written to.
    146          #define PF_R 4 //The segment may be read.
    147          #define PF_MASKPROC 0xf0000000 //Reserved for processor-specific purposes (see 4.6, Program headers).
    148          
    149          //Segment Types, p_type
    150          #define PT_NULL    0 //The array element is unused; other members' values are undefined. This type lets the program header table have ignored entries.
    151          #define PT_LOAD    1 //The array element specifies a loadable segment, described by p_filesz and p_memsz (for additional explanation, see PT_LOAD below).
    152          #define PT_DYNAMIC 2 //The array element specifies dynamic linking information. See subsection 4.7.
    153          #define PT_INTERP  3 //The array element specifies the location and size of a null-terminated path name to invoke as an interpreter.
    154          #define PT_NOTE    4 //The array element specifies the location and size of auxiliary information.
    155          #define PT_SHLIB   5 //This segment type is reserved but has unspecified semantics.
    156          #define PT_PHDR    6 //The array element, if present, specifies the location and size of the program header table itself (for additional explanation, see PT_ PHDR below).
    157          #define PT_LOPROC  0x70000000 //Values in this inclusive range are reserved for processor-specific semantics.
    158          #define PT_HIPROC  0x7fffffff
    159          
    160          //The dynamic section
    161          typedef struct{
    162            Elf32_Sword d_tag;
    163            Elf32_Word d_val;
    164          } Elf32_Dyn;
    165          
    166          //Dynamic section tags
    167          #define DT_NULL     0  //Ignored. This entry marks the end of the dynamic array. mandatory
    168          #define DT_NEEDED   1  //Index in the string table of the name of a needed library. multiple
    169          #define DT_PLTRELSZ 2  //These entries are unused by versions 1-2 of the ARM EABI. unused
    170          #define DT_PLTGOT   3
    171          #define DT_HASH     4  //The offset of the hash table section in the dynamic segment. mandatory
    172          #define DT_STRTAB   5  //The offset of the string table section in the dynamic segment. mandatory
    173          #define DT_SYMTAB   6  //The offset of the symbol table section in the dynamic segment. mandatory
    174          #define DT_RELA     7  //The offset in the dynamic segment of an SHT_RELA relocation section, Its byte size, and the byte size of an ARM RELA-type relocation entry. optional
    175          #define DT_RELASZ   8
    176          #define DT_RELAENT  9
    177          #define DT_STRSZ    10 //The byte size of the string table section. mandatory
    178          #define DT_SYMENT   11 //The byte size of an ARM symbol table entryЧ16. mandatory
    179          #define DT_INIT     12 //These entries are unused by versions 1-2 of the ARM EABI. unused
    180          #define DT_FINI     13
    181          #define DT_SONAME   14 //The Index in the string table of the name of this shared object. mandatory
    182          #define DT_RPATH    15 //Unused by the ARM EABI. unused
    183          #define DT_SYMBOLIC 16
    184          #define DT_REL      17 //The offset in the dynamic segment of an SHT_REL relocation section, Its byte size, and the byte size of an ARM REL-type relocation entry optional
    185          #define DT_RELSZ    18
    186          #define DT_RELENT   19
    187          #define DT_PLTREL   20 //These entries are unused by versions 1-2 of the ARM EABI. unused
    188          #define DT_DEBUG    21
    189          #define DT_TEXTREL  22
    190          #define DT_JMPREL   23
    191          #define DT_BIND_NOW 24
    192          #define DT_LOPROC   0x70000000 //Values in this range are reserved to the ARM EABI. unused
    193          #define DT_HIPROC   0x7fffffff
    194          
    195          //Relocation Entries
    196          typedef struct{
    197            Elf32_Addr r_offset;
    198            Elf32_Word r_info;
    199          } Elf32_Rel;
    200          
    201          typedef struct{
    202            Elf32_Addr  r_offset;
    203            Elf32_Word  r_info;
    204            Elf32_Sword r_addend;
    205          } Elf32_Rela;
    206          
    207          #define ELF32_R_SYM(i)    ((i)>>8)
    208          #define ELF32_R_TYPE(i)   ((unsigned char)(i))
    209          #define ELF32_R_INFO(s,t) (((s)<<8)+(unsigned char)(t))
    210          
    211          //ARM relocation types
    212          #define R_ARM_NONE            0   //Any No relocation. Encodes dependencies between sections.
    213          #define R_ARM_PC24            1   //ARM B/BL S Ц P + A
    214          #define R_ARM_ABS32           2   //32-bit word S + A
    215          #define R_ARM_REL32           3   //32-bit word S Ц P + A
    216          #define R_ARM_PC13            4   //ARM LDR r, [pc,Е] S Ц P + A
    217          #define R_ARM_ABS16           5   //16-bit half-word S + A
    218          #define R_ARM_ABS12           6   //ARM LDR/STR S + A
    219          #define R_ARM_THM_ABS5        7   //Thumb LDR/STR S + A
    220          #define R_ARM_ABS8            8   //8-bit byte S + A
    221          #define R_ARM_SBREL32         9   //32-bit word S Ц B + A
    222          #define R_ARM_THM_PC22        10  //Thumb BL pair S Ц P+ A
    223          #define R_ARM_THM_PC8         11  //Thumb LDR r, [pc,Е] S Ц P + A
    224          #define R_ARM_AMP_VCALL9      12  //AMP VCALL ObsoleteЧSA-1500 only.
    225          #define R_ARM_SWI24           13  //ARM SWI S + A
    226          #define R_ARM_THM_SWI8        14  //Thumb SWI S + A
    227          #define R_ARM_XPC25           15  //ARM BLX S Ц P+ A
    228          #define R_ARM_THM_XPC22       16  //Thumb BLX pair S Ц P+ A
    229          #define R_ARM_COPY            20  //32 bit word Copy symbol at dynamic link time.
    230          #define R_ARM_GLOB_DAT        21  //32 bit word Create GOT entry.
    231          #define R_ARM_JUMP_SLOT       22  //32 bit word Create PLT entry.
    232          #define R_ARM_RELATIVE        23  //32 bit word Adjust by program base.
    233          #define R_ARM_GOTOFF          24  //32 bit word Offset relative to start of GOT.
    234          #define R_ARM_GOTPC           25  //32 bit word Insert address of GOT.
    235          #define R_ARM_GOT32           26  //32 bit word Entry in GOT.
    236          #define R_ARM_PLT32           27  //ARM BL Entry in PLT.
    237          #define R_ARM_ALU_PCREL_7_0   32  //ARM ADD/SUB (S Ц P + A) & 0x000000FF
    238          #define R_ARM_ALU_PCREL_15_8  33  //ARM ADD/SUB (S Ц P + A) & 0x0000FF00
    239          #define R_ARM_ALU_PCREL_23_15 34  //ARM ADD/SUB (S Ц P + A) & 0x00FF0000
    240          #define R_ARM_LDR_SBREL_11_0  35  //ARM LDR/STR (S Ц B + A) & 0x00000FFF
    241          #define R_ARM_ALU_SBREL_19_12 36  //ARM ADD/SUB (S Ц B + A) & 0x000FF000
    242          #define R_ARM_ALU_SBREL_27_20 37  //ARM ADD/SUB (S Ц B + A) & 0x0FF00000
    243          #define R_ARM_GNU_VTENTRY     100 //32 bit word Record C++ vtable entry.
    244          #define R_ARM_GNU_VTINHERIT   101 //32 bit word Record C++ member usage.
    245          #define R_ARM_THM_PC11        102 //Thumb B S Ц P + A
    246          #define R_ARM_THM_PC9         103 //Thumb B<cond> S Ц P + A
    247          #define R_ARM_RXPC25          249 //ARM BLX (?S Ц ?P) + A For calls between program segments.
    248          #define R_ARM_RSBREL32        250 //Word (?S Ц ?SB) + A For an offset from SB, the static base.
    249          #define R_ARM_THM_RPC22       251 //Thumb BL/BLX pair (?S Ц ?P) + A For calls between program segments.
    250          #define R_ARM_RREL32          252 //Word (?S Ц ?P) + A For on offset between two segments.
    251          #define R_ARM_RABS32          253 //Word ?S + A For the address of a location in the target segment.
    252          #define R_ARM_RPC24           254 //ARM B/BL (?S Ц ?P) + A For calls between program segments.
    253          #define R_ARM_RBASE           255 //None NoneЧIdentifies the segment being relocated by the following relocation directives.
    254          
    255          typedef long TElfEntry(char *, void *,void *,void *);
    256          
    257          

   \                                 In segment CODE, align 4, keep-with-next
    258          __arm zeromem_a(void *d, int l){zeromem(d,l);}
   \                     zeromem_a:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   1D0100EF           SWI      +285
   \   00000008   0080BDE8           POP      {PC}             ;; return
    259          
    260          
    261          /*   «агрузка формата 'ELF' в оперативную пам€ть и немедленное исполнение программной секции   */
    262          
    263          //¬озвращаемые значени€:
    264          //  0  - Ёльф запущен 
    265          // -1  - Ќе открываетс€ эльф
    266          // -2  - Ќе читаетс€ эльф
    267          // -3  - ƒа и не эльф это вовсе (Ќет необходимого ID = 0x7F,'E','L','F')
    268          // -4  - Ќе найден программный заголовок
    269          // -5  - Ќе читаетс€ программный заголовок
    270          // -6  - Ќе найден динамический сегмент
    271          // -7  - Ќе выдел€етс€ пам€ть под динамический сегмент
    272          // -8  - Ќе читаетс€ динамический сегмент
    273          // -9  - —лишком много програмных сегментов
    274          // -10 - Ќе читаетс€ программный сегмент
    275          // -11 - Ќеизвестный тип программного сегмента
    276          // -12 - Ќеизвестный тип релокации
    277          // -13 - Ќе выдел€етьс€ пам€ть под эльф (Ќехватка свободной RAM)
    278          

   \                                 In segment CODE, align 4, keep-with-next
    279          long elfload(char *filename, void *param1, void *param2, void *param3)
    280          {
   \                     elfload:
   \   00000000   7FB5               PUSH     {R0-R6,LR}
   \   00000002   FFB0               SUB      SP,SP,#+508
    281            Elf32_Ehdr ehdr;			// «аголовок эльфа
    282            Elf32_Phdr phdrs[MAX_PHNUM];	        // «аголовки програм
    283            Elf32_Word dyn[DT_BIND_NOW+1];	// “эги динамической секции
    284            
    285            char *reloc, *base;
    286            unsigned long minadr=(unsigned long)-1, maxadr=0;
   \   00000004   0025               MOVS     R5,#+0
   \   00000006   ED43               MVNS     R5,R5
   \   00000008   0595               STR      R5,[SP, #+20]
    287            int n,m;
    288            
    289            zeromem_a(dyn, sizeof(dyn));
   \   0000000A   6421               MOVS     R1,#+100
   \   0000000C   66A8               ADD      R0,SP,#+408
   \   0000000E   ........           BLX      zeromem_a
    290              
    291            int fin;
    292            unsigned int iError, iError2;
    293            if ((fin=fopen(filename, A_ReadOnly+A_BIN, P_READ, &iError))<0) return -1; // Ќе открываетс€ эльф
   \   00000012   7F98               LDR      R0,[SP, #+508]
   \   00000014   0024               MOVS     R4,#+0
   \   00000016   6B46               MOV      R3,SP
   \   00000018   8022               MOVS     R2,#+128
   \   0000001A   1102               LSLS     R1,R2,#+8
   \   0000001C   0ADF               SVC      +10
   \   0000001E   0190               STR      R0,[SP, #+4]
   \   00000020   0028               CMP      R0,#+0
   \   00000022   01D5               BPL      ??elfload_0
   \   00000024   2800               MOVS     R0,R5
   \   00000026   45E1               B        ??elfload_1
    294            if (fread(fin, &ehdr, sizeof(Elf32_Ehdr), &iError)!=sizeof(Elf32_Ehdr))    // Ќе читаетс€ эльф
   \                     ??elfload_0:
   \   00000028   6B46               MOV      R3,SP
   \   0000002A   3422               MOVS     R2,#+52
   \   0000002C   09A9               ADD      R1,SP,#+36
   \   0000002E   0BDF               SVC      +11
   \   00000030   3428               CMP      R0,#+52
   \   00000032   05D0               BEQ      ??elfload_2
    295            {fclose(fin, &iError); return -2;}
   \   00000034   0198               LDR      R0,[SP, #+4]
   \   00000036   6946               MOV      R1,SP
   \   00000038   0DDF               SVC      +13
   \   0000003A   0120               MOVS     R0,#+1
   \                     ??elfload_3:
   \   0000003C   C043               MVNS     R0,R0
   \   0000003E   39E1               B        ??elfload_1
    296            
    297            
    298            if (*((long *)ehdr.e_ident)!=0x464C457F) // ƒа и не эльф это вовсе /* \x7FELF */
   \                     ??elfload_2:
   \   00000040   0998               LDR      R0,[SP, #+36]
   \   00000042   9E49               LDR      R1,??elfload_4   ;; 0x464c457f
   \   00000044   8842               CMP      R0,R1
   \   00000046   04D0               BEQ      ??elfload_5
    299            {                               
    300              fclose(fin, &iError);
   \   00000048   0198               LDR      R0,[SP, #+4]
   \   0000004A   6946               MOV      R1,SP
   \   0000004C   0DDF               SVC      +13
    301              return -3;
   \   0000004E   0220               MOVS     R0,#+2
   \   00000050   F4E7               B.N      ??elfload_3
    302            }
   \                     ??elfload_5:
   \   00000052   09A8               ADD      R0,SP,#+36
   \   00000054   808D               LDRH     R0,[R0, #+44]
   \   00000056   0B28               CMP      R0,#+11
   \   00000058   02D3               BCC      ??elfload_6
    303            
    304            // ѕрочитаем все программные сегменты и вычислим необходимую область в RAM
    305            if (ehdr.e_phnum>MAX_PHNUM) return -9; // —лишком много програмных сегментов
   \   0000005A   0820               MOVS     R0,#+8
   \                     ??elfload_7:
   \   0000005C   C043               MVNS     R0,R0
   \   0000005E   29E1               B        ??elfload_1
    306            for(n=0;n<ehdr.e_phnum;n++)
   \                     ??elfload_6:
   \   00000060   0294               STR      R4,[SP, #+8]
   \   00000062   10E0               B        ??elfload_8
    307            {
    308              if (lseek(fin, ehdr.e_phoff+n*ehdr.e_phentsize, S_SET, &iError, &iError2)!=ehdr.e_phoff+n*ehdr.e_phentsize)
    309              {fclose(fin, &iError); return -4;}				// Ќе найден программный заголовок
    310              if (fread(fin, &phdrs[n], sizeof(Elf32_Phdr), &iError)!=sizeof(Elf32_Phdr))
    311              {fclose(fin, &iError); return -5;}				// Ќе читаетс€ программный заголовок
    312              
    313              if (phdrs[n].p_type==PT_LOAD)
   \                     ??elfload_9:
   \   00000064   2868               LDR      R0,[R5, #+0]
   \   00000066   0128               CMP      R0,#+1
   \   00000068   0AD1               BNE      ??elfload_10
    314              {
    315                if (minadr>phdrs[n].p_vaddr) minadr=phdrs[n].p_vaddr;
   \   0000006A   A868               LDR      R0,[R5, #+8]
   \   0000006C   0599               LDR      R1,[SP, #+20]
   \   0000006E   8842               CMP      R0,R1
   \   00000070   00D2               BCS      ??elfload_11
   \   00000072   0590               STR      R0,[SP, #+20]
    316                if (maxadr<(phdrs[n].p_vaddr+phdrs[n].p_memsz))
   \                     ??elfload_11:
   \   00000074   6969               LDR      R1,[R5, #+20]
   \   00000076   4018               ADDS     R0,R0,R1
   \   00000078   8442               CMP      R4,R0
   \   0000007A   01D2               BCS      ??elfload_10
    317                {
    318          	maxadr=phdrs[n].p_vaddr+phdrs[n].p_memsz;
   \   0000007C   A868               LDR      R0,[R5, #+8]
   \   0000007E   4418               ADDS     R4,R0,R1
    319                }
    320              }
   \                     ??elfload_10:
   \   00000080   0298               LDR      R0,[SP, #+8]
   \   00000082   401C               ADDS     R0,R0,#+1
   \   00000084   0290               STR      R0,[SP, #+8]
   \                     ??elfload_8:
   \   00000086   0298               LDR      R0,[SP, #+8]
   \   00000088   09A9               ADD      R1,SP,#+36
   \   0000008A   898D               LDRH     R1,[R1, #+44]
   \   0000008C   8842               CMP      R0,R1
   \   0000008E   29DA               BGE      ??elfload_12
   \   00000090   08A8               ADD      R0,SP,#+32
   \   00000092   01B4               PUSH     {R0}
   \   00000094   1198               LDR      R0,[SP, #+68]
   \   00000096   0399               LDR      R1,[SP, #+12]
   \   00000098   0AAD               ADD      R5,SP,#+40
   \   0000009A   6D8D               LDRH     R5,[R5, #+42]
   \   0000009C   01AB               ADD      R3,SP,#+4
   \   0000009E   0022               MOVS     R2,#+0
   \   000000A0   6943               MULS     R1,R5,R1
   \   000000A2   4118               ADDS     R1,R0,R1
   \   000000A4   0298               LDR      R0,[SP, #+8]
   \   000000A6   0FDF               SVC      +15
   \   000000A8   1199               LDR      R1,[SP, #+68]
   \   000000AA   039A               LDR      R2,[SP, #+12]
   \   000000AC   0AAB               ADD      R3,SP,#+40
   \   000000AE   5B8D               LDRH     R3,[R3, #+42]
   \   000000B0   01B0               ADD      SP,SP,#+4
   \   000000B2   5A43               MULS     R2,R3,R2
   \   000000B4   8918               ADDS     R1,R1,R2
   \   000000B6   8842               CMP      R0,R1
   \   000000B8   04D0               BEQ      ??elfload_13
   \   000000BA   0198               LDR      R0,[SP, #+4]
   \   000000BC   6946               MOV      R1,SP
   \   000000BE   0DDF               SVC      +13
   \   000000C0   0320               MOVS     R0,#+3
   \   000000C2   BBE7               B.N      ??elfload_3
   \                     ??elfload_13:
   \   000000C4   0298               LDR      R0,[SP, #+8]
   \   000000C6   16A9               ADD      R1,SP,#+88
   \   000000C8   4001               LSLS     R0,R0,#+5
   \   000000CA   0D18               ADDS     R5,R1,R0
   \   000000CC   0198               LDR      R0,[SP, #+4]
   \   000000CE   6B46               MOV      R3,SP
   \   000000D0   2022               MOVS     R2,#+32
   \   000000D2   2900               MOVS     R1,R5
   \   000000D4   0BDF               SVC      +11
   \   000000D6   2028               CMP      R0,#+32
   \   000000D8   C4D0               BEQ      ??elfload_9
   \   000000DA   0198               LDR      R0,[SP, #+4]
   \   000000DC   6946               MOV      R1,SP
   \   000000DE   0DDF               SVC      +13
   \   000000E0   0420               MOVS     R0,#+4
   \   000000E2   BBE7               B.N      ??elfload_7
    321            }
    322            
    323            // ¬ыделим эту область и очистим ее
    324            if ((base=(char *)malloc(maxadr-minadr))==0) // Ќе выдел€етс€ пам€ть под эльф (Ќехватка свободной RAM)
   \                     ??elfload_12:
   \   000000E4   0598               LDR      R0,[SP, #+20]
   \   000000E6   251A               SUBS     R5,R4,R0
   \   000000E8   2800               MOVS     R0,R5
   \   000000EA   14DF               SVC      +20
   \   000000EC   0400               MOVS     R4,R0
   \   000000EE   04D1               BNE      ??elfload_14
    325            {
    326              fclose(fin, &iError);
   \   000000F0   0198               LDR      R0,[SP, #+4]
   \   000000F2   6946               MOV      R1,SP
   \   000000F4   0DDF               SVC      +13
    327              return -13;
   \   000000F6   0C20               MOVS     R0,#+12
   \   000000F8   A0E7               B.N      ??elfload_3
    328            }
    329            
    330            // ќбнуление выделенной области
    331            zeromem_a(base,maxadr-minadr);
   \                     ??elfload_14:
   \   000000FA   2900               MOVS     R1,R5
   \   000000FC   ........           BLX      zeromem_a
    332            
    333            // ќбход всех сегментов
    334            for(n=0;n<ehdr.e_phnum;n++)
   \   00000100   0020               MOVS     R0,#+0
   \   00000102   58E0               B.N      ??elfload_15
    335            { 
    336              if (lseek(fin, phdrs[n].p_offset, S_SET, &iError, &iError)!=phdrs[n].p_offset)
    337              {fclose(fin, &iError); mfree(base); return -6;} // Ќе найден динамический сегмент
    338          
    339              switch (phdrs[n].p_type)
   \                     ??elfload_16:
   \   00000104   0498               LDR      R0,[SP, #+16]
   \   00000106   0068               LDR      R0,[R0, #+0]
   \   00000108   0128               CMP      R0,#+1
   \   0000010A   02D0               BEQ      ??elfload_17
   \   0000010C   0228               CMP      R0,#+2
   \   0000010E   17D0               BEQ      ??elfload_18
   \   00000110   BAE0               B        ??elfload_19
    340              {
    341               case PT_LOAD:
    342                 
    343                // «агрузим программные сегменты с размером больше 0
    344                if (phdrs[n].p_filesz!=0) 
   \                     ??elfload_17:
   \   00000112   0498               LDR      R0,[SP, #+16]
   \   00000114   0269               LDR      R2,[R0, #+16]
   \   00000116   002A               CMP      R2,#+0
   \   00000118   4BD0               BEQ      ??elfload_20
    345                 {
    346          	if (fread(fin, &base[phdrs[n].p_vaddr-minadr], phdrs[n].p_filesz, &iError)!= phdrs[n].p_filesz)
   \   0000011A   8068               LDR      R0,[R0, #+8]
   \   0000011C   0599               LDR      R1,[SP, #+20]
   \   0000011E   6B46               MOV      R3,SP
   \   00000120   401A               SUBS     R0,R0,R1
   \   00000122   2118               ADDS     R1,R4,R0
   \   00000124   0198               LDR      R0,[SP, #+4]
   \   00000126   0BDF               SVC      +11
   \   00000128   0499               LDR      R1,[SP, #+16]
   \   0000012A   0969               LDR      R1,[R1, #+16]
   \   0000012C   8842               CMP      R0,R1
   \   0000012E   40D0               BEQ      ??elfload_20
    347          	{fclose(fin, &iError); mfree(base); return -10;} // Ќе читаетс€ программный сегмент
   \   00000130   0198               LDR      R0,[SP, #+4]
   \   00000132   6946               MOV      R1,SP
   \   00000134   0DDF               SVC      +13
   \   00000136   2000               MOVS     R0,R4
   \   00000138   15DF               SVC      +21
   \   0000013A   0920               MOVS     R0,#+9
   \                     ??elfload_21:
   \   0000013C   C043               MVNS     R0,R0
   \   0000013E   B9E0               B        ??elfload_1
    348                 }
    349                  break;
    350               case PT_DYNAMIC:
    351                 
    352                // ѕрочтем динамическую секцию
    353                if ((reloc=(char *)malloc(phdrs[n].p_filesz))==0) // Ќе выдел€етс€ пам€ть под динамический сегмент
   \                     ??elfload_18:
   \   00000140   0498               LDR      R0,[SP, #+16]
   \   00000142   0069               LDR      R0,[R0, #+16]
   \   00000144   14DF               SVC      +20
   \   00000146   0390               STR      R0,[SP, #+12]
   \   00000148   0028               CMP      R0,#+0
   \   0000014A   06D1               BNE      ??elfload_22
    354                {
    355          	fclose(fin, &iError);
   \   0000014C   0198               LDR      R0,[SP, #+4]
   \   0000014E   6946               MOV      R1,SP
   \   00000150   0DDF               SVC      +13
    356          	mfree(base);
   \   00000152   2000               MOVS     R0,R4
   \   00000154   15DF               SVC      +21
    357          	return -7;
   \   00000156   0620               MOVS     R0,#+6
   \   00000158   70E7               B.N      ??elfload_3
    358                }
    359                
    360                if (fread(fin, reloc, phdrs[n].p_filesz, &iError)!=phdrs[n].p_filesz)
   \                     ??elfload_22:
   \   0000015A   0498               LDR      R0,[SP, #+16]
   \   0000015C   0399               LDR      R1,[SP, #+12]
   \   0000015E   0269               LDR      R2,[R0, #+16]
   \   00000160   0198               LDR      R0,[SP, #+4]
   \   00000162   6B46               MOV      R3,SP
   \   00000164   0BDF               SVC      +11
   \   00000166   0499               LDR      R1,[SP, #+16]
   \   00000168   0969               LDR      R1,[R1, #+16]
   \   0000016A   8842               CMP      R0,R1
   \   0000016C   08D0               BEQ      ??elfload_23
    361                {fclose(fin, &iError); mfree(reloc); mfree (base); return -8;}	// Ќе читаетс€ динамический сегмент
   \   0000016E   0198               LDR      R0,[SP, #+4]
   \   00000170   6946               MOV      R1,SP
   \   00000172   0DDF               SVC      +13
   \   00000174   0398               LDR      R0,[SP, #+12]
   \   00000176   15DF               SVC      +21
   \   00000178   2000               MOVS     R0,R4
   \   0000017A   15DF               SVC      +21
   \   0000017C   0720               MOVS     R0,#+7
   \   0000017E   6DE7               B.N      ??elfload_7
    362          
    363                // ¬ытащим все тэги из динамической секции
    364                m=0;
   \                     ??elfload_23:
   \   00000180   0399               LDR      R1,[SP, #+12]
   \   00000182   0020               MOVS     R0,#+0
   \   00000184   0968               LDR      R1,[R1, #+0]
   \   00000186   66AB               ADD      R3,SP,#+408
   \   00000188   0029               CMP      R1,#+0
   \   0000018A   06D1               BNE      ??elfload_24
   \   0000018C   0BE0               B        ??elfload_25
    365                while (((Elf32_Dyn *)reloc)[m].d_tag!=DT_NULL)
    366                 {
    367          	if (((Elf32_Dyn *)reloc)[m].d_tag<=DT_BIND_NOW) 
   \                     ??elfload_26:
   \   0000018E   192A               CMP      R2,#+25
   \   00000190   02DA               BGE      ??elfload_27
    368                  {
    369          	  dyn[((Elf32_Dyn *)reloc)[m].d_tag]=((Elf32_Dyn *)reloc)[m].d_val;
   \   00000192   4968               LDR      R1,[R1, #+4]
   \   00000194   9200               LSLS     R2,R2,#+2
   \   00000196   9950               STR      R1,[R3, R2]
    370          	}
    371          	m++;
   \                     ??elfload_27:
   \   00000198   401C               ADDS     R0,R0,#+1
    372                 }
   \                     ??elfload_24:
   \   0000019A   039A               LDR      R2,[SP, #+12]
   \   0000019C   C100               LSLS     R1,R0,#+3
   \   0000019E   5118               ADDS     R1,R2,R1
   \   000001A0   0A68               LDR      R2,[R1, #+0]
   \   000001A2   002A               CMP      R2,#+0
   \   000001A4   F3D1               BNE      ??elfload_26
    373                m=0;
    374                
    375                // ¬ыполним релокацию REL
    376                if (dyn[DT_RELSZ]!=0)
   \                     ??elfload_25:
   \   000001A6   7899               LDR      R1,[SP, #+480]
   \   000001A8   0020               MOVS     R0,#+0
   \   000001AA   0029               CMP      R1,#+0
   \   000001AC   2FD1               BNE      ??elfload_28
    377                 {
    378          	while (m*sizeof(Elf32_Rel)<dyn[DT_RELSZ])
    379                   {
    380          
    381                    Elf32_Word ri=ELF32_R_TYPE(((Elf32_Rel *)(reloc+dyn[DT_REL]-phdrs[n].p_vaddr))[m].r_info);
    382                    if (ri!=R_ARM_RBASE)
    383                    {
    384                      if (ri==R_ARM_RABS32)
    385                      {
    386                        *((long*)(base+((Elf32_Rel *)(reloc+dyn[DT_REL]-phdrs[n].p_vaddr))[m].r_offset))+=(long)base-minadr;
    387                      }
    388                      else
    389                        switch(ri)
    390                         {
    391                          case R_ARM_NONE: break; // ѕустой релокейшен
    392                          case R_ARM_ABS32:
    393          
    394                          *((long*)(base+((Elf32_Rel *)(reloc+dyn[DT_REL]-phdrs[n].p_vaddr))[m].r_offset-minadr))+=(long)base;
    395                          break;
    396                          
    397                          case R_ARM_RELATIVE: // ¬ообще говор€ не minadr а начало сегмента содержащего символ
    398                            
    399                          *((long*)(base+((Elf32_Rel *)(reloc+dyn[DT_REL]-phdrs[n].p_vaddr))[m].r_offset-minadr))+=(long)base-minadr;
    400                          break;  // »гнорируем
    401                          case R_ARM_RBASE: break;
    402                          
    403                          default: 	// Ќеизвестный тип релокации
    404                            fclose(fin, &iError);
    405                            mfree(base);
    406                            mfree(reloc);
    407                            return -12;
    408                         }
    409                     }
    410          	  m++;
    411          	 }
    412                 }
    413          
    414                 mfree(reloc);
   \                     ??elfload_29:
   \   000001AE   0398               LDR      R0,[SP, #+12]
   \   000001B0   15DF               SVC      +21
   \                     ??elfload_20:
   \   000001B2   0298               LDR      R0,[SP, #+8]
   \   000001B4   401C               ADDS     R0,R0,#+1
   \                     ??elfload_15:
   \   000001B6   0290               STR      R0,[SP, #+8]
   \   000001B8   0598               LDR      R0,[SP, #+20]
   \   000001BA   4142               RSBS     R1,R0,#+0
   \   000001BC   0791               STR      R1,[SP, #+28]
   \   000001BE   0298               LDR      R0,[SP, #+8]
   \   000001C0   09A9               ADD      R1,SP,#+36
   \   000001C2   898D               LDRH     R1,[R1, #+44]
   \   000001C4   8842               CMP      R0,R1
   \   000001C6   66DA               BGE      ??elfload_30
   \   000001C8   4001               LSLS     R0,R0,#+5
   \   000001CA   16A9               ADD      R1,SP,#+88
   \   000001CC   0818               ADDS     R0,R1,R0
   \   000001CE   0490               STR      R0,[SP, #+16]
   \   000001D0   6846               MOV      R0,SP
   \   000001D2   01B4               PUSH     {R0}
   \   000001D4   0598               LDR      R0,[SP, #+20]
   \   000001D6   01AB               ADD      R3,SP,#+4
   \   000001D8   4168               LDR      R1,[R0, #+4]
   \   000001DA   0298               LDR      R0,[SP, #+8]
   \   000001DC   0022               MOVS     R2,#+0
   \   000001DE   0FDF               SVC      +15
   \   000001E0   0599               LDR      R1,[SP, #+20]
   \   000001E2   4968               LDR      R1,[R1, #+4]
   \   000001E4   01B0               ADD      SP,SP,#+4
   \   000001E6   8842               CMP      R0,R1
   \   000001E8   8CD0               BEQ      ??elfload_16
   \   000001EA   0198               LDR      R0,[SP, #+4]
   \   000001EC   6946               MOV      R1,SP
   \   000001EE   0DDF               SVC      +13
   \   000001F0   2000               MOVS     R0,R4
   \   000001F2   15DF               SVC      +21
   \   000001F4   0520               MOVS     R0,#+5
   \   000001F6   21E7               B.N      ??elfload_3
   \                     ??elfload_31:
   \   000001F8   039D               LDR      R5,[SP, #+12]
   \   000001FA   EB18               ADDS     R3,R5,R3
   \   000001FC   9A18               ADDS     R2,R3,R2
   \   000001FE   059B               LDR      R3,[SP, #+20]
   \   00000200   5218               ADDS     R2,R2,R1
   \   00000202   1168               LDR      R1,[R2, #+0]
   \   00000204   6258               LDR      R2,[R4, R1]
   \   00000206   1219               ADDS     R2,R2,R4
   \   00000208   D21A               SUBS     R2,R2,R3
   \   0000020A   6250               STR      R2,[R4, R1]
   \                     ??elfload_32:
   \   0000020C   401C               ADDS     R0,R0,#+1
   \                     ??elfload_28:
   \   0000020E   789A               LDR      R2,[SP, #+480]
   \   00000210   C100               LSLS     R1,R0,#+3
   \   00000212   9142               CMP      R1,R2
   \   00000214   CBD2               BCS      ??elfload_29
   \   00000216   0499               LDR      R1,[SP, #+16]
   \   00000218   779B               LDR      R3,[SP, #+476]
   \   0000021A   8968               LDR      R1,[R1, #+8]
   \   0000021C   039D               LDR      R5,[SP, #+12]
   \   0000021E   4A42               RSBS     R2,R1,#+0
   \   00000220   C100               LSLS     R1,R0,#+3
   \   00000222   AD18               ADDS     R5,R5,R2
   \   00000224   6D18               ADDS     R5,R5,R1
   \   00000226   ED18               ADDS     R5,R5,R3
   \   00000228   6D68               LDR      R5,[R5, #+4]
   \   0000022A   2D06               LSLS     R5,R5,#+24
   \   0000022C   2D0E               LSRS     R5,R5,#+24
   \   0000022E   0695               STR      R5,[SP, #+24]
   \   00000230   FF2D               CMP      R5,#+255
   \   00000232   EBD0               BEQ      ??elfload_32
   \   00000234   FD2D               CMP      R5,#+253
   \   00000236   DFD0               BEQ      ??elfload_31
   \   00000238   079D               LDR      R5,[SP, #+28]
   \   0000023A   069E               LDR      R6,[SP, #+24]
   \   0000023C   6519               ADDS     R5,R4,R5
   \   0000023E   002E               CMP      R6,#+0
   \   00000240   E4D0               BEQ      ??elfload_32
   \   00000242   022E               CMP      R6,#+2
   \   00000244   04D0               BEQ      ??elfload_33
   \   00000246   172E               CMP      R6,#+23
   \   00000248   0BD0               BEQ      ??elfload_34
   \   0000024A   FF2E               CMP      R6,#+255
   \   0000024C   DED0               BEQ      ??elfload_32
   \   0000024E   12E0               B        ??elfload_35
   \                     ??elfload_33:
   \   00000250   039E               LDR      R6,[SP, #+12]
   \   00000252   F318               ADDS     R3,R6,R3
   \   00000254   9A18               ADDS     R2,R3,R2
   \   00000256   5218               ADDS     R2,R2,R1
   \   00000258   1168               LDR      R1,[R2, #+0]
   \   0000025A   6A58               LDR      R2,[R5, R1]
   \   0000025C   1219               ADDS     R2,R2,R4
   \                     ??elfload_36:
   \   0000025E   6A50               STR      R2,[R5, R1]
   \   00000260   D4E7               B        ??elfload_32
   \                     ??elfload_34:
   \   00000262   039E               LDR      R6,[SP, #+12]
   \   00000264   F318               ADDS     R3,R6,R3
   \   00000266   9A18               ADDS     R2,R3,R2
   \   00000268   059B               LDR      R3,[SP, #+20]
   \   0000026A   5218               ADDS     R2,R2,R1
   \   0000026C   1168               LDR      R1,[R2, #+0]
   \   0000026E   6A58               LDR      R2,[R5, R1]
   \   00000270   1219               ADDS     R2,R2,R4
   \   00000272   D21A               SUBS     R2,R2,R3
   \   00000274   F3E7               B.N      ??elfload_36
   \                     ??elfload_35:
   \   00000276   0198               LDR      R0,[SP, #+4]
   \   00000278   6946               MOV      R1,SP
   \   0000027A   0DDF               SVC      +13
   \   0000027C   2000               MOVS     R0,R4
   \   0000027E   15DF               SVC      +21
   \   00000280   0398               LDR      R0,[SP, #+12]
   \   00000282   15DF               SVC      +21
   \   00000284   0B20               MOVS     R0,#+11
   \   00000286   59E7               B.N      ??elfload_21
    415                 break;
    416                
    417                default:	// Ќеизвестный тип програмного сегмента
    418                 fclose(fin, &iError);
   \                     ??elfload_19:
   \   00000288   0198               LDR      R0,[SP, #+4]
   \   0000028A   6946               MOV      R1,SP
   \   0000028C   0DDF               SVC      +13
    419                 mfree(base);
   \   0000028E   2000               MOVS     R0,R4
   \   00000290   15DF               SVC      +21
    420                 return -11;
   \   00000292   0A20               MOVS     R0,#+10
   \   00000294   D2E6               B.N      ??elfload_3
    421              }
    422            }
    423          
    424            fclose(fin, &iError);
   \                     ??elfload_30:
   \   00000296   0198               LDR      R0,[SP, #+4]
   \   00000298   6946               MOV      R1,SP
   \   0000029A   0DDF               SVC      +13
    425            {
    426              extern __arm void ExecuteIMB(void);
    427              ExecuteIMB();	
   \   0000029C   ........           _BLF     ExecuteIMB,??ExecuteIMB??rT
    428            }
    429            ((TElfEntry *)(base+ehdr.e_entry-minadr))(filename,param1,param2,param3);
   \   000002A0   079D               LDR      R5,[SP, #+28]
   \   000002A2   0F9E               LDR      R6,[SP, #+60]
   \   000002A4   829B               LDR      R3,[SP, #+520]
   \   000002A6   819A               LDR      R2,[SP, #+516]
   \   000002A8   8099               LDR      R1,[SP, #+512]
   \   000002AA   7F98               LDR      R0,[SP, #+508]
   \   000002AC   A419               ADDS     R4,R4,R6
   \   000002AE   6419               ADDS     R4,R4,R5
   \   000002B0   A047               BLX      R4
    430            return 0;
   \   000002B2   0020               MOVS     R0,#+0
   \                     ??elfload_1:
   \   000002B4   7FB0               ADD      SP,SP,#+508
   \   000002B6   04B0               ADD      SP,SP,#+16
   \   000002B8   70BD               POP      {R4-R6,PC}
   \   000002BA   C046               Nop      
   \                     ??elfload_4:
   \   000002BC   7F454C46           DC32     0x464c457f
    431          }

   Maximum stack usage in bytes:

     Function  CSTACK
     --------  ------
     elfload     548
     zeromem_a     4


   Segment part sizes:

     Function/Label Bytes
     -------------- -----
     zeromem_a        12
     elfload         704
      Others          20

 
 736 bytes in segment CODE
 
 716 bytes of CODE memory (+ 20 bytes shared)

Errors: none
Warnings: none
