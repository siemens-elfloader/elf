##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    07/Mar/2011  11:51:11 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\elfpack_mod_last\main\edl.c                   #
#    Command line    =  C:\arm\elfpack_mod_last\main\edl.c -D NDEBUG -D X75  #
#                       -lCN C:\arm\elfpack_mod_last\Other\CX75sw25\List\    #
#                       -lb C:\arm\elfpack_mod_last\Other\CX75sw25\List\ -o  #
#                       C:\arm\elfpack_mod_last\Other\CX75sw25\Obj\ -s9      #
#                       --no_unroll --cpu_mode thumb --endian little --cpu   #
#                       ARM926EJ-S --stack_align 4 --interwork -e --fpu      #
#                       None -I "C:\arm2\Embedded Workbench 4.0              #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  C:\arm\elfpack_mod_last\Other\CX75sw25\List\edl.lst  #
#    Object file     =  C:\arm\elfpack_mod_last\Other\CX75sw25\Obj\edl.r79   #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\elfpack_mod_last\main\edl.c
      1          
      2          #include "..\..\inc\swilib.h"
      3          #include "edl.h"
      4          
      5          //Main pointer on EDL Base

   \                                 In segment DATA_Z, align 4, align-sorted
      6          int *pEDL_TOP = 0;
   \                     pEDL_TOP:
   \   00000000                      DS8 4
      7          
      8          
      9          // EDL System Init
     10          // 0 - EDL система уже запущена (EDL System is launched)
     11          // 1 - EDL система создана (EDL System is created)

   \                                 In segment CODE, align 4, keep-with-next
     12          __arm int EDL_system_init()
     13          {
   \                     EDL_system_init:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
     14           if (pEDL_TOP) return 0;
   \   00000004   ........           LDR      R4,??DataTable13  ;; pEDL_TOP
   \   00000008   000094E5           LDR      R0,[R4, #+0]
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0000A013           MOVNE    R0,#+0
   \   00000014   3080BD18           POPNE    {R4,R5,PC}
     15           pEDL_TOP = malloc(4*EDL_MAXSIZE);
   \   00000018   ........           LDR      R5,??DataTable14  ;; edl_sys_size
   \   0000001C   000095E5           LDR      R0,[R5, #+0]
   \   00000020   0001A0E1           LSL      R0,R0,#+2
   \   00000024   140000EF           SWI      +20
   \   00000028   000084E5           STR      R0,[R4, #+0]
     16           if (pEDL_TOP)
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   3080BD08           POPEQ    {R4,R5,PC}
     17            {
     18             for (int i = 0; i < EDL_MAXSIZE; i++)
   \   00000034   002095E5           LDR      R2,[R5, #+0]
   \   00000038   0010A0E3           MOV      R1,#+0
   \   0000003C   000052E3           CMP      R2,#+0
   \   00000040   0500001A           BNE      ??EDL_system_init_0
   \   00000044   0100A0E3           MOV      R0,#+1
   \   00000048   3080BDE8           POP      {R4,R5,PC}
     19              {
     20               pEDL_TOP[i] = EDL_VOID;
   \                     ??EDL_system_init_1:
   \   0000004C   DD22A0E3           MOV      R2,#-805306355
   \   00000050   DD2A82E3           ORR      R2,R2,#0xDD000
   \   00000054   012180E7           STR      R2,[R0, +R1, LSL #+2]
     21              }
   \   00000058   011081E2           ADD      R1,R1,#+1
   \                     ??EDL_system_init_0:
   \   0000005C   002095E5           LDR      R2,[R5, #+0]
   \   00000060   020051E1           CMP      R1,R2
   \   00000064   F8FFFF3A           BCC      ??EDL_system_init_1
     22            } else return 0; 
     23           return 1;
   \   00000068   0100A0E3           MOV      R0,#+1
   \   0000006C   3080BDE8           POP      {R4,R5,PC}       ;; return
     24          }
     25          
     26          // EDL System Kill
     27          // 0 - EDL система не запущена или не работает (EDL System don't load or don't work)
     28          // 1 - EDL система убита (EDL System is killed)

   \                                 In segment CODE, align 4, keep-with-next
     29          __arm int EDL_system_kill()
     30          {
   \                     EDL_system_kill:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
     31           if (pEDL_TOP)
   \   00000004   ........           LDR      R4,??DataTable13  ;; pEDL_TOP
   \   00000008   000094E5           LDR      R0,[R4, #+0]
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   F080BD08           POPEQ    {R4-R7,PC}
     32            {
     33              for (int i = 0; i<EDL_MAXSIZE; i++)
   \   00000014   ........           LDR      R5,??DataTable14  ;; edl_sys_size
   \   00000018   0060A0E3           MOV      R6,#+0
   \   0000001C   000095E5           LDR      R0,[R5, #+0]
   \   00000020   DD72A0E3           MOV      R7,#-805306355
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   DD7A87E3           ORR      R7,R7,#0xDD000
   \   0000002C   0B00001A           BNE      ??EDL_system_kill_0
   \   00000030   0D0000EA           B        ??EDL_system_kill_1
   \                     ??EDL_system_kill_2:
   \   00000034   000094E5           LDR      R0,[R4, #+0]
   \   00000038   060180E0           ADD      R0,R0,R6, LSL #+2
   \   0000003C   001090E5           LDR      R1,[R0, #+0]
   \   00000040   000051E3           CMP      R1,#+0
   \   00000044   07005101           CMPEQ    R1,R7
   \   00000048   0300000A           BEQ      ??EDL_system_kill_3
     34               {
     35                if (pEDL_TOP[i] != 0 || pEDL_TOP[i] != EDL_VOID)
     36                 {
     37                   EDL_HEADER *edl = (EDL_HEADER *)pEDL_TOP[i];
     38                   edl->killproc();
   \   0000004C   7C0091E5           LDR      R0,[R1, #+124]
   \   00000050   30FF2FE1           BLX      R0
     39                   pEDL_TOP[i] = EDL_VOID;
   \   00000054   000094E5           LDR      R0,[R4, #+0]
   \   00000058   067180E7           STR      R7,[R0, +R6, LSL #+2]
     40                 }
     41               }
   \                     ??EDL_system_kill_3:
   \   0000005C   016086E2           ADD      R6,R6,#+1
   \                     ??EDL_system_kill_0:
   \   00000060   000095E5           LDR      R0,[R5, #+0]
   \   00000064   000056E1           CMP      R6,R0
   \   00000068   F1FFFF3A           BCC      ??EDL_system_kill_2
     42              
     43              zeromem((void *)pEDL_TOP, EDL_MAXSIZE*4);
   \                     ??EDL_system_kill_1:
   \   0000006C   000095E5           LDR      R0,[R5, #+0]
   \   00000070   0011A0E1           LSL      R1,R0,#+2
   \   00000074   000094E5           LDR      R0,[R4, #+0]
   \   00000078   1D0100EF           SWI      +285
     44              mfree(pEDL_TOP);
   \   0000007C   000094E5           LDR      R0,[R4, #+0]
   \   00000080   150000EF           SWI      +21
     45              pEDL_TOP = 0;
   \   00000084   0000A0E3           MOV      R0,#+0
   \   00000088   000084E5           STR      R0,[R4, #+0]
     46              return 1;
   \   0000008C   0100A0E3           MOV      R0,#+1
     47            }
     48           return 0;
   \   00000090   F080BDE8           POP      {R4-R7,PC}       ;; return
     49          }
     50          
     51          // EDL System ReInit

   \                                 In segment CODE, align 4, keep-with-next
     52          __arm int EDL_system_reinit()
     53          {
   \                     EDL_system_reinit:
   \   00000000   00402DE9           PUSH     {LR}
     54           if (EDL_system_kill())
   \   00000004   ........           BL       EDL_system_kill
     55            {
     56             return EDL_system_init();
     57            } 
     58            else
     59             return EDL_system_init();
   \   00000008   0040BDE8           POP      {LR}             ;; Pop
   \   0000000C   ........           B        EDL_system_init  ;; tailcall
     60          }
     61          
     62          //-1 - Не найдено! (No find)
     63          //-2 - EDL система не запущена или не работает (EDL System don't load or don't work)
     64          //+i - Отражает позицию найденной библиотеки (Place find lib)

   \                                 In segment CODE, align 4, keep-with-next
     65          __arm int isEDL_exist_ep(char *name, short version)
     66          {
   \                     isEDL_exist_ep:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
     67            if (!pEDL_TOP) return -2;
   \   00000004   ........           LDR      R6,??DataTable13  ;; pEDL_TOP
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   000096E5           LDR      R0,[R6, #+0]
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0100E003           MVNEQ    R0,#+1
   \   0000001C   F083BD08           POPEQ    {R4-R9,PC}
     68            for (int i = 0; i<EDL_MAXSIZE; i++)
   \   00000020   ........           LDR      R7,??DataTable14  ;; edl_sys_size
   \   00000024   0080A0E3           MOV      R8,#+0
   \   00000028   000000EA           B        ??isEDL_exist_ep_0
   \                     ??isEDL_exist_ep_1:
   \   0000002C   018088E2           ADD      R8,R8,#+1
   \                     ??isEDL_exist_ep_0:
   \   00000030   000097E5           LDR      R0,[R7, #+0]
   \   00000034   000058E1           CMP      R8,R0
   \   00000038   1000002A           BCS      ??isEDL_exist_ep_2
   \   0000003C   000096E5           LDR      R0,[R6, #+0]
   \   00000040   DD22A0E3           MOV      R2,#-805306355
   \   00000044   080180E0           ADD      R0,R0,R8, LSL #+2
   \   00000048   001090E5           LDR      R1,[R0, #+0]
   \   0000004C   DD2A82E3           ORR      R2,R2,#0xDD000
   \   00000050   020051E1           CMP      R1,R2
   \   00000054   F4FFFF0A           BEQ      ??isEDL_exist_ep_1
     69             {
     70              if (pEDL_TOP[i] != EDL_VOID)
     71               {
     72                EDL_HEADER *edl_struct = (EDL_HEADER *)pEDL_TOP[i];
   \   00000058   0190A0E1           MOV      R9,R1
     73                
     74                if (!strcmp(name, edl_struct->name))
   \   0000005C   0C1089E2           ADD      R1,R9,#+12
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   190000EF           SWI      +25
   \   00000068   000050E3           CMP      R0,#+0
     75                 {
     76                  if (version == edl_struct->version) return i;
   \   0000006C   FC06D901           LDRSHEQ  R0,[R9, #+108]
   \   00000070   00005501           CMPEQ    R5,R0
   \   00000074   ECFFFF1A           BNE      ??isEDL_exist_ep_1
   \   00000078   0800A0E1           MOV      R0,R8
   \   0000007C   F083BDE8           POP      {R4-R9,PC}
     77                 }
     78                }
     79              }
     80             return -1;
   \                     ??isEDL_exist_ep_2:
   \   00000080   0000E0E3           MVN      R0,#+0
   \   00000084   F083BDE8           POP      {R4-R9,PC}       ;; return
     81          }
     82          
     83          //0 - Библиотека не поддерживается (Current Library don't support)
     84          //1 - Библиотека поддерживается (Current Library support)

   \                                 In segment CODE, align 4, keep-with-next
     85          __arm int isEDL_support_ep(char platform, char *phone, short sw)
     86          {
   \                     isEDL_support_ep:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
     87           if (!platform) return 1;
   \   00000014   000054E3           CMP      R4,#+0
   \   00000018   0100001A           BNE      ??isEDL_support_ep_0
   \                     ??isEDL_support_ep_1:
   \   0000001C   0100A0E3           MOV      R0,#+1
   \   00000020   F680BDE8           POP      {R1,R2,R4-R7,PC}
     88           else
     89            {
     90             char p = 0; 
   \                     ??isEDL_support_ep_0:
   \   00000024   0070A0E3           MOV      R7,#+0
     91             if (isSGoldX75() == 0) p =  platform&EDL_PLATFORM_SGX65;
   \   00000028   008300EF           SWI      +33536
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   01700402           ANDEQ    R7,R4,#0x1
     92             if (isSGoldX75() == 1) p = (platform&EDL_PLATFORM_SGX75)>>1;
   \   00000034   008300EF           SWI      +33536
   \   00000038   010050E3           CMP      R0,#+1
   \   0000003C   02000402           ANDEQ    R0,R4,#0x2
   \   00000040   C070A001           ASREQ    R7,R0,#+1
     93             if (isSGoldX75() == 2) p = (platform&EDL_PLATFORM_NSG)>>2;
   \   00000044   008300EF           SWI      +33536
   \   00000048   020050E3           CMP      R0,#+2
   \   0000004C   04000402           ANDEQ    R0,R4,#0x4
   \   00000050   4071A001           ASREQ    R7,R0,#+2
     94             if (isSGoldX75() == 3) p = (platform&EDL_PLATFORM_ELKA)>>3;
   \   00000054   008300EF           SWI      +33536
   \   00000058   030050E3           CMP      R0,#+3
   \   0000005C   08000402           ANDEQ    R0,R4,#0x8
   \   00000060   C071A001           ASREQ    R7,R0,#+3
     95             
     96             if (p == 1)
   \   00000064   FF7007E2           AND      R7,R7,#0xFF
   \   00000068   010057E3           CMP      R7,#+1
   \   0000006C   1800001A           BNE      ??isEDL_support_ep_2
     97              {
     98               if (!strcmp(phone, EDL_PHONE_NONE) || !strcmp(phone, Get_Phone_Info(PI_MODEL)))
   \   00000070   68109FE5           LDR      R1,??isEDL_support_ep_3+0x4  ;; `?<Constant "NONE">`
   \   00000074   0500A0E1           MOV      R0,R5
   \   00000078   190000EF           SWI      +25
   \   0000007C   000050E3           CMP      R0,#+0
   \   00000080   0600000A           BEQ      ??isEDL_support_ep_4
   \   00000084   0900A0E3           MOV      R0,#+9
   \   00000088   D50100EF           SWI      +469
   \   0000008C   0010A0E1           MOV      R1,R0
   \   00000090   0500A0E1           MOV      R0,R5
   \   00000094   190000EF           SWI      +25
   \   00000098   000050E3           CMP      R0,#+0
   \   0000009C   0C00001A           BNE      ??isEDL_support_ep_2
     99                {
    100                 char sw_str[8];
    101                 sprintf(sw_str, "%d", sw);
   \                     ??isEDL_support_ep_4:
   \   000000A0   0620A0E1           MOV      R2,R6
   \   000000A4   0C1F8FE2           ADR      R1,??isEDL_support_ep_3  ;; "%d"
   \   000000A8   0D00A0E1           MOV      R0,SP
   \   000000AC   160000EF           SWI      +22
    102                 if (!sw || !strcmp(sw_str, Get_Phone_Info(PI_SW_NUMBER))) return 1;
   \   000000B0   000056E3           CMP      R6,#+0
   \   000000B4   D8FFFF0A           BEQ      ??isEDL_support_ep_1
   \   000000B8   0700A0E3           MOV      R0,#+7
   \   000000BC   D50100EF           SWI      +469
   \   000000C0   0010A0E1           MOV      R1,R0
   \   000000C4   0D00A0E1           MOV      R0,SP
   \   000000C8   190000EF           SWI      +25
   \   000000CC   000050E3           CMP      R0,#+0
   \   000000D0   D1FFFF0A           BEQ      ??isEDL_support_ep_1
    103                }
    104              }
    105            }
    106           return 0;
   \                     ??isEDL_support_ep_2:
   \   000000D4   0000A0E3           MOV      R0,#+0
   \   000000D8   F680BDE8           POP      {R1,R2,R4-R7,PC}  ;; return
   \                     ??isEDL_support_ep_3:
   \   000000DC   25640000           DC8      "%d",+0
   \   000000E0   ........           DC32     `?<Constant "NONE">`
    107          }
    108          
    109          // -100  - Нет фаила (File is not find)
    110          // -101  - Фаил не открывается/не читается (File don't open / don't read)
    111          // -102  - Недостаточно памяти (Is not memory)
    112          // -103  - Cтруктура EDL_HEADER не обнаружена (EDL_HEADER struct is not detect)
    113          // -104  - EDL система не работает или не запущена (EDL system don't work or don't load)
    114          // -105  - Данная библиотека уже существует (Library is exist)
    115          // -106  - В библиотеке нет ни одной ф-ии (In library zero count functions)
    116          // -107  - Библиотека не поддерживается (Library is not support)
    117          
    118          // -1 .. -13 - Ошибки формата 'ELF' (Errors of ELF format)
    119          
    120          // +i    - Библиотека загружена! i - отражает кол-во ф-ий (Library is loaded, i is count functions of library)

   \                                 In segment CODE, align 4, keep-with-next
    121          __arm int EDL_load_ep(char *fname)
    122          {
   \                     EDL_load_ep:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   43DF4DE2           SUB      SP,SP,#+268
    123            char fn[256];
    124            strcpy(fn, fname);
    125            if (fname[1] != ':')
   \   00000008   C0419FE5           LDR      R4,??EDL_load_ep_0+0x4  ;; `?<Constant {-572657938, 857809203, -286335523}`
   \   0000000C   0050A0E1           MOV      R5,R0
   \   00000010   0510A0E1           MOV      R1,R5
   \   00000014   0C008DE2           ADD      R0,SP,#+12
   \   00000018   1A0000EF           SWI      +26
   \   0000001C   0100D5E5           LDRB     R0,[R5, #+1]
   \   00000020   3A0050E3           CMP      R0,#+58
   \   00000024   0700000A           BEQ      ??EDL_load_ep_1
    126             {
    127               sprintf(fn, "X:\\Zbin\\libs\\%s.edl", fname);
   \   00000028   0520A0E1           MOV      R2,R5
   \   0000002C   0C1084E2           ADD      R1,R4,#+12
   \   00000030   0C008DE2           ADD      R0,SP,#+12
   \   00000034   160000EF           SWI      +22
    128               fn[0] = '0' + DEFAULT_DISK_N;
   \   00000038   94119FE5           LDR      R1,??EDL_load_ep_0+0x8  ;; DEFAULT_DISK_N
   \   0000003C   001091E5           LDR      R1,[R1, #+0]
   \   00000040   301081E2           ADD      R1,R1,#+48
   \   00000044   0C10CDE5           STRB     R1,[SP, #+12]
    129             }
    130            
    131            int edl_size = get_file_size(fn);
   \                     ??EDL_load_ep_1:
   \   00000048   0C008DE2           ADD      R0,SP,#+12
   \   0000004C   ........           _BLF     get_file_size,??get_file_size??rA
   \   00000050   0060A0E1           MOV      R6,R0
    132            if (edl_size == -1) return -100;
   \   00000054   0050E0E3           MVN      R5,#+0
   \   00000058   050056E1           CMP      R6,R5
   \   0000005C   6300C503           BICEQ    R0,R5,#0x63
   \   00000060   5700000A           BEQ      ??EDL_load_ep_2
    133            int edl = fopen(fn, A_ReadOnly+A_BIN, P_READ, 0);
   \   00000064   0030A0E3           MOV      R3,#+0
   \   00000068   8020A0E3           MOV      R2,#+128
   \   0000006C   801CA0E3           MOV      R1,#+32768
   \   00000070   0C008DE2           ADD      R0,SP,#+12
   \   00000074   0A0000EF           SWI      +10
   \   00000078   0080B0E1           MOVS     R8,R0
    134            if (edl < 0) return -101;
   \   0000007C   6400C543           BICMI    R0,R5,#0x64
   \   00000080   4F00004A           BMI      ??EDL_load_ep_2
    135            
    136            
    137            char *data = malloc(edl_size);
   \   00000084   0600A0E1           MOV      R0,R6
   \   00000088   140000EF           SWI      +20
   \   0000008C   0070B0E1           MOVS     R7,R0
    138            if (!data) return -102;
   \   00000090   6500C503           BICEQ    R0,R5,#0x65
   \   00000094   4A00000A           BEQ      ??EDL_load_ep_2
    139               
    140            fread(edl, data, edl_size, 0);
   \   00000098   0030A0E3           MOV      R3,#+0
   \   0000009C   0620A0E1           MOV      R2,R6
   \   000000A0   0710A0E1           MOV      R1,R7
   \   000000A4   0800A0E1           MOV      R0,R8
   \   000000A8   0B0000EF           SWI      +11
    141            fclose(edl, 0);
   \   000000AC   0010A0E3           MOV      R1,#+0
   \   000000B0   0800A0E1           MOV      R0,R8
   \   000000B4   0D0000EF           SWI      +13
    142               
    143            int edlpos = 0;
    144            int edl_id[3]={EDL_ID1,EDL_ID2,EDL_ID3};
   \   000000B8   0E0094E8           LDM      R4,{R1-R3}
   \   000000BC   0D00A0E1           MOV      R0,SP
   \   000000C0   0E0080E8           STM      R0,{R1-R3}
    145            for (int i=0; i<edl_size; i++)
   \   000000C4   0040A0E3           MOV      R4,#+0
   \   000000C8   000000EA           B        ??EDL_load_ep_3
   \                     ??EDL_load_ep_4:
   \   000000CC   014084E2           ADD      R4,R4,#+1
   \                     ??EDL_load_ep_3:
   \   000000D0   060054E1           CMP      R4,R6
   \   000000D4   240000AA           BGE      ??EDL_load_ep_5
    146             {
    147              if (memcmp((char *)data + i, (char *)edl_id, 12) == 0)
   \   000000D8   0C20A0E3           MOV      R2,#+12
   \   000000DC   0D10A0E1           MOV      R1,SP
   \   000000E0   070084E0           ADD      R0,R4,R7
   \   000000E4   1C0100EF           SWI      +284
   \   000000E8   000050E3           CMP      R0,#+0
   \   000000EC   F6FFFF1A           BNE      ??EDL_load_ep_4
    148               {
    149                edlpos = i;
    150                goto END_SCAN_EDLFILE;
    151               }
    152              }
    153            
    154            return -103;
    155            
    156            END_SCAN_EDLFILE:
    157            
    158            asm("NOP");
   \   000000F0   0000A0E1           NOP              
    159             
    160            EDL_HEADER *edls = malloc(sizeof(EDL_HEADER));
   \   000000F4   8000A0E3           MOV      R0,#+128
   \   000000F8   140000EF           SWI      +20
   \   000000FC   0080A0E1           MOV      R8,R0
    161            memcpy(edls, data + edlpos, sizeof(EDL_HEADER));
   \   00000100   8020A0E3           MOV      R2,#+128
   \   00000104   071084E0           ADD      R1,R4,R7
   \   00000108   1E0100EF           SWI      +286
    162             
    163            zeromem((void *)data, edl_size);
   \   0000010C   0610A0E1           MOV      R1,R6
   \   00000110   0700A0E1           MOV      R0,R7
   \   00000114   1D0100EF           SWI      +285
    164            mfree(data);
   \   00000118   0700A0E1           MOV      R0,R7
   \   0000011C   150000EF           SWI      +21
    165          
    166             int ex = isEDL_exist_ep(edls->name, edls->version);
   \   00000120   FC16D8E1           LDRSH    R1,[R8, #+108]
   \   00000124   0C0088E2           ADD      R0,R8,#+12
   \   00000128   ........           BL       isEDL_exist_ep
   \   0000012C   0040A0E1           MOV      R4,R0
    167             if (ex == -1)
   \   00000130   050054E1           CMP      R4,R5
   \   00000134   1D00001A           BNE      ??EDL_load_ep_6
    168              {
    169               if (isEDL_support_ep(edls->platform, edls->phone, edls->sw))
   \   00000138   7000D8E5           LDRB     R0,[R8, #+112]
   \   0000013C   FA27D8E1           LDRSH    R2,[R8, #+122]
   \   00000140   711088E2           ADD      R1,R8,#+113
   \   00000144   ........           BL       isEDL_support_ep
   \   00000148   000050E3           CMP      R0,#+0
   \   0000014C   1300000A           BEQ      ??EDL_load_ep_7
    170                {
    171                 short count = edls->count;
   \   00000150   FE46D8E1           LDRSH    R4,[R8, #+110]
    172                 mfree(edls);
   \   00000154   0800A0E1           MOV      R0,R8
   \   00000158   150000EF           SWI      +21
    173                 if (!count) return -106;
   \   0000015C   000054E3           CMP      R4,#+0
   \   00000160   0400001A           BNE      ??EDL_load_ep_8
   \   00000164   6900C5E3           BIC      R0,R5,#0x69
   \   00000168   000000EA           B        ??EDL_load_ep_9
   \                     ??EDL_load_ep_5:
   \   0000016C   6600C5E3           BIC      R0,R5,#0x66
   \                     ??EDL_load_ep_9:
   \   00000170   43DF8DE2           ADD      SP,SP,#+268
   \   00000174   F081BDE8           POP      {R4-R8,PC}
    174                 short res = elfload(fn, "", 0, 0);
   \                     ??EDL_load_ep_8:
   \   00000178   0030A0E3           MOV      R3,#+0
   \   0000017C   0020A0E3           MOV      R2,#+0
   \   00000180   111F8FE2           ADR      R1,??EDL_load_ep_0  ;; ""
   \   00000184   0C008DE2           ADD      R0,SP,#+12
   \   00000188   ........           _BLF     elfload,??elfload??rA
   \   0000018C   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000190   4008B0E1           MOVS     R0,R0, ASR #+16
    175                 if (!res) return count;
   \   00000194   0A00001A           BNE      ??EDL_load_ep_2
   \   00000198   0400A0E1           MOV      R0,R4
   \   0000019C   F3FFFFEA           B        ??EDL_load_ep_9
    176                      else return res;
    177                } else 
    178                   {
    179                    mfree(edls);
   \                     ??EDL_load_ep_7:
   \   000001A0   0800A0E1           MOV      R0,R8
   \   000001A4   150000EF           SWI      +21
    180                    return -107;
   \   000001A8   6A00C5E3           BIC      R0,R5,#0x6A
   \   000001AC   EFFFFFEA           B        ??EDL_load_ep_9
    181                   }
    182              } else 
    183                   {
    184                    mfree(edls);
   \                     ??EDL_load_ep_6:
   \   000001B0   0800A0E1           MOV      R0,R8
   \   000001B4   150000EF           SWI      +21
    185                    if (ex == -2) return -104; 
   \   000001B8   020074E3           CMN      R4,#+2
   \   000001BC   6700C503           BICEQ    R0,R5,#0x67
    186                             else return -105;
   \   000001C0   6800C513           BICNE    R0,R5,#0x68
   \                     ??EDL_load_ep_2:
   \   000001C4   43DF8DE2           ADD      SP,SP,#+268      ;; stack cleaning
   \   000001C8   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??EDL_load_ep_0:
   \   000001CC   00000000           DC8      "",+0,+0,+0
   \   000001D0   ........           DC32     `?<Constant {-572657938, 857809203, -286335523}`
   \   000001D4   ........           DC32     DEFAULT_DISK_N
    187                   }
    188          }
    189          
    190          
    191          //  0 - Библиотека не существует (Library is not exist)
    192          // -1 - EDL система не работает или не запущена (EDL system don't work or don't load)
    193          //  1 - Библиотека выгружена (Library unload from RAM)

   \                                 In segment CODE, align 4, keep-with-next
    194          __arm int EDL_unload_ep(char *name, short version)
    195          {
   \                     EDL_unload_ep:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    196            int plc = isEDL_exist_ep(name, version);
   \   00000004   ........           BL       isEDL_exist_ep
   \   00000008   0040A0E1           MOV      R4,R0
    197            if (plc == -1) return 0;
   \   0000000C   010074E3           CMN      R4,#+1
   \   00000010   0F00000A           BEQ      ??EDL_unload_ep_0
    198            if (plc == -2) return -1;
   \   00000014   020074E3           CMN      R4,#+2
   \   00000018   0000E003           MVNEQ    R0,#+0
   \   0000001C   3080BD08           POPEQ    {R4,R5,PC}
    199            if (plc >= 0)
   \   00000020   000054E3           CMP      R4,#+0
   \   00000024   0A00004A           BMI      ??EDL_unload_ep_0
    200             {
    201               EDL_HEADER *edl = (EDL_HEADER *)pEDL_TOP[plc];
    202               edl->killproc();
   \   00000028   ........           LDR      R5,??DataTable13  ;; pEDL_TOP
   \   0000002C   000095E5           LDR      R0,[R5, #+0]
   \   00000030   040190E7           LDR      R0,[R0, +R4, LSL #+2]
   \   00000034   7C0090E5           LDR      R0,[R0, #+124]
   \   00000038   30FF2FE1           BLX      R0
    203               pEDL_TOP[plc] = EDL_VOID;
   \   0000003C   000095E5           LDR      R0,[R5, #+0]
   \   00000040   DD12A0E3           MOV      R1,#-805306355
   \   00000044   DD1A81E3           ORR      R1,R1,#0xDD000
   \   00000048   041180E7           STR      R1,[R0, +R4, LSL #+2]
    204               return 1;
   \   0000004C   0100A0E3           MOV      R0,#+1
   \   00000050   3080BDE8           POP      {R4,R5,PC}
    205             }
    206            else return 0;
   \                     ??EDL_unload_ep_0:
   \   00000054   0000A0E3           MOV      R0,#+0
   \   00000058   3080BDE8           POP      {R4,R5,PC}       ;; return
    207          }
    208          
    209          
    210          
    211          //  0 - Библиотека уже существует (Library is exist)
    212          // -1 - EDL система не работает или не запущена (EDL system don't work or don't load)
    213          //  1 - Добавлена (Library added in base)

   \                                 In segment CODE, align 4, keep-with-next
    214          __arm int EDL_addlib_ep(EDL_STRUCT *edl_struct)
    215          {
   \                     EDL_addlib_ep:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    216            int plc = isEDL_exist_ep(edl_struct->edl_head.name, edl_struct->edl_head.version);
   \   00000008   FC16D4E1           LDRSH    R1,[R4, #+108]
   \   0000000C   0C0084E2           ADD      R0,R4,#+12
   \   00000010   ........           BL       isEDL_exist_ep
    217            if (plc >= 0) return 0;
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0000A053           MOVPL    R0,#+0
   \   0000001C   1080BD58           POPPL    {R4,PC}
    218            else
    219               {
    220                if (plc == -1)
   \   00000020   010070E3           CMN      R0,#+1
   \   00000024   1100001A           BNE      ??EDL_addlib_ep_0
    221                 {
    222                  for (int i = 0; i<EDL_MAXSIZE; i++)
   \   00000028   ........           LDR      R1,??DataTable14  ;; edl_sys_size
   \   0000002C   0000A0E3           MOV      R0,#+0
   \   00000030   001091E5           LDR      R1,[R1, #+0]
   \   00000034   DDC2A0E3           MOV      R12,#-805306355
   \   00000038   DDCA8CE3           ORR      R12,R12,#0xDD000
   \   0000003C   000000EA           B        ??EDL_addlib_ep_1
   \                     ??EDL_addlib_ep_2:
   \   00000040   010080E2           ADD      R0,R0,#+1
   \                     ??EDL_addlib_ep_1:
   \   00000044   010050E1           CMP      R0,R1
   \   00000048   0800002A           BCS      ??EDL_addlib_ep_0
   \   0000004C   ........           LDR      R2,??DataTable13  ;; pEDL_TOP
   \   00000050   002092E5           LDR      R2,[R2, #+0]
   \   00000054   002182E0           ADD      R2,R2,R0, LSL #+2
   \   00000058   003092E5           LDR      R3,[R2, #+0]
   \   0000005C   0C0053E1           CMP      R3,R12
   \   00000060   F6FFFF1A           BNE      ??EDL_addlib_ep_2
    223                   {
    224                     if (pEDL_TOP[i] == EDL_VOID)
    225                      {
    226                       pEDL_TOP[i] = (int)edl_struct;
   \   00000064   004082E5           STR      R4,[R2, #+0]
    227                       return 1;
   \   00000068   0100A0E3           MOV      R0,#+1
   \   0000006C   1080BDE8           POP      {R4,PC}
    228                      }
    229                   }
    230                 } else return -1;
    231               }
    232            return -1;
   \                     ??EDL_addlib_ep_0:
   \   00000070   0000E0E3           MVN      R0,#+0
   \   00000074   1080BDE8           POP      {R4,PC}          ;; return
    233          }
    234          
    235          
    236          //  0 - Библиотека не существует (Library is not exist)
    237          // -1 - EDL система не работает или не запущена (EDL system don't work or don't load)
    238          //  1 - Библиотека убрана из системы (Но ещё висит в RAM) / Library is removed, but she in RAM

   \                                 In segment CODE, align 4, keep-with-next
    239          __arm int EDL_remove_ep(EDL_STRUCT *edl_struct)
    240          {
   \                     EDL_remove_ep:
   \   00000000   00402DE9           PUSH     {LR}
    241            int plc = isEDL_exist_ep(edl_struct->edl_head.name, edl_struct->edl_head.version);
   \   00000004   FC16D0E1           LDRSH    R1,[R0, #+108]
   \   00000008   0C0080E2           ADD      R0,R0,#+12
   \   0000000C   ........           BL       isEDL_exist_ep
    242            if (plc == -1) return 0;
   \   00000010   010070E3           CMN      R0,#+1
   \   00000014   0B00000A           BEQ      ??EDL_remove_ep_0
    243            if (plc == -2) return -1;
   \   00000018   020070E3           CMN      R0,#+2
   \   0000001C   0000E003           MVNEQ    R0,#+0
   \   00000020   0080BD08           POPEQ    {PC}
    244            if (plc >=  0)
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   0600004A           BMI      ??EDL_remove_ep_0
    245              {
    246                pEDL_TOP[plc] = EDL_VOID;
   \   0000002C   ........           LDR      R1,??DataTable13  ;; pEDL_TOP
   \   00000030   DD22A0E3           MOV      R2,#-805306355
   \   00000034   001091E5           LDR      R1,[R1, #+0]
   \   00000038   DD2A82E3           ORR      R2,R2,#0xDD000
   \   0000003C   002181E7           STR      R2,[R1, +R0, LSL #+2]
    247                return 1;
   \   00000040   0100A0E3           MOV      R0,#+1
   \   00000044   0080BDE8           POP      {PC}
    248              }
    249            return 0;
   \                     ??EDL_remove_ep_0:
   \   00000048   0000A0E3           MOV      R0,#+0
   \   0000004C   0080BDE8           POP      {PC}             ;; return
    250          }
    251          
    252          
    253          //  0 - Библиотека не существует (Library is not exist)
    254          // -1 - EDL система не работает или не запущена (EDL system don't work or don't load)
    255          //  1 - Адреса ф-ий заполнены (Addresses functions filled) 

   \                                 In segment CODE, align 4, keep-with-next
    256          __arm int EDL_use_ep(char *name, short version, void *func_struct)
    257          {
   \                     EDL_use_ep:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0240A0E1           MOV      R4,R2
    258           int pls = isEDL_exist_ep(name, version);
   \   00000008   ........           BL       isEDL_exist_ep
    259           if (pls == -1) return 0;
   \   0000000C   010070E3           CMN      R0,#+1
   \   00000010   0000A003           MOVEQ    R0,#+0
   \   00000014   1080BD08           POPEQ    {R4,PC}
    260           if (pls == -2) return -1;
   \   00000018   020070E3           CMN      R0,#+2
   \   0000001C   0000E003           MVNEQ    R0,#+0
   \   00000020   1080BD08           POPEQ    {R4,PC}
    261           else
    262            {
    263             EDL_STRUCT *edl = (EDL_STRUCT *)pEDL_TOP[pls];
   \   00000024   ........           LDR      R1,??DataTable13  ;; pEDL_TOP
   \   00000028   001091E5           LDR      R1,[R1, #+0]
   \   0000002C   000191E7           LDR      R0,[R1, +R0, LSL #+2]
    264             memcpy(func_struct, &edl->edl_pnt.func_first, edl->edl_head.count*4);
   \   00000030   FE16D0E1           LDRSH    R1,[R0, #+110]
   \   00000034   0121A0E1           LSL      R2,R1,#+2
   \   00000038   801080E2           ADD      R1,R0,#+128
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   1E0100EF           SWI      +286
    265             return 1;
   \   00000044   0100A0E3           MOV      R0,#+1
   \   00000048   1080BDE8           POP      {R4,PC}          ;; return
    266            }
    267          }
    268          
    269          // Возвращает указатель на базу библиотеки (Return pointer on Library)

   \                                 In segment CODE, align 4, keep-with-next
    270          __arm void *getEDL_baseAddr_ep()
    271          {
    272           return pEDL_TOP;
   \                     getEDL_baseAddr_ep:
   \   00000000   ........           LDR      R0,??DataTable13  ;; pEDL_TOP
   \   00000004   000090E5           LDR      R0,[R0, #+0]
   \   00000008   1EFF2FE1           BX       LR               ;; return
    273          }
    274          
    275          // Возвращает текущее кол-во загруженных библиотек (Return сurrent count libs)

   \                                 In segment CODE, align 4, keep-with-next
    276          __arm int getEDL_curLibs_ep()
    277          {
    278           int cur = 0; 
    279           for (int i = 0; i<EDL_MAXSIZE; i++)
   \                     getEDL_curLibs_ep:
   \   00000000   ........           LDR      R2,??DataTable14  ;; edl_sys_size
   \   00000004   0000A0E3           MOV      R0,#+0
   \   00000008   002092E5           LDR      R2,[R2, #+0]
   \   0000000C   0010A0E3           MOV      R1,#+0
   \   00000010   000052E3           CMP      R2,#+0
   \   00000014   DDC2A0E3           MOV      R12,#-805306355
   \   00000018   DDCA8CE3           ORR      R12,R12,#0xDD000
   \   0000001C   0600001A           BNE      ??getEDL_curLibs_ep_0
   \   00000020   1EFF2FE1           BX       LR
    280            {
    281             if (pEDL_TOP[i] != EDL_VOID) cur++;
   \                     ??getEDL_curLibs_ep_1:
   \   00000024   ........           LDR      R3,??DataTable13  ;; pEDL_TOP
   \   00000028   003093E5           LDR      R3,[R3, #+0]
   \   0000002C   013193E7           LDR      R3,[R3, +R1, LSL #+2]
    282            }
   \   00000030   011081E2           ADD      R1,R1,#+1
   \   00000034   0C0053E1           CMP      R3,R12
   \   00000038   01008012           ADDNE    R0,R0,#+1
   \                     ??getEDL_curLibs_ep_0:
   \   0000003C   020051E1           CMP      R1,R2
   \   00000040   F7FFFF3A           BCC      ??getEDL_curLibs_ep_1
    283           return cur;
   \   00000044   1EFF2FE1           BX       LR               ;; return
    284          }
    285          
    286          // Возвращает максимальное кол-во загружаемых библиотек (Return max count libs)

   \                                 In segment CODE, align 4, keep-with-next
    287          __arm int getEDL_maxLibs_ep()
    288          {
    289           return EDL_MAXSIZE;
   \                     getEDL_maxLibs_ep:
   \   00000000   ........           LDR      R0,??DataTable14  ;; edl_sys_size
   \   00000004   000090E5           LDR      R0,[R0, #+0]
   \   00000008   1EFF2FE1           BX       LR               ;; return
    290          }
    291          
    292          
    293          // isSGoldX75()
    294          #ifdef NEWSGOLD
    295          #ifdef ELKA
    296          #pragma diag_suppress=Pe177
    297          __root static const int SWILIB_FUNC300 @ "SWILIB_FUNC300_30A" = 0x00000003;
    298          #pragma diag_default=Pe177
    299          #else
    300          #pragma diag_suppress=Pe177
    301          __root static const int SWILIB_FUNC300 @ "SWILIB_FUNC300_30A" = 0x00000002;
    302          #pragma diag_default=Pe177
    303          #endif
    304          #else
    305          #ifdef X75
    306          #pragma diag_suppress=Pe177

   \                                 In segment SWILIB_FUNC300_30A, align 4, align-sorted, root
   \   00000000   01000000           DC32 1
    307          __root static const int SWILIB_FUNC300 @ "SWILIB_FUNC300_30A" = 0x00000001;
    308          #pragma diag_default=Pe177
    309          #else
    310          #pragma diag_suppress=Pe177
    311          __root static const int SWILIB_FUNC300 @ "SWILIB_FUNC300_30A" = 0x00000000;
    312          #pragma diag_default=Pe177
    313          #endif
    314          #endif
    315          
    316          
    317          
    318          #pragma diag_suppress=Pe177

   \                                 In segment SWILIB_FUNC300_30A, align 4, align-sorted, root
   \   00000000   ........           DC32 EDL_load_ep
    319          __root static const int SWILIB_FUNC301 @ "SWILIB_FUNC300_30A" = (int)EDL_load_ep;

   \                                 In segment SWILIB_FUNC300_30A, align 4, align-sorted, root
   \   00000000   ........           DC32 EDL_unload_ep
    320          __root static const int SWILIB_FUNC302 @ "SWILIB_FUNC300_30A" = (int)EDL_unload_ep;
    321          

   \                                 In segment SWILIB_FUNC300_30A, align 4, align-sorted, root
   \   00000000   ........           DC32 EDL_addlib_ep
    322          __root static const int SWILIB_FUNC303 @ "SWILIB_FUNC300_30A" = (int)EDL_addlib_ep;

   \                                 In segment SWILIB_FUNC300_30A, align 4, align-sorted, root
   \   00000000   ........           DC32 EDL_remove_ep
    323          __root static const int SWILIB_FUNC304 @ "SWILIB_FUNC300_30A" = (int)EDL_remove_ep;

   \                                 In segment SWILIB_FUNC300_30A, align 4, align-sorted, root
   \   00000000   ........           DC32 EDL_use_ep
    324          __root static const int SWILIB_FUNC305 @ "SWILIB_FUNC300_30A" = (int)EDL_use_ep;
    325          

   \                                 In segment SWILIB_FUNC300_30A, align 4, align-sorted, root
   \   00000000   ........           DC32 isEDL_exist_ep
    326          __root static const int SWILIB_FUNC306 @ "SWILIB_FUNC300_30A" = (int)isEDL_exist_ep;

   \                                 In segment SWILIB_FUNC300_30A, align 4, align-sorted, root
   \   00000000   ........           DC32 isEDL_support_ep
    327          __root static const int SWILIB_FUNC307 @ "SWILIB_FUNC300_30A" = (int)isEDL_support_ep;

   \                                 In segment SWILIB_FUNC300_30A, align 4, align-sorted, root
   \   00000000   ........           DC32 getEDL_baseAddr_ep
    328          __root static const int SWILIB_FUNC308 @ "SWILIB_FUNC300_30A" = (int)getEDL_baseAddr_ep;

   \                                 In segment SWILIB_FUNC300_30A, align 4, align-sorted, root
   \   00000000   ........           DC32 getEDL_curLibs_ep
    329          __root static const int SWILIB_FUNC309 @ "SWILIB_FUNC300_30A" = (int)getEDL_curLibs_ep;

   \                                 In segment SWILIB_FUNC300_30A, align 4, align-sorted, root
   \   00000000   ........           DC32 getEDL_maxLibs_ep

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   ........           DC32     pEDL_TOP

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   ........           DC32     edl_sys_size

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   256400             DC8 "%d"

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "NONE">`:
   \   00000000   4E4F4E4500         DC8 "NONE"
   \   00000005   000000             DC8 0, 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant {-572657938, 857809203, -286335523}`:
   \   00000000   EEEEDDDD3321       DC32 -572657938, 857809203, -286335523
   \              2133DDDDEEEE
   \   0000000C   583A5C5A6269       DC8 "X:\\Zbin\\libs\\%s.edl"
   \              6E5C6C696273
   \              5C25732E6564
   \              6C00        

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   00                 DC8 ""
    330          __root static const int SWILIB_FUNC30A @ "SWILIB_FUNC300_30A" = (int)getEDL_maxLibs_ep;
    331          #pragma diag_default=Pe177
    332          

   Maximum stack usage in bytes:

     Function           CSTACK
     --------           ------
     EDL_addlib_ep          8
     EDL_load_ep          292
     EDL_remove_ep          4
     EDL_system_init       12
     EDL_system_kill       20
     EDL_system_reinit      4
     EDL_unload_ep         12
     EDL_use_ep             8
     getEDL_baseAddr_ep     0
     getEDL_curLibs_ep      0
     getEDL_maxLibs_ep      0
     isEDL_exist_ep        28
     isEDL_support_ep      28


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     pEDL_TOP                          4
     EDL_system_init                 112
     EDL_system_kill                 148
     EDL_system_reinit                16
     isEDL_exist_ep                  136
     isEDL_support_ep                228
     EDL_load_ep                     472
     EDL_unload_ep                    92
     EDL_addlib_ep                   120
     EDL_remove_ep                    80
     EDL_use_ep                       76
     getEDL_baseAddr_ep               12
     getEDL_curLibs_ep                72
     getEDL_maxLibs_ep                12
     SWILIB_FUNC300                    4
     SWILIB_FUNC301                    4
     SWILIB_FUNC302                    4
     SWILIB_FUNC303                    4
     SWILIB_FUNC304                    4
     SWILIB_FUNC305                    4
     SWILIB_FUNC306                    4
     SWILIB_FUNC307                    4
     SWILIB_FUNC308                    4
     SWILIB_FUNC309                    4
     SWILIB_FUNC30A                    4
     ??DataTable13                     4
     ??DataTable14                     4
     ?<Constant "%d">                  3
     ?<Constant "NONE">                8
     ?<Constant {-572657938, 857809203, -286335523}
                                      32
     ?<Constant "">                    1
      Others                          88

 
 1 660 bytes in segment CODE
    44 bytes in segment DATA_C
     4 bytes in segment DATA_Z
    12 bytes in segment INITTAB
    44 bytes in segment SWILIB_FUNC300_30A
 
 1 584 bytes of CODE  memory (+ 88 bytes shared)
    88 bytes of CONST memory
     4 bytes of DATA  memory

Errors: none
Warnings: none
