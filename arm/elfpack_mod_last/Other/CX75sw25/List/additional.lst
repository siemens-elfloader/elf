##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    07/Mar/2011  11:51:07 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\elfpack_mod_last\main\additional.c            #
#    Command line    =  C:\arm\elfpack_mod_last\main\additional.c -D NDEBUG  #
#                       -D X75 -lCN C:\arm\elfpack_mod_last\Other\CX75sw25\L #
#                       ist\ -lb C:\arm\elfpack_mod_last\Other\CX75sw25\List #
#                       \ -o C:\arm\elfpack_mod_last\Other\CX75sw25\Obj\     #
#                       -s9 --no_unroll --cpu_mode thumb --endian little     #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --fpu None -I "C:\arm2\Embedded Workbench 4.0        #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  C:\arm\elfpack_mod_last\Other\CX75sw25\List\addition #
#                       al.lst                                               #
#    Object file     =  C:\arm\elfpack_mod_last\Other\CX75sw25\Obj\additiona #
#                       l.r79                                                #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\elfpack_mod_last\main\additional.c
      1          #include "..\..\inc\swilib.h"
      2          
      3          #ifdef NEWSGOLD
      4          extern void(*OldShowMsg)(int, int);
      5          #else
      6          extern void(*OldTxtOpen)(WSHDR*, WSHDR*);
      7          #endif
      8          

   \                                 In segment CODE, align 4, keep-with-next
      9          int get_file_size(const char * fname)
     10          {
   \                     get_file_size:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   8BB0               SUB      SP,SP,#+44
     11            FSTATS fs;
     12            unsigned int err;
     13            if (GetFileStats(fname,&fs,&err)==-1) return (-1);
   \   00000004   6A46               MOV      R2,SP
   \   00000006   0024               MOVS     R4,#+0
   \   00000008   E443               MVNS     R4,R4
   \   0000000A   01A9               ADD      R1,SP,#+4
   \   0000000C   84DF               SVC      +132
   \   0000000E   A042               CMP      R0,R4
   \   00000010   01D1               BNE      ??get_file_size_0
   \   00000012   2000               MOVS     R0,R4
   \   00000014   00E0               B        ??get_file_size_1
     14            else return (fs.size);
   \                     ??get_file_size_0:
   \   00000016   0298               LDR      R0,[SP, #+8]
   \                     ??get_file_size_1:
   \   00000018   0BB0               ADD      SP,SP,#+44
   \   0000001A   10BD               POP      {R4,PC}          ;; return
     15          }
     16          

   \                                 In segment CODE, align 4, keep-with-next
     17          __arm void REDRAW_impl(void)
     18          {
   \                     REDRAW_impl:
   \   00000000   00402DE9           PUSH     {LR}
     19            LockSched();
   \   00000004   460100EF           SWI      +326
     20          #ifdef NEWSGOLD
     21            PendedRedrawGUI();
     22          #else
     23            PendedRedrawGUI();
   \   00000008   410100EF           SWI      +321
     24            GBS_SendMessage(MMI_CEPID,0x90);
   \   0000000C   9010A0E3           MOV      R1,#+144
   \   00000010   0900A0E3           MOV      R0,#+9
   \   00000014   420C80E3           ORR      R0,R0,#0x4200
   \   00000018   000100EF           SWI      +256
     25          #endif
     26            UnlockSched();
   \   0000001C   470100EF           SWI      +327
     27          }
   \   00000020   0080BDE8           POP      {PC}             ;; return
     28          
     29          

   \                                 In segment CODE, align 4, keep-with-next
     30          __thumb void SEQKILLER_impl(void *data, void(*next_in_seq)(void *), void *data_to_kill)
     31          {
   \                     SEQKILLER_impl:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   1400               MOVS     R4,R2
     32            next_in_seq(data);
   \   00000004   8847               BLX      R1
     33            mfree(data_to_kill);
   \   00000006   2000               MOVS     R0,R4
   \   00000008   15DF               SVC      +21
     34          }
   \   0000000A   10BD               POP      {R4,PC}          ;; return
     35          

   \                                 In segment CODE, align 4, keep-with-next
     36          unsigned int char8to16(int c)
     37          {
     38            if (c==0xA8) c=0x401;
   \                     char8to16:
   \   00000000   A828               CMP      R0,#+168
   \   00000002   01D1               BNE      ??char8to16_0
   \   00000004   1248               LDR      R0,??char8to16_1  ;; 0x401
   \   00000006   7047               BX       LR
     39            if (c==0xAA) c=0x404;
   \                     ??char8to16_0:
   \   00000008   AA28               CMP      R0,#+170
   \   0000000A   01D1               BNE      ??char8to16_2
   \   0000000C   1148               LDR      R0,??char8to16_1+0x4  ;; 0x404
   \   0000000E   7047               BX       LR
     40            if (c==0xAF) c=0x407;
   \                     ??char8to16_2:
   \   00000010   AF28               CMP      R0,#+175
   \   00000012   01D1               BNE      ??char8to16_3
   \   00000014   1048               LDR      R0,??char8to16_1+0x8  ;; 0x407
   \   00000016   7047               BX       LR
     41            if (c==0xB8) c=0x451;
   \                     ??char8to16_3:
   \   00000018   B828               CMP      R0,#+184
   \   0000001A   01D1               BNE      ??char8to16_4
   \   0000001C   0F48               LDR      R0,??char8to16_1+0xC  ;; 0x451
   \   0000001E   7047               BX       LR
     42            if (c==0xBA) c=0x454;
   \                     ??char8to16_4:
   \   00000020   BA28               CMP      R0,#+186
   \   00000022   01D1               BNE      ??char8to16_5
   \   00000024   0E48               LDR      R0,??char8to16_1+0x10  ;; 0x454
   \   00000026   7047               BX       LR
     43            if (c==0xBF) c=0x457;
   \                     ??char8to16_5:
   \   00000028   BF28               CMP      R0,#+191
   \   0000002A   01D1               BNE      ??char8to16_6
   \   0000002C   0D48               LDR      R0,??char8to16_1+0x14  ;; 0x457
   \   0000002E   7047               BX       LR
     44            if (c==0xB2) c=0x406;
   \                     ??char8to16_6:
   \   00000030   B228               CMP      R0,#+178
   \   00000032   01D1               BNE      ??char8to16_7
   \   00000034   0C48               LDR      R0,??char8to16_1+0x18  ;; 0x406
   \   00000036   7047               BX       LR
     45            if (c==0xB3) c=0x456;
   \                     ??char8to16_7:
   \   00000038   B328               CMP      R0,#+179
   \   0000003A   01D1               BNE      ??char8to16_8
   \   0000003C   0B48               LDR      R0,??char8to16_1+0x1C  ;; 0x456
   \   0000003E   7047               BX       LR
     46            if ((c>=0xC0)&&(c<0x100)) c+=0x350;
   \                     ??char8to16_8:
   \   00000040   C028               CMP      R0,#+192
   \   00000042   04DB               BLT      ??char8to16_9
   \   00000044   FF28               CMP      R0,#+255
   \   00000046   02DC               BGT      ??char8to16_9
   \   00000048   D421               MOVS     R1,#+212
   \   0000004A   8900               LSLS     R1,R1,#+2
   \   0000004C   4018               ADDS     R0,R0,R1
     47            return(c);
   \                     ??char8to16_9:
   \   0000004E   7047               BX       LR
   \                     ??char8to16_1:
   \   00000050   01040000           DC32     0x401
   \   00000054   04040000           DC32     0x404
   \   00000058   07040000           DC32     0x407
   \   0000005C   51040000           DC32     0x451
   \   00000060   54040000           DC32     0x454
   \   00000064   57040000           DC32     0x457
   \   00000068   06040000           DC32     0x406
   \   0000006C   56040000           DC32     0x456
     48          }
     49          

   \                                 In segment CODE, align 4, keep-with-next
     50          void ascii2ws(char *s, WSHDR *ws)
     51          {
   \                     ascii2ws:
   \   00000000   30B5               PUSH     {R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   04E0               B        ??ascii2ws_0
     52            int c;
     53            while((c=*s++))
     54            {
     55              wsAppendChar(ws,char8to16(c));
   \                     ??ascii2ws_1:
   \   00000008   ........           BL       char8to16
   \   0000000C   0100               MOVS     R1,R0
   \   0000000E   2800               MOVS     R0,R5
   \   00000010   1CDF               SVC      +28
     56            }
   \                     ??ascii2ws_0:
   \   00000012   2078               LDRB     R0,[R4, #+0]
   \   00000014   641C               ADDS     R4,R4,#+1
   \   00000016   0028               CMP      R0,#+0
   \   00000018   F6D1               BNE      ??ascii2ws_1
     57          }
   \   0000001A   30BD               POP      {R4,R5,PC}       ;; return
     58          #ifdef NEWSGOLD
     59          __arm void ESI(WSHDR *ws, int dummy, char *s)
     60          #else

   \                                 In segment CODE, align 4, keep-with-next
     61          __arm void ESI(char *s, WSHDR *ws)
     62          #endif
     63          {
   \                     ESI:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
     64            if (((unsigned int)s>>28)==0xA) //Только строки из области RAM/FLASH
   \   00000008   240EA0E1           LSR      R0,R4,#+28
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0A0050E3           CMP      R0,#+10
   \   00000014   0600001A           BNE      ??ESI_0
     65            {
     66              CutWSTR(ws,0); 
   \   00000018   0010A0E3           MOV      R1,#+0
   \   0000001C   0500A0E1           MOV      R0,R5
   \   00000020   260100EF           SWI      +294
     67              ascii2ws(s,ws);
   \   00000024   0510A0E1           MOV      R1,R5
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           BLX      ascii2ws
   \   00000030   3080BDE8           POP      {R4,R5,PC}
     68            }
     69            else
     70            {
     71              wsprintf(ws,"|%d|",s);
   \                     ??ESI_0:
   \   00000034   0C109FE5           LDR      R1,??ESI_1       ;; `?<Constant "|%d|">`
   \   00000038   0420A0E1           MOV      R2,R4
   \   0000003C   0500A0E1           MOV      R0,R5
   \   00000040   240100EF           SWI      +292
     72            }
     73          }
   \   00000044   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??ESI_1:
   \   00000048   ........           DC32     `?<Constant "|%d|">`
     74          

   \                                 In segment CODE, align 4, keep-with-next
     75          __arm void DoUnknownFileType(WSHDR *filename)
     76          {
   \                     DoUnknownFileType:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
     77            WSHDR *wsmime=AllocWS(15);
   \   00000008   0F00A0E3           MOV      R0,#+15
   \   0000000C   250100EF           SWI      +293
   \   00000010   0050A0E1           MOV      R5,R0
     78            wsprintf(wsmime,"txt");
   \   00000014   071F8FE2           ADR      R1,??DoUnknownFileType_0  ;; "txt"
   \   00000018   240100EF           SWI      +292
     79            ExecuteFile(filename,wsmime,0);
   \   0000001C   0020A0E3           MOV      R2,#+0
   \   00000020   0510A0E1           MOV      R1,R5
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   940000EF           SWI      +148
     80            FreeWS(wsmime);
   \   0000002C   0500A0E1           MOV      R0,R5
   \   00000030   290100EF           SWI      +297
     81          }
   \   00000034   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??DoUnknownFileType_0:
   \   00000038   74787400           DC8      "txt"
     82          
     83          #ifdef NEWSGOLD 
     84          __no_init int *EXT2_AREA;
     85          #ifdef ELKA
     86          __no_init int EXT2_CNT @ "REGEXPL_CNT";
     87          #endif
     88          
     89          #else

   \                                 In segment DATA_N, align 4, align-sorted
     90          __no_init TREGEXPLEXT *EXT2_AREA;
   \                     EXT2_AREA:
   \   00000000                      DS8 4

   \                                 In segment REGEXPL_CNT, align 4, align-sorted
     91          __no_init int EXT2_CNT @ "REGEXPL_CNT";
   \                     EXT2_CNT:
   \   00000000                      DS8 4
     92          #endif
     93          
     94          #ifdef NEWSGOLD 
     95          #ifdef ELKA
     96          #else
     97          __arm int *GET_EXT2_TABLE(void)
     98          {
     99            int *p=EXT2_AREA;
    100            if (p)
    101            {
    102              return(p+1);
    103            }
    104            p=malloc(4);
    105            *p=0;
    106            return ((EXT2_AREA=p)+1);
    107          }
    108          #endif
    109          #endif  
    110          
    111          #ifdef NEWSGOLD 
    112          #ifdef ELKA
    113          __arm int *EXT2_REALLOC(void)
    114          {
    115            int size;
    116            size=sizeof(REGEXPLEXT);
    117            int *p;
    118            int *p2;
    119            int n;
    120            LockSched();
    121            n=EXT2_CNT;
    122            p=EXT2_AREA;
    123            p2=malloc((n+1)*size);
    124            if (p) 
    125            {    
    126              memcpy(p2,p,n*size);
    127              mfree(p);
    128            }
    129            EXT2_CNT=n+1;
    130            EXT2_AREA=p2;
    131            p2+=(n*(size/sizeof(int)));
    132            UnlockSched();
    133            return (p2);
    134          }
    135          #else
    136          __arm int *EXT2_REALLOC(void)
    137          {
    138            int size;
    139            size=sizeof(REGEXPLEXT);
    140            int *p;
    141            int *p2;
    142            int n;
    143            LockSched();
    144            n=*(p=EXT2_AREA);
    145            p2=malloc((n+1)*size+4);
    146            memcpy(p2,p,n*size+4);
    147            *p2=n+1;
    148            mfree(p);
    149            EXT2_AREA=p2;
    150            p2+=(n*(size/sizeof(int)))+1;
    151            UnlockSched();
    152            return (p2);
    153          }
    154          #endif
    155          #else

   \                                 In segment CODE, align 4, keep-with-next
    156          __arm TREGEXPLEXT *EXT2_REALLOC(void)
    157          {
   \                     EXT2_REALLOC:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
    158            TREGEXPLEXT *p,*p2;
    159            int n;
    160            LockSched();
    161            n=EXT2_CNT;
   \   00000004   ........           LDR      R4,??DataTable2  ;; EXT2_CNT
    162            p=EXT2_AREA;
   \   00000008   ........           LDR      R6,??DataTable3  ;; EXT2_AREA
   \   0000000C   460100EF           SWI      +326
   \   00000010   005094E5           LDR      R5,[R4, #+0]
   \   00000014   007096E5           LDR      R7,[R6, #+0]
    163            p2=malloc((n+1)*sizeof(TREGEXPLEXT));
   \   00000018   018085E2           ADD      R8,R5,#+1
   \   0000001C   2410A0E3           MOV      R1,#+36
   \   00000020   910800E0           MUL      R0,R1,R8
   \   00000024   140000EF           SWI      +20
   \   00000028   0090A0E1           MOV      R9,R0
    164            zeromem(p2,(n+1)*sizeof(TREGEXPLEXT));
   \   0000002C   2400A0E3           MOV      R0,#+36
   \   00000030   900801E0           MUL      R1,R0,R8
   \   00000034   0900A0E1           MOV      R0,R9
   \   00000038   1D0100EF           SWI      +285
    165            if (p) 
   \   0000003C   000057E3           CMP      R7,#+0
   \   00000040   0600000A           BEQ      ??EXT2_REALLOC_0
    166            {    
    167              memcpy(p2,p,n*sizeof(TREGEXPLEXT));
   \   00000044   2400A0E3           MOV      R0,#+36
   \   00000048   900502E0           MUL      R2,R0,R5
   \   0000004C   0710A0E1           MOV      R1,R7
   \   00000050   0900A0E1           MOV      R0,R9
   \   00000054   1E0100EF           SWI      +286
    168              mfree(p);
   \   00000058   0700A0E1           MOV      R0,R7
   \   0000005C   150000EF           SWI      +21
    169            }
    170            EXT2_CNT=n+1;
   \                     ??EXT2_REALLOC_0:
   \   00000060   008084E5           STR      R8,[R4, #+0]
    171            EXT2_AREA=p2;
   \   00000064   009086E5           STR      R9,[R6, #+0]
    172            UnlockSched();
   \   00000068   470100EF           SWI      +327
    173            return (p2+n);
   \   0000006C   2410A0E3           MOV      R1,#+36
   \   00000070   919520E0           MLA      R0,R1,R5,R9
   \   00000074   F083BDE8           POP      {R4-R9,PC}       ;; return
    174          }
    175          
    176          
    177          #endif
    178          
    179          
    180          
    181          #ifdef NEWSGOLD
    182          __thumb MyShowMSG(int p1, int p2)
    183          {
    184          #ifdef ELKA
    185            if (p2!=0x1DD1)
    186          #else
    187              if (p2!=(0x1DCC+5))
    188          #endif    
    189              {
    190                OldShowMsg(p1,p2);
    191                return;
    192              }
    193            asm("MOVS R0,R6\n");
    194            DoUnknownFileType((WSHDR *)p1);
    195          }
    196          #else
    197          

   \                                 In segment CODE, align 4, keep-with-next
    198          __arm void PropertyPatch(WSHDR *unk_foldername, WSHDR *unk_filename)
    199          {
   \                     PropertyPatch:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    200            WSHDR *ws;
    201            ws=AllocWS(255);
   \   0000000C   FF00A0E3           MOV      R0,#+255
   \   00000010   250100EF           SWI      +293
   \   00000014   0060A0E1           MOV      R6,R0
    202            wstrcpy(ws,unk_foldername);
   \   00000018   0410A0E1           MOV      R1,R4
   \   0000001C   1F0100EF           SWI      +287
    203            wsAppendChar(ws,'\\');
   \   00000020   5C10A0E3           MOV      R1,#+92
   \   00000024   0600A0E1           MOV      R0,R6
   \   00000028   1C0000EF           SWI      +28
    204            wstrcat (ws,unk_filename);
   \   0000002C   0510A0E1           MOV      R1,R5
   \   00000030   0600A0E1           MOV      R0,R6
   \   00000034   210100EF           SWI      +289
    205            DoUnknownFileType(ws);
   \   00000038   0600A0E1           MOV      R0,R6
   \   0000003C   ........           BL       DoUnknownFileType
    206            FreeWS(ws);
   \   00000040   0600A0E1           MOV      R0,R6
   \   00000044   290100EF           SWI      +297
    207          }
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
    208          
    209          #endif
    210          
    211          
    212          //Патчи
    213          #pragma diag_suppress=Pe177
    214          
    215          #ifdef NEWSGOLD
    216          __root static const int NEW_SHOWMSG @ "PATCH_SHOWMSG_BLF" = (int)MyShowMSG;
    217          #endif
    218          
    219          

   \                                 In segment SWILIB_FUNC172, align 4, align-sorted, root
   \   00000000   ........           DC32 REDRAW_impl
    220          __root static const int SWILIB_FUNC172 @ "SWILIB_FUNC172" = (int)REDRAW_impl;

   \                                 In segment SWILIB_FUNC19C, align 4, align-sorted, root
   \   00000000   ........           DC32 SEQKILLER_impl
    221          __root static const int SWILIB_FUNC19C @ "SWILIB_FUNC19C" = (int)SEQKILLER_impl;
    222          #pragma diag_default=Pe177
    223          
    224          
    225          #ifndef NEWSGOLD
    226          
    227          // В этот файл включены некоторые функции которых нет в прошивке для SGOLD
    228          
    229          // ========================================== Reg Files =============================================

   \                                 In segment CODE, align 4, keep-with-next
    230          __arm void RegFile(WSHDR*ext,int unical_id,int menu_flag,unsigned int* icon1,int obex_path_id,int enabled_options,void *proc1,void *proc2,unsigned int *icon2)
    231          {
   \                     RegFile:
   \   00000000   F74F2DE9           PUSH     {R0-R2,R4-R11,LR}
   \   00000004   30809DE5           LDR      R8,[SP, #+48]
   \   00000008   34909DE5           LDR      R9,[SP, #+52]
   \   0000000C   38A09DE5           LDR      R10,[SP, #+56]
   \   00000010   3CB09DE5           LDR      R11,[SP, #+60]
   \   00000014   40409DE5           LDR      R4,[SP, #+64]
   \   00000018   0370A0E1           MOV      R7,R3
    232            TREGEXPLEXT *reg;
    233            unsigned int *icon2new;
    234            reg=EXT2_REALLOC();
   \   0000001C   ........           BL       EXT2_REALLOC
   \   00000020   0050A0E1           MOV      R5,R0
    235            LockSched();
   \   00000024   460100EF           SWI      +326
    236            reg->zero=0;
   \   00000028   0060A0E3           MOV      R6,#+0
   \   0000002C   006085E5           STR      R6,[R5, #+0]
    237            reg->icon1=icon1;
   \   00000030   047085E5           STR      R7,[R5, #+4]
    238            reg->unical_id=unical_id;
   \   00000034   04009DE5           LDR      R0,[SP, #+4]
   \   00000038   080085E5           STR      R0,[R5, #+8]
    239            reg->obex_path_id=obex_path_id;
   \   0000003C   0C80C5E5           STRB     R8,[R5, #+12]
    240            reg->menu_flag=menu_flag;
   \   00000040   08009DE5           LDR      R0,[SP, #+8]
   \   00000044   BE00C5E1           STRH     R0,[R5, #+14]
    241            reg->enabled_options=enabled_options;
   \   00000048   1090C5E5           STRB     R9,[R5, #+16]
    242            reg->ext=ext;
   \   0000004C   00009DE5           LDR      R0,[SP, #+0]
   \   00000050   140085E5           STR      R0,[R5, #+20]
    243            reg->proc=proc1;
   \   00000054   18A085E5           STR      R10,[R5, #+24]
    244            reg->altproc=proc2;
   \   00000058   1CB085E5           STR      R11,[R5, #+28]
    245             
    246            icon2new=malloc(sizeof(int)*2);
   \   0000005C   0800A0E3           MOV      R0,#+8
   \   00000060   140000EF           SWI      +20
    247            icon2new[0]=*icon1>>28==0xA?*icon2:*icon1+1;
   \   00000064   001097E5           LDR      R1,[R7, #+0]
   \   00000068   212EA0E1           LSR      R2,R1,#+28
   \   0000006C   0A0052E3           CMP      R2,#+10
   \   00000070   00109405           LDREQ    R1,[R4, #+0]
   \   00000074   01108112           ADDNE    R1,R1,#+1
   \   00000078   001080E5           STR      R1,[R0, #+0]
    248            icon2new[1]=0;
   \   0000007C   046080E5           STR      R6,[R0, #+4]
    249            reg->icon2=icon2new;
   \   00000080   200085E5           STR      R0,[R5, #+32]
    250            UnlockSched();
   \   00000084   470100EF           SWI      +327
    251          }
   \   00000088   F78FBDE8           POP      {R0-R2,R4-R11,PC}  ;; return
    252          

   \                                 In segment CODE, align 4, keep-with-next
    253          __arm int GetBigIcon(const unsigned int icon, int uid)
    254          {
   \                     GetBigIcon:
   \   00000000   00402DE9           PUSH     {LR}
    255            asm("mov r1, r8");
   \   00000004   0810A0E1           mov r1, r8       
    256            TREGEXPLEXT *reg;
    257            if ((icon>>28)!=0xA) return (icon+1);
   \   00000008   202EA0E1           LSR      R2,R0,#+28
   \   0000000C   0A0052E3           CMP      R2,#+10
   \   00000010   01008012           ADDNE    R0,R0,#+1
   \   00000014   0080BD18           POPNE    {PC}
    258            reg=get_regextpnt_by_uid(uid);
   \   00000018   0100A0E1           MOV      R0,R1
   \   0000001C   CF0100EF           SWI      +463
    259            if (!reg) return (0);
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0080BD08           POPEQ    {PC}
    260            return (*(reg->icon2));
   \   00000028   200090E5           LDR      R0,[R0, #+32]
   \   0000002C   000090E5           LDR      R0,[R0, #+0]
   \   00000030   0080BDE8           POP      {PC}             ;; return
    261          }
    262          

   \                                 In segment CODE, align 4, keep-with-next
    263          __arm void UnregExplExt_impl(REGEXPLEXT const * reg_orig)
    264          {
   \                     UnregExplExt_impl:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
    265            char ext[16];
    266            TREGEXPLEXT *reg=(TREGEXPLEXT*)EXT2_AREA;
    267            for (int i=0;i!=EXT2_CNT;i++)
   \   00000004   ........           LDR      R5,??DataTable2  ;; EXT2_CNT
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   ........           LDR      R0,??DataTable3  ;; EXT2_AREA
   \   00000010   10D04DE2           SUB      SP,SP,#+16
   \   00000014   007090E5           LDR      R7,[R0, #+0]
   \   00000018   0060A0E3           MOV      R6,#+0
   \   0000001C   000000EA           B        ??UnregExplExt_impl_0
   \                     ??UnregExplExt_impl_1:
   \   00000020   016086E2           ADD      R6,R6,#+1
   \                     ??UnregExplExt_impl_0:
   \   00000024   000095E5           LDR      R0,[R5, #+0]
   \   00000028   000056E1           CMP      R6,R0
   \   0000002C   FF81BD08           POPEQ    {R0-R8,PC}
    268            {
    269              if (reg_orig->unical_id==reg[i].unical_id)
   \   00000030   2400A0E3           MOV      R0,#+36
   \   00000034   907628E0           MLA      R8,R0,R6,R7
   \   00000038   040094E5           LDR      R0,[R4, #+4]
   \   0000003C   081098E5           LDR      R1,[R8, #+8]
   \   00000040   010050E1           CMP      R0,R1
   \   00000044   F5FFFF1A           BNE      ??UnregExplExt_impl_1
    270              {
    271                ws_2str(reg[i].ext,ext,15);
   \   00000048   140098E5           LDR      R0,[R8, #+20]
   \   0000004C   0F20A0E3           MOV      R2,#+15
   \   00000050   0D10A0E1           MOV      R1,SP
   \   00000054   A30000EF           SWI      +163
    272                if (!strcmp(ext,reg_orig->ext))
   \   00000058   001094E5           LDR      R1,[R4, #+0]
   \   0000005C   0D00A0E1           MOV      R0,SP
   \   00000060   190000EF           SWI      +25
   \   00000064   000050E3           CMP      R0,#+0
   \   00000068   ECFFFF1A           BNE      ??UnregExplExt_impl_1
    273                {
    274                  FreeWS(reg[i].ext);
   \   0000006C   140098E5           LDR      R0,[R8, #+20]
   \   00000070   290100EF           SWI      +297
    275                  mfree((void*)reg[i].icon2);
   \   00000074   200098E5           LDR      R0,[R8, #+32]
   \   00000078   150000EF           SWI      +21
    276                  EXT2_CNT--;
   \   0000007C   000095E5           LDR      R0,[R5, #+0]
    277                  memcpy(&reg[i],&reg[i+1],sizeof(TREGEXPLEXT)*(EXT2_CNT-i));
   \   00000080   2410A0E3           MOV      R1,#+36
   \   00000084   010040E2           SUB      R0,R0,#+1
   \   00000088   000085E5           STR      R0,[R5, #+0]
   \   0000008C   060040E0           SUB      R0,R0,R6
   \   00000090   910002E0           MUL      R2,R1,R0
   \   00000094   241088E2           ADD      R1,R8,#+36
   \   00000098   0800A0E1           MOV      R0,R8
   \   0000009C   1E0100EF           SWI      +286
    278                  return;
   \   000000A0   FF81BDE8           POP      {R0-R8,PC}       ;; return
    279                }
    280              }
    281            }
    282          }
    283          
    284          // ========================================= Keyb Hooks ===========================================
    285          typedef struct
    286          {
    287            void *next;
    288            void *prev;
    289            int (*proc)(int submsg,int msg);
    290            char is_first;
    291          }PLIST;
    292          
    293          
    294          

   \                                 In segment DATA_N, align 4, align-sorted
    295          __no_init LLQ _plistq;
   \                     _plistq:
   \   00000000                      DS8 12
    296          
    297          #pragma optimize=no_inline

   \                                 In segment CODE, align 4, keep-with-next
    298          static void LLaddToEnd(LLQ *ll, void *data)
    299          {
    300            LLIST *d=data;
    301            d->next=NULL;
   \                     LLaddToEnd:
   \   00000000   0022               MOVS     R2,#+0
   \   00000002   0A60               STR      R2,[R1, #+0]
    302            d->prev=ll->last;
   \   00000004   4268               LDR      R2,[R0, #+4]
   \   00000006   4A60               STR      R2,[R1, #+4]
    303            if (ll->last)
   \   00000008   4268               LDR      R2,[R0, #+4]
   \   0000000A   002A               CMP      R2,#+0
   \   0000000C   01D0               BEQ      ??LLaddToEnd_0
    304            {
    305              ((LLIST *)ll->last)->next=d;
   \   0000000E   1160               STR      R1,[R2, #+0]
   \   00000010   00E0               B        ??LLaddToEnd_1
    306            }
    307            else
    308            {
    309              ll->first=d;
   \                     ??LLaddToEnd_0:
   \   00000012   0160               STR      R1,[R0, #+0]
    310            }
    311            ll->last=d;
   \                     ??LLaddToEnd_1:
   \   00000014   4160               STR      R1,[R0, #+4]
    312          }
   \   00000016   7047               BX       LR
    313          
    314          #pragma optimize=no_inline

   \                                 In segment CODE, align 4, keep-with-next
    315          static void LLaddToBegin(LLQ *ll, void *data)
    316          {
    317            LLIST *d=data;
    318            d->next=ll->first;
   \                     LLaddToBegin:
   \   00000000   0268               LDR      R2,[R0, #+0]
   \   00000002   0A60               STR      R2,[R1, #+0]
    319            d->prev=0;
   \   00000004   0022               MOVS     R2,#+0
   \   00000006   4A60               STR      R2,[R1, #+4]
    320            if (!ll->last)
   \   00000008   4268               LDR      R2,[R0, #+4]
   \   0000000A   002A               CMP      R2,#+0
   \   0000000C   01D1               BNE      ??LLaddToBegin_0
    321            {
    322              ll->last=d;
   \   0000000E   4160               STR      R1,[R0, #+4]
   \   00000010   01E0               B        ??LLaddToBegin_1
    323            }
    324            else
    325            {
    326              ((LLIST *)ll->first)->prev=d;
   \                     ??LLaddToBegin_0:
   \   00000012   0268               LDR      R2,[R0, #+0]
   \   00000014   5160               STR      R1,[R2, #+4]
    327            }
    328            ll->first=d;
   \                     ??LLaddToBegin_1:
   \   00000016   0160               STR      R1,[R0, #+0]
    329          }
   \   00000018   7047               BX       LR
    330          
    331          #pragma optimize=no_inline

   \                                 In segment CODE, align 4, keep-with-next
    332          static void LLremoveFromQ(LLQ *ll, void *data, int is_free)
    333          {
   \                     LLremoveFromQ:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0300               MOVS     R3,R0
   \   00000004   0800               MOVS     R0,R1
    334            LLIST *d=data;
    335            if (d->prev)
   \   00000006   4168               LDR      R1,[R0, #+4]
   \   00000008   0029               CMP      R1,#+0
   \   0000000A   02D0               BEQ      ??LLremoveFromQ_0
    336            {
    337              ((LLIST *)d->prev)->next=d->next;
   \   0000000C   0468               LDR      R4,[R0, #+0]
   \   0000000E   0C60               STR      R4,[R1, #+0]
   \   00000010   01E0               B        ??LLremoveFromQ_1
    338            }
    339            else
    340            {
    341              ll->first=d->next;
   \                     ??LLremoveFromQ_0:
   \   00000012   0168               LDR      R1,[R0, #+0]
   \   00000014   1960               STR      R1,[R3, #+0]
    342            }
    343            if (d->next)
   \                     ??LLremoveFromQ_1:
   \   00000016   0168               LDR      R1,[R0, #+0]
   \   00000018   0029               CMP      R1,#+0
   \   0000001A   02D0               BEQ      ??LLremoveFromQ_2
    344            {
    345              ((LLIST *)d->next)->prev=d->prev;
   \   0000001C   4468               LDR      R4,[R0, #+4]
   \   0000001E   4C60               STR      R4,[R1, #+4]
   \   00000020   01E0               B        ??LLremoveFromQ_3
    346            }
    347            else
    348            {
    349              ll->last=d->prev;
   \                     ??LLremoveFromQ_2:
   \   00000022   4168               LDR      R1,[R0, #+4]
   \   00000024   5960               STR      R1,[R3, #+4]
    350            }
    351            if (is_free)
   \                     ??LLremoveFromQ_3:
   \   00000026   002A               CMP      R2,#+0
   \   00000028   01D0               BEQ      ??LLremoveFromQ_4
    352            {
    353              ll->data_mfree(d);
   \   0000002A   9968               LDR      R1,[R3, #+8]
   \   0000002C   8847               BLX      R1
    354            }
    355          }
   \                     ??LLremoveFromQ_4:
   \   0000002E   10BD               POP      {R4,PC}          ;; return
    356          

   \                                 In segment CODE, align 4, keep-with-next
    357          __arm void AddKeybMsgHook_impl(int (*proc)(int submsg,int msg))
    358          {
   \                     AddKeybMsgHook_impl:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
    359            LLQ *plistq=&_plistq;
    360            PLIST *newp;
    361            if (!plistq->data_mfree)
   \   00000004   ........           LDR      R6,??DataTable7  ;; _plistq
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   080096E5           LDR      R0,[R6, #+8]
   \   00000010   0050A0E3           MOV      R5,#+0
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0300001A           BNE      ??AddKeybMsgHook_impl_0
    362            {
    363              plistq->first=0;
   \   0000001C   005086E5           STR      R5,[R6, #+0]
    364              plistq->last=0;
   \   00000020   045086E5           STR      R5,[R6, #+4]
    365              plistq->data_mfree=(void(*)(void *))mfree_adr();
   \   00000024   158000EF           SWI      +32789
   \   00000028   080086E5           STR      R0,[R6, #+8]
    366            }
    367            newp=malloc(sizeof(PLIST));
   \                     ??AddKeybMsgHook_impl_0:
   \   0000002C   1000A0E3           MOV      R0,#+16
   \   00000030   140000EF           SWI      +20
    368            if (newp)
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   7080BD08           POPEQ    {R4-R6,PC}
    369            {
    370              newp->proc=proc;
   \   0000003C   084080E5           STR      R4,[R0, #+8]
    371              newp->is_first=0;
   \   00000040   0C50C0E5           STRB     R5,[R0, #+12]
    372              LLaddToEnd(plistq,newp);
   \   00000044   0010A0E1           MOV      R1,R0
   \   00000048   0600A0E1           MOV      R0,R6
   \   0000004C   ........           BLX      LLaddToEnd
    373            }
    374          }
   \   00000050   7080BDE8           POP      {R4-R6,PC}       ;; return
    375          
    376          

   \                                 In segment CODE, align 4, keep-with-next
    377          __arm int AddKeybMsgHook_end_impl(int (*proc)(int submsg,int msg))
    378          {
   \                     AddKeybMsgHook_end_impl:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    379            LLQ *plistq=&_plistq;
    380            PLIST *newp, *pfirst;
    381            if (!plistq->data_mfree)
   \   00000004   ........           LDR      R5,??DataTable7  ;; _plistq
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   080095E5           LDR      R0,[R5, #+8]
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0300001A           BNE      ??AddKeybMsgHook_end_impl_0
    382            {
    383              plistq->first=0;
   \   00000018   000085E5           STR      R0,[R5, #+0]
    384              plistq->last=0;
   \   0000001C   040085E5           STR      R0,[R5, #+4]
    385              plistq->data_mfree=(void(*)(void *))mfree_adr();
   \   00000020   158000EF           SWI      +32789
   \   00000024   080085E5           STR      R0,[R5, #+8]
    386            }
    387            if (pfirst=plistq->first)
   \                     ??AddKeybMsgHook_end_impl_0:
   \   00000028   000095E5           LDR      R0,[R5, #+0]
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   0300000A           BEQ      ??AddKeybMsgHook_end_impl_1
    388            {
    389              if (pfirst->is_first==1) return 0;
   \   00000034   0C00D0E5           LDRB     R0,[R0, #+12]
   \   00000038   010050E3           CMP      R0,#+1
   \   0000003C   0000A003           MOVEQ    R0,#+0
   \   00000040   3080BD08           POPEQ    {R4,R5,PC}
    390            }
    391            newp=malloc(sizeof(PLIST));
   \                     ??AddKeybMsgHook_end_impl_1:
   \   00000044   1000A0E3           MOV      R0,#+16
   \   00000048   140000EF           SWI      +20
    392            if (!newp) return 0;
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   3080BD08           POPEQ    {R4,R5,PC}
    393            newp->proc=proc;
   \   00000054   084080E5           STR      R4,[R0, #+8]
    394            newp->is_first=1;
   \   00000058   0110A0E3           MOV      R1,#+1
   \   0000005C   0C10C0E5           STRB     R1,[R0, #+12]
    395            LLaddToBegin(plistq,newp);
   \   00000060   0010A0E1           MOV      R1,R0
   \   00000064   0500A0E1           MOV      R0,R5
   \   00000068   ........           BLX      LLaddToBegin
    396            return 1;
   \   0000006C   0100A0E3           MOV      R0,#+1
   \   00000070   3080BDE8           POP      {R4,R5,PC}       ;; return
    397          }  
    398          
    399          extern BXR1(void *, void (*)(void *));
    400          
    401          

   \                                 In segment CODE, align 4, keep-with-next
    402          __arm void RemoveKeybMsgHook_impl(int (*proc)(int submsg,int msg))
    403          {
    404            LLQ *plistq=&_plistq;
    405            PLIST *plist=plistq->first;
   \                     RemoveKeybMsgHook_impl:
   \   00000000   ........           LDR      R3,??DataTable7  ;; _plistq
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   001093E5           LDR      R1,[R3, #+0]
   \   0000000C   000000EA           B        ??RemoveKeybMsgHook_impl_0
    406            while(plist)
    407            {
    408              if (plist->proc==proc)
    409              {
    410                LLremoveFromQ(plistq,plist,1);
    411                return;      
    412              }  
    413              plist=plist->next;    
   \                     ??RemoveKeybMsgHook_impl_1:
   \   00000010   001091E5           LDR      R1,[R1, #+0]
   \                     ??RemoveKeybMsgHook_impl_0:
   \   00000014   000051E3           CMP      R1,#+0
   \   00000018   0080BD08           POPEQ    {PC}
   \   0000001C   082091E5           LDR      R2,[R1, #+8]
   \   00000020   000052E1           CMP      R2,R0
   \   00000024   F9FFFF1A           BNE      ??RemoveKeybMsgHook_impl_1
   \   00000028   0120A0E3           MOV      R2,#+1
   \   0000002C   0300A0E1           MOV      R0,R3
   \   00000030   ........           BLX      LLremoveFromQ
   \   00000034   0080BDE8           POP      {PC}             ;; return
    414            }
    415          }
    416          
    417          

   \                                 In segment CODE, align 4, keep-with-next
    418          int PatchKeybMsg(int submsg, int msg)
    419          {
   \                     PatchKeybMsg:
   \   00000000   E1B5               PUSH     {R0,R5-R7,LR}
    420            LLQ *plistq=&_plistq;
    421            PLIST *plist=plistq->first;
   \   00000002   ....               LDR      R0,??DataTable7  ;; _plistq
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   0768               LDR      R7,[R0, #+0]
    422            int proc_ret;
    423            int is_no_gui=0;
   \   00000008   0026               MOVS     R6,#+0
   \   0000000A   01E0               B        ??PatchKeybMsg_0
    424            while(plist)
    425            {
    426              if (plist->proc)
    427              {
    428                proc_ret=plist->proc(submsg,msg);
    429                switch(proc_ret)
    430                {
    431                case KEYHOOK_NEXT:
    432                  break;
    433                case KEYHOOK_NEXT_NOT2GUI:
    434                  is_no_gui=1;
   \                     ??PatchKeybMsg_1:
   \   0000000C   0126               MOVS     R6,#+1
    435                  break;
    436                case KEYHOOK_BREAK:
    437                  return (2);
    438                case KEYHOOK_ENDQ:
    439                  return is_no_gui==1?2:0;
    440                default:
    441                  break;
    442                }      
    443              }
    444              plist=plist->next;
   \                     ??PatchKeybMsg_2:
   \   0000000E   3F68               LDR      R7,[R7, #+0]
   \                     ??PatchKeybMsg_0:
   \   00000010   002F               CMP      R7,#+0
   \   00000012   11D0               BEQ      ??PatchKeybMsg_3
   \   00000014   BA68               LDR      R2,[R7, #+8]
   \   00000016   1000               MOVS     R0,R2
   \   00000018   F9D0               BEQ      ??PatchKeybMsg_2
   \   0000001A   0098               LDR      R0,[SP, #+0]
   \   0000001C   2900               MOVS     R1,R5
   \   0000001E   9047               BLX      R2
   \   00000020   0128               CMP      R0,#+1
   \   00000022   F3D0               BEQ      ??PatchKeybMsg_1
   \   00000024   0228               CMP      R0,#+2
   \   00000026   08D0               BEQ      ??PatchKeybMsg_4
   \   00000028   0328               CMP      R0,#+3
   \   0000002A   F0D1               BNE      ??PatchKeybMsg_2
   \   0000002C   012E               CMP      R6,#+1
   \   0000002E   01D1               BNE      ??PatchKeybMsg_5
   \   00000030   0220               MOVS     R0,#+2
   \   00000032   02E0               B        ??PatchKeybMsg_4
   \                     ??PatchKeybMsg_5:
   \   00000034   0020               MOVS     R0,#+0
   \   00000036   00E0               B        ??PatchKeybMsg_4
    445            }
    446            return is_no_gui;
   \                     ??PatchKeybMsg_3:
   \   00000038   3000               MOVS     R0,R6
   \                     ??PatchKeybMsg_4:
   \   0000003A   01B0               ADD      SP,SP,#+4
   \   0000003C   E0BD               POP      {R5-R7,PC}
    447          }
    448          
    449          // ========================================= fread/fwrite ===========================================
    450          extern int (*FReadOld)(int FileHandler, void *cBuffer, int iByteCount, unsigned int *ErrorNumber);
    451          extern unsigned int(*FWriteOld)(int FileHandler, char * cBuffer, int iByteCount, unsigned int *ErrorNumber);
    452          

   \                                 In segment CODE, align 4, keep-with-next
    453          int fread32(int fh, void *buf, int len, unsigned int *err)
    454          {
   \                     fread32:
   \   00000000   FBB5               PUSH     {R0,R1,R3-R7,LR}
   \   00000002   1500               MOVS     R5,R2
    455            int clen;
    456            int rlen;
    457            int total=0;
   \   00000004   0024               MOVS     R4,#+0
   \   00000006   03E0               B        ??fread32_0
    458            while(len)
    459            {
    460              clen=len>=0x4000?0x4000:len;
    461              total+=(rlen=FReadOld(fh, buf, clen, err));
    462              if (rlen!=clen) break;
    463              buf=(char *)buf+rlen;
   \                     ??fread32_1:
   \   00000008   0199               LDR      R1,[SP, #+4]
    464              len-=clen;
   \   0000000A   AD1B               SUBS     R5,R5,R6
   \   0000000C   0818               ADDS     R0,R1,R0
   \   0000000E   0190               STR      R0,[SP, #+4]
   \                     ??fread32_0:
   \   00000010   002D               CMP      R5,#+0
   \   00000012   0ED0               BEQ      ??fread32_2
   \   00000014   8026               MOVS     R6,#+128
   \   00000016   F601               LSLS     R6,R6,#+7
   \   00000018   B542               CMP      R5,R6
   \   0000001A   00DA               BGE      ??fread32_3
   \   0000001C   2E00               MOVS     R6,R5
   \                     ??fread32_3:
   \   0000001E   0098               LDR      R0,[SP, #+0]
   \   00000020   054F               LDR      R7,??fread32_4   ;; FReadOld
   \   00000022   029B               LDR      R3,[SP, #+8]
   \   00000024   0199               LDR      R1,[SP, #+4]
   \   00000026   3F68               LDR      R7,[R7, #+0]
   \   00000028   3200               MOVS     R2,R6
   \   0000002A   B847               BLX      R7
   \   0000002C   2418               ADDS     R4,R4,R0
   \   0000002E   B042               CMP      R0,R6
   \   00000030   EAD0               BEQ      ??fread32_1
    465            }
    466            return(total);
   \                     ??fread32_2:
   \   00000032   2000               MOVS     R0,R4
   \   00000034   03B0               ADD      SP,SP,#+12
   \   00000036   F0BD               POP      {R4-R7,PC}       ;; return
   \                     ??fread32_4:
   \   00000038   ........           DC32     FReadOld
    467          }
    468          
    469          

   \                                 In segment CODE, align 4, keep-with-next
    470          unsigned int fwrite32(int fh, void *buf, int len, unsigned int *err)
    471          {
   \                     fwrite32:
   \   00000000   FBB5               PUSH     {R0,R1,R3-R7,LR}
   \   00000002   1500               MOVS     R5,R2
    472            int clen;
    473            unsigned int wlen;
    474            int total=0;
   \   00000004   0024               MOVS     R4,#+0
   \   00000006   03E0               B        ??fwrite32_0
    475            while(len)
    476            {
    477              clen=len>=0x4000?0x4000:len;
    478              total+=(wlen=FWriteOld(fh, buf, clen, err));
    479              if (wlen!=clen) break;
    480              buf=(char *)buf+wlen;
   \                     ??fwrite32_1:
   \   00000008   0199               LDR      R1,[SP, #+4]
    481              len-=clen;
   \   0000000A   AD1B               SUBS     R5,R5,R6
   \   0000000C   0818               ADDS     R0,R1,R0
   \   0000000E   0190               STR      R0,[SP, #+4]
   \                     ??fwrite32_0:
   \   00000010   002D               CMP      R5,#+0
   \   00000012   0ED0               BEQ      ??fwrite32_2
   \   00000014   8026               MOVS     R6,#+128
   \   00000016   F601               LSLS     R6,R6,#+7
   \   00000018   B542               CMP      R5,R6
   \   0000001A   00DA               BGE      ??fwrite32_3
   \   0000001C   2E00               MOVS     R6,R5
   \                     ??fwrite32_3:
   \   0000001E   0098               LDR      R0,[SP, #+0]
   \   00000020   054F               LDR      R7,??fwrite32_4  ;; FWriteOld
   \   00000022   029B               LDR      R3,[SP, #+8]
   \   00000024   0199               LDR      R1,[SP, #+4]
   \   00000026   3F68               LDR      R7,[R7, #+0]
   \   00000028   3200               MOVS     R2,R6
   \   0000002A   B847               BLX      R7
   \   0000002C   2418               ADDS     R4,R4,R0
   \   0000002E   B042               CMP      R0,R6
   \   00000030   EAD0               BEQ      ??fwrite32_1
    482            }
    483            return(total);
   \                     ??fwrite32_2:
   \   00000032   2000               MOVS     R0,R4
   \   00000034   03B0               ADD      SP,SP,#+12
   \   00000036   F0BD               POP      {R4-R7,PC}       ;; return
   \                     ??fwrite32_4:
   \   00000038   ........           DC32     FWriteOld
    484          }
    485          
    486          
    487          
    488          #pragma diag_suppress=Pe177

   \                                 In segment SWILIB_FUNC00B, align 4, align-sorted, root
   \   00000000   ........           DC32 fread32
    489          __root static const int SWILIB_FUNC00B @ "SWILIB_FUNC00B" = (int)fread32;

   \                                 In segment SWILIB_FUNC00C, align 4, align-sorted, root
   \   00000000   ........           DC32 fwrite32
    490          __root static const int SWILIB_FUNC00C @ "SWILIB_FUNC00C" = (int)fwrite32;

   \                                 In segment SWILIB_FUNC095, align 4, align-sorted, root
   \   00000000   ........           DC32 UnregExplExt_impl
    491          __root static const int SWILIB_FUNC095 @ "SWILIB_FUNC095" = (int)UnregExplExt_impl;

   \                                 In segment SWILIB_FUNC12B_12D, align 4, align-sorted, root
   \   00000000   ........           DC32 AddKeybMsgHook_impl
    492          __root static const int SWILIB_FUNC12B @ "SWILIB_FUNC12B_12D" = (int)AddKeybMsgHook_impl;

   \                                 In segment SWILIB_FUNC12B_12D, align 4, align-sorted, root
   \   00000000   ........           DC32 AddKeybMsgHook_end_impl
    493          __root static const int SWILIB_FUNC12C @ "SWILIB_FUNC12B_12D" = (int)AddKeybMsgHook_end_impl;

   \                                 In segment SWILIB_FUNC12B_12D, align 4, align-sorted, root
   \   00000000   ........           DC32 RemoveKeybMsgHook_impl

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     EXT2_CNT

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   ........           DC32     EXT2_AREA

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   ........           DC32     _plistq

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "|%d|">`:
   \   00000000   7C25647C00         DC8 "|%d|"
   \   00000005   000000             DC8 0, 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \   00000000   74787400           DC8 "txt"
    494          __root static const int SWILIB_FUNC12D @ "SWILIB_FUNC12B_12D" = (int)RemoveKeybMsgHook_impl;
    495          #pragma diag_default=Pe177
    496          
    497          
    498          
    499          #endif
    500          

   Maximum stack usage in bytes:

     Function                CSTACK
     --------                ------
     AddKeybMsgHook_end_impl    12
     AddKeybMsgHook_impl        16
     DoUnknownFileType          12
     ESI                        12
     EXT2_REALLOC               28
     GetBigIcon                  4
     LLaddToBegin                4
     LLaddToEnd                  4
     LLremoveFromQ               8
     PatchKeybMsg               24
     PropertyPatch              16
     REDRAW_impl                 4
     RegFile                    48
     RemoveKeybMsgHook_impl      4
     SEQKILLER_impl              8
     UnregExplExt_impl          40
     ascii2ws                   12
     char8to16                   4
     fread32                    32
     fwrite32                   32
     get_file_size              52


   Segment part sizes:

     Function/Label          Bytes
     --------------          -----
     get_file_size             28
     REDRAW_impl               36
     SEQKILLER_impl            12
     char8to16                112
     ascii2ws                  28
     ESI                       76
     DoUnknownFileType         60
     EXT2_AREA                  4
     EXT2_CNT                   4
     EXT2_REALLOC             120
     PropertyPatch             76
     SWILIB_FUNC172             4
     SWILIB_FUNC19C             4
     RegFile                  140
     GetBigIcon                52
     UnregExplExt_impl        164
     _plistq                   12
     LLaddToEnd                24
     LLaddToBegin              26
     LLremoveFromQ             48
     AddKeybMsgHook_impl       84
     AddKeybMsgHook_end_impl  116
     RemoveKeybMsgHook_impl    56
     PatchKeybMsg              62
     fread32                   60
     fwrite32                  60
     SWILIB_FUNC00B             4
     SWILIB_FUNC00C             4
     SWILIB_FUNC095             4
     SWILIB_FUNC12B             4
     SWILIB_FUNC12C             4
     SWILIB_FUNC12D             4
     ??DataTable2               4
     ??DataTable3               4
     ??DataTable7               4
     ?<Constant "|%d|">         8
     ?<Constant "txt">          4
      Others                  124

 
 1 576 bytes in segment CODE
    12 bytes in segment DATA_C
    16 bytes in segment DATA_N
     4 bytes in segment REGEXPL_CNT
     4 bytes in segment SWILIB_FUNC00B
     4 bytes in segment SWILIB_FUNC00C
     4 bytes in segment SWILIB_FUNC095
    12 bytes in segment SWILIB_FUNC12B_12D
     4 bytes in segment SWILIB_FUNC172
     4 bytes in segment SWILIB_FUNC19C
 
 1 452 bytes of CODE  memory (+ 124 bytes shared)
    44 bytes of CONST memory
    20 bytes of DATA  memory

Errors: none
Warnings: none
