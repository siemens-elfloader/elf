##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    07/Mar/2011  11:51:14 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\elfpack_mod_last\main\png.c                   #
#    Command line    =  C:\arm\elfpack_mod_last\main\png.c -D NDEBUG -D X75  #
#                       -lCN C:\arm\elfpack_mod_last\Other\CX75sw25\List\    #
#                       -lb C:\arm\elfpack_mod_last\Other\CX75sw25\List\ -o  #
#                       C:\arm\elfpack_mod_last\Other\CX75sw25\Obj\ -s9      #
#                       --no_unroll --cpu_mode thumb --endian little --cpu   #
#                       ARM926EJ-S --stack_align 4 --interwork -e --fpu      #
#                       None -I "C:\arm2\Embedded Workbench 4.0              #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  C:\arm\elfpack_mod_last\Other\CX75sw25\List\png.lst  #
#    Object file     =  C:\arm\elfpack_mod_last\Other\CX75sw25\Obj\png.r79   #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\elfpack_mod_last\main\png.c
      1          #include "..\..\inc\swilib.h"
      2          #include "..\..\inc\pnglist.h"
      3          
      4          extern unsigned int DEFAULT_COLOR;
      5          extern unsigned int ALPHA_THRESHOLD;
      6          extern unsigned int CACHE_PNG;

   \                                 In segment DATA_I, align 4, align-sorted
      7          unsigned int DEFAULT_DISK_N2=4;;
   \                     DEFAULT_DISK_N2:
   \   00000000                      DS8 4
   \   00000004                      REQUIRE `?<Initializer for DEFAULT_DISK_N2>`
      8          

   \                                 In segment DATA_C, align 4, align-sorted
      9          const char DEFAULT_FOLDER[]=":\\ZBin\\img\\";
   \                     DEFAULT_FOLDER:
   \   00000000   3A5C5A42696E       DC8 ":\\ZBin\\img\\"
   \              5C696D675C00
     10          
     11          #define number 8
     12          
     13          const char Pointer[1]={0xFF};
     14          const IMGHDR empty_img = {0,0,0x1,(char *)Pointer};
   \                     empty_img:
   \   0000000C   0000               DC8 0, 0
   \   0000000E   0100               DC16 1
   \   00000010   ........           DC32 Pointer

   \                                 In segment DATA_C, align 1, align-sorted
   \                     Pointer:
   \   00000000   FF                 DC8 255
     15          

   \                                 In segment CODE, align 4, keep-with-next
     16          void* xmalloc(int x,int n)
     17          {
   \                     xmalloc:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   0800               MOVS     R0,R1
     18            return malloc(n);
   \   00000004   14DF               SVC      +20
   \   00000006   00BD               POP      {PC}             ;; return
     19          }
     20          

   \                                 In segment CODE, align 4, keep-with-next
     21          void xmfree(int x,void* ptr)
     22          {
   \                     xmfree:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   0800               MOVS     R0,R1
     23            mfree(ptr);
   \   00000004   15DF               SVC      +21
     24          }
   \   00000006   00BD               POP      {PC}             ;; return
     25          
     26          
     27          typedef struct {
     28            PNGLIST *top;
     29            char *bitmap;
     30          }A_pltop;
     31          
     32          
     33          

   \                                 In segment CODE, align 4, keep-with-next
     34          __arm void clear_cache() // Юзаем для очистки памяти от png, например при закрытии или сворачивании.
     35          {
   \                     clear_cache:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
     36           A_pltop *pltop=PNG_TOP();
   \   00000004   B98100EF           SWI      +33209
   \   00000008   0040A0E1           MOV      R4,R0
     37           LockSched();
   \   0000000C   460100EF           SWI      +326
     38           PNGLIST *pl=pltop->top;
   \   00000010   005094E5           LDR      R5,[R4, #+0]
     39           pltop->top=0;
   \   00000014   0000A0E3           MOV      R0,#+0
   \   00000018   000084E5           STR      R0,[R4, #+0]
     40           UnlockSched();
   \   0000001C   470100EF           SWI      +327
   \   00000020   000055E3           CMP      R5,#+0
   \   00000024   7080BD08           POPEQ    {R4-R6,PC}
     41           while(pl)
     42            {
     43             PNGLIST *pl_prev;
     44             pl_prev=pl;
   \                     ??clear_cache_0:
   \   00000028   0540A0E1           MOV      R4,R5
     45             pl=pl->next;
   \   0000002C   005095E5           LDR      R5,[R5, #+0]
     46             mfree(pl_prev->pngname);
   \   00000030   046084E2           ADD      R6,R4,#+4
   \   00000034   000096E5           LDR      R0,[R6, #+0]
   \   00000038   150000EF           SWI      +21
     47              if(pl_prev->img)
   \   0000003C   040096E5           LDR      R0,[R6, #+4]
   \   00000040   000050E3           CMP      R0,#+0
   \   00000044   0300000A           BEQ      ??clear_cache_1
     48               {
     49                mfree(pl_prev->img->bitmap);
   \   00000048   040090E5           LDR      R0,[R0, #+4]
   \   0000004C   150000EF           SWI      +21
     50                mfree(pl_prev->img);
   \   00000050   040096E5           LDR      R0,[R6, #+4]
   \   00000054   150000EF           SWI      +21
     51               }
     52             mfree(pl_prev);
   \                     ??clear_cache_1:
   \   00000058   0400A0E1           MOV      R0,R4
   \   0000005C   150000EF           SWI      +21
     53            }
   \   00000060   000055E3           CMP      R5,#+0
   \   00000064   EFFFFF1A           BNE      ??clear_cache_0
     54          }
   \   00000068   7080BDE8           POP      {R4-R6,PC}       ;; return
     55          
     56          
     57          
     58          
     59          

   \                                 In segment CODE, align 4, keep-with-next
     60          __arm void read_data_fn(png_structp png_ptr, png_bytep data, png_size_t length)
     61          {
   \                     read_data_fn:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   0250A0E1           MOV      R5,R2
     62            unsigned int err;
     63            int f;
     64            f=(int)png_get_io_ptr(png_ptr);
   \   00000010   5E0100EF           SWI      +350
     65            fread(f, data, length, &err);
   \   00000014   0D30A0E1           MOV      R3,SP
   \   00000018   0520A0E1           MOV      R2,R5
   \   0000001C   0410A0E1           MOV      R1,R4
   \   00000020   0B0000EF           SWI      +11
     66          }
   \   00000024   3180BDE8           POP      {R0,R4,R5,PC}    ;; return
     67          

   \                                 In segment CODE, align 4, keep-with-next
     68          __arm IMGHDR* create_imghdr(const char *fname, int type)
     69          {
   \                     create_imghdr:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   28D04DE2           SUB      SP,SP,#+40
   \   00000008   0150A0E1           MOV      R5,R1
     70            int f;
     71            char buf[number];
     72            unsigned int err;
     73            struct PP
     74            {
     75              char *row;
     76              char *img;
     77              IMGHDR * img_h;
     78            } pp;
     79            IMGHDR * img_hc;
     80            png_structp png_ptr=NULL;
   \   0000000C   0060A0E3           MOV      R6,#+0
   \   00000010   00608DE5           STR      R6,[SP, #+0]
     81            png_infop info_ptr=NULL;
   \   00000014   0C608DE5           STR      R6,[SP, #+12]
     82            png_uint_32 rowbytes;
     83            
     84            if ((f=fopen(fname, A_ReadOnly+A_BIN, P_READ, &err))==-1) return 0;
   \   00000018   14308DE2           ADD      R3,SP,#+20
   \   0000001C   8020A0E3           MOV      R2,#+128
   \   00000020   801CA0E3           MOV      R1,#+32768
   \   00000024   0A0000EF           SWI      +10
   \   00000028   0040A0E1           MOV      R4,R0
   \   0000002C   010070E3           CMN      R0,#+1
   \   00000030   3201000A           BEQ      ??create_imghdr_0
     85            pp.row=NULL;
   \                     ??create_imghdr_1:
   \   00000034   0080A0E3           MOV      R8,#+0
     86            pp.img=NULL;
   \   00000038   0670A0E1           MOV      R7,R6
     87            pp.img_h=NULL;
   \   0000003C   0690A0E1           MOV      R9,R6
     88            
     89            if (fread(f, &buf, number, &err)!=number) goto L_CLOSE_FILE;
   \   00000040   14308DE2           ADD      R3,SP,#+20
   \   00000044   0820A0E3           MOV      R2,#+8
   \   00000048   20108DE2           ADD      R1,SP,#+32
   \   0000004C   0B0000EF           SWI      +11
   \   00000050   080050E3           CMP      R0,#+8
   \   00000054   2001001A           BNE      ??create_imghdr_2
     90            if  (!png_check_sig((png_bytep)buf,number)) goto  L_CLOSE_FILE;
   \   00000058   0810A0E3           MOV      R1,#+8
   \   0000005C   20008DE2           ADD      R0,SP,#+32
   \   00000060   B20100EF           SWI      +434
   \   00000064   000050E3           CMP      R0,#+0
   \   00000068   1B01000A           BEQ      ??create_imghdr_2
     91            
     92            png_ptr = png_create_read_struct_2("1.2.5", (png_voidp)0, 0, 0, (png_voidp)0,(png_malloc_ptr)xmalloc,(png_free_ptr)xmfree);
   \   0000006C   20059FE5           LDR      R0,??create_imghdr_3  ;; xmfree
   \   00000070   01002DE9           PUSH     {R0}
   \   00000074   1C059FE5           LDR      R0,??create_imghdr_3+0x4  ;; xmalloc
   \   00000078   01002DE9           PUSH     {R0}
   \   0000007C   0000A0E3           MOV      R0,#+0
   \   00000080   01002DE9           PUSH     {R0}
   \   00000084   0030A0E1           MOV      R3,R0
   \   00000088   0020A0E1           MOV      R2,R0
   \   0000008C   0010A0E1           MOV      R1,R0
   \   00000090   04059FE5           LDR      R0,??create_imghdr_3+0x8  ;; `?<Constant "1.2.5">`
   \   00000094   A80100EF           SWI      +424
   \   00000098   0C008DE5           STR      R0,[SP, #+12]
     93            if (!png_ptr) goto L_CLOSE_FILE;
   \   0000009C   000050E3           CMP      R0,#+0
   \   000000A0   0CD08DE2           ADD      SP,SP,#+12
   \   000000A4   0C01000A           BEQ      ??create_imghdr_2
     94            
     95            info_ptr = png_create_info_struct(png_ptr);
   \   000000A8   560100EF           SWI      +342
   \   000000AC   0C008DE5           STR      R0,[SP, #+12]
     96            if (!info_ptr)
   \   000000B0   000050E3           CMP      R0,#+0
   \   000000B4   0400001A           BNE      ??create_imghdr_4
     97            {
     98              png_destroy_read_struct(&png_ptr, (png_infopp)NULL, (png_infopp)NULL);
   \   000000B8   0020A0E3           MOV      R2,#+0
   \   000000BC   0210A0E1           MOV      R1,R2
   \                     ??create_imghdr_5:
   \   000000C0   0D00A0E1           MOV      R0,SP
   \   000000C4   570100EF           SWI      +343
     99              goto L_CLOSE_FILE;
   \   000000C8   030100EA           B        ??create_imghdr_2
    100            }
    101            if (setjmp(png_jmpbuf(png_ptr)))
   \                     ??create_imghdr_4:
   \   000000CC   00009DE5           LDR      R0,[SP, #+0]
   \   000000D0   620100EF           SWI      +354
   \   000000D4   000050E3           CMP      R0,#+0
    102            {
    103              png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
   \   000000D8   0020A013           MOVNE    R2,#+0
   \   000000DC   0C108D12           ADDNE    R1,SP,#+12
   \   000000E0   F6FFFF1A           BNE      ??create_imghdr_5
    104              goto L_CLOSE_FILE;
    105            }
    106            
    107            png_set_read_fn(png_ptr, (void *)f, read_data_fn);
   \   000000E4   B4249FE5           LDR      R2,??create_imghdr_3+0xC  ;; read_data_fn
   \   000000E8   00009DE5           LDR      R0,[SP, #+0]
   \   000000EC   0410A0E1           MOV      R1,R4
   \   000000F0   A90100EF           SWI      +425
    108            
    109            png_set_sig_bytes(png_ptr, number);
   \   000000F4   00009DE5           LDR      R0,[SP, #+0]
   \   000000F8   0810A0E3           MOV      R1,#+8
   \   000000FC   580100EF           SWI      +344
    110            
    111            png_read_info(png_ptr, info_ptr);
   \   00000100   0C109DE5           LDR      R1,[SP, #+12]
   \   00000104   00009DE5           LDR      R0,[SP, #+0]
   \   00000108   590100EF           SWI      +345
    112            
    113            png_uint_32 width, height;
    114            int bit_depth, color_type;
    115            
    116            png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type, 0, 0, 0);
   \   0000010C   0000A0E3           MOV      R0,#+0
   \   00000110   01002DE9           PUSH     {R0}
   \   00000114   01002DE9           PUSH     {R0}
   \   00000118   01002DE9           PUSH     {R0}
   \   0000011C   1C008DE2           ADD      R0,SP,#+28
   \   00000120   01002DE9           PUSH     {R0}
   \   00000124   28008DE2           ADD      R0,SP,#+40
   \   00000128   01002DE9           PUSH     {R0}
   \   0000012C   20109DE5           LDR      R1,[SP, #+32]
   \   00000130   1C308DE2           ADD      R3,SP,#+28
   \   00000134   14009DE5           LDR      R0,[SP, #+20]
   \   00000138   18208DE2           ADD      R2,SP,#+24
   \   0000013C   5A0100EF           SWI      +346
    117            
    118            if (type==0)
   \   00000140   000055E3           CMP      R5,#+0
   \   00000144   14D08DE2           ADD      SP,SP,#+20
   \   00000148   0500001A           BNE      ??create_imghdr_6
    119            {
    120              if (color_type == PNG_COLOR_TYPE_GRAY) 
   \   0000014C   10009DE5           LDR      R0,[SP, #+16]
   \   00000150   000050E3           CMP      R0,#+0
    121                type=PNG_1;
    122              else type=DEFAULT_COLOR+1;
   \   00000154   48049F15           LDRNE    R0,??create_imghdr_3+0x10  ;; DEFAULT_COLOR
   \   00000158   FF50A003           MOVEQ    R5,#+255
   \   0000015C   00009015           LDRNE    R0,[R0, #+0]
   \   00000160   01508012           ADDNE    R5,R0,#+1
    123            }
    124            
    125            if (bit_depth < 8) png_set_gray_1_2_4_to_8(png_ptr);
   \                     ??create_imghdr_6:
   \   00000164   18009DE5           LDR      R0,[SP, #+24]
   \   00000168   080050E3           CMP      R0,#+8
   \   0000016C   010000AA           BGE      ??create_imghdr_7
   \   00000170   00009DE5           LDR      R0,[SP, #+0]
   \   00000174   D60100EF           SWI      +470
    126              
    127            if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))
   \                     ??create_imghdr_7:
   \   00000178   00009DE5           LDR      R0,[SP, #+0]
   \   0000017C   0C109DE5           LDR      R1,[SP, #+12]
   \   00000180   1020A0E3           MOV      R2,#+16
   \   00000184   AC0100EF           SWI      +428
   \   00000188   000050E3           CMP      R0,#+0
   \   0000018C   0100000A           BEQ      ??create_imghdr_8
    128              png_set_tRNS_to_alpha(png_ptr); 
   \   00000190   00009DE5           LDR      R0,[SP, #+0]
   \   00000194   AD0100EF           SWI      +429
    129            
    130            if (bit_depth == 16) png_set_strip_16(png_ptr);
   \                     ??create_imghdr_8:
   \   00000198   18009DE5           LDR      R0,[SP, #+24]
   \   0000019C   100050E3           CMP      R0,#+16
   \   000001A0   0100001A           BNE      ??create_imghdr_9
   \   000001A4   00009DE5           LDR      R0,[SP, #+0]
   \   000001A8   AF0100EF           SWI      +431
    131            
    132            if (bit_depth < 8) png_set_packing(png_ptr);
   \                     ??create_imghdr_9:
   \   000001AC   18009DE5           LDR      R0,[SP, #+24]
   \   000001B0   080050E3           CMP      R0,#+8
   \   000001B4   010000AA           BGE      ??create_imghdr_10
   \   000001B8   00009DE5           LDR      R0,[SP, #+0]
   \   000001BC   B00100EF           SWI      +432
    133            
    134            if (color_type == PNG_COLOR_TYPE_PALETTE)
   \                     ??create_imghdr_10:
   \   000001C0   10009DE5           LDR      R0,[SP, #+16]
   \   000001C4   030050E3           CMP      R0,#+3
   \   000001C8   0100001A           BNE      ??create_imghdr_11
    135              png_set_palette_to_rgb(png_ptr);
   \   000001CC   00009DE5           LDR      R0,[SP, #+0]
   \   000001D0   AB0100EF           SWI      +427
    136            
    137            if (color_type == PNG_COLOR_TYPE_GRAY_ALPHA || color_type == PNG_COLOR_TYPE_GRAY)
   \                     ??create_imghdr_11:
   \   000001D4   10009DE5           LDR      R0,[SP, #+16]
   \   000001D8   040050E3           CMP      R0,#+4
   \   000001DC   00005013           CMPNE    R0,#+0
   \   000001E0   0100001A           BNE      ??create_imghdr_12
    138              png_set_gray_to_rgb(png_ptr);
   \   000001E4   00009DE5           LDR      R0,[SP, #+0]
   \   000001E8   B10100EF           SWI      +433
    139            
    140            png_set_filler(png_ptr,0xFF,PNG_FILLER_AFTER);
   \                     ??create_imghdr_12:
   \   000001EC   00009DE5           LDR      R0,[SP, #+0]
   \   000001F0   0120A0E3           MOV      R2,#+1
   \   000001F4   FF10A0E3           MOV      R1,#+255
   \   000001F8   AE0100EF           SWI      +430
    141            png_read_update_info(png_ptr, info_ptr);
   \   000001FC   0C109DE5           LDR      R1,[SP, #+12]
   \   00000200   00009DE5           LDR      R0,[SP, #+0]
   \   00000204   AA0100EF           SWI      +426
    142            
    143            rowbytes = png_get_rowbytes(png_ptr, info_ptr);
   \   00000208   00009DE5           LDR      R0,[SP, #+0]
   \   0000020C   0C109DE5           LDR      R1,[SP, #+12]
   \   00000210   5F0100EF           SWI      +351
    144            
    145            pp.row=malloc(rowbytes);
   \   00000214   140000EF           SWI      +20
   \   00000218   0080A0E1           MOV      R8,R0
    146            pp.img_h=img_hc=malloc(sizeof(IMGHDR));
   \   0000021C   0800A0E3           MOV      R0,#+8
   \   00000220   140000EF           SWI      +20
   \   00000224   1C008DE5           STR      R0,[SP, #+28]
   \   00000228   0090A0E1           MOV      R9,R0
    147            
    148            if (type==PNG_1)
   \   0000022C   04009DE5           LDR      R0,[SP, #+4]
   \   00000230   FF0055E3           CMP      R5,#+255
   \   00000234   2F00001A           BNE      ??create_imghdr_13
    149            {
    150              int rowc_w=(width+7)>>3;
   \   00000238   070080E2           ADD      R0,R0,#+7
   \   0000023C   A051A0E1           LSR      R5,R0,#+3
    151              int size=height*rowc_w;
   \   00000240   08009DE5           LDR      R0,[SP, #+8]
   \   00000244   95000BE0           MUL      R11,R5,R0
    152              unsigned char *iimg=(unsigned char *)(pp.img=malloc(size));
   \   00000248   0B00A0E1           MOV      R0,R11
   \   0000024C   140000EF           SWI      +20
   \   00000250   0070A0E1           MOV      R7,R0
    153              zeromem(iimg,size);
   \   00000254   0B10A0E1           MOV      R1,R11
   \   00000258   1D0100EF           SWI      +285
    154              for (unsigned int y = 0; y<height; y++)
   \   0000025C   08009DE5           LDR      R0,[SP, #+8]
   \   00000260   07A0A0E1           MOV      R10,R7
   \   00000264   00B0A0E3           MOV      R11,#+0
   \   00000268   000050E3           CMP      R0,#+0
   \   0000026C   1400001A           BNE      ??create_imghdr_14
    155              {
    156                png_read_row(png_ptr, (png_bytep)pp.row, NULL);
    157                for (unsigned int x = 0; x<width; x++)
    158                {
    159                  if (!pp.row[x*4+0] && !pp.row[x*4+1] && !pp.row[x*4+2])
    160                    iimg[x>>3]|=(0x80>>(x&7));
    161                }
    162                iimg+=rowc_w;
    163              }
    164              pp.img_h->bpnum=1;
   \                     ??create_imghdr_15:
   \   00000270   0100A0E3           MOV      R0,#+1
   \   00000274   890000EA           B        ??create_imghdr_16
   \                     ??create_imghdr_17:
   \   00000278   001188E0           ADD      R1,R8,R0, LSL #+2
   \   0000027C   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000280   000052E3           CMP      R2,#+0
   \   00000284   0120D105           LDRBEQ   R2,[R1, #+1]
   \   00000288   00005203           CMPEQ    R2,#+0
   \   0000028C   0210D105           LDRBEQ   R1,[R1, #+2]
   \   00000290   00005103           CMPEQ    R1,#+0
   \   00000294   0400001A           BNE      ??create_imghdr_18
   \   00000298   A0118AE0           ADD      R1,R10,R0, LSR #+3
   \   0000029C   0020D1E5           LDRB     R2,[R1, #+0]
   \   000002A0   07C000E2           AND      R12,R0,#0x7
   \   000002A4   332C82E1           ORR      R2,R2,R3, LSR R12
   \   000002A8   0020C1E5           STRB     R2,[R1, #+0]
   \                     ??create_imghdr_18:
   \   000002AC   010080E2           ADD      R0,R0,#+1
   \                     ??create_imghdr_19:
   \   000002B0   04109DE5           LDR      R1,[SP, #+4]
   \   000002B4   010050E1           CMP      R0,R1
   \   000002B8   EEFFFF3A           BCC      ??create_imghdr_17
   \                     ??create_imghdr_20:
   \   000002BC   0AA085E0           ADD      R10,R5,R10
   \   000002C0   01B08BE2           ADD      R11,R11,#+1
   \                     ??create_imghdr_14:
   \   000002C4   08009DE5           LDR      R0,[SP, #+8]
   \   000002C8   00005BE1           CMP      R11,R0
   \   000002CC   E7FFFF2A           BCS      ??create_imghdr_15
   \   000002D0   00009DE5           LDR      R0,[SP, #+0]
   \   000002D4   0020A0E3           MOV      R2,#+0
   \   000002D8   0810A0E1           MOV      R1,R8
   \   000002DC   600100EF           SWI      +352
   \   000002E0   04109DE5           LDR      R1,[SP, #+4]
   \   000002E4   0600A0E1           MOV      R0,R6
   \   000002E8   000051E3           CMP      R1,#+0
   \   000002EC   8030A0E3           MOV      R3,#+128
   \   000002F0   EEFFFF1A           BNE      ??create_imghdr_19
   \   000002F4   F0FFFFEA           B        ??create_imghdr_20
    165            }
    166            else
    167            {
    168              switch (type)
   \                     ??create_imghdr_13:
   \   000002F8   08109DE5           LDR      R1,[SP, #+8]
   \   000002FC   A4A29FE5           LDR      R10,??create_imghdr_3+0x14  ;; ALPHA_THRESHOLD
   \   00000300   910000E0           MUL      R0,R1,R0
   \   00000304   015055E2           SUBS     R5,R5,#+1
   \   00000308   0400000A           BEQ      ??create_imghdr_21
   \   0000030C   015055E2           SUBS     R5,R5,#+1
   \   00000310   2C00000A           BEQ      ??create_imghdr_22
   \   00000314   015055E2           SUBS     R5,R5,#+1
   \   00000318   5700000A           BEQ      ??create_imghdr_23
   \   0000031C   600000EA           B        ??create_imghdr_24
    169              {
    170              case PNG_8:
    171                {
    172                  unsigned char *iimg=(unsigned char *)(pp.img=malloc(width*height));
   \                     ??create_imghdr_21:
   \   00000320   140000EF           SWI      +20
   \   00000324   0070A0E1           MOV      R7,R0
    173                  for (unsigned int y = 0; y<height; y++)
   \   00000328   08009DE5           LDR      R0,[SP, #+8]
   \   0000032C   0750A0E1           MOV      R5,R7
   \   00000330   00B0A0E3           MOV      R11,#+0
   \   00000334   000050E3           CMP      R0,#+0
   \   00000338   0200001A           BNE      ??create_imghdr_25
    174                  {
    175                    png_read_row(png_ptr, (png_bytep)pp.row, NULL);
    176                    for (unsigned int x = 0; x<width; x++)
    177                    {
    178                      if (pp.row[x*4+3]<ALPHA_THRESHOLD)
    179                        *iimg++=0xC0;
    180                      else
    181                      {
    182                        unsigned char c=(pp.row[x*4+0] & 0xE0);
    183                        c|=((pp.row[x*4+1]>>3)&0x1C);
    184                        c|=((pp.row[x*4+2]>>6)&0x3);
    185                        *iimg++=c;
    186                      }
    187                    }
    188                  }
    189                  pp.img_h->bpnum=5;
   \                     ??create_imghdr_26:
   \   0000033C   0500A0E3           MOV      R0,#+5
   \   00000340   560000EA           B        ??create_imghdr_16
   \                     ??create_imghdr_27:
   \   00000344   01B08BE2           ADD      R11,R11,#+1
   \                     ??create_imghdr_25:
   \   00000348   08009DE5           LDR      R0,[SP, #+8]
   \   0000034C   00005BE1           CMP      R11,R0
   \   00000350   F9FFFF2A           BCS      ??create_imghdr_26
   \   00000354   00009DE5           LDR      R0,[SP, #+0]
   \   00000358   0020A0E3           MOV      R2,#+0
   \   0000035C   0810A0E1           MOV      R1,R8
   \   00000360   600100EF           SWI      +352
   \   00000364   04109DE5           LDR      R1,[SP, #+4]
   \   00000368   0600A0E1           MOV      R0,R6
   \   0000036C   000051E3           CMP      R1,#+0
   \   00000370   1CC0A0E3           MOV      R12,#+28
   \   00000374   0900001A           BNE      ??create_imghdr_28
   \   00000378   F1FFFFEA           B        ??create_imghdr_27
   \                     ??create_imghdr_29:
   \   0000037C   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000380   0130D1E5           LDRB     R3,[R1, #+1]
   \   00000384   0210D1E5           LDRB     R1,[R1, #+2]
   \   00000388   E02002E2           AND      R2,R2,#0xE0
   \   0000038C   A3310CE0           AND      R3,R12,R3, LSR #+3
   \   00000390   022083E1           ORR      R2,R3,R2
   \   00000394   211382E1           ORR      R1,R2,R1, LSR #+6
   \                     ??create_imghdr_30:
   \   00000398   ........           STRB     R1,[R5], #+1
   \   0000039C   010080E2           ADD      R0,R0,#+1
   \                     ??create_imghdr_28:
   \   000003A0   04109DE5           LDR      R1,[SP, #+4]
   \   000003A4   010050E1           CMP      R0,R1
   \   000003A8   E5FFFF2A           BCS      ??create_imghdr_27
   \   000003AC   00309AE5           LDR      R3,[R10, #+0]
   \   000003B0   001188E0           ADD      R1,R8,R0, LSL #+2
   \   000003B4   0320D1E5           LDRB     R2,[R1, #+3]
   \   000003B8   030052E1           CMP      R2,R3
   \   000003BC   EEFFFF2A           BCS      ??create_imghdr_29
   \   000003C0   C010A0E3           MOV      R1,#+192
   \   000003C4   F3FFFFEA           B        ??create_imghdr_30
    190                  break;
    191                }
    192              case PNG_16:
    193                {
    194                  unsigned short *iimg=(unsigned short *)(pp.img=malloc(width*height*2));
   \                     ??create_imghdr_22:
   \   000003C8   8000A0E1           LSL      R0,R0,#+1
   \   000003CC   140000EF           SWI      +20
   \   000003D0   0070A0E1           MOV      R7,R0
    195                  for (unsigned int y = 0; y<height; y++)
   \   000003D4   08009DE5           LDR      R0,[SP, #+8]
   \   000003D8   0750A0E1           MOV      R5,R7
   \   000003DC   00B0A0E3           MOV      R11,#+0
   \   000003E0   000050E3           CMP      R0,#+0
   \   000003E4   0200001A           BNE      ??create_imghdr_31
    196                  {
    197                    png_read_row(png_ptr, (png_bytep)pp.row, NULL);
    198                    for (unsigned int x = 0; x<width; x++)
    199                    {
    200                      if (pp.row[x*4+3]<ALPHA_THRESHOLD)
    201                        *iimg++=0xE000;
    202                      else
    203                      {
    204                        unsigned int c=((pp.row[x*4+0]<<8)&0xF800);
    205                        c|=((pp.row[x*4+1]<<3)&0x7E0);
    206                        c|=((pp.row[x*4+2]>>3)&0x1F);
    207                        *iimg++=c;
    208                      }
    209                    }
    210                  }
    211                  pp.img_h->bpnum=8;
   \                     ??create_imghdr_32:
   \   000003E8   0800A0E3           MOV      R0,#+8
   \   000003EC   2B0000EA           B        ??create_imghdr_16
   \                     ??create_imghdr_33:
   \   000003F0   01B08BE2           ADD      R11,R11,#+1
   \                     ??create_imghdr_31:
   \   000003F4   08009DE5           LDR      R0,[SP, #+8]
   \   000003F8   00005BE1           CMP      R11,R0
   \   000003FC   F9FFFF2A           BCS      ??create_imghdr_32
   \   00000400   00009DE5           LDR      R0,[SP, #+0]
   \   00000404   0020A0E3           MOV      R2,#+0
   \   00000408   0810A0E1           MOV      R1,R8
   \   0000040C   600100EF           SWI      +352
   \   00000410   04109DE5           LDR      R1,[SP, #+4]
   \   00000414   0600A0E1           MOV      R0,R6
   \   00000418   000051E3           CMP      R1,#+0
   \   0000041C   7ECEA0E3           MOV      R12,#+2016
   \   00000420   0B00001A           BNE      ??create_imghdr_34
   \   00000424   F1FFFFEA           B        ??create_imghdr_33
   \                     ??create_imghdr_35:
   \   00000428   0020D1E5           LDRB     R2,[R1, #+0]
   \   0000042C   F83CA0E3           MOV      R3,#+63488
   \   00000430   022403E0           AND      R2,R3,R2, LSL #+8
   \   00000434   0130D1E5           LDRB     R3,[R1, #+1]
   \   00000438   0210D1E5           LDRB     R1,[R1, #+2]
   \   0000043C   83310CE0           AND      R3,R12,R3, LSL #+3
   \   00000440   022083E1           ORR      R2,R3,R2
   \   00000444   A111A0E1           LSR      R1,R1,#+3
   \   00000448   021081E1           ORR      R1,R1,R2
   \                     ??create_imghdr_36:
   \   0000044C   ........           STRH     R1,[R5], #+2
   \   00000450   010080E2           ADD      R0,R0,#+1
   \                     ??create_imghdr_34:
   \   00000454   04109DE5           LDR      R1,[SP, #+4]
   \   00000458   010050E1           CMP      R0,R1
   \   0000045C   E3FFFF2A           BCS      ??create_imghdr_33
   \   00000460   00309AE5           LDR      R3,[R10, #+0]
   \   00000464   001188E0           ADD      R1,R8,R0, LSL #+2
   \   00000468   0320D1E5           LDRB     R2,[R1, #+3]
   \   0000046C   030052E1           CMP      R2,R3
   \   00000470   ECFFFF2A           BCS      ??create_imghdr_35
   \   00000474   E01CA0E3           MOV      R1,#+57344
   \   00000478   F3FFFFEA           B        ??create_imghdr_36
    212                  break;
    213                }
    214              case PNG_24:
    215                {
    216                  unsigned char *iimg=(unsigned char *)(pp.img=malloc((width*height)<<2));
   \                     ??create_imghdr_23:
   \   0000047C   0001A0E1           LSL      R0,R0,#+2
   \   00000480   140000EF           SWI      +20
   \   00000484   0070A0E1           MOV      R7,R0
    217                  for (unsigned int y = 0; y<height; y++)
   \   00000488   08009DE5           LDR      R0,[SP, #+8]
   \   0000048C   0750A0E1           MOV      R5,R7
   \   00000490   00A0A0E3           MOV      R10,#+0
   \   00000494   000050E3           CMP      R0,#+0
   \   00000498   2900001A           BNE      ??create_imghdr_37
    218                  {
    219                    png_read_row(png_ptr, (png_bytep)pp.row, NULL);
    220                    for (unsigned int x = 0; x<width; x++)
    221                    {
    222          	    unsigned int c;
    223                      *iimg++=pp.row[x*4+2];
    224                      *iimg++=pp.row[x*4+1];
    225                      *iimg++=pp.row[x*4+0];
    226          	    c=pp.row[x*4+3];
    227                      *iimg++=c;
    228                    }
    229                  }
    230                  pp.img_h->bpnum=0xA;
   \                     ??create_imghdr_38:
   \   0000049C   0A00A0E3           MOV      R0,#+10
   \                     ??create_imghdr_16:
   \   000004A0   B200C9E1           STRH     R0,[R9, #+2]
    231                  break;
    232                }
    233              }
    234            }
    235            pp.img_h->w=width;
   \                     ??create_imghdr_24:
   \   000004A4   04009DE5           LDR      R0,[SP, #+4]
   \   000004A8   0000C9E5           STRB     R0,[R9, #+0]
    236            pp.img_h->h=height;
   \   000004AC   08009DE5           LDR      R0,[SP, #+8]
   \   000004B0   0100C9E5           STRB     R0,[R9, #+1]
    237            pp.img_h->bitmap=pp.img;
   \   000004B4   047089E5           STR      R7,[R9, #+4]
    238            
    239            png_read_end(png_ptr, info_ptr);
   \   000004B8   0C109DE5           LDR      R1,[SP, #+12]
   \   000004BC   00009DE5           LDR      R0,[SP, #+0]
   \   000004C0   5D0100EF           SWI      +349
    240            png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
   \   000004C4   0020A0E3           MOV      R2,#+0
   \   000004C8   0C108DE2           ADD      R1,SP,#+12
   \   000004CC   0D00A0E1           MOV      R0,SP
   \   000004D0   570100EF           SWI      +343
    241            if (!pp.img)
   \   000004D4   000057E3           CMP      R7,#+0
   \   000004D8   2500001A           BNE      ??create_imghdr_39
    242            {
    243            L_CLOSE_FILE:
    244              mfree(pp.row);
   \                     ??create_imghdr_2:
   \   000004DC   0800A0E1           MOV      R0,R8
   \   000004E0   150000EF           SWI      +21
    245              mfree(pp.img);
   \   000004E4   0700A0E1           MOV      R0,R7
   \   000004E8   150000EF           SWI      +21
    246              mfree(pp.img_h);
   \   000004EC   0900A0E1           MOV      R0,R9
   \   000004F0   150000EF           SWI      +21
    247              fclose(f, &err);
   \   000004F4   14108DE2           ADD      R1,SP,#+20
   \   000004F8   0400A0E1           MOV      R0,R4
   \   000004FC   0D0000EF           SWI      +13
    248              return NULL;
   \                     ??create_imghdr_0:
   \   00000500   0000A0E3           MOV      R0,#+0
   \   00000504   28D08DE2           ADD      SP,SP,#+40
   \   00000508   F08FBDE8           POP      {R4-R11,PC}
    249            }
   \                     ??create_imghdr_40:
   \   0000050C   001188E0           ADD      R1,R8,R0, LSL #+2
   \   00000510   0220D1E5           LDRB     R2,[R1, #+2]
   \   00000514   010080E2           ADD      R0,R0,#+1
   \   00000518   ........           STRB     R2,[R5], #+1
   \   0000051C   0120D1E5           LDRB     R2,[R1, #+1]
   \   00000520   ........           STRB     R2,[R5], #+1
   \   00000524   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000528   ........           STRB     R2,[R5], #+1
   \   0000052C   0310D1E5           LDRB     R1,[R1, #+3]
   \   00000530   ........           STRB     R1,[R5], #+1
   \                     ??create_imghdr_41:
   \   00000534   04109DE5           LDR      R1,[SP, #+4]
   \   00000538   010050E1           CMP      R0,R1
   \   0000053C   F2FFFF3A           BCC      ??create_imghdr_40
   \                     ??create_imghdr_42:
   \   00000540   01A08AE2           ADD      R10,R10,#+1
   \                     ??create_imghdr_37:
   \   00000544   08009DE5           LDR      R0,[SP, #+8]
   \   00000548   00005AE1           CMP      R10,R0
   \   0000054C   D2FFFF2A           BCS      ??create_imghdr_38
   \   00000550   00009DE5           LDR      R0,[SP, #+0]
   \   00000554   0020A0E3           MOV      R2,#+0
   \   00000558   0810A0E1           MOV      R1,R8
   \   0000055C   600100EF           SWI      +352
   \   00000560   04109DE5           LDR      R1,[SP, #+4]
   \   00000564   0600A0E1           MOV      R0,R6
   \   00000568   000051E3           CMP      R1,#+0
   \   0000056C   F0FFFF1A           BNE      ??create_imghdr_41
   \   00000570   F2FFFFEA           B        ??create_imghdr_42
    250            mfree(pp.row);
   \                     ??create_imghdr_39:
   \   00000574   0800A0E1           MOV      R0,R8
   \   00000578   150000EF           SWI      +21
    251            fclose(f, &err);
   \   0000057C   14108DE2           ADD      R1,SP,#+20
   \   00000580   0400A0E1           MOV      R0,R4
   \   00000584   0D0000EF           SWI      +13
    252            return (img_hc);
   \   00000588   1C009DE5           LDR      R0,[SP, #+28]
   \   0000058C   28D08DE2           ADD      SP,SP,#+40
   \   00000590   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??create_imghdr_3:
   \   00000594   ........           DC32     xmfree
   \   00000598   ........           DC32     xmalloc
   \   0000059C   ........           DC32     `?<Constant "1.2.5">`
   \   000005A0   ........           DC32     read_data_fn
   \   000005A4   ........           DC32     DEFAULT_COLOR
   \   000005A8   ........           DC32     ALPHA_THRESHOLD
    253          }
    254          

   \                                 In segment DATA_N, align 4, align-sorted
    255          volatile __no_init PNGTOP_DESC pngtop; 
   \                     pngtop:
   \   00000000                      DS8 12
    256          
    257          #pragma inline
    258          int tolower(int C)
    259          {
    260            if ((C>='A' && C<='Z')) C-='A'-'a';
    261            return(C);
    262          }
    263          

   \                                 In segment CODE, align 4, keep-with-next
    264          char* strcpy_tolow(char *s1,const char *s2)
    265          {
   \                     strcpy_tolow:
   \   00000000   0A78               LDRB     R2,[R1, #+0]
   \   00000002   002A               CMP      R2,#+0
   \   00000004   0BD0               BEQ      ??strcpy_tolow_0
    266            while(*s2)
    267            {
    268              *s1++=tolower(*s2++);   
   \                     ??strcpy_tolow_1:
   \   00000006   0A78               LDRB     R2,[R1, #+0]
   \   00000008   412A               CMP      R2,#+65
   \   0000000A   02DB               BLT      ??strcpy_tolow_2
   \   0000000C   5B2A               CMP      R2,#+91
   \   0000000E   00DA               BGE      ??strcpy_tolow_2
   \   00000010   2032               ADDS     R2,R2,#+32
   \                     ??strcpy_tolow_2:
   \   00000012   491C               ADDS     R1,R1,#+1
   \   00000014   0270               STRB     R2,[R0, #+0]
    269            }
   \   00000016   0A78               LDRB     R2,[R1, #+0]
   \   00000018   401C               ADDS     R0,R0,#+1
   \   0000001A   002A               CMP      R2,#+0
   \   0000001C   F3D1               BNE      ??strcpy_tolow_1
    270            *s1=0;
   \                     ??strcpy_tolow_0:
   \   0000001E   0021               MOVS     R1,#+0
   \   00000020   0170               STRB     R1,[R0, #+0]
    271            return s1;
   \   00000022   7047               BX       LR
    272          }
    273          

   \                                 In segment CODE, align 4, keep-with-next
    274          __arm void print10(char *s, unsigned int v)
    275          {
    276            unsigned int buf=0xF;
   \                     print10:
   \   00000000   8C309FE5           LDR      R3,??print10_0   ;; 0xffffffffcccccccd
   \   00000004   10002DE9           PUSH     {R4}
   \   00000008   0F20A0E3           MOV      R2,#+15
   \   0000000C   0A0051E3           CMP      R1,#+10
   \   00000010   0A00003A           BCC      ??print10_1
    277            while(v>=10)
    278            {
    279              buf=(buf<<4)|(v%10);
   \                     ??print10_2:
   \   00000014   93C184E0           UMULL    R12,R4,R3,R1
   \   00000018   0AC0A0E3           MOV      R12,#+10
   \   0000001C   A441A0E1           LSR      R4,R4,#+3
   \   00000020   9C0404E0           MUL      R4,R12,R4
   \   00000024   044041E0           SUB      R4,R1,R4
   \   00000028   022284E1           ORR      R2,R4,R2, LSL #+4
    280              v/=10;
   \   0000002C   93418CE0           UMULL    R4,R12,R3,R1
   \   00000030   ACC1A0E1           LSR      R12,R12,#+3
   \   00000034   0C10A0E1           MOV      R1,R12
    281            }
   \   00000038   0A0051E3           CMP      R1,#+10
   \   0000003C   F4FFFF2A           BCS      ??print10_2
    282            *s++=v+'0';
   \                     ??print10_1:
   \   00000040   301081E2           ADD      R1,R1,#+48
   \   00000044   ........           STRB     R1,[R0], #+1
   \   00000048   020000EA           B        ??print10_3
    283            while((v=buf&0x0F)<10) {*s++=v+'0'; buf>>=4;}
   \                     ??print10_4:
   \   0000004C   301081E2           ADD      R1,R1,#+48
   \   00000050   ........           STRB     R1,[R0], #+1
   \   00000054   2222A0E1           LSR      R2,R2,#+4
   \                     ??print10_3:
   \   00000058   0F1002E2           AND      R1,R2,#0xF
   \   0000005C   0A0051E3           CMP      R1,#+10
   \   00000060   F9FFFF3A           BCC      ??print10_4
    284            *s++='.';
   \   00000064   2E10A0E3           MOV      R1,#+46
   \   00000068   ........           STRB     R1,[R0], #+1
    285            *s++='p';
   \   0000006C   7010A0E3           MOV      R1,#+112
   \   00000070   ........           STRB     R1,[R0], #+1
    286            *s++='n';
   \   00000074   6E10A0E3           MOV      R1,#+110
   \   00000078   ........           STRB     R1,[R0], #+1
    287            *s++='g';
   \   0000007C   6710A0E3           MOV      R1,#+103
   \   00000080   ........           STRB     R1,[R0], #+1
    288            *s='\0';
   \   00000084   0010A0E3           MOV      R1,#+0
   \   00000088   0010C0E5           STRB     R1,[R0, #+0]
    289          }
   \   0000008C   1000BDE8           POP      {R4}
   \   00000090   1EFF2FE1           BX       LR               ;; return
   \                     ??print10_0:
   \   00000094   CDCCCCCC           DC32     0xffffffffcccccccd
    290          

   \                                 In segment CODE, align 4, keep-with-next
    291          __arm IMGHDR *find_png_in_cache(char *png_name)
    292          {
   \                     find_png_in_cache:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
    293            PNGLIST *pl;
    294            PNGLIST *pl_prev;
    295            LockSched();
    296            pl=(PNGLIST *)(&(pngtop.pltop));
   \   00000004   ........           LDR      R5,??DataTable1  ;; pngtop
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0560A0E1           MOV      R6,R5
   \   00000010   460100EF           SWI      +326
    297            pl_prev=NULL;  
   \   00000014   0070A0E3           MOV      R7,#+0
   \   00000018   000000EA           B        ??find_png_in_cache_0
    298            while((pl=pl->next))
    299            {
    300              if (!strcmp(pl->pngname,png_name))
    301              {
    302                //Найден, переносим в начало и выходим
    303                if (pl_prev)
    304                {
    305          	//Только если не в самом начале
    306          	pl_prev->next=pl->next; //Удалили из найденого места
    307          	pl->next=(PNGLIST *)(pngtop.pltop); //Следующий - весь список
    308          	pngtop.pltop=pl; //А первый в списке - найденый
    309                }
    310                UnlockSched();
    311                return(pl->img);
    312              }
    313              pl_prev=pl; //Текущий обработанный - теперь предыдущий
   \                     ??find_png_in_cache_1:
   \   0000001C   0670A0E1           MOV      R7,R6
   \                     ??find_png_in_cache_0:
   \   00000020   006096E5           LDR      R6,[R6, #+0]
   \   00000024   000056E3           CMP      R6,#+0
   \   00000028   0E00000A           BEQ      ??find_png_in_cache_2
   \   0000002C   040096E5           LDR      R0,[R6, #+4]
   \   00000030   0410A0E1           MOV      R1,R4
   \   00000034   190000EF           SWI      +25
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   F6FFFF1A           BNE      ??find_png_in_cache_1
   \   00000040   000057E3           CMP      R7,#+0
   \   00000044   0400000A           BEQ      ??find_png_in_cache_3
   \   00000048   000096E5           LDR      R0,[R6, #+0]
   \   0000004C   000087E5           STR      R0,[R7, #+0]
   \   00000050   000095E5           LDR      R0,[R5, #+0]
   \   00000054   000086E5           STR      R0,[R6, #+0]
   \   00000058   006085E5           STR      R6,[R5, #+0]
   \                     ??find_png_in_cache_3:
   \   0000005C   470100EF           SWI      +327
   \   00000060   080096E5           LDR      R0,[R6, #+8]
   \   00000064   F080BDE8           POP      {R4-R7,PC}
    314            }
    315            UnlockSched();
   \                     ??find_png_in_cache_2:
   \   00000068   470100EF           SWI      +327
    316            return (0);
   \   0000006C   0000A0E3           MOV      R0,#+0
   \   00000070   F080BDE8           POP      {R4-R7,PC}       ;; return
    317          }
    318          

   \                                 In segment CODE, align 4, keep-with-next
    319          __arm IMGHDR* PatchGetPIT(unsigned int pic)
    320          {
   \                     PatchGetPIT:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
    321            IMGHDR * img;
    322            unsigned int i;
    323            char fname[256];
    324            
    325            PNGLIST *pl;
    326            PNGLIST *pl_prev;
    327            PNGLIST *cur;
    328            unsigned int mask80;
    329            unsigned int mask40;
    330            char *bp;
    331            if ((pic>>28)==0xA)
   \   00000004   ........           LDR      R4,??DataTable1  ;; pngtop
   \   00000008   70A29FE5           LDR      R10,??PatchGetPIT_0  ;; DEFAULT_FOLDER
   \   0000000C   40DF4DE2           SUB      SP,SP,#+256
   \   00000010   0050A0E1           MOV      R5,R0
   \   00000014   250EA0E1           LSR      R0,R5,#+28
   \   00000018   0A0050E3           CMP      R0,#+10
   \   0000001C   0E00001A           BNE      ??PatchGetPIT_1
    332            {
    333              strcpy_tolow(fname,(char*)pic);
   \   00000020   0510A0E1           MOV      R1,R5
   \   00000024   0D00A0E1           MOV      R0,SP
   \   00000028   ........           BLX      strcpy_tolow
    334              img=find_png_in_cache(fname);
   \   0000002C   0D00A0E1           MOV      R0,SP
   \   00000030   ........           BL       find_png_in_cache
   \   00000034   0050B0E1           MOVS     R5,R0
    335              if (img) return (img);
   \   00000038   0000000A           BEQ      ??PatchGetPIT_2
   \                     ??PatchGetPIT_3:
   \   0000003C   530000EA           B        ??PatchGetPIT_4
    336              img=create_imghdr(fname,0);
   \                     ??PatchGetPIT_2:
   \   00000040   0010A0E3           MOV      R1,#+0
   \   00000044   0D00A0E1           MOV      R0,SP
   \   00000048   ........           BL       create_imghdr
   \   0000004C   0050B0E1           MOVS     R5,R0
    337              if (!img) return ((IMGHDR *)&empty_img);
   \   00000050   5B00001A           BNE      ??PatchGetPIT_5
   \   00000054   0C008AE2           ADD      R0,R10,#+12
   \   00000058   4D0000EA           B        ??PatchGetPIT_6
    338            }
    339            else
    340            {
    341              //Ищем в списке динамических иконок
    342              {
    343                DYNPNGICONLIST *dynp;
    344                LockSched();
   \                     ??PatchGetPIT_1:
   \   0000005C   460100EF           SWI      +326
    345                dynp=pngtop.dyn_pltop;
   \   00000060   080094E5           LDR      R0,[R4, #+8]
   \   00000064   000000EA           B        ??PatchGetPIT_7
    346                while(dynp)
    347                {
    348          	if (dynp->icon==pic)
    349          	{
    350          	  IMGHDR *i=dynp->img;
    351          	  if (i)
    352          	  {
    353          	    UnlockSched();
    354          	    return(i);
    355          	  }	  
    356          	}
    357          	dynp=dynp->next;
   \                     ??PatchGetPIT_8:
   \   00000068   000090E5           LDR      R0,[R0, #+0]
   \                     ??PatchGetPIT_7:
   \   0000006C   000050E3           CMP      R0,#+0
   \   00000070   0800000A           BEQ      ??PatchGetPIT_9
   \   00000074   041090E5           LDR      R1,[R0, #+4]
   \   00000078   050051E1           CMP      R1,R5
   \   0000007C   F9FFFF1A           BNE      ??PatchGetPIT_8
   \   00000080   086090E5           LDR      R6,[R0, #+8]
   \   00000084   000056E3           CMP      R6,#+0
   \   00000088   F6FFFF0A           BEQ      ??PatchGetPIT_8
   \   0000008C   470100EF           SWI      +327
   \   00000090   0600A0E1           MOV      R0,R6
   \   00000094   3E0000EA           B        ??PatchGetPIT_6
    358                }
    359                UnlockSched();
   \                     ??PatchGetPIT_9:
   \   00000098   470100EF           SWI      +327
    360              }
    361              if ((pngtop.bitmap) && (pic<20000))
   \   0000009C   040094E5           LDR      R0,[R4, #+4]
   \   000000A0   000050E3           CMP      R0,#+0
   \   000000A4   7300000A           BEQ      ??PatchGetPIT_10
   \   000000A8   2000A0E3           MOV      R0,#+32
   \   000000AC   4E0C80E3           ORR      R0,R0,#0x4E00
   \   000000B0   000055E1           CMP      R5,R0
   \   000000B4   1D00002A           BCS      ??PatchGetPIT_11
    362              {
    363                mask40=(mask80=0x80UL>>((pic&3)<<1))>>1;
   \   000000B8   8000A0E3           MOV      R0,#+128
    364                bp=pngtop.bitmap+(pic>>2);
    365                if ((i=*bp)&mask80)  // Есть запись в битмапе
   \   000000BC   C0619FE5           LDR      R6,??PatchGetPIT_0+0x4  ;; DEFAULT_DISK_N2
   \   000000C0   031005E2           AND      R1,R5,#0x3
   \   000000C4   8110A0E1           LSL      R1,R1,#+1
   \   000000C8   30B1A0E1           LSR      R11,R0,R1
   \   000000CC   040094E5           LDR      R0,[R4, #+4]
   \   000000D0   AB90A0E1           LSR      R9,R11,#+1
   \   000000D4   258180E0           ADD      R8,R0,R5, LSR #+2
   \   000000D8   0070D8E5           LDRB     R7,[R8, #+0]
   \   000000DC   07001BE1           TST      R11,R7
   \   000000E0   1400000A           BEQ      ??PatchGetPIT_12
    366                {
    367                  if (i&mask40)  
   \   000000E4   070019E1           TST      R9,R7
   \   000000E8   1000000A           BEQ      ??PatchGetPIT_11
    368                  {
    369                    char *next=strcpy_tolow(fname+1,DEFAULT_FOLDER); // Картинка вроде как есть на диске
   \   000000EC   0A10A0E1           MOV      R1,R10
   \   000000F0   01008DE2           ADD      R0,SP,#+1
   \   000000F4   ........           BLX      strcpy_tolow
    370          	  *fname=DEFAULT_DISK_N2+'0';
   \   000000F8   002096E5           LDR      R2,[R6, #+0]
    371                    print10(next,pic);
   \   000000FC   0510A0E1           MOV      R1,R5
   \   00000100   302082E2           ADD      R2,R2,#+48
   \   00000104   0020CDE5           STRB     R2,[SP, #+0]
   \   00000108   ........           BL       print10
    372                    img=find_png_in_cache(fname);
   \   0000010C   0D00A0E1           MOV      R0,SP
   \   00000110   ........           BL       find_png_in_cache
   \   00000114   0050B0E1           MOVS     R5,R0
    373                    if (img) return (img);
   \   00000118   1C00001A           BNE      ??PatchGetPIT_4
    374                    img=create_imghdr(fname,0);          
   \   0000011C   0010A0E3           MOV      R1,#+0
   \   00000120   0D00A0E1           MOV      R0,SP
   \   00000124   ........           BL       create_imghdr
   \   00000128   0050A0E1           MOV      R5,R0
   \   0000012C   240000EA           B        ??PatchGetPIT_5
    375                  } 
    376                  else return(0);                                // Картинки нет - выходим
   \                     ??PatchGetPIT_11:
   \   00000130   0000A0E3           MOV      R0,#+0
   \   00000134   160000EA           B        ??PatchGetPIT_6
    377                }
    378                else 
    379                {
    380          	LockSched();
   \                     ??PatchGetPIT_12:
   \   00000138   460100EF           SWI      +326
    381          	*bp|=mask80; // Записи нет, ставим флаг что есть
   \   0000013C   0000D8E5           LDRB     R0,[R8, #+0]
   \   00000140   00008BE1           ORR      R0,R11,R0
   \   00000144   0000C8E5           STRB     R0,[R8, #+0]
    382          	UnlockSched();
   \   00000148   470100EF           SWI      +327
    383                  char *next=strcpy_tolow(fname+1,DEFAULT_FOLDER);
   \   0000014C   0A10A0E1           MOV      R1,R10
   \   00000150   01008DE2           ADD      R0,SP,#+1
   \   00000154   ........           BLX      strcpy_tolow
    384          	*fname=DEFAULT_DISK_N2+'0';
   \   00000158   002096E5           LDR      R2,[R6, #+0]
    385                  print10(next,pic);
   \   0000015C   0510A0E1           MOV      R1,R5
   \   00000160   302082E2           ADD      R2,R2,#+48
   \   00000164   0020CDE5           STRB     R2,[SP, #+0]
   \   00000168   ........           BL       print10
    386                  img=find_png_in_cache(fname);
   \   0000016C   0D00A0E1           MOV      R0,SP
   \   00000170   ........           BL       find_png_in_cache
   \   00000174   0050B0E1           MOVS     R5,R0
    387                  if (img)
   \   00000178   0700000A           BEQ      ??PatchGetPIT_13
    388                  {
    389          	  LockSched();
   \   0000017C   460100EF           SWI      +326
    390          	  *bp|=mask40;
   \   00000180   0000D8E5           LDRB     R0,[R8, #+0]
   \   00000184   000089E1           ORR      R0,R9,R0
   \   00000188   0000C8E5           STRB     R0,[R8, #+0]
    391          	  UnlockSched();
   \   0000018C   470100EF           SWI      +327
    392                    return (img);
   \                     ??PatchGetPIT_4:
   \   00000190   0500A0E1           MOV      R0,R5
   \                     ??PatchGetPIT_6:
   \   00000194   40DF8DE2           ADD      SP,SP,#+256
   \   00000198   F08FBDE8           POP      {R4-R11,PC}
    393                  }
    394                  img=create_imghdr(fname,0);                 // Пробуем создать
   \                     ??PatchGetPIT_13:
   \   0000019C   0010A0E3           MOV      R1,#+0
   \   000001A0   0D00A0E1           MOV      R0,SP
   \   000001A4   ........           BL       create_imghdr
   \   000001A8   0050B0E1           MOVS     R5,R0
    395                  if (img)
   \   000001AC   DFFFFF0A           BEQ      ??PatchGetPIT_11
    396                  {
    397          	  LockSched();
   \   000001B0   460100EF           SWI      +326
    398          	  *bp|=mask40;
   \   000001B4   0000D8E5           LDRB     R0,[R8, #+0]
   \   000001B8   000089E1           ORR      R0,R9,R0
   \   000001BC   0000C8E5           STRB     R0,[R8, #+0]
    399          	  UnlockSched();
   \   000001C0   470100EF           SWI      +327
    400                  }
    401                  else  return (0);
    402                }
    403              }
    404              else return(0);
    405            }
    406            //Ничего не нашли, теперь пробуем добавить
    407            
    408            //if (!img) return (0); //Нечего добавлять
    409            cur=malloc(sizeof(PNGLIST)); //Создаем элемент списка
   \                     ??PatchGetPIT_5:
   \   000001C4   0C00A0E3           MOV      R0,#+12
   \   000001C8   140000EF           SWI      +20
   \   000001CC   0060A0E1           MOV      R6,R0
    410            cur->pngname=malloc(strlen(fname)+1);
   \   000001D0   0D00A0E1           MOV      R0,SP
   \   000001D4   1B0000EF           SWI      +27
   \   000001D8   010080E2           ADD      R0,R0,#+1
   \   000001DC   140000EF           SWI      +20
   \   000001E0   040086E5           STR      R0,[R6, #+4]
    411            strcpy(cur->pngname,fname);
   \   000001E4   0D10A0E1           MOV      R1,SP
   \   000001E8   1A0000EF           SWI      +26
    412            cur->img=img;
   \   000001EC   085086E5           STR      R5,[R6, #+8]
    413            i=0; //Это количество элементов в списке
    414            LockSched();
   \   000001F0   460100EF           SWI      +326
    415            cur->next=(PNGLIST *)(pngtop.pltop); //Следующий - весь список
   \   000001F4   000094E5           LDR      R0,[R4, #+0]
   \   000001F8   0050A0E3           MOV      R5,#+0
   \   000001FC   0070A0E3           MOV      R7,#+0
   \   00000200   000086E5           STR      R0,[R6, #+0]
    416            pngtop.pltop=cur; //Первый в списке - новый элемент
   \   00000204   006084E5           STR      R6,[R4, #+0]
    417            //Теперь подрезаем конец
    418            pl=(PNGLIST *)(&(pngtop.pltop));
    419            do
    420            {
    421              pl_prev=pl;
   \                     ??PatchGetPIT_14:
   \   00000208   0400A0E1           MOV      R0,R4
    422              pl=pl->next;
   \   0000020C   004094E5           LDR      R4,[R4, #+0]
    423              if (!pl)
   \   00000210   000054E3           CMP      R4,#+0
   \   00000214   0100001A           BNE      ??PatchGetPIT_15
    424              {
    425                //Закончились элементы раньше
    426                UnlockSched();
   \   00000218   470100EF           SWI      +327
    427                return(cur->img);
   \   0000021C   140000EA           B        ??PatchGetPIT_16
    428              }
    429              i++;
    430            }
    431            while(i<=CACHE_PNG); //Пока количество элементов меньше допустимого
   \                     ??PatchGetPIT_15:
   \   00000220   60109FE5           LDR      R1,??PatchGetPIT_0+0x8  ;; CACHE_PNG
   \   00000224   017087E2           ADD      R7,R7,#+1
   \   00000228   001091E5           LDR      R1,[R1, #+0]
   \   0000022C   070051E1           CMP      R1,R7
   \   00000230   F4FFFF2A           BCS      ??PatchGetPIT_14
    432            pl_prev->next=NULL; //Обрежем список
   \   00000234   005080E5           STR      R5,[R0, #+0]
    433            UnlockSched();
   \   00000238   470100EF           SWI      +327
    434            //Остальное можно сделать с разлоченной многозадачностью
    435            do
    436            {
    437              //Удаляем текущий
    438              if (pl->img)
   \                     ??PatchGetPIT_17:
   \   0000023C   080094E5           LDR      R0,[R4, #+8]
   \   00000240   000050E3           CMP      R0,#+0
   \   00000244   0300000A           BEQ      ??PatchGetPIT_18
    439              { 
    440                mfree(pl->img->bitmap);
   \   00000248   040090E5           LDR      R0,[R0, #+4]
   \   0000024C   150000EF           SWI      +21
    441                mfree(pl->img);
   \   00000250   080094E5           LDR      R0,[R4, #+8]
   \   00000254   150000EF           SWI      +21
    442              }
    443              mfree(pl->pngname);
   \                     ??PatchGetPIT_18:
   \   00000258   040094E5           LDR      R0,[R4, #+4]
   \   0000025C   150000EF           SWI      +21
    444              pl_prev=pl;
   \   00000260   0400A0E1           MOV      R0,R4
    445              pl=pl->next;
   \   00000264   004094E5           LDR      R4,[R4, #+0]
    446              mfree(pl_prev);
   \   00000268   150000EF           SWI      +21
    447            }
    448            while(pl); //Пока есть элементы, освобождаем их
   \   0000026C   000054E3           CMP      R4,#+0
   \   00000270   F1FFFF1A           BNE      ??PatchGetPIT_17
    449            return(cur->img);
   \                     ??PatchGetPIT_16:
   \   00000274   080096E5           LDR      R0,[R6, #+8]
   \                     ??PatchGetPIT_10:
   \   00000278   40DF8DE2           ADD      SP,SP,#+256      ;; stack cleaning
   \   0000027C   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??PatchGetPIT_0:
   \   00000280   ........           DC32     DEFAULT_FOLDER
   \   00000284   ........           DC32     DEFAULT_DISK_N2
   \   00000288   ........           DC32     CACHE_PNG
    450          }
    451          

   \                                 In segment CODE, align 4, keep-with-next
    452          __arm void InitPngBitMap(void)
    453          {
   \                     InitPngBitMap:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    454            if (!pngtop.bitmap)
   \   00000004   2C509FE5           LDR      R5,??InitPngBitMap_0  ;; pngtop
   \   00000008   8840A0E3           MOV      R4,#+136
   \   0000000C   040095E5           LDR      R0,[R5, #+4]
   \   00000010   4C4D84E3           ORR      R4,R4,#0x1300
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0200001A           BNE      ??InitPngBitMap_1
    455            {
    456              pngtop.bitmap=malloc(20000/8*2);
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   140000EF           SWI      +20
   \   00000024   040085E5           STR      R0,[R5, #+4]
    457            }
    458            zeromem((void*)(pngtop.bitmap),20000/8*2);
   \                     ??InitPngBitMap_1:
   \   00000028   040095E5           LDR      R0,[R5, #+4]
   \   0000002C   0410A0E1           MOV      R1,R4
   \   00000030   1D0100EF           SWI      +285
    459          }
   \   00000034   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??InitPngBitMap_0:
   \   00000038   ........           DC32     pngtop
    460          
    461          #pragma diag_suppress=Pe177

   \                                 In segment SWILIB_FUNC1E9, align 4, align-sorted, root
   \   00000000   ........           DC32 create_imghdr

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   ........           DC32     pngtop

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for DEFAULT_DISK_N2>`:
   \   00000000   04000000           DC32 4

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "1.2.5">`:
   \   00000000   312E322E3500       DC8 "1.2.5"
   \   00000006   0000               DC8 0, 0
    462          __root static const int SWILIB_FUNC1E9 @ "SWILIB_FUNC1E9" = (int)create_imghdr;
    463          #pragma diag_default=Pe177

   Maximum stack usage in bytes:

     Function          CSTACK
     --------          ------
     InitPngBitMap        12
     PatchGetPIT         292
     clear_cache          16
     create_imghdr        96
     find_png_in_cache    20
     print10               4
     read_data_fn         16
     strcpy_tolow          4
     xmalloc               4
     xmfree                4


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     DEFAULT_DISK_N2                   4
     DEFAULT_FOLDER                   20
     Pointer                           1
     xmalloc                           8
     xmfree                            8
     clear_cache                     108
     read_data_fn                     40
     create_imghdr                  1452
     pngtop                           12
     strcpy_tolow                     36
     print10                         152
     find_png_in_cache               116
     PatchGetPIT                     652
     InitPngBitMap                    60
     SWILIB_FUNC1E9                    4
     ??DataTable1                      4
     ?<Initializer for DEFAULT_DISK_N2>
                                       4
     ?<Constant "1.2.5">               8
      Others                          64

 
 2 688 bytes in segment CODE
    29 bytes in segment DATA_C
     4 bytes in segment DATA_I
     4 bytes in segment DATA_ID
    12 bytes in segment DATA_N
    12 bytes in segment INITTAB
     4 bytes in segment SWILIB_FUNC1E9
 
 2 636 bytes of CODE  memory (+ 64 bytes shared)
    37 bytes of CONST memory
    16 bytes of DATA  memory

Errors: none
Warnings: none
