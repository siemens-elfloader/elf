//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION   21/Apr/2011  22:57:51 /
// Copyright 1999-2005 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Cpu mode        =  interwork                                           /
//    Endian          =  little                                              /
//    Stack alignment =  4                                                   /
//    Source file     =  C:\arm\vNes_snd\SWILIB.C                            /
//    Command line    =  C:\arm\vNes_snd\SWILIB.C -D NDEBUG -lCN             /
//                       C:\arm\vNes_snd\Release\List\ -lA                   /
//                       C:\arm\vNes_snd\Release\List\ -o                    /
//                       C:\arm\vNes_snd\Release\Obj\ -s9 --cpu_mode arm     /
//                       --endian little --cpu ARM926EJ-S --stack_align 4    /
//                       --interwork -e --fpu None --dlib_config             /
//                       "C:\arm2\Embedded Workbench 4.0                     /
//                       Evaluation\ARM\LIB\dl5tpainl8f.h" -I                /
//                       "C:\arm2\Embedded Workbench 4.0                     /
//                       Evaluation\ARM\INC\" --inline_threshold=2           /
//    List file       =  C:\arm\vNes_snd\Release\List\SWILIB.s79             /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME SWILIB

        RTMODEL "StackAlign4", "USED"
        RTMODEL "__cpu_mode", "__pcs__interwork"
        RTMODEL "__data_model", "absolute"
        RTMODEL "__endian", "little"
        RTMODEL "__rt_version", "6"

        RSEG CSTACK:DATA:NOROOT(2)

        MULTWEAK ??alltrim??rT
        MULTWEAK ??emptystr??rT
        MULTWEAK ??fgets??rT
        MULTWEAK ??fread32??rT
        MULTWEAK ??fwrite32??rT
        MULTWEAK ??get3int??rT
        MULTWEAK ??getint??rT
        MULTWEAK ??getshort??rT
        MULTWEAK ??isalth??rT
        MULTWEAK ??isval??rT
        MULTWEAK ??loadfile??rT
        MULTWEAK ??max??rT
        MULTWEAK ??min??rT
        MULTWEAK ??printf??rT
        MULTWEAK ??putint??rT
        MULTWEAK ??putshort??rT
        MULTWEAK ??savefile??rT
        MULTWEAK ??strchrpos??rT
        MULTWEAK ??strcmpsize??rT
        MULTWEAK ??strdup??rT
        MULTWEAK ??todown??rT
        MULTWEAK ??toup??rT
        PUBWEAK ?init?tab?DATA_Z
        PUBLIC alltrim
        FUNCTION alltrim,0203H
        PUBLIC emptystr
        FUNCTION emptystr,0203H
        PUBLIC err
        PUBLIC fgets
        FUNCTION fgets,0203H
        PUBLIC fread32
        FUNCTION fread32,0203H
        LOCFRAME CSTACK, 28, STACK
        PUBLIC fwrite32
        FUNCTION fwrite32,0203H
        LOCFRAME CSTACK, 28, STACK
        PUBLIC get3int
        FUNCTION get3int,0203H
        PUBLIC getint
        FUNCTION getint,0203H
        PUBLIC getshort
        FUNCTION getshort,0203H
        PUBLIC isalth
        FUNCTION isalth,0203H
        PUBLIC isval
        FUNCTION isval,0203H
        PUBLIC loadfile
        FUNCTION loadfile,0203H
        LOCFRAME CSTACK, 28, STACK
        PUBLIC loadfilesize
        PUBLIC max
        FUNCTION max,0203H
        PUBLIC min
        FUNCTION min,0203H
        PUBLIC printf
        FUNCTION printf,0203H
        PUBLIC putint
        FUNCTION putint,0203H
        PUBLIC putshort
        FUNCTION putshort,0203H
        PUBLIC savefile
        FUNCTION savefile,0203H
        LOCFRAME CSTACK, 20, STACK
        PUBLIC strchrpos
        FUNCTION strchrpos,0203H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC strcmpsize
        FUNCTION strcmpsize,0203H
        LOCFRAME CSTACK, 4, STACK
        PUBLIC strdup
        FUNCTION strdup,0203H
        PUBLIC todown
        FUNCTION todown,0203H
        PUBLIC toup
        FUNCTION toup,0203H
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 HUGEDATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, CPSR:32, R13:32
        CFI Resource R14:32, SPSR:32
        CFI VirtualResource ?RET:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon0
        
        
        CFI Common cfiCommon1 Using cfiNames0
        CFI CodeAlign 4
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon1
        
alltrim             SYMBOL "alltrim"
??alltrim??rT       SYMBOL "??rT", alltrim
emptystr            SYMBOL "emptystr"
??emptystr??rT      SYMBOL "??rT", emptystr
fgets               SYMBOL "fgets"
??fgets??rT         SYMBOL "??rT", fgets
fread32             SYMBOL "fread32"
??fread32??rT       SYMBOL "??rT", fread32
fwrite32            SYMBOL "fwrite32"
??fwrite32??rT      SYMBOL "??rT", fwrite32
get3int             SYMBOL "get3int"
??get3int??rT       SYMBOL "??rT", get3int
getint              SYMBOL "getint"
??getint??rT        SYMBOL "??rT", getint
getshort            SYMBOL "getshort"
??getshort??rT      SYMBOL "??rT", getshort
isalth              SYMBOL "isalth"
??isalth??rT        SYMBOL "??rT", isalth
isval               SYMBOL "isval"
??isval??rT         SYMBOL "??rT", isval
loadfile            SYMBOL "loadfile"
??loadfile??rT      SYMBOL "??rT", loadfile
max                 SYMBOL "max"
??max??rT           SYMBOL "??rT", max
min                 SYMBOL "min"
??min??rT           SYMBOL "??rT", min
printf              SYMBOL "printf"
??printf??rT        SYMBOL "??rT", printf
putint              SYMBOL "putint"
??putint??rT        SYMBOL "??rT", putint
putshort            SYMBOL "putshort"
??putshort??rT      SYMBOL "??rT", putshort
savefile            SYMBOL "savefile"
??savefile??rT      SYMBOL "??rT", savefile
strchrpos           SYMBOL "strchrpos"
??strchrpos??rT     SYMBOL "??rT", strchrpos
strcmpsize          SYMBOL "strcmpsize"
??strcmpsize??rT    SYMBOL "??rT", strcmpsize
strdup              SYMBOL "strdup"
??strdup??rT        SYMBOL "??rT", strdup
todown              SYMBOL "todown"
??todown??rT        SYMBOL "??rT", todown
toup                SYMBOL "toup"
??toup??rT          SYMBOL "??rT", toup

// C:\arm\vNes_snd\SWILIB.C
//    1 
//    2 // swilib.c
//    3 #include "c:\arm\inc\Swilib.h"
//    4 //#define HIGHCOLOR // 16-битный режим
//    5 //#define GRAPH  // Графика
//    6 //#define UNPACK // Распаковка архивов
//    7 #define NO7Z   // Кроме 7z
//    8 //#define NOZIP  // Кроме zip
//    9 #define NORAR  // Кроме rar
//   10 //#define NOLOAD // in loadgraph data loaded allready
//   11 
//   12 //#ifdef ELKA
//   13 //  #define width 240
//   14 //  #define height 304
//   15 //#else
//   16 //  #define width 132
//   17 //  #define height 176
//   18 //#endif
//   19 extern int width, height;
//   20 

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   21 unsigned int err=0;
err:
        DS8 4

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   22 int loadfilesize=0;
loadfilesize:
        DS8 4

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI NoFunction
        THUMB
??fread32??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock0
        REQUIRE fread32
//   23 
//   24 //#define ELKA // Для EL-71
//   25 //#ifndef NEWSGOLD
//   26 //#define NEWSGOLD // Для S75
//   27 //#endif
//   28 //#ifndef NEWSGOLD
//   29 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock1 Using cfiCommon1
        CFI Function fread32
        ARM
//   30 int fread32(int fh, void *buf, int len, unsigned int *err){
fread32:
        PUSH     {R4-R9,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R9 Frame(CFA, -8)
        CFI R8 Frame(CFA, -12)
        CFI R7 Frame(CFA, -16)
        CFI R6 Frame(CFA, -20)
        CFI R5 Frame(CFA, -24)
        CFI R4 Frame(CFA, -28)
        CFI CFA R13+28
        MOV      R4,R0
        MOV      R5,R1
        MOV      R6,R2
        MOV      R7,R3
//   31   int clen, rlen, total=0;
        MOV      R8,#+0
        B        ??fread32_0
//   32   while(len){
//   33   if (len>16384) clen=16384; else clen=len;
//   34   total+=(rlen=fread(fh, buf, clen, err));
//   35   if (rlen!=clen) break;
//   36   buf=(char*)buf+rlen;
??fread32_1:
        ADD      R5,R0,R5
//   37   len-=clen;
        SUB      R6,R6,R9
??fread32_0:
        CMP      R6,#+0
        BEQ      ??fread32_2
        MOV      R0,#+1
        ORR      R0,R0,#0x4000
        CMP      R6,R0
        MOVGE    R9,#+16384
        MOVLT    R9,R6
        MOV      R3,R7
        MOV      R2,R9
        MOV      R1,R5
        MOV      R0,R4
        SWI      +11
        ADD      R8,R0,R8
        CMP      R0,R9
        BEQ      ??fread32_1
//   38   }return(total);
??fread32_2:
        MOV      R0,R8
        POP      {R4-R9,PC}       ;; return
        CFI EndBlock cfiBlock1
//   39 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock2 Using cfiCommon0
        CFI NoFunction
        THUMB
??fwrite32??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock2
        REQUIRE fwrite32
//   40 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock3 Using cfiCommon1
        CFI Function fwrite32
        ARM
//   41 int fwrite32(int fh, void *buf, int len, unsigned int *err){
fwrite32:
        PUSH     {R4-R9,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R9 Frame(CFA, -8)
        CFI R8 Frame(CFA, -12)
        CFI R7 Frame(CFA, -16)
        CFI R6 Frame(CFA, -20)
        CFI R5 Frame(CFA, -24)
        CFI R4 Frame(CFA, -28)
        CFI CFA R13+28
        MOV      R4,R0
        MOV      R5,R1
        MOV      R6,R2
        MOV      R7,R3
//   42   int clen, rlen, total=0;
        MOV      R8,#+0
        B        ??fwrite32_0
//   43   while(len){
//   44   if (len>16384) clen=16384; else clen=len;
//   45   total+=(rlen=fwrite(fh, buf, clen, err));
//   46   if (rlen!=clen) break;
//   47   buf=(char*)buf+rlen;
??fwrite32_1:
        ADD      R5,R0,R5
//   48   len-=clen;
        SUB      R6,R6,R9
??fwrite32_0:
        CMP      R6,#+0
        BEQ      ??fwrite32_2
        MOV      R0,#+1
        ORR      R0,R0,#0x4000
        CMP      R6,R0
        MOVGE    R9,#+16384
        MOVLT    R9,R6
        MOV      R3,R7
        MOV      R2,R9
        MOV      R1,R5
        MOV      R0,R4
        SWI      +12
        ADD      R8,R0,R8
        CMP      R0,R9
        BEQ      ??fwrite32_1
//   49   }return(total);
??fwrite32_2:
        MOV      R0,R8
        POP      {R4-R9,PC}       ;; return
        CFI EndBlock cfiBlock3
//   50 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock4 Using cfiCommon0
        CFI NoFunction
        THUMB
??min??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock4
        REQUIRE min
//   51 //#endif
//   52 
//   53 //void *memset(void *mem, int val, int size){
//   54 //  char *s=(char*)mem;
//   55 //  while(--size>=0) *s++=(char)val;
//   56 //  return mem;
//   57 //}
//   58 
//   59 //void *memsetw(void *mem, int val, int size){
//   60 //  short *s=(short*)mem;
//   61 //  while(--size>=0) *s++=val;
//   62 //  return mem;
//   63 //}
//   64 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock5 Using cfiCommon1
        CFI Function min
        ARM
//   65 int min(int a, int b){ return (a<b)?a:b;}
min:
        CMP      R0,R1
        MOVGE    R0,R1
        BX       LR               ;; return
        CFI EndBlock cfiBlock5

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock6 Using cfiCommon0
        CFI NoFunction
        THUMB
??max??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock6
        REQUIRE max

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock7 Using cfiCommon1
        CFI Function max
        ARM
//   66 int max(int a, int b){ return (a>b)?a:b;}
max:
        CMP      R1,R0
        MOVGE    R0,R1
        BX       LR               ;; return
        CFI EndBlock cfiBlock7

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock8 Using cfiCommon0
        CFI NoFunction
        THUMB
??fgets??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock8
        REQUIRE fgets
//   67 //int abs(int a){ return (a<0)?-a:a;}
//   68 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock9 Using cfiCommon1
        CFI Function fgets
        ARM
//   69 int fgets(char *buf,int size,int fh){ return 0;} //fake!!!
fgets:
        MOV      R0,#+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock9

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock10 Using cfiCommon0
        CFI NoFunction
        THUMB
??printf??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock10
        REQUIRE printf

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock11 Using cfiCommon1
        CFI Function printf
        ARM
//   70 void printf(char *s,...){}  //fake!!!
printf:
        PUSH     {R1-R3}
        CFI CFA R13+12
        ADD      SP,SP,#+12
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock11

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock12 Using cfiCommon0
        CFI NoFunction
        THUMB
??strdup??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock12
        REQUIRE strdup

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock13 Using cfiCommon1
        CFI Function strdup
        ARM
//   71 char *strdup(char *s){ return s;}
strdup:
        BX       LR               ;; return
        CFI EndBlock cfiBlock13

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock14 Using cfiCommon0
        CFI NoFunction
        THUMB
??savefile??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock14
        REQUIRE savefile
//   72 
//   73 //void *memcpyrev(void *to, void *from, int size){
//   74 //  char *s=(char*)to+size, *ss=(char*)from+size;
//   75 //  while(--size>=0)
//   76 //    *--s=*--ss;
//   77 //  return to;
//   78 //}
//   79 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock15 Using cfiCommon1
        CFI Function savefile
        ARM
//   80 int savefile(char *fname, char *buf, int size){
savefile:
        PUSH     {R4-R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
//   81   int f,i;
//   82   if((f=fopen(fname,A_WriteOnly+A_BIN+A_Create+A_Truncate,P_WRITE,&err))==-1) return 0;
        LDR      R6,??savefile_0  ;; err
        MOV      R4,R1
        MOV      R5,R2
        MOV      R3,R6
        MOV      R2,#+256
        MOV      R1,#+1
        ORR      R1,R1,#0x8300
        SWI      +10
        MOV      R7,R0
        CMN      R7,#+1
        MOVEQ    R0,#+0
        POPEQ    {R4-R7,PC}
//   83   i=fwrite32(f,buf,size,&err); 
        MOV      R3,R6
        MOV      R2,R5
        MOV      R1,R4
        BL       fwrite32
        MOV      R4,R0
//   84   fclose(f,&err); 
        MOV      R1,R6
        MOV      R0,R7
        SWI      +13
//   85   return i;
        MOV      R0,R4
        POP      {R4-R7,PC}       ;; return
        DATA
??savefile_0:
        DC32     err
        CFI EndBlock cfiBlock15
//   86 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock16 Using cfiCommon0
        CFI NoFunction
        THUMB
??loadfile??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock16
        REQUIRE loadfile
//   87 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock17 Using cfiCommon1
        CFI Function loadfile
        ARM
//   88 char *loadfile(char *filename){ // Загрузить файл, распак-ть
loadfile:
        PUSH     {R5-R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI CFA R13+16
        SUB      SP,SP,#+4
        CFI CFA R13+20
//   89   int f; unsigned int err;  char *buf=0;
        MOV      R5,#+0
//   90   if((f=fopen(filename,A_ReadOnly+A_BIN,P_READ,&err))!=-1){
        MOV      R3,SP
        MOV      R2,#+128
        MOV      R1,#+32768
        SWI      +10
        MOV      R6,R0
        CMN      R6,#+1
        BEQ      ??loadfile_0
//   91     if(loadfilesize=lseek(f,0,2,&err,&err)){
        LDR      R7,??loadfile_1  ;; loadfilesize
        MOV      R0,SP
        PUSH     {R0}
        CFI CFA R13+24
        ADD      R3,SP,#+4
        MOV      R2,#+2
        MOV      R1,#+0
        MOV      R0,R6
        SWI      +15
        STR      R0,[R7, #+0]
        CMP      R0,#+0
        ADD      SP,SP,#+4
        CFI CFA R13+20
        BEQ      ??loadfile_2
//   92       buf=(char*)malloc(loadfilesize);
        SWI      +20
        MOV      R5,R0
//   93       lseek(f,0,0,&err,&err);
        MOV      R0,SP
        PUSH     {R0}
        CFI CFA R13+24
        ADD      R3,SP,#+4
        MOV      R2,#+0
        MOV      R1,#+0
        MOV      R0,R6
        SWI      +15
//   94       if(fread32(f,buf,loadfilesize,&err)!=loadfilesize){ mfree(buf); buf=0;}
        LDR      R2,[R7, #+0]
        ADD      R3,SP,#+4
        MOV      R1,R5
        MOV      R0,R6
        BL       fread32
        LDR      R1,[R7, #+0]
        ADD      SP,SP,#+4
        CFI CFA R13+20
        CMP      R0,R1
        BEQ      ??loadfile_2
        MOV      R0,R5
        SWI      +21
        MOV      R5,#+0
//   95     } fclose(f,&err);
??loadfile_2:
        MOV      R1,SP
        MOV      R0,R6
        SWI      +13
//   96 #ifdef UNPACK
//   97     extern char *un7z(char *buf);
//   98     extern char *unrar(char *buf);
//   99     extern char *unzip(char *buf);
//  100     if(buf && loadfilesize>4){
//  101 #ifndef NORAR
//  102       if(*(int *)buf=='!raR') buf=unrar(buf); //unrar
//  103       else
//  104 #endif      
//  105 #ifndef NOZIP
//  106       if(*(int*)buf==0x4034b50) buf=unzip(buf); //unzip
//  107       else
//  108 #endif
//  109 #ifndef NO7Z      
//  110       if(*(short*)buf=='z7') buf=un7z(buf); //un7z
//  111 #endif
//  112      ;      
//  113     }
//  114 //#ifdef SAVETEST
//  115 //  int out=fopen("0:\\ZBin\\123",A_WriteOnly+A_BIN+A_Create,P_WRITE,&err);
//  116 //  fwrite32(out,buf,loadfilesize,&err);
//  117 //  fclose(out,&err);
//  118 //#endif    
//  119     
//  120 #endif      
//  121   } return buf;
??loadfile_0:
        MOV      R0,R5
        POP      {R1,R5-R7,PC}
        DATA
??loadfile_1:
        DC32     loadfilesize
        CFI EndBlock cfiBlock17
//  122 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock18 Using cfiCommon0
        CFI NoFunction
        THUMB
??toup??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock18
        REQUIRE toup
//  123 
//  124 //void *memset(void *buf, int val, int size){
//  125 //  char *b=(char*)buf;
//  126 //  while(--size>=0) *b++=val; 
//  127 //  return buf;
//  128 //}
//  129 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock19 Using cfiCommon1
        CFI Function toup
        ARM
//  130 char *toup(char *str){			// К верхнему регистру
//  131   char *val=str;
toup:
        MOV      R1,R0
        LDRB     R2,[R1, #+0]
        CMP      R2,#+0
        BXEQ     LR
//  132   while(*val!=NULL){
//  133          if(*val>='a' && *val<='z')  *val-=' ';  
??toup_0:
        LDRB     R2,[R1, #+0]
        MOV      R3,R2
        CMP      R2,#+97
        BCC      ??toup_1
        CMP      R3,#+123
        BCS      ??toup_1
??toup_2:
        ADD      R3,R3,#+224
        B        ??toup_3
//  134     else if(*val>='а' && *val<='п')  *val-=' ';  
??toup_1:
        CMP      R3,#+224
        BCC      ??toup_4
        CMP      R3,#+240
        BCC      ??toup_2
//  135     else if(*val>='р' && *val<='я')  *val-= 80;  
??toup_4:
        CMP      R3,#+240
        ADDCS    R3,R3,#+176
??toup_3:
        STRB     R3,[R1], #+1
//  136     ++val;
//  137   }
        LDRB     R2,[R1, #+0]
        CMP      R2,#+0
        BNE      ??toup_0
//  138   return str;
        BX       LR               ;; return
        CFI EndBlock cfiBlock19
//  139 }  

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock20 Using cfiCommon0
        CFI NoFunction
        THUMB
??todown??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock20
        REQUIRE todown
//  140 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock21 Using cfiCommon1
        CFI Function todown
        ARM
//  141 char *todown(char *str){		// К нижнему регистру
//  142   char *val=str;
todown:
        MOV      R1,R0
        LDRB     R2,[R1, #+0]
        CMP      R2,#+0
        BXEQ     LR
//  143   while(*val!=NULL){
//  144          if(*val>='A' && *val<='Z')  *val+=' '; 
??todown_0:
        LDRB     R2,[R1, #+0]
        MOV      R3,R2
        CMP      R2,#+65
        BCC      ??todown_1
        CMP      R3,#+91
        BCS      ??todown_1
??todown_2:
        ADD      R3,R3,#+32
        B        ??todown_3
//  145     else if(*val>='А' && *val<='П')  *val+=' ';
??todown_1:
        CMP      R3,#+192
        BCC      ??todown_4
        CMP      R3,#+208
        BCC      ??todown_2
//  146     else if(*val>='Р' && *val<='Я')  *val+= 80; 
??todown_4:
        CMP      R3,#+208
        BCC      ??todown_3
        CMP      R3,#+224
        ADDCC    R3,R3,#+80
??todown_3:
        STRB     R3,[R1], #+1
//  147     ++val;
//  148   }
        LDRB     R2,[R1, #+0]
        CMP      R2,#+0
        BNE      ??todown_0
//  149   return str;
        BX       LR               ;; return
        CFI EndBlock cfiBlock21
//  150 }  

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock22 Using cfiCommon0
        CFI NoFunction
        THUMB
??isalth??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock22
        REQUIRE isalth
//  151 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock23 Using cfiCommon1
        CFI Function isalth
        ARM
//  152 int  isalth (unsigned char sym){	// Алфавитный символ ?
//  153   return ((sym>='A' && sym<='Z') || (sym>=(unsigned char)'А' && sym<=(unsigned char)'П')
//  154     || (sym>=(unsigned char)'Р' && sym<=(unsigned char)'Я'));}
isalth:
        CMP      R0,#+65
        BCC      ??isalth_0
        CMP      R0,#+91
        BCC      ??isalth_1
??isalth_0:
        CMP      R0,#+192
        BCC      ??isalth_2
        CMP      R0,#+208
        BCC      ??isalth_1
??isalth_2:
        CMP      R0,#+208
        BCC      ??isalth_3
        CMP      R0,#+224
        BCS      ??isalth_3
??isalth_1:
        MOV      R0,#+1
        BX       LR
??isalth_3:
        MOV      R0,#+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock23

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock24 Using cfiCommon0
        CFI NoFunction
        THUMB
??isval??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock24
        REQUIRE isval
//  155 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock25 Using cfiCommon1
        CFI Function isval
        ARM
//  156 int  isval (char sym){		// Символ является числом ?
//  157   return (sym>='0' && sym<='9');}
isval:
        CMP      R0,#+48
        BCC      ??isval_0
        CMP      R0,#+58
        MOVCC    R0,#+1
        BXCC     LR
??isval_0:
        MOV      R0,#+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock25

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock26 Using cfiCommon0
        CFI NoFunction
        THUMB
??strchrpos??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock26
        REQUIRE strchrpos
//  158 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock27 Using cfiCommon1
        CFI Function strchrpos
        ARM
//  159 int strchrpos(const char *s, int c){	// Позиция символа в строке (1-N, 0=нет)
strchrpos:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
        MOV      R4,R0
//  160   char *sptr=strchr(s,c);
        SWI      +24
//  161   return (sptr)?sptr-s+1:NULL;
        CMP      R0,#+0
        SUBNE    R0,R0,R4
        ADDNE    R0,R0,#+1
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock27
//  162 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock28 Using cfiCommon0
        CFI NoFunction
        THUMB
??emptystr??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock28
        REQUIRE emptystr
//  163   

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock29 Using cfiCommon1
        CFI Function emptystr
        ARM
//  164 int emptystr(char *str){		// Пустая ли строка
emptystr:
        B        ??emptystr_0
//  165   while(*str && (*str==' ' || *str==9)) ++str;
??emptystr_1:
        ADD      R0,R0,#+1
??emptystr_0:
        LDRB     R1,[R0, #+0]
        CMP      R1,#+0
        BEQ      ??emptystr_2
        CMP      R1,#+32
        CMPNE    R1,#+9
        BEQ      ??emptystr_1
//  166   return ((*str)?0:1);
??emptystr_2:
        CMP      R1,#+0
        MOVNE    R0,#+0
        BXNE     LR
        MOV      R0,#+1
        BX       LR               ;; return
        CFI EndBlock cfiBlock29
//  167 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock30 Using cfiCommon0
        CFI NoFunction
        THUMB
??alltrim??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock30
        REQUIRE alltrim
//  168 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock31 Using cfiCommon1
        CFI Function alltrim
        ARM
//  169 char  *alltrim (char *str){		// Удалить пробелы по бокам строки
//  170   char *s;
//  171   if(!*str) return str;
alltrim:
        LDRB     R1,[R0, #+0]
        CMP      R1,#+0
        BNE      ??alltrim_0
        BX       LR
//  172   while(*str==' ' || *str==9) ++str;
??alltrim_1:
        ADD      R0,R0,#+1
??alltrim_0:
        LDRB     R1,[R0, #+0]
        CMP      R1,#+32
        CMPNE    R1,#+9
        BEQ      ??alltrim_1
//  173   s=str;
        MOV      R1,R0
        LDRB     R2,[R1, #+0]
        CMP      R2,#+0
        BEQ      ??alltrim_2
//  174   while(*s) ++s;
??alltrim_3:
        LDRB     R2,[R1, #+1]!
        CMP      R2,#+0
        BNE      ??alltrim_3
//  175   while(s>str && (*(s-1)==' ' || *(s-1)==9)) --s;
??alltrim_2:
        CMP      R0,R1
        BCS      ??alltrim_4
        LDRB     R2,[R1, #-1]
        CMP      R2,#+32
        CMPNE    R2,#+9
        SUBEQ    R1,R1,#+1
        BEQ      ??alltrim_2
//  176   *s=NULL;
??alltrim_4:
        MOV      R2,#+0
        STRB     R2,[R1, #+0]
//  177   return str;
        BX       LR               ;; return
        CFI EndBlock cfiBlock31
//  178 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock32 Using cfiCommon0
        CFI NoFunction
        THUMB
??strcmpsize??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock32
        REQUIRE strcmpsize
//  179 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock33 Using cfiCommon1
        CFI Function strcmpsize
        ARM
//  180 int   strcmpsize (const char *s1,const char *s2,int size){ // Сравнить строки длины size
strcmpsize:
        PUSH     {R4}
        CFI R4 Frame(CFA, -4)
        CFI CFA R13+4
//  181   int i;
//  182   for(i=0;i<size && s1[i]==s2[i];i++);
        MOV      R3,#+0
        B        ??strcmpsize_0
??strcmpsize_1:
        LDRB     R12,[R3, +R0]
        LDRB     R4,[R3, +R1]
        CMP      R12,R4
        BNE      ??strcmpsize_2
        ADD      R3,R3,#+1
??strcmpsize_0:
        CMP      R3,R2
        BLT      ??strcmpsize_1
//  183     return (i==size)?NULL:s1[i]-s2[i];
        MOVEQ    R0,#+0
        BEQ      ??strcmpsize_3
??strcmpsize_2:
        LDRB     R0,[R3, +R0]
        LDRB     R1,[R3, +R1]
        SUB      R0,R0,R1
??strcmpsize_3:
        POP      {R4}
        CFI R4 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock33
//  184 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock34 Using cfiCommon0
        CFI NoFunction
        THUMB
??getint??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock34
        REQUIRE getint
//  185 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock35 Using cfiCommon1
        CFI Function getint
        ARM
//  186 int getint(void *ptr){ // Получить int
//  187   if((int)ptr & 3) return *(unsigned char*)ptr | *((unsigned char*)ptr+1)<<8\ 
getint:
        TST      R0,#0x3
        BEQ      ??getint_0
//  188     | *((unsigned char*)ptr+2)<<16 | *((unsigned char*)ptr+3)<<24;
        LDRB     R1,[R0, #+0]
        LDRB     R2,[R0, #+1]
        ORR      R1,R1,R2, LSL #+8
        LDRB     R2,[R0, #+2]
        LDRB     R0,[R0, #+3]
        ORR      R1,R1,R2, LSL #+16
        ORR      R0,R1,R0, LSL #+24
        BX       LR
//  189   else return *(int*)ptr;
??getint_0:
        LDR      R0,[R0, #+0]
        BX       LR               ;; return
        CFI EndBlock cfiBlock35
//  190 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock36 Using cfiCommon0
        CFI NoFunction
        THUMB
??get3int??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock36
        REQUIRE get3int
//  191 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock37 Using cfiCommon1
        CFI Function get3int
        ARM
//  192 int get3int(void *ptr){ // Получить 3int
//  193   return *(unsigned char*)ptr | *((unsigned char*)ptr+1)<<8 | *((unsigned char*)ptr+2)<<16; 
get3int:
        LDRB     R1,[R0, #+0]
        LDRB     R2,[R0, #+1]
        LDRB     R0,[R0, #+2]
        ORR      R1,R1,R2, LSL #+8
        ORR      R0,R1,R0, LSL #+16
        BX       LR               ;; return
        CFI EndBlock cfiBlock37
//  194 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock38 Using cfiCommon0
        CFI NoFunction
        THUMB
??getshort??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock38
        REQUIRE getshort
//  195 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock39 Using cfiCommon1
        CFI Function getshort
        ARM
//  196 short getshort(void *ptr){ // Получить short
//  197   if((int)ptr & 1) return *(unsigned char*)ptr | *((unsigned char*)ptr+1)<<8;
getshort:
        TST      R0,#0x1
        BEQ      ??getshort_0
        LDRB     R1,[R0, #+0]
        LDRB     R0,[R0, #+1]
        ORR      R0,R1,R0, LSL #+8
        MOV      R0,R0, LSL #+16
        MOV      R0,R0, ASR #+16
        BX       LR
//  198   else return *(short*)ptr;
??getshort_0:
        LDRSH    R0,[R0, #+0]
        BX       LR               ;; return
        CFI EndBlock cfiBlock39
//  199 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock40 Using cfiCommon0
        CFI NoFunction
        THUMB
??putint??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock40
        REQUIRE putint
//  200 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock41 Using cfiCommon1
        CFI Function putint
        ARM
//  201 void putint(void *ptr, int data){ // Записать int
//  202   if((int)ptr & 3){ *(char*)ptr=data; *((char*)ptr+1)=data>>8;
putint:
        TST      R0,#0x3
        BEQ      ??putint_0
        STRB     R1,[R0, #+0]
        ASR      R2,R1,#+8
        STRB     R2,[R0, #+1]
//  203     *((char*)ptr+2)=data>>16; *((char*)ptr+3)=data>>24;
        ASR      R2,R1,#+16
        STRB     R2,[R0, #+2]
        ASR      R1,R1,#+24
        STRB     R1,[R0, #+3]
        BX       LR
//  204   }else *(int*)ptr=data;
??putint_0:
        STR      R1,[R0, #+0]
//  205   
//  206 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock41

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock42 Using cfiCommon0
        CFI NoFunction
        THUMB
??putshort??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock42
        REQUIRE putshort
//  207  

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock43 Using cfiCommon1
        CFI Function putshort
        ARM
//  208 void putshort(void *ptr, short data){ // Записать short
//  209   if((int)ptr & 1){ *(char*)ptr=data; *((char*)ptr+1)=data>>8;
putshort:
        TST      R0,#0x1
        BEQ      ??putshort_0
        STRB     R1,[R0, #+0]
        ASR      R1,R1,#+8
        STRB     R1,[R0, #+1]
        BX       LR
//  210   }else *(short*)ptr=data;
??putshort_0:
        STRH     R1,[R0, #+0]
//  211 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock43

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_Z:
        DCD      sfe(DATA_Z) - sfb(DATA_Z), sfb(DATA_Z), sfb(DATA_Z)

        END
//  212 
//  213 #ifdef GRAPH
//  214 /*-----------------------------
//  215 смещ.	размер	имя
//  216 00	2	'BM'
//  217 02	4	Размер файла в байтах;
//  218 06	2	0
//  219 08	2	0
//  220 10	4	Смещение начала изображения в файле;
//  221 14	4	Размер этого заголовка, 40;
//  222 18	4	Ширина изображения в пикселях;
//  223 22	4	Высота изображения в пикселях;
//  224 26	2	Число плоскостей изображения, 1;
//  225 28	2	Бит на пиксел: 1,4,8 или 24;
//  226 30	4	Тип сжатия;
//  227 34	4	Размер сжатого изображения в байтах или 0;
//  228 38	4	Горизонтальное разрешение, в пикселях / на метр;
//  229 42	4	Вертикальное разрешение, в пикселях / на метр;
//  230 46	4	Количество используемых цветов;
//  231 50	4	Число "важных" цветов;
//  232 54	4*N	Карты цветов BGRР;
//  233 
//  234 BMP	заголовок 54 б + палитра 4*256;*/
//  235 
//  236 inline unsigned char rgb888tobyte(int color){
//  237   return ((color>>6)&3)|((color>>11)&0x1C)|((color>>16)&0xE0); }
//  238 
//  239 inline short rgb888toshort(int color){
//  240   return ((color>>3)&0x1f)|((color>>5)&0x7e0)|((color>>8)&0xf800); }
//  241 
//  242 inline unsigned char rgb565tobyte(short color){
//  243   return ((color>>3)&3)|((color>>6)&0x1C)|((color>>8)&0xE0); }
//  244 
//  245 inline short rgb565toshort(short color){
//  246   return color; }
//  247 
//  248 
//  249 int loadgraphsize=0;
//  250 #ifndef HIGHCOLOR
//  251   const int graphpoints=1;
//  252 #else  
//  253   const int graphpoints=2;
//  254 #endif
//  255 // Формат файла 2б х 2б у  далее точки (повернуты как надо, без выравнивания)
//  256 char *loadgraph(char *filename){ // Загрузить графику (распаковываем и перекодируем) #define HIGHCOLOR учесть
//  257   unsigned char *bmp=0, *buf=0, *pbuf, *pbmp, *ptr;
//  258   int *pal;
//  259   int sizex, sizey, bytepixel, pitch;
//  260   int i,j;
//  261   do{
//  262     if(!(bmp=(unsigned char*)
//  263 #ifndef NOLOAD
//  264     loadfile(filename)
//  265 #else
//  266     filename
//  267 #endif
//  268     )) break;
//  269     if(getshort(bmp)!='MB') break;
//  270     sizex=getint(bmp+18);
//  271     sizey=getint(bmp+22);
//  272     bytepixel=getshort(bmp+28)>>3;
//  273     if(!sizex || !sizey || bytepixel<1 || bytepixel>4) break;
//  274     pitch=sizex*bytepixel;
//  275     if(pitch&3) pitch+=4-(pitch&3);
//  276     if(!(buf=(unsigned char*)malloc(loadgraphsize=sizex*sizey*graphpoints+4))) break;
//  277     *(short*)buf=sizex; *(short*)(buf+2)=sizey; 
//  278     pbuf=buf+4;
//  279     ptr=bmp+getint(bmp+10)+sizey*pitch;
//  280 #ifndef HIGHCOLOR //1 byte
//  281     switch(bytepixel){
//  282     case 1: //8 -> 8
//  283       memcpy(pal=(int*)(bmp+52),bmp+54,*(short*)(bmp+50)?(*(short*)(bmp+50)<<2):1024);
//  284     for(j=0;j<sizey;j++){
//  285       pbmp=(ptr-=pitch);
//  286       for(i=0;i<sizex;i++){
//  287         *pbuf++=rgb888tobyte(pal[*pbmp++]);
//  288     }  } break;
//  289     case 2: //16 bit
//  290     for(j=0;j<sizey;j++){
//  291       pbmp=(ptr-=pitch);
//  292       for(i=0;i<sizex;i++){
//  293         *pbuf++=rgb565tobyte(*(short*)pbmp);
//  294         pbmp+=2;
//  295     }  } break;
//  296     case 3: //24 bit
//  297     for(j=0;j<sizey;j++){
//  298       pbmp=(ptr-=pitch);
//  299       for(i=0;i<sizex;i++){
//  300         *pbuf++=rgb888tobyte(get3int(pbmp));
//  301         pbmp+=3;
//  302     }  } break;
//  303     case 4: //32 bit
//  304     if((i=getint(bmp+10))&3){ //Выровнять данные на границу 4
//  305       j=i-(i&3);
//  306       memcpy(bmp+j, bmp+i, sizey*pitch);
//  307       ptr=bmp+j+sizey*pitch;
//  308     }
//  309     for(j=0;j<sizey;j++){
//  310       pbmp=(ptr-=pitch);
//  311       for(i=0;i<sizex;i++){
//  312         *pbuf++=rgb888tobyte(*(int*)pbmp);
//  313         pbmp+=4;
//  314     }  } break;
//  315  #else    // 2 byte
//  316     switch(bytepixel){
//  317     case 1: //8 -> 16
//  318     memcpy(pal=(int*)(bmp+52),bmp+54,*(short*)(bmp+50)?(*(short*)(bmp+50)<<2):1024);
//  319     for(j=0;j<sizey;j++){
//  320       pbmp=(ptr-=pitch);
//  321       for(i=0;i<sizex;i++){
//  322         *(short*)pbuf=rgb888toshort(pal[*pbmp++]);
//  323         pbuf+=2;
//  324     }  } break;
//  325     case 2: //16 bit
//  326     for(j=0;j<sizey;j++){
//  327       pbmp=(ptr-=pitch);
//  328       for(i=0;i<sizex;i++){
//  329         *(short*)pbuf=rgb565toshort(*(short*)pbmp);
//  330         pbmp+=2;
//  331         pbuf+=2;
//  332     }  } break;
//  333     case 3: //24 bit
//  334     for(j=0;j<sizey;j++){
//  335       pbmp=(ptr-=pitch);
//  336       for(i=0;i<sizex;i++){
//  337         *(short*)pbuf=rgb888toshort(get3int(pbmp));
//  338         pbmp+=3;
//  339         pbuf+=2;
//  340     }  } break;
//  341     case 4: //32 bit
//  342     if((i=getint(bmp+10))&3){ //Выровнять данные на границу 4
//  343       j=i-(i&3);
//  344       memcpy(bmp+j, bmp+i, sizey*pitch);
//  345       ptr=bmp+j+sizey*pitch;
//  346     }
//  347     for(j=0;j<sizey;j++){
//  348       pbmp=(ptr-=pitch);
//  349       for(i=0;i<sizex;i++){
//  350         *(short*)pbuf=rgb888toshort(*(int*)pbmp);
//  351         pbmp+=4;
//  352         pbuf+=2;
//  353     }  } break;
//  354 #endif    
//  355     }
//  356     mfree(bmp);
//  357     return (char*)buf;
//  358   }while(0);
//  359   if(bmp) mfree(bmp);
//  360   if(buf) mfree(buf);
//  361   return 0;
//  362 }
//  363 #endif
//  364 
//  365 // Вывести на экран в поз х,у картинку размером sizex,sizey с поз. в bmp х0,у0 и 
//  366 // прозрачным цветом (если<>0)  Флаги: 0x40 = всегда
//  367 /*void bitblt(void *screen, void *bmp, int x, int y, int sizex, int sizey, int x0, int y0,  int colormask, int flags){
//  368   int i,j, sizexx, bmpx, bmpy;
//  369   // Проверка на дурака
//  370   if(!screen || !bmp || x>=width || y>=height) return;
//  371   bmpx=*(short*)bmp; 
//  372   bmpy=*(short*)((char*)bmp+2);
//  373   if(!sizex) sizex=bmpx;
//  374   if(!sizey) sizey=bmpy;
//  375   
//  376   if(x<0){ sizex+=x; x0-=x; x=0;}
//  377   if(y<0){ sizey+=y0; y0-=y; y=0;}
//  378   if(x0<0 || x0>=bmpx || y0<0 || y0>=bmpy || sizex<=0 || sizey<=0) return;
//  379   
//  380   if(x+sizex>=width) sizex=width-x;
//  381   if(x0+sizex>=bmpx) sizex=bmpx-x0;
//  382   if(y+sizey>=height) sizey=height-y;
//  383   if(y0+sizey>=bmpy) sizey=bmpy-y0;
//  384   
//  385 #ifndef HIGHCOLOR
//  386   char *scr=(char*)screen, *pic=(char*)bmp+4;
//  387   sizexx=sizex;
//  388 #else
//  389   short *scr=(short*)screen, *pic=(short*)((char*)bmp+4);
//  390   sizexx=sizex<<1;
//  391 #endif
//  392   scr+=width*y+x;
//  393   pic+=bmpx*y0 + x0;
//  394   if(colormask || (flags&0x40)){
//  395     for(j=0; j<sizey; j++, scr+=width-sizex, pic+=bmpx-sizex)
//  396       for(i=0; i<sizex; i++, scr++, pic++)
//  397         if(*pic!=
//  398 #ifndef HIGHCOLOR
//  399   (char)
//  400 #else
//  401  (short)             
//  402 #endif
//  403    colormask) *scr=*pic;
//  404   }else{
//  405     for(j=0; j<sizey; j++, scr+=width, pic+=bmpx)
//  406       memcpy(scr,pic,sizexx);
//  407   }
//  408 }
//  409 */
//  410 
//  411 //void debsave();
//  412 //char debarea[10000], *deb=debarea;
//  413 ////unsigned int err;
//  414 //
//  415 //void debsave(){
//  416 //  int f;
//  417 //  if(deb==debarea) return;
//  418 //  f=fopen("0:\\ZBin\\nes\\log",A_ReadWrite+A_BIN+A_Create+A_Append,P_READ+P_WRITE,&err);
//  419 //  if (f==-1) return;
//  420 //  fwrite32(f,(unsigned char*)debarea,deb-debarea,&err);
//  421 //  fclose(f,&err);
//  422 //  deb=debarea;
//  423 //}
//  424 //
//  425 //void debug(int num, int val){
//  426 //  if(deb-debarea<9800){
//  427 //  sprintf(deb,"\n%d = %d",num,val);
//  428 //  deb+=strlen(deb);
//  429 //  }
//  430 //}
//  431 
//  432 //    void memcpy3(signed char *to, signed char *from, int size){
//  433 //      to+=size;
//  434 //      from+=size;
//  435 //      while(--size>=0){
//  436 //        *--to=*--from;
//  437 //      }
//  438 //    }
//  439 //
//  440 //    void memcpy4(signed char *to, signed char *from, int size){
//  441 //      while(--size>=0){
//  442 //        *to++=*from++;
//  443 //      }
//  444 //    }
//  445     
//  446 //    void memmove(signed char *to, signed char *from, int size){
//  447 //      if(from<to)
//  448 //        if(from+size>=to) memcpy3(to,from,size);
//  449 //        else memcpy4(to,from,size);
//  450 //      else memcpy4(to,from,size);
//  451 //    }
//  452 
//  453 #ifndef DOS
//  454 /*
//  455     void *memmove(void *to, void *from, int size){
//  456       if((char*)from<(char*)to && (char*)from+size>=(char*)to) return memmov(to,from,size); //memcpyrev
//  457       return memcpy(to,from,size);
//  458     }
//  459 */
//  460 #endif
//  461 
//  462 //char *strcpy2(char *to, char *from){
//  463 //  char *res=to--;
//  464 //  do{ *++to=*from++;
//  465 //  }while(*to);
//  466 //  return res;
//  467 //}
//  468 //
//  469 //char *strcat2(char *to, char *from){
//  470 //  char *res=to--;
//  471 //  while(*++to); --to;
//  472 //  do{ *++to=*from++;
//  473 //  }while(*to);
//  474 //  return res;
//  475 //}
// 
// 1 364 bytes in segment CODE
//     8 bytes in segment DATA_Z
//    12 bytes in segment INITTAB
// 
// 1 276 bytes of CODE memory (+ 100 bytes shared)
//     8 bytes of DATA memory
//
//Errors: none
//Warnings: none
