##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    21/Apr/2011  22:57:51 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\arm\vNes_snd\SWILIB.C                             #
#    Command line    =  C:\arm\vNes_snd\SWILIB.C -D NDEBUG -lCN              #
#                       C:\arm\vNes_snd\Release\List\ -lA                    #
#                       C:\arm\vNes_snd\Release\List\ -o                     #
#                       C:\arm\vNes_snd\Release\Obj\ -s9 --cpu_mode arm      #
#                       --endian little --cpu ARM926EJ-S --stack_align 4     #
#                       --interwork -e --fpu None --dlib_config              #
#                       "C:\arm2\Embedded Workbench 4.0                      #
#                       Evaluation\ARM\LIB\dl5tpainl8f.h" -I                 #
#                       "C:\arm2\Embedded Workbench 4.0                      #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  C:\arm\vNes_snd\Release\List\SWILIB.lst              #
#    Object file     =  C:\arm\vNes_snd\Release\Obj\SWILIB.r79               #
#                                                                            #
#                                                                            #
##############################################################################

C:\arm\vNes_snd\SWILIB.C
      1          
      2          // swilib.c
      3          #include "c:\arm\inc\Swilib.h"
      4          //#define HIGHCOLOR // 16-битный режим
      5          //#define GRAPH  // Графика
      6          //#define UNPACK // Распаковка архивов
      7          #define NO7Z   // Кроме 7z
      8          //#define NOZIP  // Кроме zip
      9          #define NORAR  // Кроме rar
     10          //#define NOLOAD // in loadgraph data loaded allready
     11          
     12          //#ifdef ELKA
     13          //  #define width 240
     14          //  #define height 304
     15          //#else
     16          //  #define width 132
     17          //  #define height 176
     18          //#endif
     19          extern int width, height;
     20          

   \                                 In segment DATA_Z, align 4, align-sorted
     21          unsigned int err=0;
   \                     err:
   \   00000000                      DS8 4

   \                                 In segment DATA_Z, align 4, align-sorted
     22          int loadfilesize=0;
   \                     loadfilesize:
   \   00000000                      DS8 4
     23          
     24          //#define ELKA // Для EL-71
     25          //#ifndef NEWSGOLD
     26          //#define NEWSGOLD // Для S75
     27          //#endif
     28          //#ifndef NEWSGOLD
     29          

   \                                 In segment CODE, align 4, keep-with-next
     30          int fread32(int fh, void *buf, int len, unsigned int *err){
   \                     fread32:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   0370A0E1           MOV      R7,R3
     31            int clen, rlen, total=0;
   \   00000014   0080A0E3           MOV      R8,#+0
   \   00000018   010000EA           B        ??fread32_0
     32            while(len){
     33            if (len>16384) clen=16384; else clen=len;
     34            total+=(rlen=fread(fh, buf, clen, err));
     35            if (rlen!=clen) break;
     36            buf=(char*)buf+rlen;
   \                     ??fread32_1:
   \   0000001C   055080E0           ADD      R5,R0,R5
     37            len-=clen;
   \   00000020   096046E0           SUB      R6,R6,R9
   \                     ??fread32_0:
   \   00000024   000056E3           CMP      R6,#+0
   \   00000028   0C00000A           BEQ      ??fread32_2
   \   0000002C   0100A0E3           MOV      R0,#+1
   \   00000030   400C80E3           ORR      R0,R0,#0x4000
   \   00000034   000056E1           CMP      R6,R0
   \   00000038   409CA0A3           MOVGE    R9,#+16384
   \   0000003C   0690A0B1           MOVLT    R9,R6
   \   00000040   0730A0E1           MOV      R3,R7
   \   00000044   0920A0E1           MOV      R2,R9
   \   00000048   0510A0E1           MOV      R1,R5
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   0B0000EF           SWI      +11
   \   00000054   088080E0           ADD      R8,R0,R8
   \   00000058   090050E1           CMP      R0,R9
   \   0000005C   EEFFFF0A           BEQ      ??fread32_1
     38            }return(total);
   \                     ??fread32_2:
   \   00000060   0800A0E1           MOV      R0,R8
   \   00000064   F083BDE8           POP      {R4-R9,PC}       ;; return
     39          }
     40          

   \                                 In segment CODE, align 4, keep-with-next
     41          int fwrite32(int fh, void *buf, int len, unsigned int *err){
   \                     fwrite32:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   0370A0E1           MOV      R7,R3
     42            int clen, rlen, total=0;
   \   00000014   0080A0E3           MOV      R8,#+0
   \   00000018   010000EA           B        ??fwrite32_0
     43            while(len){
     44            if (len>16384) clen=16384; else clen=len;
     45            total+=(rlen=fwrite(fh, buf, clen, err));
     46            if (rlen!=clen) break;
     47            buf=(char*)buf+rlen;
   \                     ??fwrite32_1:
   \   0000001C   055080E0           ADD      R5,R0,R5
     48            len-=clen;
   \   00000020   096046E0           SUB      R6,R6,R9
   \                     ??fwrite32_0:
   \   00000024   000056E3           CMP      R6,#+0
   \   00000028   0C00000A           BEQ      ??fwrite32_2
   \   0000002C   0100A0E3           MOV      R0,#+1
   \   00000030   400C80E3           ORR      R0,R0,#0x4000
   \   00000034   000056E1           CMP      R6,R0
   \   00000038   409CA0A3           MOVGE    R9,#+16384
   \   0000003C   0690A0B1           MOVLT    R9,R6
   \   00000040   0730A0E1           MOV      R3,R7
   \   00000044   0920A0E1           MOV      R2,R9
   \   00000048   0510A0E1           MOV      R1,R5
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   0C0000EF           SWI      +12
   \   00000054   088080E0           ADD      R8,R0,R8
   \   00000058   090050E1           CMP      R0,R9
   \   0000005C   EEFFFF0A           BEQ      ??fwrite32_1
     49            }return(total);
   \                     ??fwrite32_2:
   \   00000060   0800A0E1           MOV      R0,R8
   \   00000064   F083BDE8           POP      {R4-R9,PC}       ;; return
     50          }
     51          //#endif
     52          
     53          //void *memset(void *mem, int val, int size){
     54          //  char *s=(char*)mem;
     55          //  while(--size>=0) *s++=(char)val;
     56          //  return mem;
     57          //}
     58          
     59          //void *memsetw(void *mem, int val, int size){
     60          //  short *s=(short*)mem;
     61          //  while(--size>=0) *s++=val;
     62          //  return mem;
     63          //}
     64          

   \                                 In segment CODE, align 4, keep-with-next
     65          int min(int a, int b){ return (a<b)?a:b;}
   \                     min:
   \   00000000   010050E1           CMP      R0,R1
   \   00000004   0100A0A1           MOVGE    R0,R1
   \   00000008   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
     66          int max(int a, int b){ return (a>b)?a:b;}
   \                     max:
   \   00000000   000051E1           CMP      R1,R0
   \   00000004   0100A0A1           MOVGE    R0,R1
   \   00000008   1EFF2FE1           BX       LR               ;; return
     67          //int abs(int a){ return (a<0)?-a:a;}
     68          

   \                                 In segment CODE, align 4, keep-with-next
     69          int fgets(char *buf,int size,int fh){ return 0;} //fake!!!
   \                     fgets:
   \   00000000   0000A0E3           MOV      R0,#+0
   \   00000004   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
     70          void printf(char *s,...){}  //fake!!!
   \                     printf:
   \   00000000   0E002DE9           PUSH     {R1-R3}
   \   00000004   0CD08DE2           ADD      SP,SP,#+12
   \   00000008   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
     71          char *strdup(char *s){ return s;}
   \                     strdup:
   \   00000000   1EFF2FE1           BX       LR               ;; return
     72          
     73          //void *memcpyrev(void *to, void *from, int size){
     74          //  char *s=(char*)to+size, *ss=(char*)from+size;
     75          //  while(--size>=0)
     76          //    *--s=*--ss;
     77          //  return to;
     78          //}
     79          

   \                                 In segment CODE, align 4, keep-with-next
     80          int savefile(char *fname, char *buf, int size){
   \                     savefile:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
     81            int f,i;
     82            if((f=fopen(fname,A_WriteOnly+A_BIN+A_Create+A_Truncate,P_WRITE,&err))==-1) return 0;
   \   00000004   50609FE5           LDR      R6,??savefile_0  ;; err
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   0250A0E1           MOV      R5,R2
   \   00000010   0630A0E1           MOV      R3,R6
   \   00000014   402FA0E3           MOV      R2,#+256
   \   00000018   0110A0E3           MOV      R1,#+1
   \   0000001C   831C81E3           ORR      R1,R1,#0x8300
   \   00000020   0A0000EF           SWI      +10
   \   00000024   0070A0E1           MOV      R7,R0
   \   00000028   010077E3           CMN      R7,#+1
   \   0000002C   0000A003           MOVEQ    R0,#+0
   \   00000030   F080BD08           POPEQ    {R4-R7,PC}
     83            i=fwrite32(f,buf,size,&err); 
   \   00000034   0630A0E1           MOV      R3,R6
   \   00000038   0520A0E1           MOV      R2,R5
   \   0000003C   0410A0E1           MOV      R1,R4
   \   00000040   ........           BL       fwrite32
   \   00000044   0040A0E1           MOV      R4,R0
     84            fclose(f,&err); 
   \   00000048   0610A0E1           MOV      R1,R6
   \   0000004C   0700A0E1           MOV      R0,R7
   \   00000050   0D0000EF           SWI      +13
     85            return i;
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??savefile_0:
   \   0000005C   ........           DC32     err
     86          }
     87          

   \                                 In segment CODE, align 4, keep-with-next
     88          char *loadfile(char *filename){ // Загрузить файл, распак-ть
   \                     loadfile:
   \   00000000   E0402DE9           PUSH     {R5-R7,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
     89            int f; unsigned int err;  char *buf=0;
   \   00000008   0050A0E3           MOV      R5,#+0
     90            if((f=fopen(filename,A_ReadOnly+A_BIN,P_READ,&err))!=-1){
   \   0000000C   0D30A0E1           MOV      R3,SP
   \   00000010   8020A0E3           MOV      R2,#+128
   \   00000014   801CA0E3           MOV      R1,#+32768
   \   00000018   0A0000EF           SWI      +10
   \   0000001C   0060A0E1           MOV      R6,R0
   \   00000020   010076E3           CMN      R6,#+1
   \   00000024   2300000A           BEQ      ??loadfile_0
     91              if(loadfilesize=lseek(f,0,2,&err,&err)){
   \   00000028   90709FE5           LDR      R7,??loadfile_1  ;; loadfilesize
   \   0000002C   0D00A0E1           MOV      R0,SP
   \   00000030   01002DE9           PUSH     {R0}
   \   00000034   04308DE2           ADD      R3,SP,#+4
   \   00000038   0220A0E3           MOV      R2,#+2
   \   0000003C   0010A0E3           MOV      R1,#+0
   \   00000040   0600A0E1           MOV      R0,R6
   \   00000044   0F0000EF           SWI      +15
   \   00000048   000087E5           STR      R0,[R7, #+0]
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   04D08DE2           ADD      SP,SP,#+4
   \   00000054   1400000A           BEQ      ??loadfile_2
     92                buf=(char*)malloc(loadfilesize);
   \   00000058   140000EF           SWI      +20
   \   0000005C   0050A0E1           MOV      R5,R0
     93                lseek(f,0,0,&err,&err);
   \   00000060   0D00A0E1           MOV      R0,SP
   \   00000064   01002DE9           PUSH     {R0}
   \   00000068   04308DE2           ADD      R3,SP,#+4
   \   0000006C   0020A0E3           MOV      R2,#+0
   \   00000070   0010A0E3           MOV      R1,#+0
   \   00000074   0600A0E1           MOV      R0,R6
   \   00000078   0F0000EF           SWI      +15
     94                if(fread32(f,buf,loadfilesize,&err)!=loadfilesize){ mfree(buf); buf=0;}
   \   0000007C   002097E5           LDR      R2,[R7, #+0]
   \   00000080   04308DE2           ADD      R3,SP,#+4
   \   00000084   0510A0E1           MOV      R1,R5
   \   00000088   0600A0E1           MOV      R0,R6
   \   0000008C   ........           BL       fread32
   \   00000090   001097E5           LDR      R1,[R7, #+0]
   \   00000094   04D08DE2           ADD      SP,SP,#+4
   \   00000098   010050E1           CMP      R0,R1
   \   0000009C   0200000A           BEQ      ??loadfile_2
   \   000000A0   0500A0E1           MOV      R0,R5
   \   000000A4   150000EF           SWI      +21
   \   000000A8   0050A0E3           MOV      R5,#+0
     95              } fclose(f,&err);
   \                     ??loadfile_2:
   \   000000AC   0D10A0E1           MOV      R1,SP
   \   000000B0   0600A0E1           MOV      R0,R6
   \   000000B4   0D0000EF           SWI      +13
     96          #ifdef UNPACK
     97              extern char *un7z(char *buf);
     98              extern char *unrar(char *buf);
     99              extern char *unzip(char *buf);
    100              if(buf && loadfilesize>4){
    101          #ifndef NORAR
    102                if(*(int *)buf=='!raR') buf=unrar(buf); //unrar
    103                else
    104          #endif      
    105          #ifndef NOZIP
    106                if(*(int*)buf==0x4034b50) buf=unzip(buf); //unzip
    107                else
    108          #endif
    109          #ifndef NO7Z      
    110                if(*(short*)buf=='z7') buf=un7z(buf); //un7z
    111          #endif
    112               ;      
    113              }
    114          //#ifdef SAVETEST
    115          //  int out=fopen("0:\\ZBin\\123",A_WriteOnly+A_BIN+A_Create,P_WRITE,&err);
    116          //  fwrite32(out,buf,loadfilesize,&err);
    117          //  fclose(out,&err);
    118          //#endif    
    119              
    120          #endif      
    121            } return buf;
   \                     ??loadfile_0:
   \   000000B8   0500A0E1           MOV      R0,R5
   \   000000BC   E280BDE8           POP      {R1,R5-R7,PC}
   \                     ??loadfile_1:
   \   000000C0   ........           DC32     loadfilesize
    122          }
    123          
    124          //void *memset(void *buf, int val, int size){
    125          //  char *b=(char*)buf;
    126          //  while(--size>=0) *b++=val; 
    127          //  return buf;
    128          //}
    129          

   \                                 In segment CODE, align 4, keep-with-next
    130          char *toup(char *str){			// К верхнему регистру
    131            char *val=str;
   \                     toup:
   \   00000000   0010A0E1           MOV      R1,R0
   \   00000004   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000008   000052E3           CMP      R2,#+0
   \   0000000C   1EFF2F01           BXEQ     LR
    132            while(*val!=NULL){
    133                   if(*val>='a' && *val<='z')  *val-=' ';  
   \                     ??toup_0:
   \   00000010   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000014   0230A0E1           MOV      R3,R2
   \   00000018   610052E3           CMP      R2,#+97
   \   0000001C   0300003A           BCC      ??toup_1
   \   00000020   7B0053E3           CMP      R3,#+123
   \   00000024   0100002A           BCS      ??toup_1
   \                     ??toup_2:
   \   00000028   E03083E2           ADD      R3,R3,#+224
   \   0000002C   050000EA           B        ??toup_3
    134              else if(*val>='а' && *val<='п')  *val-=' ';  
   \                     ??toup_1:
   \   00000030   E00053E3           CMP      R3,#+224
   \   00000034   0100003A           BCC      ??toup_4
   \   00000038   F00053E3           CMP      R3,#+240
   \   0000003C   F9FFFF3A           BCC      ??toup_2
    135              else if(*val>='р' && *val<='я')  *val-= 80;  
   \                     ??toup_4:
   \   00000040   F00053E3           CMP      R3,#+240
   \   00000044   B0308322           ADDCS    R3,R3,#+176
   \                     ??toup_3:
   \   00000048   ........           STRB     R3,[R1], #+1
    136              ++val;
    137            }
   \   0000004C   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000050   000052E3           CMP      R2,#+0
   \   00000054   EDFFFF1A           BNE      ??toup_0
    138            return str;
   \   00000058   1EFF2FE1           BX       LR               ;; return
    139          }  
    140          

   \                                 In segment CODE, align 4, keep-with-next
    141          char *todown(char *str){		// К нижнему регистру
    142            char *val=str;
   \                     todown:
   \   00000000   0010A0E1           MOV      R1,R0
   \   00000004   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000008   000052E3           CMP      R2,#+0
   \   0000000C   1EFF2F01           BXEQ     LR
    143            while(*val!=NULL){
    144                   if(*val>='A' && *val<='Z')  *val+=' '; 
   \                     ??todown_0:
   \   00000010   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000014   0230A0E1           MOV      R3,R2
   \   00000018   410052E3           CMP      R2,#+65
   \   0000001C   0300003A           BCC      ??todown_1
   \   00000020   5B0053E3           CMP      R3,#+91
   \   00000024   0100002A           BCS      ??todown_1
   \                     ??todown_2:
   \   00000028   203083E2           ADD      R3,R3,#+32
   \   0000002C   070000EA           B        ??todown_3
    145              else if(*val>='А' && *val<='П')  *val+=' ';
   \                     ??todown_1:
   \   00000030   C00053E3           CMP      R3,#+192
   \   00000034   0100003A           BCC      ??todown_4
   \   00000038   D00053E3           CMP      R3,#+208
   \   0000003C   F9FFFF3A           BCC      ??todown_2
    146              else if(*val>='Р' && *val<='Я')  *val+= 80; 
   \                     ??todown_4:
   \   00000040   D00053E3           CMP      R3,#+208
   \   00000044   0100003A           BCC      ??todown_3
   \   00000048   E00053E3           CMP      R3,#+224
   \   0000004C   50308332           ADDCC    R3,R3,#+80
   \                     ??todown_3:
   \   00000050   ........           STRB     R3,[R1], #+1
    147              ++val;
    148            }
   \   00000054   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000058   000052E3           CMP      R2,#+0
   \   0000005C   EBFFFF1A           BNE      ??todown_0
    149            return str;
   \   00000060   1EFF2FE1           BX       LR               ;; return
    150          }  
    151          

   \                                 In segment CODE, align 4, keep-with-next
    152          int  isalth (unsigned char sym){	// Алфавитный символ ?
    153            return ((sym>='A' && sym<='Z') || (sym>=(unsigned char)'А' && sym<=(unsigned char)'П')
    154              || (sym>=(unsigned char)'Р' && sym<=(unsigned char)'Я'));}
   \                     isalth:
   \   00000000   410050E3           CMP      R0,#+65
   \   00000004   0100003A           BCC      ??isalth_0
   \   00000008   5B0050E3           CMP      R0,#+91
   \   0000000C   0700003A           BCC      ??isalth_1
   \                     ??isalth_0:
   \   00000010   C00050E3           CMP      R0,#+192
   \   00000014   0100003A           BCC      ??isalth_2
   \   00000018   D00050E3           CMP      R0,#+208
   \   0000001C   0300003A           BCC      ??isalth_1
   \                     ??isalth_2:
   \   00000020   D00050E3           CMP      R0,#+208
   \   00000024   0300003A           BCC      ??isalth_3
   \   00000028   E00050E3           CMP      R0,#+224
   \   0000002C   0100002A           BCS      ??isalth_3
   \                     ??isalth_1:
   \   00000030   0100A0E3           MOV      R0,#+1
   \   00000034   1EFF2FE1           BX       LR
   \                     ??isalth_3:
   \   00000038   0000A0E3           MOV      R0,#+0
   \   0000003C   1EFF2FE1           BX       LR               ;; return
    155          

   \                                 In segment CODE, align 4, keep-with-next
    156          int  isval (char sym){		// Символ является числом ?
    157            return (sym>='0' && sym<='9');}
   \                     isval:
   \   00000000   300050E3           CMP      R0,#+48
   \   00000004   0200003A           BCC      ??isval_0
   \   00000008   3A0050E3           CMP      R0,#+58
   \   0000000C   0100A033           MOVCC    R0,#+1
   \   00000010   1EFF2F31           BXCC     LR
   \                     ??isval_0:
   \   00000014   0000A0E3           MOV      R0,#+0
   \   00000018   1EFF2FE1           BX       LR               ;; return
    158          

   \                                 In segment CODE, align 4, keep-with-next
    159          int strchrpos(const char *s, int c){	// Позиция символа в строке (1-N, 0=нет)
   \                     strchrpos:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    160            char *sptr=strchr(s,c);
   \   00000008   180000EF           SWI      +24
    161            return (sptr)?sptr-s+1:NULL;
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   04004010           SUBNE    R0,R0,R4
   \   00000014   01008012           ADDNE    R0,R0,#+1
   \   00000018   1080BDE8           POP      {R4,PC}          ;; return
    162          }
    163            

   \                                 In segment CODE, align 4, keep-with-next
    164          int emptystr(char *str){		// Пустая ли строка
   \                     emptystr:
   \   00000000   000000EA           B        ??emptystr_0
    165            while(*str && (*str==' ' || *str==9)) ++str;
   \                     ??emptystr_1:
   \   00000004   010080E2           ADD      R0,R0,#+1
   \                     ??emptystr_0:
   \   00000008   0010D0E5           LDRB     R1,[R0, #+0]
   \   0000000C   000051E3           CMP      R1,#+0
   \   00000010   0200000A           BEQ      ??emptystr_2
   \   00000014   200051E3           CMP      R1,#+32
   \   00000018   09005113           CMPNE    R1,#+9
   \   0000001C   F8FFFF0A           BEQ      ??emptystr_1
    166            return ((*str)?0:1);
   \                     ??emptystr_2:
   \   00000020   000051E3           CMP      R1,#+0
   \   00000024   0000A013           MOVNE    R0,#+0
   \   00000028   1EFF2F11           BXNE     LR
   \   0000002C   0100A0E3           MOV      R0,#+1
   \   00000030   1EFF2FE1           BX       LR               ;; return
    167          }
    168          

   \                                 In segment CODE, align 4, keep-with-next
    169          char  *alltrim (char *str){		// Удалить пробелы по бокам строки
    170            char *s;
    171            if(!*str) return str;
   \                     alltrim:
   \   00000000   0010D0E5           LDRB     R1,[R0, #+0]
   \   00000004   000051E3           CMP      R1,#+0
   \   00000008   0100001A           BNE      ??alltrim_0
   \   0000000C   1EFF2FE1           BX       LR
    172            while(*str==' ' || *str==9) ++str;
   \                     ??alltrim_1:
   \   00000010   010080E2           ADD      R0,R0,#+1
   \                     ??alltrim_0:
   \   00000014   0010D0E5           LDRB     R1,[R0, #+0]
   \   00000018   200051E3           CMP      R1,#+32
   \   0000001C   09005113           CMPNE    R1,#+9
   \   00000020   FAFFFF0A           BEQ      ??alltrim_1
    173            s=str;
   \   00000024   0010A0E1           MOV      R1,R0
   \   00000028   0020D1E5           LDRB     R2,[R1, #+0]
   \   0000002C   000052E3           CMP      R2,#+0
   \   00000030   0200000A           BEQ      ??alltrim_2
    174            while(*s) ++s;
   \                     ??alltrim_3:
   \   00000034   0120F1E5           LDRB     R2,[R1, #+1]!
   \   00000038   000052E3           CMP      R2,#+0
   \   0000003C   FCFFFF1A           BNE      ??alltrim_3
    175            while(s>str && (*(s-1)==' ' || *(s-1)==9)) --s;
   \                     ??alltrim_2:
   \   00000040   010050E1           CMP      R0,R1
   \   00000044   0400002A           BCS      ??alltrim_4
   \   00000048   012051E5           LDRB     R2,[R1, #-1]
   \   0000004C   200052E3           CMP      R2,#+32
   \   00000050   09005213           CMPNE    R2,#+9
   \   00000054   01104102           SUBEQ    R1,R1,#+1
   \   00000058   F8FFFF0A           BEQ      ??alltrim_2
    176            *s=NULL;
   \                     ??alltrim_4:
   \   0000005C   0020A0E3           MOV      R2,#+0
   \   00000060   0020C1E5           STRB     R2,[R1, #+0]
    177            return str;
   \   00000064   1EFF2FE1           BX       LR               ;; return
    178          }
    179          

   \                                 In segment CODE, align 4, keep-with-next
    180          int   strcmpsize (const char *s1,const char *s2,int size){ // Сравнить строки длины size
   \                     strcmpsize:
   \   00000000   10002DE9           PUSH     {R4}
    181            int i;
    182            for(i=0;i<size && s1[i]==s2[i];i++);
   \   00000004   0030A0E3           MOV      R3,#+0
   \   00000008   040000EA           B        ??strcmpsize_0
   \                     ??strcmpsize_1:
   \   0000000C   00C0D3E7           LDRB     R12,[R3, +R0]
   \   00000010   0140D3E7           LDRB     R4,[R3, +R1]
   \   00000014   04005CE1           CMP      R12,R4
   \   00000018   0400001A           BNE      ??strcmpsize_2
   \   0000001C   013083E2           ADD      R3,R3,#+1
   \                     ??strcmpsize_0:
   \   00000020   020053E1           CMP      R3,R2
   \   00000024   F8FFFFBA           BLT      ??strcmpsize_1
    183              return (i==size)?NULL:s1[i]-s2[i];
   \   00000028   0000A003           MOVEQ    R0,#+0
   \   0000002C   0200000A           BEQ      ??strcmpsize_3
   \                     ??strcmpsize_2:
   \   00000030   0000D3E7           LDRB     R0,[R3, +R0]
   \   00000034   0110D3E7           LDRB     R1,[R3, +R1]
   \   00000038   010040E0           SUB      R0,R0,R1
   \                     ??strcmpsize_3:
   \   0000003C   1000BDE8           POP      {R4}
   \   00000040   1EFF2FE1           BX       LR               ;; return
    184          }
    185          

   \                                 In segment CODE, align 4, keep-with-next
    186          int getint(void *ptr){ // Получить int
    187            if((int)ptr & 3) return *(unsigned char*)ptr | *((unsigned char*)ptr+1)<<8\
   \                     getint:
   \   00000000   030010E3           TST      R0,#0x3
   \   00000004   0700000A           BEQ      ??getint_0
    188              | *((unsigned char*)ptr+2)<<16 | *((unsigned char*)ptr+3)<<24;
   \   00000008   0010D0E5           LDRB     R1,[R0, #+0]
   \   0000000C   0120D0E5           LDRB     R2,[R0, #+1]
   \   00000010   021481E1           ORR      R1,R1,R2, LSL #+8
   \   00000014   0220D0E5           LDRB     R2,[R0, #+2]
   \   00000018   0300D0E5           LDRB     R0,[R0, #+3]
   \   0000001C   021881E1           ORR      R1,R1,R2, LSL #+16
   \   00000020   000C81E1           ORR      R0,R1,R0, LSL #+24
   \   00000024   1EFF2FE1           BX       LR
    189            else return *(int*)ptr;
   \                     ??getint_0:
   \   00000028   000090E5           LDR      R0,[R0, #+0]
   \   0000002C   1EFF2FE1           BX       LR               ;; return
    190          }
    191          

   \                                 In segment CODE, align 4, keep-with-next
    192          int get3int(void *ptr){ // Получить 3int
    193            return *(unsigned char*)ptr | *((unsigned char*)ptr+1)<<8 | *((unsigned char*)ptr+2)<<16; 
   \                     get3int:
   \   00000000   0010D0E5           LDRB     R1,[R0, #+0]
   \   00000004   0120D0E5           LDRB     R2,[R0, #+1]
   \   00000008   0200D0E5           LDRB     R0,[R0, #+2]
   \   0000000C   021481E1           ORR      R1,R1,R2, LSL #+8
   \   00000010   000881E1           ORR      R0,R1,R0, LSL #+16
   \   00000014   1EFF2FE1           BX       LR               ;; return
    194          }
    195          

   \                                 In segment CODE, align 4, keep-with-next
    196          short getshort(void *ptr){ // Получить short
    197            if((int)ptr & 1) return *(unsigned char*)ptr | *((unsigned char*)ptr+1)<<8;
   \                     getshort:
   \   00000000   010010E3           TST      R0,#0x1
   \   00000004   0500000A           BEQ      ??getshort_0
   \   00000008   0010D0E5           LDRB     R1,[R0, #+0]
   \   0000000C   0100D0E5           LDRB     R0,[R0, #+1]
   \   00000010   000481E1           ORR      R0,R1,R0, LSL #+8
   \   00000014   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000018   4008A0E1           MOV      R0,R0, ASR #+16
   \   0000001C   1EFF2FE1           BX       LR
    198            else return *(short*)ptr;
   \                     ??getshort_0:
   \   00000020   F000D0E1           LDRSH    R0,[R0, #+0]
   \   00000024   1EFF2FE1           BX       LR               ;; return
    199          }
    200          

   \                                 In segment CODE, align 4, keep-with-next
    201          void putint(void *ptr, int data){ // Записать int
    202            if((int)ptr & 3){ *(char*)ptr=data; *((char*)ptr+1)=data>>8;
   \                     putint:
   \   00000000   030010E3           TST      R0,#0x3
   \   00000004   0700000A           BEQ      ??putint_0
   \   00000008   0010C0E5           STRB     R1,[R0, #+0]
   \   0000000C   4124A0E1           ASR      R2,R1,#+8
   \   00000010   0120C0E5           STRB     R2,[R0, #+1]
    203              *((char*)ptr+2)=data>>16; *((char*)ptr+3)=data>>24;
   \   00000014   4128A0E1           ASR      R2,R1,#+16
   \   00000018   0220C0E5           STRB     R2,[R0, #+2]
   \   0000001C   411CA0E1           ASR      R1,R1,#+24
   \   00000020   0310C0E5           STRB     R1,[R0, #+3]
   \   00000024   1EFF2FE1           BX       LR
    204            }else *(int*)ptr=data;
   \                     ??putint_0:
   \   00000028   001080E5           STR      R1,[R0, #+0]
    205            
    206          }
   \   0000002C   1EFF2FE1           BX       LR               ;; return
    207           

   \                                 In segment CODE, align 4, keep-with-next
    208          void putshort(void *ptr, short data){ // Записать short
    209            if((int)ptr & 1){ *(char*)ptr=data; *((char*)ptr+1)=data>>8;
   \                     putshort:
   \   00000000   010010E3           TST      R0,#0x1
   \   00000004   0300000A           BEQ      ??putshort_0
   \   00000008   0010C0E5           STRB     R1,[R0, #+0]
   \   0000000C   4114A0E1           ASR      R1,R1,#+8
   \   00000010   0110C0E5           STRB     R1,[R0, #+1]
   \   00000014   1EFF2FE1           BX       LR
    210            }else *(short*)ptr=data;
   \                     ??putshort_0:
   \   00000018   B010C0E1           STRH     R1,[R0, #+0]
    211          }
   \   0000001C   1EFF2FE1           BX       LR               ;; return
    212          
    213          #ifdef GRAPH
    214          /*-----------------------------
    215          смещ.	размер	имя
    216          00	2	'BM'
    217          02	4	Размер файла в байтах;
    218          06	2	0
    219          08	2	0
    220          10	4	Смещение начала изображения в файле;
    221          14	4	Размер этого заголовка, 40;
    222          18	4	Ширина изображения в пикселях;
    223          22	4	Высота изображения в пикселях;
    224          26	2	Число плоскостей изображения, 1;
    225          28	2	Бит на пиксел: 1,4,8 или 24;
    226          30	4	Тип сжатия;
    227          34	4	Размер сжатого изображения в байтах или 0;
    228          38	4	Горизонтальное разрешение, в пикселях / на метр;
    229          42	4	Вертикальное разрешение, в пикселях / на метр;
    230          46	4	Количество используемых цветов;
    231          50	4	Число "важных" цветов;
    232          54	4*N	Карты цветов BGRР;
    233          
    234          BMP	заголовок 54 б + палитра 4*256;*/
    235          
    236          inline unsigned char rgb888tobyte(int color){
    237            return ((color>>6)&3)|((color>>11)&0x1C)|((color>>16)&0xE0); }
    238          
    239          inline short rgb888toshort(int color){
    240            return ((color>>3)&0x1f)|((color>>5)&0x7e0)|((color>>8)&0xf800); }
    241          
    242          inline unsigned char rgb565tobyte(short color){
    243            return ((color>>3)&3)|((color>>6)&0x1C)|((color>>8)&0xE0); }
    244          
    245          inline short rgb565toshort(short color){
    246            return color; }
    247          
    248          
    249          int loadgraphsize=0;
    250          #ifndef HIGHCOLOR
    251            const int graphpoints=1;
    252          #else  
    253            const int graphpoints=2;
    254          #endif
    255          // Формат файла 2б х 2б у  далее точки (повернуты как надо, без выравнивания)
    256          char *loadgraph(char *filename){ // Загрузить графику (распаковываем и перекодируем) #define HIGHCOLOR учесть
    257            unsigned char *bmp=0, *buf=0, *pbuf, *pbmp, *ptr;
    258            int *pal;
    259            int sizex, sizey, bytepixel, pitch;
    260            int i,j;
    261            do{
    262              if(!(bmp=(unsigned char*)
    263          #ifndef NOLOAD
    264              loadfile(filename)
    265          #else
    266              filename
    267          #endif
    268              )) break;
    269              if(getshort(bmp)!='MB') break;
    270              sizex=getint(bmp+18);
    271              sizey=getint(bmp+22);
    272              bytepixel=getshort(bmp+28)>>3;
    273              if(!sizex || !sizey || bytepixel<1 || bytepixel>4) break;
    274              pitch=sizex*bytepixel;
    275              if(pitch&3) pitch+=4-(pitch&3);
    276              if(!(buf=(unsigned char*)malloc(loadgraphsize=sizex*sizey*graphpoints+4))) break;
    277              *(short*)buf=sizex; *(short*)(buf+2)=sizey; 
    278              pbuf=buf+4;
    279              ptr=bmp+getint(bmp+10)+sizey*pitch;
    280          #ifndef HIGHCOLOR //1 byte
    281              switch(bytepixel){
    282              case 1: //8 -> 8
    283                memcpy(pal=(int*)(bmp+52),bmp+54,*(short*)(bmp+50)?(*(short*)(bmp+50)<<2):1024);
    284              for(j=0;j<sizey;j++){
    285                pbmp=(ptr-=pitch);
    286                for(i=0;i<sizex;i++){
    287                  *pbuf++=rgb888tobyte(pal[*pbmp++]);
    288              }  } break;
    289              case 2: //16 bit
    290              for(j=0;j<sizey;j++){
    291                pbmp=(ptr-=pitch);
    292                for(i=0;i<sizex;i++){
    293                  *pbuf++=rgb565tobyte(*(short*)pbmp);
    294                  pbmp+=2;
    295              }  } break;
    296              case 3: //24 bit
    297              for(j=0;j<sizey;j++){
    298                pbmp=(ptr-=pitch);
    299                for(i=0;i<sizex;i++){
    300                  *pbuf++=rgb888tobyte(get3int(pbmp));
    301                  pbmp+=3;
    302              }  } break;
    303              case 4: //32 bit
    304              if((i=getint(bmp+10))&3){ //Выровнять данные на границу 4
    305                j=i-(i&3);
    306                memcpy(bmp+j, bmp+i, sizey*pitch);
    307                ptr=bmp+j+sizey*pitch;
    308              }
    309              for(j=0;j<sizey;j++){
    310                pbmp=(ptr-=pitch);
    311                for(i=0;i<sizex;i++){
    312                  *pbuf++=rgb888tobyte(*(int*)pbmp);
    313                  pbmp+=4;
    314              }  } break;
    315           #else    // 2 byte
    316              switch(bytepixel){
    317              case 1: //8 -> 16
    318              memcpy(pal=(int*)(bmp+52),bmp+54,*(short*)(bmp+50)?(*(short*)(bmp+50)<<2):1024);
    319              for(j=0;j<sizey;j++){
    320                pbmp=(ptr-=pitch);
    321                for(i=0;i<sizex;i++){
    322                  *(short*)pbuf=rgb888toshort(pal[*pbmp++]);
    323                  pbuf+=2;
    324              }  } break;
    325              case 2: //16 bit
    326              for(j=0;j<sizey;j++){
    327                pbmp=(ptr-=pitch);
    328                for(i=0;i<sizex;i++){
    329                  *(short*)pbuf=rgb565toshort(*(short*)pbmp);
    330                  pbmp+=2;
    331                  pbuf+=2;
    332              }  } break;
    333              case 3: //24 bit
    334              for(j=0;j<sizey;j++){
    335                pbmp=(ptr-=pitch);
    336                for(i=0;i<sizex;i++){
    337                  *(short*)pbuf=rgb888toshort(get3int(pbmp));
    338                  pbmp+=3;
    339                  pbuf+=2;
    340              }  } break;
    341              case 4: //32 bit
    342              if((i=getint(bmp+10))&3){ //Выровнять данные на границу 4
    343                j=i-(i&3);
    344                memcpy(bmp+j, bmp+i, sizey*pitch);
    345                ptr=bmp+j+sizey*pitch;
    346              }
    347              for(j=0;j<sizey;j++){
    348                pbmp=(ptr-=pitch);
    349                for(i=0;i<sizex;i++){
    350                  *(short*)pbuf=rgb888toshort(*(int*)pbmp);
    351                  pbmp+=4;
    352                  pbuf+=2;
    353              }  } break;
    354          #endif    
    355              }
    356              mfree(bmp);
    357              return (char*)buf;
    358            }while(0);
    359            if(bmp) mfree(bmp);
    360            if(buf) mfree(buf);
    361            return 0;
    362          }
    363          #endif
    364          
    365          // Вывести на экран в поз х,у картинку размером sizex,sizey с поз. в bmp х0,у0 и 
    366          // прозрачным цветом (если<>0)  Флаги: 0x40 = всегда
    367          /*void bitblt(void *screen, void *bmp, int x, int y, int sizex, int sizey, int x0, int y0,  int colormask, int flags){
    368            int i,j, sizexx, bmpx, bmpy;
    369            // Проверка на дурака
    370            if(!screen || !bmp || x>=width || y>=height) return;
    371            bmpx=*(short*)bmp; 
    372            bmpy=*(short*)((char*)bmp+2);
    373            if(!sizex) sizex=bmpx;
    374            if(!sizey) sizey=bmpy;
    375            
    376            if(x<0){ sizex+=x; x0-=x; x=0;}
    377            if(y<0){ sizey+=y0; y0-=y; y=0;}
    378            if(x0<0 || x0>=bmpx || y0<0 || y0>=bmpy || sizex<=0 || sizey<=0) return;
    379            
    380            if(x+sizex>=width) sizex=width-x;
    381            if(x0+sizex>=bmpx) sizex=bmpx-x0;
    382            if(y+sizey>=height) sizey=height-y;
    383            if(y0+sizey>=bmpy) sizey=bmpy-y0;
    384            
    385          #ifndef HIGHCOLOR
    386            char *scr=(char*)screen, *pic=(char*)bmp+4;
    387            sizexx=sizex;
    388          #else
    389            short *scr=(short*)screen, *pic=(short*)((char*)bmp+4);
    390            sizexx=sizex<<1;
    391          #endif
    392            scr+=width*y+x;
    393            pic+=bmpx*y0 + x0;
    394            if(colormask || (flags&0x40)){
    395              for(j=0; j<sizey; j++, scr+=width-sizex, pic+=bmpx-sizex)
    396                for(i=0; i<sizex; i++, scr++, pic++)
    397                  if(*pic!=
    398          #ifndef HIGHCOLOR
    399            (char)
    400          #else
    401           (short)             
    402          #endif
    403             colormask) *scr=*pic;
    404            }else{
    405              for(j=0; j<sizey; j++, scr+=width, pic+=bmpx)
    406                memcpy(scr,pic,sizexx);
    407            }
    408          }
    409          */
    410          
    411          //void debsave();
    412          //char debarea[10000], *deb=debarea;
    413          ////unsigned int err;
    414          //
    415          //void debsave(){
    416          //  int f;
    417          //  if(deb==debarea) return;
    418          //  f=fopen("0:\\ZBin\\nes\\log",A_ReadWrite+A_BIN+A_Create+A_Append,P_READ+P_WRITE,&err);
    419          //  if (f==-1) return;
    420          //  fwrite32(f,(unsigned char*)debarea,deb-debarea,&err);
    421          //  fclose(f,&err);
    422          //  deb=debarea;
    423          //}
    424          //
    425          //void debug(int num, int val){
    426          //  if(deb-debarea<9800){
    427          //  sprintf(deb,"\n%d = %d",num,val);
    428          //  deb+=strlen(deb);
    429          //  }
    430          //}
    431          
    432          //    void memcpy3(signed char *to, signed char *from, int size){
    433          //      to+=size;
    434          //      from+=size;
    435          //      while(--size>=0){
    436          //        *--to=*--from;
    437          //      }
    438          //    }
    439          //
    440          //    void memcpy4(signed char *to, signed char *from, int size){
    441          //      while(--size>=0){
    442          //        *to++=*from++;
    443          //      }
    444          //    }
    445              
    446          //    void memmove(signed char *to, signed char *from, int size){
    447          //      if(from<to)
    448          //        if(from+size>=to) memcpy3(to,from,size);
    449          //        else memcpy4(to,from,size);
    450          //      else memcpy4(to,from,size);
    451          //    }
    452          
    453          #ifndef DOS
    454          /*
    455              void *memmove(void *to, void *from, int size){
    456                if((char*)from<(char*)to && (char*)from+size>=(char*)to) return memmov(to,from,size); //memcpyrev
    457                return memcpy(to,from,size);
    458              }
    459          */
    460          #endif
    461          
    462          //char *strcpy2(char *to, char *from){
    463          //  char *res=to--;
    464          //  do{ *++to=*from++;
    465          //  }while(*to);
    466          //  return res;
    467          //}
    468          //
    469          //char *strcat2(char *to, char *from){
    470          //  char *res=to--;
    471          //  while(*++to); --to;
    472          //  do{ *++to=*from++;
    473          //  }while(*to);
    474          //  return res;
    475          //}

   Maximum stack usage in bytes:

     Function   CSTACK
     --------   ------
     alltrim        0
     emptystr       0
     fgets          0
     fread32       28
     fwrite32      28
     get3int        0
     getint         0
     getshort       0
     isalth         0
     isval          0
     loadfile      28
     max            0
     min            0
     printf         0
     putint         0
     putshort       0
     savefile      20
     strchrpos      8
     strcmpsize     4
     strdup         0
     todown         0
     toup           0


   Segment part sizes:

     Function/Label Bytes
     -------------- -----
     err               4
     loadfilesize      4
     fread32         104
     fwrite32        104
     min              12
     max              12
     fgets             8
     printf           12
     strdup            4
     savefile         96
     loadfile        196
     toup             92
     todown          100
     isalth           64
     isval            28
     strchrpos        28
     emptystr         52
     alltrim         104
     strcmpsize       68
     getint           48
     get3int          24
     getshort         40
     putint           48
     putshort         32
      Others         100

 
 1 364 bytes in segment CODE
     8 bytes in segment DATA_Z
    12 bytes in segment INITTAB
 
 1 276 bytes of CODE memory (+ 100 bytes shared)
     8 bytes of DATA memory

Errors: none
Warnings: none
