//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION   21/Apr/2011  22:57:52 /
// Copyright 1999-2005 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Cpu mode        =  interwork                                           /
//    Endian          =  little                                              /
//    Stack alignment =  4                                                   /
//    Source file     =  C:\arm\vNes_snd\Siemens.c                           /
//    Command line    =  C:\arm\vNes_snd\Siemens.c -D NDEBUG -lCN            /
//                       C:\arm\vNes_snd\Release\List\ -lA                   /
//                       C:\arm\vNes_snd\Release\List\ -o                    /
//                       C:\arm\vNes_snd\Release\Obj\ -s9 --cpu_mode arm     /
//                       --endian little --cpu ARM926EJ-S --stack_align 4    /
//                       --interwork -e --fpu None --dlib_config             /
//                       "C:\arm2\Embedded Workbench 4.0                     /
//                       Evaluation\ARM\LIB\dl5tpainl8f.h" -I                /
//                       "C:\arm2\Embedded Workbench 4.0                     /
//                       Evaluation\ARM\INC\" --inline_threshold=2           /
//    List file       =  C:\arm\vNes_snd\Release\List\Siemens.s79            /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME Siemens

        RTMODEL "StackAlign4", "USED"
        RTMODEL "__cpu_mode", "__pcs__interwork"
        RTMODEL "__data_model", "absolute"
        RTMODEL "__endian", "little"
        RTMODEL "__rt_version", "6"

        RSEG CSTACK:DATA:NOROOT(2)

        PUBWEAK `?*?DATA_ID`
??DataTable0 EQU 0
??DataTable1 EQU 0
??DataTable2 EQU 0
        MULTWEAK ??DrawScreen??rT
        MULTWEAK ??Killer??rT
        MULTWEAK ??kill_data??rA
        MULTWEAK ??main??rT
        MULTWEAK ??maincsm_onclose??rT
        MULTWEAK ??maincsm_oncreate??rT
        MULTWEAK ??maincsm_onmessage??rT
        MULTWEAK ??method0??rT
        MULTWEAK ??method1??rT
        MULTWEAK ??method2??rT
        MULTWEAK ??method3??rT
        MULTWEAK ??method4??rT
        MULTWEAK ??method5??rT
        MULTWEAK ??method7??rT
        MULTWEAK ??method8??rT
        MULTWEAK ??method9??rT
        MULTWEAK ??onclose??rA
        MULTWEAK ??oncreate??rA
        MULTWEAK ??onexit??rA
        MULTWEAK ??onkey??rA
        MULTWEAK ??onredraw??rA
        MULTWEAK ??onstart??rA
        PUBWEAK ?init?tab?DATA_I
        PUBWEAK ?init?tab?DATA_Z
        PUBLIC C65
        PUBLIC Canvas
        PUBLIC DrawScreen
        FUNCTION DrawScreen,0201H
        LOCFRAME CSTACK, 56, STACK
        PUBLIC EL71
        PUBLIC Killer
        FUNCTION Killer,0603H
        LOCFRAME CSTACK, 4, STACK
        PUBLIC MAINCSM
        PUBLIC S75
        PUBLIC SGOLD2
        PUBLIC gui_methods
        PUBLIC height
        PUBLIC img
        PUBLIC main
        FUNCTION main,0a03H
        LOCFRAME CSTACK, 208, STACK
        PUBLIC maincsm_name_body
        PUBLIC maincsm_onclose
        FUNCTION maincsm_onclose,0603H
        LOCFRAME CSTACK, 4, STACK
        PUBLIC maincsm_oncreate
        FUNCTION maincsm_oncreate,0603H
        LOCFRAME CSTACK, 16, STACK
        PUBLIC maincsm_onmessage
        FUNCTION maincsm_onmessage,0603H
        LOCFRAME CSTACK, 4, STACK
        PUBLIC method0
        FUNCTION method0,0603H
        LOCFRAME CSTACK, 4, STACK
        PUBLIC method1
        FUNCTION method1,0603H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC method2
        FUNCTION method2,0603H
        PUBLIC method3
        FUNCTION method3,0603H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC method4
        FUNCTION method4,0603H
        PUBLIC method5
        FUNCTION method5,0603H
        LOCFRAME CSTACK, 4, STACK
        PUBLIC method7
        FUNCTION method7,0603H
        PUBLIC method8
        FUNCTION method8,0603H
        PUBLIC method9
        FUNCTION method9,0603H
        PUBLIC minus11
        PUBLIC msgerror
        PUBLIC screen
        PUBLIC screensize
        PUBLIC width
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 HUGEDATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, CPSR:32, R13:32
        CFI Resource R14:32, SPSR:32
        CFI VirtualResource ?RET:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon0
        
        
        CFI Common cfiCommon1 Using cfiNames0
        CFI CodeAlign 4
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon1
        
kill_data           SYMBOL "kill_data"
onclose             SYMBOL "onclose"
oncreate            SYMBOL "oncreate"
onexit              SYMBOL "onexit"
onkey               SYMBOL "onkey"
onredraw            SYMBOL "onredraw"
onstart             SYMBOL "onstart"
DrawScreen          SYMBOL "DrawScreen"
??DrawScreen??rT    SYMBOL "??rT", DrawScreen
Killer              SYMBOL "Killer"
??Killer??rT        SYMBOL "??rT", Killer
??kill_data??rA     SYMBOL "??rA", kill_data
main                SYMBOL "main"
??main??rT          SYMBOL "??rT", main
maincsm_onclose     SYMBOL "maincsm_onclose"
??maincsm_onclose??rT SYMBOL "??rT", maincsm_onclose
maincsm_oncreate    SYMBOL "maincsm_oncreate"
??maincsm_oncreate??rT SYMBOL "??rT", maincsm_oncreate
maincsm_onmessage   SYMBOL "maincsm_onmessage"
??maincsm_onmessage??rT SYMBOL "??rT", maincsm_onmessage
method0             SYMBOL "method0"
??method0??rT       SYMBOL "??rT", method0
method1             SYMBOL "method1"
??method1??rT       SYMBOL "??rT", method1
method2             SYMBOL "method2"
??method2??rT       SYMBOL "??rT", method2
method3             SYMBOL "method3"
??method3??rT       SYMBOL "??rT", method3
method4             SYMBOL "method4"
??method4??rT       SYMBOL "??rT", method4
method5             SYMBOL "method5"
??method5??rT       SYMBOL "??rT", method5
method7             SYMBOL "method7"
??method7??rT       SYMBOL "??rT", method7
method8             SYMBOL "method8"
??method8??rT       SYMBOL "??rT", method8
method9             SYMBOL "method9"
??method9??rT       SYMBOL "??rT", method9
??onclose??rA       SYMBOL "??rA", onclose
??oncreate??rA      SYMBOL "??rA", oncreate
??onexit??rA        SYMBOL "??rA", onexit
??onkey??rA         SYMBOL "??rA", onkey
??onredraw??rA      SYMBOL "??rA", onredraw
??onstart??rA       SYMBOL "??rA", onstart

        EXTERN ELF_BEGIN
        EXTERN Title
        EXTERN errors
        EXTERN kill_data
        FUNCTION kill_data,0202H
        EXTERN onclose
        FUNCTION onclose,0200H
        EXTERN oncreate
        FUNCTION oncreate,0200H
        EXTERN onexit
        FUNCTION onexit,0200H
        EXTERN onkey
        FUNCTION onkey,0202H
        EXTERN onredraw
        FUNCTION onredraw,0200H
        EXTERN onstart
        FUNCTION onstart,0202H


        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI NoFunction
        THUMB
??DrawScreen??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock0
        REQUIRE DrawScreen
// C:\arm\vNes_snd\Siemens.c
//    1 // Siemens.c 0.5 cbn(c) SGOLD 1,2,3 вместе! :) +FreeRam
//    2 // http://cbn.narod.ru  e-mail: cbn@yandex.ru
//    3 // Интерфейс мобилы для IAR
//    4 // Здесь ничего не трогаем! (если не уверены)
//    5 // #define NEWSGOLD //ДОЛЖНО БЫТЬ ЗАДАНО ВСЕГДА!
//    6 // т.к. тип мобилы определяется автоматически
//    7 // Если экран в приложении объявлен как short *screen, то нужно указать и #define HIGHCOLOR
//    8 // Внешние функции вызываются при:
//    9 
//   10 //#define DLL //для обработки elf2dll
//   11 
//   12 #include "c:\arm\inc\Swilib.h"
//   13 
//   14 extern int onstart(char *exename, char *fname); // Старте приложения. Возвращает 0 или 1 для выхода.
//   15 extern void oncreate(); // Создании окна
//   16 extern void onclose(); // Закрытии окна
//   17 extern void onexit(); // Выходе
//   18 extern void onredraw(); // Перерисовке экрана
//   19 extern int onkey(unsigned char keycode, int pressed); // Нажатии клавиши. Возвращает 0 или 1 для выхода.
//   20 extern char *Title;
//   21 extern const char *errors[]; //строки ошибок для кодов возврата
//   22 char *msgerror=0; //текст ошибки при выходе
//   23 
//   24 //#define RAMSCREEN
//   25 //экран в памяти
//   26 //#define FREERAM
//   27 // FREERAM задает нестандартное использ. памяти
//   28 #ifdef FREERAM
//   29   extern int isFreeRam(char *exename, char *fname); //1=использ.FreeRam, 0=нет
//   30   extern void FreeRamInit(char *exename);
//   31   extern void FreeRamExit();
//   32   unsigned char USERAM=0; //использ. ли FreeRam
//   33 #endif
//   34 //#define HIGHCOLOR
//   35 //#include "swilib.h"
//   36 //#define NEWSGOLD
//   37 // HIGHCOLOR задает 16 битный режим (RGB 565 по 2 байта на точку экрана screen)
//   38 // или 8 битный режим (RGB 232 по 1 байту на точку)
//   39 #ifdef HIGHCOLOR
//   40   #define scrtype short
//   41   #define scrtypedat 8
//   42 #else
//   43   #define scrtype char
//   44   #define scrtypedat 5
//   45 #endif
//   46 
//   47 unsigned char SGOLD2=0, C65=0, S75=0, EL71=0;
//   48 #ifdef DEBUG
//   49   unsigned char debug=0;
//   50 #endif
//   51 int width=132, height=176, screensize;
//   52 
//   53 scrtype *screen=0;//[width*height];
//   54 unsigned char img[12]={132,176,scrtypedat,0,0,0};
//   55 //IMGHDR img = {132, 176, scrtypedat,0,0};
//   56 
//   57 // Ниже читать уже не надо! :)
//   58 typedef struct
//   59 {
//   60   GUI gui;
//   61   WSHDR *ws1;
//   62   WSHDR *ws2;
//   63   int i1;
//   64 }MAIN_GUI;
//   65 
//   66 typedef struct
//   67 {
//   68   CSM_RAM csm;
//   69   int gui_id;
//   70 }MAIN_CSM;
//   71 
//   72 typedef struct{
//   73 //#ifdef NEWSGOLD
//   74 //  int pid_from;
//   75 //  int msg;
//   76 //#else
//   77   short pid_from;
//   78   short msg;
//   79 //#endif
//   80   int submess;
//   81   void *data0;
//   82   void *data1;
//   83 } GBSS_MSG;
//   84 
//   85 void UpdateCSMname();

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock1 Using cfiCommon1
        CFI Function DrawScreen
        ARM
//   86 void DrawScreen(){
DrawScreen:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//   87 #ifndef RAMSCREEN
//   88   RECT rc;  DRWOBJ drwobj;
//   89   StoreXYWHtoRECT(&rc,0,EL71?24:0,width,height);
        LDR      R4,??DataTable4  ;; Canvas
        SUB      SP,SP,#+44
        CFI CFA R13+52
        LDRB     R0,[R4, #+43]
        MOV      R1,#+0
        CMP      R0,#+0
        LDR      R0,[R4, #+28]
        MOVNE    R2,#+24
        PUSH     {R0}
        CFI CFA R13+56
        LDR      R3,[R4, #+24]
        MOVEQ    R2,#+0
        ADD      R0,SP,#+4
        SWI      +307
//   90   SetPropTo_Obj5(&drwobj,&rc,0,(IMGHDR*)&img);
        ADD      R3,R4,#+8
        MOV      R2,#+0
        ADD      R1,SP,#+4
        ADD      R0,SP,#+12
        SWI      +337
//   91   SetColor(&drwobj,GetPaletteAdrByColorIndex(0),GetPaletteAdrByColorIndex(1));
        MOV      R0,#+1
        SWI      +302
        MOV      R4,R0
        MOV      R0,#+0
        SWI      +302
        MOV      R1,R0
        MOV      R2,R4
        ADD      R0,SP,#+12
        SWI      +331
//   92   DrawObject(&drwobj);
        ADD      R0,SP,#+12
        SWI      +298
//   93 #endif  
//   94 }
        ADD      SP,SP,#+48
        CFI CFA R13+8
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock1

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock2 Using cfiCommon0
        CFI NoFunction
        THUMB
??method0??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock2
        REQUIRE method0
//   95 
//   96 //FAKES delete!!!
//   97 //void *memset(void *mem, int val, int size){ return 0;}
//   98 //void *memcpy(void *to, const void *from, int size){return 0;}
//   99 
//  100 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock3 Using cfiCommon1
        CFI Function method0
        ARM
//  101 void method0(MAIN_GUI *data){ onredraw(); DrawScreen();}
method0:
        PUSH     {LR}
        CFI ?RET Frame(CFA, -4)
        CFI CFA R13+4
        _BLF     onredraw,??onredraw??rA
        POP      {LR}             ;; Pop
        CFI ?RET R14
        CFI CFA R13+0
        B        DrawScreen       ;; tailcall
        CFI EndBlock cfiBlock3

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock4 Using cfiCommon0
        CFI NoFunction
        THUMB
??method1??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock4
        REQUIRE method1

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock5 Using cfiCommon1
        CFI Function method1
        ARM
//  102 void method1(MAIN_GUI *data, void *(*malloc_adr)(int)){  oncreate(); data->gui.state=1;}
method1:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
        MOV      R4,R0
        _BLF     oncreate,??oncreate??rA
        MOV      R0,#+1
        STRB     R0,[R4, #+12]
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock5

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock6 Using cfiCommon0
        CFI NoFunction
        THUMB
??method2??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock6
        REQUIRE method2

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock7 Using cfiCommon1
        CFI Function method2
        ARM
//  103 void method2(MAIN_GUI *data, void (*mfree_adr)(void *)){  data->gui.state=0;}
method2:
        MOV      R1,#+0
        STRB     R1,[R0, #+12]
        BX       LR               ;; return
        CFI EndBlock cfiBlock7

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock8 Using cfiCommon0
        CFI NoFunction
        THUMB
??method3??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock8
        REQUIRE method3

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock9 Using cfiCommon1
        CFI Function method3
        ARM
//  104 void method3(MAIN_GUI *data, void *(*malloc_adr)(int), void (*mfree_adr)(void *)){ 
method3:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
        MOV      R4,R0
//  105 #ifndef NOIDLETMR  
//  106   DisableIDLETMR();// это чтобы эльф не выкл. через 2 минуты
        SWI      +383
//  107 #endif  
//  108   data->gui.state=2;
        MOV      R0,#+2
        STRB     R0,[R4, #+12]
//  109 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock9

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock10 Using cfiCommon0
        CFI NoFunction
        THUMB
??method4??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock10
        REQUIRE method4

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock11 Using cfiCommon1
        CFI Function method4
        ARM
//  110 void method4(MAIN_GUI *data, void (*mfree_adr)(void *)){ if (data->gui.state!=2) return; data->gui.state=1;}
method4:
        LDRB     R1,[R0, #+12]
        CMP      R1,#+2
        MOVEQ    R1,#+1
        STRBEQ   R1,[R0, #+12]
        BX       LR               ;; return
        CFI EndBlock cfiBlock11

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock12 Using cfiCommon0
        CFI NoFunction
        THUMB
??method5??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock12
        REQUIRE method5

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock13 Using cfiCommon1
        CFI Function method5
        ARM
//  111 int method5(MAIN_GUI *data, GUI_MSG *msg){
//  112   if(SGOLD2) return onkey(msg->gbsmsg->submess, msg->gbsmsg->msg);
method5:
        LDR      R0,[R1, #+4]
        LDRSH    R1,[R0, #+2]
        LDR      R0,[R0, #+4]
        AND      R0,R0,#0xFF
//  113   return onkey(((GBSS_MSG*)msg->gbsmsg)->submess, ((GBSS_MSG*)msg->gbsmsg)->msg);}
        _BF      onkey,??onkey??rA  ;; tailcall
        CFI EndBlock cfiBlock13

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock14 Using cfiCommon0
        CFI NoFunction
        THUMB
??method7??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock14
        REQUIRE method7

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock15 Using cfiCommon1
        CFI Function method7
        ARM
//  114 void method7(MAIN_GUI *data, void (*mfree_adr)(void *)){}//  mfree_adr(data);
method7:
        BX       LR               ;; return
        CFI EndBlock cfiBlock15

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock16 Using cfiCommon0
        CFI NoFunction
        THUMB
??method8??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock16
        REQUIRE method8

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock17 Using cfiCommon1
        CFI Function method8
        ARM
//  115 int method8(void){return(0);} // Пустая ф-я
method8:
        MOV      R0,#+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock17

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock18 Using cfiCommon0
        CFI NoFunction
        THUMB
??method9??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock18
        REQUIRE method9

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock19 Using cfiCommon1
        CFI Function method9
        ARM
//  116 int method9(void){return(0);} // Пустая ф-я
method9:
        MOV      R0,#+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock19

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock20 Using cfiCommon0
        CFI NoFunction
        THUMB
??maincsm_oncreate??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock20
        REQUIRE maincsm_oncreate

        RSEG DATA_I:DATA:SORT:NOROOT(2)
//  117 
//  118 const void * const gui_methods[11]={
//  119   (void *)method0,	//Redraw
//  120   (void *)method1,	//Create
//  121   (void *)method2,	//Close
//  122   (void *)method3,	//Focus
//  123   (void *)method4,	//Unfocus
//  124   (void *)method5,	//OnKey
//  125   0,
//  126   (void *)method7,	//Destroy
//  127   (void *)method8,
//  128   (void *)method9,
//  129   0
//  130 };
//  131 
//  132 RECT Canvas={0,0,131,175};
Canvas:
        DS8 8
        REQUIRE `?<Initializer for Canvas>`
img:
        DS8 12
        REQUIRE `?<Initializer for img>`
msgerror:
        DS8 4
        REQUIRE `?<Initializer for msgerror>`
width:
        DS8 4
        REQUIRE `?<Initializer for width>`
height:
        DS8 4
        REQUIRE `?<Initializer for height>`
screensize:
        DS8 4
        REQUIRE `?<Initializer for screensize>`
screen:
        DS8 4
        REQUIRE `?<Initializer for screen>`
SGOLD2:
        DS8 1
        REQUIRE `?<Initializer for SGOLD2>`
C65:
        DS8 1
        REQUIRE `?<Initializer for C65>`
S75:
        DS8 1
        REQUIRE `?<Initializer for S75>`
EL71:
        DS8 1
        REQUIRE `?<Initializer for EL71>`
//  133 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock21 Using cfiCommon1
        CFI Function maincsm_oncreate
        ARM
//  134 void maincsm_oncreate(CSM_RAM *data)
//  135 {
maincsm_oncreate:
        PUSH     {R4-R6,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
        MOV      R4,R0
//  136   MAIN_GUI *main_gui=(MAIN_GUI *)malloc(sizeof(MAIN_GUI));
        MOV      R0,#+60
        SWI      +20
        MOV      R5,R0
//  137   MAIN_CSM*csm=(MAIN_CSM*)data;
//  138   zeromem(main_gui,sizeof(MAIN_GUI));
        MOV      R1,#+60
        SWI      +285
//  139  // ustk=malloc(STKSZ); // Выделяем память
//  140  // info_ws=AllocWS(512);
//  141   if(EL71){ Canvas.x2=239; Canvas.y2=319;}//added
        LDR      R0,??maincsm_oncreate_0  ;; Canvas
        LDRB     R1,[R0, #+43]
        CMP      R1,#+0
        BEQ      ??maincsm_oncreate_1
        MOV      R1,#+239
        STRH     R1,[R0, #+4]
        ADD      R1,R1,#+80
        STRH     R1,[R0, #+6]
//  142   
//  143   main_gui->gui.canvas=(RECT*)((void *)(&Canvas));
//  144   main_gui->gui.flag30=2;
//  145   main_gui->gui.methods=(void *)gui_methods;
??maincsm_oncreate_1:
        LDR      R6,??DataTable3  ;; `?<Constant "0:\\\\ZBin\\\\SGOLD">`
        STR      R0,[R5, #+0]
        MOV      R0,#+2
        STR      R0,[R5, #+44]
        ADD      R0,R6,#+44
        STR      R0,[R5, #+4]
//  146   main_gui->gui.item_ll.data_mfree=(void (*)(void *))mfree_adr();
        SWI      +32789
        STR      R0,[R5, #+28]
//  147   csm->csm.state=0;
        MOV      R0,#+0
        STR      R0,[R4, #+16]
//  148   csm->csm.unk1=0;
        STR      R0,[R4, #+20]
//  149   csm->gui_id=CreateGUI(main_gui);
        MOV      R0,R5
        SWI      +311
        STR      R0,[R4, #+40]
//  150   UpdateCSMname();
        LDR      R0,??maincsm_oncreate_0+0x4  ;; Title
        LDR      R1,[R0, #+0]
        ADD      R0,R6,#+112
        SWI      +292
//  151 }
        POP      {R4-R6,PC}       ;; return
        DATA
??maincsm_oncreate_0:
        DC32     Canvas
        DC32     Title
        CFI EndBlock cfiBlock21

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock22 Using cfiCommon0
        CFI NoFunction
        THUMB
??Killer??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock22
        REQUIRE Killer
//  152 
//  153 //#ifdef CPP
//  154 //#define externC extern "C"
//  155 //#else
//  156 //#define externC extern
//  157 //#endif
//  158 extern void *ELF_BEGIN;
//  159 extern void kill_data(void *p, void (*func_p)(void *));
//  160 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock23 Using cfiCommon1
        CFI Function Killer
        ARM
//  161 void Killer(void){
Killer:
        PUSH     {LR}
        CFI ?RET Frame(CFA, -4)
        CFI CFA R13+4
//  162   onexit();
        _BLF     onexit,??onexit??rA
        LDR      R0,??Killer_0    ;; Canvas + 36
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ      ??Killer_1
//  163 #ifdef RAMSCREEN
//  164   if(C65)
//  165 #endif
//  166   if(screen) mfree(screen); //screen=0; //moved
        SWI      +21
//  167 #ifdef FREERAM
//  168   ////if(USERAM) 
//  169     FreeRamExit();
//  170 #endif    
//  171 #ifndef DLL    
//  172   kill_data(&ELF_BEGIN,(void (*)(void *))mfree_adr());
??Killer_1:
        SWI      +32789
        MOV      R1,R0
        LDR      R0,??Killer_0+0x4  ;; ELF_BEGIN
        POP      {LR}             ;; Pop
        CFI ?RET R14
        CFI CFA R13+0
        _BF      kill_data,??kill_data??rA  ;; tailcall
        DATA
??Killer_0:
        DC32     Canvas + 36
        DC32     ELF_BEGIN
        CFI EndBlock cfiBlock23
//  173 #endif  
//  174 //  ((void (*)(void *))(mfree_adr()))(&ELF_BEGIN);
//  175 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock24 Using cfiCommon0
        CFI NoFunction
        THUMB
??maincsm_onclose??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock24
        REQUIRE maincsm_onclose
//  176 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock25 Using cfiCommon1
        CFI Function maincsm_onclose
        ARM
//  177 void maincsm_onclose(CSM_RAM *csm)
//  178 {
maincsm_onclose:
        PUSH     {LR}
        CFI ?RET Frame(CFA, -4)
        CFI CFA R13+4
//  179   onclose();
        _BLF     onclose,??onclose??rA
//  180 #ifdef DLL  
//  181   Killer();
//  182 #else  
//  183   SUBPROC((void *)Killer);
        LDR      R0,??DataTable5  ;; Killer
        SWI      +369
//  184 #endif  
//  185 }
        POP      {PC}             ;; return
        CFI EndBlock cfiBlock25

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock26 Using cfiCommon0
        CFI NoFunction
        THUMB
??maincsm_onmessage??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock26
        REQUIRE maincsm_onmessage
//  186 
//  187 //int maincsm_onmessage(CSM_RAM *data, GBS_MSG *msg){  
//  188 //  MAIN_CSM *csm=(MAIN_CSM*)data;
//  189 //  if ((msg->msg==MSG_GUI_DESTROYED)&&((int)msg->data0==csm->gui_id))
//  190 //     csm->csm.state=-3; 
//  191 //  return(1);
//  192 //}
//  193 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock27 Using cfiCommon1
        CFI Function maincsm_onmessage
        ARM
//  194 int maincsm_onmessage(CSM_RAM *data, GBS_MSG *ms){  
maincsm_onmessage:
        SUB      SP,SP,#+4
        CFI CFA R13+4
//  195   MAIN_CSM *csm=(MAIN_CSM*)data;
//  196   if(SGOLD2){
        LDR      R2,[R1, #+8]
        LDRSH    R1,[R1, #+2]
        MVN      R3,#+2
//  197     if ((ms->msg==MSG_GUI_DESTROYED)&&((int)ms->data0==csm->gui_id))
//  198      csm->csm.state=-3; 
//  199   }else{
//  200     GBSS_MSG *msg=(GBSS_MSG *)ms;
//  201     if ((msg->msg==0x98)&&((int)msg->data0==csm->gui_id))
        CMP      R1,#+152
        LDREQ    R1,[R0, #+40]
        CMPEQ    R2,R1
//  202      csm->csm.state=-3; 
        STREQ    R3,[R0, #+16]
//  203   }
//  204   return(1);
        POP      {R1}
        CFI CFA R13+0
        MOV      R0,#+1
        BX       LR               ;; return
        CFI EndBlock cfiBlock27
//  205 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock28 Using cfiCommon0
        CFI NoFunction
        THUMB
??main??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock28
        REQUIRE main
//  206 
//  207 
//  208 const int minus11=-11;

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//  209 unsigned short maincsm_name_body[140];
maincsm_name_body:
        DS8 280

        RSEG DATA_C:CONST:SORT:NOROOT(2)
`?<Constant "0:\\\\ZBin\\\\SGOLD">`:
        DATA
        DC8 "0:\\ZBin\\SGOLD"
        DC8 0, 0
        DC8 "NoMemory"
        DC8 0, 0, 0
        DC8 "%s \316\370\350\341\352\340 %d"
        DC8 0, 0, 0
gui_methods:
        DC32 method0, method1, method2, method3, method4, method5, 0H, method7
        DC32 method8, method9, 0H
//  210 
//  211 const struct
//  212 {
//  213   CSM_DESC maincsm;
//  214   WSHDR maincsm_name;
//  215 }MAINCSM =
MAINCSM:
        DC32 maincsm_onmessage, maincsm_oncreate, maincsm_onclose, 44, 1
        DC32 minus11, maincsm_name_body, 55AACCCCH, 3333AA55H, 0
        DC16 139
        DC8 0, 0

        RSEG DATA_C:CONST:SORT:NOROOT(2)
minus11:
        DATA
        DC32 -11
//  216 {
//  217   {
//  218   maincsm_onmessage,
//  219   maincsm_oncreate,
//  220 #ifdef NEWSGOLD
//  221   0,
//  222   0,
//  223   0,
//  224   0,
//  225 #endif  
//  226   maincsm_onclose,
//  227   sizeof(MAIN_CSM),
//  228   1,
//  229   &minus11
//  230   },
//  231   {
//  232     maincsm_name_body,
//  233     NAMECSM_MAGIC1,
//  234     NAMECSM_MAGIC2,
//  235     0x0,
//  236     139
//  237   }
//  238 };
//  239 
//  240 inline void UpdateCSMname(){
//  241   wsprintf((WSHDR *)&MAINCSM.maincsm_name,Title);
//  242 }
//  243 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock29 Using cfiCommon1
        CFI Function main
        ARM
//  244 int main(char *exename, char *fname){
main:
        PUSH     {R4-R9,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R9 Frame(CFA, -8)
        CFI R8 Frame(CFA, -12)
        CFI R7 Frame(CFA, -16)
        CFI R6 Frame(CFA, -20)
        CFI R5 Frame(CFA, -24)
        CFI R4 Frame(CFA, -28)
        CFI CFA R13+28
//  245   char dummy[sizeof(MAIN_CSM)];
//  246   char *s;
//  247   int err;
//  248   int f;
//  249 #ifdef DEBUG
//  250   if((f=fopen("0:\\ZBin\\DEBUG",A_ReadOnly+A_BIN,P_READ,&err))!=-1){
//  251     debug=1; fclose(f,&err);
//  252   }
//  253 #endif  
//  254   if((f=fopen("0:\\ZBin\\SGOLD",A_ReadOnly+A_BIN,P_READ,&err))!=-1){
        LDR      R6,??DataTable3  ;; `?<Constant "0:\\\\ZBin\\\\SGOLD">`
        LDR      R7,??DataTable4  ;; Canvas
        SUB      SP,SP,#+180
        CFI CFA R13+208
        MOV      R4,R0
        MOV      R5,R1
        MOV      R3,SP
        MOV      R2,#+128
        MOV      R1,#+32768
        MOV      R0,R6
        SWI      +10
        CMN      R0,#+1
        BEQ      ??main_0
//  255     fclose(f,&err);
        MOV      R1,SP
        SWI      +13
        B        ??main_1
//  256   }else{
//  257   if((f=ScreenH())<176) C65=1; //C65
??main_0:
        SWI      +33161
        MOV      R8,#+1
        CMP      R0,#+176
        STRBLT   R8,[R7, #+41]
        BLT      ??main_1
//  258   else if(f>176){ EL71=SGOLD2=1; //EL71
        CMP      R0,#+177
        BLT      ??main_2
        STRB     R8,[R7, #+40]
        STRB     R8,[R7, #+43]
//  259     *(short*)img=width=240; *(short*)(img+2)=height=296;
        MOV      R0,#+240
        STR      R0,[R7, #+24]
        STRH     R0,[R7, #+8]
        MOV      R0,#+296
        STR      R0,[R7, #+28]
        STRH     R0,[R7, #+10]
//  260     img[4]=scrtypedat;
        MOV      R0,#+5
        STRB     R0,[R7, #+12]
        B        ??main_3
//  261   }else{
//  262     if(s=(char*)malloc(2500000)){
??main_2:
        LDR      R0,??main_4      ;; 0x2625a0
        SWI      +20
        CMP      R0,#+0
        BEQ      ??main_1
//  263       mfree(s); S75=SGOLD2=1; //S75 
        SWI      +21
        STRB     R8,[R7, #+40]
        STRB     R8,[R7, #+42]
//  264     }
//  265   }
//  266   }
//  267 #ifdef FREERAM
//  268   if((f=fopen("0:\\ZBin\\NEWSGOLD",A_ReadOnly+A_BIN,P_READ,&err))!=-1){
//  269     fclose(f,&err);
//  270   }else
//  271     if(USERAM=isFreeRam(exename,fname)) FreeRamInit(exename);//!SGOLD вместо EL
//  272 #endif  
//  273 #ifdef RAMSCREEN
//  274   if(C65){
//  275 #endif
//  276   if(!(*(long*)(img+(EL71?8:4))=(long)(screen=(scrtype*)malloc(screensize=width*height*sizeof(scrtype))))){
??main_1:
        LDRB     R0,[R7, #+43]
        CMP      R0,#+0
        BEQ      ??main_5
??main_3:
        MOV      R8,#+8
        B        ??main_6
??main_5:
        MOV      R8,#+4
??main_6:
        LDR      R0,[R7, #+24]
        LDR      R1,[R7, #+28]
        LDR      R9,??DataTable5  ;; Killer
        MUL      R0,R1,R0
        STR      R0,[R7, #+32]
        SWI      +20
        STR      R0,[R7, #+36]
        ADD      R1,R8,R7
        STR      R0,[R1, #+8]
        CMP      R0,#+0
        BNE      ??main_7
//  277     ShowMSG(1,(int)"NoMemory");
        ADD      R1,R6,#+16
        B        ??main_8
//  278    #ifdef DLL  
//  279      Killer();
//  280    #else  
//  281      SUBPROC((void *)Killer);
//  282    #endif  
//  283     return 0;
//  284   }
//  285 #ifdef RAMSCREEN
//  286   }else screen=RamScreenBuffer()+(EL71?(24*240):0);
//  287 #endif  
//  288   memset(screen,0,screensize);
??main_7:
        LDR      R2,[R7, #+32]
        MOV      R1,#+0
        SWI      +187
//  289   if(f=onstart(exename,fname)){
        MOV      R1,R5
        MOV      R0,R4
        _BLF     onstart,??onstart??rA
        CMP      R0,#+0
        BEQ      ??main_9
//  290     char buf[128];
//  291     sprintf(buf,"%s Ошибка %d", (msgerror)?msgerror:errors[f], f);
        LDR      R2,[R7, #+20]
        MOV      R3,R0
        CMP      R2,#+0
        LDREQ    R1,??main_4+0x4  ;; errors
        LDREQ    R2,[R1, +R0, LSL #+2]
        ADD      R1,R6,#+28
        ADD      R0,SP,#+8
        SWI      +22
//  292     ShowMSG(1,(int)buf);
        ADD      R1,SP,#+8
??main_8:
        MOV      R0,#+1
        SWI      +328
//  293 //#ifdef FREERAM
//  294 //    if(USERAM) FreeRamExit();
//  295 //#endif    
//  296   #ifdef DLL  
//  297   Killer();
//  298   #else  
//  299   SUBPROC((void *)Killer);
        MOV      R0,R9
        SWI      +369
        MOV      R0,#+0
        ADD      SP,SP,#+180
        CFI CFA R13+28
        POP      {R4-R9,PC}
        CFI CFA R13+208
//  300   #endif  
//  301   }else{
//  302     if(!SGOLD2) memcpy(((char*)&MAINCSM.maincsm)+8,((char*)&MAINCSM.maincsm)+24,sizeof(CSM_DESC)-24);
??main_9:
        LDRB     R0,[R7, #+40]
        CMP      R0,#+0
        BNE      ??main_10
        MOV      R2,#+0
        ADD      R1,R6,#+112
        ADD      R0,R6,#+96
        SWI      +286
//  303     CreateCSM(&MAINCSM.maincsm,dummy,0);
??main_10:
        MOV      R2,#+0
        ADD      R1,SP,#+136
        ADD      R0,R6,#+88
        SWI      +263
//  304   }
//  305 
//  306     
//  307   return 0;
        MOV      R0,#+0
        ADD      SP,SP,#+180
        CFI CFA R13+28
        POP      {R4-R9,PC}       ;; return
        DATA
??main_4:
        DC32     0x2625a0
        DC32     errors
        CFI EndBlock cfiBlock29
//  308 }

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable3:
        DC32     `?<Constant "0:\\\\ZBin\\\\SGOLD">`

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable4:
        DC32     Canvas

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable5:
        DC32     Killer

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock30 Using cfiCommon1
        CFI NoFunction
        ARM
??onredraw??rA:
        LDR      R12,??Subroutine15_0  ;; onredraw
        BX       R12
        DATA
??Subroutine15_0:
        DC32     onredraw
        CFI EndBlock cfiBlock30

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock31 Using cfiCommon1
        CFI NoFunction
        ARM
??oncreate??rA:
        LDR      R12,??Subroutine16_0  ;; oncreate
        BX       R12
        DATA
??Subroutine16_0:
        DC32     oncreate
        CFI EndBlock cfiBlock31

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock32 Using cfiCommon1
        CFI NoFunction
        ARM
??onkey??rA:
        LDR      R12,??Subroutine17_0  ;; onkey
        BX       R12
        DATA
??Subroutine17_0:
        DC32     onkey
        CFI EndBlock cfiBlock32

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock33 Using cfiCommon1
        CFI NoFunction
        ARM
??onexit??rA:
        LDR      R12,??Subroutine18_0  ;; onexit
        BX       R12
        DATA
??Subroutine18_0:
        DC32     onexit
        CFI EndBlock cfiBlock33

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock34 Using cfiCommon1
        CFI NoFunction
        ARM
??kill_data??rA:
        LDR      R12,??Subroutine19_0  ;; kill_data
        BX       R12
        DATA
??Subroutine19_0:
        DC32     kill_data
        CFI EndBlock cfiBlock34

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock35 Using cfiCommon1
        CFI NoFunction
        ARM
??onclose??rA:
        LDR      R12,??Subroutine20_0  ;; onclose
        BX       R12
        DATA
??Subroutine20_0:
        DC32     onclose
        CFI EndBlock cfiBlock35

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock36 Using cfiCommon1
        CFI NoFunction
        ARM
??onstart??rA:
        LDR      R12,??Subroutine21_0  ;; onstart
        BX       R12
        DATA
??Subroutine21_0:
        DC32     onstart
        CFI EndBlock cfiBlock36

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for Canvas>`:
        DATA
        DC16 0, 0, 131, 175
`?<Initializer for img>`:
        DC8 132, 176, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0
`?<Initializer for msgerror>`:
        DC32 0H
`?<Initializer for width>`:
        DC32 132
`?<Initializer for height>`:
        DC32 176
`?<Initializer for screensize>`:
        DC8 0, 0, 0, 0
`?<Initializer for screen>`:
        DC32 0H
`?<Initializer for SGOLD2>`:
        DC8 0
`?<Initializer for C65>`:
        DC8 0
`?<Initializer for S75>`:
        DC8 0
`?<Initializer for EL71>`:
        DC8 0

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_Z:
        DCD      sfe(DATA_Z) - sfb(DATA_Z), sfb(DATA_Z), sfb(DATA_Z)

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?*?DATA_ID`:

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_I:
        DCD      sfe(DATA_I) - sfb(DATA_I), sfb(DATA_I), sfb(DATA_ID)

        END
//  309                                  
// 
// 1 080 bytes in segment CODE
//   136 bytes in segment DATA_C
//    44 bytes in segment DATA_I
//    44 bytes in segment DATA_ID
//   280 bytes in segment DATA_Z
//    24 bytes in segment INITTAB
// 
// 936 bytes of CODE  memory (+ 168 bytes shared)
// 180 bytes of CONST memory
// 324 bytes of DATA  memory
//
//Errors: none
//Warnings: 2
