
;(с) ValeraVi (http://www.vi-soft.com.ua)
;Пример текста патча (.vkp файл) для программы V_KLay 2.7.2+
;Здесь в файле может быть любой текст в виде комментариев.
;Строка комментариев должна начинаться с точки с запятой ';',
; а также допускаются комментарии как в C++ (/*...*/ и //...)
;
;Потом итет строка задающая корректор адреса (HEX) - число которое
;   будет прибавляться (отниматься) ко всем адресам. Думаю будет полезно,
;   если лень править все адреса.
;Корректор адреса вседга должен быть со знаком (+ или -) - это его
;   идентификатор.

-0x34a68 ;это комментарий его можно писать здесь.

;Корректор адреса может встречаться в тесте патча много раз, например:

+0x345			;ко всем последующим адресам будет прибавляться число 0x345
045df2: 4567 e123	;вот к этому оно будет прибавляться
+0			;ко всем последующим адресам будет прибавляться число 0,
			; т.е. сброс действия предыдущего корректора.
;!!! Значение текущего корректора НЕ прибавляется к предыдущему!
;    Оно просто замещает предыдущее!

;Описания данных патча делаются в формате:
;  _Адрес_: [_старые_данные_] _новые_данные_
; квадратные скобки - означают, что старые данные (т.е. те которые
; сейчас есть во флеше) указывать не обязательно. Но если их не указать
; отменить патч будет невозможно.
;Перед адресом могут быть колько угодно пробелов.
;Сразу после адреса должно идти двоеточие ':'
;Между двоеточием, старыми данными и новыми должен быть как минимум один
;символ пробела или табуляции. После новых данных должна сразу заканчиваться
;строка, либо через пробел - комментарии.
;
;пример одного байта данных:

3e0002: ee 55 ;здесь можно писать комментарии

;пример нескольких байтов данных: на каждый байт - по 2 символа
; байты пишутся без пробелов. Кол-во байтов старых должно равняться
; кол-ву новых байт.
3e0008: 445566 778899

;пример нескольких байтов без старых данных:
3e0004: ffddee33 ; здесь вот нету старых данных






;Так же есть дополнительные возможности представления данных в теле патча:

;Двоичное число.
;модификатор: 0n, пример:
123456: 4546 0n1011001001001110  ; можно юзать для задания всяких там масок и т.п.
;    Кол-во байтов, занимаемое числом равно [число символов после 0n] / 8 c округлением в большую сторону.
;    Максимальное число 2^32 (DWORD)

;Знакове (беззнаковое) десятичное целое число (integer).
;модификатор: 0i
; пример 1:
000000: 01               0i255                   ; 3-х значное число => занимает 1 байт
000010: 0102             0i65535                 ; 5-ти значное число => 2 байта (WORD)
000030: 010203           0i16777215              ; 8-ми значное число => 3 байта
000040: 01020304         0i4294967295            ;10-ти значное число => 4 байта (DWORD)
000050: 0102030405       0i1099511627775         ;13-ти значное число => 5 байтов
000060: 010203040506     0i281474976710655       ;15-ти значное число => 6 байтов
000070: 01020304050607   0i72057594037927935     ;17-ти значное число => 7 байтов
000090: 0102030405060708 0i18446744073709551615  ;20-ти значное число => 8 байтов (UINT64)
;пример 2:
000000: 01 0i-005
000010: 0102 0i00010
000020: 0i10112 0i00003
000030: 01020304 0i0000000050
000040: 0001020000 56,0i00090,78AD
000040: 01020000 0i00100,123D
;     Отделяйте десятичное число разделителями групп данных (,) - это поможет предотвратить будущие
;  ошибки, т.к. если за десятичным числом будудут иди 16-ричные данные с десятичными цифрами, то такие
;  цифры могут быть ошибочно учтены в определении кол-ва байт занимаемых десятичным числом.
;     Как видно из примеров, кол-во байтов занимаемых десятичным числом определяется кол-вом знаков
;  в десятичном числе (подробнее смотрите пример 1). Если число помещается в меньшее кол-во знаков
;  (разрядов) необходимо дописать столько лидирующий нулей сколько нужно (пример 2). Колво знаков (разрядов)
;  в десятичном числе должно обязательно быть одним из указанных в примере 1.
;     Перед деятичным числом (после идентификатора 0i) можно указывать знак числа, но нужно
;  позаботится о том чтобы это число поместилось в заданный размер, например 0i-255 будет не корректно,
;  т.к. в байт можно поместить минимум -127, следовательно под -255 нужно зарезервировать
;  слово (WORD), т.е. нужно написать: 0i-00255
;     Программа работает с 64-разрядными числами, поэтому использование чисел больше 18446744073709551615
;  (для беззнаковых), больше +9223372036854775807 или меньше -9223372036854775808 (для знаковых)
;  приведет к непредсказуемым результатам.

;Шестнадцатиричное число.
;модификатор: 0x, пример:
123456: 454545 0x123456      ;можно юзать для задания 16-ричных чисел размером
;    больше байта в нормальном виде, а не перевернутом. Кол-во байтов, занимаемое
;    числом равно [число символов после 0x] / 2 c округлением в большую сторону.
;    Максимальное число 2^32 (DWORD)

;Строка ASCII.
;строку нужно писать между кавычками - двойными (") или одинарными ('), пример:
123456: 00000000000000000000112233445566   06"© cool hacker"  ; в строке допускаюстя Escape
;     последовательности (\n, \r, \" и т.п.). Кодировка - Windows.
;     Если строка в двойных кавычках - 1 символ будет представлен 1 байтом;
;      если строка в одинарных кавычках - 1 символ будет представлен 2 байтами (UNICODE);
;      в любом случае рекомендуется использовать только цифры, английские буквы, и др. символы,
;      ACSII коды которых меньше 0х80, т.к. символы националных алфавитов могу по разному отображаться
;      на не UNOCODE операционных системах с разной локализацией.
;     Если внутри строки нужно вставить комбинацию символов, соответствующую комментариям
;     ( /* , */ или //), то их нужно разделить символом Ecsape последовательности
;     ( /\* , *\/ или /\/) или поставить символом Ecsape последовательности преде каждым их символом
;     ( \/\* , \*\/ или \/\/) .

;  В старых данных допускается больше байтов чем в новых, т.е. старыми данными как бы указываем
;макс. размер допустимого буффера для новыйх байтов.

;  В старых данных тоже допускаются вышеперечисленные модификаторы и строки.

;  Данные (старые или новые) в одной строке можно группировать (отделять) запятой (она игнорируется),
;например:
123456: 0102030405 1112,13,1415

;  Все модификаторы кроме "" и '' действуют от места их появления до конца данных или до запятой,
;т.о. если в одной строке нужно записать 2 16-ричных числа - отделяйте их запятой, например:
123456: 0102030405060708 11120x0001,0x0002,2345

;   Строку с данными патча можно разбивать, используя символ склеивания строк - '\', например:
123456: 0000000000000000000011223344556677 \
        06"© cool hacker"07   ; комментарий можно только тут.
;символ склеивания можно вставлять только вместо пробелов и сразу после него должен быть
;конец строки - никаких пробелов или комментариев.




;Знакове (беззнаковое) десятичное целое число (integer).
;модификатор: 0i
;пример:
123456: 4546 0i32768
123456: 4546 0i-300
;    Кол-во байтов, занимаемое числом равно числу байт старых данных в соответствующей
; группе байтов. Группы байтов разделяются запятыми, десятичные числа также должны быть
; разделены запятыми. 
;   Использание делятичных чисел в старых данных не допускается.
;   Использование десятичных чисел в строке патча где отсутствуют старые данные не допускается.
;   Перед идентификатором десятичноего числа можно указывать данные, тогда колво байт для
; десятичного числа вычисляется как кол-во байт старых данных в текущей группе минус кол-во
; байт, которые занимают данные перед идентификатором старых данных. Например:
000000: 32302e30,38 ffed0i-300,0i+30
; здесь перед десятичным числом 0i-300 есть 2 байта данных ff и ed, следовательно, т.к.
; старыми данными для этой группы зарезервировано 4 байта (32302e30), то на десятичное
; число 0i-300 остается 4-2 = 2 байта.
; Если же данные перед десятичным числом выделить в отдельную группу (запятой), но десятичное
; число будет занимать все отведенное ему место в группе байтов, а не остаток. Пример:
000000: 3230,2e30,38 ffed,0i-300,0i+30
;   После десятичного числа тоже можно указывать другие данные, отделив их от десятичного
; числа запятой и выделив им место новой группой в старых данных. Например:
000000: 32302e30,38,0000 ffed0i-300,0i+30,12de
; здесь 12de - дополнительные 2 байта данных после десятичного числа,
;       0000 - новая группа в старых данных (перед ней стоит запятая) для дополнительных 2-х байтов.
;ВНИМАНИЕ! переполнение в группах байтов, отделенных запятыми не отслеживается, т.о. если будет:
000000: 32,2e30,38 ffed,0i-300,0i+30
; то результат может быть трудно предсказуемым, т.о. если пользуетесь десятичными числами -
; в старых и новых данных запятых должно быть одинаковое количество и стоять они должны на
; одинаковых позициях (если считать в байтах). Если в строке патча идентификатор десятичного
; числа не используется, то запятые не имеют значения и игнорируются (кроме случаев, описанных
; выше для других идентификаторов).



;в тексте патча можно использовать директивы:

#pragma disable warn_no_old_on_apply	; для последующих блоков данных патча отключается
	;предупреждение о том что блок не содержит старых данных и последующая отмена патча
	;не сможет выполнится полностью.
	; Будет полезна при наличии в патче очень большого куска данных для записи во флеш
	;если еще ко всему прочему старые данные этого блока во флеше трудно предугадать.
	;Например - для баз словарей Т9.
#pragma enable warn_no_old_on_apply	; отменить действие этой директивы

#pragma disable warn_if_new_exist_on_apply	;при применении патча, для последующих блоков
	;данных патча отключается предупреждение от том что старые данные во флеш не найдены,
	;если во флеше уже находятся новые данные.
	; Полезна в случае, если в патче есть данные которые могут уже быть записаны во флеш.
	;Например - патч отключения проверки CRC.
#pragma enable warn_if_new_exist_on_apply	; отменить действие этой директивы

#pragma disable warn_if_old_exist_on_undo	;при отмене патча, для последующих блоков данных
	;патча отключается предупреждение от том что новые данные во флеш не найдены, если во
	;флеше уже находятся старые данные.
#pragma enable warn_if_old_exist_on_undo	; отменить действие этой директивы

#pragma disable undo			; при отмене патча не использовать последущие
	; блоки данных патча.
	; Используйте только в крайних случаях и на тех блоках данных которые 100% ничего не
	;испортят. Например можно использовать на блоках данных патча отключения проверки CRC,
	;т.к. их наличие необходимо многим патчам, а если их отменит один их них, то все остальные
	;патчи работать не будут.
#pragma enable undo			; отменить действие этой директивы

#pragma enable old_equal_ff		; если старые данные не указаны, считать их равными FF.
	; Используется для уменьшения размера файла патча, если в патче есть блоки данных со старыми
	;данными равными FF. При этом такие старые данные можно не указывать и написать перед такими
	;эту директиву.
	;На блоки данных, у которых есть старые данные эта директива не влияет.
#pragma disable old_equal_ff		; отменить действие этой директивы

; !!!Если используете директивы, то обязательно в конце патча отмените их действие, т.к. если кто-нибудь
;будет бездумно склеивать тексты патчей в один патч, то не отмененная директива одного патча будет
;действовать на последующие патчи!!!


; Патч применяется сверху вниз, а отменяется снизу вверх!
; Это сделано для того чтобы корректно происходила отмена перекрывающихся блоков данных патча.
; Например патч:
0e5267: 45e0 2345
0e5267: 23 db
;теперь отменится правильно и без сообщений о не найденных новых данных.